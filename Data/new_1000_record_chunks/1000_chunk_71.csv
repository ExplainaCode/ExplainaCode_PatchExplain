record_number,buggy_code,fixed_code
70001,"/** 
 * @see org.olat.core.gui.components.form.flexible.impl.FormBasicController#initForm(org.olat.core.gui.components.form.flexible.FormItemContainer,org.olat.core.gui.control.Controller,org.olat.core.gui.UserRequest)
 */
@Override protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  htmlElement=uifactory.addRichTextElementForFileData(""String_Node_Str"",null,body,-1,-1,false,baseContainer,fileName,customLinkTreeModel,formLayout,ureq.getUserSession(),getWindowControl());
  RichTextConfiguration editorConfiguration=htmlElement.getEditorConfiguration();
  editorConfiguration.addOnInitCallbackFunction(""String_Node_Str"");
  editorConfiguration.setNonQuotedConfigValue(RichTextConfiguration.HEIGHT,""String_Node_Str"");
  save=uifactory.addFormLink(""String_Node_Str"",formLayout,Link.BUTTON);
  save.addActionListener(this,FormEvent.ONCLICK);
  cancel=uifactory.addFormLink(""String_Node_Str"",formLayout,Link.BUTTON);
  cancel.addActionListener(this,FormEvent.ONCLICK);
  saveClose=uifactory.addFormLink(""String_Node_Str"",formLayout,Link.BUTTON);
  saveClose.addActionListener(this,FormEvent.ONCLICK);
  VelocityContainer vc=(VelocityContainer)formLayout.getComponent();
  metadataVC=createVelocityContainer(""String_Node_Str"");
  vc.put(""String_Node_Str"",metadataVC);
  long lm=fileLeaf.getLastModified();
  metadataVC.contextPut(""String_Node_Str"",Formatter.getInstance(ureq.getLocale()).formatDateAndTime(new Date(lm)));
  metadataVC.contextPut(""String_Node_Str"",charSet);
  metadataVC.contextPut(""String_Node_Str"",fileName);
}","/** 
 * @see org.olat.core.gui.components.form.flexible.impl.FormBasicController#initForm(org.olat.core.gui.components.form.flexible.FormItemContainer,org.olat.core.gui.control.Controller,org.olat.core.gui.UserRequest)
 */
@Override protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  if (fileToLargeError != null) {
    VelocityContainer vc=(VelocityContainer)formLayout.getComponent();
    vc.contextPut(""String_Node_Str"",fileToLargeError);
  }
 else {
    htmlElement=uifactory.addRichTextElementForFileData(""String_Node_Str"",null,body,-1,-1,false,baseContainer,fileName,customLinkTreeModel,formLayout,ureq.getUserSession(),getWindowControl());
    RichTextConfiguration editorConfiguration=htmlElement.getEditorConfiguration();
    editorConfiguration.addOnInitCallbackFunction(""String_Node_Str"");
    editorConfiguration.setNonQuotedConfigValue(RichTextConfiguration.HEIGHT,""String_Node_Str"");
    save=uifactory.addFormLink(""String_Node_Str"",formLayout,Link.BUTTON);
    save.addActionListener(this,FormEvent.ONCLICK);
    cancel=uifactory.addFormLink(""String_Node_Str"",formLayout,Link.BUTTON);
    cancel.addActionListener(this,FormEvent.ONCLICK);
    saveClose=uifactory.addFormLink(""String_Node_Str"",formLayout,Link.BUTTON);
    saveClose.addActionListener(this,FormEvent.ONCLICK);
    VelocityContainer vc=(VelocityContainer)formLayout.getComponent();
    metadataVC=createVelocityContainer(""String_Node_Str"");
    vc.put(""String_Node_Str"",metadataVC);
    long lm=fileLeaf.getLastModified();
    metadataVC.contextPut(""String_Node_Str"",Formatter.getInstance(ureq.getLocale()).formatDateAndTime(new Date(lm)));
    metadataVC.contextPut(""String_Node_Str"",charSet);
    metadataVC.contextPut(""String_Node_Str"",fileName);
  }
}"
70002,"/** 
 * Factory method to create a file based HTML editor instance that uses locking to prevent two people editing the same file.
 * @param ureq
 * @param wControl
 * @param baseContainer the baseContainer (below that folder all images can be chosen)
 * @param relFilePath the file e.g. ""index.html""
 * @param userActivityLogger the userActivity Logger if used
 * @param customLinkTreeModel Model for internal-link tree e.g. course-node tree with link information
 * @param editorCheckEnabled true: check if file has been created with another tool and warn user about potential data loss; false: ignore other authoring tools
 * @return Controller with internal-link selector
 */
protected HTMLEditorController(UserRequest ureq,WindowControl wControl,VFSContainer baseContainer,String relFilePath,CustomLinkTreeModel customLinkTreeModel,boolean editorCheckEnabled){
  super(ureq,wControl,""String_Node_Str"");
  this.baseContainer=baseContainer;
  this.fileRelPath=relFilePath;
  this.customLinkTreeModel=customLinkTreeModel;
  this.editorCheckEnabled=editorCheckEnabled;
  this.fileName=((relFilePath.charAt(0) == '/') ? relFilePath.substring(1) : relFilePath);
  this.fileLeaf=(VFSLeaf)baseContainer.resolve(fileName);
  if (fileLeaf == null)   throw new AssertException(""String_Node_Str"" + getFileDebuggingPath(baseContainer,relFilePath) + ""String_Node_Str"");
  long size=fileLeaf.getSize();
  if (size > FolderConfig.getMaxEditSizeLimit()) {
    setTranslator(Util.createPackageTranslator(PlainTextEditorController.class,getLocale(),getTranslator()));
    getWindowControl().setError(translate(""String_Node_Str"",new String[]{(size / 1000) + ""String_Node_Str"",(FolderConfig.getMaxEditSizeLimit() / 1000) + ""String_Node_Str""}));
    this.body=""String_Node_Str"";
    this.editable=false;
    return;
  }
  if (fileLeaf instanceof LocalFileImpl) {
    OLATResourceable lockResourceable=OresHelper.createOLATResourceableTypeWithoutCheck(fileLeaf.toString());
    String lockToken=Encoder.encrypt(getFileDebuggingPath(baseContainer,relFilePath));
    this.lock=CoordinatorManager.getInstance().getCoordinator().getLocker().acquireLock(lockResourceable,ureq.getIdentity(),lockToken);
    VelocityContainer vc=(VelocityContainer)flc.getComponent();
    if (!lock.isSuccess()) {
      vc.contextPut(""String_Node_Str"",Boolean.TRUE);
      vc.contextPut(""String_Node_Str"",lock.getOwner().getName());
      this.editable=false;
      return;
    }
 else {
      vc.contextPut(""String_Node_Str"",Boolean.FALSE);
    }
  }
  this.body=parsePage(fileLeaf);
  initForm(ureq);
}","/** 
 * Factory method to create a file based HTML editor instance that uses locking to prevent two people editing the same file.
 * @param ureq
 * @param wControl
 * @param baseContainer the baseContainer (below that folder all images can be chosen)
 * @param relFilePath the file e.g. ""index.html""
 * @param userActivityLogger the userActivity Logger if used
 * @param customLinkTreeModel Model for internal-link tree e.g. course-node tree with link information
 * @param editorCheckEnabled true: check if file has been created with another tool and warn user about potential data loss; false: ignore other authoring tools
 * @return Controller with internal-link selector
 */
protected HTMLEditorController(UserRequest ureq,WindowControl wControl,VFSContainer baseContainer,String relFilePath,CustomLinkTreeModel customLinkTreeModel,boolean editorCheckEnabled){
  super(ureq,wControl,""String_Node_Str"");
  this.baseContainer=baseContainer;
  this.fileRelPath=relFilePath;
  this.customLinkTreeModel=customLinkTreeModel;
  this.editorCheckEnabled=editorCheckEnabled;
  this.fileName=((relFilePath.charAt(0) == '/') ? relFilePath.substring(1) : relFilePath);
  this.fileLeaf=(VFSLeaf)baseContainer.resolve(fileName);
  if (fileLeaf == null)   throw new AssertException(""String_Node_Str"" + getFileDebuggingPath(baseContainer,relFilePath) + ""String_Node_Str"");
  long size=fileLeaf.getSize();
  if (size > FolderConfig.getMaxEditSizeLimit()) {
    setTranslator(Util.createPackageTranslator(PlainTextEditorController.class,getLocale(),getTranslator()));
    fileToLargeError=translate(""String_Node_Str"",new String[]{(size / 1000) + ""String_Node_Str"",(FolderConfig.getMaxEditSizeLimit() / 1000) + ""String_Node_Str""});
    this.body=""String_Node_Str"";
    this.editable=false;
    initForm(ureq);
    return;
  }
  if (fileLeaf instanceof LocalFileImpl) {
    OLATResourceable lockResourceable=OresHelper.createOLATResourceableTypeWithoutCheck(fileLeaf.toString());
    String lockToken=Encoder.encrypt(getFileDebuggingPath(baseContainer,relFilePath));
    this.lock=CoordinatorManager.getInstance().getCoordinator().getLocker().acquireLock(lockResourceable,ureq.getIdentity(),lockToken);
    VelocityContainer vc=(VelocityContainer)flc.getComponent();
    if (!lock.isSuccess()) {
      vc.contextPut(""String_Node_Str"",Boolean.TRUE);
      vc.contextPut(""String_Node_Str"",lock.getOwner().getName());
      this.editable=false;
      return;
    }
 else {
      vc.contextPut(""String_Node_Str"",Boolean.FALSE);
    }
  }
  this.body=parsePage(fileLeaf);
  initForm(ureq);
}"
70003,"@Override protected boolean validateFormLogic(UserRequest ureq){
  boolean allOk=true;
  String whiteList=domainListElement.getValue();
  domainListElement.clearError();
  if (StringHelper.containsNonWhitespace(whiteList)) {
    List<String> normalizedList=registrationModule.getDomainList(whiteList);
    List<String> errors=registrationManager.validateWhiteList(normalizedList);
    if (!errors.isEmpty()) {
      StringBuilder sb=new StringBuilder();
      for (      String error : errors) {
        if (sb.length() > 0)         sb.append(""String_Node_Str"");
        sb.append(error);
      }
      domainListElement.setErrorKey(""String_Node_Str"",new String[]{sb.toString()});
      allOk&=false;
    }
  }
  if (staticPropElement.isSelected(0)) {
    if (propertyElement.isOneSelected()) {
      String propertyName=propertyElement.getSelectedKey();
      String value=propertyValueElement.getValue();
      UserPropertyHandler handler=userPropertiesConfig.getPropertyHandler(propertyName);
      ValidationError validationError=new ValidationError();
      boolean valid=handler.isValidValue(value,validationError,getLocale());
      if (!valid) {
        String errorKey=validationError.getErrorKey();
        if (errorKey == null) {
          propertyValueElement.setErrorKey(""String_Node_Str"",null);
        }
 else {
          propertyValueElement.setErrorKey(errorKey,null);
        }
      }
    }
  }
  return allOk && super.validateFormLogic(ureq);
}","@Override protected boolean validateFormLogic(UserRequest ureq){
  boolean allOk=true;
  String whiteList=domainListElement.getValue();
  domainListElement.clearError();
  if (StringHelper.containsNonWhitespace(whiteList)) {
    List<String> normalizedList=registrationModule.getDomainList(whiteList);
    List<String> errors=registrationManager.validateWhiteList(normalizedList);
    if (!errors.isEmpty()) {
      StringBuilder sb=new StringBuilder();
      for (      String error : errors) {
        if (sb.length() > 0)         sb.append(""String_Node_Str"");
        sb.append(error);
      }
      domainListElement.setErrorKey(""String_Node_Str"",new String[]{sb.toString()});
      allOk&=false;
    }
  }
  if (staticPropElement.isSelected(0)) {
    if (propertyElement.isOneSelected()) {
      String propertyName=propertyElement.getSelectedKey();
      String value=propertyValueElement.getValue();
      UserPropertyHandler handler=userPropertiesConfig.getPropertyHandler(propertyName);
      ValidationError validationError=new ValidationError();
      boolean valid=handler.isValidValue(value,validationError,getLocale());
      if (!valid) {
        propertyValueElement.setErrorKey(""String_Node_Str"",null);
        allOk&=false;
      }
    }
  }
  return allOk && super.validateFormLogic(ureq);
}"
70004,"public RegistrationAdminController(UserRequest ureq,WindowControl wControl){
  super(ureq,wControl,""String_Node_Str"");
  registrationModule=CoreSpringFactory.getImpl(RegistrationModule.class);
  registrationManager=CoreSpringFactory.getImpl(RegistrationManager.class);
  userPropertiesConfig=CoreSpringFactory.getImpl(UserPropertiesConfig.class);
  setTranslator(userPropertiesConfig.getTranslator(getTranslator()));
  enableRegistrationValues[0]=translate(""String_Node_Str"");
  List<UserPropertyHandler> allPropertyHandlers=userPropertiesConfig.getAllUserPropertyHandlers();
  List<UserPropertyHandler> propertyHandlers=new ArrayList<UserPropertyHandler>(allPropertyHandlers.size());
  for (  UserPropertyHandler handler : allPropertyHandlers) {
    if (handler instanceof Generic127CharTextPropertyHandler) {
      propertyHandlers.add(handler);
    }
  }
  propertyKeys=new String[propertyHandlers.size() + 1];
  propertyValues=new String[propertyHandlers.size() + 1];
  int count=0;
  propertyKeys[0]=""String_Node_Str"";
  propertyValues[0]=""String_Node_Str"";
  for (  UserPropertyHandler propertyHandler : propertyHandlers) {
    propertyKeys[1 + count]=propertyHandler.getName();
    propertyValues[1 + count++]=translate(propertyHandler.i18nFormElementLabelKey());
  }
  initForm(ureq);
}","public RegistrationAdminController(UserRequest ureq,WindowControl wControl){
  super(ureq,wControl,""String_Node_Str"");
  registrationModule=CoreSpringFactory.getImpl(RegistrationModule.class);
  registrationManager=CoreSpringFactory.getImpl(RegistrationManager.class);
  userPropertiesConfig=CoreSpringFactory.getImpl(UserPropertiesConfig.class);
  userPropTranslator=userPropertiesConfig.getTranslator(getTranslator());
  enableRegistrationValues[0]=translate(""String_Node_Str"");
  List<UserPropertyHandler> allPropertyHandlers=userPropertiesConfig.getAllUserPropertyHandlers();
  List<UserPropertyHandler> propertyHandlers=new ArrayList<UserPropertyHandler>(allPropertyHandlers.size());
  for (  UserPropertyHandler handler : allPropertyHandlers) {
    if (handler instanceof Generic127CharTextPropertyHandler) {
      propertyHandlers.add(handler);
    }
  }
  propertyKeys=new String[propertyHandlers.size() + 1];
  propertyValues=new String[propertyHandlers.size() + 1];
  int count=0;
  propertyKeys[0]=""String_Node_Str"";
  propertyValues[0]=""String_Node_Str"";
  for (  UserPropertyHandler propertyHandler : propertyHandlers) {
    propertyKeys[1 + count]=propertyHandler.getName();
    propertyValues[1 + count++]=userPropTranslator.translate(propertyHandler.i18nFormElementLabelKey());
  }
  initForm(ureq);
}"
70005,"protected void initSelectionElements(){
  boolean createValues=(values == null) || (values.length == 0);
  if (createValues) {
    values=new String[keys.length];
    for (int i=0; i < keys.length; i++) {
      values[i]=translator.translate(keys[i]);
    }
  }
  String[] items=new String[keys.length];
  for (int i=0; i < keys.length; i++) {
    CheckboxElementComponent ssec=new CheckboxElementComponent(getName() + ""String_Node_Str"" + keys[i],translator,this,i,(cssClasses == null ? null : cssClasses[i]));
    formLayoutContainer.put(getName() + ""String_Node_Str"" + keys[i],ssec);
    items[i]=getName() + ""String_Node_Str"" + keys[i];
    if (GUIInterna.isLoadPerformanceMode()) {
      if (getRootForm() != null) {
        getRootForm().getReplayableDispatchID(ssec);
      }
    }
  }
  SelectboxComponent sssc=new SelectboxComponent(getFormItemId() + ""String_Node_Str"",getName() + ""String_Node_Str"",translator,this,keys,values,cssClasses);
  formLayoutContainer.put(getName() + ""String_Node_Str"",sssc);
  formLayoutContainer.contextPut(""String_Node_Str"",getName() + ""String_Node_Str"");
  formLayoutContainer.contextPut(""String_Node_Str"",items);
  formLayoutContainer.contextPut(""String_Node_Str"",items.length);
  formLayoutContainer.setDirty(true);
}","protected void initSelectionElements(){
  boolean createValues=(values == null) || (values.length == 0);
  if (createValues) {
    values=new String[keys.length];
    for (int i=0; i < keys.length; i++) {
      values[i]=translator.translate(keys[i]);
    }
  }
  String[] items=new String[keys.length];
  for (int i=0; i < keys.length; i++) {
    CheckboxElementComponent ssec=new CheckboxElementComponent(getName() + ""String_Node_Str"" + keys[i],translator,this,i,(cssClasses == null ? null : cssClasses[i]));
    formLayoutContainer.put(getName() + ""String_Node_Str"" + keys[i],ssec);
    items[i]=getName() + ""String_Node_Str"" + keys[i];
    if (GUIInterna.isLoadPerformanceMode()) {
      if (getRootForm() != null) {
        getRootForm().getReplayableDispatchID(ssec);
      }
    }
  }
  String ssscId=getFormItemId() == null ? null : getFormItemId() + ""String_Node_Str"";
  SelectboxComponent sssc=new SelectboxComponent(ssscId,getName() + ""String_Node_Str"",translator,this,keys,values,cssClasses);
  formLayoutContainer.put(getName() + ""String_Node_Str"",sssc);
  formLayoutContainer.contextPut(""String_Node_Str"",getName() + ""String_Node_Str"");
  formLayoutContainer.contextPut(""String_Node_Str"",items);
  formLayoutContainer.contextPut(""String_Node_Str"",items.length);
  formLayoutContainer.setDirty(true);
}"
70006,"private void initSelectionElements(){
  boolean createValues=(values == null) || (values.length == 0);
  if (createValues) {
    values=new String[keys.length];
    for (int i=0; i < keys.length; i++) {
      values[i]=translator.translate(keys[i]);
    }
  }
  String[] items=new String[keys.length];
  for (int i=0; i < keys.length; i++) {
    RadioElementComponent ssec=new RadioElementComponent(getName() + ""String_Node_Str"" + keys[i],translator,this,i);
    formLayoutContainer.put(getName() + ""String_Node_Str"" + keys[i],ssec);
    items[i]=getName() + ""String_Node_Str"" + keys[i];
    if (GUIInterna.isLoadPerformanceMode()) {
      getRootForm().getReplayableDispatchID(ssec);
    }
  }
  SelectboxComponent sssc=new SelectboxComponent(getFormItemId() + ""String_Node_Str"",getName() + ""String_Node_Str"",translator,this,keys,values,cssClasses);
  formLayoutContainer.put(getName() + ""String_Node_Str"",sssc);
  formLayoutContainer.contextPut(""String_Node_Str"",getName() + ""String_Node_Str"");
  formLayoutContainer.contextPut(""String_Node_Str"",items);
}","private void initSelectionElements(){
  boolean createValues=(values == null) || (values.length == 0);
  if (createValues) {
    values=new String[keys.length];
    for (int i=0; i < keys.length; i++) {
      values[i]=translator.translate(keys[i]);
    }
  }
  String[] items=new String[keys.length];
  for (int i=0; i < keys.length; i++) {
    RadioElementComponent ssec=new RadioElementComponent(getName() + ""String_Node_Str"" + keys[i],translator,this,i);
    formLayoutContainer.put(getName() + ""String_Node_Str"" + keys[i],ssec);
    items[i]=getName() + ""String_Node_Str"" + keys[i];
    if (GUIInterna.isLoadPerformanceMode()) {
      getRootForm().getReplayableDispatchID(ssec);
    }
  }
  String ssscId=getFormItemId() == null ? null : getFormItemId() + ""String_Node_Str"";
  SelectboxComponent sssc=new SelectboxComponent(ssscId,getName() + ""String_Node_Str"",translator,this,keys,values,cssClasses);
  formLayoutContainer.put(getName() + ""String_Node_Str"",sssc);
  formLayoutContainer.contextPut(""String_Node_Str"",getName() + ""String_Node_Str"");
  formLayoutContainer.contextPut(""String_Node_Str"",items);
}"
70007,"private void init(UserRequest ureq,Identity statementOwner,BusinessGroup group,boolean mainLayout){
  setTranslator(UserManager.getInstance().getPropertyHandlerTranslator(getTranslator()));
  userDataVC=createVelocityContainer(""String_Node_Str"");
  if (efficiencyStatement != null) {
    userDataVC.contextPut(""String_Node_Str"",efficiencyStatement.getCourseTitle() + ""String_Node_Str"" + efficiencyStatement.getCourseRepoEntryKey().toString()+ ""String_Node_Str"");
    courseLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
    courseLink.setCustomEnabledLinkCSS(""String_Node_Str"");
    userDataVC.put(""String_Node_Str"",courseLink);
    userDataVC.contextPut(""String_Node_Str"",StringHelper.formatLocaleDateTime(efficiencyStatement.getLastUpdated(),ureq.getLocale()));
  }
  userDataVC.contextPut(""String_Node_Str"",statementOwner.getUser());
  userDataVC.contextPut(""String_Node_Str"",statementOwner.getName());
  Roles roles=ureq.getUserSession().getRoles();
  boolean isAdministrativeUser=(roles.isAuthor() || roles.isGroupManager() || roles.isUserManager()|| roles.isOLATAdmin());
  List<UserPropertyHandler> userPropertyHandlers=UserManager.getInstance().getUserPropertyHandlersFor(usageIdentifyer,isAdministrativeUser);
  userDataVC.contextPut(""String_Node_Str"",userPropertyHandlers);
  if (!getIdentity().equals(statementOwner)) {
    homeLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
    homeLink.setCustomEnabledLinkCSS(""String_Node_Str"");
    userDataVC.put(""String_Node_Str"",homeLink);
    contactLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
    contactLink.setCustomEnabledLinkCSS(""String_Node_Str"");
    userDataVC.put(""String_Node_Str"",contactLink);
  }
  if (group != null) {
    userDataVC.contextPut(""String_Node_Str"",group.getName());
    groupLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
    groupLink.setCustomEnabledLinkCSS(""String_Node_Str"");
    userDataVC.put(""String_Node_Str"",groupLink);
  }
  if (efficiencyStatement != null) {
    Controller identityAssessmentCtr=new IdentityAssessmentOverviewController(ureq,getWindowControl(),efficiencyStatement.getAssessmentNodes());
    listenTo(identityAssessmentCtr);
    userDataVC.put(""String_Node_Str"",identityAssessmentCtr.getInitialComponent());
    if (statementOwner.equals(ureq.getIdentity())) {
      portfolioModule=(PortfolioModule)CoreSpringFactory.getBean(""String_Node_Str"");
      EPArtefactHandler<?> artHandler=portfolioModule.getArtefactHandler(EfficiencyStatementArtefact.ARTEFACT_TYPE);
      if (portfolioModule.isEnabled() && artHandler != null && artHandler.isEnabled()) {
        collectArtefactLink=LinkFactory.createCustomLink(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Link.NONTRANSLATED,userDataVC,this);
        collectArtefactLink.setCustomEnabledLinkCSS(""String_Node_Str"");
      }
    }
  }
 else {
    String text=translate(""String_Node_Str"");
    Controller messageCtr=MessageUIFactory.createSimpleMessage(ureq,getWindowControl(),text);
    listenTo(messageCtr);
    userDataVC.put(""String_Node_Str"",messageCtr.getInitialComponent());
  }
  if (mainLayout) {
    LayoutMain3ColsController layoutCtr=new LayoutMain3ColsController(ureq,getWindowControl(),null,null,userDataVC,null);
    listenTo(layoutCtr);
    putInitialPanel(layoutCtr.getInitialComponent());
  }
 else {
    putInitialPanel(userDataVC);
  }
}","private void init(UserRequest ureq,Identity statementOwner,RepositoryEntry courseRepo,BusinessGroup group,boolean links,boolean mainLayout){
  setTranslator(UserManager.getInstance().getPropertyHandlerTranslator(getTranslator()));
  userDataVC=createVelocityContainer(""String_Node_Str"");
  if (efficiencyStatement != null) {
    userDataVC.contextPut(""String_Node_Str"",efficiencyStatement.getCourseTitle());
    userDataVC.contextPut(""String_Node_Str"",StringHelper.formatLocaleDateTime(efficiencyStatement.getLastUpdated(),ureq.getLocale()));
  }
 else   if (courseRepo != null) {
    userDataVC.contextPut(""String_Node_Str"",courseRepo.getDisplayname());
  }
  if (courseRepoKey != null && links) {
    courseLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
    courseLink.setCustomEnabledLinkCSS(""String_Node_Str"");
    userDataVC.put(""String_Node_Str"",courseLink);
  }
  userDataVC.contextPut(""String_Node_Str"",statementOwner.getUser());
  userDataVC.contextPut(""String_Node_Str"",statementOwner.getName());
  Roles roles=ureq.getUserSession().getRoles();
  boolean isAdministrativeUser=(roles.isAuthor() || roles.isGroupManager() || roles.isUserManager()|| roles.isOLATAdmin());
  List<UserPropertyHandler> userPropertyHandlers=UserManager.getInstance().getUserPropertyHandlersFor(usageIdentifyer,isAdministrativeUser);
  userDataVC.contextPut(""String_Node_Str"",userPropertyHandlers);
  if (!getIdentity().equals(statementOwner) && links) {
    homeLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
    homeLink.setCustomEnabledLinkCSS(""String_Node_Str"");
    userDataVC.put(""String_Node_Str"",homeLink);
    contactLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
    contactLink.setCustomEnabledLinkCSS(""String_Node_Str"");
    userDataVC.put(""String_Node_Str"",contactLink);
  }
  if (group != null) {
    userDataVC.contextPut(""String_Node_Str"",group.getName());
    if (links) {
      groupLink=LinkFactory.createButton(""String_Node_Str"",userDataVC,this);
      groupLink.setCustomEnabledLinkCSS(""String_Node_Str"");
      userDataVC.put(""String_Node_Str"",groupLink);
    }
  }
  if (efficiencyStatement != null) {
    Controller identityAssessmentCtr=new IdentityAssessmentOverviewController(ureq,getWindowControl(),efficiencyStatement.getAssessmentNodes());
    listenTo(identityAssessmentCtr);
    userDataVC.put(""String_Node_Str"",identityAssessmentCtr.getInitialComponent());
    if (statementOwner.equals(ureq.getIdentity())) {
      portfolioModule=(PortfolioModule)CoreSpringFactory.getBean(""String_Node_Str"");
      EPArtefactHandler<?> artHandler=portfolioModule.getArtefactHandler(EfficiencyStatementArtefact.ARTEFACT_TYPE);
      if (portfolioModule.isEnabled() && artHandler != null && artHandler.isEnabled()) {
        collectArtefactLink=LinkFactory.createCustomLink(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",Link.NONTRANSLATED,userDataVC,this);
        collectArtefactLink.setCustomEnabledLinkCSS(""String_Node_Str"");
      }
    }
  }
 else {
    String text=translate(""String_Node_Str"");
    Controller messageCtr=MessageUIFactory.createSimpleMessage(ureq,getWindowControl(),text);
    listenTo(messageCtr);
    userDataVC.put(""String_Node_Str"",messageCtr.getInitialComponent());
  }
  if (mainLayout) {
    LayoutMain3ColsController layoutCtr=new LayoutMain3ColsController(ureq,getWindowControl(),null,null,userDataVC,null);
    listenTo(layoutCtr);
    putInitialPanel(layoutCtr.getInitialComponent());
  }
 else {
    putInitialPanel(userDataVC);
  }
}"
70008,"private void openCourse(UserRequest ureq){
  List<ContextEntry> ces=new ArrayList<ContextEntry>(1);
  OLATResourceable ores=OresHelper.createOLATResourceableInstance(""String_Node_Str"",efficiencyStatement.getCourseRepoEntryKey());
  ces.add(BusinessControlFactory.getInstance().createContextEntry(ores));
  BusinessControl bc=BusinessControlFactory.getInstance().createFromContextEntries(ces);
  WindowControl bwControl=BusinessControlFactory.getInstance().createBusinessWindowControl(bc,getWindowControl());
  NewControllerFactory.getInstance().launch(ureq,bwControl);
}","private void openCourse(UserRequest ureq){
  List<ContextEntry> ces=new ArrayList<ContextEntry>(1);
  OLATResourceable ores=OresHelper.createOLATResourceableInstance(""String_Node_Str"",courseRepoKey);
  ces.add(BusinessControlFactory.getInstance().createContextEntry(ores));
  BusinessControl bc=BusinessControlFactory.getInstance().createFromContextEntries(ces);
  WindowControl bwControl=BusinessControlFactory.getInstance().createBusinessWindowControl(bc,getWindowControl());
  NewControllerFactory.getInstance().launch(ureq,bwControl);
}"
70009,"public EfficiencyStatementController(WindowControl wControl,UserRequest ureq,Identity statementOwner,BusinessGroup businessGroup,EfficiencyStatement efficiencyStatement,boolean mainLayout){
  super(ureq,wControl);
  this.businessGroupKey=businessGroup == null ? null : businessGroup.getKey();
  this.statementOwner=statementOwner;
  this.efficiencyStatement=efficiencyStatement;
  init(ureq,statementOwner,businessGroup,true);
}","public EfficiencyStatementController(WindowControl wControl,UserRequest ureq,Identity statementOwner,BusinessGroup businessGroup,RepositoryEntry courseRepo,EfficiencyStatement efficiencyStatement,boolean links,boolean mainLayout){
  super(ureq,wControl);
  this.courseRepoKey=courseRepo == null ? (efficiencyStatement == null ? null : efficiencyStatement.getCourseRepoEntryKey()) : courseRepo.getKey();
  if (courseRepo == null && courseRepoKey != null) {
    courseRepo=RepositoryManager.getInstance().lookupRepositoryEntry(courseRepoKey,false);
  }
  if (businessGroup == null && courseRepo != null) {
    ICourse course=CourseFactory.loadCourse(courseRepo.getOlatResource());
    List<BusinessGroup> groups=course.getCourseEnvironment().getCourseGroupManager().getParticipatingLearningGroupsFromAllContexts(statementOwner);
    if (groups.size() > 0) {
      businessGroup=groups.get(0);
    }
  }
  this.businessGroupKey=businessGroup == null ? null : businessGroup.getKey();
  this.statementOwner=statementOwner;
  this.efficiencyStatement=efficiencyStatement;
  init(ureq,statementOwner,courseRepo,businessGroup,links,true);
}"
70010,"/** 
 * Updates the users efficiency statement for this course
 * @param userCourseEnv
 * @param repoEntryKey
 * @param checkForExistingProperty
 */
private void updateUserEfficiencyStatement(final UserCourseEnvironment userCourseEnv,final Long repoEntryKey,ICourse course,final boolean checkForExistingProperty){
  CourseConfig cc=userCourseEnv.getCourseEnvironment().getCourseConfig();
  if (cc.isEfficencyStatementEnabled()) {
    Identity identity=userCourseEnv.getIdentityEnvironment().getIdentity();
    CourseNode rootNode=userCourseEnv.getCourseEnvironment().getRunStructure().getRootNode();
    List<Map<String,Object>> assessmentNodes=AssessmentHelper.addAssessableNodeAndDataToList(0,rootNode,userCourseEnv,true,true);
    EfficiencyStatement efficiencyStatement=new EfficiencyStatement();
    efficiencyStatement.setAssessmentNodes(assessmentNodes);
    efficiencyStatement.setCourseTitle(userCourseEnv.getCourseEnvironment().getCourseTitle());
    efficiencyStatement.setCourseRepoEntryKey(repoEntryKey);
    User user=identity.getUser();
    efficiencyStatement.setDisplayableUserInfo(user.getProperty(UserConstants.FIRSTNAME,null) + ""String_Node_Str"" + user.getProperty(UserConstants.LASTNAME,null)+ ""String_Node_Str""+ identity.getName()+ ""String_Node_Str"");
    efficiencyStatement.setLastUpdated(System.currentTimeMillis());
    UserEfficiencyStatementImpl efficiencyProperty=null;
    if (checkForExistingProperty) {
      efficiencyProperty=getUserEfficiencyStatementFull(repoEntryKey,identity);
    }
    if (assessmentNodes != null) {
      if (efficiencyProperty == null) {
        efficiencyProperty=new UserEfficiencyStatementImpl();
        efficiencyProperty.setIdentity(identity);
        efficiencyProperty.setCourseRepoKey(repoEntryKey);
        RepositoryEntry re=repositoryManager.lookupRepositoryEntry(repoEntryKey,false);
        if (re != null) {
          efficiencyProperty.setResource(re.getOlatResource());
        }
        fillEfficiencyStatement(efficiencyStatement,efficiencyProperty);
        dbInstance.saveObject(efficiencyProperty);
        if (isLogDebugEnabled()) {
          logDebug(""String_Node_Str"" + efficiencyProperty.getKey() + ""String_Node_Str""+ identity.getName()+ ""String_Node_Str""+ repoEntryKey);
        }
      }
 else {
        if (isLogDebugEnabled()) {
          logDebug(""String_Node_Str"" + efficiencyProperty.getKey() + ""String_Node_Str""+ identity.getName()+ ""String_Node_Str""+ repoEntryKey);
        }
        fillEfficiencyStatement(efficiencyStatement,efficiencyProperty);
        dbInstance.updateObject(efficiencyProperty);
      }
    }
 else {
      if (efficiencyProperty != null) {
        if (isLogDebugEnabled()) {
          logDebug(""String_Node_Str"" + efficiencyProperty.getKey() + ""String_Node_Str""+ identity.getName()+ ""String_Node_Str""+ repoEntryKey+ ""String_Node_Str"");
        }
        dbInstance.deleteObject(efficiencyProperty);
      }
    }
    AssessmentChangedEvent ace=new AssessmentChangedEvent(AssessmentChangedEvent.TYPE_EFFICIENCY_STATEMENT_CHANGED,identity);
    CoordinatorManager.getInstance().getCoordinator().getEventBus().fireEventToListenersOf(ace,course);
  }
}","/** 
 * Updates the users efficiency statement for this course
 * @param userCourseEnv
 * @param repoEntryKey
 * @param checkForExistingProperty
 */
private void updateUserEfficiencyStatement(final UserCourseEnvironment userCourseEnv,final Long repoEntryKey,ICourse course,final boolean checkForExistingProperty){
  CourseConfig cc=userCourseEnv.getCourseEnvironment().getCourseConfig();
  if (cc.isEfficencyStatementEnabled()) {
    Identity identity=userCourseEnv.getIdentityEnvironment().getIdentity();
    CourseNode rootNode=userCourseEnv.getCourseEnvironment().getRunStructure().getRootNode();
    List<Map<String,Object>> assessmentNodes=AssessmentHelper.addAssessableNodeAndDataToList(0,rootNode,userCourseEnv,true,true);
    EfficiencyStatement efficiencyStatement=new EfficiencyStatement();
    efficiencyStatement.setAssessmentNodes(assessmentNodes);
    efficiencyStatement.setCourseTitle(userCourseEnv.getCourseEnvironment().getCourseTitle());
    efficiencyStatement.setCourseRepoEntryKey(repoEntryKey);
    User user=identity.getUser();
    efficiencyStatement.setDisplayableUserInfo(user.getProperty(UserConstants.FIRSTNAME,null) + ""String_Node_Str"" + user.getProperty(UserConstants.LASTNAME,null)+ ""String_Node_Str""+ identity.getName()+ ""String_Node_Str"");
    efficiencyStatement.setLastUpdated(System.currentTimeMillis());
    UserEfficiencyStatementImpl efficiencyProperty=null;
    if (checkForExistingProperty) {
      efficiencyProperty=getUserEfficiencyStatementFull(repoEntryKey,identity);
    }
    if (assessmentNodes != null) {
      if (efficiencyProperty == null) {
        efficiencyProperty=new UserEfficiencyStatementImpl();
        efficiencyProperty.setIdentity(identity);
        efficiencyProperty.setCourseRepoKey(repoEntryKey);
        RepositoryEntry re=repositoryManager.lookupRepositoryEntry(repoEntryKey,false);
        if (re != null) {
          efficiencyProperty.setResource(re.getOlatResource());
          efficiencyProperty.setCourseRepoKey(re.getKey());
        }
        fillEfficiencyStatement(efficiencyStatement,efficiencyProperty);
        dbInstance.saveObject(efficiencyProperty);
        if (isLogDebugEnabled()) {
          logDebug(""String_Node_Str"" + efficiencyProperty.getKey() + ""String_Node_Str""+ identity.getName()+ ""String_Node_Str""+ repoEntryKey);
        }
      }
 else {
        if (isLogDebugEnabled()) {
          logDebug(""String_Node_Str"" + efficiencyProperty.getKey() + ""String_Node_Str""+ identity.getName()+ ""String_Node_Str""+ repoEntryKey);
        }
        fillEfficiencyStatement(efficiencyStatement,efficiencyProperty);
        dbInstance.updateObject(efficiencyProperty);
      }
    }
 else {
      if (efficiencyProperty != null) {
        if (isLogDebugEnabled()) {
          logDebug(""String_Node_Str"" + efficiencyProperty.getKey() + ""String_Node_Str""+ identity.getName()+ ""String_Node_Str""+ repoEntryKey+ ""String_Node_Str"");
        }
        dbInstance.deleteObject(efficiencyProperty);
      }
    }
    AssessmentChangedEvent ace=new AssessmentChangedEvent(AssessmentChangedEvent.TYPE_EFFICIENCY_STATEMENT_CHANGED,identity);
    CoordinatorManager.getInstance().getCoordinator().getEventBus().fireEventToListenersOf(ace,course);
  }
}"
70011,"private void createStatement(Property property){
  String repoKeyStr=property.getName();
  Long repoKey=new Long(repoKeyStr);
  RepositoryEntry re=repositoryManager.lookupRepositoryEntry(repoKey,false);
  UserEfficiencyStatementImpl impl=efficiencyStatementManager.getUserEfficiencyStatementFull(repoKey,property.getIdentity());
  if (impl != null) {
    return;
  }
  UserEfficiencyStatementImpl statement=new UserEfficiencyStatementImpl();
  statement.setIdentity(property.getIdentity());
  statement.setStatementXml(property.getTextValue());
  if (re != null) {
    statement.setResource(re.getOlatResource());
  }
  EfficiencyStatement s=(EfficiencyStatement)XStreamHelper.createXStreamInstance().fromXML(property.getTextValue());
  efficiencyStatementManager.fillEfficiencyStatement(s,statement);
  statement.setLastModified(property.getLastModified());
  dbInstance.saveObject(statement);
  dbInstance.commitAndCloseSession();
}","private void createStatement(Property property){
  String repoKeyStr=property.getName();
  Long repoKey=new Long(repoKeyStr);
  RepositoryEntry re=repositoryManager.lookupRepositoryEntry(repoKey,false);
  UserEfficiencyStatementImpl impl=efficiencyStatementManager.getUserEfficiencyStatementFull(repoKey,property.getIdentity());
  if (impl != null) {
    return;
  }
  UserEfficiencyStatementImpl statement=new UserEfficiencyStatementImpl();
  statement.setIdentity(property.getIdentity());
  statement.setStatementXml(property.getTextValue());
  if (re != null) {
    statement.setResource(re.getOlatResource());
    statement.setCourseRepoKey(re.getKey());
  }
  EfficiencyStatement s=(EfficiencyStatement)XStreamHelper.createXStreamInstance().fromXML(property.getTextValue());
  efficiencyStatementManager.fillEfficiencyStatement(s,statement);
  statement.setLastModified(property.getLastModified());
  dbInstance.saveObject(statement);
  dbInstance.commitAndCloseSession();
}"
70012,"protected boolean validateFormLogic(UserRequest ureq){
  for (  Project.EventType eventType : eventStartElementList.keySet()) {
    Date startDate=eventStartElementList.get(eventType).getDate();
    Date endDate=eventEndElementList.get(eventType).getDate();
    getLogger().debug(""String_Node_Str"" + startDate + ""String_Node_Str""+ endDate);
    if ((startDate != null) && (endDate != null) && startDate.after(endDate)) {
      eventStartElementList.get(eventType).setErrorKey(""String_Node_Str"",null);
      return false;
    }
  }
  if (!project.getTitle().equals(projectTitle.getValue()) && ProjectBrokerManagerFactory.getProjectBrokerManager().existProjectName(project.getProjectBroker().getKey(),projectTitle.getValue())) {
    projectTitle.setErrorKey(""String_Node_Str"",null);
    return false;
  }
  if (projectTitle.getValue().trim().isEmpty()) {
    projectTitle.setErrorKey(""String_Node_Str"",null);
    return false;
  }
  return true;
}","protected boolean validateFormLogic(UserRequest ureq){
  for (  Project.EventType eventType : eventStartElementList.keySet()) {
    Date startDate=eventStartElementList.get(eventType).getDate();
    Date endDate=eventEndElementList.get(eventType).getDate();
    getLogger().debug(""String_Node_Str"" + startDate + ""String_Node_Str""+ endDate);
    if ((startDate != null) && (endDate != null) && startDate.after(endDate)) {
      eventStartElementList.get(eventType).setErrorKey(""String_Node_Str"",null);
      return false;
    }
  }
  if (!project.getTitle().equals(projectTitle.getValue()) && ProjectBrokerManagerFactory.getProjectBrokerManager().existProjectName(project.getProjectBroker().getKey(),projectTitle.getValue())) {
    projectTitle.setErrorKey(""String_Node_Str"",null);
    return false;
  }
  if (projectTitle.getValue().trim().isEmpty()) {
    projectTitle.setErrorKey(""String_Node_Str"",null);
    return false;
  }
  if (attachmentFileName.getUploadFileName().length() > 99) {
    attachmentFileName.setErrorKey(""String_Node_Str"",null);
    return false;
  }
  return true;
}"
70013,"@Override protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  FormLayoutContainer buttonLayout=FormLayoutContainer.createButtonLayout(""String_Node_Str"",getTranslator());
  formLayout.add(buttonLayout);
  uifactory.addFormSubmitButton(""String_Node_Str"",""String_Node_Str"",buttonLayout);
  bttNo=uifactory.addFormLink(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",buttonLayout,Link.BUTTON);
}","@Override protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  askagainCheckbox=uifactory.addCheckboxesHorizontal(""String_Node_Str"",null,formLayout,askagain_keys,new String[]{translate(""String_Node_Str"")},null);
  FormLayoutContainer buttonLayout=FormLayoutContainer.createButtonLayout(""String_Node_Str"",getTranslator());
  formLayout.add(buttonLayout);
  uifactory.addFormSubmitButton(""String_Node_Str"",""String_Node_Str"",buttonLayout);
  bttNo=uifactory.addFormLink(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",buttonLayout,Link.BUTTON);
}"
70014,"@Override protected void formOK(UserRequest ureq){
  fireEvent(ureq,Event.DONE_EVENT);
  HistoryPoint historyEntry=HistoryManager.getInstance().readHistoryPoint(ureq.getIdentity());
  if (historyEntry != null && StringHelper.containsNonWhitespace(historyEntry.getBusinessPath())) {
    BusinessControl bc=BusinessControlFactory.getInstance().createFromContextEntries(historyEntry.getEntries());
    WindowControl bwControl=BusinessControlFactory.getInstance().createBusinessWindowControl(bc,getWindowControl());
    try {
      NewControllerFactory.getInstance().launch(ureq,bwControl);
    }
 catch (    Exception e) {
      logError(""String_Node_Str"",e);
    }
  }
}","@Override protected void formOK(UserRequest ureq){
  if (askagainCheckbox.isSelected(0)) {
    Preferences prefs=ureq.getUserSession().getGuiPreferences();
    prefs.put(WindowManager.class,""String_Node_Str"",""String_Node_Str"");
    prefs.save();
  }
  fireEvent(ureq,Event.DONE_EVENT);
  HistoryPoint historyEntry=HistoryManager.getInstance().readHistoryPoint(ureq.getIdentity());
  if (historyEntry != null && StringHelper.containsNonWhitespace(historyEntry.getBusinessPath())) {
    BusinessControl bc=BusinessControlFactory.getInstance().createFromContextEntries(historyEntry.getEntries());
    WindowControl bwControl=BusinessControlFactory.getInstance().createBusinessWindowControl(bc,getWindowControl());
    try {
      NewControllerFactory.getInstance().launch(ureq,bwControl);
    }
 catch (    Exception e) {
      logError(""String_Node_Str"",e);
    }
  }
}"
70015,"@Override protected void formCancelled(UserRequest ureq){
  fireEvent(ureq,Event.CANCELLED_EVENT);
}","@Override protected void formCancelled(UserRequest ureq){
  if (askagainCheckbox.isSelected(0)) {
    Preferences prefs=ureq.getUserSession().getGuiPreferences();
    prefs.put(WindowManager.class,""String_Node_Str"",""String_Node_Str"");
    prefs.save();
  }
  fireEvent(ureq,Event.CANCELLED_EVENT);
}"
70016,"/** 
 * returns a Collection of SubscriptionListItems for the given EPStructuredMap<br /> the returning list will contain listItems for newly added artefacts/Comments/Ratings PLUS the newly added Pages/StructElements from the ""parent""/""source"" templateMap
 * @param compareDate the comareDate (only items are added, that are created after this date)
 * @param map the EPStructuredMap
 */
public List<SubscriptionListItem> getAllSubscrItems_Structured(Date compareDate,EPStructuredMap map){
  List<SubscriptionListItem> allItems=new ArrayList<SubscriptionListItem>();
  PortfolioStructureMap sourceMap=map.getStructuredMapSource();
  allItems=getAllSubscrItems_Default(compareDate,(EPAbstractMap)sourceMap);
  String tmp_bPath;
  String tmp_linkUrl;
  List<EPStructureToArtefactLink> links=getAllArtefactLinks(map);
  for (  EPStructureToArtefactLink link : links) {
    if (link.getCreationDate().after(compareDate)) {
      PortfolioStructure linkParent=link.getStructureElement();
      Long linkKey=0L;
      if (linkParent instanceof EPPage) {
        linkKey=linkParent.getKey();
      }
 else {
        linkKey=linkParent.getRoot().getKey();
      }
      tmp_bPath=rootBusinessPath + ""String_Node_Str"" + linkKey+ ""String_Node_Str"";
      tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
      allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{getFullNameFromUser(link.getArtefact().getAuthor())}),tmp_linkUrl,link.getCreationDate(),""String_Node_Str""));
    }
  }
  allItems.addAll(getCRItemsForMap(compareDate,map));
  Collections.sort(allItems,new SubscriptionListItemComparator());
  return allItems;
}","/** 
 * returns a Collection of SubscriptionListItems for the given EPStructuredMap<br /> the returning list will contain listItems for newly added artefacts/Comments/Ratings PLUS the newly added Pages/StructElements from the ""parent""/""source"" templateMap
 * @param compareDate the comareDate (only items are added, that are created after this date)
 * @param map the EPStructuredMap
 */
public List<SubscriptionListItem> getAllSubscrItems_Structured(Date compareDate,EPStructuredMap map){
  List<SubscriptionListItem> allItems=new ArrayList<SubscriptionListItem>();
  PortfolioStructureMap sourceMap=map.getStructuredMapSource();
  allItems=getAllSubscrItems_Default(compareDate,(EPAbstractMap)sourceMap);
  String tmp_bPath;
  String tmp_linkUrl;
  Long tmp_linkKey=0L;
  String tmp_TargetTitle;
  List<EPStructureToArtefactLink> links=getAllArtefactLinks(map);
  for (  EPStructureToArtefactLink link : links) {
    if (link.getCreationDate().after(compareDate)) {
      PortfolioStructure linkParent=link.getStructureElement();
      if (linkParent instanceof EPPage) {
        tmp_linkKey=linkParent.getKey();
        tmp_TargetTitle=linkParent.getTitle();
      }
 else {
        tmp_linkKey=linkParent.getRoot().getKey();
        tmp_TargetTitle=linkParent.getRoot().getTitle();
      }
      tmp_bPath=rootBusinessPath + ""String_Node_Str"" + tmp_linkKey+ ""String_Node_Str"";
      tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
      allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{getFullNameFromUser(link.getArtefact().getAuthor()),link.getArtefact().getTitle(),tmp_TargetTitle}),tmp_linkUrl,link.getCreationDate(),""String_Node_Str""));
    }
  }
  allItems.addAll(getCRItemsForMap(compareDate,map));
  Collections.sort(allItems,new SubscriptionListItemComparator());
  return allItems;
}"
70017,"/** 
 * returns a Collection of SubscriptionListItems for the given EPDefaultMap or EPStructuredMapTemplate (they are handled the same)<br /> the returning list will contain listItems for newly added artefacts/Pages/StructElements/Comments/Ratings
 * @param compareDate the comareDate (only items are added, that are created after this date)
 * @param map the EPDefaultMap or
 */
public List<SubscriptionListItem> getAllSubscrItems_Default(Date compareDate,EPAbstractMap map){
  List<SubscriptionListItem> allItems=new ArrayList<SubscriptionListItem>();
  String tmp_bPath;
  String tmp_linkUrl;
  List<EPStructureToStructureLink> structLinkCollection=getAllStruct2StructLinks(map);
  for (  EPStructureToStructureLink structLink : structLinkCollection) {
    if (structLink.getCreationDate().after(compareDate)) {
      if (structLink.getChild() instanceof EPPage) {
        EPPage childPage=(EPPage)structLink.getChild();
        tmp_bPath=rootBusinessPath + ""String_Node_Str"" + childPage.getKey()+ ""String_Node_Str"";
        tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
        allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{childPage.getTitle()}),tmp_linkUrl,structLink.getCreationDate(),""String_Node_Str""));
      }
 else {
        if (structLink.getParent() instanceof EPPage) {
          EPPage parentPage=(EPPage)structLink.getParent();
          tmp_bPath=rootBusinessPath + ""String_Node_Str"" + parentPage.getKey()+ ""String_Node_Str"";
          tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
        }
 else {
          tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(rootBusinessPath);
          allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{structLink.getChild().getTitle()}),tmp_linkUrl,structLink.getCreationDate(),""String_Node_Str""));
        }
      }
    }
  }
  List<EPStructureToArtefactLink> links=getAllArtefactLinks(map);
  for (  EPStructureToArtefactLink link : links) {
    if (link.getCreationDate().after(compareDate)) {
      PortfolioStructure linkParent=link.getStructureElement();
      Long linkKey=0L;
      if (linkParent instanceof EPPage) {
        linkKey=linkParent.getKey();
      }
 else {
        linkKey=linkParent.getRoot().getKey();
      }
      tmp_bPath=rootBusinessPath + ""String_Node_Str"" + linkKey+ ""String_Node_Str"";
      tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
      allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{getFullNameFromUser(link.getArtefact().getAuthor())}),tmp_linkUrl,link.getCreationDate(),""String_Node_Str""));
    }
  }
  allItems.addAll(getCRItemsForMap(compareDate,map));
  Collections.sort(allItems,new SubscriptionListItemComparator());
  return allItems;
}","/** 
 * returns a Collection of SubscriptionListItems for the given EPDefaultMap or EPStructuredMapTemplate (they are handled the same)<br /> the returning list will contain listItems for newly added artefacts/Pages/StructElements/Comments/Ratings
 * @param compareDate the comareDate (only items are added, that are created after this date)
 * @param map the EPDefaultMap or
 */
public List<SubscriptionListItem> getAllSubscrItems_Default(Date compareDate,EPAbstractMap map){
  List<SubscriptionListItem> allItems=new ArrayList<SubscriptionListItem>();
  String tmp_bPath;
  String tmp_linkUrl;
  List<EPStructureToStructureLink> structLinkCollection=getAllStruct2StructLinks(map);
  for (  EPStructureToStructureLink structLink : structLinkCollection) {
    if (structLink.getCreationDate().after(compareDate)) {
      if (structLink.getChild() instanceof EPPage) {
        EPPage childPage=(EPPage)structLink.getChild();
        tmp_bPath=rootBusinessPath + ""String_Node_Str"" + childPage.getKey()+ ""String_Node_Str"";
        tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
        allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{childPage.getTitle()}),tmp_linkUrl,structLink.getCreationDate(),""String_Node_Str""));
      }
 else {
        tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(rootBusinessPath);
        if (structLink.getParent() instanceof EPPage) {
          EPPage parentPage=(EPPage)structLink.getParent();
          tmp_bPath=rootBusinessPath + ""String_Node_Str"" + parentPage.getKey()+ ""String_Node_Str"";
          tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
        }
        allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{structLink.getChild().getTitle()}),tmp_linkUrl,structLink.getCreationDate(),""String_Node_Str""));
      }
    }
  }
  Long tmp_LinkKey;
  String tmp_TargetTitle;
  List<EPStructureToArtefactLink> links=getAllArtefactLinks(map);
  for (  EPStructureToArtefactLink link : links) {
    if (link.getCreationDate().after(compareDate)) {
      PortfolioStructure linkParent=link.getStructureElement();
      if (linkParent instanceof EPPage) {
        tmp_LinkKey=linkParent.getKey();
        tmp_TargetTitle=linkParent.getTitle();
      }
 else {
        tmp_LinkKey=linkParent.getRoot().getKey();
        tmp_TargetTitle=linkParent.getRoot().getTitle();
      }
      tmp_bPath=rootBusinessPath + ""String_Node_Str"" + tmp_LinkKey+ ""String_Node_Str"";
      tmp_linkUrl=BusinessControlFactory.getInstance().getURLFromBusinessPathString(tmp_bPath);
      allItems.add(new SubscriptionListItem(translator.translate(""String_Node_Str"",new String[]{getFullNameFromUser(link.getArtefact().getAuthor()),link.getArtefact().getTitle(),tmp_TargetTitle}),tmp_linkUrl,link.getCreationDate(),""String_Node_Str""));
    }
  }
  allItems.addAll(getCRItemsForMap(compareDate,map));
  Collections.sort(allItems,new SubscriptionListItemComparator());
  return allItems;
}"
70018,"@SuppressWarnings(""String_Node_Str"") @Override public List<AjaxTreeNode> getChildrenFor(String nodeId){
  List<AjaxTreeNode> children=new ArrayList<AjaxTreeNode>();
  AjaxTreeNode child;
  try {
    List<PortfolioStructure> structs=null;
    if (nodeId.equals(ROOT_NODE_IDENTIFIER)) {
      structs=ePFMgr.getStructureElementsForUser(getIdentity(),ElementType.STRUCTURED_MAP,ElementType.DEFAULT_MAP);
      firstLevelDone=false;
    }
 else {
      PortfolioStructure selStruct=ePFMgr.loadPortfolioStructureByKey(new Long(nodeId));
      structs=ePFMgr.loadStructureChildren(selStruct);
    }
    if (structs == null || structs.size() == 0) {
      return null;
    }
    if (!firstLevelDone) {
      child=new AjaxTreeNode(NO_MAP_CHOOSEN,translate(""String_Node_Str""));
      child.put(AjaxTreeNode.CONF_LEAF,true);
      child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,true);
      child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
      child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
      child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,""String_Node_Str"");
      child.put(AjaxTreeNode.CONF_QTIP,translate(""String_Node_Str""));
      if (isUsedInStepWizzard())       children.add(child);
      firstLevelDone=true;
    }
    for (    PortfolioStructure portfolioStructure : structs) {
      if (portfolioStructure instanceof EPStructuredMap) {
        if (((EPStructuredMap)portfolioStructure).getStatus().equals(StructureStatusEnum.CLOSED)) {
          continue;
        }
      }
      String title=portfolioStructure.getTitle();
      if (!isUsedInStepWizzard() && oldStructure.getKey().equals(portfolioStructure.getKey())) {
        title=portfolioStructure.getTitle() + ""String_Node_Str"" + translate(""String_Node_Str"");
      }
      child=new AjaxTreeNode(String.valueOf(portfolioStructure.getKey()),title);
      boolean hasChilds=ePFMgr.countStructureChildren(portfolioStructure) > 0;
      child.put(AjaxTreeNode.CONF_LEAF,!hasChilds);
      child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,!hasChilds);
      child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
      child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
      child.put(AjaxTreeNode.CONF_EXPANDED,true);
      child.put(AjaxTreeNode.CONF_DISABLED,portfolioStructure instanceof EPAbstractMap);
      child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,portfolioStructure.getIcon());
      child.put(AjaxTreeNode.CONF_QTIP,portfolioStructure.getDescription());
      children.add(child);
    }
  }
 catch (  JSONException e) {
    throw new OLATRuntimeException(""String_Node_Str"",e);
  }
  return children;
}","@SuppressWarnings(""String_Node_Str"") @Override public List<AjaxTreeNode> getChildrenFor(String nodeId){
  List<AjaxTreeNode> children=new ArrayList<AjaxTreeNode>();
  AjaxTreeNode child;
  try {
    List<PortfolioStructure> structs=null;
    if (nodeId.equals(ROOT_NODE_IDENTIFIER)) {
      structs=ePFMgr.getStructureElementsForUser(getIdentity(),ElementType.STRUCTURED_MAP,ElementType.DEFAULT_MAP);
      firstLevelDone=false;
    }
 else {
      PortfolioStructure selStruct=ePFMgr.loadPortfolioStructureByKey(new Long(nodeId));
      structs=ePFMgr.loadStructureChildren(selStruct);
    }
    if (structs == null || structs.size() == 0) {
      return null;
    }
    if (!firstLevelDone) {
      child=new AjaxTreeNode(NO_MAP_CHOOSEN,translate(""String_Node_Str""));
      child.put(AjaxTreeNode.CONF_LEAF,true);
      child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,true);
      child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
      child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
      child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,""String_Node_Str"");
      child.put(AjaxTreeNode.CONF_QTIP,translate(""String_Node_Str""));
      if (isUsedInStepWizzard())       children.add(child);
      firstLevelDone=true;
    }
    for (    PortfolioStructure portfolioStructure : structs) {
      if (portfolioStructure instanceof EPStructuredMap) {
        if (((EPStructuredMap)portfolioStructure).getStatus() != null && ((EPStructuredMap)portfolioStructure).getStatus().equals(StructureStatusEnum.CLOSED)) {
          continue;
        }
      }
      String title=portfolioStructure.getTitle();
      if (!isUsedInStepWizzard() && oldStructure.getKey().equals(portfolioStructure.getKey())) {
        title=portfolioStructure.getTitle() + ""String_Node_Str"" + translate(""String_Node_Str"");
      }
      child=new AjaxTreeNode(String.valueOf(portfolioStructure.getKey()),title);
      boolean hasChilds=ePFMgr.countStructureChildren(portfolioStructure) > 0;
      child.put(AjaxTreeNode.CONF_LEAF,!hasChilds);
      child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,!hasChilds);
      child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
      child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
      child.put(AjaxTreeNode.CONF_EXPANDED,true);
      child.put(AjaxTreeNode.CONF_DISABLED,portfolioStructure instanceof EPAbstractMap);
      child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,portfolioStructure.getIcon());
      child.put(AjaxTreeNode.CONF_QTIP,portfolioStructure.getDescription());
      children.add(child);
    }
  }
 catch (  JSONException e) {
    throw new OLATRuntimeException(""String_Node_Str"",e);
  }
  return children;
}"
70019,"private AjaxTreeModel buildTreeModel(){
  AjaxTreeModel model=new AjaxTreeModel(ROOT_NODE_IDENTIFIER){
    private boolean firstLevelDone=false;
    @SuppressWarnings(""String_Node_Str"") @Override public List<AjaxTreeNode> getChildrenFor(    String nodeId){
      List<AjaxTreeNode> children=new ArrayList<AjaxTreeNode>();
      AjaxTreeNode child;
      try {
        List<PortfolioStructure> structs=null;
        if (nodeId.equals(ROOT_NODE_IDENTIFIER)) {
          structs=ePFMgr.getStructureElementsForUser(getIdentity(),ElementType.STRUCTURED_MAP,ElementType.DEFAULT_MAP);
          firstLevelDone=false;
        }
 else {
          PortfolioStructure selStruct=ePFMgr.loadPortfolioStructureByKey(new Long(nodeId));
          structs=ePFMgr.loadStructureChildren(selStruct);
        }
        if (structs == null || structs.size() == 0) {
          return null;
        }
        if (!firstLevelDone) {
          child=new AjaxTreeNode(NO_MAP_CHOOSEN,translate(""String_Node_Str""));
          child.put(AjaxTreeNode.CONF_LEAF,true);
          child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,true);
          child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
          child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
          child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,""String_Node_Str"");
          child.put(AjaxTreeNode.CONF_QTIP,translate(""String_Node_Str""));
          if (isUsedInStepWizzard())           children.add(child);
          firstLevelDone=true;
        }
        for (        PortfolioStructure portfolioStructure : structs) {
          if (portfolioStructure instanceof EPStructuredMap) {
            if (((EPStructuredMap)portfolioStructure).getStatus().equals(StructureStatusEnum.CLOSED)) {
              continue;
            }
          }
          String title=portfolioStructure.getTitle();
          if (!isUsedInStepWizzard() && oldStructure.getKey().equals(portfolioStructure.getKey())) {
            title=portfolioStructure.getTitle() + ""String_Node_Str"" + translate(""String_Node_Str"");
          }
          child=new AjaxTreeNode(String.valueOf(portfolioStructure.getKey()),title);
          boolean hasChilds=ePFMgr.countStructureChildren(portfolioStructure) > 0;
          child.put(AjaxTreeNode.CONF_LEAF,!hasChilds);
          child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,!hasChilds);
          child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
          child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
          child.put(AjaxTreeNode.CONF_EXPANDED,true);
          child.put(AjaxTreeNode.CONF_DISABLED,portfolioStructure instanceof EPAbstractMap);
          child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,portfolioStructure.getIcon());
          child.put(AjaxTreeNode.CONF_QTIP,portfolioStructure.getDescription());
          children.add(child);
        }
      }
 catch (      JSONException e) {
        throw new OLATRuntimeException(""String_Node_Str"",e);
      }
      return children;
    }
  }
;
  model.setCustomRootIconCssClass(""String_Node_Str"");
  return model;
}","private AjaxTreeModel buildTreeModel(){
  AjaxTreeModel model=new AjaxTreeModel(ROOT_NODE_IDENTIFIER){
    private boolean firstLevelDone=false;
    @SuppressWarnings(""String_Node_Str"") @Override public List<AjaxTreeNode> getChildrenFor(    String nodeId){
      List<AjaxTreeNode> children=new ArrayList<AjaxTreeNode>();
      AjaxTreeNode child;
      try {
        List<PortfolioStructure> structs=null;
        if (nodeId.equals(ROOT_NODE_IDENTIFIER)) {
          structs=ePFMgr.getStructureElementsForUser(getIdentity(),ElementType.STRUCTURED_MAP,ElementType.DEFAULT_MAP);
          firstLevelDone=false;
        }
 else {
          PortfolioStructure selStruct=ePFMgr.loadPortfolioStructureByKey(new Long(nodeId));
          structs=ePFMgr.loadStructureChildren(selStruct);
        }
        if (structs == null || structs.size() == 0) {
          return null;
        }
        if (!firstLevelDone) {
          child=new AjaxTreeNode(NO_MAP_CHOOSEN,translate(""String_Node_Str""));
          child.put(AjaxTreeNode.CONF_LEAF,true);
          child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,true);
          child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
          child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
          child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,""String_Node_Str"");
          child.put(AjaxTreeNode.CONF_QTIP,translate(""String_Node_Str""));
          if (isUsedInStepWizzard())           children.add(child);
          firstLevelDone=true;
        }
        for (        PortfolioStructure portfolioStructure : structs) {
          if (portfolioStructure instanceof EPStructuredMap) {
            if (((EPStructuredMap)portfolioStructure).getStatus() != null && ((EPStructuredMap)portfolioStructure).getStatus().equals(StructureStatusEnum.CLOSED)) {
              continue;
            }
          }
          String title=portfolioStructure.getTitle();
          if (!isUsedInStepWizzard() && oldStructure.getKey().equals(portfolioStructure.getKey())) {
            title=portfolioStructure.getTitle() + ""String_Node_Str"" + translate(""String_Node_Str"");
          }
          child=new AjaxTreeNode(String.valueOf(portfolioStructure.getKey()),title);
          boolean hasChilds=ePFMgr.countStructureChildren(portfolioStructure) > 0;
          child.put(AjaxTreeNode.CONF_LEAF,!hasChilds);
          child.put(AjaxTreeNode.CONF_IS_TYPE_LEAF,!hasChilds);
          child.put(AjaxTreeNode.CONF_ALLOWDRAG,false);
          child.put(AjaxTreeNode.CONF_ALLOWDROP,false);
          child.put(AjaxTreeNode.CONF_EXPANDED,true);
          child.put(AjaxTreeNode.CONF_DISABLED,portfolioStructure instanceof EPAbstractMap);
          child.put(AjaxTreeNode.CONF_ICON_CSS_CLASS,portfolioStructure.getIcon());
          child.put(AjaxTreeNode.CONF_QTIP,portfolioStructure.getDescription());
          children.add(child);
        }
      }
 catch (      JSONException e) {
        throw new OLATRuntimeException(""String_Node_Str"",e);
      }
      return children;
    }
  }
;
  model.setCustomRootIconCssClass(""String_Node_Str"");
  return model;
}"
70020,"@Override protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  flc.contextPut(""String_Node_Str"",getLocale());
  if (logger.isDebug())   logger.debug(""String_Node_Str"" + map.getTitle() + ""String_Node_Str""+ map.getResourceableId()+ ""String_Node_Str""+ map.getKey());
  subsContext=new SubscriptionContext(EPNotificationsHandler.TYPENNAME,map.getResourceableId(),EPNotificationsHandler.TYPENNAME);
  if (subsContext != null) {
    String businnessPath=getWindowControl().getBusinessControl().getAsString();
    PublisherData data=new PublisherData(EPNotificationsHandler.TYPENNAME,null,businnessPath);
    cSubscriptionCtrl=new ContextualSubscriptionController(ureq,getWindowControl(),subsContext,data);
    listenTo(cSubscriptionCtrl);
    flc.put(""String_Node_Str"",cSubscriptionCtrl.getInitialComponent());
  }
  dateChooser=uifactory.addDateChooser(""String_Node_Str"",""String_Node_Str"",null,formLayout);
  dateChooser.setDate(new Date());
  dateChooser.addActionListener(this,FormEvent.ONCHANGE);
  updateChangelogDisplay(ureq);
}","@Override protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  flc.contextPut(""String_Node_Str"",getLocale());
  if (logger.isDebug())   logger.debug(""String_Node_Str"" + map.getTitle() + ""String_Node_Str""+ map.getResourceableId()+ ""String_Node_Str""+ map.getKey());
  subsContext=new SubscriptionContext(EPNotificationsHandler.TYPENNAME,map.getResourceableId(),EPNotificationsHandler.TYPENNAME);
  if (subsContext != null) {
    String businessPath=""String_Node_Str"" + map.getKey() + ""String_Node_Str"";
    PublisherData data=new PublisherData(EPNotificationsHandler.TYPENNAME,null,businessPath);
    cSubscriptionCtrl=new ContextualSubscriptionController(ureq,getWindowControl(),subsContext,data);
    listenTo(cSubscriptionCtrl);
    flc.put(""String_Node_Str"",cSubscriptionCtrl.getInitialComponent());
  }
  dateChooser=uifactory.addDateChooser(""String_Node_Str"",""String_Node_Str"",null,formLayout);
  dateChooser.setDate(new Date());
  dateChooser.addActionListener(this,FormEvent.ONCHANGE);
  updateChangelogDisplay(ureq);
}"
70021,"private void updateLogViewFromWriter(){
  if (logViewerVC == null)   return;
  StringBuffer sb=writer.getBuffer();
  String log=sb.toString();
  if (removeLogNoise) {
    Matcher m=logNoiseReducePattern.matcher(log);
    log=m.replaceAll(""String_Node_Str"");
  }
  logViewerVC.contextPut(""String_Node_Str"",Formatter.escWithBR(log));
  if (sb.length() > 100000) {
    int nextLineBreakAfterHalfPos=sb.indexOf(""String_Node_Str"",sb.length() / 2);
    sb.delete(0,nextLineBreakAfterHalfPos);
  }
}","private synchronized void updateLogViewFromWriter(){
  if (logViewerVC == null)   return;
  StringBuffer sb=writer.getBuffer();
  String log=sb.toString();
  if (removeLogNoise) {
    Matcher m=logNoiseReducePattern.matcher(log);
    log=m.replaceAll(""String_Node_Str"");
  }
  logViewerVC.contextPut(""String_Node_Str"",Formatter.escWithBR(log));
  if (sb.length() > 100000) {
    int nextLineBreakAfterHalfPos=sb.indexOf(""String_Node_Str"",sb.length() / 2);
    sb.delete(0,nextLineBreakAfterHalfPos);
  }
}"
70022,"/** 
 * @see org.olat.core.gui.control.DefaultController#doDispose()
 */
@Override protected void doDispose(){
  if (logViewerVC != null) {
    Scheduler scheduler=(Scheduler)CoreSpringFactory.getBean(""String_Node_Str"");
    try {
      scheduler.deleteJob(jobName,LOG_DISPLAYER_GROUP);
      scheduler.removeJobListener(jobName);
    }
 catch (    SchedulerException e) {
      logError(""String_Node_Str"",e);
    }
    log4JLogger.removeAppender(writerAppender);
    log4JLogger=null;
    writerAppender.close();
    writerAppender=null;
    try {
      writer.close();
    }
 catch (    IOException e) {
      logError(""String_Node_Str"",e);
    }
    writer=null;
    updateLink=null;
    logViewerVC=null;
  }
}","/** 
 * @see org.olat.core.gui.control.DefaultController#doDispose()
 */
@Override protected void doDispose(){
  if (logViewerVC != null) {
    Scheduler scheduler=(Scheduler)CoreSpringFactory.getBean(""String_Node_Str"");
    try {
      scheduler.deleteJob(jobName,LOG_DISPLAYER_GROUP);
      scheduler.removeJobListener(jobName);
    }
 catch (    SchedulerException e) {
      logError(""String_Node_Str"",e);
    }
    log4JLogger.removeAppender(writerAppender);
    log4JLogger=null;
    writerAppender.close();
    writerAppender=null;
    try {
      writer.close();
    }
 catch (    IOException e) {
      logError(""String_Node_Str"",e);
    }
synchronized (this) {
      writer=null;
      updateLink=null;
      logViewerVC=null;
    }
  }
}"
70023,"public static String getSetFlexiFormDirtyForCheckbox(Form form,String id){
  String result;
  String prefix=id + ""String_Node_Str"";
  String postfix=""String_Node_Str"" + form.getDispatchFieldId() + ""String_Node_Str"";
  result=prefix + ""String_Node_Str"" + postfix;
  result+=prefix + ""String_Node_Str"" + postfix;
  return result;
}","public static String getSetFlexiFormDirtyForCheckbox(Form form,String id){
  String result;
  String prefix=secureJSVarName(id) + ""String_Node_Str"";
  String postfix=""String_Node_Str"" + form.getDispatchFieldId() + ""String_Node_Str"";
  result=prefix + ""String_Node_Str"" + postfix;
  result+=prefix + ""String_Node_Str"" + postfix;
  return result;
}"
70024,"public static String getSetFlexiFormDirty(Form form,String id){
  String result;
  String prefix=id + ""String_Node_Str"";
  String postfix=""String_Node_Str"" + form.getDispatchFieldId() + ""String_Node_Str"";
  result=prefix + ""String_Node_Str"" + postfix;
  result+=prefix + ""String_Node_Str"" + postfix;
  return result;
}","public static String getSetFlexiFormDirty(Form form,String id){
  String result;
  String prefix=secureJSVarName(id) + ""String_Node_Str"";
  String postfix=""String_Node_Str"" + form.getDispatchFieldId() + ""String_Node_Str"";
  result=prefix + ""String_Node_Str"" + postfix;
  result+=prefix + ""String_Node_Str"" + postfix;
  return result;
}"
70025,"public static String getJSStartWithVarDeclaration(String id){
  StringBuffer sb=new StringBuffer(120);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(id).append(""String_Node_Str"").append(id).append(""String_Node_Str"");
  return sb.toString();
}","public static String getJSStartWithVarDeclaration(String id){
  StringBuffer sb=new StringBuffer(120);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(secureJSVarName(id)).append(""String_Node_Str"").append(id).append(""String_Node_Str"");
  return sb.toString();
}"
70026,"public static String getExtJSVarDeclaration(String id){
  return ""String_Node_Str"" + id + ""String_Node_Str""+ id+ ""String_Node_Str"";
}","public static String getExtJSVarDeclaration(String id){
  return ""String_Node_Str"" + secureJSVarName(id) + ""String_Node_Str""+ id+ ""String_Node_Str"";
}"
70027,"/** 
 * @param us
 * @return the Windows for this user
 */
public static Windows getWindows(UserSession us){
  Windows ws=(Windows)us.getEntry(SESSIONID_NAME_FOR_WINDOWS);
  if (ws == null) {
    ws=new Windows();
    us.putEntry(SESSIONID_NAME_FOR_WINDOWS,ws);
  }
  return ws;
}","/** 
 * @param us
 * @return the Windows for this user
 */
public static Windows getWindows(UserSession us){
  Windows ws;
synchronized (us) {
    ws=(Windows)us.getEntry(SESSIONID_NAME_FOR_WINDOWS);
    if (ws == null) {
      ws=new Windows();
      us.putEntry(SESSIONID_NAME_FOR_WINDOWS,ws);
    }
  }
  return ws;
}"
70028,"/** 
 * Main method called by DispatcherAction. This processess all requests for users who are not authenticated.
 * @param request
 * @param response
 * @param uriPrefix
 */
public void execute(HttpServletRequest request,HttpServletResponse response,String uriPrefix){
  if (rejectRequest(request,response)) {
    return;
  }
  UserRequest ureq=null;
  try {
    ureq=new UserRequest(uriPrefix,request,response);
  }
 catch (  NumberFormatException nfe) {
    if (Tracing.isDebugEnabled(DMZDispatcher.class)) {
      Tracing.logDebug(""String_Node_Str"" + request.getPathInfo(),this.getClass());
    }
    DispatcherAction.sendBadRequest(request.getPathInfo(),response);
    return;
  }
  try {
    String pathInfo=request.getContextPath() + request.getPathInfo();
    ChiefControllerCreator subPathccc=null;
    boolean dmzOnly=pathInfo.equals(uriPrefix);
    if (!dmzOnly) {
      int sl=pathInfo.indexOf('/',uriPrefix.length());
      String sub;
      if (sl > 1) {
        sub=pathInfo.substring(uriPrefix.length() - 1,sl + 1);
      }
 else {
        sub=pathInfo;
      }
      subPathccc=dmzServicesByPath.get(sub);
      UserSession usess=ureq.getUserSession();
      Windows ws=Windows.getWindows(usess);
synchronized (ws) {
        ChiefController occ;
        if (subPathccc != null) {
          occ=subPathccc.createChiefController(ureq);
          Window window=occ.getWindow();
          window.setUriPrefix(uriPrefix);
          ws.registerWindow(window);
          window.dispatchRequest(ureq,true);
          return;
        }
      }
    }
    UserSession usess=ureq.getUserSession();
    Windows ws=Windows.getWindows(usess);
synchronized (ws) {
      Window window;
      boolean windowHere=ws.isExisting(uriPrefix,ureq.getWindowID());
      boolean validDispatchUri=ureq.isValidDispatchURI();
      if (validDispatchUri && !windowHere) {
        window=null;
        usess.signOffAndClear();
        usess.setLocale(LocaleNegotiator.getPreferedLocale(ureq));
        I18nManager.updateLocaleInfoToThread(usess);
        ws=Windows.getWindows(usess);
      }
 else {
        if (validDispatchUri) {
          window=ws.getWindow(ureq);
        }
 else {
          window=null;
          usess.signOffAndClear();
          usess.setLocale(LocaleNegotiator.getPreferedLocale(ureq));
          I18nManager.updateLocaleInfoToThread(usess);
          ws=Windows.getWindows(usess);
        }
      }
      if (window == null) {
        ChiefController occ=chiefControllerCreator.createChiefController(ureq);
        window=occ.getWindow();
        window.setUriPrefix(uriPrefix);
        ws.registerWindow(window);
        String businessPath=(String)usess.removeEntryFromNonClearedStore(DMZDISPATCHER_BUSINESSPATH);
        if (businessPath != null) {
          List<ContextEntry> ces=BusinessControlFactory.getInstance().createCEListFromString(businessPath);
          DTabs dts=(DTabs)window.getAttribute(""String_Node_Str"");
          dts.activate(ureq,null,null,ces);
        }
        window.dispatchRequest(ureq);
      }
 else {
        window.dispatchRequest(ureq);
      }
    }
  }
 catch (  Throwable th) {
    try {
      ChiefController msgcc=MsgFactory.createMessageChiefController(ureq,th);
      msgcc.getWindow().dispatchRequest(ureq,true);
    }
 catch (    Throwable t) {
      Tracing.logError(""String_Node_Str"",t,DMZDispatcher.class);
    }
  }
 finally {
  }
}","/** 
 * Main method called by DispatcherAction. This processess all requests for users who are not authenticated.
 * @param request
 * @param response
 * @param uriPrefix
 */
public void execute(HttpServletRequest request,HttpServletResponse response,String uriPrefix){
  if (rejectRequest(request,response)) {
    return;
  }
  UserRequest ureq=null;
  try {
    ureq=new UserRequest(uriPrefix,request,response);
  }
 catch (  NumberFormatException nfe) {
    if (Tracing.isDebugEnabled(DMZDispatcher.class)) {
      Tracing.logDebug(""String_Node_Str"" + request.getPathInfo(),this.getClass());
    }
    DispatcherAction.sendBadRequest(request.getPathInfo(),response);
    return;
  }
  try {
    String pathInfo=request.getContextPath() + request.getPathInfo();
    ChiefControllerCreator subPathccc=null;
    boolean dmzOnly=pathInfo.equals(uriPrefix);
    if (!dmzOnly) {
      int sl=pathInfo.indexOf('/',uriPrefix.length());
      String sub;
      if (sl > 1) {
        sub=pathInfo.substring(uriPrefix.length() - 1,sl + 1);
      }
 else {
        sub=pathInfo;
      }
      subPathccc=dmzServicesByPath.get(sub);
      UserSession usess=ureq.getUserSession();
      Windows ws=Windows.getWindows(usess);
synchronized (ws) {
        ChiefController occ;
        if (subPathccc != null) {
          occ=subPathccc.createChiefController(ureq);
          Window window=occ.getWindow();
          window.setUriPrefix(uriPrefix);
          ws.registerWindow(window);
          window.dispatchRequest(ureq,true);
          return;
        }
      }
    }
    UserSession usess=ureq.getUserSession();
    Windows ws=Windows.getWindows(usess);
synchronized (usess) {
      Window window;
      boolean windowHere=ws.isExisting(uriPrefix,ureq.getWindowID());
      boolean validDispatchUri=ureq.isValidDispatchURI();
      if (validDispatchUri && !windowHere) {
        window=null;
        usess.signOffAndClear();
        usess.setLocale(LocaleNegotiator.getPreferedLocale(ureq));
        I18nManager.updateLocaleInfoToThread(usess);
        ws=Windows.getWindows(usess);
      }
 else {
        if (validDispatchUri) {
          window=ws.getWindow(ureq);
        }
 else {
          window=null;
          usess.signOffAndClear();
          usess.setLocale(LocaleNegotiator.getPreferedLocale(ureq));
          I18nManager.updateLocaleInfoToThread(usess);
          ws=Windows.getWindows(usess);
        }
      }
      if (window == null) {
        ChiefController occ=chiefControllerCreator.createChiefController(ureq);
        window=occ.getWindow();
        window.setUriPrefix(uriPrefix);
        ws.registerWindow(window);
        String businessPath=(String)usess.removeEntryFromNonClearedStore(DMZDISPATCHER_BUSINESSPATH);
        if (businessPath != null) {
          List<ContextEntry> ces=BusinessControlFactory.getInstance().createCEListFromString(businessPath);
          DTabs dts=(DTabs)window.getAttribute(""String_Node_Str"");
          dts.activate(ureq,null,null,ces);
        }
      }
      window.dispatchRequest(ureq);
    }
  }
 catch (  Throwable th) {
    try {
      ChiefController msgcc=MsgFactory.createMessageChiefController(ureq,th);
      msgcc.getWindow().dispatchRequest(ureq,true);
    }
 catch (    Throwable t) {
      Tracing.logError(""String_Node_Str"",t,DMZDispatcher.class);
    }
  }
 finally {
  }
}"
70029,"/** 
 * Add horizontal aligned radio buttons. <br>
 * @param name
 * @param i18nLabel
 * @param formLayout
 * @param theKeys
 * @param theValues
 * @return
 */
public SingleSelection addRadiosHorizontal(final String name,final String i18nLabel,FormItemContainer formLayout,final String[] theKeys,final String[] theValues){
  SingleSelection ss=new SingleSelectionImpl(null,name,SingleSelectionImpl.createHorizontalLayout(null,name)){
{
      this.keys=theKeys;
      this.values=theValues;
    }
  }
;
  setLabelIfNotNull(i18nLabel,ss);
  formLayout.add(ss);
  return ss;
}","/** 
 * Add horizontal aligned radio buttons. <br>
 * @param name
 * @param i18nLabel
 * @param formLayout
 * @param theKeys
 * @param theValues
 * @return
 */
public SingleSelection addRadiosHorizontal(final String name,final String i18nLabel,FormItemContainer formLayout,final String[] theKeys,final String[] theValues){
  SingleSelection ss=new SingleSelectionImpl(name,name,SingleSelectionImpl.createHorizontalLayout(null,name)){
{
      this.keys=theKeys;
      this.values=theValues;
    }
  }
;
  setLabelIfNotNull(i18nLabel,ss);
  formLayout.add(ss);
  return ss;
}"
70030,"/** 
 * Add vertical aligned radio buttons<br>
 * @param name
 * @param i18nLabel
 * @param formLayout
 * @param theKeys
 * @param theValues
 * @return
 */
public SingleSelection addRadiosVertical(final String name,final String i18nLabel,FormItemContainer formLayout,final String[] theKeys,final String[] theValues){
  SingleSelection ss=new SingleSelectionImpl(null,name,SingleSelectionImpl.createVerticalLayout(null,name)){
{
      this.keys=theKeys;
      this.values=theValues;
    }
  }
;
  setLabelIfNotNull(i18nLabel,ss);
  formLayout.add(ss);
  return ss;
}","/** 
 * Add vertical aligned radio buttons<br>
 * @param name
 * @param i18nLabel
 * @param formLayout
 * @param theKeys
 * @param theValues
 * @return
 */
public SingleSelection addRadiosVertical(final String name,final String i18nLabel,FormItemContainer formLayout,final String[] theKeys,final String[] theValues){
  SingleSelection ss=new SingleSelectionImpl(name,name,SingleSelectionImpl.createVerticalLayout(null,name)){
{
      this.keys=theKeys;
      this.values=theValues;
    }
  }
;
  setLabelIfNotNull(i18nLabel,ss);
  formLayout.add(ss);
  return ss;
}"
70031,"/** 
 * used by the renderer, and also by the panel and tabbedpane renderer to delegate rendering
 * @param sb
 * @param source
 * @param args
 */
public void render(StringOutput sb,Component source,String[] args){
  GlobalSettings gset=getGlobalSettings();
  boolean ajaxon=gset.getAjaxFlags().isIframePostEnabled();
  boolean domReplaceable=source.isDomReplaceable();
  boolean useSpan=source.getSpanAsDomReplaceable();
  boolean forceDebugDivs=gset.isIdDivsForced();
  if (source.isVisible()) {
    int lev=renderResult.getNestedLevel();
    if (lev > 42)     throw new AssertException(""String_Node_Str"" + source.getComponentName());
    Translator componentTranslator=source.getTranslator();
    if (domReplaceable && (ajaxon || forceDebugDivs)) {
      if (useSpan) {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
    }
    ComponentRenderer cr=findComponentRenderer(source);
    URLBuilder cubu=urlBuilder.createCopyFor(source);
    if (GUIInterna.isLoadPerformanceMode()) {
      StringBuilder pathsb=new StringBuilder();
      Component cc=source;
      Container ccpar=cc.getParent();
      while (ccpar != null) {
        Map namedChildren=ccpar.getComponents();
        for (Iterator it_chd=namedChildren.keySet().iterator(); it_chd.hasNext(); ) {
          String chdName=(String)it_chd.next();
          Component chd=ccpar.getComponent(chdName);
          if (chd == cc) {
            pathsb.append(chdName).append('!');
            break;
          }
        }
        cc=ccpar;
        ccpar=cc.getParent();
      }
      cubu.setComponentPath(pathsb.toString());
    }
    renderResult.incNestedLevel();
    InterceptHandlerInstance dhi=renderResult.getInterceptHandlerInstance();
    if (dhi != null) {
      cr=dhi.createInterceptComponentRenderer(cr);
    }
    try {
      int preRenderLength=sb.length();
      cr.render(this,sb,source,cubu,componentTranslator,renderResult,args);
      if (preRenderLength == sb.length()) {
        sb.append(""String_Node_Str"");
      }
      source.setDirty(false);
    }
 catch (    Exception e) {
      renderResult.setRenderExceptionInfo(""String_Node_Str"" + source.getComponentName() + ""String_Node_Str""+ source.getClass().getName()+ ""String_Node_Str""+ source.getListenerInfo()+ ""String_Node_Str""+ e.getMessage(),e);
    }
    renderResult.decNestedLevel();
    if (ajaxon && domReplaceable) {
      if (useSpan) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
    }
  }
 else {
    if (domReplaceable && (ajaxon || forceDebugDivs)) {
      if (useSpan) {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
    }
  }
}","/** 
 * used by the renderer, and also by the panel and tabbedpane renderer to delegate rendering
 * @param sb
 * @param source
 * @param args
 */
public void render(StringOutput sb,Component source,String[] args){
  GlobalSettings gset=getGlobalSettings();
  boolean ajaxon=gset.getAjaxFlags().isIframePostEnabled();
  boolean domReplaceable=source.isDomReplaceable();
  boolean useSpan=source.getSpanAsDomReplaceable();
  boolean forceDebugDivs=gset.isIdDivsForced();
  if (source.isVisible()) {
    int lev=renderResult.getNestedLevel();
    if (lev > 60)     throw new AssertException(""String_Node_Str"" + source.getComponentName());
    Translator componentTranslator=source.getTranslator();
    if (domReplaceable && (ajaxon || forceDebugDivs)) {
      if (useSpan) {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
    }
    ComponentRenderer cr=findComponentRenderer(source);
    URLBuilder cubu=urlBuilder.createCopyFor(source);
    if (GUIInterna.isLoadPerformanceMode()) {
      StringBuilder pathsb=new StringBuilder();
      Component cc=source;
      Container ccpar=cc.getParent();
      while (ccpar != null) {
        Map namedChildren=ccpar.getComponents();
        for (Iterator it_chd=namedChildren.keySet().iterator(); it_chd.hasNext(); ) {
          String chdName=(String)it_chd.next();
          Component chd=ccpar.getComponent(chdName);
          if (chd == cc) {
            pathsb.append(chdName).append('!');
            break;
          }
        }
        cc=ccpar;
        ccpar=cc.getParent();
      }
      cubu.setComponentPath(pathsb.toString());
    }
    renderResult.incNestedLevel();
    InterceptHandlerInstance dhi=renderResult.getInterceptHandlerInstance();
    if (dhi != null) {
      cr=dhi.createInterceptComponentRenderer(cr);
    }
    try {
      int preRenderLength=sb.length();
      cr.render(this,sb,source,cubu,componentTranslator,renderResult,args);
      if (preRenderLength == sb.length()) {
        sb.append(""String_Node_Str"");
      }
      source.setDirty(false);
    }
 catch (    Exception e) {
      renderResult.setRenderExceptionInfo(""String_Node_Str"" + source.getComponentName() + ""String_Node_Str""+ source.getClass().getName()+ ""String_Node_Str""+ source.getListenerInfo()+ ""String_Node_Str""+ e.getMessage(),e);
    }
    renderResult.decNestedLevel();
    if (ajaxon && domReplaceable) {
      if (useSpan) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
    }
  }
 else {
    if (domReplaceable && (ajaxon || forceDebugDivs)) {
      if (useSpan) {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"").append(source.getDispatchID()).append(""String_Node_Str"");
      }
    }
  }
}"
70032,"public void event(UserRequest ureq,Controller source,Event event){
  if (source == deleteYesNoController) {
    if (DialogBoxUIFactory.isYesEvent(event)) {
      Kalendar cal=kalendarEvent.getCalendar();
      CalendarManagerFactory.getInstance().getCalendarManager().removeEventFrom(cal,kalendarEvent);
      fireEvent(ureq,Event.DONE_EVENT);
    }
  }
 else   if (source == copyEventToCalendarController) {
    if (event.equals(Event.DONE_EVENT))     fireEvent(ureq,Event.DONE_EVENT);
 else     if (event.equals(Event.CANCELLED_EVENT))     mainPanel.setContent(mainVC);
  }
 else   if (source == activeLinkProvider) {
    if (kalendarEvent.getCalendar() != null) {
      fireEvent(ureq,Event.DONE_EVENT);
    }
  }
 else   if (source == eventForm) {
    if (event == Event.DONE_EVENT) {
      kalendarEvent=eventForm.getUpdatedKalendarEvent();
      boolean doneSuccessfully=true;
      if (isNew) {
        String calendarID=eventForm.getChoosenKalendarID();
        for (Iterator iter=availableCalendars.iterator(); iter.hasNext(); ) {
          KalendarRenderWrapper calendarWrapper=(KalendarRenderWrapper)iter.next();
          if (!calendarWrapper.getKalendar().getCalendarID().equals(calendarID))           continue;
          Kalendar cal=calendarWrapper.getKalendar();
          boolean result=CalendarManagerFactory.getInstance().getCalendarManager().addEventTo(cal,kalendarEvent);
          if (result == false) {
            doneSuccessfully=false;
          }
        }
      }
 else {
        Kalendar cal=kalendarEvent.getCalendar();
        doneSuccessfully=CalendarManagerFactory.getInstance().getCalendarManager().updateEventFrom(cal,kalendarEvent);
      }
      if (!doneSuccessfully) {
        showError(""String_Node_Str"");
        fireEvent(ureq,Event.FAILED_EVENT);
        return;
      }
      if (eventForm.isMulti()) {
        removeAsListenerAndDispose(copyEventToCalendarController);
        copyEventToCalendarController=new CopyEventToCalendarController(kalendarEvent,availableCalendars,getTranslator(),getWindowControl());
        listenTo(copyEventToCalendarController);
        mainPanel.setContent(copyEventToCalendarController.getInitialComponent());
        return;
      }
      fireEvent(ureq,Event.DONE_EVENT);
    }
 else     if (event == Event.CANCELLED_EVENT) {
      eventForm.setEntry(kalendarEvent);
      fireEvent(ureq,Event.DONE_EVENT);
    }
  }
 else   if (source == customMediaChooserCtr) {
    boolean doneSuccessfully=true;
    if (event instanceof URLChoosenEvent) {
      URLChoosenEvent urlEvent=(URLChoosenEvent)event;
      String url=urlEvent.getURL();
      List<KalendarEventLink> links=kalendarEvent.getKalendarEventLinks();
      String provider=customMediaChooserCtr.getClass().getSimpleName();
      String id=url;
      String displayName=StringHelper.containsNonWhitespace(urlEvent.getDisplayName()) ? urlEvent.getDisplayName() : url;
      String uri=url.contains(""String_Node_Str"") ? url : (Settings.getServerContextPathURI() + url);
      String iconCssClass=urlEvent.getIconCssClass();
      if (!StringHelper.containsNonWhitespace(iconCssClass)) {
        iconCssClass=CSSHelper.createFiletypeIconCssClassFor(url);
      }
      links.add(new KalendarEventLink(provider,id,displayName,uri,iconCssClass));
      Kalendar cal=kalendarEvent.getCalendar();
      doneSuccessfully=CalendarManagerFactory.getInstance().getCalendarManager().updateEventFrom(cal,kalendarEvent);
    }
    if (doneSuccessfully) {
      fireEvent(ureq,event);
    }
 else {
      showError(""String_Node_Str"");
      fireEvent(ureq,Event.FAILED_EVENT);
    }
  }
 else   if (source == externalLinksController || source == mediaLinksController) {
    Kalendar cal=kalendarEvent.getCalendar();
    if (kalendarEvent.getCalendar() != null) {
      boolean doneSuccessfully=CalendarManagerFactory.getInstance().getCalendarManager().updateEventFrom(cal,kalendarEvent);
      if (doneSuccessfully) {
        fireEvent(ureq,Event.DONE_EVENT);
      }
 else {
        showError(""String_Node_Str"");
        fireEvent(ureq,Event.FAILED_EVENT);
      }
    }
  }
}","public void event(UserRequest ureq,Controller source,Event event){
  if (source == deleteYesNoController) {
    if (DialogBoxUIFactory.isYesEvent(event)) {
      Kalendar cal=kalendarEvent.getCalendar();
      CalendarManagerFactory.getInstance().getCalendarManager().removeEventFrom(cal,kalendarEvent);
      fireEvent(ureq,Event.DONE_EVENT);
    }
  }
 else   if (source == copyEventToCalendarController) {
    if (event.equals(Event.DONE_EVENT))     fireEvent(ureq,Event.DONE_EVENT);
 else     if (event.equals(Event.CANCELLED_EVENT)) {
      eventForm.setMulti(false);
      mainPanel.setContent(mainVC);
    }
  }
 else   if (source == activeLinkProvider) {
    if (kalendarEvent.getCalendar() != null) {
      fireEvent(ureq,Event.DONE_EVENT);
    }
  }
 else   if (source == eventForm) {
    if (event == Event.DONE_EVENT) {
      kalendarEvent=eventForm.getUpdatedKalendarEvent();
      boolean doneSuccessfully=true;
      if (isNew) {
        String calendarID=eventForm.getChoosenKalendarID();
        for (Iterator iter=availableCalendars.iterator(); iter.hasNext(); ) {
          KalendarRenderWrapper calendarWrapper=(KalendarRenderWrapper)iter.next();
          if (!calendarWrapper.getKalendar().getCalendarID().equals(calendarID))           continue;
          Kalendar cal=calendarWrapper.getKalendar();
          boolean result=CalendarManagerFactory.getInstance().getCalendarManager().addEventTo(cal,kalendarEvent);
          if (result == false) {
            doneSuccessfully=false;
          }
        }
      }
 else {
        Kalendar cal=kalendarEvent.getCalendar();
        doneSuccessfully=CalendarManagerFactory.getInstance().getCalendarManager().updateEventFrom(cal,kalendarEvent);
      }
      if (!doneSuccessfully) {
        showError(""String_Node_Str"");
        fireEvent(ureq,Event.FAILED_EVENT);
        return;
      }
      if (eventForm.isMulti()) {
        removeAsListenerAndDispose(copyEventToCalendarController);
        copyEventToCalendarController=new CopyEventToCalendarController(kalendarEvent,availableCalendars,getTranslator(),getWindowControl());
        listenTo(copyEventToCalendarController);
        mainPanel.setContent(copyEventToCalendarController.getInitialComponent());
        return;
      }
      fireEvent(ureq,Event.DONE_EVENT);
    }
 else     if (event == Event.CANCELLED_EVENT) {
      eventForm.setEntry(kalendarEvent);
      fireEvent(ureq,Event.DONE_EVENT);
    }
  }
 else   if (source == customMediaChooserCtr) {
    boolean doneSuccessfully=true;
    if (event instanceof URLChoosenEvent) {
      URLChoosenEvent urlEvent=(URLChoosenEvent)event;
      String url=urlEvent.getURL();
      List<KalendarEventLink> links=kalendarEvent.getKalendarEventLinks();
      String provider=customMediaChooserCtr.getClass().getSimpleName();
      String id=url;
      String displayName=StringHelper.containsNonWhitespace(urlEvent.getDisplayName()) ? urlEvent.getDisplayName() : url;
      String uri=url.contains(""String_Node_Str"") ? url : (Settings.getServerContextPathURI() + url);
      String iconCssClass=urlEvent.getIconCssClass();
      if (!StringHelper.containsNonWhitespace(iconCssClass)) {
        iconCssClass=CSSHelper.createFiletypeIconCssClassFor(url);
      }
      links.add(new KalendarEventLink(provider,id,displayName,uri,iconCssClass));
      Kalendar cal=kalendarEvent.getCalendar();
      doneSuccessfully=CalendarManagerFactory.getInstance().getCalendarManager().updateEventFrom(cal,kalendarEvent);
    }
    if (doneSuccessfully) {
      fireEvent(ureq,event);
    }
 else {
      showError(""String_Node_Str"");
      fireEvent(ureq,Event.FAILED_EVENT);
    }
  }
 else   if (source == externalLinksController || source == mediaLinksController) {
    Kalendar cal=kalendarEvent.getCalendar();
    if (kalendarEvent.getCalendar() != null) {
      boolean doneSuccessfully=CalendarManagerFactory.getInstance().getCalendarManager().updateEventFrom(cal,kalendarEvent);
      if (doneSuccessfully) {
        fireEvent(ureq,Event.DONE_EVENT);
      }
 else {
        showError(""String_Node_Str"");
        fireEvent(ureq,Event.FAILED_EVENT);
      }
    }
  }
}"
70033,"/** 
 * 1. Calculate if the node should be accessible at all. <br/> 2. If the coursenode is visible, build a treenode.
 */
public void build(){
  for (Iterator iter=accesses.values().iterator(); iter.hasNext(); ) {
    Boolean entry=(Boolean)iter.next();
    atLeastOneAccessible=atLeastOneAccessible || entry.booleanValue();
  }
  if (isVisible()) {
    gtn=new GenericTreeNode();
    gtn.setTitle(courseNode.getShortTitle());
    gtn.setAltText(courseNode.getLongTitle());
    String type=courseNode.getType();
    CourseNodeConfiguration cnConfig=CourseNodeFactory.getInstance().getCourseNodeConfigurationEvenForDisabledBB(type);
    String nodeCssClass=cnConfig.getIconCSSClass();
    gtn.setIconCssClass(nodeCssClass);
    gtn.setUserObject(this);
    gtn.setAccessible(true);
  }
}","/** 
 * 1. Calculate if the node should be accessible at all. <br/> 2. If the coursenode is visible, build a treenode.
 */
public void build(){
  for (Iterator iter=accesses.values().iterator(); iter.hasNext(); ) {
    Boolean entry=(Boolean)iter.next();
    atLeastOneAccessible=atLeastOneAccessible || entry.booleanValue();
  }
  if (isVisible()) {
    gtn=new GenericTreeNode();
    gtn.setTitle(courseNode.getShortTitle());
    gtn.setAltText(courseNode.getLongTitle());
    String type=courseNode.getType();
    CourseNodeConfiguration cnConfig=CourseNodeFactory.getInstance().getCourseNodeConfigurationEvenForDisabledBB(type);
    if (cnConfig != null) {
      String nodeCssClass=cnConfig.getIconCSSClass();
      gtn.setIconCssClass(nodeCssClass);
    }
    gtn.setUserObject(this);
    gtn.setAccessible(true);
  }
}"
70034,"public void event(UserRequest ureq,Controller source,Event event){
  if (source == editorCtr) {
    if (event == Event.DONE_EVENT) {
      fireEvent(ureq,new FolderEvent(FolderEvent.NEW_FILE_EVENT,fileName));
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
 else     if (event == Event.CANCELLED_EVENT) {
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
  }
 else   if (source == createFileForm) {
    if (event == Event.CANCELLED_EVENT) {
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
 else     if (event == Event.FAILED_EVENT) {
      status=FolderCommandStatus.STATUS_FAILED;
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
 else     if (event == Event.DONE_EVENT) {
      String relFilePath=""String_Node_Str"" + fileName;
      if (!folderComponent.getCurrentContainerPath().equals(""String_Node_Str"")) {
        relFilePath=folderComponent.getCurrentContainerPath() + relFilePath;
      }
      VFSContainer writableRootContainer=folderComponent.getRootContainer();
      Object[] result=VFSManager.findWritableRootFolderFor(writableRootContainer,relFilePath);
      if (result != null) {
        writableRootContainer=(VFSContainer)result[0];
        relFilePath=(String)result[1];
      }
 else {
        relFilePath=fileName;
        writableRootContainer=folderComponent.getCurrentContainer();
      }
      if (relFilePath.endsWith(""String_Node_Str"") || relFilePath.endsWith(""String_Node_Str"")) {
        editorCtr=WysiwygFactory.createWysiwygController(ureq,getWindowControl(),writableRootContainer,relFilePath,true);
        ((HTMLEditorController)editorCtr).setNewFile(true);
      }
 else {
        editorCtr=new PlainTextEditorController(ureq,getWindowControl(),(VFSLeaf)writableRootContainer.resolve(relFilePath),""String_Node_Str"",true,true,null);
      }
      this.listenTo(editorCtr);
      mainPanel.setContent(editorCtr.getInitialComponent());
    }
  }
}","public void event(UserRequest ureq,Controller source,Event event){
  if (source == editorCtr) {
    if (event == Event.DONE_EVENT) {
      fireEvent(ureq,new FolderEvent(FolderEvent.NEW_FILE_EVENT,fileName));
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
 else     if (event == Event.CANCELLED_EVENT) {
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
  }
 else   if (source == createFileForm) {
    if (event == Event.CANCELLED_EVENT) {
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
 else     if (event == Event.FAILED_EVENT) {
      status=FolderCommandStatus.STATUS_FAILED;
      fireEvent(ureq,FolderCommand.FOLDERCOMMAND_FINISHED);
    }
 else     if (event == Event.DONE_EVENT) {
      String relFilePath=""String_Node_Str"" + fileName;
      if (!folderComponent.getCurrentContainerPath().equals(""String_Node_Str"")) {
        relFilePath=folderComponent.getCurrentContainerPath() + relFilePath;
      }
      VFSContainer writableRootContainer=folderComponent.getRootContainer();
      ContainerAndFile result=VFSManager.findWritableRootFolderFor(writableRootContainer,relFilePath);
      if (result != null) {
        writableRootContainer=result.getContainer();
        relFilePath=result.getFileName();
      }
 else {
        relFilePath=fileName;
        writableRootContainer=folderComponent.getCurrentContainer();
      }
      if (relFilePath.endsWith(""String_Node_Str"") || relFilePath.endsWith(""String_Node_Str"")) {
        editorCtr=WysiwygFactory.createWysiwygController(ureq,getWindowControl(),writableRootContainer,relFilePath,true);
        ((HTMLEditorController)editorCtr).setNewFile(true);
      }
 else {
        editorCtr=new PlainTextEditorController(ureq,getWindowControl(),(VFSLeaf)writableRootContainer.resolve(relFilePath),""String_Node_Str"",true,true,null);
      }
      this.listenTo(editorCtr);
      mainPanel.setContent(editorCtr.getInitialComponent());
    }
  }
}"
70035,"/** 
 * @see org.olat.modules.bc.commands.FolderCommand#execute(org.olat.modules.bc.components.FolderComponent,org.olat.core.gui.UserRequest,org.olat.core.gui.control.WindowControl,org.olat.core.gui.translator.Translator)
 */
public Controller execute(FolderComponent folderComponent,UserRequest ureq,WindowControl wControl,Translator translator){
  String pos=ureq.getParameter(ListRenderer.PARAM_CONTENTEDITID);
  if (!StringHelper.containsNonWhitespace(pos)) {
    status=FolderCommandStatus.STATUS_FAILED;
    getWindowControl().setError(translator.translate(""String_Node_Str""));
    return null;
  }
  status=FolderCommandHelper.sanityCheck(wControl,folderComponent);
  if (status == FolderCommandStatus.STATUS_SUCCESS) {
    currentItem=folderComponent.getCurrentContainerChildren().get(Integer.parseInt(pos));
    status=FolderCommandHelper.sanityCheck2(wControl,folderComponent,ureq,currentItem);
  }
  if (status == FolderCommandStatus.STATUS_FAILED) {
    return null;
  }
  status=FolderCommandHelper.fileEditSanityCheck(currentItem);
  if (status == FolderCommandStatus.STATUS_FAILED) {
    logWarn(""String_Node_Str"" + folderComponent.getCurrentContainerPath() + ""String_Node_Str""+ currentItem.getName(),null);
    getWindowControl().setError(translator.translate(""String_Node_Str""));
    return null;
  }
  if (MetaInfoHelper.isLocked(currentItem,ureq)) {
    List<String> lockedFiles=Collections.singletonList(currentItem.getName());
    String msg=MetaInfoHelper.renderLockedMessageAsHtml(translator,folderComponent.getCurrentContainer(),lockedFiles);
    List<String> buttonLabels=Collections.singletonList(translator.translate(""String_Node_Str""));
    lockedFiledCtr=activateGenericDialog(ureq,translator.translate(""String_Node_Str""),msg,buttonLabels,lockedFiledCtr);
    return null;
  }
  String relFilePath=""String_Node_Str"" + currentItem.getName();
  if (!folderComponent.getCurrentContainerPath().equals(""String_Node_Str"")) {
    relFilePath=folderComponent.getCurrentContainerPath() + relFilePath;
  }
  VFSContainer writableRootContainer=folderComponent.getRootContainer();
  Object[] result=VFSManager.findWritableRootFolderFor(writableRootContainer,relFilePath);
  if (result != null) {
    writableRootContainer=(VFSContainer)result[0];
    relFilePath=(String)result[1];
  }
 else {
    relFilePath=currentItem.getName();
    writableRootContainer=folderComponent.getCurrentContainer();
  }
  if (relFilePath.endsWith(""String_Node_Str"") || relFilePath.endsWith(""String_Node_Str"")) {
    CustomLinkTreeModel customLinkTreeModel=folderComponent.getCustomLinkTreeModel();
    if (customLinkTreeModel != null) {
      editorc=WysiwygFactory.createWysiwygControllerWithInternalLink(ureq,getWindowControl(),writableRootContainer,relFilePath,true,customLinkTreeModel);
      ((HTMLEditorController)editorc).setNewFile(false);
    }
 else {
      editorc=WysiwygFactory.createWysiwygController(ureq,getWindowControl(),writableRootContainer,relFilePath,true);
      ((HTMLEditorController)editorc).setNewFile(false);
    }
  }
 else {
    editorc=new PlainTextEditorController(ureq,getWindowControl(),(VFSLeaf)currentItem,""String_Node_Str"",true,false,null);
  }
  listenTo(editorc);
  putInitialPanel(editorc.getInitialComponent());
  return this;
}","/** 
 * @see org.olat.modules.bc.commands.FolderCommand#execute(org.olat.modules.bc.components.FolderComponent,org.olat.core.gui.UserRequest,org.olat.core.gui.control.WindowControl,org.olat.core.gui.translator.Translator)
 */
public Controller execute(FolderComponent folderComponent,UserRequest ureq,WindowControl wControl,Translator translator){
  String pos=ureq.getParameter(ListRenderer.PARAM_CONTENTEDITID);
  if (!StringHelper.containsNonWhitespace(pos)) {
    status=FolderCommandStatus.STATUS_FAILED;
    getWindowControl().setError(translator.translate(""String_Node_Str""));
    return null;
  }
  status=FolderCommandHelper.sanityCheck(wControl,folderComponent);
  if (status == FolderCommandStatus.STATUS_SUCCESS) {
    currentItem=folderComponent.getCurrentContainerChildren().get(Integer.parseInt(pos));
    status=FolderCommandHelper.sanityCheck2(wControl,folderComponent,ureq,currentItem);
  }
  if (status == FolderCommandStatus.STATUS_FAILED) {
    return null;
  }
  status=FolderCommandHelper.fileEditSanityCheck(currentItem);
  if (status == FolderCommandStatus.STATUS_FAILED) {
    logWarn(""String_Node_Str"" + folderComponent.getCurrentContainerPath() + ""String_Node_Str""+ currentItem.getName(),null);
    getWindowControl().setError(translator.translate(""String_Node_Str""));
    return null;
  }
  if (MetaInfoHelper.isLocked(currentItem,ureq)) {
    List<String> lockedFiles=Collections.singletonList(currentItem.getName());
    String msg=MetaInfoHelper.renderLockedMessageAsHtml(translator,folderComponent.getCurrentContainer(),lockedFiles);
    List<String> buttonLabels=Collections.singletonList(translator.translate(""String_Node_Str""));
    lockedFiledCtr=activateGenericDialog(ureq,translator.translate(""String_Node_Str""),msg,buttonLabels,lockedFiledCtr);
    return null;
  }
  String relFilePath=""String_Node_Str"" + currentItem.getName();
  if (!folderComponent.getCurrentContainerPath().equals(""String_Node_Str"")) {
    relFilePath=folderComponent.getCurrentContainerPath() + relFilePath;
  }
  VFSContainer writableRootContainer=folderComponent.getRootContainer();
  ContainerAndFile result=VFSManager.findWritableRootFolderFor(writableRootContainer,relFilePath);
  if (result != null) {
    writableRootContainer=result.getContainer();
    relFilePath=currentItem.getName();
  }
 else {
    relFilePath=currentItem.getName();
    writableRootContainer=folderComponent.getCurrentContainer();
  }
  if (relFilePath.endsWith(""String_Node_Str"") || relFilePath.endsWith(""String_Node_Str"")) {
    CustomLinkTreeModel customLinkTreeModel=folderComponent.getCustomLinkTreeModel();
    if (customLinkTreeModel != null) {
      editorc=WysiwygFactory.createWysiwygControllerWithInternalLink(ureq,getWindowControl(),writableRootContainer,relFilePath,true,customLinkTreeModel);
      ((HTMLEditorController)editorc).setNewFile(false);
    }
 else {
      editorc=WysiwygFactory.createWysiwygController(ureq,getWindowControl(),writableRootContainer,relFilePath,true);
      ((HTMLEditorController)editorc).setNewFile(false);
    }
  }
 else {
    editorc=new PlainTextEditorController(ureq,getWindowControl(),(VFSLeaf)currentItem,""String_Node_Str"",true,false,null);
  }
  listenTo(editorc);
  putInitialPanel(editorc.getInitialComponent());
  return this;
}"
70036,"/** 
 * @see org.olat.core.util.vfs.VFSItem#resolveFile(java.lang.String)
 */
public VFSItem resolve(String path){
  path=VFSManager.sanitizePath(path);
  if (path.equals(""String_Node_Str""))   return this;
  String childName=VFSManager.extractChild(path);
  VFSItem vfsItem=null;
  for (Iterator iter=mergedContainers.iterator(); iter.hasNext(); ) {
    VFSContainer container=(VFSContainer)iter.next();
    String nextPath=path.substring(childName.length() + 1);
    boolean nameMatch=container.getName().equals(childName);
    if (container instanceof NamedContainerImpl && !nameMatch) {
      container=((NamedContainerImpl)container).getDelegate();
      String name=container.getName();
      if (name == null) {
        continue;
      }
      nameMatch=name.equals(childName);
    }
    if (nameMatch) {
      vfsItem=container.resolve(nextPath);
      if (vfsItem != null && vfsItem instanceof VFSContainer) {
        VFSContainer resolvedContainer=(VFSContainer)vfsItem;
        resolvedContainer.setDefaultItemFilter(defaultFilter);
      }
      return vfsItem;
    }
  }
  for (Iterator iter=mergedContainersChildren.iterator(); iter.hasNext(); ) {
    VFSContainer container=(VFSContainer)iter.next();
    if (container instanceof NamedContainerImpl) {
      container=((NamedContainerImpl)container).getDelegate();
    }
    vfsItem=container.resolve(path);
    if (vfsItem != null) {
      if (vfsItem instanceof VFSContainer) {
        VFSContainer resolvedContainer=(VFSContainer)vfsItem;
        resolvedContainer.setDefaultItemFilter(defaultFilter);
      }
      return vfsItem;
    }
  }
  return null;
}","/** 
 * @see org.olat.core.util.vfs.VFSItem#resolveFile(java.lang.String)
 */
public VFSItem resolve(String path){
  path=VFSManager.sanitizePath(path);
  if (path.equals(""String_Node_Str""))   return this;
  String childName=VFSManager.extractChild(path);
  VFSItem vfsItem=null;
  for (  VFSContainer container : mergedContainers) {
    String nextPath=path.substring(childName.length() + 1);
    boolean nameMatch=container.getName().equals(childName);
    if (container instanceof NamedContainerImpl && !nameMatch) {
      container=((NamedContainerImpl)container).getDelegate();
      String name=container.getName();
      if (name == null) {
        continue;
      }
      nameMatch=name.equals(childName);
    }
    if (nameMatch) {
      vfsItem=container.resolve(nextPath);
      if (vfsItem != null && vfsItem instanceof VFSContainer) {
        VFSContainer resolvedContainer=(VFSContainer)vfsItem;
        resolvedContainer.setDefaultItemFilter(defaultFilter);
      }
      return vfsItem;
    }
  }
  for (  VFSContainer container : mergedContainersChildren) {
    if (container instanceof NamedContainerImpl) {
      container=((NamedContainerImpl)container).getDelegate();
    }
    vfsItem=container.resolve(path);
    if (vfsItem != null) {
      if (vfsItem instanceof VFSContainer) {
        VFSContainer resolvedContainer=(VFSContainer)vfsItem;
        resolvedContainer.setDefaultItemFilter(defaultFilter);
      }
      return vfsItem;
    }
  }
  return null;
}"
70037,"/** 
 * @see org.olat.core.util.vfs.VFSContainer#getItems(org.olat.core.util.vfs.filters.VFSItemFilter)
 */
public List getItems(VFSItemFilter filter){
  List all=new ArrayList();
  if (filter == null && defaultFilter == null) {
    all.addAll(mergedContainers);
  }
 else {
    for (Iterator iter=mergedContainers.iterator(); iter.hasNext(); ) {
      VFSContainer mergedContainer=(VFSContainer)iter.next();
      boolean passedFilter=true;
      if (defaultFilter != null && !defaultFilter.accept(mergedContainer))       passedFilter=false;
      if (passedFilter && filter != null && !filter.accept(mergedContainer))       passedFilter=false;
      if (passedFilter)       all.add(mergedContainer);
    }
  }
  for (Iterator iter=mergedContainersChildren.iterator(); iter.hasNext(); ) {
    VFSContainer container=(VFSContainer)iter.next();
    all.addAll(container.getItems(filter));
  }
  return all;
}","/** 
 * @see org.olat.core.util.vfs.VFSContainer#getItems(org.olat.core.util.vfs.filters.VFSItemFilter)
 */
public List<VFSItem> getItems(VFSItemFilter filter){
  List<VFSItem> all=new ArrayList<VFSItem>();
  if (filter == null && defaultFilter == null) {
    all.addAll(mergedContainers);
  }
 else {
    for (    VFSContainer mergedContainer : mergedContainers) {
      boolean passedFilter=true;
      if (defaultFilter != null && !defaultFilter.accept(mergedContainer))       passedFilter=false;
      if (passedFilter && filter != null && !filter.accept(mergedContainer))       passedFilter=false;
      if (passedFilter)       all.add(mergedContainer);
    }
  }
  for (  VFSContainer container : mergedContainersChildren) {
    all.addAll(container.getItems(filter));
  }
  return all;
}"
70038,"/** 
 */
public MergeSource(VFSContainer parentContainer,String name){
  super(name);
  this.parentContainer=parentContainer;
  this.mergedContainers=new ArrayList();
  this.mergedContainersChildren=new ArrayList();
}","/** 
 */
public MergeSource(VFSContainer parentContainer,String name){
  super(name);
  this.parentContainer=parentContainer;
  this.mergedContainers=new ArrayList<VFSContainer>();
  this.mergedContainersChildren=new ArrayList<VFSContainer>();
}"
70039,"private boolean isContainerNameTaken(String containerName){
  for (Iterator iter=mergedContainers.iterator(); iter.hasNext(); ) {
    VFSContainer mergedContainer=(VFSContainer)iter.next();
    if (mergedContainer.getName().equals(containerName))     return true;
  }
  return false;
}","private boolean isContainerNameTaken(String containerName){
  for (Iterator<VFSContainer> iter=mergedContainers.iterator(); iter.hasNext(); ) {
    VFSContainer mergedContainer=iter.next();
    if (mergedContainer.getName().equals(containerName))     return true;
  }
  return false;
}"
70040,"private static Object[] findWritableRootFolderForRecursion(VFSContainer rootDir,String relFilePath,int recursionLevel){
  recursionLevel++;
  if (recursionLevel > 20) {
    log.warn(""String_Node_Str"" + rootDir + ""String_Node_Str""+ relFilePath);
    return null;
  }
  if (rootDir instanceof NamedContainerImpl) {
    rootDir=((NamedContainerImpl)rootDir).delegate;
  }
  if (rootDir instanceof MergeSource) {
    VFSContainer rootWriteContainer=((MergeSource)rootDir).getRootWriteContainer();
    if (rootWriteContainer == null) {
      List<VFSItem> children=rootDir.getItems();
      String nextChildName=relFilePath.substring(1,relFilePath.indexOf(""String_Node_Str"",1));
      if (children.size() == 0) {
        return null;
      }
      for (      VFSItem child : children) {
        if (child.getName().equals(nextChildName)) {
          if (child instanceof VFSContainer) {
            rootDir=(VFSContainer)child;
            relFilePath=relFilePath.substring(relFilePath.indexOf(""String_Node_Str"",1));
            break;
          }
 else {
            return null;
          }
        }
      }
    }
 else {
      rootDir=rootWriteContainer;
    }
  }
  if (rootDir != null && rootDir instanceof LocalFolderImpl) {
    return new Object[]{rootDir,relFilePath};
  }
 else {
    return findWritableRootFolderForRecursion(rootDir,relFilePath,recursionLevel);
  }
}","private static ContainerAndFile findWritableRootFolderForRecursion(VFSContainer rootDir,String relFilePath,int recursionLevel){
  recursionLevel++;
  if (recursionLevel > 20) {
    log.warn(""String_Node_Str"" + rootDir + ""String_Node_Str""+ relFilePath);
    return null;
  }
  if (rootDir instanceof NamedContainerImpl) {
    rootDir=((NamedContainerImpl)rootDir).getDelegate();
  }
  if (rootDir instanceof MergeSource) {
    MergeSource mergedDir=(MergeSource)rootDir;
    int stop=relFilePath.indexOf(""String_Node_Str"",1);
    if (stop > 0) {
      String nextLevel=extractChild(relFilePath);
      VFSItem item=mergedDir.resolve(nextLevel);
      if (item instanceof NamedContainerImpl) {
        item=((NamedContainerImpl)item).getDelegate();
      }
      if (item instanceof MergeSource) {
        rootDir=(MergeSource)item;
        relFilePath=relFilePath.substring(stop);
        return findWritableRootFolderForRecursion(rootDir,relFilePath,recursionLevel);
      }
    }
    VFSContainer rootWriteContainer=mergedDir.getRootWriteContainer();
    if (rootWriteContainer == null) {
      List<VFSItem> children=rootDir.getItems();
      if (children.isEmpty()) {
        return null;
      }
      String nextChildName=relFilePath.substring(1,relFilePath.indexOf(""String_Node_Str"",1));
      for (      VFSItem child : children) {
        if (child.getName().equals(nextChildName)) {
          if (child instanceof VFSContainer) {
            rootDir=(VFSContainer)child;
            relFilePath=relFilePath.substring(relFilePath.indexOf(""String_Node_Str"",1));
            break;
          }
 else {
            return null;
          }
        }
      }
    }
 else {
      rootDir=rootWriteContainer;
    }
  }
  if (rootDir != null && rootDir instanceof LocalFolderImpl) {
    return new ContainerAndFile(rootDir,relFilePath);
  }
 else {
    return findWritableRootFolderForRecursion(rootDir,relFilePath,recursionLevel);
  }
}"
70041,"/** 
 * This method takes a VFSContainer and a relative path to a file that exists within this container. The method checks if the given container is a writable container that can be used e.g. by the HTML editor as a base directory where to store some things. If the method detects that this is not the case it works against the relative file path and checks each directory in the path. <br> The result will be an object array that contains the corrected container and the new relative path. If no writable container could be found NULL is returned. <br> Limitations: the method stops at least after 20 iterations returning NULL
 * @param rootDir the container that should be checked
 * @param relFilePath The valid file path within this container
 * @return Object array that contains 1) a writable rootDir and 2) thecorrected relFilePath that mathes to the new rootDir. Can be NULL if no writable root folder could be found.
 */
public static Object[] findWritableRootFolderFor(VFSContainer rootDir,String relFilePath){
  int level=0;
  return findWritableRootFolderForRecursion(rootDir,relFilePath,level);
}","/** 
 * This method takes a VFSContainer and a relative path to a file that exists within this container. The method checks if the given container is a writable container that can be used e.g. by the HTML editor as a base directory where to store some things. If the method detects that this is not the case it works against the relative file path and checks each directory in the path. <br> The result will be an object array that contains the corrected container and the new relative path. If no writable container could be found NULL is returned. <br> Limitations: the method stops at least after 20 iterations returning NULL
 * @param rootDir the container that should be checked
 * @param relFilePath The valid file path within this container
 * @return Object array that contains 1) a writable rootDir and 2) thecorrected relFilePath that mathes to the new rootDir. Can be NULL if no writable root folder could be found.
 */
public static ContainerAndFile findWritableRootFolderFor(VFSContainer rootDir,String relFilePath){
  int level=0;
  return findWritableRootFolderForRecursion(rootDir,relFilePath,level);
}"
70042,"@Override public String getAction(int row){
  int sortedRow=table.getSortedRow(row);
  ViteroBooking booking=(ViteroBooking)getTable().getTableDataModel().getObject(sortedRow);
  if (viteroManager.canGoBooking(booking)) {
    Object state=getTable().getTableDataModel().getValueAt(sortedRow,ViteroBookingDataModel.Column.sign.ordinal());
    if (Sign.signout.equals(state)) {
      return super.getAction(row);
    }
  }
  return null;
}","@Override public String getAction(int row){
  int sortedRow=table.getSortedRow(row);
  ViteroBooking booking=(ViteroBooking)getTable().getTableDataModel().getObject(sortedRow);
  if (viteroManager.canGoBooking(booking)) {
    if (booking.isAutoSignIn()) {
      Object state=getTable().getTableDataModel().getValueAt(sortedRow,ViteroBookingDataModel.Column.sign.ordinal());
      if (Sign.signout.equals(state)) {
        return super.getAction(row);
      }
    }
 else {
      return super.getAction(row);
    }
  }
  return null;
}"
70043,"@Override public void renderValue(StringOutput sb,int row,Renderer renderer){
  int sortedRow=table.getSortedRow(row);
  ViteroBooking booking=(ViteroBooking)getTable().getTableDataModel().getObject(sortedRow);
  if (viteroManager.canGoBooking(booking)) {
    Object state=getTable().getTableDataModel().getValueAt(sortedRow,ViteroBookingDataModel.Column.sign.ordinal());
    if (Sign.signout.equals(state)) {
      sb.append(translator.translate(getHeaderKey()));
    }
  }
}","@Override public void renderValue(StringOutput sb,int row,Renderer renderer){
  int sortedRow=table.getSortedRow(row);
  ViteroBooking booking=(ViteroBooking)getTable().getTableDataModel().getObject(sortedRow);
  if (viteroManager.canGoBooking(booking)) {
    if (booking.isAutoSignIn()) {
      Object state=getTable().getTableDataModel().getValueAt(sortedRow,ViteroBookingDataModel.Column.sign.ordinal());
      if (Sign.signout.equals(state)) {
        sb.append(translator.translate(getHeaderKey()));
      }
    }
 else {
      sb.append(translator.translate(getHeaderKey()));
    }
  }
}"
70044,"@Override protected void initDefaultProperties(){
  String homesRoot=getStringConfigParameter(CONFIG_ROOT,System.getProperty(""String_Node_Str"") + ""String_Node_Str"",false);
  if (Settings.isJUnitTest()) {
    FolderConfig.setFolderRoot(homesRoot + ""String_Node_Str"");
  }
 else {
    FolderConfig.setFolderRoot(homesRoot);
  }
  log.info(""String_Node_Str"" + FolderConfig.getCanonicalRoot() + ""String_Node_Str"");
  int maxULMB=getIntConfigParameter(CONFIG_LIMITULMB,100);
  FolderConfig.setLimitULKB(maxULMB * 1024);
  log.info(""String_Node_Str"" + FolderConfig.getLimitULKB() + ""String_Node_Str"");
  int quotaMB=getIntConfigParameter(CONFIG_QUOTAMB,100);
  FolderConfig.setDefaultQuotaKB(quotaMB * 1024);
  log.info(""String_Node_Str"" + FolderConfig.getDefaultQuotaKB() + ""String_Node_Str"");
  boolean sendDocLinkyOnly=getBooleanConfigParameter(CONFIG_SENDDOCLINKONLY,true);
  FolderConfig.setSendDocumentLinkOnly(sendDocLinkyOnly);
  boolean sendDocToExtern=getBooleanConfigParameter(CONFIG_SENDDOCTOEXTERN,false);
  FolderConfig.setSendDocumentToExtern(sendDocToExtern);
  File fTmp=new File(FolderConfig.getCanonicalTmpDir());
  fTmp.mkdirs();
}","@Override protected void initDefaultProperties(){
  File defaultHome=new File(System.getProperty(""String_Node_Str""),""String_Node_Str"");
  String homesRoot=getStringConfigParameter(CONFIG_ROOT,defaultHome.getAbsolutePath(),false);
  if (Settings.isJUnitTest()) {
    FolderConfig.setFolderRoot(homesRoot + ""String_Node_Str"");
  }
 else {
    FolderConfig.setFolderRoot(homesRoot);
  }
  log.info(""String_Node_Str"" + FolderConfig.getCanonicalRoot() + ""String_Node_Str"");
  int maxULMB=getIntConfigParameter(CONFIG_LIMITULMB,100);
  FolderConfig.setLimitULKB(maxULMB * 1024);
  log.info(""String_Node_Str"" + FolderConfig.getLimitULKB() + ""String_Node_Str"");
  int quotaMB=getIntConfigParameter(CONFIG_QUOTAMB,100);
  FolderConfig.setDefaultQuotaKB(quotaMB * 1024);
  log.info(""String_Node_Str"" + FolderConfig.getDefaultQuotaKB() + ""String_Node_Str"");
  boolean sendDocLinkyOnly=getBooleanConfigParameter(CONFIG_SENDDOCLINKONLY,true);
  FolderConfig.setSendDocumentLinkOnly(sendDocLinkyOnly);
  boolean sendDocToExtern=getBooleanConfigParameter(CONFIG_SENDDOCTOEXTERN,false);
  FolderConfig.setSendDocumentToExtern(sendDocToExtern);
  File fTmp=new File(FolderConfig.getCanonicalTmpDir());
  fTmp.mkdirs();
}"
70045,"public String getAuthor(){
  if (versionFile instanceof MetaTagged) {
    MetaInfo info=((MetaTagged)versionFile).getMetaInfo();
    return info.getAuthor();
  }
  return ""String_Node_Str"";
}","public String getAuthor(){
  return versions.getAuthor();
}"
70046,"public RevisionListController(UserRequest ureq,WindowControl wControl,Versionable versionedFile,String title,String description){
  super(ureq,wControl);
  this.versionedFile=versionedFile;
  TableGuiConfiguration summaryTableConfig=new TableGuiConfiguration();
  summaryTableConfig.setDownloadOffered(true);
  summaryTableConfig.setTableEmptyMessage(getTranslator().translate(""String_Node_Str""));
  revisionListTableCtr=new TableController(summaryTableConfig,ureq,getWindowControl(),getTranslator());
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",0,null,ureq.getLocale()){
    @Override public int compareTo(    int rowa,    int rowb){
      Object a=table.getTableDataModel().getValueAt(rowa,dataColumn);
      Object b=table.getTableDataModel().getValueAt(rowb,dataColumn);
      if (a == null || b == null) {
        boolean bb=(b == null);
        return (a == null) ? (bb ? 0 : -1) : (bb ? 1 : 0);
      }
      try {
        Long la=new Long((String)a);
        Long lb=new Long((String)b);
        return la.compareTo(lb);
      }
 catch (      NumberFormatException e) {
        return super.compareTo(rowa,rowb);
      }
    }
  }
);
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",1,null,ureq.getLocale()));
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",2,null,ureq.getLocale()));
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",3,null,ureq.getLocale()));
  revisionListTableCtr.addColumnDescriptor(new StaticColumnDescriptor(CMD_DOWNLOAD,""String_Node_Str"",getTranslator().translate(""String_Node_Str"")));
  revisionListTableCtr.addColumnDescriptor(new StaticColumnDescriptor(CMD_RESTORE,""String_Node_Str"",getTranslator().translate(""String_Node_Str"")));
  revisionListTableCtr.addMultiSelectAction(""String_Node_Str"",CMD_DELETE);
  revisionListTableCtr.addMultiSelectAction(""String_Node_Str"",CMD_CANCEL);
  revisionListTableCtr.setMultiSelect(true);
  List<VFSRevision> revisions=new ArrayList<VFSRevision>(versionedFile.getVersions().getRevisions());
  revisions.add(new CurrentRevision((VFSLeaf)versionedFile));
  revisionListTableCtr.setTableDataModel(new RevisionListDataModel(revisions,ureq.getLocale()));
  listenTo(revisionListTableCtr);
  mainVC=createVelocityContainer(""String_Node_Str"");
  mainVC.put(""String_Node_Str"",revisionListTableCtr.getInitialComponent());
  if (StringHelper.containsNonWhitespace(title)) {
    mainVC.contextPut(""String_Node_Str"",title);
  }
  if (StringHelper.containsNonWhitespace(description)) {
    mainVC.contextPut(""String_Node_Str"",description);
  }
  putInitialPanel(mainVC);
}","public RevisionListController(UserRequest ureq,WindowControl wControl,Versionable versionedFile,String title,String description){
  super(ureq,wControl);
  VFSLeaf versionedLeaf=null;
  if (versionedFile instanceof VFSLeaf) {
    versionedLeaf=(VFSLeaf)versionedFile;
  }
  if (versionedLeaf != null && versionedLeaf.getParentContainer() != null) {
    versionedLeaf=(VFSLeaf)versionedLeaf.getParentContainer().resolve(((VFSLeaf)versionedFile).getName());
    if (versionedLeaf instanceof Versionable) {
      versionedFile=(Versionable)versionedLeaf;
    }
  }
  this.versionedFile=versionedFile;
  TableGuiConfiguration summaryTableConfig=new TableGuiConfiguration();
  summaryTableConfig.setDownloadOffered(true);
  summaryTableConfig.setTableEmptyMessage(getTranslator().translate(""String_Node_Str""));
  revisionListTableCtr=new TableController(summaryTableConfig,ureq,getWindowControl(),getTranslator());
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",0,null,ureq.getLocale()){
    @Override public int compareTo(    int rowa,    int rowb){
      Object a=table.getTableDataModel().getValueAt(rowa,dataColumn);
      Object b=table.getTableDataModel().getValueAt(rowb,dataColumn);
      if (a == null || b == null) {
        boolean bb=(b == null);
        return (a == null) ? (bb ? 0 : -1) : (bb ? 1 : 0);
      }
      try {
        Long la=new Long((String)a);
        Long lb=new Long((String)b);
        return la.compareTo(lb);
      }
 catch (      NumberFormatException e) {
        return super.compareTo(rowa,rowb);
      }
    }
  }
);
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",1,null,ureq.getLocale()));
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",2,null,ureq.getLocale()));
  revisionListTableCtr.addColumnDescriptor(new DefaultColumnDescriptor(""String_Node_Str"",3,null,ureq.getLocale()));
  revisionListTableCtr.addColumnDescriptor(new StaticColumnDescriptor(CMD_DOWNLOAD,""String_Node_Str"",getTranslator().translate(""String_Node_Str"")));
  revisionListTableCtr.addColumnDescriptor(new StaticColumnDescriptor(CMD_RESTORE,""String_Node_Str"",getTranslator().translate(""String_Node_Str"")));
  revisionListTableCtr.addMultiSelectAction(""String_Node_Str"",CMD_DELETE);
  revisionListTableCtr.addMultiSelectAction(""String_Node_Str"",CMD_CANCEL);
  revisionListTableCtr.setMultiSelect(true);
  Versions versions=versionedFile.getVersions();
  List<VFSRevision> revisions=new ArrayList<VFSRevision>(versions.getRevisions());
  revisions.add(new CurrentRevision(versionedLeaf,versions));
  revisionListTableCtr.setTableDataModel(new RevisionListDataModel(revisions,ureq.getLocale()));
  listenTo(revisionListTableCtr);
  mainVC=createVelocityContainer(""String_Node_Str"");
  mainVC.put(""String_Node_Str"",revisionListTableCtr.getInitialComponent());
  if (StringHelper.containsNonWhitespace(title)) {
    mainVC.contextPut(""String_Node_Str"",title);
  }
  if (StringHelper.containsNonWhitespace(description)) {
    mainVC.contextPut(""String_Node_Str"",description);
  }
  putInitialPanel(mainVC);
}"
70047,"public CurrentRevision(VFSLeaf versionFile){
  this.versionFile=versionFile;
}","public CurrentRevision(VFSLeaf versionFile,Versions versions){
  this.versionFile=versionFile;
  this.versions=versions;
}"
70048,"public String getRevisionNr(){
  return ((Versionable)versionFile).getVersions().getRevisionNr();
}","public String getRevisionNr(){
  return versions.getRevisionNr();
}"
70049,"public String getComment(){
  Versions versions=((Versionable)versionFile).getVersions();
  String comment=versions.getComment();
  if (StringHelper.containsNonWhitespace(comment)) {
    return comment;
  }
 else   if (""String_Node_Str"".equals(versions.getRevisionNr())) {
    return translate(""String_Node_Str"");
  }
  return ""String_Node_Str"";
}","public String getComment(){
  String comment=versions.getComment();
  if (StringHelper.containsNonWhitespace(comment)) {
    return comment;
  }
 else   if (""String_Node_Str"".equals(versions.getRevisionNr())) {
    return translate(""String_Node_Str"");
  }
  return ""String_Node_Str"";
}"
70050,"public String getAuthor(){
  return author;
}","@Override public String getAuthor(){
  return author;
}"
70051,"public String getCanonicalRoot(){
  return FolderConfig.getCanonicalRoot();
}","public String getCanonicalRoot(){
  if (rootFolder == null) {
    rootFolder=new File(FolderConfig.getCanonicalRoot());
  }
  return rootFolder.getAbsolutePath();
}"
70052,"/** 
 * Binds a name to an object, along with associated attributes. If attrs is null, the resulting binding will have the attributes associated with obj if obj is a DirContext, and no attributes otherwise. If attrs is non-null, the resulting binding will have attrs as its attributes; any attributes associated with obj are ignored.
 * @param name the name to bind; may not be empty
 * @param obj the object to bind; possibly null
 * @param attrs the attributes to associate with the binding
 * @exception NameAlreadyBoundException if name is already bound
 * @exception InvalidAttributesException if some ""mandatory"" attributes of thebinding are not supplied
 * @exception NamingException if a naming exception is encountered
 */
public void bind(String name,Object obj,Attributes attrs) throws NamingException {
  VFSItem file=resolveFile(name);
  if (file != null)   throw new NameAlreadyBoundException(smgr.getString(""String_Node_Str"",name));
  int lastSlash=name.lastIndexOf('/');
  if (lastSlash == -1)   throw new NamingException();
  String parent=name.substring(0,lastSlash);
  VFSItem folder=resolveFile(parent);
  if (folder == null || (!(folder instanceof VFSContainer)))   throw new NamingException(smgr.getString(""String_Node_Str"",name));
  String newName=name.substring(lastSlash + 1);
  VFSLeaf childLeaf=((VFSContainer)folder).createChildLeaf(newName);
  if (childLeaf == null)   throw new NamingException(smgr.getString(""String_Node_Str"",name));
  copyVFS(childLeaf,name,obj,attrs);
  VFSSecurityCallback callback=folder.getLocalSecurityCallback();
  if (callback != null && callback.getSubscriptionContext() != null) {
    SubscriptionContext subContext=callback.getSubscriptionContext();
    NotificationsManager.getInstance().markPublisherNews(subContext,null);
  }
  if (childLeaf instanceof MetaTagged) {
    MetaInfo infos=((MetaTagged)childLeaf).getMetaInfo();
    if (infos != null && infos.getAuthorIdentity() == null) {
      infos.setAuthor(userSession.getIdentity().getName());
      infos.clearThumbnails();
      infos.write();
    }
  }
  if (obj instanceof VFSResource) {
    VFSResource vfsResource=(VFSResource)obj;
    if (vfsResource.vfsItem instanceof Versionable && ((Versionable)vfsResource.vfsItem).getVersions().isVersioned()) {
      Versionable currentVersion=(Versionable)vfsResource.vfsItem;
      VersionsManager.getInstance().move(currentVersion,childLeaf.getParentContainer());
    }
  }
}","/** 
 * Binds a name to an object, along with associated attributes. If attrs is null, the resulting binding will have the attributes associated with obj if obj is a DirContext, and no attributes otherwise. If attrs is non-null, the resulting binding will have attrs as its attributes; any attributes associated with obj are ignored.
 * @param name the name to bind; may not be empty
 * @param obj the object to bind; possibly null
 * @param attrs the attributes to associate with the binding
 * @exception NameAlreadyBoundException if name is already bound
 * @exception InvalidAttributesException if some ""mandatory"" attributes of thebinding are not supplied
 * @exception NamingException if a naming exception is encountered
 */
public void bind(String name,Object obj,Attributes attrs) throws NamingException {
  VFSItem file=resolveFile(name);
  if (file != null)   throw new NameAlreadyBoundException(smgr.getString(""String_Node_Str"",name));
  int lastSlash=name.lastIndexOf('/');
  if (lastSlash == -1)   throw new NamingException();
  String parent=name.substring(0,lastSlash);
  VFSItem folder=resolveFile(parent);
  if (folder == null || (!(folder instanceof VFSContainer)))   throw new NamingException(smgr.getString(""String_Node_Str"",name));
  String newName=name.substring(lastSlash + 1);
  VFSLeaf childLeaf=((VFSContainer)folder).createChildLeaf(newName);
  if (childLeaf == null)   throw new NamingException(smgr.getString(""String_Node_Str"",name));
  copyVFS(childLeaf,name,obj,attrs);
  VFSSecurityCallback callback=folder.getLocalSecurityCallback();
  if (callback != null && callback.getSubscriptionContext() != null) {
    SubscriptionContext subContext=callback.getSubscriptionContext();
    NotificationsManager.getInstance().markPublisherNews(subContext,null);
  }
  if (childLeaf instanceof MetaTagged) {
    MetaInfo infos=((MetaTagged)childLeaf).getMetaInfo();
    if (infos != null && infos.getAuthorIdentity() == null) {
      infos.setAuthor(userSession.getIdentity().getName());
      infos.clearThumbnails();
      infos.write();
    }
  }
  if (obj instanceof VFSResource) {
    VFSResource vfsResource=(VFSResource)obj;
    if (vfsResource.vfsItem instanceof Versionable && ((Versionable)vfsResource.vfsItem).getVersions().isVersioned()) {
      VFSLeaf currentVersion=(VFSLeaf)vfsResource.vfsItem;
      VersionsManager.getInstance().move(currentVersion,childLeaf,identity);
    }
  }
}"
70053,"/** 
 * Binds a name to an object, along with associated attributes, overwriting any existing binding. If attrs is null and obj is a DirContext, the attributes from obj are used. If attrs is null and obj is not a DirContext, any existing attributes associated with the object already bound in the directory remain unchanged. If attrs is non-null, any existing attributes associated with the object already bound in the directory are removed and attrs is associated with the named object. If obj is a DirContext and attrs is non-null, the attributes of obj are ignored.
 * @param name the name to bind; may not be empty
 * @param obj the object to bind; possibly null
 * @param attrs the attributes to associate with the binding
 * @exception InvalidAttributesException if some ""mandatory"" attributes of thebinding are not supplied
 * @exception NamingException if a naming exception is encountered
 */
public void rebind(String name,Object obj,Attributes attrs) throws NamingException {
  VFSItem vfsItem=resolveFile(name);
  if (vfsItem == null || (!(vfsItem instanceof VFSLeaf)))   throw new NamingException(smgr.getString(""String_Node_Str"",name));
  VFSLeaf file=(VFSLeaf)vfsItem;
  if (file instanceof Versionable && ((Versionable)file).getVersions().isVersioned()) {
    VersionsManager.getInstance().addToRevisions((Versionable)file,identity,""String_Node_Str"");
  }
  copyVFS(file,name,obj,attrs);
  if (file instanceof MetaTagged) {
    MetaInfo infos=((MetaTagged)file).getMetaInfo();
    if (infos != null && infos.getAuthorIdentity() == null) {
      infos.setAuthor(userSession.getIdentity().getName());
      infos.clearThumbnails();
      infos.write();
    }
  }
  if (obj instanceof VFSResource) {
    VFSResource vfsResource=(VFSResource)obj;
    if (vfsResource.vfsItem instanceof Versionable && ((Versionable)vfsResource.vfsItem).getVersions().isVersioned()) {
      Versionable currentVersion=(Versionable)vfsResource.vfsItem;
      VersionsManager.getInstance().move(currentVersion,file.getParentContainer());
    }
  }
}","/** 
 * Binds a name to an object, along with associated attributes, overwriting any existing binding. If attrs is null and obj is a DirContext, the attributes from obj are used. If attrs is null and obj is not a DirContext, any existing attributes associated with the object already bound in the directory remain unchanged. If attrs is non-null, any existing attributes associated with the object already bound in the directory are removed and attrs is associated with the named object. If obj is a DirContext and attrs is non-null, the attributes of obj are ignored.
 * @param name the name to bind; may not be empty
 * @param obj the object to bind; possibly null
 * @param attrs the attributes to associate with the binding
 * @exception InvalidAttributesException if some ""mandatory"" attributes of thebinding are not supplied
 * @exception NamingException if a naming exception is encountered
 */
public void rebind(String name,Object obj,Attributes attrs) throws NamingException {
  VFSItem vfsItem=resolveFile(name);
  if (vfsItem == null || (!(vfsItem instanceof VFSLeaf))) {
    throw new NamingException(smgr.getString(""String_Node_Str"",name));
  }
  VFSLeaf file=(VFSLeaf)vfsItem;
  if (file instanceof Versionable && ((Versionable)file).getVersions().isVersioned()) {
    if (file.getSize() == 0) {
      VersionsManager.getInstance().createVersionsFor(file,true);
    }
 else {
      VersionsManager.getInstance().addToRevisions((Versionable)file,identity,""String_Node_Str"");
    }
  }
  copyVFS(file,name,obj,attrs);
  if (file instanceof MetaTagged) {
    MetaInfo infos=((MetaTagged)file).getMetaInfo();
    if (infos != null && infos.getAuthorIdentity() == null) {
      infos.setAuthor(userSession.getIdentity().getName());
      infos.clearThumbnails();
      infos.write();
    }
  }
  if (obj instanceof VFSResource) {
    VFSResource vfsResource=(VFSResource)obj;
    if (vfsResource.vfsItem instanceof Versionable && ((Versionable)vfsResource.vfsItem).getVersions().isVersioned()) {
      Versionable currentVersion=(Versionable)vfsResource.vfsItem;
      VersionsManager.getInstance().move(currentVersion,file.getParentContainer());
    }
  }
}"
70054,"/** 
 * @see org.olat.core.util.vfs.version.VersionsManager#addToRevisions(org.olat.core.util.vfs.version.Versionable,org.olat.core.id.Identity,java.lang.String)
 */
@Override public boolean addToRevisions(Versionable currentVersion,Identity identity,String comment){
  VFSLeaf currentFile=(VFSLeaf)currentVersion;
  VFSLeaf versionFile=getCanonicalVersionXmlFile(currentFile,true);
  if (versionFile == null) {
    return false;
  }
  VFSContainer versionContainer=versionFile.getParentContainer();
  String name=currentFile.getName();
  Versions v=readVersions(currentFile,versionFile);
  if (!(v instanceof VersionsFileImpl)) {
    log.error(""String_Node_Str"" + v);
    return false;
  }
  VersionsFileImpl versions=(VersionsFileImpl)v;
  String uuid=UUID.randomUUID().toString() + ""String_Node_Str"" + name;
  String versionNr=getNextRevisionNr(versions);
  String currentAuthor=versions.getAuthor();
  long lastModifiedDate=0;
  if (currentFile instanceof MetaTagged) {
    MetaInfo metaInfo=((MetaTagged)currentFile).getMetaInfo();
    if (metaInfo != null) {
      metaInfo.clearThumbnails();
      if (currentAuthor == null) {
        currentAuthor=metaInfo.getAuthor();
      }
      lastModifiedDate=metaInfo.getLastModified();
    }
  }
  if (lastModifiedDate <= 0) {
    Calendar cal=Calendar.getInstance();
    cal.setTime(new Date());
    lastModifiedDate=cal.getTimeInMillis();
  }
  RevisionFileImpl newRevision=new RevisionFileImpl();
  newRevision.setName(name);
  newRevision.setFilename(uuid);
  newRevision.setRevisionNr(versionNr);
  newRevision.setComment(versions.getComment());
  newRevision.setAuthor(currentAuthor);
  newRevision.setLastModified(lastModifiedDate);
  if (versions.getRevisions().isEmpty() && currentVersion instanceof MetaTagged) {
    MetaTagged metaTagged=(MetaTagged)currentVersion;
    versions.setCreator(metaTagged.getMetaInfo().getAuthor());
  }
  VFSLeaf target=versionContainer.createChildLeaf(uuid);
  if (VFSManager.copyContent(currentFile,target)) {
    if (identity != null) {
      versions.setAuthor(identity.getName());
    }
    versions.setComment(comment);
    versions.getRevisions().add(newRevision);
    versions.setRevisionNr(getNextRevisionNr(versions));
    XStreamHelper.writeObject(mystream,versionFile,versions);
    if (currentVersion.getVersions() instanceof VersionsFileImpl) {
      ((VersionsFileImpl)currentVersion.getVersions()).update(versions);
    }
    return true;
  }
 else {
    log.error(""String_Node_Str"" + currentVersion);
  }
  return false;
}","/** 
 * @see org.olat.core.util.vfs.version.VersionsManager#addToRevisions(org.olat.core.util.vfs.version.Versionable,org.olat.core.id.Identity,java.lang.String)
 */
@Override public boolean addToRevisions(Versionable currentVersion,Identity identity,String comment){
  VFSLeaf currentFile=(VFSLeaf)currentVersion;
  VFSLeaf versionFile=getCanonicalVersionXmlFile(currentFile,true);
  if (versionFile == null) {
    return false;
  }
  VFSContainer versionContainer=versionFile.getParentContainer();
  String name=currentFile.getName();
  Versions v=readVersions(currentFile,versionFile);
  if (!(v instanceof VersionsFileImpl)) {
    log.error(""String_Node_Str"" + v);
    return false;
  }
  VersionsFileImpl versions=(VersionsFileImpl)v;
  String uuid=UUID.randomUUID().toString() + ""String_Node_Str"" + name;
  String versionNr=getNextRevisionNr(versions);
  String currentAuthor=versions.getAuthor();
  long lastModifiedDate=0;
  if (currentFile instanceof MetaTagged) {
    MetaInfo metaInfo=((MetaTagged)currentFile).getMetaInfo();
    if (metaInfo != null) {
      metaInfo.clearThumbnails();
      if (currentAuthor == null) {
        currentAuthor=metaInfo.getAuthor();
      }
      lastModifiedDate=metaInfo.getLastModified();
    }
  }
  if (lastModifiedDate <= 0) {
    Calendar cal=Calendar.getInstance();
    cal.setTime(new Date());
    lastModifiedDate=cal.getTimeInMillis();
  }
  RevisionFileImpl newRevision=new RevisionFileImpl();
  newRevision.setUuid(UUID.randomUUID().toString());
  newRevision.setName(name);
  newRevision.setFilename(uuid);
  newRevision.setRevisionNr(versionNr);
  newRevision.setComment(versions.getComment());
  newRevision.setAuthor(currentAuthor);
  newRevision.setLastModified(lastModifiedDate);
  if (versions.getRevisions().isEmpty() && currentVersion instanceof MetaTagged) {
    MetaTagged metaTagged=(MetaTagged)currentVersion;
    versions.setCreator(metaTagged.getMetaInfo().getAuthor());
  }
  VFSLeaf target=versionContainer.createChildLeaf(uuid);
  if (VFSManager.copyContent(currentFile,target)) {
    if (identity != null) {
      versions.setAuthor(identity.getName());
    }
    versions.setComment(comment);
    versions.getRevisions().add(newRevision);
    versions.setRevisionNr(getNextRevisionNr(versions));
    XStreamHelper.writeObject(mystream,versionFile,versions);
    if (currentVersion.getVersions() instanceof VersionsFileImpl) {
      ((VersionsFileImpl)currentVersion.getVersions()).update(versions);
    }
    return true;
  }
 else {
    log.error(""String_Node_Str"" + currentVersion);
  }
  return false;
}"
70055,"@Override public Versions createVersionsFor(VFSLeaf leaf){
  if (!(leaf instanceof Versionable)) {
    return NOT_VERSIONED;
  }
 else   if (isVersionFile(leaf)) {
    return NOT_VERSIONED;
  }
  Versions versions=readVersions(leaf,false);
  return versions;
}","@Override public Versions createVersionsFor(VFSLeaf leaf,boolean force){
  if (!(leaf instanceof Versionable)) {
    return NOT_VERSIONED;
  }
 else   if (isVersionFile(leaf)) {
    return NOT_VERSIONED;
  }
  Versions versions=readVersions(leaf,false);
  return versions;
}"
70056,"/** 
 * Move a versioned file to the target container
 * @param currentVersion
 * @param target container
 * @return
 */
public abstract boolean move(Versionable currentVersion,VFSContainer container);","/** 
 * Move a versioned file to an other (WebDAV only!!!)
 * @param currentVersion
 * @param oldVersion
 * @return
 */
public abstract boolean move(VFSLeaf currentFile,VFSLeaf targetFile,Identity author);"
70057,"/** 
 * Get or create the versions datas of this file
 * @param a file
 * @return
 */
public abstract Versions createVersionsFor(VFSLeaf leaf);","/** 
 * Get or create the versions datas of this file
 * @param a file
 * @param force the creation of the file
 * @return
 */
public abstract Versions createVersionsFor(VFSLeaf leaf,boolean force);"
70058,"/** 
 * @see org.olat.core.util.vfs.VFSItem#resolveFile(java.lang.String)
 */
public static VFSItem resolveFile(VFSContainer rootContainer,String path){
  path=VFSManager.sanitizePath(path);
  if (path.equals(""String_Node_Str"")) {
    return rootContainer;
  }
  if (rootContainer instanceof LocalFolderImpl) {
    LocalFolderImpl l=(LocalFolderImpl)rootContainer;
    String fsPath=l.getBasefile().getAbsolutePath() + path;
    File t=new File(fsPath);
    if (t.exists()) {
      String bcroot=FolderConfig.getCanonicalRoot();
      if (t.isDirectory()) {
        if (fsPath.startsWith(bcroot)) {
          fsPath=fsPath.replace(bcroot,""String_Node_Str"");
          return new OlatRootFolderImpl(fsPath,rootContainer);
        }
 else {
          return new LocalFolderImpl(t,rootContainer);
        }
      }
 else {
        if (fsPath.startsWith(bcroot)) {
          fsPath=fsPath.replace(bcroot,""String_Node_Str"");
          return new OlatRootFileImpl(fsPath,rootContainer);
        }
 else {
          return new LocalFileImpl(t,rootContainer);
        }
      }
    }
 else {
      return null;
    }
  }
  String childName=VFSManager.extractChild(path);
  List<VFSItem> children=rootContainer.getItems();
  for (  VFSItem child : children) {
    String curName=child.getName();
    if (childName.equals(curName)) {
      return child.resolve(path.substring(childName.length() + 1));
    }
  }
  return null;
}","/** 
 * @see org.olat.core.util.vfs.VFSItem#resolveFile(java.lang.String)
 */
public static VFSItem resolveFile(VFSContainer rootContainer,String path){
  path=VFSManager.sanitizePath(path);
  if (path.equals(""String_Node_Str"")) {
    return rootContainer;
  }
  if (rootContainer instanceof LocalFolderImpl) {
    String childName=extractChild(path);
    LocalFolderImpl l=(LocalFolderImpl)rootContainer;
    File t=new File(l.getBasefile().getAbsolutePath(),childName);
    if (t.exists()) {
      String bcroot=FolderConfig.getCanonicalRoot();
      String fsPath=t.getAbsolutePath();
      if (t.isDirectory()) {
        VFSContainer subContainer;
        if (fsPath.startsWith(bcroot)) {
          fsPath=fsPath.replace(bcroot,""String_Node_Str"");
          subContainer=new OlatRootFolderImpl(fsPath,rootContainer);
        }
 else {
          subContainer=new LocalFolderImpl(t,rootContainer);
        }
        String subPath=path.substring(childName.length() + 1);
        return resolveFile(subContainer,subPath);
      }
 else {
        if (fsPath.startsWith(bcroot)) {
          fsPath=fsPath.replace(bcroot,""String_Node_Str"");
          return new OlatRootFileImpl(fsPath,rootContainer);
        }
 else {
          return new LocalFileImpl(t,rootContainer);
        }
      }
    }
 else {
      return null;
    }
  }
  String childName=extractChild(path);
  List<VFSItem> children=rootContainer.getItems();
  for (  VFSItem child : children) {
    String curName=child.getName();
    if (childName.equals(curName)) {
      return child.resolve(path.substring(childName.length() + 1));
    }
  }
  return null;
}"
70059,"/** 
 * Get the container which security callback affects this item. This searches up the path of parents to see wether it can find any container with a callback. If no callback can be found, null is returned.
 * @param vfsItem
 * @return
 */
public static VFSContainer findInheritingSecurityCallbackContainer(VFSItem vfsItem){
  if (vfsItem instanceof NamedContainerImpl)   return findInheritingSecurityCallbackContainer(((NamedContainerImpl)vfsItem).delegate);
  if (vfsItem instanceof MergeSource) {
    MergeSource mergeSource=(MergeSource)vfsItem;
    VFSContainer rootWriteContainer=mergeSource.getRootWriteContainer();
    if (rootWriteContainer != null && rootWriteContainer.getLocalSecurityCallback() != null) {
      return rootWriteContainer;
    }
 else     if (mergeSource.getLocalSecurityCallback() != null) {
      return mergeSource;
    }
 else     if (mergeSource.getParentContainer() != null) {
      return findInheritingSecurityCallbackContainer(mergeSource.getParentContainer());
    }
  }
 else {
    if ((vfsItem instanceof VFSContainer) && (vfsItem.getLocalSecurityCallback() != null))     return (VFSContainer)vfsItem;
    if (vfsItem.getParentContainer() != null)     return findInheritingSecurityCallbackContainer(vfsItem.getParentContainer());
  }
  return null;
}","/** 
 * Get the container which security callback affects this item. This searches up the path of parents to see wether it can find any container with a callback. If no callback can be found, null is returned.
 * @param vfsItem
 * @return
 */
public static VFSContainer findInheritingSecurityCallbackContainer(VFSItem vfsItem){
  if (vfsItem == null)   return null;
  if (vfsItem instanceof NamedContainerImpl)   return findInheritingSecurityCallbackContainer(((NamedContainerImpl)vfsItem).delegate);
  if (vfsItem instanceof MergeSource) {
    MergeSource mergeSource=(MergeSource)vfsItem;
    VFSContainer rootWriteContainer=mergeSource.getRootWriteContainer();
    if (rootWriteContainer != null && rootWriteContainer.getLocalSecurityCallback() != null) {
      return rootWriteContainer;
    }
 else     if (mergeSource.getLocalSecurityCallback() != null) {
      return mergeSource;
    }
 else     if (mergeSource.getParentContainer() != null) {
      return findInheritingSecurityCallbackContainer(mergeSource.getParentContainer());
    }
  }
 else {
    if ((vfsItem instanceof VFSContainer) && (vfsItem.getLocalSecurityCallback() != null))     return (VFSContainer)vfsItem;
    if (vfsItem.getParentContainer() != null)     return findInheritingSecurityCallbackContainer(vfsItem.getParentContainer());
  }
  return null;
}"
70060,"public static VCProvider createDefaultProvider(){
  if (_registeredProviders == null || _registeredProviders.isEmpty()) {
    return null;
  }
  String providerId=_registeredProviders.keySet().iterator().next();
  return createProvider(providerId);
}","public static VCProvider createDefaultProvider(){
  if (_registeredProviders == null || _registeredProviders.isEmpty()) {
    return null;
  }
  List<VCProvider> providers=getProviders();
  if (!providers.isEmpty()) {
    return createProvider(providers.get(0).getProviderId());
  }
  return null;
}"
70061,"/** 
 * Updates the catalog entry under the path specified in the URL.
 * @response.representation.200.qname {http://www.example.com}catalogEntryVO
 * @response.representation.200.mediaType application/xml, application/json
 * @response.representation.200.doc The catalog entry200.example  {@link org.olat.catalog.restapi.Examples#SAMPLE_CATALOGENTRYVO}
 * @response.representation.401.doc Not authorized
 * @response.representation.404.doc The path could not be resolved to a valid catalog entry
 * @param path The path
 * @param name The name
 * @param description The description
 * @param httpRquest The HTTP request
 * @param uriInfo The URI informations
 * @return The response
 */
@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response updatePostCatalogEntry(@PathParam(""String_Node_Str"") List<PathSegment> path,@FormParam(""String_Node_Str"") String name,@FormParam(""String_Node_Str"") String description,@Context HttpServletRequest httpRequest,@Context UriInfo uriInfo){
  CatalogEntryVO entryVo=new CatalogEntryVO();
  entryVo.setName(name);
  entryVo.setDescription(description);
  return updateCatalogEntry(path,entryVo,httpRequest,uriInfo);
}","/** 
 * Updates the catalog entry under the path specified in the URL.
 * @response.representation.200.qname {http://www.example.com}catalogEntryVO
 * @response.representation.200.mediaType application/xml, application/json
 * @response.representation.200.doc The catalog entry200.example  {@link org.olat.catalog.restapi.Examples#SAMPLE_CATALOGENTRYVO}
 * @response.representation.401.doc Not authorized
 * @response.representation.404.doc The path could not be resolved to a valid catalog entry
 * @param path The path
 * @param name The name
 * @param description The description
 * @param newParentKey The parent key to move the entry (optional)
 * @param httpRquest The HTTP request
 * @param uriInfo The URI informations
 * @return The response
 */
@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_FORM_URLENCODED) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response updatePostCatalogEntry(@PathParam(""String_Node_Str"") List<PathSegment> path,@FormParam(""String_Node_Str"") String name,@FormParam(""String_Node_Str"") String description,@FormParam(""String_Node_Str"") Long newParentKey,@Context HttpServletRequest httpRequest,@Context UriInfo uriInfo){
  CatalogEntryVO entryVo=new CatalogEntryVO();
  entryVo.setName(name);
  entryVo.setDescription(description);
  return updateCatalogEntry(path,entryVo,newParentKey,httpRequest,uriInfo);
}"
70062,"/** 
 * Updates the catalog entry with the path specified in the URL.
 * @response.representation.200.qname {http://www.example.com}catalogEntryVO
 * @response.representation.200.mediaType application/xml, application/json
 * @response.representation.200.doc The catalog entry200.example  {@link org.olat.catalog.restapi.Examples#SAMPLE_CATALOGENTRYVO}
 * @response.representation.401.doc Not authorized
 * @response.representation.404.doc The path could not be resolved to a valid catalog entry
 * @param path The path
 * @param entryVo The catalog entry
 * @param httpRquest The HTTP request
 * @param uriInfo The URI informations
 * @return The response
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response updateCatalogEntry(@PathParam(""String_Node_Str"") List<PathSegment> path,CatalogEntryVO entryVo,@Context HttpServletRequest httpRequest,@Context UriInfo uriInfo){
  if (!isAuthor(httpRequest)) {
    return Response.serverError().status(Status.UNAUTHORIZED).build();
  }
  Long key=getCatalogEntryKeyFromPath(path);
  if (key == null) {
    return Response.serverError().status(Status.NOT_ACCEPTABLE).build();
  }
  CatalogEntry ce=catalogManager.loadCatalogEntry(key);
  if (ce.getType() == CatalogEntry.TYPE_NODE) {
    if (!canAdminSubTree(ce,httpRequest)) {
      return Response.serverError().status(Status.UNAUTHORIZED).build();
    }
  }
  Identity id=getUserRequest(httpRequest).getIdentity();
  LockResult lock=CoordinatorManager.getInstance().getCoordinator().getLocker().acquireLock(catalogRes,id,LOCK_TOKEN);
  if (!lock.isSuccess()) {
    return getLockedResponse(lock,httpRequest);
  }
  try {
    ce=catalogManager.loadCatalogEntry(ce);
    if (ce == null) {
      return Response.serverError().status(Status.NOT_FOUND).build();
    }
    ce.setName(entryVo.getName());
    ce.setDescription(entryVo.getDescription());
    ce.setType(guessType(entryVo));
    catalogManager.updateCatalogEntry(ce);
  }
 catch (  Exception e) {
    throw new WebApplicationException(e);
  }
 finally {
    CoordinatorManager.getInstance().getCoordinator().getLocker().releaseLock(lock);
  }
  CatalogEntryVO newEntryVo=link(get(ce),uriInfo);
  return Response.ok(newEntryVo).build();
}","/** 
 * Updates the catalog entry with the path specified in the URL.
 * @response.representation.200.qname {http://www.example.com}catalogEntryVO
 * @response.representation.200.mediaType application/xml, application/json
 * @response.representation.200.doc The catalog entry200.example  {@link org.olat.catalog.restapi.Examples#SAMPLE_CATALOGENTRYVO}
 * @response.representation.401.doc Not authorized
 * @response.representation.404.doc The path could not be resolved to a valid catalog entry
 * @param path The path
 * @param entryVo The catalog entry
 * @param newParentKey The parent key to move the entry (optional)
 * @param httpRquest The HTTP request
 * @param uriInfo The URI informations
 * @return The response
 */
@POST @Path(""String_Node_Str"") @Consumes({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) @Produces({MediaType.APPLICATION_XML,MediaType.APPLICATION_JSON}) public Response updateCatalogEntry(@PathParam(""String_Node_Str"") List<PathSegment> path,CatalogEntryVO entryVo,@QueryParam(""String_Node_Str"") Long newParentKey,@Context HttpServletRequest httpRequest,@Context UriInfo uriInfo){
  if (!isAuthor(httpRequest)) {
    return Response.serverError().status(Status.UNAUTHORIZED).build();
  }
  Long key=getCatalogEntryKeyFromPath(path);
  if (key == null) {
    return Response.serverError().status(Status.NOT_ACCEPTABLE).build();
  }
  CatalogEntry ce=catalogManager.loadCatalogEntry(key);
  if (ce.getType() == CatalogEntry.TYPE_NODE) {
    if (!canAdminSubTree(ce,httpRequest)) {
      return Response.serverError().status(Status.UNAUTHORIZED).build();
    }
  }
  CatalogEntry newParent=null;
  if (newParentKey != null) {
    newParent=catalogManager.loadCatalogEntry(newParentKey);
    if (newParent.getType() == CatalogEntry.TYPE_NODE) {
      if (!canAdminSubTree(newParent,httpRequest)) {
        return Response.serverError().status(Status.UNAUTHORIZED).build();
      }
    }
  }
  Identity id=getUserRequest(httpRequest).getIdentity();
  LockResult lock=CoordinatorManager.getInstance().getCoordinator().getLocker().acquireLock(catalogRes,id,LOCK_TOKEN);
  if (!lock.isSuccess()) {
    return getLockedResponse(lock,httpRequest);
  }
  try {
    ce=catalogManager.loadCatalogEntry(ce);
    if (ce == null) {
      return Response.serverError().status(Status.NOT_FOUND).build();
    }
    if (StringHelper.containsNonWhitespace(entryVo.getName())) {
      ce.setName(entryVo.getName());
    }
    if (StringHelper.containsNonWhitespace(entryVo.getDescription())) {
      ce.setDescription(entryVo.getDescription());
    }
    if (entryVo.getType() != null) {
      ce.setType(guessType(entryVo));
    }
    catalogManager.updateCatalogEntry(ce);
    if (newParent != null) {
      catalogManager.moveCatalogEntry(ce,newParent);
    }
  }
 catch (  Exception e) {
    throw new WebApplicationException(e);
  }
 finally {
    CoordinatorManager.getInstance().getCoordinator().getLocker().releaseLock(lock);
  }
  CatalogEntryVO newEntryVo=link(get(ce),uriInfo);
  return Response.ok(newEntryVo).build();
}"
70063,"/** 
 * TODO: rename to getForumController and save instance?
 * @param ureq
 * @param wControl
 * @param isAdmin
 * @param subsContext the subscriptioncontext if subscriptions to this forumshould be possible
 * @return a forum controller
 */
public Controller createForumController(UserRequest ureq,WindowControl wControl,boolean isAdmin,boolean isGuestOnly,final SubscriptionContext subsContext){
  Codepoint.codepoint(CollaborationTools.class,""String_Node_Str"");
  final boolean isAdm=isAdmin;
  final boolean isGuest=isGuestOnly;
  final ForumManager fom=ForumManager.getInstance();
  final NarrowedPropertyManager npm=NarrowedPropertyManager.getInstance(ores);
  Codepoint.codepoint(CollaborationTools.class,""String_Node_Str"");
  Forum forum=coordinatorManager.getCoordinator().getSyncer().doInSync(ores,new SyncerCallback<Forum>(){
    public Forum execute(){
      Codepoint.codepoint(CollaborationTools.class,""String_Node_Str"");
      Forum aforum;
      Long forumKey;
      Property forumKeyProperty=npm.findProperty(null,null,PROP_CAT_BG_COLLABTOOLS,KEY_FORUM);
      if (forumKeyProperty == null) {
        aforum=fom.addAForum();
        forumKey=aforum.getKey();
        if (log.isDebug()) {
          log.debug(""String_Node_Str"" + forumKey.longValue() + ""String_Node_Str""+ ores.getResourceableTypeName()+ ""String_Node_Str""+ ores.getResourceableId());
        }
        forumKeyProperty=npm.createPropertyInstance(null,null,PROP_CAT_BG_COLLABTOOLS,KEY_FORUM,null,forumKey,null,null);
        npm.saveProperty(forumKeyProperty);
      }
 else {
        forumKey=forumKeyProperty.getLongValue();
        aforum=fom.loadForum(forumKey);
        if (aforum == null) {
          throw new AssertException(""String_Node_Str"" + forumKey.longValue() + ""String_Node_Str""+ ores.getResourceableTypeName()+ ""String_Node_Str""+ ores.getResourceableId());
        }
        if (log.isDebug()) {
          log.debug(""String_Node_Str"" + forumKey.longValue() + ""String_Node_Str""+ ores.getResourceableTypeName()+ ""String_Node_Str""+ ores.getResourceableId());
        }
      }
      Codepoint.codepoint(CollaborationTools.class,""String_Node_Str"");
      return aforum;
    }
  }
);
  Translator trans=Util.createPackageTranslator(this.getClass(),ureq.getLocale());
  TitleInfo titleInfo=new TitleInfo(null,trans.translate(""String_Node_Str""));
  titleInfo.setSeparatorEnabled(true);
  Controller forumController=ForumUIFactory.getTitledForumController(ureq,wControl,forum,new ForumCallback(){
    public boolean mayOpenNewThread(){
      return true;
    }
    public boolean mayReplyMessage(){
      return true;
    }
    public boolean mayEditMessageAsModerator(){
      return isAdm;
    }
    public boolean mayDeleteMessageAsModerator(){
      return isAdm;
    }
    public boolean mayArchiveForum(){
      return !isGuest;
    }
    public boolean mayFilterForUser(){
      return isAdm;
    }
    public SubscriptionContext getSubscriptionContext(){
      return subsContext;
    }
  }
,titleInfo);
  return forumController;
}","/** 
 * TODO: rename to getForumController and save instance?
 * @param ureq
 * @param wControl
 * @param isAdmin
 * @param subsContext the subscriptioncontext if subscriptions to this forumshould be possible
 * @return a forum controller
 */
public Controller createForumController(UserRequest ureq,WindowControl wControl,boolean isAdmin,boolean isGuestOnly,final SubscriptionContext subsContext){
  Codepoint.codepoint(CollaborationTools.class,""String_Node_Str"");
  final boolean isAdm=isAdmin;
  final boolean isGuest=isGuestOnly;
  Forum forum=getForum();
  Translator trans=Util.createPackageTranslator(this.getClass(),ureq.getLocale());
  TitleInfo titleInfo=new TitleInfo(null,trans.translate(""String_Node_Str""));
  titleInfo.setSeparatorEnabled(true);
  Controller forumController=ForumUIFactory.getTitledForumController(ureq,wControl,forum,new ForumCallback(){
    public boolean mayOpenNewThread(){
      return true;
    }
    public boolean mayReplyMessage(){
      return true;
    }
    public boolean mayEditMessageAsModerator(){
      return isAdm;
    }
    public boolean mayDeleteMessageAsModerator(){
      return isAdm;
    }
    public boolean mayArchiveForum(){
      return !isGuest;
    }
    public boolean mayFilterForUser(){
      return isAdm;
    }
    public SubscriptionContext getSubscriptionContext(){
      return subsContext;
    }
  }
,titleInfo);
  return forumController;
}"
70064,"/** 
 * Update the repository entry with the latest set properties in the feed resource. <p> Properties are: <ul> <li>Title <li>Author <li>Descripion (wiki style in repository) <li>Image </ul>
 * @param feed
 */
void enrichRepositoryEntryByFeedInformation(Feed feed){
  RepositoryEntry entry=getRepositoryEntry(feed);
  if (entry != null && feed != null) {
    Date whenTheFeedWasLastModified=feed.getLastModified();
    if (whenTheFeedWasLastModified != null && entry.getLastModified().before(whenTheFeedWasLastModified)) {
      entry.setDisplayname(feed.getTitle());
      entry.setDescription(feed.getDescription());
      VFSContainer repoHome=new LocalFolderImpl(new File(FolderConfig.getCanonicalRoot() + FolderConfig.getRepositoryHome()));
      String imageFilename=RepositoryEntryImageController.getImageFilename(entry);
      VFSItem oldEntryImage=repoHome.resolve(imageFilename);
      if (oldEntryImage != null) {
        oldEntryImage.delete();
      }
      String feedImage=feed.getImageName();
      if (feedImage != null) {
        VFSItem newImage=getFeedMediaContainer(feed).resolve(feedImage);
        if (newImage == null) {
          deleteImage(feed);
        }
 else {
          repoHome.copyFrom(newImage);
          VFSItem newEntryImage=repoHome.resolve(feed.getImageName());
          newEntryImage.rename(imageFilename);
        }
      }
    }
  }
}","/** 
 * Update the repository entry with the latest set properties in the feed resource. <p> Properties are: <ul> <li>Title <li>Author <li>Descripion (wiki style in repository) <li>Image </ul>
 * @param feed
 */
void enrichRepositoryEntryByFeedInformation(Feed feed){
  RepositoryEntry entry=getRepositoryEntry(feed);
  if (entry != null && feed != null) {
    Date whenTheFeedWasLastModified=feed.getLastModified();
    if (whenTheFeedWasLastModified != null && entry.getLastModified().before(whenTheFeedWasLastModified)) {
      String saveTitle=PersistenceHelper.truncateStringDbSave(feed.getTitle(),100,true);
      entry.setDisplayname(saveTitle);
      String saveDesc=PersistenceHelper.truncateStringDbSave(feed.getDescription(),16777210,true);
      entry.setDescription(saveDesc);
      VFSContainer repoHome=new LocalFolderImpl(new File(FolderConfig.getCanonicalRoot() + FolderConfig.getRepositoryHome()));
      String imageFilename=RepositoryEntryImageController.getImageFilename(entry);
      VFSItem oldEntryImage=repoHome.resolve(imageFilename);
      if (oldEntryImage != null) {
        oldEntryImage.delete();
      }
      String feedImage=feed.getImageName();
      if (feedImage != null) {
        VFSItem newImage=getFeedMediaContainer(feed).resolve(feedImage);
        if (newImage == null) {
          deleteImage(feed);
        }
 else {
          repoHome.copyFrom(newImage);
          VFSItem newEntryImage=repoHome.resolve(feed.getImageName());
          newEntryImage.rename(imageFilename);
        }
      }
    }
  }
}"
70065,"/** 
 * @see org.olat.core.gui.components.form.flexible.impl.FormBasicController#initForm(org.olat.core.gui.components.form.flexible.FormItemContainer,org.olat.core.gui.control.Controller,org.olat.core.gui.UserRequest)
 */
@Override @SuppressWarnings(""String_Node_Str"") protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  this.setFormTitle(""String_Node_Str"");
  title=uifactory.addTextElement(""String_Node_Str"",""String_Node_Str"",256,feed.getTitle(),this.flc);
  title.setMandatory(true);
  title.setNotEmptyCheck(""String_Node_Str"");
  description=uifactory.addRichTextElementForStringDataMinimalistic(""String_Node_Str"",""String_Node_Str"",feed.getDescription(),5,-1,false,formLayout,ureq.getUserSession(),getWindowControl());
  description.setMandatory(true);
  description.setMaxLength(4000);
  description.setNotEmptyCheck(""String_Node_Str"");
  RichTextConfiguration richTextConfig=description.getEditorConfiguration();
  richTextConfig.setFileBrowserUploadRelPath(""String_Node_Str"");
  String VELOCITY_ROOT=Util.getPackageVelocityRoot(this.getClass());
  imageContainer=FormLayoutContainer.createCustomFormLayout(""String_Node_Str"",getTranslator(),VELOCITY_ROOT + ""String_Node_Str"");
  imageContainer.setLabel(""String_Node_Str"",null);
  flc.add(imageContainer);
  deleteImageLink=uifactory.addFormLink(""String_Node_Str"",imageContainer);
  image=new ImageComponent(""String_Node_Str"");
  imageContainer.put(""String_Node_Str"",image);
  file=uifactory.addFileElement(""String_Node_Str"",this.flc);
  file.addActionListener(this,FormEvent.ONCHANGE);
  if (feed.getImageName() != null) {
    MediaResource imageResource=FeedManager.getInstance().createFeedMediaFile(feed,feed.getImageName());
    setImage(imageResource);
  }
 else {
    imageContainer.setVisible(false);
  }
  Set<String> mimeTypes=new HashSet<String>();
  mimeTypes.add(""String_Node_Str"");
  mimeTypes.add(""String_Node_Str"");
  mimeTypes.add(""String_Node_Str"");
  mimeTypes.add(""String_Node_Str"");
  file.limitToMimeType(mimeTypes,""String_Node_Str"",null);
  final FormLayoutContainer buttonLayout=FormLayoutContainer.createButtonLayout(""String_Node_Str"",getTranslator());
  this.flc.add(buttonLayout);
  uifactory.addFormSubmitButton(""String_Node_Str"",buttonLayout);
  cancelButton=uifactory.addFormLink(""String_Node_Str"",buttonLayout,Link.BUTTON);
}","/** 
 * @see org.olat.core.gui.components.form.flexible.impl.FormBasicController#initForm(org.olat.core.gui.components.form.flexible.FormItemContainer,org.olat.core.gui.control.Controller,org.olat.core.gui.UserRequest)
 */
@Override @SuppressWarnings(""String_Node_Str"") protected void initForm(FormItemContainer formLayout,Controller listener,UserRequest ureq){
  this.setFormTitle(""String_Node_Str"");
  String saveTitle=PersistenceHelper.truncateStringDbSave(feed.getTitle(),256,true);
  title=uifactory.addTextElement(""String_Node_Str"",""String_Node_Str"",256,saveTitle,this.flc);
  title.setMandatory(true);
  title.setNotEmptyCheck(""String_Node_Str"");
  description=uifactory.addRichTextElementForStringDataMinimalistic(""String_Node_Str"",""String_Node_Str"",feed.getDescription(),5,-1,false,formLayout,ureq.getUserSession(),getWindowControl());
  description.setMandatory(true);
  description.setMaxLength(4000);
  description.setNotEmptyCheck(""String_Node_Str"");
  RichTextConfiguration richTextConfig=description.getEditorConfiguration();
  richTextConfig.setFileBrowserUploadRelPath(""String_Node_Str"");
  String VELOCITY_ROOT=Util.getPackageVelocityRoot(this.getClass());
  imageContainer=FormLayoutContainer.createCustomFormLayout(""String_Node_Str"",getTranslator(),VELOCITY_ROOT + ""String_Node_Str"");
  imageContainer.setLabel(""String_Node_Str"",null);
  flc.add(imageContainer);
  deleteImageLink=uifactory.addFormLink(""String_Node_Str"",imageContainer);
  image=new ImageComponent(""String_Node_Str"");
  imageContainer.put(""String_Node_Str"",image);
  file=uifactory.addFileElement(""String_Node_Str"",this.flc);
  file.addActionListener(this,FormEvent.ONCHANGE);
  if (feed.getImageName() != null) {
    MediaResource imageResource=FeedManager.getInstance().createFeedMediaFile(feed,feed.getImageName());
    setImage(imageResource);
  }
 else {
    imageContainer.setVisible(false);
  }
  Set<String> mimeTypes=new HashSet<String>();
  mimeTypes.add(""String_Node_Str"");
  mimeTypes.add(""String_Node_Str"");
  mimeTypes.add(""String_Node_Str"");
  mimeTypes.add(""String_Node_Str"");
  file.limitToMimeType(mimeTypes,""String_Node_Str"",null);
  final FormLayoutContainer buttonLayout=FormLayoutContainer.createButtonLayout(""String_Node_Str"",getTranslator());
  this.flc.add(buttonLayout);
  uifactory.addFormSubmitButton(""String_Node_Str"",buttonLayout);
  cancelButton=uifactory.addFormLink(""String_Node_Str"",buttonLayout,Link.BUTTON);
}"
70066,"/** 
 * Received Data
 * @param c
 * @param t
 */
public void receivedData(Connection c,Transfer t){
  String dataId=ongoingTransfers.remove(c);
  if (dataId == null) {
    return;
  }
  if (DEBUG) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId);
  }
  releaseReceiveSlot();
  List<DataRequest> requests=dataToRequests.remove(dataId);
  boolean isBindingType=requests.get(0).getType().equals(DataType.BINDING_OBJECT_T);
  Map<String,List<DataRequest>> byTarget=new HashMap<>();
  for (  DataRequest req : requests) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + req.getTarget()+ ""String_Node_Str""+ dataId+ ""String_Node_Str"");
    List<DataRequest> sameTarget=byTarget.get(req.getTarget());
    if (sameTarget == null) {
      sameTarget=new LinkedList<DataRequest>();
      byTarget.put(req.getTarget(),sameTarget);
    }
    sameTarget.add(req);
  }
  if (NIOTracer.isActivated()) {
    int tag=abs(dataId.hashCode());
    NIOTracer.emitDataTransferEvent(dataId);
    NIOTracer.emitCommEvent(false,connection2Partner.get(c),tag,t.getSize());
    connection2Partner.remove(c);
  }
  if (byTarget.size() == 1) {
    String targetName=requests.get(0).getTarget();
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
    }
    if (t.isFile() || t.isObject()) {
      if (!isPersistentEnabled() && isBindingType) {
        receivedBindingObjectAsFile(t.getFileName(),targetName);
      }
      receivedValue(t.getDestination(),targetName,t.getObject(),requests);
    }
 else     if (t.isByteBuffer()) {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
 else {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
  }
 else {
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
    }
    if (t.isFile()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ t.getFileName());
      }
      List<DataRequest> reqs;
      if (!isPersistentEnabled() && isBindingType) {
        BindingObject bo=getTargetBindingObject(t.getFileName(),requests.get(0).getTarget());
        reqs=byTarget.remove(bo.toString());
        receivedBindingObjectAsFile(t.getFileName(),reqs.get(0).getTarget());
      }
 else {
        reqs=byTarget.remove(t.getFileName());
      }
      receivedValue(t.getDestination(),t.getFileName(),t.getObject(),reqs);
    }
 else     if (t.isObject()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      receivedValue(t.getDestination(),dataId,t.getObject(),byTarget.remove(dataId));
    }
 else     if (t.isByteBuffer()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      BindingObject bo=getTargetBindingObject(dataId,requests.get(0).getSource().getFirstURI().getPath());
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(dataId));
    }
 else {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      BindingObject bo=getTargetBindingObject(dataId,requests.get(0).getSource().getFirstURI().getPath());
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(dataId));
    }
    for (    Entry<String,List<DataRequest>> entry : byTarget.entrySet()) {
      String targetName=entry.getKey();
      List<DataRequest> reqs=entry.getValue();
      try {
        if (DEBUG) {
          LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
        }
        if (t.isFile()) {
          if (!isPersistentEnabled() && reqs.get(0).getType().equals(DataType.BINDING_OBJECT_T)) {
            receivedBindingObjectAsFile(t.getFileName(),targetName);
          }
 else {
            Files.copy((new File(t.getFileName())).toPath(),(new File(targetName)).toPath());
          }
          receivedValue(t.getDestination(),targetName,t.getObject(),byTarget.remove(targetName));
        }
 else         if (t.isObject()) {
          Object o=Serializer.deserialize(t.getArray());
          receivedValue(t.getDestination(),targetName,o,reqs);
        }
 else {
          BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
          NIOBindingDataManager.copyCachedData(dataId,targetName);
          receivedValue(t.getDestination(),targetName,bo.toString(),byTarget.remove(targetName));
        }
      }
 catch (      IOException|ClassNotFoundException e) {
        LOGGER.warn(""String_Node_Str"",e);
      }
    }
  }
  requestTransfers();
  if (finish == true && !hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}","/** 
 * Received Data
 * @param c
 * @param t
 */
public void receivedData(Connection c,Transfer t){
  String dataId=ongoingTransfers.remove(c);
  if (dataId == null) {
    return;
  }
  if (DEBUG) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId);
  }
  releaseReceiveSlot();
  List<DataRequest> requests=dataToRequests.remove(dataId);
  boolean isBindingType=requests.get(0).getType().equals(DataType.BINDING_OBJECT_T);
  Map<String,List<DataRequest>> byTarget=new HashMap<>();
  for (  DataRequest req : requests) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + req.getTarget()+ ""String_Node_Str""+ dataId+ ""String_Node_Str"");
    List<DataRequest> sameTarget=byTarget.get(req.getTarget());
    if (sameTarget == null) {
      sameTarget=new LinkedList<DataRequest>();
      byTarget.put(req.getTarget(),sameTarget);
    }
    sameTarget.add(req);
  }
  if (NIOTracer.isActivated()) {
    int tag=abs(dataId.hashCode());
    NIOTracer.emitDataTransferEvent(dataId);
    NIOTracer.emitCommEvent(false,connection2Partner.get(c),tag,t.getSize());
    connection2Partner.remove(c);
  }
  if (byTarget.size() == 1) {
    String targetName=requests.get(0).getTarget();
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
    }
    if (t.isFile() || t.isObject()) {
      if (!isPersistentEnabled() && isBindingType) {
        receivedBindingObjectAsFile(t.getFileName(),targetName);
      }
      receivedValue(t.getDestination(),targetName,t.getObject(),requests);
    }
 else     if (t.isByteBuffer()) {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
 else {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
  }
 else {
    String workingDir=getWorkingDir();
    if (!workingDir.endsWith(File.separator)) {
      workingDir=workingDir + File.separator;
    }
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
    }
    if (t.isFile()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ t.getFileName());
      }
      List<DataRequest> reqs;
      if (!isPersistentEnabled() && isBindingType) {
        BindingObject bo=getTargetBindingObject(t.getFileName(),requests.get(0).getTarget());
        reqs=byTarget.remove(bo.toString());
        receivedBindingObjectAsFile(t.getFileName(),reqs.get(0).getTarget());
      }
 else {
        reqs=byTarget.remove(t.getFileName());
      }
      receivedValue(t.getDestination(),t.getFileName(),t.getObject(),reqs);
    }
 else     if (t.isObject()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      receivedValue(t.getDestination(),dataId,t.getObject(),byTarget.remove(dataId));
    }
 else     if (t.isByteBuffer()) {
      BindingObject bo=getTargetBindingObject(workingDir + dataId,requests.get(0).getTarget());
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ bo.toString()+ ""String_Node_Str""+ dataId);
      }
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(bo.toString()));
    }
 else {
      BindingObject bo=getTargetBindingObject(workingDir + dataId,requests.get(0).getTarget());
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ bo.toString()+ ""String_Node_Str""+ dataId);
      }
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(bo.toString()));
    }
    for (    Entry<String,List<DataRequest>> entry : byTarget.entrySet()) {
      String targetName=entry.getKey();
      List<DataRequest> reqs=entry.getValue();
      try {
        if (DEBUG) {
          LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
        }
        if (t.isFile()) {
          if (!isPersistentEnabled() && isBindingType) {
            BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getTarget());
            receivedBindingObjectAsFile(t.getFileName(),targetName);
            receivedValue(t.getDestination(),bo.getName(),bo.toString(),byTarget.remove(targetName));
          }
 else {
            Files.copy((new File(t.getFileName())).toPath(),(new File(targetName)).toPath());
            receivedValue(t.getDestination(),targetName,t.getObject(),byTarget.remove(targetName));
          }
        }
 else         if (t.isObject()) {
          Object o=Serializer.deserialize(t.getArray());
          receivedValue(t.getDestination(),targetName,o,reqs);
        }
 else {
          BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getTarget());
          NIOBindingDataManager.copyCachedData(dataId,bo.getName());
          receivedValue(t.getDestination(),bo.getName(),bo.toString(),byTarget.remove(targetName));
        }
      }
 catch (      IOException|ClassNotFoundException e) {
        LOGGER.warn(""String_Node_Str"",e);
      }
    }
  }
  requestTransfers();
  if (finish == true && !hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}"
70067,"/** 
 * Adds a new task summary request
 * @param logger
 */
public void getTaskSummary(Logger logger){
  Semaphore sem=new Semaphore(0);
  TaskSummaryRequest request=new TaskSummaryRequest(LOGGER,sem);
  addRequest(request);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}","/** 
 * Adds a new task summary request
 * @param logger
 */
public void getTaskSummary(Logger logger){
  Semaphore sem=new Semaphore(0);
  TaskSummaryRequest request=new TaskSummaryRequest(logger,sem);
  addRequest(request);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}"
70068,"@Override public void process(TaskScheduler ts) throws ShutdownException {
  ts.getTaskSummary(logger);
  sem.release();
}","@Override public void process(TaskScheduler ts) throws ShutdownException {
  ts.getTaskSummary(this.logger);
  this.sem.release();
}"
70069,"public void obtainBindingData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  BindingObject tgtBO=((BindingObjectLocation)target).getBindingObject();
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + bo.getName());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ tgtBO.getName());
      }
      BindingObject bo=BindingObject.generate(u.getPath());
      if (ld.getName().equals(tgtBO.getName())) {
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
 else {
        LOGGER.debug(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ tgtBO.getName());
        BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
      listener.notifyEnd(null);
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ tgtBO.getName());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + tgtBO.getName(),e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        BindingObject bo=BindingObject.generate(sourcePath);
        if (ld.getName().equals(tgtBO.getName())) {
          LOGGER.debug(""String_Node_Str"" + bo.getName());
          reason.setDataTarget(sourcePath);
        }
 else {
          LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
          BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
          if (tgtData != null) {
            tgtData.addLocation(target);
          }
          LOGGER.debug(""String_Node_Str"" + tgtBO.getName());
          reason.setDataTarget(sourcePath);
        }
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ tgtBO.getName());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
}","public void obtainBindingData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  BindingObject tgtBO=((BindingObjectLocation)target).getBindingObject();
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          Copy.waitForCopyTofinish(copy,this);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          Copy.waitForCopyTofinish(copy,this);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + bo.getName());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ tgtBO.getName());
      }
      BindingObject bo=BindingObject.generate(u.getPath());
      if (ld.getName().equals(tgtBO.getName())) {
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
 else {
        LOGGER.debug(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ tgtBO.getName());
        BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
      listener.notifyEnd(null);
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ tgtBO.getName());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + tgtBO.getName(),e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        BindingObject bo=BindingObject.generate(sourcePath);
        if (ld.getName().equals(tgtBO.getName())) {
          LOGGER.debug(""String_Node_Str"" + bo.getName());
          reason.setDataTarget(sourcePath);
        }
 else {
          LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
          BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
          if (tgtData != null) {
            tgtData.addLocation(target);
          }
          LOGGER.debug(""String_Node_Str"" + tgtBO.getName());
          reason.setDataTarget(sourcePath);
        }
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ tgtBO.getName());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
}"
70070,"public void obtainFileData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      try {
        if (DEBUG) {
          LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ targetPath);
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + targetPath,e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          LOGGER.debug(""String_Node_Str"" + targetPath);
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ targetPath);
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ targetPath);
  ld.releaseHostRemoval();
}","public void obtainFileData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          Copy.waitForCopyTofinish(copy,this);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          Copy.waitForCopyTofinish(copy,this);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      try {
        if (DEBUG) {
          LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ targetPath);
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + targetPath,e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          LOGGER.debug(""String_Node_Str"" + targetPath);
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ targetPath);
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ targetPath);
  ld.releaseHostRemoval();
}"
70071,"private void sendFile(Connection c,String path,Data d){
  if (path.startsWith(File.separator)) {
    File f=new File(path);
    if (f.exists()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ path+ ""String_Node_Str""+ d.getName());
      }
      c.sendDataFile(path);
    }
 else {
      ErrorManager.warn(""String_Node_Str"" + path + ""String_Node_Str""+ c.hashCode()+ ""String_Node_Str"");
      handleDataToSendNotAvailable(c,d);
    }
  }
 else {
    sendObject(c,path,d);
  }
}","private void sendFile(Connection c,String path,Data d){
  if (path.startsWith(File.separator)) {
    File f=new File(path);
    if (f.exists()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ path+ ""String_Node_Str""+ d.getName());
      }
      c.sendDataFile(path);
    }
 else {
      if (!f.getName().equals(d.getName())) {
        File renamed;
        if (isMaster()) {
          renamed=new File(Comm.getAppHost().getCompleteRemotePath(DataType.FILE_T,d.getName()).getPath());
        }
 else {
          renamed=new File(f.getParentFile().getAbsolutePath() + File.separator + d.getName());
        }
        if (renamed.exists()) {
          if (DEBUG) {
            LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ renamed.getAbsolutePath()+ ""String_Node_Str""+ d.getName());
          }
          c.sendDataFile(renamed.getAbsolutePath());
        }
 else {
          ErrorManager.warn(""String_Node_Str"" + path + ""String_Node_Str""+ renamed.getAbsolutePath()+ ""String_Node_Str""+ c.hashCode()+ ""String_Node_Str"");
          handleDataToSendNotAvailable(c,d);
        }
      }
 else {
        ErrorManager.warn(""String_Node_Str"" + path + ""String_Node_Str""+ c.hashCode()+ ""String_Node_Str"");
        handleDataToSendNotAvailable(c,d);
      }
    }
  }
 else {
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ d.getName());
    }
    sendObject(c,path,d);
  }
}"
70072,"/** 
 * Marks a location for deletion
 * @param loc
 */
public void markForDeletion(DataLocation loc){
  if (!requestQueue.offer(new DeleteFileRequest(loc))) {
    ErrorManager.error(ERROR_QUEUE_OFFER + ""String_Node_Str"");
  }
}","/** 
 * Marks a location for deletion
 * @param loc
 */
public void markForDeletion(DataLocation loc){
  LOGGER.debug(""String_Node_Str"" + loc + ""String_Node_Str"");
  Semaphore sem=new Semaphore(0);
  if (!requestQueue.offer(new DeleteFileRequest(loc,sem))) {
    ErrorManager.error(ERROR_QUEUE_OFFER + ""String_Node_Str"");
  }
  sem.acquireUninterruptibly();
  LOGGER.debug(""String_Node_Str"" + loc + ""String_Node_Str"");
}"
70073,"public FileInputStream newFileInputStream(FileDescriptor fd){
  StreamList list=obtainList(fd);
  FileInputStream fis=new FileInputStream(fd);
  if (list != null)   list.addStream(fis);
  return fis;
}","public FileInputStream newFileInputStream(FileDescriptor fd){
  StreamList list=obtainList(fd);
  FileInputStream fis=new FileInputStream(fd);
  if (list != null) {
    list.addStream(fis);
  }
  return fis;
}"
70074,"public boolean isTaskFile(String fileName){
  File f=new File(fileName);
  if (taskFiles.contains(f.getAbsolutePath())) {
    return true;
  }
 else {
    return false;
  }
}","public boolean isTaskFile(String fileName){
  if (fileName == null) {
    File f=new File(fileName);
    if (taskFiles.contains(f.getAbsolutePath())) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
70075,"/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,StreamSTD streamValues,File taskSandboxWorkingDir) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    process.getOutputStream().close();
    logBinaryExecution(process,exitValue,fileOutPath,fileErrPath);
    exitValue=process.waitFor();
  }
 catch (  Exception e) {
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
  return exitValue;
}","/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,StreamSTD streamValues,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    process.getOutputStream().close();
    logBinaryExecution(process,fileOutPath,fileErrPath,defaultOutStream,defaultErrStream);
    exitValue=process.waitFor();
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + exitValue);
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    System.err.println(ERROR_PROC_EXEC);
    e.printStackTrace();
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
  return exitValue;
}"
70076,"private static void logBinaryExecution(Process process,int exitValue,String fileOutPath,String fileErrPath) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + exitValue);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    StreamGobbler outputGobbler=new StreamGobbler(process.getInputStream(),System.out,LogManager.getLogger(Loggers.WORKER));
    outputGobbler.start();
  }
  System.out.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    StreamGobbler errorGobbler=new StreamGobbler(process.getErrorStream(),System.err,LogManager.getLogger(Loggers.WORKER));
    errorGobbler.start();
  }
  System.err.println(""String_Node_Str"");
}","private static void logBinaryExecution(Process process,String fileOutPath,String fileErrPath,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  StreamGobbler errorGobbler=null;
  StreamGobbler outputGobbler=null;
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    if (fileOutPath == null) {
      outputGobbler=new StreamGobbler(process.getInputStream(),defaultOutStream,LogManager.getLogger(Loggers.WORKER));
      outputGobbler.start();
    }
 else {
      try (FileInputStream outputStream=new FileInputStream(fileOutPath)){
        outputGobbler=new StreamGobbler(outputStream,defaultOutStream,LogManager.getLogger(Loggers.WORKER));
        outputGobbler.start();
      }
 catch (      IOException ioe) {
        System.err.println(ERROR_OUTPUTREADER);
        ioe.printStackTrace();
        throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
      }
    }
  }
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    if (fileErrPath == null) {
      errorGobbler=new StreamGobbler(process.getErrorStream(),defaultErrStream,LogManager.getLogger(Loggers.WORKER));
      errorGobbler.start();
    }
 else {
      try (FileInputStream errStream=new FileInputStream(fileErrPath)){
        errorGobbler=new StreamGobbler(errStream,defaultErrStream,LogManager.getLogger(Loggers.WORKER));
        errorGobbler.start();
      }
 catch (      IOException ioe) {
        throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
      }
    }
  }
  if (outputGobbler != null) {
    try {
      outputGobbler.join();
    }
 catch (    InterruptedException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  System.out.println(""String_Node_Str"");
  if (errorGobbler != null) {
    try {
      errorGobbler.join();
    }
 catch (    InterruptedException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  System.err.println(""String_Node_Str"");
}"
70077,"/** 
 * Invokes an MPI method
 * @param mpiRunner
 * @param mpiBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numProcs;
  cmd[5]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes an MPI method
 * @param mpiRunner
 * @param mpiBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numProcs;
  cmd[5]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70078,"/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  String[] cmd;
  if (args.isEmpty()) {
    cmd=new String[NUM_BASE_DECAF_ARGS - 2];
  }
 else {
    cmd=new String[NUM_BASE_DECAF_ARGS];
  }
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  if (!args.isEmpty()) {
    cmd[9]=""String_Node_Str"";
    cmd[10]=args;
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  String[] cmd;
  if (args.isEmpty()) {
    cmd=new String[NUM_BASE_DECAF_ARGS - 2];
  }
 else {
    cmd=new String[NUM_BASE_DECAF_ARGS];
  }
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  if (!args.isEmpty()) {
    cmd[9]=""String_Node_Str"";
    cmd[10]=args;
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70079,"/** 
 * Invokes an OmpSs method
 * @param ompssBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes an OmpSs method
 * @param ompssBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70080,"/** 
 * Invokes a binary method
 * @param binary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeBinaryMethod(String binary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes a binary method
 * @param binary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeBinaryMethod(String binary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70081,"public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeMPIMethod(mpiRunner,mpiBinary,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeMPIMethod(mpiRunner,mpiBinary,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70082,"public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeDecafMethod(dfRunner,dfScript,dfExecutor,dfLib,mpiRunner,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeDecafMethod(dfRunner,dfScript,dfExecutor,dfLib,mpiRunner,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70083,"public static Object invokeOmpSsMethod(String ompssBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeOmpSsMethod(ompssBinary,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeOmpSsMethod(String ompssBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeOmpSsMethod(ompssBinary,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70084,"public static Object invokeBinaryMethod(String binary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeBinaryMethod(binary,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeBinaryMethod(String binary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeBinaryMethod(binary,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70085,"@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.binary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeBinaryMethod(this.binary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.binary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeBinaryMethod(this.binary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    LOGGER.error(""String_Node_Str"",iee);
    throw new JobExecutionException(iee);
  }
}"
70086,"private Object invokeDecafMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.dfScript + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeDecafMethod(nw.getInstallDir() + DecafImplementation.SCRIPT_PATH,this.dfScript,this.dfExecutor,this.dfLib,this.mpiRunner,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","private Object invokeDecafMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.dfScript + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeDecafMethod(nw.getInstallDir() + DecafImplementation.SCRIPT_PATH,this.dfScript,this.dfExecutor,this.dfLib,this.mpiRunner,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}"
70087,"private Object invokeMPIMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.mpiBinary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeMPIMethod(this.mpiRunner,this.mpiBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","private Object invokeMPIMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.mpiBinary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeMPIMethod(this.mpiRunner,this.mpiBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}"
70088,"@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + ompssBinary + ""String_Node_Str""+ nw.getHostName());
  try {
    return GenericInvoker.invokeOmpSsMethod(this.ompssBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + ompssBinary + ""String_Node_Str""+ nw.getHostName());
  try {
    return GenericInvoker.invokeOmpSsMethod(this.ompssBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}"
70089,"public void unregisterThread(){
  try {
    close();
    threadToStream.remove(Thread.currentThread().getId());
  }
 catch (  Exception e) {
    e.printStackTrace(System.err);
  }
}","public void unregisterThread(){
  try {
    flush();
    close();
    threadToStream.remove(Thread.currentThread().getId());
  }
 catch (  Exception e) {
    e.printStackTrace(System.err);
  }
}"
70090,"@Override public void run(){
  try {
    final byte[] buffer=new byte[BUFFER_SIZE];
    int nRead;
    while ((nRead=in.read(buffer,0,buffer.length)) != -1) {
      byte[] readData=new byte[nRead];
      System.arraycopy(buffer,0,readData,0,nRead);
      out.print(new String(readData));
    }
  }
 catch (  IOException ioe) {
    logger.error(""String_Node_Str"",ioe);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException ioe) {
        logger.warn(""String_Node_Str"",ioe);
      }
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}","@Override public void run(){
  logger.debug(""String_Node_Str"");
  try {
    final byte[] buffer=new byte[BUFFER_SIZE];
    int nRead;
    while ((nRead=in.read(buffer,0,buffer.length)) != -1) {
      byte[] readData=new byte[nRead];
      System.arraycopy(buffer,0,readData,0,nRead);
      out.print(new String(readData));
      out.flush();
    }
  }
 catch (  IOException ioe) {
    logger.error(""String_Node_Str"",ioe);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException ioe) {
        logger.warn(""String_Node_Str"",ioe);
      }
    }
    if (out != null) {
      out.flush();
    }
  }
}"
70091,"/** 
 * Tries to schedule the current action
 * @throws InvalidSchedulingException
 */
public final void tryToLaunch() throws InvalidSchedulingException {
  lock.lock();
  if (selectedResource != null && state == State.RUNNABLE && !hasDataPredecessors() && schedulingInfo.isExecutable()) {
    if (selectedResource.isRemoved() || (isSchedulingConstrained() && unrequiredResource() || isTargetResourceEnforced() && selectedResource != schedulingInfo.getEnforcedTargetResource())) {
      lock.unlock();
      throw new InvalidSchedulingException();
    }
    execute();
  }
 else {
    lock.unlock();
  }
}","/** 
 * Tries to schedule the current action
 * @throws InvalidSchedulingException
 */
public final void tryToLaunch() throws InvalidSchedulingException {
  lock.lock();
  if (selectedResource != null && state == State.RUNNABLE && !hasDataPredecessors() && schedulingInfo.isExecutable()) {
    if ((selectedResource.isRemoved() && !isToStopResource()) || (isSchedulingConstrained() && unrequiredResource() || isTargetResourceEnforced() && selectedResource != schedulingInfo.getEnforcedTargetResource())) {
      lock.unlock();
      throw new InvalidSchedulingException();
    }
    execute();
  }
 else {
    lock.unlock();
  }
}"
70092,"public boolean isTaskFile(String fileName){
  if (fileName == null) {
    File f=new File(fileName);
    if (taskFiles.contains(f.getAbsolutePath())) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","public boolean isTaskFile(String fileName){
  if (fileName != null) {
    File f=new File(fileName);
    if (taskFiles.contains(f.getAbsolutePath())) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
70093,"/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
  for (  Resource r : loc.getHosts()) {
switch (loc.getType()) {
case PRIVATE:
      r.addLogicalData(this);
    break;
case SHARED:
  SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}
}","/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
switch (loc.getType()) {
case PRIVATE:
    for (    Resource r : loc.getHosts()) {
      r.addLogicalData(this);
    }
  break;
case SHARED:
SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}"
70094,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null)   return;
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
      return;
    }
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName());
  }
  orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null) {
    return;
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  if (ld.getId() != null) {
    orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
  }
 else {
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + ld.getName());
    }
    orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
  }
}"
70095,"private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,Comm.getAppHost().getName());
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}","private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,targetHostname);
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}"
70096,"/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
  for (  Resource r : loc.getHosts()) {
switch (loc.getType()) {
case PRIVATE:
      r.addLogicalData(this);
    break;
case SHARED:
  SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}
}","/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
switch (loc.getType()) {
case PRIVATE:
    for (    Resource r : loc.getHosts()) {
      r.addLogicalData(this);
    }
  break;
case SHARED:
SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}"
70097,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null)   return;
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
      return;
    }
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName());
  }
  orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null) {
    return;
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  if (ld.getId() != null) {
    orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
  }
 else {
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + ld.getName());
    }
    orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
  }
}"
70098,"private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,Comm.getAppHost().getName());
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}","private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,targetHostname);
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}"
70099,"@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.taskId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}","@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.jobId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}"
70100,"/** 
 * New task result from a given set of   {@code params}
 * @param taskId
 * @param params
 */
public NIOTaskResult(int taskId,LinkedList<NIOParam> params){
  this.taskId=taskId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}","/** 
 * New task result from a given set of   {@code params}
 * @param jobId
 * @param params
 */
public NIOTaskResult(int jobId,LinkedList<NIOParam> params){
  this.jobId=jobId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}"
70101,"@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.taskId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}","@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.jobId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}"
70102,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.taskId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.jobId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
70103,"public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription());
  resourceUser.updatedResource(worker,modification);
}","public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription().copy());
  resourceUser.updatedResource(worker,modification);
}"
70104,"/** 
 * Selects a subset of the critical set able to execute all the cores
 */
public void defineCriticalSet(){
synchronized (this) {
    int coreCount=CoreManager.getCoreCount();
    boolean[] runnable=new boolean[coreCount];
    for (int coreId=0; coreId < coreCount; coreId++) {
      runnable[coreId]=false;
    }
    String resourceName;
    for (    Worker<? extends WorkerResourceDescription> res : staticSet.values()) {
      List<Integer> cores=res.getExecutableCores();
      for (int i=0; i < cores.size(); i++) {
        runnable[cores.get(i)]=true;
      }
    }
    for (    DynamicMethodWorker resource : criticalOrder) {
      resourceName=resource.getName();
      List<Integer> executableCores=resource.getExecutableCores();
      boolean needed=false;
      for (int i=0; i < executableCores.size() && !needed; i++) {
        needed=needed || !runnable[executableCores.get(i)];
      }
      if (needed) {
        for (int i=0; i < executableCores.size(); i++) {
          runnable[executableCores.get(i)]=true;
        }
      }
 else {
        criticalSet.remove(resourceName);
        criticalOrder.remove(resource);
        nonCriticalSet.put(resourceName,resource);
      }
    }
  }
}","/** 
 * Selects a subset of the critical set able to execute all the cores
 */
public void defineCriticalSet(){
synchronized (this) {
    int coreCount=CoreManager.getCoreCount();
    boolean[] runnable=new boolean[coreCount];
    for (int coreId=0; coreId < coreCount; coreId++) {
      runnable[coreId]=false;
    }
    String resourceName;
    for (    Worker<? extends WorkerResourceDescription> res : staticSet.values()) {
      List<Integer> cores=res.getExecutableCores();
      for (int i=0; i < cores.size(); i++) {
        runnable[cores.get(i)]=true;
      }
    }
    LinkedList<DynamicMethodWorker> criticalOrderRemovals=new LinkedList();
    for (    DynamicMethodWorker resource : criticalOrder) {
      resourceName=resource.getName();
      List<Integer> executableCores=resource.getExecutableCores();
      boolean needed=false;
      for (int i=0; i < executableCores.size() && !needed; i++) {
        needed=needed || !runnable[executableCores.get(i)];
      }
      if (needed) {
        for (int i=0; i < executableCores.size(); i++) {
          runnable[executableCores.get(i)]=true;
        }
      }
 else {
        criticalSet.remove(resourceName);
        criticalOrderRemovals.add(resource);
        nonCriticalSet.put(resourceName,resource);
      }
    }
    for (    DynamicMethodWorker resource : criticalOrderRemovals) {
      criticalOrder.remove(resource);
    }
  }
}"
70105,"public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription());
  resourceUser.updatedResource(worker,modification);
}","public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription().copy());
  resourceUser.updatedResource(worker,modification);
}"
70106,"@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.taskId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}","@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.jobId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}"
70107,"/** 
 * New task result from a given set of   {@code params}
 * @param taskId
 * @param params
 */
public NIOTaskResult(int taskId,LinkedList<NIOParam> params){
  this.taskId=taskId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}","/** 
 * New task result from a given set of   {@code params}
 * @param jobId
 * @param params
 */
public NIOTaskResult(int jobId,LinkedList<NIOParam> params){
  this.jobId=jobId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}"
70108,"@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.taskId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}","@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.jobId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}"
70109,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.taskId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.jobId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
70110,"/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String[] cmd=new String[NUM_BASE_DECAF_ARGS];
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  cmd[9]=""String_Node_Str"" + args + ""String_Node_Str"";
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  String[] cmd;
  if (args.isEmpty()) {
    cmd=new String[NUM_BASE_DECAF_ARGS - 1];
  }
 else {
    cmd=new String[NUM_BASE_DECAF_ARGS];
  }
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  if (!args.isEmpty()) {
    cmd[9]=""String_Node_Str"" + args + ""String_Node_Str"";
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}"
70111,"@Override public Object invokeMethod() throws JobExecutionException {
  checkArguments();
  return invokeMPIMethod();
}","@Override public Object invokeMethod() throws JobExecutionException {
  checkArguments();
  return invokeDecafMethod();
}"
70112,"private static void addArguments(ArrayList<String> lArgs,NIOTask nt,NIOWorker nw) throws JobExecutionException, SerializedObjectException {
  lArgs.add(Boolean.toString(NIOTracer.isActivated()));
  lArgs.add(Integer.toString(nt.getTaskId()));
  lArgs.add(Boolean.toString(nt.isWorkerDebug()));
  lArgs.add(STORAGE_CONF);
  if (nt.getMethodType() != MethodType.METHOD) {
    throw new JobExecutionException(ERROR_UNSUPPORTED_JOB_TYPE);
  }
  MethodImplementation impl=(MethodImplementation)nt.getMethodImplementation();
  lArgs.add(String.valueOf(impl.getMethodType()));
  lArgs.add(impl.getDeclaringClass());
  lArgs.add(impl.getAlternativeMethodName());
  lArgs.add(String.valueOf(nt.getSlaveWorkersNodeNames().size()));
  lArgs.addAll(nt.getSlaveWorkersNodeNames());
  lArgs.add(String.valueOf(nt.getResourceDescription().getTotalCPUComputingUnits()));
  lArgs.add(Boolean.toString(nt.isHasTarget()));
  if (nt.isHasReturn()) {
    DataType returnType=nt.getParams().getLast().getType();
    lArgs.add(Integer.toString(returnType.ordinal()));
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Integer.toString(nt.getNumParams()));
  for (  NIOParam np : nt.getParams()) {
    DataType type=np.getType();
    lArgs.add(Integer.toString(type.ordinal()));
    lArgs.add(Integer.toString(np.getStream().ordinal()));
    lArgs.add(np.getPrefix());
switch (type) {
case FILE_T:
      String destFile=new File(np.getValue().toString()).getName();
    String originalFile=""String_Node_Str"";
  if (np.getData() != null) {
    originalFile=np.getData().getName();
  }
lArgs.add(originalFile + ""String_Node_Str"" + destFile+ ""String_Node_Str""+ np.isPreserveSourceData()+ ""String_Node_Str""+ np.isWriteFinalValue()+ ""String_Node_Str""+ np.getOriginalName());
break;
case OBJECT_T:
case PSCO_T:
case EXTERNAL_OBJECT_T:
lArgs.add(np.getValue().toString());
lArgs.add(np.isWriteFinalValue() ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case STRING_T:
String value=np.getValue().toString();
String[] vals=value.split(""String_Node_Str"");
int numSubStrings=vals.length;
lArgs.add(Integer.toString(numSubStrings));
for (String v : vals) {
lArgs.add(v);
}
break;
default :
lArgs.add(np.getValue().toString());
}
}
}","private static void addArguments(ArrayList<String> lArgs,NIOTask nt,NIOWorker nw) throws JobExecutionException, SerializedObjectException {
  lArgs.add(Boolean.toString(NIOTracer.isActivated()));
  lArgs.add(Integer.toString(nt.getTaskId()));
  lArgs.add(Boolean.toString(nt.isWorkerDebug()));
  lArgs.add(STORAGE_CONF);
  if (nt.getMethodType() != MethodType.METHOD) {
    throw new JobExecutionException(ERROR_UNSUPPORTED_JOB_TYPE);
  }
  MethodImplementation impl=(MethodImplementation)nt.getMethodImplementation();
  lArgs.add(String.valueOf(impl.getMethodType()));
  lArgs.add(impl.getDeclaringClass());
  lArgs.add(impl.getAlternativeMethodName());
  lArgs.add(String.valueOf(nt.getSlaveWorkersNodeNames().size()));
  lArgs.addAll(nt.getSlaveWorkersNodeNames());
  lArgs.add(String.valueOf(nt.getResourceDescription().getTotalCPUComputingUnits()));
  lArgs.add(Boolean.toString(nt.isHasTarget()));
  if (nt.isHasReturn()) {
    DataType returnType=nt.getParams().getLast().getType();
    lArgs.add(Integer.toString(returnType.ordinal()));
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Integer.toString(nt.getNumParams()));
  for (  NIOParam np : nt.getParams()) {
    DataType type=np.getType();
    lArgs.add(Integer.toString(type.ordinal()));
    lArgs.add(Integer.toString(np.getStream().ordinal()));
    lArgs.add(np.getPrefix());
switch (type) {
case FILE_T:
      String originalFile=""String_Node_Str"";
    if (np.getData() != null) {
      originalFile=np.getData().getName();
    }
  String destFile=new File(np.getValue().toString()).getName();
if (!isRuntimeRenamed(destFile)) {
  destFile=originalFile;
}
lArgs.add(originalFile + ""String_Node_Str"" + destFile+ ""String_Node_Str""+ np.isPreserveSourceData()+ ""String_Node_Str""+ np.isWriteFinalValue()+ ""String_Node_Str""+ np.getOriginalName());
break;
case OBJECT_T:
case PSCO_T:
case EXTERNAL_OBJECT_T:
lArgs.add(np.getValue().toString());
lArgs.add(np.isWriteFinalValue() ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case STRING_T:
String value=np.getValue().toString();
String[] vals=value.split(""String_Node_Str"");
int numSubStrings=vals.length;
lArgs.add(Integer.toString(numSubStrings));
for (String v : vals) {
lArgs.add(v);
}
break;
default :
lArgs.add(np.getValue().toString());
}
}
}"
70113,"private static String writeHostfile(File taskSandboxWorkingDir,String workers) throws InvokeExecutionException {
  String filename=taskSandboxWorkingDir.getAbsolutePath() + File.separator + ""String_Node_Str"";
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(filename));
    writer.write(workers);
  }
 catch (  IOException e) {
    throw new InvokeExecutionException(""String_Node_Str"",e);
  }
 finally {
    try {
      if (writer != null)       writer.close();
    }
 catch (    IOException e) {
    }
  }
  return filename;
}","private static String writeHostfile(File taskSandboxWorkingDir,String workers) throws InvokeExecutionException {
  String filename=taskSandboxWorkingDir.getAbsolutePath() + File.separator + ""String_Node_Str"";
  String workersInLines=workers.replace(',','\n');
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(filename));
    writer.write(workersInLines);
  }
 catch (  IOException e) {
    throw new InvokeExecutionException(""String_Node_Str"",e);
  }
 finally {
    try {
      if (writer != null)       writer.close();
    }
 catch (    IOException e) {
    }
  }
  return filename;
}"
70114,"public void newCoreElementsDetected(List<Integer> newCores){
  int coreCount=CoreManager.getCoreCount();
  for (  CloudInstanceTypeDescription type : types.values()) {
    int[][] slotsI=new int[coreCount][];
    int[] slotsC=type.getSlotsCore().clone();
    for (int i=0; i < type.getSlotsImplLength(); ++i) {
      int[] slotsImpl=type.getSpecificSlotsImpl(i);
      slotsI[i]=slotsImpl.clone();
    }
    for (    int coreId : newCores) {
      List<Implementation> impls=CoreManager.getCoreImplementations(coreId);
      int implsSize=impls.size();
      slotsI[coreId]=new int[implsSize];
      for (int implId=0; implId < implsSize; ++implId) {
        Implementation impl=impls.get(implId);
        if (impl.getTaskType() == TaskType.METHOD) {
          MethodResourceDescription rd=(MethodResourceDescription)impl.getRequirements();
          Integer into=type.getResourceDescription().canHostSimultaneously(rd);
          slotsC[coreId]=Math.max(slotsC[coreId],into);
          slotsI[coreId][implId]=into;
        }
      }
    }
    type.setSlotsCore(slotsC);
    type.setSlotsImpl(slotsI);
  }
}","public void newCoreElementsDetected(List<Integer> newCores){
  int coreCount=CoreManager.getCoreCount();
  for (  CloudInstanceTypeDescription type : types.values()) {
    int[][] slotsI=new int[coreCount][];
    int[] slotsC=Arrays.copyOf(type.getSlotsCore(),coreCount);
    for (int i=0; i < type.getSlotsImplLength(); ++i) {
      int[] slotsImpl=type.getSpecificSlotsImpl(i);
      slotsI[i]=slotsImpl.clone();
    }
    for (    int coreId : newCores) {
      List<Implementation> impls=CoreManager.getCoreImplementations(coreId);
      int implsSize=impls.size();
      slotsI[coreId]=new int[implsSize];
      for (int implId=0; implId < implsSize; ++implId) {
        Implementation impl=impls.get(implId);
        if (impl.getTaskType() == TaskType.METHOD) {
          MethodResourceDescription rd=(MethodResourceDescription)impl.getRequirements();
          Integer into=type.getResourceDescription().canHostSimultaneously(rd);
          slotsC[coreId]=Math.max(slotsC[coreId],into);
          slotsI[coreId][implId]=into;
        }
      }
    }
    type.setSlotsCore(slotsC);
    type.setSlotsImpl(slotsI);
  }
}"
70115,"/** 
 * Returns the total slots per per core
 * @return
 */
public static int[] getTotalSlots(){
  int[] counts=new int[CoreManager.getCoreCount()];
  int[] cloudCount=cloudManager.getPendingCoreCounts();
synchronized (pool) {
    for (int i=0; i < counts.length; i++) {
      if (i < cloudCount.length) {
        counts[i]=poolCoreMaxConcurrentTasks[i] + cloudCount[i];
      }
 else {
        counts[i]=poolCoreMaxConcurrentTasks[i];
      }
    }
  }
  return counts;
}","/** 
 * Returns the total slots per per core
 * @return
 */
public static int[] getTotalSlots(){
  int[] counts=new int[CoreManager.getCoreCount()];
  if (CoreManager.getCoreCount() > 0) {
    int[] cloudCount=cloudManager.getPendingCoreCounts();
synchronized (pool) {
      for (int i=0; i < counts.length; i++) {
        if (i < cloudCount.length) {
          counts[i]=poolCoreMaxConcurrentTasks[i] + cloudCount[i];
        }
 else {
          counts[i]=poolCoreMaxConcurrentTasks[i];
        }
      }
    }
  }
  return counts;
}"
70116,"/** 
 * Updates the coreElement information
 * @param updatedCores
 */
public static void coreElementUpdates(List<Integer> updatedCores){
synchronized (pool) {
    pool.coreElementUpdates(updatedCores);
    cloudManager.newCoreElementsDetected(updatedCores);
  }
}","/** 
 * Updates the coreElement information
 * @param updatedCores
 */
public static void coreElementUpdates(List<Integer> updatedCores){
synchronized (pool) {
    pool.coreElementUpdates(updatedCores);
    cloudManager.newCoreElementsDetected(updatedCores);
    updateMaxConcurrentTasks(updatedCores);
  }
}"
70117,"public boolean isPreserveSourceData(){
  return readDataVersion.hasPendingLectures();
}","public boolean isPreserveSourceData(){
  return readDataVersion.isOnlyReader();
}"
70118,"/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new Jedis(MASTER_HOSTNAME,REDIS_PORT);
  }
}","/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line TODO: What to do with storage conf? StorageItf.init needs different content wrt storage_init.sh
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new JedisPool(MASTER_HOSTNAME,REDIS_PORT);
  }
}"
70119,"/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  if (clusterMode) {
    redisClusterConnection.del(id.getBytes());
  }
 else {
    redisConnection.del(id.getBytes());
  }
}","/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  if (clusterMode) {
    redisClusterConnection.del(id.getBytes());
  }
 else {
    redisConnection.getResource().del(id.getBytes());
  }
}"
70120,"/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  byte[] serializedObject=Serializer.serialize(o);
  String result=clusterMode ? redisClusterConnection.set(id.getBytes(),serializedObject) : redisConnection.set(id.getBytes(),serializedObject);
  if (!result.equals(""String_Node_Str"")) {
    throw new StorageException(""String_Node_Str"" + id);
  }
}","/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  byte[] serializedObject=Serializer.serialize(o);
  String result=clusterMode ? redisClusterConnection.set(id.getBytes(),serializedObject) : redisConnection.getResource().set(id.getBytes(),serializedObject);
  if (!result.equals(""String_Node_Str"")) {
    throw new StorageException(""String_Node_Str"" + id);
  }
}"
70121,"/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.get(id.getBytes());
  if (serializedObject == null) {
    throw new StorageException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}","/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.getResource().get(id.getBytes());
  if (serializedObject == null) {
    throw new StorageException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}"
70122,"/** 
 * Returns all the valid locations of a given id WARNING: Given that Redis has no immediate mechanisms to retrieve this information, we will return all the nodes instead, because a connection to any of them will grant us that we can retrieve it
 * @param id
 * @return
 * @throws StorageException
 */
public static List<String> getLocations(String id) throws StorageException {
  return hosts;
}","/** 
 * Returns all the valid locations of a given id WARNING: Given that Redis has no immediate mechanisms to retrieve this information, we will return all the nodes instead, because a connection to any of them will grant us that we can retrieve it
 * @param id
 * @return
 * @throws StorageException
 */
public static List<String> getLocations(String id) throws StorageException {
  if (clusterMode) {
    return hosts;
  }
  return hosts;
}"
70123,"/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  System.out.println(""String_Node_Str"" + MASTER_HOSTNAME);
  System.out.flush();
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new Jedis(MASTER_HOSTNAME,REDIS_PORT);
  }
}","/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new Jedis(MASTER_HOSTNAME,REDIS_PORT);
  }
}"
70124,"/** 
 * Consolidates all intermediate versions to the final id
 * @param idFinal
 * @throws StorageException
 */
public static void consolidateVersion(String idFinal) throws StorageException {
  LOGGER.info(""String_Node_Str"" + idFinal);
  idFinal=previousVersion.get(idFinal);
  previousVersion.remove(idFinal);
  while (idFinal != null) {
    removeById(idFinal);
    idFinal=previousVersion.get(idFinal);
    previousVersion.remove(idFinal);
  }
}","/** 
 * Consolidates all intermediate versions to the final id
 * @param idFinal
 * @throws StorageException
 */
public static void consolidateVersion(String idFinal) throws StorageException {
  LOGGER.info(""String_Node_Str"" + idFinal);
  idFinal=previousVersion.get(idFinal);
  while (idFinal != null) {
    LOGGER.info(""String_Node_Str"" + idFinal);
    removeById(idFinal);
    String oldId=idFinal;
    idFinal=previousVersion.get(idFinal);
    previousVersion.remove(oldId);
  }
}"
70125,"/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.get(id.getBytes());
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}","/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.get(id.getBytes());
  if (serializedObject == null) {
    throw new StorageException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}"
70126,"/** 
 * Retrieves the result of persistent storage execution
 * @param event
 * @return
 */
public static Object getResult(CallbackEvent event) throws StorageException {
  if (true)   throw new StorageException(""String_Node_Str"");
  return null;
}","/** 
 * Retrieves the result of persistent storage execution
 * @param event
 * @return
 */
public static Object getResult(CallbackEvent event) throws StorageException {
  throw new StorageException(""String_Node_Str"");
}"
70127,"@Override public ResourceDescription getDynamicCommons(ResourceDescription other){
  MethodResourceDescription otherMRD=(MethodResourceDescription)other;
  MethodResourceDescription common=new MethodResourceDescription();
  for (  Processor p : otherMRD.getProcessors()) {
    boolean isProcessorCompatible=false;
    int i=0;
    while (i < this.processors.size() && !isProcessorCompatible) {
      Processor pThis=this.processors.get(i);
      if (checkProcessorCompatibility(pThis,p)) {
        isProcessorCompatible=true;
        common.addProcessor(getDynamicCommonsProcessor(pThis,p));
      }
      i=i + 1;
    }
  }
  if (checkCompatibility(this.memoryType,otherMRD.memoryType)) {
    common.setMemoryType(this.getMemoryType());
    common.setMemorySize(Math.min(this.memorySize,otherMRD.getMemorySize()));
  }
  return common;
}","@Override public ResourceDescription getDynamicCommons(ResourceDescription other){
  MethodResourceDescription otherMRD=(MethodResourceDescription)other;
  MethodResourceDescription common=new MethodResourceDescription();
  for (  Processor p : otherMRD.getProcessors()) {
    boolean isProcessorCompatible=false;
    int i=0;
    while (i < this.processors.size() && !isProcessorCompatible) {
      Processor pThis=this.processors.get(i);
      if (checkProcessorCompatibility(pThis,p)) {
        isProcessorCompatible=true;
        Processor commonProcessor=getDynamicCommonsProcessor(pThis,p);
        if (commonProcessor.getComputingUnits() > 0) {
          common.addProcessor(commonProcessor);
        }
      }
      i=i + 1;
    }
  }
  if (checkCompatibility(this.memoryType,otherMRD.memoryType)) {
    common.setMemoryType(this.getMemoryType());
    common.setMemorySize(Math.min(this.memorySize,otherMRD.getMemorySize()));
  }
  return common;
}"
70128,"public int getSpecificSlotsImpl(int i,int j){
  return this.slotsImpl[i][j];
}","public int getSpecificSlotsImpl(int coreId,int implId){
  return this.slotsImpl[coreId][implId];
}"
70129,"/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  redisConnection=new Jedis(""String_Node_Str"",6379);
  hosts=new String[]{""String_Node_Str""};
}","/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  System.out.println(""String_Node_Str"" + storageConf);
  redisConnection=new Jedis(""String_Node_Str"",6379);
  hosts=new String[]{""String_Node_Str""};
}"
70130,"/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  LOGGER.debug(""String_Node_Str"" + id);
  redisConnection.del(id.getBytes());
  LOGGER.debug(""String_Node_Str"");
}","/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  redisConnection.del(id.getBytes());
}"
70131,"/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  LOGGER.debug(""String_Node_Str"");
  byte[] serializedObject=Serializer.serialize(o);
  LOGGER.debug(""String_Node_Str"");
  redisConnection.set(id.getBytes(),serializedObject);
  LOGGER.debug(""String_Node_Str"");
}","/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  byte[] serializedObject=Serializer.serialize(o);
  String result=redisConnection.set(id.getBytes(),serializedObject);
  if (!result.equals(""String_Node_Str"")) {
    throw new StorageException(""String_Node_Str"" + id);
  }
}"
70132,"/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  LOGGER.debug(""String_Node_Str"");
  byte[] serializedObject=redisConnection.get(id.getBytes());
  LOGGER.debug(""String_Node_Str"");
  Object ret=Serializer.deserialize(serializedObject);
  LOGGER.debug(""String_Node_Str"");
  return ret;
}","/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=redisConnection.get(id.getBytes());
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}"
70133,"/** 
 * Create a new version of the PSCO id @id in the host @hostname Returns the id of the new version
 * @param id
 * @param hostName
 * @return
 * @throws StorageException
 */
public static String newVersion(String id,boolean preserveSource,String hostName) throws StorageException {
  return null;
}","/** 
 * Create a new version of the PSCO id @id in the host @hostname Returns the id of the new version
 * @param id
 * @param hostName
 * @return
 * @throws StorageException
 */
public static String newVersion(String id,boolean preserveSource,String hostName) throws StorageException, IOException, ClassNotFoundException {
  Object obj=getByID(id);
  String new_id=UUID.randomUUID().toString();
  makePersistent(obj,new_id);
  if (!preserveSource) {
    removeById(id);
  }
  return new_id;
}"
70134,"/** 
 * Sets the ID
 */
protected void setID(String id) throws IOException, StorageException {
  if (this.id != null) {
    StorageItf.removeById(id);
    StorageItf.makePersistent(this,id);
  }
  this.id=id;
}","/** 
 * Sets the ID
 */
protected void setID(String id) throws IOException, StorageException {
  this.id=id;
}"
70135,"private static String getLsCpuOutput() throws InvalidMapException {
  String cmdOutput=null;
  ProcessBuilder pb=new ProcessBuilder(""String_Node_Str"");
  try {
    Process process=pb.start();
    process.getOutputStream().close();
    int exitValue=process.waitFor();
    if (exitValue != 0) {
      throw new InvalidMapException(""String_Node_Str"" + exitValue);
    }
    StringBuilder sb=new StringBuilder();
    try (BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=br.readLine()) != null) {
        sb.append(line).append(""String_Node_Str"");
      }
    }
 catch (    IOException ioe) {
      throw new InvalidMapException(""String_Node_Str"",ioe);
    }
    cmdOutput=sb.toString();
  }
 catch (  IOException ioe) {
    throw new InvalidMapException(""String_Node_Str"",ioe);
  }
catch (  InterruptedException ie) {
    throw new InvalidMapException(""String_Node_Str"",ie);
  }
  return cmdOutput;
}","private static String getLsCpuOutput() throws InvalidMapException {
  String cmdOutput=null;
  ProcessBuilder pb=new ProcessBuilder(""String_Node_Str"");
  try {
    pb.environment().remove(Tracer.LD_PRELOAD);
    Process process=pb.start();
    process.getOutputStream().close();
    int exitValue=process.waitFor();
    if (exitValue != 0) {
      throw new InvalidMapException(""String_Node_Str"" + exitValue);
    }
    StringBuilder sb=new StringBuilder();
    try (BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=br.readLine()) != null) {
        sb.append(line).append(""String_Node_Str"");
      }
    }
 catch (    IOException ioe) {
      throw new InvalidMapException(""String_Node_Str"",ioe);
    }
    cmdOutput=sb.toString();
  }
 catch (  IOException ioe) {
    throw new InvalidMapException(""String_Node_Str"",ioe);
  }
catch (  InterruptedException ie) {
    throw new InvalidMapException(""String_Node_Str"",ie);
  }
  return cmdOutput;
}"
70136,"/** 
 * New Core Elements have been detected; the Task Scheduler needs to be notified to modify any internal structure using that information.
 */
public final void coreElementsUpdated(){
  LOGGER.info(""String_Node_Str"");
  int newCoreCount=CoreManager.getCoreCount();
  SchedulingInformation.updateCoreCount(newCoreCount);
  this.blockedActions.updateCoreCount(newCoreCount);
  this.readyCounts=new int[newCoreCount];
  for (  ResourceScheduler<P,T,I> rs : workers.values()) {
    rs.updatedCoreElements(newCoreCount);
  }
}","/** 
 * New Core Elements have been detected; the Task Scheduler needs to be notified to modify any internal structure using that information.
 */
public final void coreElementsUpdated(){
  LOGGER.info(""String_Node_Str"");
  int newCoreCount=CoreManager.getCoreCount();
  SchedulingInformation.updateCoreCount(newCoreCount);
  this.blockedActions.updateCoreCount(newCoreCount);
  this.readyCounts=new int[newCoreCount];
  for (  ResourceScheduler<P,T,I> rs : workers.values()) {
    rs.updatedCoreElements(newCoreCount);
    SchedulingInformation.updateResource(rs);
  }
}"
70137,"@SuppressWarnings(""String_Node_Str"") public static <P extends Profile,T extends WorkerResourceDescription,I extends Implementation<T>>void changesOnWorker(ResourceScheduler<P,T,I> ui){
  for (  LinkedList<ResourceScheduler<Profile,WorkerResourceDescription,Implementation<WorkerResourceDescription>>> coreToWorker : coreToWorkers) {
    coreToWorker.remove(ui);
  }
  SchedulingInformation.updateCoreCount(CoreManager.getCoreCount());
  LinkedList<Integer> executableCores=ui.getExecutableCores();
  for (  int coreId : executableCores) {
    coreToWorkers.get(coreId).add((ResourceScheduler<Profile,WorkerResourceDescription,Implementation<WorkerResourceDescription>>)ui);
  }
}","public static <P extends Profile,T extends WorkerResourceDescription,I extends Implementation<T>>void changesOnWorker(ResourceScheduler<P,T,I> ui){
  for (  LinkedList<ResourceScheduler<Profile,WorkerResourceDescription,Implementation<WorkerResourceDescription>>> coreToWorker : coreToWorkers) {
    coreToWorker.remove(ui);
  }
  SchedulingInformation.updateCoreCount(CoreManager.getCoreCount());
  updateResource(ui);
}"
70138,"@Decaf(dfScript=""String_Node_Str"",mpiRunner=""String_Node_Str"",computingNodes=""String_Node_Str"") @Constraints(computingUnits=""String_Node_Str"") Integer taskConcurrentMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);","@Constraints(computingUnits=""String_Node_Str"") Integer taskConcurrentMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);"
70139,"@Decaf(dfScript=""String_Node_Str"",mpiRunner=""String_Node_Str"",computingNodes=""String_Node_Str"") @Constraints(computingUnits=""String_Node_Str"") int taskSingleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);","@Constraints(computingUnits=""String_Node_Str"") int taskSingleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);"
70140,"@Decaf(dfScript=""String_Node_Str"",mpiRunner=""String_Node_Str"",computingNodes=""String_Node_Str"") @Constraints(computingUnits=""String_Node_Str"") Integer taskMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);","@Constraints(computingUnits=""String_Node_Str"") Integer taskMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);"
70141,"/** 
 * Sets MPI / OMPSs environment variables
 */
private static void setEnvironmentVariables(){
  String hostname=""String_Node_Str"";
  try {
    hostname=InetAddress.getLocalHost().getHostName();
  }
 catch (  UnknownHostException e1) {
    ErrorManager.warn(""String_Node_Str"" + hostname);
  }
  GATWorker.hostnames.add(hostname);
  ++GATWorker.numNodes;
  boolean firstElement=true;
  StringBuilder hostnamesSTR=new StringBuilder();
  for (Iterator<String> it=GATWorker.hostnames.iterator(); it.hasNext(); ) {
    String nodeName=it.next();
    if (nodeName.endsWith(""String_Node_Str"")) {
      nodeName=nodeName.substring(0,hostname.lastIndexOf(""String_Node_Str""));
    }
    if (firstElement) {
      firstElement=false;
      hostnamesSTR.append(hostname);
      for (int i=1; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(hostname);
      }
    }
 else {
      for (int i=0; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(hostname);
      }
    }
  }
  if (GATWorker.debug) {
    System.out.println(""String_Node_Str"" + hostnamesSTR.toString());
    System.out.println(""String_Node_Str"" + GATWorker.numNodes);
    System.out.println(""String_Node_Str"" + GATWorker.cus);
  }
  System.setProperty(Constants.COMPSS_HOSTNAMES,hostnamesSTR.toString());
  System.setProperty(Constants.COMPSS_NUM_NODES,String.valueOf(GATWorker.numNodes));
  System.setProperty(Constants.COMPSS_NUM_THREADS,String.valueOf(GATWorker.cus));
}","/** 
 * Sets MPI / OMPSs environment variables
 */
private static void setEnvironmentVariables(){
  String hostname=""String_Node_Str"";
  try {
    hostname=InetAddress.getLocalHost().getHostName();
  }
 catch (  UnknownHostException e1) {
    ErrorManager.warn(""String_Node_Str"" + hostname);
  }
  GATWorker.hostnames.add(hostname);
  ++GATWorker.numNodes;
  boolean firstElement=true;
  StringBuilder hostnamesSTR=new StringBuilder();
  for (  String nodeName : GATWorker.hostnames) {
    if (nodeName.endsWith(""String_Node_Str"")) {
      nodeName=nodeName.substring(0,nodeName.lastIndexOf(""String_Node_Str""));
    }
    if (firstElement) {
      firstElement=false;
      hostnamesSTR.append(nodeName);
      for (int i=1; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(nodeName);
      }
    }
 else {
      for (int i=0; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(nodeName);
      }
    }
  }
  if (GATWorker.debug) {
    System.out.println(""String_Node_Str"" + hostnamesSTR.toString());
    System.out.println(""String_Node_Str"" + GATWorker.numNodes);
    System.out.println(""String_Node_Str"" + GATWorker.cus);
  }
  System.setProperty(Constants.COMPSS_HOSTNAMES,hostnamesSTR.toString());
  System.setProperty(Constants.COMPSS_NUM_NODES,String.valueOf(GATWorker.numNodes));
  System.setProperty(Constants.COMPSS_NUM_THREADS,String.valueOf(GATWorker.cus));
}"
70142,"private void deleteFolder(File folder){
  if (folder.isDirectory()) {
    for (    File f : folder.listFiles()) {
      deleteFolder(f);
    }
  }
  if (!folder.delete()) {
    logger.error(""String_Node_Str"" + (folder == null ? ""String_Node_Str"" : folder.getName()));
  }
}","private void deleteFolder(File folder){
  if (folder.isDirectory()) {
    for (    File f : folder.listFiles()) {
      deleteFolder(f);
    }
  }
  if (!folder.delete()) {
    LOGGER.error(""String_Node_Str"" + (folder == null ? ""String_Node_Str"" : folder.getName()));
  }
}"
70143,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  logger.info(""String_Node_Str"" + ld.getName());
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      logger.debug(""String_Node_Str"" + loc.getPath());
      reason.setDataTarget(loc.getPath());
      listener.notifyEnd(null);
      return;
    }
  }
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
    if (tgtData != null) {
      tgtData.addLocation(target);
    }
    logger.debug(""String_Node_Str"" + target.getPath());
    reason.setDataTarget(target.getPath());
    listener.notifyEnd(null);
    return;
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (debug) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      logger.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
      try {
        if (debug) {
          logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        logger.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (debug) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        String sourcePath=source.getURIInHost(Comm.getAppHost()).getPath();
        String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          logger.debug(""String_Node_Str"" + target.getPath());
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        continue;
      }
      logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoval();
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  LOGGER.info(""String_Node_Str"" + ld.getName());
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      LOGGER.debug(""String_Node_Str"" + loc.getPath());
      reason.setDataTarget(loc.getPath());
      listener.notifyEnd(null);
      return;
    }
  }
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
    if (tgtData != null) {
      tgtData.addLocation(target);
    }
    LOGGER.debug(""String_Node_Str"" + target.getPath());
    reason.setDataTarget(target.getPath());
    listener.notifyEnd(null);
    return;
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
      try {
        if (DEBUG) {
          LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        String sourcePath=source.getURIInHost(Comm.getAppHost()).getPath();
        String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          LOGGER.debug(""String_Node_Str"" + target.getPath());
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoval();
}"
70144,"private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
    Thread.currentThread().interrupt();
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + copy.getName() + ""String_Node_Str""+ copy.getId()+ ""String_Node_Str"");
  }
}","private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
    Thread.currentThread().interrupt();
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + copy.getName() + ""String_Node_Str""+ copy.getId()+ ""String_Node_Str"");
  }
}"
70145,"@Override public void setWorkerIsReady(String nodeName){
  logger.info(""String_Node_Str"" + nodeName);
  WorkerStarter ws=WorkerStarter.getWorkerStarter(nodeName);
  if (ws != null) {
    ws.setWorkerIsReady();
  }
 else {
    logger.warn(""String_Node_Str"" + nodeName + ""String_Node_Str"");
  }
}","@Override public void setWorkerIsReady(String nodeName){
  logger.info(""String_Node_Str"" + nodeName + ""String_Node_Str"");
  WorkerStarter ws=WorkerStarter.getWorkerStarter(nodeName);
  if (ws != null) {
    ws.setWorkerIsReady();
  }
 else {
    logger.warn(""String_Node_Str"" + nodeName + ""String_Node_Str"");
  }
}"
70146,"public NIONode startWorker() throws InitNodeException {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort && !toStop) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
        throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
 else       if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
      pid=-1;
    }
    n=new NIONode(name,port);
    String nodeName=nw.getName();
    addresstoWorkerStarter.put(nodeName,this);
    logger.debug(""String_Node_Str"");
    command=getStartCommand(nw,port);
    long timer=0;
    while (pid < 0) {
      timer=timer + (WAIT_TIME_UNIT * 4);
      try {
        Thread.sleep(WAIT_TIME_UNIT * 4);
      }
 catch (      Exception e) {
      }
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
        pid=0;
      }
 else       if (po.getExitValue() == 0) {
        String output=po.getOutput();
        String[] lines=output.split(""String_Node_Str"");
        pid=Integer.parseInt(lines[lines.length - 1]);
      }
 else {
        if (timer > MAX_WAIT_FOR_SSH) {
          throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
        }
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    long delay=WAIT_TIME_UNIT;
    long totalWait=0;
    logger.debug(""String_Node_Str"");
    CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,nodeName);
    while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT) && !toStop) {
      try {
        logger.debug(""String_Node_Str"" + delay);
        Thread.sleep(delay);
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
      if (!workerIsReady) {
        if (debug) {
          logger.debug(""String_Node_Str"" + nodeName);
        }
        Connection c=NIOAdaptor.tm.startConnection(n);
        c.sendCommand(cmd);
        c.receive();
        c.finishConnection();
        totalWait+=delay;
        delay=(delay < 3900) ? delay * 2 : 4000;
      }
    }
    logger.debug(""String_Node_Str"" + nodeName + ""String_Node_Str"");
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      return n;
    }
  }
  if (toStop) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else   if (!workerIsReady) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
}","public NIONode startWorker() throws InitNodeException {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
synchronized (addresstoWorkerStarter) {
    addresstoWorkerStarter.put(name,this);
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort && !toStop) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
        throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
 else       if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
      pid=-1;
    }
    n=new NIONode(name,port);
    command=getStartCommand(nw,port);
    long timer=0;
    while (pid < 0) {
      timer=timer + (WAIT_TIME_UNIT * 4);
      try {
        Thread.sleep(WAIT_TIME_UNIT * 4);
      }
 catch (      Exception e) {
      }
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
        pid=0;
      }
 else       if (po.getExitValue() == 0) {
        String output=po.getOutput();
        String[] lines=output.split(""String_Node_Str"");
        pid=Integer.parseInt(lines[lines.length - 1]);
      }
 else {
        if (timer > MAX_WAIT_FOR_SSH) {
          throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
        }
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    long delay=WAIT_TIME_UNIT;
    long totalWait=0;
    logger.debug(""String_Node_Str"");
    CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,name);
    while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT) && !toStop) {
      try {
        logger.debug(""String_Node_Str"" + delay);
        Thread.sleep(delay);
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
      if (!workerIsReady) {
        if (debug) {
          logger.debug(""String_Node_Str"" + name);
        }
        Connection c=NIOAdaptor.tm.startConnection(n);
        c.sendCommand(cmd);
        c.receive();
        c.finishConnection();
        totalWait+=delay;
        delay=(delay < 3900) ? delay * 2 : 4000;
      }
    }
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      return n;
    }
  }
  if (toStop) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else   if (!workerIsReady) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
}"
70147,"public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String ldLibraryPath=System.getenv(LIBRARY_PATH_ENV);
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + C_LIB_RELATIVE_PATH);
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + COMMONS_LIB_RELATIVE_PATH);
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}","public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String ldLibraryPath=System.getenv(LIBRARY_PATH_ENV);
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + C_LIB_RELATIVE_PATH);
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + BINDINGS_RELATIVE_PATH);
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}"
70148,"public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String pycompssHome=nw.getInstallDir() + PYCOMPSS_RELATIVE_PATH;
  env.put(""String_Node_Str"",pycompssHome);
  String pythonPath=System.getenv(""String_Node_Str"");
  if (pythonPath == null) {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir();
  }
 else {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir()+ pythonPath;
  }
  env.put(""String_Node_Str"",pythonPath);
  String ldLibraryPath=System.getenv(""String_Node_Str"");
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}","public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String pycompssHome=nw.getInstallDir() + PYCOMPSS_RELATIVE_PATH;
  env.put(""String_Node_Str"",pycompssHome);
  String pythonPath=System.getenv(""String_Node_Str"");
  if (pythonPath == null) {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir();
  }
 else {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir()+ pythonPath;
  }
  env.put(""String_Node_Str"",pythonPath);
  String ldLibraryPath=System.getenv(""String_Node_Str"");
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  String bindingsHome=nw.getInstallDir() + BINDINGS_RELATIVE_PATH;
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + bindingsHome);
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}"
70149,"/** 
 * We have explicitly called the barrier API. STEPS: Add a new synchronization node. Add an edge from last synchronization point to barrier. Add edges from writer tasks to barrier
 */
private void addNewBarrier(){
  synchronizationId++;
  taskDetectedAfterSync=false;
  this.GM.addBarrierToGraph(synchronizationId);
  if (synchronizationId > 1) {
    this.GM.addEdgeToGraph(""String_Node_Str"" + (synchronizationId - 1),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
  }
  for (  Task writer : writers.values()) {
    this.GM.addEdgeToGraph(String.valueOf(writer.getId()),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
  }
}","/** 
 * We have explicitly called the barrier API. STEPS: Add a new synchronization node. Add an edge from last synchronization point to barrier. Add edges from writer tasks to barrier
 */
private void addNewBarrier(){
  synchronizationId++;
  taskDetectedAfterSync=false;
  this.GM.addBarrierToGraph(synchronizationId);
  if (synchronizationId > 1) {
    this.GM.addEdgeToGraph(""String_Node_Str"" + (synchronizationId - 1),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
  }
  HashSet<Task> uniqueWriters=new HashSet<>(writers.values());
  for (  Task writer : uniqueWriters) {
    if (writer.getSynchronizationId() == (synchronizationId - 1)) {
      this.GM.addEdgeToGraph(String.valueOf(writer.getId()),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
    }
  }
}"
70150,"public static Integer align(String pFlag,String pMode,String dFlag,String database,String iFlag,String partitionFile,String oFlag,String partitionOutput){
  return -1;
}","/** 
 * Dummy implementation to call the BLAST binary for algin withou extra CMD args
 * @param pFlag
 * @param pMode
 * @param dFlag
 * @param database
 * @param iFlag
 * @param partitionFile
 * @param oFlag
 * @param partitionOutput
 * @return
 */
public static Integer align(String pFlag,String pMode,String dFlag,String database,String iFlag,String partitionFile,String oFlag,String partitionOutput){
  return -1;
}"
70151,"private static void parseArgs(String[] args){
  Blast.debug=Boolean.parseBoolean(args[0]);
  Blast.databasePath=args[1];
  Blast.inputFileName=args[2];
  Blast.numFragments=Integer.parseInt(args[3]);
  Blast.tmpDir=args[4];
  Blast.outputFileName=args[5];
  Blast.commandArgs=""String_Node_Str"";
  for (int i=6; i < args.length; i++) {
    Blast.commandArgs+=args[i] + ""String_Node_Str"";
  }
}","/** 
 * Parses the input parameters and initializes the class atributes
 * @param args
 */
private static void parseArgs(String[] args){
  Blast.debug=Boolean.parseBoolean(args[0]);
  Blast.databasePath=args[1];
  Blast.inputFileName=args[2];
  Blast.numFragments=Integer.parseInt(args[3]);
  Blast.tmpDir=args[4];
  Blast.outputFileName=args[5];
  Blast.commandArgs=""String_Node_Str"";
  for (int i=6; i < args.length; i++) {
    Blast.commandArgs+=args[i] + ""String_Node_Str"";
  }
}"
70152,"private static void logArgs(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + System.getenv(ENV_BLAST_BINARY));
  System.out.println(""String_Node_Str"" + Blast.debug);
  System.out.println(""String_Node_Str"" + Blast.databasePath);
  System.out.println(""String_Node_Str"" + Blast.inputFileName);
  System.out.println(""String_Node_Str"" + Blast.numFragments);
  System.out.println(""String_Node_Str"" + Blast.tmpDir);
  System.out.println(""String_Node_Str"" + Blast.outputFileName);
  System.out.println(""String_Node_Str"" + Blast.commandArgs);
  System.out.println(""String_Node_Str"");
}","/** 
 * Prints the class attributes used for the execution
 */
private static void logArgs(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + System.getenv(ENV_BLAST_BINARY));
  System.out.println(""String_Node_Str"" + Blast.debug);
  System.out.println(""String_Node_Str"" + Blast.databasePath);
  System.out.println(""String_Node_Str"" + Blast.inputFileName);
  System.out.println(""String_Node_Str"" + Blast.numFragments);
  System.out.println(""String_Node_Str"" + Blast.tmpDir);
  System.out.println(""String_Node_Str"" + Blast.outputFileName);
  System.out.println(""String_Node_Str"" + Blast.commandArgs);
  System.out.println(""String_Node_Str"");
}"
70153,"public static void main(String[] args) throws BlastException {
}","/** 
 * MAIN CODE
 * @param args
 * @throws BlastException
 */
public static void main(String[] args) throws BlastException {
}"
70154,"public BlastException(String msg,Exception e){
  super(msg,e);
}","/** 
 * Constructs a new BlastException with a nested exception @e and error message @msg
 * @param msg
 * @param e
 */
public BlastException(String msg,Exception e){
  super(msg,e);
}"
70155,"/** 
 * Bind numCUs core units to the job
 * @param jobId
 * @param numCUs
 * @return
 * @throws UnsufficientAvailableComputingUnitsException
 */
public int[] bindComputingUnits(int jobId,int numCUs) throws UnsufficientAvailableComputingUnitsException {
  int assignedCoreUnits[]=new int[numCUs];
  int numAssignedCores=0;
synchronized (this.bindedComputingUnits) {
    for (int coreId=0; coreId < this.bindedComputingUnits.length; ++coreId) {
      if (this.bindedComputingUnits[coreId] == -1) {
        this.bindedComputingUnits[coreId]=jobId;
        assignedCoreUnits[numAssignedCores]=coreId;
        numAssignedCores++;
      }
      if (numAssignedCores == numCUs) {
        break;
      }
    }
    if (numAssignedCores != numCUs) {
      releaseComputingUnits(jobId);
      throw new UnsufficientAvailableComputingUnitsException(""String_Node_Str"");
    }
  }
  return assignedCoreUnits;
}","/** 
 * Bind numCUs core units to the job
 * @param jobId
 * @param numCUs
 * @return
 * @throws UnsufficientAvailableComputingUnitsException
 */
public int[] bindComputingUnits(int jobId,int numCUs) throws UnsufficientAvailableComputingUnitsException {
  if (numCUs == 0)   return new int[0];
  int assignedCoreUnits[]=new int[numCUs];
  int numAssignedCores=0;
synchronized (this.bindedComputingUnits) {
    for (int coreId=0; coreId < this.bindedComputingUnits.length; ++coreId) {
      if (this.bindedComputingUnits[coreId] == -1) {
        this.bindedComputingUnits[coreId]=jobId;
        assignedCoreUnits[numAssignedCores]=coreId;
        numAssignedCores++;
      }
      if (numAssignedCores == numCUs) {
        break;
      }
    }
    if (numAssignedCores != numCUs) {
      releaseComputingUnits(jobId);
      throw new UnsufficientAvailableComputingUnitsException(""String_Node_Str"");
    }
  }
  return assignedCoreUnits;
}"
70156,"private static void generateTrace(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  String appName=System.getProperty(ITConstants.IT_APP_NAME);
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",System.getProperty(ITConstants.IT_APP_LOG_DIR),appName,String.valueOf(hostToSlots.size() + 1));
  Process p;
  pb.environment().remove(LD_PRELOAD);
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out);
  StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err);
  outputGobbler.start();
  errorGobbler.start();
  int exitCode=0;
  try {
    exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
  String lang=System.getProperty(ITConstants.IT_LANG);
  if (exitCode == 0 && lang.equalsIgnoreCase(ITConstants.Lang.PYTHON.name())) {
    try {
      new TraceMerger(System.getProperty(ITConstants.IT_APP_LOG_DIR),appName).merge();
    }
 catch (    IOException e) {
      ErrorManager.warn(""String_Node_Str"",e);
    }
  }
}","private static void generateTrace(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  String appName=System.getProperty(ITConstants.IT_APP_NAME);
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",System.getProperty(ITConstants.IT_APP_LOG_DIR),appName,String.valueOf(hostToSlots.size() + 1));
  Process p;
  pb.environment().remove(LD_PRELOAD);
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out,logger);
  StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err,logger);
  outputGobbler.start();
  errorGobbler.start();
  int exitCode=0;
  try {
    exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
  String lang=System.getProperty(ITConstants.IT_LANG);
  if (exitCode == 0 && lang.equalsIgnoreCase(ITConstants.Lang.PYTHON.name())) {
    try {
      new TraceMerger(System.getProperty(ITConstants.IT_APP_LOG_DIR),appName).merge();
    }
 catch (    IOException e) {
      ErrorManager.warn(""String_Node_Str"",e);
    }
  }
}"
70157,"private static void generateMasterPackage(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pb.environment().remove(LD_PRELOAD);
  Process p;
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  if (debug) {
    StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out);
    StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err);
    outputGobbler.start();
    errorGobbler.start();
  }
  try {
    int exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
}","private static void generateMasterPackage(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pb.environment().remove(LD_PRELOAD);
  Process p;
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  if (debug) {
    StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out,logger);
    StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err,logger);
    outputGobbler.start();
    errorGobbler.start();
  }
  try {
    int exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
}"
70158,"/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param hasReturn
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,boolean hasReturn,StreamSTD streamValues,File taskSandboxWorkingDir) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    exitValue=process.waitFor();
  }
 catch (  Exception e) {
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
 finally {
    logBinaryExecution(process,exitValue,fileOutPath,fileErrPath);
  }
  return hasReturn ? exitValue : null;
}","/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param hasReturn
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,boolean hasReturn,StreamSTD streamValues,File taskSandboxWorkingDir) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    exitValue=process.waitFor();
  }
 catch (  Exception e) {
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
 finally {
    logBinaryExecution(process,exitValue,fileOutPath,fileErrPath);
  }
  return hasReturn ? exitValue : null;
}"
70159,"private static void logBinaryExecution(Process process,int exitValue,String fileOutPath,String fileErrPath) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + exitValue);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader outputReader=(fileOutPath != null) ? new BufferedReader(new FileReader(fileOutPath)) : new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=outputReader.readLine()) != null) {
        System.out.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
    }
  }
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader errorReader=(fileErrPath != null) ? new BufferedReader(new FileReader(fileErrPath)) : new BufferedReader(new InputStreamReader(process.getErrorStream()))){
      String line=null;
      while ((line=errorReader.readLine()) != null) {
        System.err.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_ERRORREADER,ioe);
    }
  }
}","private static void logBinaryExecution(Process process,int exitValue,String fileOutPath,String fileErrPath) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + exitValue);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader outputReader=(fileOutPath != null) ? new BufferedReader(new FileReader(fileOutPath)) : new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=outputReader.readLine()) != null) {
        System.out.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
    }
  }
  System.out.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader errorReader=(fileErrPath != null) ? new BufferedReader(new FileReader(fileErrPath)) : new BufferedReader(new InputStreamReader(process.getErrorStream()))){
      String line=null;
      while ((line=errorReader.readLine()) != null) {
        System.err.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_ERRORREADER,ioe);
    }
  }
  System.err.println(""String_Node_Str"");
}"
70160,"public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numNodes;
  cmd[5]=""String_Node_Str"";
  cmd[6]=""String_Node_Str"";
  cmd[7]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}","public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numProcs;
  cmd[5]=""String_Node_Str"";
  cmd[6]=""String_Node_Str"";
  cmd[7]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}"
70161,"public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}","public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}"
70162,"public static Object invokeBinaryMethod(String binary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}","public static Object invokeBinaryMethod(String binary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}"
70163,"private JobDescription prepareJob() throws Exception {
  TaskDescription taskParams=this.taskParams;
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  ArrayList<String> symlinks=new ArrayList<String>();
  ArrayList<String> paramArgs=new ArrayList<String>();
  String sandboxDir=getResourceNode().getWorkingDir() + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ this.jobId;
  processParameters(sandboxDir,symlinks,paramArgs);
  lArgs.add(sandboxDir);
  if (symlinks.size() > 0) {
    lArgs.add(""String_Node_Str"" + symlinks.size());
    lArgs.addAll(symlinks);
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Boolean.toString(Tracer.isActivated()));
  lArgs.add(getHostName());
  if (debug) {
    logger.debug(""String_Node_Str"" + getHostName());
  }
  if (Tracer.isActivated()) {
    lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
    lArgs.add(String.valueOf(this.taskParams.getId() + 1));
    int slot=Tracer.getNextSlot(targetHost);
    lArgs.add(String.valueOf(slot));
    sd.addAttribute(""String_Node_Str"",slot);
  }
  lArgs.add(sandboxDir);
  lArgs.add(getResourceNode().getAppDir());
  lArgs.add(getClasspath());
  lArgs.add(getPythonpath());
  lArgs.add(String.valueOf(debug));
  lArgs.add(STORAGE_CONF);
  AbstractMethodImplementation absImpl=(AbstractMethodImplementation)this.impl;
  lArgs.add(String.valueOf(absImpl.getMethodType()));
switch (absImpl.getMethodType()) {
case METHOD:
    MethodImplementation methodImpl=(MethodImplementation)absImpl;
  lArgs.add(methodImpl.getDeclaringClass());
String methodName=methodImpl.getAlternativeMethodName();
if (methodName == null || methodName.isEmpty()) {
methodName=taskParams.getName();
}
lArgs.add(methodName);
break;
case MPI:
MPIImplementation mpiImpl=(MPIImplementation)absImpl;
lArgs.add(mpiImpl.getMpiRunner());
lArgs.add(mpiImpl.getBinary());
break;
case OMPSS:
OmpSsImplementation ompssImpl=(OmpSsImplementation)absImpl;
lArgs.add(ompssImpl.getBinary());
break;
case OPENCL:
OpenCLImplementation openclImpl=(OpenCLImplementation)absImpl;
lArgs.add(openclImpl.getKernel());
break;
case BINARY:
BinaryImplementation binaryImpl=(BinaryImplementation)absImpl;
lArgs.add(binaryImpl.getBinary());
break;
}
lArgs.add(String.valueOf(slaveWorkersNodeNames.size()));
lArgs.addAll(slaveWorkersNodeNames);
lArgs.add(String.valueOf(((MethodResourceDescription)this.impl.getRequirements()).getTotalCPUComputingUnits()));
lArgs.addAll(paramArgs);
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ absImpl.getMethodDefinition()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,absImpl.getRequirements().getWallClockLimit());
if (absImpl.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,absImpl.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalCPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalGPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalFPGAComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,absImpl.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI.getSchema() + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}","private JobDescription prepareJob() throws Exception {
  TaskDescription taskParams=this.taskParams;
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  boolean isSpecific=false;
  String sandboxDir=null;
  AbstractMethodImplementation absImpl=(AbstractMethodImplementation)this.impl;
switch (absImpl.getMethodType()) {
case BINARY:
    BinaryImplementation binaryImpl=(BinaryImplementation)absImpl;
  sandboxDir=binaryImpl.getWorkingDir();
isSpecific=true;
break;
case MPI:
MPIImplementation mpiImpl=(MPIImplementation)absImpl;
sandboxDir=mpiImpl.getWorkingDir();
isSpecific=true;
break;
case OMPSS:
OmpSsImplementation ompssImpl=(OmpSsImplementation)absImpl;
sandboxDir=ompssImpl.getWorkingDir();
isSpecific=true;
break;
case OPENCL:
OpenCLImplementation openclImpl=(OpenCLImplementation)absImpl;
sandboxDir=openclImpl.getWorkingDir();
isSpecific=true;
break;
case METHOD:
sandboxDir=null;
break;
}
if (sandboxDir == null || sandboxDir.isEmpty() || sandboxDir.equals(Constants.UNASSIGNED)) {
sandboxDir=getResourceNode().getWorkingDir() + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ this.jobId;
isSpecific=false;
}
ArrayList<String> symlinks=new ArrayList<>();
ArrayList<String> paramArgs=new ArrayList<>();
processParameters(sandboxDir,symlinks,paramArgs);
lArgs.add(Boolean.toString(isSpecific));
lArgs.add(sandboxDir);
if (symlinks.size() > 0) {
lArgs.add(String.valueOf(symlinks.size()));
lArgs.addAll(symlinks);
}
 else {
lArgs.add(""String_Node_Str"");
}
lArgs.add(Boolean.toString(Tracer.isActivated()));
lArgs.add(getHostName());
if (debug) {
logger.debug(""String_Node_Str"" + getHostName());
}
if (Tracer.isActivated()) {
lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
lArgs.add(String.valueOf(this.taskParams.getId() + 1));
int slot=Tracer.getNextSlot(targetHost);
lArgs.add(String.valueOf(slot));
sd.addAttribute(""String_Node_Str"",slot);
}
lArgs.add(sandboxDir);
lArgs.add(getResourceNode().getAppDir());
lArgs.add(getClasspath());
lArgs.add(getPythonpath());
lArgs.add(String.valueOf(debug));
lArgs.add(STORAGE_CONF);
lArgs.add(String.valueOf(absImpl.getMethodType()));
switch (absImpl.getMethodType()) {
case METHOD:
MethodImplementation methodImpl=(MethodImplementation)absImpl;
lArgs.add(methodImpl.getDeclaringClass());
String methodName=methodImpl.getAlternativeMethodName();
if (methodName == null || methodName.isEmpty()) {
methodName=taskParams.getName();
}
lArgs.add(methodName);
break;
case MPI:
MPIImplementation mpiImpl=(MPIImplementation)absImpl;
lArgs.add(mpiImpl.getMpiRunner());
lArgs.add(mpiImpl.getBinary());
break;
case OMPSS:
OmpSsImplementation ompssImpl=(OmpSsImplementation)absImpl;
lArgs.add(ompssImpl.getBinary());
break;
case OPENCL:
OpenCLImplementation openclImpl=(OpenCLImplementation)absImpl;
lArgs.add(openclImpl.getKernel());
break;
case BINARY:
BinaryImplementation binaryImpl=(BinaryImplementation)absImpl;
lArgs.add(binaryImpl.getBinary());
break;
}
lArgs.add(String.valueOf(slaveWorkersNodeNames.size()));
lArgs.addAll(slaveWorkersNodeNames);
lArgs.add(String.valueOf(((MethodResourceDescription)this.impl.getRequirements()).getTotalCPUComputingUnits()));
lArgs.addAll(paramArgs);
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ absImpl.getMethodDefinition()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,absImpl.getRequirements().getWallClockLimit());
if (absImpl.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,absImpl.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalCPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalGPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalFPGAComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,absImpl.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI.getSchema() + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}"
70164,"/** 
 * Communications initializer
 */
public static synchronized void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}","/** 
 * Communications initializer
 */
public static void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}"
70165,"/** 
 * Return the active adaptors
 * @return
 */
public static synchronized HashMap<String,CommAdaptor> getAdaptors(){
  return adaptors;
}","/** 
 * Return the active adaptors
 * @return
 */
public static Map<String,CommAdaptor> getAdaptors(){
  return adaptors;
}"
70166,"/** 
 * Stops all the submitted jobs
 */
public static synchronized void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}","/** 
 * Stops all the submitted jobs
 */
public static void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}"
70167,"/** 
 * Initializes the internal adaptor and constructs a comm configuration
 * @param adaptorName
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws ConstructConfigurationException
 */
public static synchronized Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws ConstructConfigurationException {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    try {
      Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
      adaptor=(CommAdaptor)constrAdaptor.newInstance();
    }
 catch (    NoSuchMethodException|SecurityException|ClassNotFoundException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
      throw new ConstructConfigurationException(e);
    }
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}","/** 
 * Initializes the internal adaptor and constructs a comm configuration
 * @param adaptorName
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws ConstructConfigurationException
 */
public static Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws ConstructConfigurationException {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    try {
      Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
      adaptor=(CommAdaptor)constrAdaptor.newInstance();
    }
 catch (    NoSuchMethodException|SecurityException|ClassNotFoundException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
      throw new ConstructConfigurationException(e);
    }
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}"
70168,"/** 
 * Initializes a worker with name @name and configuration @config
 * @param name
 * @param config
 * @return
 */
public static synchronized COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}","/** 
 * Initializes a worker with name @name and configuration @config
 * @param name
 * @param config
 * @return
 */
public static COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}"
70169,"/** 
 * Returns all the data stored in a host @host
 * @param host
 * @return
 */
public static synchronized HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}","/** 
 * Returns all the data stored in a host @host
 * @param host
 * @return
 */
public static HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}"
70170,"/** 
 * Stops the communication layer.  Clean FTM, Job, {GATJob, NIOJob} and WSJob
 */
public static synchronized void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}","/** 
 * Stops the communication layer.  Clean FTM, Job, {GATJob, NIOJob} and WSJob
 */
public static void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}"
70171,"public void perform(){
  Resource targetHost=tgtLoc.getHosts().getFirst();
  logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ tgtLoc);
synchronized (srcData) {
    if (tgtData != null) {
      MultiURI u;
      if ((u=srcData.alreadyAvailable(targetHost)) != null) {
        setFinalTarget(u.getPath());
        end(DataOperation.OpEndState.OP_OK);
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ targetHost+ ""String_Node_Str""+ u.getPath());
        return;
      }
      Copy copyInProgress=null;
      if ((copyInProgress=srcData.alreadyCopying(tgtLoc)) != null) {
        String path=copyInProgress.tgtLoc.getURIInHost(targetHost).getPath();
        setFinalTarget(path);
        end(DataOperation.OpEndState.OP_IN_PROGRESS);
synchronized (copyInProgress.getEventListeners()) {
          copyInProgress.addEventListeners(getEventListeners());
        }
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ path+ ""String_Node_Str"");
        return;
      }
    }
    srcData.startCopy(this,tgtLoc);
  }
  try {
    specificCopy();
  }
 catch (  CopyException e) {
    end(DataOperation.OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    DataLocation actualLocation;
synchronized (srcData) {
      actualLocation=srcData.finishedCopy(this);
    }
    if (tgtData != null) {
synchronized (tgtData) {
        tgtData.addLocation(actualLocation);
      }
    }
  }
  String path=tgtLoc.getURIInHost(targetHost).getPath();
  setFinalTarget(path);
synchronized (srcData) {
    end(DataOperation.OpEndState.OP_OK);
  }
  logger.debug(""String_Node_Str"" + getName());
}","public void perform(){
  Resource targetHost=tgtLoc.getHosts().getFirst();
  logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ tgtLoc);
synchronized (srcData) {
    if (tgtData != null) {
      MultiURI u;
      if ((u=srcData.alreadyAvailable(targetHost)) != null) {
        setFinalTarget(u.getPath());
        end(DataOperation.OpEndState.OP_OK);
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ targetHost+ ""String_Node_Str""+ u.getPath());
        return;
      }
      Copy copyInProgress=null;
      if ((copyInProgress=srcData.alreadyCopying(tgtLoc)) != null) {
        String path=copyInProgress.tgtLoc.getURIInHost(targetHost).getPath();
        setFinalTarget(path);
        end(DataOperation.OpEndState.OP_IN_PROGRESS);
synchronized (copyInProgress.getEventListeners()) {
          copyInProgress.addEventListeners(getEventListeners());
        }
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ path+ ""String_Node_Str"");
        return;
      }
    }
    srcData.startCopy(this,tgtLoc);
  }
  try {
    logger.debug(""String_Node_Str"" + getName());
    specificCopy();
  }
 catch (  CopyException e) {
    end(DataOperation.OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    DataLocation actualLocation;
synchronized (srcData) {
      actualLocation=srcData.finishedCopy(this);
    }
    if (tgtData != null) {
synchronized (tgtData) {
        tgtData.addLocation(actualLocation);
      }
    }
  }
  String path=tgtLoc.getURIInHost(targetHost).getPath();
  setFinalTarget(path);
synchronized (srcData) {
    end(DataOperation.OpEndState.OP_OK);
  }
  logger.debug(""String_Node_Str"" + getName() + ""String_Node_Str"");
}"
70172,"public MultiURI(Protocol protocol,Resource host,String path){
  this.protocol=protocol;
  this.host=host;
  this.path=path;
  this.internal=new HashMap<>();
}","public MultiURI(Protocol protocol,Resource host,String path){
  this.protocol=protocol;
  this.host=host;
  this.path=path;
  this.internal=new HashMap<>();
  try {
    host.setInternalURI(this);
  }
 catch (  UnstartedNodeException e) {
    e.printStackTrace();
  }
}"
70173,"public String debugString(){
  StringBuilder sb=new StringBuilder(this.protocol.getSchema() + this.host.toString() + File.separator+ this.path+ ""String_Node_Str"");
  for (  Entry<String,Object> e : internal.entrySet()) {
    sb.append(""String_Node_Str"").append(e.getKey()).append(""String_Node_Str"").append(e.getValue()).append(""String_Node_Str"");
  }
  return sb.toString();
}","public String debugString(){
  StringBuilder sb=new StringBuilder(this.protocol.getSchema() + this.host.getName() + File.separator+ this.path+ ""String_Node_Str"");
  for (  Entry<String,Object> e : internal.entrySet()) {
    sb.append(""String_Node_Str"").append(e.getKey()).append(""String_Node_Str"").append(e.getValue()).append(""String_Node_Str"");
  }
  return sb.toString();
}"
70174,"public Object getInternalURI(String adaptor) throws UnstartedNodeException {
  Object o=internal.get(adaptor);
  if (o == null) {
    host.setInternalURI(this);
    o=internal.get(adaptor);
  }
  return o;
}","public Object getInternalURI(String adaptor) throws UnstartedNodeException {
  Object o=internal.get(adaptor);
  return o;
}"
70175,"@Override public void specificCopy() throws CopyException {
  logger.debug(DBG_PREFIX + ""String_Node_Str"" + getName());
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<>();
  for (  MultiURI uri : targetURIs) {
    try {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedTargetURIs.add(internalURI);
      }
    }
 catch (    UnstartedNodeException une) {
      throw new GATCopyException(une);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    logger.error(DBG_PREFIX + ERR_NO_TGT_URI);
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        try {
          URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
          if (internalURI != null) {
            selectedSourceURIs.add(internalURI);
          }
        }
 catch (        UnstartedNodeException une) {
          throw new GATCopyException(une);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      try {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
 catch (      UnstartedNodeException une) {
        throw new GATCopyException(une);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        logger.warn(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"",exception);
  }
  throw new GATCopyException(exception);
}","@Override public void specificCopy() throws CopyException {
  logger.debug(DBG_PREFIX + ""String_Node_Str"" + getName());
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<>();
  for (  MultiURI uri : targetURIs) {
    try {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedTargetURIs.add(internalURI);
      }
    }
 catch (    UnstartedNodeException une) {
      throw new GATCopyException(une);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    logger.error(DBG_PREFIX + ERR_NO_TGT_URI);
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  logger.debug(DBG_PREFIX + ""String_Node_Str"");
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        try {
          URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
          if (internalURI != null) {
            selectedSourceURIs.add(internalURI);
          }
        }
 catch (        UnstartedNodeException une) {
          logger.error(DBG_PREFIX + ""String_Node_Str"");
          throw new GATCopyException(une);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      try {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
 catch (      UnstartedNodeException une) {
        logger.error(DBG_PREFIX + ""String_Node_Str"" + getName());
        throw new GATCopyException(une);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        logger.debug(""String_Node_Str"" + getName() + ""String_Node_Str"");
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        logger.error(DBG_PREFIX + ERR_NO_SRC_URI);
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        logger.warn(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"",exception);
  }
  throw new GATCopyException(exception);
}"
70176,"public static synchronized void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}","/** 
 * Communications initializer
 */
public static synchronized void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}"
70177,"public static synchronized LogicalData registerPSCO(String dataId,String id){
  String targetPath=Protocol.PERSISTENT_URI.getSchema() + id;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}","/** 
 * Registers a new PSCO id @id for the data with id @dataId dataId must exist
 * @param dataId
 * @param id
 * @return
 */
public static synchronized LogicalData registerPSCO(String dataId,String id){
  String targetPath=Protocol.PERSISTENT_URI.getSchema() + id;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}"
70178,"public static synchronized LogicalData registerData(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=new LogicalData(dataId);
  data.put(dataId,logicalData);
  return logicalData;
}","/** 
 * Registers a new data with id @dataId
 * @param dataId
 * @return
 */
public static synchronized LogicalData registerData(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=new LogicalData(dataId);
  data.put(dataId,logicalData);
  return logicalData;
}"
70179,"public static synchronized String dataDump(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (  Map.Entry<String,LogicalData> lde : data.entrySet()) {
    sb.append(""String_Node_Str"").append(lde.getKey()).append(""String_Node_Str"");
    LogicalData ld=lde.getValue();
    for (    MultiURI u : ld.getURIs()) {
      sb.append(""String_Node_Str"").append(u.toString()).append(""String_Node_Str"");
      for (      String adaptor : adaptors.keySet()) {
        Object internal=null;
        try {
          internal=u.getInternalURI(adaptor);
          if (internal != null) {
            sb.append(""String_Node_Str"").append(internal.toString()).append(""String_Node_Str"");
          }
        }
 catch (        UnstartedNodeException une) {
        }
      }
    }
  }
  return sb.toString();
}","/** 
 * Dumps the stored data (only for testing)
 * @return
 */
public static synchronized String dataDump(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (  Map.Entry<String,LogicalData> lde : data.entrySet()) {
    sb.append(""String_Node_Str"").append(lde.getKey()).append(""String_Node_Str"");
    LogicalData ld=lde.getValue();
    for (    MultiURI u : ld.getURIs()) {
      sb.append(""String_Node_Str"").append(u.toString()).append(""String_Node_Str"");
      for (      String adaptor : adaptors.keySet()) {
        Object internal=null;
        try {
          internal=u.getInternalURI(adaptor);
          if (internal != null) {
            sb.append(""String_Node_Str"").append(internal.toString()).append(""String_Node_Str"");
          }
        }
 catch (        UnstartedNodeException une) {
        }
      }
    }
  }
  return sb.toString();
}"
70180,"public static MasterResource getAppHost(){
  return appHost;
}","/** 
 * Returns the resource assigned as master node
 * @return
 */
public static MasterResource getAppHost(){
  return appHost;
}"
70181,"public static synchronized HashMap<String,CommAdaptor> getAdaptors(){
  return adaptors;
}","/** 
 * Return the active adaptors
 * @return
 */
public static synchronized HashMap<String,CommAdaptor> getAdaptors(){
  return adaptors;
}"
70182,"public static synchronized void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}","/** 
 * Stops all the submitted jobs
 */
public static synchronized void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}"
70183,"public static synchronized Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws Exception {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
    adaptor=(CommAdaptor)constrAdaptor.newInstance();
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}","/** 
 * Initializes the internal adaptor and constructs a comm configuration
 * @param adaptorName
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws ConstructConfigurationException
 */
public static synchronized Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws ConstructConfigurationException {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    try {
      Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
      adaptor=(CommAdaptor)constrAdaptor.newInstance();
    }
 catch (    NoSuchMethodException|SecurityException|ClassNotFoundException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
      throw new ConstructConfigurationException(e);
    }
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}"
70184,"public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  if (value instanceof StubItf) {
    String id=((StubItf)value).getID();
    if (id != null) {
      Comm.registerPSCO(dataId,id);
    }
  }
  return logicalData;
}","/** 
 * Registers a new value @value for the data with id @dataId dataId must exist
 * @param dataId
 * @param value
 * @return
 */
public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  if (value instanceof StubItf) {
    String id=((StubItf)value).getID();
    if (id != null) {
      Comm.registerPSCO(dataId,id);
    }
  }
  return logicalData;
}"
70185,"public static synchronized Object clearValue(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=data.get(dataId);
  return logicalData.removeValue();
}","/** 
 * Clears the value of the data id @dataId
 * @param dataId
 * @return
 */
public static synchronized Object clearValue(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=data.get(dataId);
  return logicalData.removeValue();
}"
70186,"public static synchronized COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}","/** 
 * Initializes a worker with name @name and configuration @config
 * @param name
 * @param config
 * @return
 */
public static synchronized COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}"
70187,"public static synchronized LogicalData registerLocation(String dataId,DataLocation location){
  logger.debug(""String_Node_Str"" + dataId + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + location);
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}","/** 
 * Registers a new location @location for the data with id @dataId dataId must exist
 * @param dataId
 * @param location
 * @return
 */
public static synchronized LogicalData registerLocation(String dataId,DataLocation location){
  logger.debug(""String_Node_Str"" + dataId + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + location);
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}"
70188,"public static synchronized HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}","/** 
 * Returns all the data stored in a host @host
 * @param host
 * @return
 */
public static synchronized HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}"
70189,"public static synchronized void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}","/** 
 * Stops the communication layer.  Clean FTM, Job, {GATJob, NIOJob} and WSJob
 */
public static synchronized void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}"
70190,"public static synchronized boolean existsData(String renaming){
  return (data.get(renaming) != null);
}","/** 
 * Checks if a given dataId @renaming exists
 * @param renaming
 * @return
 */
public static synchronized boolean existsData(String renaming){
  return (data.get(renaming) != null);
}"
70191,"public static synchronized void removeData(String renaming){
  logger.debug(""String_Node_Str"" + renaming);
  LogicalData ld=data.remove(renaming);
  ld.isObsolete();
  for (  DataLocation dl : ld.getLocations()) {
    MultiURI uri=dl.getURIInHost(appHost);
    if (uri != null) {
      File f=new File(uri.getPath());
      if (f.exists()) {
        logger.info(""String_Node_Str"" + f.getAbsolutePath());
        if (!f.delete()) {
          logger.error(""String_Node_Str"" + f.getAbsolutePath());
        }
      }
    }
  }
}","/** 
 * Removes the data with id @renaming
 * @param renaming
 */
public static synchronized void removeData(String renaming){
  logger.debug(""String_Node_Str"" + renaming);
  LogicalData ld=data.remove(renaming);
  ld.isObsolete();
  for (  DataLocation dl : ld.getLocations()) {
    MultiURI uri=dl.getURIInHost(appHost);
    if (uri != null) {
      File f=new File(uri.getPath());
      if (f.exists()) {
        logger.info(""String_Node_Str"" + f.getAbsolutePath());
        if (!f.delete()) {
          logger.error(""String_Node_Str"" + f.getAbsolutePath());
        }
      }
    }
  }
}"
70192,"public static synchronized LogicalData getData(String dataId){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + data.get(dataId));
  }
  return data.get(dataId);
}","/** 
 * Returns the data with id @dataId
 * @param dataId
 * @return
 */
public static synchronized LogicalData getData(String dataId){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + data.get(dataId));
  }
  return data.get(dataId);
}"
70193,"/** 
 * Creates a configuration instance for the specific adaptor
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws Exception
 */
public Configuration constructConfiguration(Object project_properties,Object resources_properties) throws Exception ;","/** 
 * Creates a configuration instance for the specific adaptor
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws Exception
 */
public Configuration constructConfiguration(Object project_properties,Object resources_properties) throws ConstructConfigurationException ;"
70194,"public void setWorkingDir(String workingDir){
  if (workingDir == null) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (workingDir.isEmpty()) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (!workingDir.endsWith(File.separator)) {
    this.workingDir=workingDir + File.separator;
  }
 else {
    this.workingDir=workingDir;
  }
}","public void setWorkingDir(String workingDir){
  if (workingDir == null) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (workingDir.isEmpty()) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (!workingDir.endsWith(File.separator)) {
    this.workingDir=workingDir + File.separator;
  }
 else {
    this.workingDir=workingDir;
  }
  String host=this.getHost().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
  String sandboxWorkingDir=this.getWorkingDir() + DEPLOYMENT_ID + File.separator+ host+ File.separator;
  this.setSandboxWorkingDir(sandboxWorkingDir);
}"
70195,"@Override public void specificCopy() throws Exception {
  logger.debug(""String_Node_Str"");
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<URI>();
  for (  MultiURI uri : targetURIs) {
    URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
    if (internalURI != null) {
      selectedTargetURIs.add(internalURI);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<URI>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedSourceURIs.add(internalURI);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"");
  }
  throw exception;
}","@Override public void specificCopy() throws Exception {
  logger.debug(""String_Node_Str"");
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<URI>();
  for (  MultiURI uri : targetURIs) {
    URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
    if (internalURI != null) {
      selectedTargetURIs.add(internalURI);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<URI>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedSourceURIs.add(internalURI);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        logger.debug(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"",exception);
  }
  throw exception;
}"
70196,"public static boolean generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  return new CleanerExecutor(node).executeScript(traceScripts,traceParams);
}","public static boolean generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  return new GATScriptExecutor(node).executeScript(traceScripts,traceParams,""String_Node_Str"" + host);
}"
70197,"@Override public void deleteTemporary(){
}","@Override public void deleteTemporary(){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=getHost();
  String installDir=getInstallDir();
  String workingDir=getWorkingDir();
  String user=getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ GAT_SCRIPT_PATH+ CLEANER_SCRIPT_NAME));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"" + workingDir + ""String_Node_Str""+ getName(),e);
    return;
  }
  String pars=workingDir;
  traceParams.add(pars);
  logger.debug(""String_Node_Str"" + workingDir + ""String_Node_Str""+ getName());
  boolean result=new GATScriptExecutor(this).executeScript(traceScripts,traceParams,""String_Node_Str"" + host);
  if (!result) {
    logger.error(""String_Node_Str"" + workingDir + ""String_Node_Str""+ getName());
  }
}"
70198,"@Override public void updateTaskCount(int processorCoreCount){
  if (GATTracer.isActivated()) {
    System.err.println(""String_Node_Str"");
  }
}","@Override public void updateTaskCount(int processorCoreCount){
  if (GATTracer.isActivated()) {
    logger.error(""String_Node_Str"");
  }
}"
70199,"@Override public void start() throws Exception {
  if (GATTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    tracingJob=GATTracer.startTracing(this);
    waitForTracingReady();
  }
}","@Override public void start() throws Exception {
  initWorkingDir();
  if (GATTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    tracingJob=GATTracer.startTracing(this);
    waitForTracingReady();
  }
}"
70200,"public String getWorkingDir(){
  return this.config.getWorkingDir();
}","public String getWorkingDir(){
  return this.config.getSandboxWorkingDir();
}"
70201,"@Override public void stop(ShutdownListener sl){
  try {
    File workingDirRoot=new File(this.config.getWorkingDir());
    for (    File c : workingDirRoot.listFiles()) {
      delete(c);
    }
  }
 catch (  FileNotFoundException e) {
    logger.warn(""String_Node_Str"" + e);
  }
  sl.notifyEnd();
}","@Override public void stop(ShutdownListener sl){
  try {
    String workingDir=this.config.getWorkingDir();
    if (workingDir != null || !workingDir.isEmpty()) {
      File workingDirRoot=new File(workingDir);
      if (workingDirRoot != null) {
        File[] filesInFolder=workingDirRoot.listFiles();
        if (filesInFolder != null) {
          for (          File c : filesInFolder) {
            delete(c);
          }
        }
      }
    }
  }
 catch (  FileNotFoundException e) {
    logger.warn(""String_Node_Str"" + e);
  }
  sl.notifyEnd();
}"
70202,"@Test public void loadIDLTest(){
  String constraintsFile=this.getClass().getResource(""String_Node_Str"").getPath();
  LinkedList<Integer> updatedMethods=new LinkedList<Integer>();
  HashMap<Integer,LinkedList<MethodImplementation>> readMethods=new HashMap<Integer,LinkedList<MethodImplementation>>();
  int coreCount=IDLParser.parseIDLMethods(updatedMethods,readMethods,constraintsFile);
  assertEquals(coreCount,CORECOUNT_RESULT);
  assertEquals(readMethods.size(),CORECOUNT_RESULT);
  System.out.println(""String_Node_Str"");
  LinkedList<MethodImplementation> implList=readMethods.get(0);
  assertNotNull(implList);
  MethodImplementation impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  Processor p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(p.getArchitecture(),""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(1);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE1_IMPLS_RESULT);
  impl=implList.get(0);
  assertEquals(impl.getRequirements().getMemorySize(),2.0f,0);
  assertEquals(impl.getRequirements().getStorageSize(),10.0f,0);
  impl=implList.get(1);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(impl.getRequirements().getMemorySize(),4.0f,0);
  impl=implList.get(2);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),1);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(2);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(3);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(4);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(impl.getRequirements().getProcessors().size(),COMPUTING_UNITS_RESULT);
  Processor p1=impl.getRequirements().getProcessors().get(0);
  Processor p2=impl.getRequirements().getProcessors().get(1);
  System.out.println(""String_Node_Str"");
  assertEquals(p1.getType(),""String_Node_Str"");
  assertEquals(p1.getComputingUnits(),2);
  assertEquals(p1.getArchitecture(),""String_Node_Str"");
  assertEquals(p1.getInternalMemory(),0.6f,0);
  System.out.println(""String_Node_Str"");
  assertEquals(p2.getType(),""String_Node_Str"");
  assertEquals(p2.getComputingUnits(),256);
  assertEquals(p2.getArchitecture(),""String_Node_Str"");
  assertEquals(p2.getInternalMemory(),0.024f,0);
}","@Test public void loadIDLTest(){
  String constraintsFile=this.getClass().getResource(""String_Node_Str"").getPath();
  LinkedList<Integer> updatedMethods=new LinkedList<Integer>();
  HashMap<Integer,LinkedList<MethodImplementation>> readMethods=new HashMap<Integer,LinkedList<MethodImplementation>>();
  int coreCount=IDLParser.parseIDLMethods(updatedMethods,readMethods,constraintsFile);
  assertEquals(coreCount,CORECOUNT_RESULT);
  assertEquals(readMethods.size(),CORECOUNT_RESULT);
  System.out.println(""String_Node_Str"");
  LinkedList<MethodImplementation> implList=readMethods.get(0);
  assertNotNull(implList);
  MethodImplementation impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  Processor p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(p.getArchitecture(),""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(1);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE1_IMPLS_RESULT);
  impl=implList.get(0);
  assertEquals(impl.getRequirements().getMemorySize(),2.0f,0);
  assertEquals(impl.getRequirements().getStorageSize(),10.0f,0);
  impl=implList.get(1);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(impl.getRequirements().getMemorySize(),4.0f,0);
  impl=implList.get(2);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),1);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(2);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(3);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(4);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(impl.getRequirements().getProcessors().size(),PROCESSOR_COUNT);
  Processor p1=impl.getRequirements().getProcessors().get(0);
  Processor p2=impl.getRequirements().getProcessors().get(1);
  System.out.println(""String_Node_Str"");
  assertEquals(p1.getType(),""String_Node_Str"");
  assertEquals(p1.getComputingUnits(),2);
  assertEquals(p1.getArchitecture(),""String_Node_Str"");
  assertEquals(p1.getInternalMemory(),0.6f,0);
  System.out.println(""String_Node_Str"");
  assertEquals(p2.getType(),""String_Node_Str"");
  assertEquals(p2.getComputingUnits(),256);
  assertEquals(p2.getArchitecture(),""String_Node_Str"");
  assertEquals(p2.getInternalMemory(),0.024f,0);
}"
70203,"public void generateWorkersDebugInfo(){
}","public boolean generateWorkersDebugInfo(){
  return false;
}"
70204,"public void generatePackage(){
}","public boolean generatePackage(){
  return false;
}"
70205,public abstract void generateWorkersDebugInfo();,public abstract boolean generateWorkersDebugInfo();
70206,public abstract void generatePackage();,public abstract boolean generatePackage();
70207,"public void retrieveData(boolean saveUniqueData){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=getAllDataFromHost();
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=null;
      String safePath=Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + ld.getName();
      try {
        SimpleURI uri=new SimpleURI(safePath);
        safeLoc=DataLocation.createLocation(Comm.appHost,uri);
      }
 catch (      Exception e) {
        ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + safePath,e);
      }
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (Tracer.isActivated()) {
      node.generatePackage();
      getTracingPackageToMaster();
      if (debug) {
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
      logger.debug(""String_Node_Str"" + this.getName());
    }
  }
}","public void retrieveData(boolean saveUniqueData){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=getAllDataFromHost();
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=null;
      String safePath=Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + ld.getName();
      try {
        SimpleURI uri=new SimpleURI(safePath);
        safeLoc=DataLocation.createLocation(Comm.appHost,uri);
      }
 catch (      Exception e) {
        ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + safePath,e);
      }
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (Tracer.isActivated()) {
      if (node.generatePackage()) {
        getTracingPackageToMaster();
        if (debug) {
          logger.debug(""String_Node_Str"" + this.getName());
        }
      }
    }
    if (debug) {
      if (node.generateWorkersDebugInfo()) {
        getWorkersDebugInfo();
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
  }
}"
70208,"public void executeScript(List<URI> cleanScripts,List<String> cleanParams){
}","public boolean executeScript(List<URI> cleanScripts,List<String> cleanParams){
}"
70209,"public static void generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  new CleanerExecutor(node).executeScript(traceScripts,traceParams);
}","public static boolean generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  return new CleanerExecutor(node).executeScript(traceScripts,traceParams);
}"
70210,"@Override public void generateWorkersDebugInfo(){
  logger.info(""String_Node_Str"");
}","@Override public boolean generateWorkersDebugInfo(){
  logger.info(""String_Node_Str"");
  return false;
}"
70211,"@Override public void generatePackage(){
  logger.debug(""String_Node_Str"");
  GATTracer.generatePackage(this);
}","@Override public boolean generatePackage(){
  logger.debug(""String_Node_Str"");
  GATTracer.generatePackage(this);
  return true;
}"
70212,"@Override public void stop(){
  logger.debug(""String_Node_Str"");
  HashSet<NIOWorkerNode> workers=new HashSet<NIOWorkerNode>();
  workers.addAll(nodes);
  Semaphore sem=new Semaphore(0);
  ShutdownListener sl=new ShutdownListener(sem);
  for (  NIOWorkerNode worker : workers) {
    logger.debug(""String_Node_Str"" + worker.getName());
    worker.stop(sl);
  }
  logger.debug(""String_Node_Str"");
  sl.enable();
  try {
    sem.acquire();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  tm.shutdown(null);
  logger.debug(""String_Node_Str"");
}","@Override public void stop(){
  logger.debug(""String_Node_Str"");
  HashSet<NIOWorkerNode> workers=new HashSet<NIOWorkerNode>();
  workers.addAll(nodes);
  Semaphore sem=new Semaphore(0);
  ShutdownListener sl=new ShutdownListener(sem);
  for (  NIOWorkerNode worker : workers) {
    logger.debug(""String_Node_Str"" + worker.getName());
    sl.addOperation();
    worker.stop(sl);
  }
  logger.debug(""String_Node_Str"");
  sl.enable();
  try {
    sem.acquire();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  tm.shutdown(null);
  logger.debug(""String_Node_Str"");
}"
70213,"@Override public void generateWorkersDebugInfo(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles();
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  commManager.waitUntilWorkersDebugInfoGenerated();
  logger.debug(""String_Node_Str"");
}","@Override public boolean generateWorkersDebugInfo(){
  if (started) {
    logger.debug(""String_Node_Str"" + this.getHost());
    if (node == null) {
      logger.error(""String_Node_Str"");
    }
    Connection c=NIOAgent.tm.startConnection(node);
    CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles();
    c.sendCommand(cmd);
    c.receive();
    c.finishConnection();
    commManager.waitUntilWorkersDebugInfoGenerated();
    logger.debug(""String_Node_Str"");
    return true;
  }
 else {
    logger.debug(""String_Node_Str"");
    return false;
  }
}"
70214,"@Override public void generatePackage(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGeneratePackage cmd=new CommandGeneratePackage();
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  commManager.waitUntilTracingPackageGenerated();
  logger.debug(""String_Node_Str"");
}","@Override public boolean generatePackage(){
  if (started) {
    logger.debug(""String_Node_Str"" + this.getHost());
    if (node == null) {
      logger.error(""String_Node_Str"" + this.getHost() + ""String_Node_Str"");
      return false;
    }
 else {
      Connection c=NIOAgent.tm.startConnection(node);
      CommandGeneratePackage cmd=new CommandGeneratePackage();
      c.sendCommand(cmd);
      c.receive();
      c.finishConnection();
      commManager.waitUntilTracingPackageGenerated();
      logger.debug(""String_Node_Str"");
      return true;
    }
  }
 else {
    logger.debug(""String_Node_Str"" + this.getHost() + ""String_Node_Str"");
    return false;
  }
}"
70215,"@Override public void start() throws Exception {
  NIONode n=null;
  try {
    n=new WorkerStarter(this).startWorker();
  }
 catch (  Exception e) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"",e);
    throw e;
  }
  this.node=n;
  if (NIOTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    NIOTracer.startTracing(this.getName(),this.getUser(),this.getHost(),this.getLimitOfTasks());
  }
}","@Override public void start() throws Exception {
  NIONode n=null;
  try {
    workerStarter=new WorkerStarter(this);
    n=workerStarter.startWorker();
  }
 catch (  Exception e) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"",e);
    throw e;
  }
  this.node=n;
  if (NIOTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    NIOTracer.startTracing(this.getName(),this.getUser(),this.getHost(),this.getLimitOfTasks());
  }
}"
70216,"@Override public void stop(ShutdownListener sl){
  logger.debug(""String_Node_Str"" + this.getName());
  if (node == null) {
    sl.notifyFailure(new UnstartedNodeException());
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  commManager.shuttingDown(this,c,sl);
  CommandShutdown cmd=new CommandShutdown(null,null);
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
}","@Override public void stop(ShutdownListener sl){
  if (started) {
    logger.debug(""String_Node_Str"" + this.getName());
    if (node == null) {
      sl.notifyFailure(new UnstartedNodeException());
      logger.error(""String_Node_Str"");
    }
    Connection c=NIOAgent.tm.startConnection(node);
    commManager.shuttingDown(this,c,sl);
    CommandShutdown cmd=new CommandShutdown(null,null);
    c.sendCommand(cmd);
    c.receive();
    c.finishConnection();
  }
 else {
    logger.debug(""String_Node_Str"" + this.getName() + ""String_Node_Str"");
    workerStarter.setToStop();
    sl.notifyEnd();
  }
}"
70217,"public NIONode startWorker() throws Exception {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
    }
    command=getStartCommand(nw,port);
    ProcessOut po=executeCommand(user,name,command);
    if (po.getExitValue() == 0) {
      String output=po.getOutput();
      String[] lines=output.split(""String_Node_Str"");
      pid=Integer.parseInt(lines[lines.length - 1]);
      long delay=300;
      long totalWait=0;
      n=new NIONode(name,port);
      String nodeName=nw.getName();
      addresstoWorkerStarter.put(nodeName,this);
      logger.debug(""String_Node_Str"");
      CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,nodeName);
      while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT)) {
        Thread.sleep(delay);
        if (!workerIsReady) {
          if (debug) {
            logger.debug(""String_Node_Str"" + nodeName);
          }
          Connection c=NIOAdaptor.tm.startConnection(n);
          c.sendCommand(cmd);
          c.receive();
          c.finishConnection();
          totalWait+=delay;
          delay=(delay < 1900) ? delay * 2 : 2000;
        }
      }
    }
 else {
      throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
    }
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      return n;
    }
  }
  if (!workerIsReady) {
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
  }
 else {
    return n;
  }
}","public NIONode startWorker() throws Exception {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort && !toStop) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
    }
    command=getStartCommand(nw,port);
    ProcessOut po=executeCommand(user,name,command);
    if (po.getExitValue() == 0) {
      String output=po.getOutput();
      String[] lines=output.split(""String_Node_Str"");
      pid=Integer.parseInt(lines[lines.length - 1]);
      long delay=300;
      long totalWait=0;
      n=new NIONode(name,port);
      String nodeName=nw.getName();
      addresstoWorkerStarter.put(nodeName,this);
      logger.debug(""String_Node_Str"");
      CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,nodeName);
      while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT) && !toStop) {
        Thread.sleep(delay);
        if (!workerIsReady) {
          if (debug) {
            logger.debug(""String_Node_Str"" + nodeName);
          }
          Connection c=NIOAdaptor.tm.startConnection(n);
          c.sendCommand(cmd);
          c.receive();
          c.finishConnection();
          totalWait+=delay;
          delay=(delay < 1900) ? delay * 2 : 2000;
        }
      }
    }
 else {
      throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
    }
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      nw.setStarted(true);
      return n;
    }
  }
  if (toStop) {
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
    return null;
  }
 else   if (!workerIsReady) {
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
  }
 else {
    return n;
  }
}"
70218,"@Override public void generateWorkersDebugInfo(){
}","@Override public boolean generateWorkersDebugInfo(){
  return false;
}"
70219,"@Override public void generatePackage(){
}","@Override public boolean generatePackage(){
  return false;
}"
70220,"public LogicalData transferObjectValue(TransferObjectRequest toRequest){
  Semaphore sem=toRequest.getSemaphore();
  DataAccessId daId=toRequest.getDaId();
  RWAccessId rwaId=(RWAccessId)daId;
  String sourceName=rwaId.getReadDataInstance().getRenaming();
  LogicalData ld=Comm.getData(sourceName);
  if (ld == null) {
    ErrorManager.error(""String_Node_Str"" + sourceName);
  }
  if (ld.isInMemory()) {
    if (!ld.isOnStorage()) {
      try {
        ld.writeToStorage();
        ld.removeValue();
      }
 catch (      Exception e) {
        ErrorManager.error(""String_Node_Str"",e);
      }
    }
 else {
      Comm.clearValue(sourceName);
    }
    toRequest.setResponse(ld.getValue());
    toRequest.getSemaphore().release();
  }
 else {
    DataLocation targetLocation=null;
    String path=DataLocation.Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + sourceName;
    try {
      SimpleURI uri=new SimpleURI(path);
      targetLocation=DataLocation.createLocation(Comm.appHost,uri);
    }
 catch (    Exception e) {
      ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + path,e);
    }
    Comm.appHost.getData(sourceName,targetLocation,new ObjectTransferable(),new OneOpWithSemListener(sem));
  }
  return ld;
}","public LogicalData transferObjectValue(TransferObjectRequest toRequest){
  Semaphore sem=toRequest.getSemaphore();
  DataAccessId daId=toRequest.getDaId();
  RWAccessId rwaId=(RWAccessId)daId;
  String sourceName=rwaId.getReadDataInstance().getRenaming();
  LogicalData ld=Comm.getData(sourceName);
  if (ld == null) {
    ErrorManager.error(""String_Node_Str"" + sourceName);
  }
  if (ld.isInMemory()) {
    if (!ld.isOnStorage()) {
      try {
        ld.writeToStorage();
        ld.removeValue();
      }
 catch (      Exception e) {
        ErrorManager.error(""String_Node_Str"",e);
      }
    }
 else {
      Comm.clearValue(sourceName);
    }
    toRequest.setResponse(ld.getValue());
    toRequest.setTargetData(ld);
    toRequest.getSemaphore().release();
  }
 else {
    DataLocation targetLocation=null;
    String path=DataLocation.Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + sourceName;
    try {
      SimpleURI uri=new SimpleURI(path);
      targetLocation=DataLocation.createLocation(Comm.appHost,uri);
    }
 catch (    Exception e) {
      ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + path,e);
    }
    Comm.appHost.getData(sourceName,targetLocation,new ObjectTransferable(),new OneOpWithSemListener(sem));
  }
  return ld;
}"
70221,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,Job.JobListener listener){
  return null;
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,Job.JobListener listener){
  return null;
}"
70222,"public abstract Job<?> newJob(int taskId,TaskParams taskparams,Implementation<?> impl,Resource res,JobListener listener);","public abstract Job<?> newJob(int taskId,TaskDescription taskparams,Implementation<?> impl,Resource res,JobListener listener);"
70223,"public TaskParams getTaskParams(){
  return taskParams;
}","public TaskDescription getTaskParams(){
  return taskParams;
}"
70224,"public Job(int taskId,TaskParams task,Implementation<?> impl,Resource res,JobListener listener){
  jobId=nextJobId++;
  this.taskId=taskId;
  this.history=JobHistory.NEW;
  this.taskParams=task;
  this.impl=impl;
  this.worker=res;
  this.listener=listener;
  classpathFromFile=getResourceNode().getClasspath();
  if (!classpathFromFile.equals(""String_Node_Str"")) {
    if (!classpathFromEnvironment.equals(""String_Node_Str"")) {
      workerClasspath=classpathFromEnvironment + ""String_Node_Str"" + classpathFromFile;
    }
 else {
      workerClasspath=classpathFromFile;
    }
  }
 else {
    workerClasspath=classpathFromEnvironment;
  }
  pythonpathFromFile=getResourceNode().getPythonpath();
  if (!pythonpathFromFile.equals(""String_Node_Str"")) {
    if (!pythonpathFromEnvironment.equals(""String_Node_Str"")) {
      workerPythonpath=pythonpathFromEnvironment + ""String_Node_Str"" + pythonpathFromFile;
    }
 else {
      workerPythonpath=pythonpathFromFile;
    }
  }
 else {
    workerPythonpath=pythonpathFromEnvironment;
  }
}","public Job(int taskId,TaskDescription task,Implementation<?> impl,Resource res,JobListener listener){
  jobId=nextJobId++;
  this.taskId=taskId;
  this.history=JobHistory.NEW;
  this.taskParams=task;
  this.impl=impl;
  this.worker=res;
  this.listener=listener;
  classpathFromFile=getResourceNode().getClasspath();
  if (!classpathFromFile.equals(""String_Node_Str"")) {
    if (!classpathFromEnvironment.equals(""String_Node_Str"")) {
      workerClasspath=classpathFromEnvironment + ""String_Node_Str"" + classpathFromFile;
    }
 else {
      workerClasspath=classpathFromFile;
    }
  }
 else {
    workerClasspath=classpathFromEnvironment;
  }
  pythonpathFromFile=getResourceNode().getPythonpath();
  if (!pythonpathFromFile.equals(""String_Node_Str"")) {
    if (!pythonpathFromEnvironment.equals(""String_Node_Str"")) {
      workerPythonpath=pythonpathFromEnvironment + ""String_Node_Str"" + pythonpathFromFile;
    }
 else {
      workerPythonpath=pythonpathFromFile;
    }
  }
 else {
    workerPythonpath=pythonpathFromEnvironment;
  }
}"
70225,"public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,JobListener listener){
  return node.newJob(taskId,taskParams,impl,this,listener);
}","public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,JobListener listener){
  return node.newJob(taskId,taskParams,impl,this,listener);
}"
70226,"public GATJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener,GATContext context,boolean userNeeded,boolean usingGlobus){
  super(taskId,taskParams,impl,res,listener);
  this.context=context;
  this.userNeeded=userNeeded;
  this.usingGlobus=usingGlobus;
}","public GATJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener,GATContext context,boolean userNeeded,boolean usingGlobus){
  super(taskId,taskParams,impl,res,listener);
  this.context=context;
  this.userNeeded=userNeeded;
  this.usingGlobus=usingGlobus;
}"
70227,"private JobDescription prepareJob() throws Exception {
  MethodImplementation method=(MethodImplementation)this.impl;
  TaskParams taskParams=this.taskParams;
  String methodName=method.getAlternativeMethodName();
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Boolean.toString(Tracer.isActivated()));
  lArgs.add(getHostName());
  if (debug) {
    logger.debug(""String_Node_Str"" + getHostName());
  }
  if (Tracer.isActivated()) {
    lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
    lArgs.add(String.valueOf(this.taskParams.getId() + 1));
    int slot=Tracer.getNextSlot(targetHost);
    lArgs.add(String.valueOf(slot));
    sd.addAttribute(""String_Node_Str"",slot);
  }
  lArgs.add(getResourceNode().getAppDir());
  lArgs.add(getClasspath());
  lArgs.add(getPythonpath());
  lArgs.add(String.valueOf(debug));
  lArgs.add(STORAGE_CONF);
  lArgs.add(method.getDeclaringClass());
  lArgs.add(methodName);
  lArgs.add(Boolean.toString(taskParams.hasTargetObject()));
  int numParams=taskParams.getParameters().length;
  if (taskParams.hasReturnValue()) {
    numParams--;
  }
  lArgs.add(Integer.toString(numParams));
  for (  Parameter param : taskParams.getParameters()) {
    DataType type=param.getType();
    lArgs.add(Integer.toString(type.ordinal()));
switch (type) {
case FILE_T:
      DependencyParameter dFilePar=(DependencyParameter)param;
    lArgs.add(dFilePar.getDataTarget());
  break;
case PSCO_T:
logger.error(""String_Node_Str"");
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
break;
case OBJECT_T:
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
lArgs.add(dPar.getDataTarget());
if (dAccId instanceof RAccessId) {
lArgs.add(""String_Node_Str"");
}
 else {
lArgs.add(""String_Node_Str"");
}
break;
case STRING_T:
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
lArgs.add(Integer.toString(numSubStrings));
lArgs.add(value);
break;
default :
BasicTypeParameter btParB=(BasicTypeParameter)param;
lArgs.add(btParB.getValue().toString());
break;
}
}
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ method.getDeclaringClass()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,method.getRequirements().getWallClockLimit());
if (method.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,method.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",method.getRequirements().getTotalComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,method.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}","private JobDescription prepareJob() throws Exception {
  MethodImplementation method=(MethodImplementation)this.impl;
  TaskDescription taskParams=this.taskParams;
  String methodName=method.getAlternativeMethodName();
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Boolean.toString(Tracer.isActivated()));
  lArgs.add(getHostName());
  if (debug) {
    logger.debug(""String_Node_Str"" + getHostName());
  }
  if (Tracer.isActivated()) {
    lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
    lArgs.add(String.valueOf(this.taskParams.getId() + 1));
    int slot=Tracer.getNextSlot(targetHost);
    lArgs.add(String.valueOf(slot));
    sd.addAttribute(""String_Node_Str"",slot);
  }
  lArgs.add(getResourceNode().getAppDir());
  lArgs.add(getClasspath());
  lArgs.add(getPythonpath());
  lArgs.add(String.valueOf(debug));
  lArgs.add(STORAGE_CONF);
  lArgs.add(method.getDeclaringClass());
  lArgs.add(methodName);
  lArgs.add(Boolean.toString(taskParams.hasTargetObject()));
  int numParams=taskParams.getParameters().length;
  if (taskParams.hasReturnValue()) {
    numParams--;
  }
  lArgs.add(Integer.toString(numParams));
  for (  Parameter param : taskParams.getParameters()) {
    DataType type=param.getType();
    lArgs.add(Integer.toString(type.ordinal()));
switch (type) {
case FILE_T:
      DependencyParameter dFilePar=(DependencyParameter)param;
    lArgs.add(dFilePar.getDataTarget());
  break;
case PSCO_T:
logger.error(""String_Node_Str"");
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
break;
case OBJECT_T:
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
lArgs.add(dPar.getDataTarget());
if (dAccId instanceof RAccessId) {
lArgs.add(""String_Node_Str"");
}
 else {
lArgs.add(""String_Node_Str"");
}
break;
case STRING_T:
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
lArgs.add(Integer.toString(numSubStrings));
lArgs.add(value);
break;
default :
BasicTypeParameter btParB=(BasicTypeParameter)param;
lArgs.add(btParB.getValue().toString());
break;
}
}
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ method.getDeclaringClass()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,method.getRequirements().getWallClockLimit());
if (method.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,method.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",method.getRequirements().getTotalComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,method.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}"
70228,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new GATJob(taskId,taskParams,impl,res,listener,config.getContext(),config.isUserNeeded(),config.isUsingGlobus());
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new GATJob(taskId,taskParams,impl,res,listener,config.getContext(),config.isUserNeeded(),config.isUsingGlobus());
}"
70229,"@Override public void handle(Connection c){
  if (agent.isMyUuid(this.uuid)) {
    if (agent.getMaster() == null) {
      agent.setMaster((NIONode)c.getNode());
    }
  }
  CommandCheckWorkerACK cmd=new CommandCheckWorkerACK(uuid,nodeName);
  c.sendCommand(cmd);
  c.finishConnection();
}","@Override public void handle(Connection c){
  if (agent.isMyUuid(this.uuid)) {
    if (agent.getMaster() == null) {
      agent.setMaster((NIONode)c.getNode());
    }
    CommandCheckWorkerACK cmd=new CommandCheckWorkerACK(uuid,nodeName);
    c.sendCommand(cmd);
  }
  c.finishConnection();
}"
70230,"public NIOJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
}","public NIOJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
}"
70231,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new NIOJob(taskId,taskParams,impl,res,listener);
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new NIOJob(taskId,taskParams,impl,res,listener);
}"
70232,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob<COMPSsWorker>(taskId,taskParams,impl,res,listener);
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob<COMPSsWorker>(taskId,taskParams,impl,res,listener);
}"
70233,"public WSJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
  this.returnValue=null;
}","public WSJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
  this.returnValue=null;
}"
70234,"@Override public void processRequests(){
  while (true) {
    WSJob<?> job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskParams taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == DataDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}","@Override public void processRequests(){
  while (true) {
    WSJob<?> job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskDescription taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == DataDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}"
70235,"private Object obtainObject(DataAccessId oaId){
  Semaphore sem=new Semaphore(0);
  TransferObjectRequest tor=new TransferObjectRequest(oaId,sem);
  requestQueue.offer(tor);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
  }
  Object oUpdated=tor.getResponse();
  if (oUpdated == null) {
    LogicalData ld=tor.getLogicalDataTarget();
    try {
      ld.loadFromStorage();
      oUpdated=ld.getValue();
    }
 catch (    Exception e) {
      logger.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ld.getName(),e);
      ErrorManager.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ld.getName(),e);
    }
  }
  return oUpdated;
}","private Object obtainObject(DataAccessId oaId){
  Semaphore sem=new Semaphore(0);
  TransferObjectRequest tor=new TransferObjectRequest(oaId,sem);
  requestQueue.offer(tor);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
  }
  Object oUpdated=tor.getResponse();
  if (oUpdated == null) {
    LogicalData ld=tor.getLogicalDataTarget();
    try {
      ld.loadFromStorage();
      oUpdated=ld.getValue();
    }
 catch (    Exception e) {
      logger.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ((ld == null) ? ""String_Node_Str"" : ld.getName()),e);
      ErrorManager.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ((ld == null) ? ""String_Node_Str"" : ld.getName()),e);
    }
  }
  return oUpdated;
}"
70236,"public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  return logicalData;
}","public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  if (value instanceof StubItf) {
    String id=((StubItf)value).getID();
    if (id != null) {
      Comm.registerPSCO(dataId,id);
    }
  }
  return logicalData;
}"
70237,"private static void setPropertiesFromRuntime(RuntimeConfigManager manager){
  try {
    if (manager != null) {
      if (manager.getDeploymentId() != null && System.getProperty(ITConstants.IT_DEPLOYMENT_ID) == null) {
        System.setProperty(ITConstants.IT_DEPLOYMENT_ID,manager.getDeploymentId());
      }
      if (manager.getMasterName() != null && System.getProperty(ITConstants.IT_MASTER_NAME) == null) {
        System.setProperty(ITConstants.IT_MASTER_NAME,manager.getMasterName());
      }
      if (manager.getMasterPort() != null && System.getProperty(ITConstants.IT_MASTER_PORT) == null) {
        System.setProperty(ITConstants.IT_MASTER_PORT,manager.getMasterPort());
      }
      if (manager.getAppName() != null && System.getProperty(ITConstants.IT_APP_NAME) == null) {
        System.setProperty(ITConstants.IT_APP_NAME,manager.getAppName());
      }
      if (manager.getCOMPSsBaseLogDir() != null && System.getProperty(ITConstants.IT_BASE_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_BASE_LOG_DIR,manager.getCOMPSsBaseLogDir());
      }
      if (manager.getSpecificLogDir() != null && System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_SPECIFIC_LOG_DIR,manager.getSpecificLogDir());
      }
      if (manager.getLog4jConfiguration() != null && System.getProperty(ITConstants.LOG4J) == null) {
        System.setProperty(ITConstants.LOG4J,manager.getLog4jConfiguration());
      }
      if (manager.getResourcesFile() != null && System.getProperty(ITConstants.IT_RES_FILE) == null) {
        System.setProperty(ITConstants.IT_RES_FILE,manager.getResourcesFile());
      }
      if (manager.getResourcesSchema() != null && System.getProperty(ITConstants.IT_RES_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_RES_SCHEMA,manager.getResourcesSchema());
      }
      if (manager.getProjectFile() != null && System.getProperty(ITConstants.IT_PROJ_FILE) == null) {
        System.setProperty(ITConstants.IT_PROJ_FILE,manager.getProjectFile());
      }
      if (manager.getProjectSchema() != null && System.getProperty(ITConstants.IT_PROJ_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_PROJ_SCHEMA,manager.getProjectSchema());
      }
      if (manager.getScheduler() != null && System.getProperty(ITConstants.IT_SCHEDULER) == null) {
        System.setProperty(ITConstants.IT_SCHEDULER,manager.getScheduler());
      }
      if (manager.getMonitorInterval() > 0 && System.getProperty(ITConstants.IT_MONITOR) == null) {
        System.setProperty(ITConstants.IT_MONITOR,Long.toString(manager.getMonitorInterval()));
      }
      if (manager.getGATAdaptor() != null && System.getProperty(ITConstants.GAT_ADAPTOR_PATH) == null) {
        System.setProperty(ITConstants.GAT_ADAPTOR_PATH,manager.getGATAdaptor());
      }
      if (manager.getGATBrokerAdaptor() != null && System.getProperty(ITConstants.GAT_BROKER_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_BROKER_ADAPTOR,manager.getGATBrokerAdaptor());
      }
      if (manager.getGATFileAdaptor() != null && System.getProperty(ITConstants.GAT_FILE_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_FILE_ADAPTOR,manager.getGATFileAdaptor());
      }
      if (manager.getWorkerCP() != null && System.getProperty(ITConstants.IT_WORKER_CP) == null) {
        System.setProperty(ITConstants.IT_WORKER_CP,manager.getWorkerCP());
      }
      if (manager.getServiceName() != null && System.getProperty(ITConstants.IT_SERVICE_NAME) == null) {
        System.setProperty(ITConstants.IT_SERVICE_NAME,manager.getServiceName());
      }
      if (System.getProperty(ITConstants.COMM_ADAPTOR) == null) {
        if (manager.getCommAdaptor() != null) {
          System.setProperty(ITConstants.COMM_ADAPTOR,manager.getCommAdaptor());
        }
 else {
          System.setProperty(ITConstants.COMM_ADAPTOR,ITConstants.DEFAULT_ADAPTOR);
        }
      }
      if (System.getProperty(ITConstants.GAT_DEBUG) == null) {
        System.setProperty(ITConstants.GAT_DEBUG,Boolean.toString(manager.isGATDebug()));
      }
      if (System.getProperty(ITConstants.IT_LANG) == null) {
        System.setProperty(ITConstants.IT_LANG,manager.getLang());
      }
      if (System.getProperty(ITConstants.IT_GRAPH) == null) {
        System.setProperty(ITConstants.IT_GRAPH,Boolean.toString(manager.isGraph()));
      }
      if (System.getProperty(ITConstants.IT_TRACING) == null) {
        System.setProperty(ITConstants.IT_TRACING,String.valueOf(manager.getTracing()));
      }
      if (System.getProperty(ITConstants.IT_EXTRAE_CONFIG_FILE) == null) {
        System.setProperty(ITConstants.IT_EXTRAE_CONFIG_FILE,manager.getCustomExtraeFile());
      }
      if (System.getProperty(ITConstants.IT_PRESCHED) == null) {
        System.setProperty(ITConstants.IT_PRESCHED,Boolean.toString(manager.isPresched()));
      }
      if (System.getProperty(ITConstants.IT_TASK_EXECUTION) == null || System.getProperty(ITConstants.IT_TASK_EXECUTION).equals(""String_Node_Str"")) {
        System.setProperty(ITConstants.IT_TASK_EXECUTION,ITConstants.EXECUTION_INTERNAL);
      }
      if (manager.getContext() != null) {
        System.setProperty(ITConstants.IT_CONTEXT,manager.getContext());
      }
      System.setProperty(ITConstants.IT_TO_FILE,Boolean.toString(manager.isToFile()));
    }
 else {
      setDefaultProperties();
    }
  }
 catch (  Exception e) {
    System.err.println(WARN_IT_FILE_NOT_READ);
    e.printStackTrace();
  }
}","private static void setPropertiesFromRuntime(RuntimeConfigManager manager){
  try {
    if (manager != null) {
      if (manager.getDeploymentId() != null && System.getProperty(ITConstants.IT_DEPLOYMENT_ID) == null) {
        System.setProperty(ITConstants.IT_DEPLOYMENT_ID,manager.getDeploymentId());
      }
      if (manager.getMasterName() != null && System.getProperty(ITConstants.IT_MASTER_NAME) == null) {
        System.setProperty(ITConstants.IT_MASTER_NAME,manager.getMasterName());
      }
      if (manager.getMasterPort() != null && System.getProperty(ITConstants.IT_MASTER_PORT) == null) {
        System.setProperty(ITConstants.IT_MASTER_PORT,manager.getMasterPort());
      }
      if (manager.getAppName() != null && System.getProperty(ITConstants.IT_APP_NAME) == null) {
        System.setProperty(ITConstants.IT_APP_NAME,manager.getAppName());
      }
      if (manager.getTaskSummary() != null && System.getProperty(ITConstants.IT_TASK_SUMMARY) == null) {
        System.setProperty(ITConstants.IT_TASK_SUMMARY,manager.getTaskSummary());
      }
      if (manager.getCOMPSsBaseLogDir() != null && System.getProperty(ITConstants.IT_BASE_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_BASE_LOG_DIR,manager.getCOMPSsBaseLogDir());
      }
      if (manager.getSpecificLogDir() != null && System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_SPECIFIC_LOG_DIR,manager.getSpecificLogDir());
      }
      if (manager.getLog4jConfiguration() != null && System.getProperty(ITConstants.LOG4J) == null) {
        System.setProperty(ITConstants.LOG4J,manager.getLog4jConfiguration());
      }
      if (manager.getResourcesFile() != null && System.getProperty(ITConstants.IT_RES_FILE) == null) {
        System.setProperty(ITConstants.IT_RES_FILE,manager.getResourcesFile());
      }
      if (manager.getResourcesSchema() != null && System.getProperty(ITConstants.IT_RES_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_RES_SCHEMA,manager.getResourcesSchema());
      }
      if (manager.getProjectFile() != null && System.getProperty(ITConstants.IT_PROJ_FILE) == null) {
        System.setProperty(ITConstants.IT_PROJ_FILE,manager.getProjectFile());
      }
      if (manager.getProjectSchema() != null && System.getProperty(ITConstants.IT_PROJ_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_PROJ_SCHEMA,manager.getProjectSchema());
      }
      if (manager.getScheduler() != null && System.getProperty(ITConstants.IT_SCHEDULER) == null) {
        System.setProperty(ITConstants.IT_SCHEDULER,manager.getScheduler());
      }
      if (manager.getMonitorInterval() > 0 && System.getProperty(ITConstants.IT_MONITOR) == null) {
        System.setProperty(ITConstants.IT_MONITOR,Long.toString(manager.getMonitorInterval()));
      }
      if (manager.getGATAdaptor() != null && System.getProperty(ITConstants.GAT_ADAPTOR_PATH) == null) {
        System.setProperty(ITConstants.GAT_ADAPTOR_PATH,manager.getGATAdaptor());
      }
      if (manager.getGATBrokerAdaptor() != null && System.getProperty(ITConstants.GAT_BROKER_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_BROKER_ADAPTOR,manager.getGATBrokerAdaptor());
      }
      if (manager.getGATFileAdaptor() != null && System.getProperty(ITConstants.GAT_FILE_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_FILE_ADAPTOR,manager.getGATFileAdaptor());
      }
      if (manager.getWorkerCP() != null && System.getProperty(ITConstants.IT_WORKER_CP) == null) {
        System.setProperty(ITConstants.IT_WORKER_CP,manager.getWorkerCP());
      }
      if (manager.getServiceName() != null && System.getProperty(ITConstants.IT_SERVICE_NAME) == null) {
        System.setProperty(ITConstants.IT_SERVICE_NAME,manager.getServiceName());
      }
      if (System.getProperty(ITConstants.COMM_ADAPTOR) == null) {
        if (manager.getCommAdaptor() != null) {
          System.setProperty(ITConstants.COMM_ADAPTOR,manager.getCommAdaptor());
        }
 else {
          System.setProperty(ITConstants.COMM_ADAPTOR,ITConstants.DEFAULT_ADAPTOR);
        }
      }
      if (System.getProperty(ITConstants.GAT_DEBUG) == null) {
        System.setProperty(ITConstants.GAT_DEBUG,Boolean.toString(manager.isGATDebug()));
      }
      if (System.getProperty(ITConstants.IT_LANG) == null) {
        System.setProperty(ITConstants.IT_LANG,manager.getLang());
      }
      if (System.getProperty(ITConstants.IT_GRAPH) == null) {
        System.setProperty(ITConstants.IT_GRAPH,Boolean.toString(manager.isGraph()));
      }
      if (System.getProperty(ITConstants.IT_TRACING) == null) {
        System.setProperty(ITConstants.IT_TRACING,String.valueOf(manager.getTracing()));
      }
      if (System.getProperty(ITConstants.IT_EXTRAE_CONFIG_FILE) == null) {
        System.setProperty(ITConstants.IT_EXTRAE_CONFIG_FILE,manager.getCustomExtraeFile());
      }
      if (System.getProperty(ITConstants.IT_PRESCHED) == null) {
        System.setProperty(ITConstants.IT_PRESCHED,Boolean.toString(manager.isPresched()));
      }
      if (System.getProperty(ITConstants.IT_TASK_EXECUTION) == null || System.getProperty(ITConstants.IT_TASK_EXECUTION).equals(""String_Node_Str"")) {
        System.setProperty(ITConstants.IT_TASK_EXECUTION,ITConstants.EXECUTION_INTERNAL);
      }
      if (manager.getContext() != null) {
        System.setProperty(ITConstants.IT_CONTEXT,manager.getContext());
      }
      System.setProperty(ITConstants.IT_TO_FILE,Boolean.toString(manager.isToFile()));
    }
 else {
      setDefaultProperties();
    }
  }
 catch (  Exception e) {
    System.err.println(WARN_IT_FILE_NOT_READ);
    e.printStackTrace();
  }
}"
70238,"/** 
 * Stops the COMPSsRuntime
 */
@Override public void stopIT(boolean terminate){
synchronized (this) {
    if (Tracer.isActivated()) {
      Tracer.emitEvent(Tracer.Event.STOP.getId(),Tracer.Event.STOP.getType());
    }
    td.getTaskSummary(logger);
    logger.info(""String_Node_Str"");
    if (GraphGenerator.isEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    if (RuntimeMonitor.isEnabled()) {
      logger.debug(""String_Node_Str"");
      runtimeMonitor.shutdown();
    }
    logger.debug(""String_Node_Str"");
    if (ap != null) {
      ap.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    if (td != null) {
      td.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    Comm.stop();
    logger.debug(""String_Node_Str"");
  }
  logger.warn(""String_Node_Str"");
}","/** 
 * Stops the COMPSsRuntime
 */
@Override public void stopIT(boolean terminate){
synchronized (this) {
    if (Tracer.isActivated()) {
      Tracer.emitEvent(Tracer.Event.STOP.getId(),Tracer.Event.STOP.getType());
    }
    boolean taskSummaryEnabled=System.getProperty(ITConstants.IT_TASK_SUMMARY) != null && !System.getProperty(ITConstants.IT_TASK_SUMMARY).isEmpty() && Boolean.valueOf(System.getProperty(ITConstants.IT_TASK_SUMMARY));
    if (taskSummaryEnabled) {
      td.getTaskSummary(logger);
    }
    logger.info(""String_Node_Str"");
    if (GraphGenerator.isEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    if (RuntimeMonitor.isEnabled()) {
      logger.debug(""String_Node_Str"");
      runtimeMonitor.shutdown();
    }
    logger.debug(""String_Node_Str"");
    if (ap != null) {
      ap.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    if (td != null) {
      td.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    Comm.stop();
    logger.debug(""String_Node_Str"");
  }
  logger.warn(""String_Node_Str"");
}"
70239,"public DataAccessId registerObjectAccess(AccessMode mode,Object value,int code,int readerId){
  DataInfo oInfo;
  Integer aoId=codeToId.get(code);
  if (aoId == null) {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=new ObjectInfo(code);
    aoId=oInfo.getDataId();
    codeToId.put(code,aoId);
    idToData.put(aoId,oInfo);
    DataInstanceId lastDID=oInfo.getCurrentDataInstanceId();
    String renaming=lastDID.getRenaming();
    if (mode != AccessMode.W) {
      Comm.registerValue(renaming,value);
      if (value instanceof StubItf) {
        String id=((StubItf)value).getID();
        if (id != null) {
          Comm.registerPSCO(renaming,id);
        }
      }
    }
  }
 else {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=idToData.get(aoId);
  }
  return willAccess(mode,oInfo);
}","public DataAccessId registerObjectAccess(AccessMode mode,Object value,int code,int readerId){
  DataInfo oInfo;
  Integer aoId=codeToId.get(code);
  if (aoId == null) {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=new ObjectInfo(code);
    aoId=oInfo.getDataId();
    codeToId.put(code,aoId);
    idToData.put(aoId,oInfo);
    DataInstanceId lastDID=oInfo.getCurrentDataInstanceId();
    String renaming=lastDID.getRenaming();
    if (mode != AccessMode.W) {
      Comm.registerValue(renaming,value);
    }
  }
 else {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=idToData.get(aoId);
  }
  return willAccess(mode,oInfo);
}"
70240,"/** 
 * Sets the PSCO Id value (null if it is not PSCO)
 * @param id
 */
public synchronized void setId(String id){
  this.id=id;
}","/** 
 * Sets the LD id
 * @param id
 */
public synchronized void setId(String id){
  this.id=id;
}"
70241,"/** 
 * Loads the value of the LogicalData from a file
 * @throws Exception
 */
public synchronized void loadFromStorage() throws Exception {
  if (value != null) {
    return;
  }
  for (  DataLocation loc : this.locations) {
switch (loc.getType()) {
case PRIVATE:
case SHARED:
      MultiURI u=loc.getURIInHost(Comm.appHost);
    if (u == null) {
      continue;
    }
  String path=u.getPath();
if (path.startsWith(File.separator)) {
  this.value=Serializer.deserialize(path);
  String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
  SimpleURI uri=new SimpleURI(targetPath);
  DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
  addLocation(tgtLoc);
}
return;
case PERSISTENT:
PersistentLocation pLoc=(PersistentLocation)loc;
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.Event.STORAGE_GETBYID.getId(),Tracer.Event.STORAGE_GETBYID.getType());
}
try {
this.value=StorageItf.getByID(pLoc.getId());
}
 catch (StorageException se) {
throw new Exception(""String_Node_Str"" + pLoc.getId(),se);
}
 finally {
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.EVENT_END,Tracer.Event.STORAGE_GETBYID.getType());
}
}
String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
SimpleURI uri=new SimpleURI(targetPath);
DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
addLocation(tgtLoc);
return;
}
}
throw new Exception(""String_Node_Str"");
}","/** 
 * Loads the value of the LogicalData from a file
 * @throws Exception
 */
public synchronized void loadFromStorage() throws Exception {
  if (value != null) {
    return;
  }
  for (  DataLocation loc : this.locations) {
switch (loc.getType()) {
case PRIVATE:
case SHARED:
      MultiURI u=loc.getURIInHost(Comm.appHost);
    if (u == null) {
      continue;
    }
  String path=u.getPath();
if (path.startsWith(File.separator)) {
  this.value=Serializer.deserialize(path);
  String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
  SimpleURI uri=new SimpleURI(targetPath);
  DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
  addLocation(tgtLoc);
}
return;
case PERSISTENT:
PersistentLocation pLoc=(PersistentLocation)loc;
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.Event.STORAGE_GETBYID.getId(),Tracer.Event.STORAGE_GETBYID.getType());
}
try {
this.value=StorageItf.getByID(pLoc.getId());
this.id=pLoc.getId();
}
 catch (StorageException se) {
throw new Exception(""String_Node_Str"" + pLoc.getId(),se);
}
 finally {
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.EVENT_END,Tracer.Event.STORAGE_GETBYID.getType());
}
}
String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
SimpleURI uri=new SimpleURI(targetPath);
DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
addLocation(tgtLoc);
return;
}
}
throw new Exception(""String_Node_Str"");
}"
70242,"/** 
 * Prints in a file the final task graph
 */
public void commitGraph(){
  logger.debug(""String_Node_Str"");
  try {
    full_graph.close();
    try (FileInputStream sourceStream=new FileInputStream(COMPLETE_GRAPH_TMP_FILE);FileOutputStream destStream=new FileOutputStream(COMPLETE_GRAPH_FILE);FileChannel sourceChannel=sourceStream.getChannel();FileChannel destChannel=destStream.getChannel()){
      destChannel.transferFrom(sourceChannel,0,sourceChannel.size());
    }
     full_graph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_TMP_FILE,true));
    BufferedWriter finalGraph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_FILE,true));
    closeDependenceGraph(finalGraph);
    openLegend(finalGraph);
    legend.close();
    try (FileInputStream sourceStream=new FileInputStream(COMPLETE_LEGEND_TMP_FILE);FileOutputStream destStream=new FileOutputStream(COMPLETE_GRAPH_FILE);FileChannel sourceChannel=sourceStream.getChannel();FileChannel destChannel=destStream.getChannel()){
      destChannel.position(destChannel.size());
      sourceChannel.transferTo(0,sourceChannel.size(),destChannel);
    }
     legend=new BufferedWriter(new FileWriter(COMPLETE_LEGEND_TMP_FILE,true));
    closeLegend(finalGraph);
    closeGraphFile(finalGraph);
    finalGraph.close();
  }
 catch (  Exception e) {
    logger.error(ERROR_COMMIT_FINAL_GRAPH,e);
  }
}","/** 
 * Prints in a file the final task graph
 */
public void commitGraph(){
  logger.debug(""String_Node_Str"");
  try {
    full_graph.close();
    FileInputStream sourceFIS=null;
    FileOutputStream destFOS=null;
    FileChannel sourceChannel=null;
    FileChannel destChannel=null;
    try {
      sourceFIS=new FileInputStream(COMPLETE_GRAPH_TMP_FILE);
      destFOS=new FileOutputStream(COMPLETE_GRAPH_FILE);
      sourceChannel=sourceFIS.getChannel();
      destChannel=destFOS.getChannel();
      destChannel.transferFrom(sourceChannel,0,sourceChannel.size());
    }
  finally {
      sourceChannel.close();
      sourceFIS.close();
      destChannel.close();
      destFOS.close();
    }
    full_graph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_TMP_FILE,true));
    BufferedWriter finalGraph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_FILE,true));
    closeDependenceGraph(finalGraph);
    openLegend(finalGraph);
    legend.close();
    try {
      sourceFIS=new FileInputStream(COMPLETE_LEGEND_TMP_FILE);
      sourceChannel=sourceFIS.getChannel();
      destFOS=new FileOutputStream(COMPLETE_GRAPH_FILE,true);
      destChannel=destFOS.getChannel();
      destChannel.position(destChannel.size());
      sourceChannel.transferTo(0,sourceChannel.size(),destChannel);
    }
  finally {
      sourceChannel.close();
      sourceFIS.close();
      destChannel.close();
      destFOS.close();
    }
    legend=new BufferedWriter(new FileWriter(COMPLETE_LEGEND_TMP_FILE,true));
    closeLegend(finalGraph);
    closeGraphFile(finalGraph);
    finalGraph.close();
  }
 catch (  Exception e) {
    logger.error(ERROR_COMMIT_FINAL_GRAPH,e);
  }
}"
70243,"public MethodConfiguration(MethodConfiguration clone){
  super(clone);
  host=clone.host;
  user=clone.host;
  installDir=clone.installDir;
  workingDir=clone.workingDir;
  totalComputingUnits=clone.totalComputingUnits;
  appDir=clone.appDir;
  classpath=clone.classpath;
  pythonpath=clone.pythonpath;
  libraryPath=clone.libraryPath;
}","public MethodConfiguration(MethodConfiguration clone){
  super(clone);
  host=clone.host;
  user=clone.user;
  installDir=clone.installDir;
  workingDir=clone.workingDir;
  totalComputingUnits=clone.totalComputingUnits;
  appDir=clone.appDir;
  classpath=clone.classpath;
  pythonpath=clone.pythonpath;
  libraryPath=clone.libraryPath;
}"
70244,"public final void getWorkloadState(ResourceUser.WorkloadStatus response){
  int coreCount=CoreManager.getCoreCount();
  Profile[] coreProfile=new Profile[coreCount];
  for (int coreId=0; coreId < coreCount; coreId++) {
    coreProfile[coreId]=new Profile();
  }
  for (  ResourceScheduler<P,T> ui : workers.values()) {
    if (ui == null) {
      continue;
    }
    LinkedList<Implementation<T>>[] impls=ui.getExecutableImpls();
    for (int coreId=0; coreId < coreCount; coreId++) {
      for (      Implementation<T> impl : impls[coreId]) {
        coreProfile[coreId].accumulate(ui.getProfile(impl));
      }
    }
    LinkedList<AllocatableAction<P,T>> runningActions=ui.getHostedActions();
    long now=System.currentTimeMillis();
    for (    AllocatableAction<P,T> running : runningActions) {
      if (running.getImplementations().length > 0) {
        int coreId=running.getImplementations()[0].getCoreId();
        response.registerRunning(coreId,now - running.getStartTime());
      }
    }
  }
  for (int coreId=0; coreId < coreCount; coreId++) {
    response.registerNoResources(coreId,blockedActions.getActionCounts()[coreId]);
    response.registerReady(coreId,readyCounts[coreId]);
    response.registerTimes(coreId,coreProfile[coreId].getMinExecutionTime(),coreProfile[coreId].getAverageExecutionTime(),coreProfile[coreId].getMaxExecutionTime());
  }
}","public final void getWorkloadState(ResourceUser.WorkloadStatus response){
  int coreCount=CoreManager.getCoreCount();
  Profile[] coreProfile=new Profile[coreCount];
  for (int coreId=0; coreId < coreCount; coreId++) {
    coreProfile[coreId]=new Profile();
  }
  for (  ResourceScheduler<P,T> ui : workers.values()) {
    if (ui == null) {
      continue;
    }
    LinkedList<Implementation<T>>[] impls=ui.getExecutableImpls();
    for (int coreId=0; coreId < coreCount; coreId++) {
      for (      Implementation<T> impl : impls[coreId]) {
        coreProfile[coreId].accumulate(ui.getProfile(impl));
      }
    }
    LinkedList<AllocatableAction<P,T>> runningActions=ui.getHostedActions();
    long now=System.currentTimeMillis();
    for (    AllocatableAction<P,T> running : runningActions) {
      if (running.getImplementations().length > 0) {
        Integer coreId=running.getImplementations()[0].getCoreId();
        if (coreId != null) {
          response.registerRunning(coreId,now - running.getStartTime());
        }
      }
    }
  }
  for (int coreId=0; coreId < coreCount; coreId++) {
    response.registerNoResources(coreId,blockedActions.getActionCounts()[coreId]);
    response.registerReady(coreId,readyCounts[coreId]);
    response.registerTimes(coreId,coreProfile[coreId].getMinExecutionTime(),coreProfile[coreId].getAverageExecutionTime(),coreProfile[coreId].getMaxExecutionTime());
  }
}"
70245,"public TaskAnalyser(){
  currentTaskCount=new HashMap<Integer,Integer>();
  writers=new TreeMap<Integer,Task>();
  appIdToTaskCount=new HashMap<Long,Integer>();
  appIdToTotalTaskCount=new HashMap<Long,Integer>();
  appIdToSemaphore=new HashMap<Long,Semaphore>();
  appIdToWrittenFiles=new HashMap<Long,TreeSet<Integer>>();
  waitedTasks=new Hashtable<Task,List<Semaphore>>();
  synchronizationId=0;
  logger.info(""String_Node_Str"");
}","public TaskAnalyser(){
  currentTaskCount=new HashMap<Integer,Integer>();
  writers=new TreeMap<Integer,Task>();
  appIdToTaskCount=new HashMap<Long,Integer>();
  appIdToTotalTaskCount=new HashMap<Long,Integer>();
  appIdToSemaphore=new HashMap<Long,Semaphore>();
  appIdToWrittenFiles=new HashMap<Long,TreeSet<Integer>>();
  appIdToSCOWrittenIds=new HashMap<Long,TreeSet<Integer>>();
  waitedTasks=new Hashtable<Task,List<Semaphore>>();
  synchronizationId=0;
  logger.info(""String_Node_Str"");
}"
70246,"/** 
 * Registers and action as completed and releases all the resource and data dependencies.
 * @param action action that has finished
 */
public final void actionCompleted(AllocatableAction<P,T> action){
  ResourceScheduler<P,T> resource=action.getAssignedResource();
  if (action.getImplementations().length > 0) {
    int coreId=action.getImplementations()[0].getCoreId();
    readyCounts[coreId]--;
  }
  LinkedList<AllocatableAction<P,T>> dataFreeActions=action.completed();
  for (  AllocatableAction<P,T> dataFreeAction : dataFreeActions) {
    if (dataFreeAction.getImplementations().length > 0) {
      int coreId=dataFreeAction.getImplementations()[0].getCoreId();
      readyCounts[coreId]++;
    }
    try {
      dependencyFreeAction(dataFreeAction);
    }
 catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
  LinkedList<AllocatableAction<P,T>> resourceFree=resource.unscheduleAction(action);
  workerLoadUpdate((ResourceScheduler<P,T>)action.getAssignedResource());
  HashSet<AllocatableAction<P,T>> freeTasks=new HashSet<AllocatableAction<P,T>>();
  freeTasks.addAll(dataFreeActions);
  freeTasks.addAll(resourceFree);
  for (  AllocatableAction<P,T> a : freeTasks) {
    try {
      try {
        a.tryToLaunch();
      }
 catch (      InvalidSchedulingException ise) {
        Score aScore=a.schedulingScore(this);
        a.schedule(action.getConstrainingPredecessor().getAssignedResource(),aScore);
        try {
          a.tryToLaunch();
        }
 catch (        InvalidSchedulingException ise2) {
        }
      }
    }
 catch (    UnassignedActionException ure) {
      StringBuilder info=new StringBuilder(""String_Node_Str"");
      info.append(action.toString());
      ErrorManager.fatal(info.toString());
    }
catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
}","/** 
 * Registers and action as completed and releases all the resource and data dependencies.
 * @param action action that has finished
 */
public final void actionCompleted(AllocatableAction<P,T> action){
  ResourceScheduler<P,T> resource=action.getAssignedResource();
  if (action.getImplementations().length > 0) {
    int coreId=action.getImplementations()[0].getCoreId();
    readyCounts[coreId]--;
  }
  LinkedList<AllocatableAction<P,T>> dataFreeActions=action.completed();
  for (  AllocatableAction<P,T> dataFreeAction : dataFreeActions) {
    if (dataFreeAction.getImplementations().length > 0) {
      int coreId=dataFreeAction.getImplementations()[0].getCoreId();
      readyCounts[coreId]++;
    }
    try {
      dependencyFreeAction(dataFreeAction);
    }
 catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
  LinkedList<AllocatableAction<P,T>> resourceFree=resource.unscheduleAction(action);
  workerLoadUpdate((ResourceScheduler<P,T>)action.getAssignedResource());
  for (  AllocatableAction<P,T> a : resourceFree) {
    try {
      try {
        a.tryToLaunch();
      }
 catch (      InvalidSchedulingException ise) {
        Score aScore=a.schedulingScore(this);
        a.schedule(action.getConstrainingPredecessor().getAssignedResource(),aScore);
        try {
          a.tryToLaunch();
        }
 catch (        InvalidSchedulingException ise2) {
        }
      }
    }
 catch (    UnassignedActionException ure) {
      StringBuilder info=new StringBuilder(""String_Node_Str"");
      info.append(action.toString());
      ErrorManager.fatal(info.toString());
    }
catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
}"
70247,"@Override public void dependencyFreeAction(AllocatableAction<P,T> action) throws BlockedActionException {
  dependingActions.removeAction(action);
  try {
    Score actionScore=action.schedulingScore(this);
    action.schedule(actionScore);
  }
 catch (  UnassignedActionException ex) {
    unassignedReadyActions.addAction(action);
  }
}","@Override public void dependencyFreeAction(AllocatableAction<P,T> action) throws BlockedActionException {
  dependingActions.removeAction(action);
  try {
    Score actionScore=action.schedulingScore(this);
    action.schedule(actionScore);
    try {
      action.tryToLaunch();
    }
 catch (    InvalidSchedulingException ise) {
      action.schedule(action.getConstrainingPredecessor().getAssignedResource(),actionScore);
      try {
        action.tryToLaunch();
      }
 catch (      InvalidSchedulingException ise2) {
      }
    }
  }
 catch (  UnassignedActionException ex) {
    unassignedReadyActions.addAction(action);
  }
}"
70248,"public MasterResource(){
  super(new COMPSsMaster());
  userExecutionDirPath=System.getProperty(""String_Node_Str"");
  boolean mustCreateExecutionSandbox=true;
  String specificOpt=System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR);
  if (specificOpt != null && !specificOpt.isEmpty()) {
    COMPSsLogBaseDirPath=specificOpt.endsWith(File.separator) ? specificOpt : specificOpt + File.separator;
    mustCreateExecutionSandbox=false;
  }
 else {
    String baseOpt=System.getProperty(ITConstants.IT_BASE_LOG_DIR);
    if (baseOpt != null && !baseOpt.isEmpty()) {
      baseOpt=baseOpt.endsWith(File.separator) ? baseOpt : baseOpt + File.separator;
      COMPSsLogBaseDirPath=baseOpt + ""String_Node_Str"" + File.separator;
    }
 else {
      COMPSsLogBaseDirPath=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator;
    }
  }
  if (!new File(COMPSsLogBaseDirPath).exists()) {
    if (!new File(COMPSsLogBaseDirPath).mkdir()) {
      ErrorManager.error(ERROR_COMPSs_LOG_BASE_DIR);
    }
  }
  if (mustCreateExecutionSandbox) {
    String appName=System.getProperty(ITConstants.IT_APP_NAME);
    if (System.getProperty(ITConstants.IT_SERVICE_NAME) != null) {
      String serviceName=System.getProperty(ITConstants.IT_SERVICE_NAME);
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
 else {
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
  }
 else {
    appLogDirPath=COMPSsLogBaseDirPath;
    System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
  }
  tempDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(tempDirPath).mkdir()) {
    ErrorManager.error(ERROR_TEMP_DIR);
  }
  jobsDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(jobsDirPath).mkdir()) {
    ErrorManager.error(ERROR_JOBS_DIR);
  }
  workersDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(workersDirPath).mkdir()) {
    System.err.println(ERROR_WORKERS_DIR);
    System.exit(1);
  }
}","public MasterResource(){
  super(new COMPSsMaster(),null);
  userExecutionDirPath=System.getProperty(""String_Node_Str"");
  boolean mustCreateExecutionSandbox=true;
  String specificOpt=System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR);
  if (specificOpt != null && !specificOpt.isEmpty()) {
    COMPSsLogBaseDirPath=specificOpt.endsWith(File.separator) ? specificOpt : specificOpt + File.separator;
    mustCreateExecutionSandbox=false;
  }
 else {
    String baseOpt=System.getProperty(ITConstants.IT_BASE_LOG_DIR);
    if (baseOpt != null && !baseOpt.isEmpty()) {
      baseOpt=baseOpt.endsWith(File.separator) ? baseOpt : baseOpt + File.separator;
      COMPSsLogBaseDirPath=baseOpt + ""String_Node_Str"" + File.separator;
    }
 else {
      COMPSsLogBaseDirPath=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator;
    }
  }
  if (!new File(COMPSsLogBaseDirPath).exists()) {
    if (!new File(COMPSsLogBaseDirPath).mkdir()) {
      ErrorManager.error(ERROR_COMPSs_LOG_BASE_DIR);
    }
  }
  if (mustCreateExecutionSandbox) {
    String appName=System.getProperty(ITConstants.IT_APP_NAME);
    if (System.getProperty(ITConstants.IT_SERVICE_NAME) != null) {
      String serviceName=System.getProperty(ITConstants.IT_SERVICE_NAME);
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
 else {
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
  }
 else {
    appLogDirPath=COMPSsLogBaseDirPath;
    System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
  }
  tempDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(tempDirPath).mkdir()) {
    ErrorManager.error(ERROR_TEMP_DIR);
  }
  jobsDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(jobsDirPath).mkdir()) {
    ErrorManager.error(ERROR_JOBS_DIR);
  }
  workersDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(workersDirPath).mkdir()) {
    System.err.println(ERROR_WORKERS_DIR);
    System.exit(1);
  }
}"
70249,"public void start(HashMap<String,String> disks) throws Exception {
  this.node.start();
  for (  java.util.Map.Entry<String,String> disk : disks.entrySet()) {
    addSharedDisk(disk.getKey(),disk.getValue());
  }
}","public void start() throws Exception {
  this.node.start();
  if (sharedDisks != null) {
    for (    java.util.Map.Entry<String,String> disk : sharedDisks.entrySet()) {
      SharedDiskManager.addSharedToMachine(disk.getKey(),disk.getValue(),this);
    }
  }
}"
70250,"public void run(){
  Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
  try {
    selectedResource.getResource().start(new HashMap<String,String>());
    notifyCompleted();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ErrorManager.warn(""String_Node_Str"",e);
    notifyError();
  }
}","public void run(){
  Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
  try {
    selectedResource.getResource().start();
    notifyCompleted();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ErrorManager.warn(""String_Node_Str"",e);
    notifyError();
  }
}"
70251,"@Override protected void doAction(){
  (new Thread(){
    public void run(){
      Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
      try {
        selectedResource.getResource().start(new HashMap<String,String>());
        notifyCompleted();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        ErrorManager.warn(""String_Node_Str"",e);
        notifyError();
      }
    }
  }
).start();
}","@Override protected void doAction(){
  (new Thread(){
    public void run(){
      Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
      try {
        selectedResource.getResource().start();
        notifyCompleted();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        ErrorManager.warn(""String_Node_Str"",e);
        notifyError();
      }
    }
  }
).start();
}"
70252,"public FakeWorker(WorkerResourceDescription description,int limitOfTasks){
  super(""String_Node_Str"",(T)description,new FakeNode(),limitOfTasks);
}","public FakeWorker(WorkerResourceDescription description,int limitOfTasks){
  super(""String_Node_Str"",(T)description,new FakeNode(),limitOfTasks,null);
}"
70253,"public void run(){
  boolean check=operations.getCheck();
  runtimeLogger.debug(""String_Node_Str"" + check);
  CloudMethodResourceDescription requested=rcr.getRequested();
  VM granted;
  if (reused == null) {
    this.setName(""String_Node_Str"" + name);
    try {
      granted=createResourceOnProvider(requested);
    }
 catch (    Exception e) {
      notifyFailure();
      return;
    }
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
 else {
    granted=reused;
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + reused.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
  this.setName(""String_Node_Str"" + granted.getName());
  CloudMethodWorker r=ResourceManager.getDynamicResource(granted.getName());
  if (r == null) {
    if (reused == null) {
      try {
        if (debug) {
          runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
        }
        r=prepareNewResource(granted);
        operations.vmReady(granted);
      }
 catch (      Exception e) {
        runtimeLogger.error(""String_Node_Str"",e);
        powerOff(granted);
        notifyFailure();
        return;
      }
    }
 else {
      int limitOfTasks=granted.getDescription().getTotalComputingUnits();
      r=new CloudMethodWorker(granted.getDescription(),granted.getNode(),limitOfTasks);
      if (debug) {
        runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
      }
    }
    granted.setWorker(r);
    ResourceManager.addCloudWorker(rcr,r);
  }
 else {
    ResourceManager.increasedCloudWorker(rcr,r,granted.getDescription());
  }
synchronized (count) {
    count--;
  }
}","public void run(){
  boolean check=operations.getCheck();
  runtimeLogger.debug(""String_Node_Str"" + check);
  CloudMethodResourceDescription requested=rcr.getRequested();
  VM granted;
  if (reused == null) {
    this.setName(""String_Node_Str"" + name);
    try {
      granted=createResourceOnProvider(requested);
    }
 catch (    Exception e) {
      runtimeLogger.error(""String_Node_Str"",e);
      notifyFailure();
      return;
    }
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
 else {
    granted=reused;
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + reused.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
  this.setName(""String_Node_Str"" + granted.getName());
  CloudMethodWorker r=ResourceManager.getDynamicResource(granted.getName());
  if (r == null) {
    if (reused == null) {
      try {
        if (debug) {
          runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
        }
        r=prepareNewResource(granted);
        operations.vmReady(granted);
      }
 catch (      Exception e) {
        runtimeLogger.error(""String_Node_Str"",e);
        powerOff(granted);
        notifyFailure();
        return;
      }
    }
 else {
      int limitOfTasks=granted.getDescription().getTotalComputingUnits();
      r=new CloudMethodWorker(granted.getDescription(),granted.getNode(),limitOfTasks,rcr.getRequested().getImage().getSharedDisks());
      try {
        r.start();
      }
 catch (      Exception e) {
        runtimeLogger.error(""String_Node_Str"",e);
        powerOff(granted);
        notifyFailure();
        return;
      }
      if (debug) {
        runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
      }
    }
    granted.setWorker(r);
    ResourceManager.addCloudWorker(rcr,r);
  }
 else {
    ResourceManager.increasedCloudWorker(rcr,r,granted.getDescription());
  }
synchronized (count) {
    count--;
  }
}"
70254,"private CloudMethodWorker prepareNewResource(VM vm) throws Exception {
  CloudMethodResourceDescription granted=vm.getDescription();
  CloudImageDescription cid=granted.getImage();
  HashMap<String,String> workerProperties=cid.getProperties();
  String user=cid.getConfig().getUser();
  String password=workerProperties.get(ITConstants.PASSWORD);
  try {
    operations.configureAccess(granted.getName(),user,password);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  try {
    operations.prepareMachine(granted.getName(),cid);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    throw e;
  }
  CloudMethodWorker worker;
  MethodConfiguration mc=new MethodConfiguration(cid.getConfig());
  try {
    int limitOfTasks=mc.getLimitOfTasks();
    int computingUnits=granted.getTotalComputingUnits();
    if (limitOfTasks < 0 && computingUnits < 0) {
      mc.setLimitOfTasks(0);
    }
 else {
      mc.setLimitOfTasks(Math.max(limitOfTasks,computingUnits));
    }
    worker=new CloudMethodWorker(granted.getName(),granted,mc);
    worker.start(cid.getSharedDisks());
  }
 catch (  Exception e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"",e);
  }
  try {
    worker.announceCreation();
  }
 catch (  Exception e) {
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e2) {
      resourceLogger.error(""String_Node_Str"",e2);
    }
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  if (operations.getTerminate()) {
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    try {
      worker.announceDestruction();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    }
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"");
  }
  for (  java.util.Map.Entry<String,String> disk : cid.getSharedDisks().entrySet()) {
    String diskName=disk.getKey();
    String mounpoint=disk.getValue();
    worker.addSharedDisk(diskName,mounpoint);
  }
  return worker;
}","private CloudMethodWorker prepareNewResource(VM vm) throws Exception {
  CloudMethodResourceDescription granted=vm.getDescription();
  CloudImageDescription cid=granted.getImage();
  HashMap<String,String> workerProperties=cid.getProperties();
  String user=cid.getConfig().getUser();
  String password=workerProperties.get(ITConstants.PASSWORD);
  try {
    operations.configureAccess(granted.getName(),user,password);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  try {
    operations.prepareMachine(granted.getName(),cid);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    throw e;
  }
  CloudMethodWorker worker;
  MethodConfiguration mc=new MethodConfiguration(cid.getConfig());
  try {
    int limitOfTasks=mc.getLimitOfTasks();
    int computingUnits=granted.getTotalComputingUnits();
    if (limitOfTasks < 0 && computingUnits < 0) {
      mc.setLimitOfTasks(0);
    }
 else {
      mc.setLimitOfTasks(Math.max(limitOfTasks,computingUnits));
    }
    worker=new CloudMethodWorker(granted.getName(),granted,mc,cid.getSharedDisks());
    worker.start();
  }
 catch (  Exception e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"",e);
  }
  try {
    worker.announceCreation();
  }
 catch (  Exception e) {
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e2) {
      resourceLogger.error(""String_Node_Str"",e2);
    }
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  if (operations.getTerminate()) {
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    try {
      worker.announceDestruction();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    }
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"");
  }
  return worker;
}"
70255,"/** 
 * Reconfigures the master node adding its shared disks
 * @param sharedDisks Shared Disk descriptions (diskName->mountpoint)
 */
public static void updateMasterConfiguration(HashMap<String,String> sharedDisks){
  for (  java.util.Map.Entry<String,String> disk : sharedDisks.entrySet()) {
    String diskName=disk.getKey();
    String mountPoint=disk.getValue();
    Comm.appHost.addSharedDisk(diskName,mountPoint);
  }
}","/** 
 * Reconfigures the master node adding its shared disks
 * @param sharedDisks Shared Disk descriptions (diskName->mountpoint)
 */
public static void updateMasterConfiguration(HashMap<String,String> sharedDisks){
  Comm.appHost.updateSharedDisk(sharedDisks);
  try {
    Comm.appHost.start();
  }
 catch (  Exception e) {
    ErrorManager.error(""String_Node_Str"",e);
  }
}"
70256,"/** 
 * Initializes a new Method Worker
 * @param name
 * @param rd
 * @param sharedDisks
 * @param mc
 */
public static void newMethodWorker(String name,MethodResourceDescription rd,HashMap<String,String> sharedDisks,MethodConfiguration mc){
  int taskCount;
  int limitOfTasks=mc.getLimitOfTasks();
  int computingUnits=rd.getTotalComputingUnits();
  if (limitOfTasks < 0 && computingUnits < 0) {
    taskCount=0;
  }
 else {
    taskCount=Math.max(limitOfTasks,computingUnits);
  }
  mc.setLimitOfTasks(taskCount);
  MethodWorker newResource=new MethodWorker(name,rd,mc);
  addStaticResource(newResource);
}","/** 
 * Initializes a new Method Worker
 * @param name
 * @param rd
 * @param sharedDisks
 * @param mc
 */
public static void newMethodWorker(String name,MethodResourceDescription rd,HashMap<String,String> sharedDisks,MethodConfiguration mc){
  int taskCount;
  int limitOfTasks=mc.getLimitOfTasks();
  int computingUnits=rd.getTotalComputingUnits();
  if (limitOfTasks < 0 && computingUnits < 0) {
    taskCount=0;
  }
 else {
    taskCount=Math.max(limitOfTasks,computingUnits);
  }
  mc.setLimitOfTasks(taskCount);
  MethodWorker newResource=new MethodWorker(name,rd,mc,sharedDisks);
  addStaticResource(newResource);
}"
70257,"@Override protected void doFailed(){
  String taskName=task.getTaskParams().getName();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Comm.appHost.getJobsDirPath()).append(""String_Node_Str"");
  Iterator<Integer> j=jobs.iterator();
  while (true) {
    sb.append(j.next());
    if (!j.hasNext()) {
      break;
    }
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  ErrorManager.warn(sb.toString());
  task.setStatus(Task.TaskState.FAILED);
  producer.notifyTaskEnd(task);
}","@Override protected void doFailed(){
  String taskName=task.getTaskParams().getName();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Comm.appHost.getJobsDirPath()).append(""String_Node_Str"");
  Iterator<Integer> j=jobs.iterator();
  while (j.hasNext()) {
    sb.append(j.next());
    if (!j.hasNext()) {
      break;
    }
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  ErrorManager.warn(sb.toString());
  task.setStatus(Task.TaskState.FAILED);
  producer.notifyTaskEnd(task);
}"
70258,"private void transferJobData(DependencyParameter param,JobTransfersListener listener){
  Worker<?> w=selectedResource.getResource();
  DataAccessId access=param.getDataAccessId();
  if (access instanceof DataAccessId.WAccessId) {
    String tgtName=((DataAccessId.WAccessId)access).getWrittenDataInstance().getRenaming();
    param.setDataTarget(w.getCompleteRemotePath(param.getType(),tgtName));
    return;
  }
  listener.addOperation();
  if (access instanceof DataAccessId.RAccessId) {
    String srcName=((DataAccessId.RAccessId)access).getReadDataInstance().getRenaming();
    w.getData(srcName,srcName,param,listener);
  }
 else {
    String srcName=((DataAccessId.RWAccessId)access).getReadDataInstance().getRenaming();
    String tgtName=((DataAccessId.RWAccessId)access).getWrittenDataInstance().getRenaming();
    w.getData(srcName,tgtName,(LogicalData)null,param,listener);
  }
}","private void transferJobData(DependencyParameter param,JobTransfersListener listener){
  Worker<?> w=selectedResource.getResource();
  DataAccessId access=param.getDataAccessId();
  if (access instanceof DataAccessId.WAccessId) {
    String tgtName=((DataAccessId.WAccessId)access).getWrittenDataInstance().getRenaming();
    if (debug) {
      jobLogger.debug(""String_Node_Str"" + w.getCompleteRemotePath(param.getType(),tgtName));
    }
    param.setDataTarget(w.getCompleteRemotePath(param.getType(),tgtName));
    return;
  }
  listener.addOperation();
  if (access instanceof DataAccessId.RAccessId) {
    String srcName=((DataAccessId.RAccessId)access).getReadDataInstance().getRenaming();
    w.getData(srcName,srcName,param,listener);
  }
 else {
    String srcName=((DataAccessId.RWAccessId)access).getReadDataInstance().getRenaming();
    String tgtName=((DataAccessId.RWAccessId)access).getWrittenDataInstance().getRenaming();
    w.getData(srcName,tgtName,(LogicalData)null,param,listener);
  }
}"
70259,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,DataOperation.EventListener listener){
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
      if (tgtData != null) {
        tgtData.addLocation(target);
      }
      reason.setDataTarget(target.getPath());
      listener.notifyEnd(null);
      return;
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemove();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.appHost)) {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getTargetLoc().getPath())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + target.getPath() + ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.appHost)) {
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + target.getPath() + ""String_Node_Str"",ex);
          }
        }
 else {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  for (  URI u : ld.getURIs()) {
    if (u.getHost() == Comm.appHost) {
      try {
        if (debug) {
          logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        reason.setDataTarget(target.getPath());
        listener.notifyEnd(null);
        ld.releaseHostRemoveLock();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + target.getPath() + ""String_Node_Str"",ex);
      }
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost()+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoveLock();
        return;
      }
 else {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          Files.copy(new File(source.getPath()).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
          listener.notifyEnd(null);
          ld.releaseHostRemoveLock();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + source.getPath() + ""String_Node_Str""+ target.getPath(),ex);
        }
      }
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        continue;
      }
      logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoveLock();
      return;
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoveLock();
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,DataOperation.EventListener listener){
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
      if (tgtData != null) {
        tgtData.addLocation(target);
      }
      logger.debug(""String_Node_Str"" + target.getPath());
      reason.setDataTarget(target.getPath());
      listener.notifyEnd(null);
      return;
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemove();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.appHost)) {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + target.getPath());
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ target.getPath()+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.appHost)) {
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + target.getPath());
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ target.getPath()+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.appHost+ ""String_Node_Str"");
  }
  for (  URI u : ld.getURIs()) {
    logger.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ u.getHost()+ ""String_Node_Str"");
    if (u.getHost() == Comm.appHost) {
      try {
        if (debug) {
          logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        logger.debug(""String_Node_Str"" + target.getPath());
        reason.setDataTarget(target.getPath());
        listener.notifyEnd(null);
        ld.releaseHostRemoveLock();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ target.getPath()+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost()+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoveLock();
        return;
      }
 else {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          Files.copy(new File(source.getPath()).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
          logger.debug(""String_Node_Str"" + target.getPath());
          reason.setDataTarget(target.getPath());
          listener.notifyEnd(null);
          ld.releaseHostRemoveLock();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + source.getPath() + ""String_Node_Str""+ target.getPath(),ex);
        }
      }
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        continue;
      }
      logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoveLock();
      return;
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoveLock();
}"
70260,"private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
}","private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + copy.getName() + ""String_Node_Str""+ copy.getId()+ ""String_Node_Str"");
  }
}"
70261,"private synchronized void addLocation_private(DataLocation loc){
  isBeingSaved=false;
  locations.add(loc);
switch (loc.getType()) {
case PRIVATE:
    for (    Resource host : loc.getHosts()) {
      if (host == null) {
        host=Comm.appHost;
      }
      boolean done=false;
      HashSet<LogicalData> files=null;
      while (!done) {
        try {
          files=hostToPrivateFiles.get(host);
          if (files == null) {
            files=new HashSet<LogicalData>();
            hostToPrivateFiles.put(host,files);
          }
          done=true;
        }
 catch (        ConcurrentModificationException cme) {
          logger.debug(""String_Node_Str"");
        }
      }
      files.add(this);
    }
  if (loc.getPath().startsWith(File.separator)) {
    onFile=true;
  }
break;
case SHARED:
String shared=loc.getSharedDisk();
boolean done=false;
HashSet<LogicalData> files=null;
while (!done) {
try {
files=sharedDiskToSharedFiles.get(shared);
if (files == null) {
files=new HashSet<LogicalData>();
sharedDiskToSharedFiles.put(shared,files);
}
done=true;
}
 catch (ConcurrentModificationException cme) {
logger.debug(""String_Node_Str"");
}
}
files.add(this);
onFile=true;
break;
}
}","private synchronized void addLocation_private(DataLocation loc){
  isBeingSaved=false;
  locations.add(loc);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + this.getName() + ""String_Node_Str""+ loc.getLocationKey()+ ""String_Node_Str"");
  }
switch (loc.getType()) {
case PRIVATE:
    for (    Resource host : loc.getHosts()) {
      if (host == null) {
        host=Comm.appHost;
      }
      boolean done=false;
      HashSet<LogicalData> files=null;
      while (!done) {
        try {
          files=hostToPrivateFiles.get(host);
          if (files == null) {
            files=new HashSet<LogicalData>();
            hostToPrivateFiles.put(host,files);
          }
          done=true;
        }
 catch (        ConcurrentModificationException cme) {
          logger.debug(""String_Node_Str"");
        }
      }
      files.add(this);
    }
  if (loc.getPath().startsWith(File.separator)) {
    onFile=true;
  }
break;
case SHARED:
String shared=loc.getSharedDisk();
boolean done=false;
HashSet<LogicalData> files=null;
while (!done) {
try {
files=sharedDiskToSharedFiles.get(shared);
if (files == null) {
files=new HashSet<LogicalData>();
sharedDiskToSharedFiles.put(shared,files);
}
done=true;
}
 catch (ConcurrentModificationException cme) {
logger.debug(""String_Node_Str"");
}
}
files.add(this);
onFile=true;
break;
}
}"
70262,"public Copy(LogicalData srcData,DataLocation prefSrc,DataLocation prefTgt,LogicalData tgtData,Transferable reason,EventListener listener){
  super(srcData,listener);
  this.srcData=srcData;
  this.srcLoc=prefSrc;
  this.tgtData=tgtData;
  this.tgtLoc=prefTgt;
  this.reason=reason;
}","public Copy(LogicalData srcData,DataLocation prefSrc,DataLocation prefTgt,LogicalData tgtData,Transferable reason,EventListener listener){
  super(srcData,listener);
  this.srcData=srcData;
  this.srcLoc=prefSrc;
  this.tgtData=tgtData;
  this.tgtLoc=prefTgt;
  this.reason=reason;
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName() + ""String_Node_Str""+ this.getId()+ ""String_Node_Str"");
  }
}"
70263,"public void setFinalTarget(String targetAbsolutePath){
  reason.setDataTarget(targetAbsolutePath);
}","public void setFinalTarget(String targetAbsolutePath){
  if (debug) {
    logger.debug(""String_Node_Str"" + targetAbsolutePath);
  }
  reason.setDataTarget(targetAbsolutePath);
}"
70264,"public void stop(boolean saveUniqueData,ShutdownListener sl){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=LogicalData.getAllDataFromHost(this);
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=DataLocation.getLocation(Comm.appHost,Comm.appHost.getTempDirPath() + ld.getName());
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (tracing) {
      node.generatePackage();
      getTracingPackageToMaster();
      if (debug) {
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
      logger.debug(""String_Node_Str"" + this.getName());
    }
  }
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}","public void stop(ShutdownListener sl){
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}"
70265,"public void copiedData(int transferGroupId){
  LinkedList<Copy> copies=groupToCopy.remove(transferGroupId);
  if (copies == null) {
    return;
  }
  for (  Copy c : copies) {
    if (!c.isRegistered()) {
      continue;
    }
    DataLocation actualLocation=c.getSourceData().finishedCopy(c);
    LogicalData tgtData=c.getTargetData();
    if (tgtData != null) {
      tgtData.addLocation(actualLocation);
    }
  }
}","public void copiedData(int transferGroupId){
  logger.debug(""String_Node_Str"");
  LinkedList<Copy> copies=groupToCopy.remove(transferGroupId);
  if (copies == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  for (  Copy c : copies) {
    logger.debug(""String_Node_Str"" + c.getName());
    if (!c.isRegistered()) {
      logger.debug(""String_Node_Str"" + c.getName());
      continue;
    }
    DataLocation actualLocation=c.getSourceData().finishedCopy(c);
    if (actualLocation != null) {
      logger.debug(""String_Node_Str"" + actualLocation.getPath());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    LogicalData tgtData=c.getTargetData();
    if (tgtData != null) {
      logger.debug(""String_Node_Str"");
      if (actualLocation.getType().equals(DataLocation.Type.PRIVATE)) {
        logger.debug(""String_Node_Str"" + actualLocation.getPath() + ""String_Node_Str""+ tgtData.getName());
        tgtData.addLocation(actualLocation);
      }
 else {
        logger.debug(""String_Node_Str"" + tgtData.getName());
      }
      logger.debug(""String_Node_Str"" + tgtData.getName() + ""String_Node_Str""+ tgtData.getURIs());
    }
 else {
      logger.warn(""String_Node_Str"" + c.getName());
    }
  }
}"
70266,"public long getMonitorInterval(){
  return config.getLong(ITConstants.IT_MONITOR);
}","public long getMonitorInterval(){
  return config.getLong(ITConstants.IT_MONITOR,ITConstants.DEFAULT_MONITOR_INTERVAL);
}"
70267,"public String getDeploymentId(){
  return config.getString(ITConstants.IT_DEPLOYMENT_ID);
}","public String getDeploymentId(){
  return config.getString(ITConstants.IT_DEPLOYMENT_ID,ITConstants.DEFAULT_DEPLOYMENT_ID);
}"
70268,"public void stop(boolean saveUniqueData,ShutdownListener sl){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=LogicalData.getAllDataFromHost(this);
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=DataLocation.getLocation(Comm.appHost,Comm.appHost.getTempDirPath() + ld.getName());
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (this.getType() != Type.SERVICE) {
    if (tracing) {
      node.generatePackage();
      getTracingPackageToMaster();
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
    }
  }
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}","public void stop(boolean saveUniqueData,ShutdownListener sl){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=LogicalData.getAllDataFromHost(this);
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=DataLocation.getLocation(Comm.appHost,Comm.appHost.getTempDirPath() + ld.getName());
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (tracing) {
      node.generatePackage();
      getTracingPackageToMaster();
      if (debug) {
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
      logger.debug(""String_Node_Str"" + this.getName());
    }
  }
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}"
70269,"public void receivedShutdown(Connection requester,LinkedList<Data> filesToSend){
  closingConnection=requester;
  finish=true;
  if (!hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}","public void receivedShutdown(Connection requester,LinkedList<Data> filesToSend){
  logger.debug(""String_Node_Str"");
  closingConnection=requester;
  finish=true;
  if (!hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}"
70270,"@Override public void generateWorkersDebugInfo(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles(this.getHost(),this.getInstallDir(),this.getWorkingDir(),this.getName());
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  logger.debug(""String_Node_Str"");
}","@Override public void generateWorkersDebugInfo(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles(this.getHost(),this.getInstallDir(),this.getWorkingDir(),this.getName());
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  commManager.waitUntilWorkersDebugInfoGenerated();
  logger.debug(""String_Node_Str"");
}"
70271,"@Override public void stop(ShutdownListener sl){
  logger.info(""String_Node_Str"" + this.getName());
  if (node == null) {
    sl.notifyFailure(new Exception());
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  commManager.shuttingDown(this,c,sl);
  CommandShutdown cmd=new CommandShutdown(null,null);
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
}","@Override public void stop(ShutdownListener sl){
  logger.debug(""String_Node_Str"" + this.getName());
  if (node == null) {
    sl.notifyFailure(new Exception());
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  commManager.shuttingDown(this,c,sl);
  CommandShutdown cmd=new CommandShutdown(null,null);
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
}"
70272,"public void processRequests(){
  while (true) {
    Job<?> job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      job.submit();
      if (debug) {
        logger.debug(""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      logger.error(SUBMISSION_ERROR + job.getJobId(),ex);
      job.getListener().jobFailed(job,Job.JobListener.JobEndStatus.SUBMISSION_FAILED);
    }
  }
}","public void processRequests(){
  while (true) {
    Job<?> job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      job.submit();
      if (debug) {
        logger.debug(""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      logger.error(SUBMISSION_ERROR + job.getJobId(),ex);
      job.getListener().jobFailed(job,Job.JobListener.JobEndStatus.SUBMISSION_FAILED);
    }
  }
  logger.debug(""String_Node_Str"");
}"
70273,"private static String[] getStartCommand(NIOWorkerNode node,int workerPort){
  String libPath=node.getLibPath();
  String appDir=node.getAppDir();
  String[] jvmFlags=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String workingDir=node.getWorkingDir();
  String cp=(System.getProperty(ITConstants.IT_WORKER_CP) != null && System.getProperty(ITConstants.IT_WORKER_CP).compareTo(""String_Node_Str"") != 0) ? System.getProperty(ITConstants.IT_WORKER_CP) : ""String_Node_Str"";
  String installDir=node.getInstallDir();
  String workerDebug=Boolean.toString(Logger.getLogger(Loggers.WORKER).isDebugEnabled());
  String storageConf=System.getProperty(ITConstants.IT_STORAGE_CONF);
  if ((storageConf == null) || (storageConf.compareTo(""String_Node_Str"") == 0) || (storageConf.compareTo(""String_Node_Str"") == 0)) {
    storageConf=""String_Node_Str"";
    logger.warn(""String_Node_Str"");
  }
  String executionType=System.getProperty(ITConstants.IT_TASK_EXECUTION);
  String[] cmd=new String[19 + jvmFlags.length];
  cmd[0]=installDir + (installDir.endsWith(File.separator) ? ""String_Node_Str"" : File.separator) + STARTER_SCRIPT_PATH+ STARTER_SCRIPT_NAME;
  cmd[1]=libPath.isEmpty() ? ""String_Node_Str"" : libPath;
  cmd[2]=appDir.isEmpty() ? ""String_Node_Str"" : appDir;
  cmd[3]=cp.isEmpty() ? ""String_Node_Str"" : cp;
  cmd[4]=String.valueOf(jvmFlags.length);
  for (int i=0; i < jvmFlags.length; ++i) {
    cmd[5 + i]=jvmFlags[i];
  }
  int nextPosition=5 + jvmFlags.length;
  cmd[nextPosition++]=workerDebug;
  cmd[nextPosition++]=(node.getLimitOfTasks() >= 0) ? String.valueOf(node.getLimitOfTasks()) : String.valueOf(NUM_THREADS);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_SEND_WORKER);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_RECEIVE_WORKER);
  cmd[nextPosition++]=node.getName();
  cmd[nextPosition++]=String.valueOf(workerPort);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MASTER_PORT);
  cmd[nextPosition++]=DEPLOYMENT_ID;
  cmd[nextPosition++]=workingDir;
  cmd[nextPosition++]=node.getInstallDir();
  cmd[nextPosition++]=String.valueOf(tracing_level);
  if (tracing) {
    Integer hostId=NIOTracer.registerHost(node.getName(),NUM_THREADS);
    cmd[nextPosition++]=String.valueOf(hostId.toString());
  }
 else {
    cmd[nextPosition++]=""String_Node_Str"";
  }
  cmd[nextPosition++]=storageConf;
  cmd[nextPosition++]=executionType;
  return cmd;
}","private static String[] getStartCommand(NIOWorkerNode node,int workerPort){
  String libPath=node.getLibPath();
  String appDir=node.getAppDir();
  String workerJVMflags=(System.getProperty(ITConstants.IT_WORKER_JVM_OPTS) != null) ? System.getProperty(ITConstants.IT_WORKER_JVM_OPTS) : ""String_Node_Str"";
  String[] jvmFlags=workerJVMflags.split(""String_Node_Str"");
  String workingDir=node.getWorkingDir();
  String cp=(System.getProperty(ITConstants.IT_WORKER_CP) != null && System.getProperty(ITConstants.IT_WORKER_CP).compareTo(""String_Node_Str"") != 0) ? System.getProperty(ITConstants.IT_WORKER_CP) : ""String_Node_Str"";
  String installDir=node.getInstallDir();
  String workerDebug=Boolean.toString(Logger.getLogger(Loggers.WORKER).isDebugEnabled());
  String storageConf=System.getProperty(ITConstants.IT_STORAGE_CONF);
  if ((storageConf == null) || (storageConf.compareTo(""String_Node_Str"") == 0) || (storageConf.compareTo(""String_Node_Str"") == 0)) {
    storageConf=""String_Node_Str"";
    logger.warn(""String_Node_Str"");
  }
  String executionType=System.getProperty(ITConstants.IT_TASK_EXECUTION);
  String[] cmd=new String[19 + jvmFlags.length];
  cmd[0]=installDir + (installDir.endsWith(File.separator) ? ""String_Node_Str"" : File.separator) + STARTER_SCRIPT_PATH+ STARTER_SCRIPT_NAME;
  cmd[1]=libPath.isEmpty() ? ""String_Node_Str"" : libPath;
  cmd[2]=appDir.isEmpty() ? ""String_Node_Str"" : appDir;
  cmd[3]=cp.isEmpty() ? ""String_Node_Str"" : cp;
  cmd[4]=String.valueOf(jvmFlags.length);
  for (int i=0; i < jvmFlags.length; ++i) {
    cmd[5 + i]=jvmFlags[i];
  }
  int nextPosition=5 + jvmFlags.length;
  cmd[nextPosition++]=workerDebug;
  cmd[nextPosition++]=(node.getLimitOfTasks() >= 0) ? String.valueOf(node.getLimitOfTasks()) : String.valueOf(NUM_THREADS);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_SEND_WORKER);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_RECEIVE_WORKER);
  cmd[nextPosition++]=node.getName();
  cmd[nextPosition++]=String.valueOf(workerPort);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MASTER_PORT);
  cmd[nextPosition++]=DEPLOYMENT_ID;
  cmd[nextPosition++]=workingDir;
  cmd[nextPosition++]=node.getInstallDir();
  cmd[nextPosition++]=String.valueOf(tracing_level);
  if (tracing) {
    Integer hostId=NIOTracer.registerHost(node.getName(),NUM_THREADS);
    cmd[nextPosition++]=String.valueOf(hostId.toString());
  }
 else {
    cmd[nextPosition++]=""String_Node_Str"";
  }
  cmd[nextPosition++]=storageConf;
  cmd[nextPosition++]=executionType;
  return cmd;
}"
70274,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob(taskId,taskParams,impl,res,listener);
}","@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob<COMPSsWorker>(taskId,taskParams,impl,res,listener);
}"
70275,"public static void init() throws Exception {
  if (callerQueue == null) {
    callerQueue=new RequestQueue<WSJob>();
  }
 else {
    callerQueue.clear();
  }
  caller=new WSCaller(callerQueue);
  callerPool=new ThreadPool(POOL_SIZE,POOL_NAME,caller);
  try {
    callerPool.startThreads();
  }
 catch (  Exception e) {
    logger.error(THREAD_POOL_ERR,e);
    throw e;
  }
}","public static void init() throws Exception {
  if (callerQueue == null) {
    callerQueue=new RequestQueue<WSJob<?>>();
  }
 else {
    callerQueue.clear();
  }
  caller=new WSCaller(callerQueue);
  callerPool=new ThreadPool(POOL_SIZE,POOL_NAME,caller);
  try {
    callerPool.startThreads();
  }
 catch (  Exception e) {
    logger.error(THREAD_POOL_ERR,e);
    throw e;
  }
}"
70276,"public WSCaller(RequestQueue<WSJob> queue){
  super(queue);
}","public WSCaller(RequestQueue<WSJob<?>> queue){
  super(queue);
}"
70277,"public void processRequests(){
  while (true) {
    WSJob job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskParams taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == ParamDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case SCO_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}","public void processRequests(){
  while (true) {
    WSJob<?> job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskParams taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == ParamDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case SCO_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}"
70278,"@Override public void reduceDynamic(ResourceDescription rd){
}","@Override public ResourceDescription reduceDynamic(ResourceDescription rd){
  return null;
}"
70279,"private static void testImmutableObjects(){
  Integer i=ObjectTestImpl.createInteger(5);
  String s=ObjectTestImpl.createString(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + i);
  System.out.println(""String_Node_Str"" + s);
  ObjectTestImpl.printObjects(i,s);
}","private static void testImmutableObjects(){
  Integer i=ObjectTestImpl.createInteger(5);
  String s=ObjectTestImpl.createString(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + i);
  System.out.println(""String_Node_Str"" + s);
  ObjectTestImpl.printContent(i,s);
}"
70280,"public static void printObjects(Integer i,String s){
  System.out.println(""String_Node_Str"" + i);
  System.out.println(""String_Node_Str"" + s);
}","public static void printObjects(A a,B b){
  System.out.println(""String_Node_Str"" + a.getIntField());
  System.out.println(""String_Node_Str"" + b.getStringField());
}"
70281,"@Method(declaringClass=""String_Node_Str"") void printObjects(@Parameter(type=Type.OBJECT,direction=Direction.IN) Integer i,@Parameter(type=Type.OBJECT,direction=Direction.IN) String s);","@Method(declaringClass=""String_Node_Str"") void printObjects(@Parameter(type=Type.OBJECT,direction=Direction.IN) A a,@Parameter(type=Type.OBJECT,direction=Direction.IN) B b);"
70282,"/** 
 * Received Data
 * @param c
 * @param t
 */
public void receivedData(Connection c,Transfer t){
  String dataId=ongoingTransfers.remove(c);
  if (dataId == null) {
    return;
  }
  if (DEBUG) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId);
  }
  releaseReceiveSlot();
  List<DataRequest> requests=dataToRequests.remove(dataId);
  boolean isBindingType=requests.get(0).getType().equals(DataType.BINDING_OBJECT_T);
  Map<String,List<DataRequest>> byTarget=new HashMap<>();
  for (  DataRequest req : requests) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + req.getTarget()+ ""String_Node_Str""+ dataId+ ""String_Node_Str"");
    List<DataRequest> sameTarget=byTarget.get(req.getTarget());
    if (sameTarget == null) {
      sameTarget=new LinkedList<DataRequest>();
      byTarget.put(req.getTarget(),sameTarget);
    }
    sameTarget.add(req);
  }
  if (NIOTracer.isActivated()) {
    int tag=abs(dataId.hashCode());
    NIOTracer.emitDataTransferEvent(dataId);
    NIOTracer.emitCommEvent(false,connection2Partner.get(c),tag,t.getSize());
    connection2Partner.remove(c);
  }
  if (byTarget.size() == 1) {
    String targetName=requests.get(0).getTarget();
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
    }
    if (t.isFile() || t.isObject()) {
      if (!isPersistentEnabled() && isBindingType) {
        receivedBindingObjectAsFile(t.getFileName(),targetName);
      }
      receivedValue(t.getDestination(),targetName,t.getObject(),requests);
    }
 else     if (t.isByteBuffer()) {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
 else {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
  }
 else {
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
    }
    if (t.isFile()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ t.getFileName());
      }
      List<DataRequest> reqs;
      if (!isPersistentEnabled() && isBindingType) {
        BindingObject bo=getTargetBindingObject(t.getFileName(),requests.get(0).getTarget());
        reqs=byTarget.remove(bo.toString());
        receivedBindingObjectAsFile(t.getFileName(),reqs.get(0).getTarget());
      }
 else {
        reqs=byTarget.remove(t.getFileName());
      }
      receivedValue(t.getDestination(),t.getFileName(),t.getObject(),reqs);
    }
 else     if (t.isObject()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      receivedValue(t.getDestination(),dataId,t.getObject(),byTarget.remove(dataId));
    }
 else     if (t.isByteBuffer()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      BindingObject bo=getTargetBindingObject(dataId,requests.get(0).getSource().getFirstURI().getPath());
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(dataId));
    }
 else {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      BindingObject bo=getTargetBindingObject(dataId,requests.get(0).getSource().getFirstURI().getPath());
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(dataId));
    }
    for (    Entry<String,List<DataRequest>> entry : byTarget.entrySet()) {
      String targetName=entry.getKey();
      List<DataRequest> reqs=entry.getValue();
      try {
        if (DEBUG) {
          LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
        }
        if (t.isFile()) {
          if (!isPersistentEnabled() && reqs.get(0).getType().equals(DataType.BINDING_OBJECT_T)) {
            receivedBindingObjectAsFile(t.getFileName(),targetName);
          }
 else {
            Files.copy((new File(t.getFileName())).toPath(),(new File(targetName)).toPath());
          }
          receivedValue(t.getDestination(),targetName,t.getObject(),byTarget.remove(targetName));
        }
 else         if (t.isObject()) {
          Object o=Serializer.deserialize(t.getArray());
          receivedValue(t.getDestination(),targetName,o,reqs);
        }
 else {
          BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
          NIOBindingDataManager.copyCachedData(dataId,targetName);
          receivedValue(t.getDestination(),targetName,bo.toString(),byTarget.remove(targetName));
        }
      }
 catch (      IOException|ClassNotFoundException e) {
        LOGGER.warn(""String_Node_Str"",e);
      }
    }
  }
  requestTransfers();
  if (finish == true && !hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}","/** 
 * Received Data
 * @param c
 * @param t
 */
public void receivedData(Connection c,Transfer t){
  String dataId=ongoingTransfers.remove(c);
  if (dataId == null) {
    return;
  }
  if (DEBUG) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId);
  }
  releaseReceiveSlot();
  List<DataRequest> requests=dataToRequests.remove(dataId);
  boolean isBindingType=requests.get(0).getType().equals(DataType.BINDING_OBJECT_T);
  Map<String,List<DataRequest>> byTarget=new HashMap<>();
  for (  DataRequest req : requests) {
    LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + req.getTarget()+ ""String_Node_Str""+ dataId+ ""String_Node_Str"");
    List<DataRequest> sameTarget=byTarget.get(req.getTarget());
    if (sameTarget == null) {
      sameTarget=new LinkedList<DataRequest>();
      byTarget.put(req.getTarget(),sameTarget);
    }
    sameTarget.add(req);
  }
  if (NIOTracer.isActivated()) {
    int tag=abs(dataId.hashCode());
    NIOTracer.emitDataTransferEvent(dataId);
    NIOTracer.emitCommEvent(false,connection2Partner.get(c),tag,t.getSize());
    connection2Partner.remove(c);
  }
  if (byTarget.size() == 1) {
    String targetName=requests.get(0).getTarget();
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
    }
    if (t.isFile() || t.isObject()) {
      if (!isPersistentEnabled() && isBindingType) {
        receivedBindingObjectAsFile(t.getFileName(),targetName);
      }
      receivedValue(t.getDestination(),targetName,t.getObject(),requests);
    }
 else     if (t.isByteBuffer()) {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
 else {
      BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getSource().getFirstURI().getPath());
      receivedValue(t.getDestination(),targetName,bo.toString(),requests);
    }
  }
 else {
    String workingDir=getWorkingDir();
    if (!workingDir.endsWith(File.separator)) {
      workingDir=workingDir + File.separator;
    }
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
    }
    if (t.isFile()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ t.getFileName());
      }
      List<DataRequest> reqs;
      if (!isPersistentEnabled() && isBindingType) {
        BindingObject bo=getTargetBindingObject(t.getFileName(),requests.get(0).getTarget());
        reqs=byTarget.remove(bo.toString());
        receivedBindingObjectAsFile(t.getFileName(),reqs.get(0).getTarget());
      }
 else {
        reqs=byTarget.remove(t.getFileName());
      }
      receivedValue(t.getDestination(),t.getFileName(),t.getObject(),reqs);
    }
 else     if (t.isObject()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ dataId);
      }
      receivedValue(t.getDestination(),dataId,t.getObject(),byTarget.remove(dataId));
    }
 else     if (t.isByteBuffer()) {
      BindingObject bo=getTargetBindingObject(workingDir + dataId,requests.get(0).getTarget());
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ bo.toString()+ ""String_Node_Str""+ dataId);
      }
      NIOBindingDataManager.setByteArray(bo.getName(),t.getByteBuffer(),bo.getType(),bo.getElements());
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(bo.toString()));
    }
 else {
      BindingObject bo=getTargetBindingObject(workingDir + dataId,requests.get(0).getTarget());
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ bo.toString()+ ""String_Node_Str""+ dataId);
      }
      receivedValue(t.getDestination(),dataId,bo.toString(),byTarget.remove(bo.toString()));
    }
    for (    Entry<String,List<DataRequest>> entry : byTarget.entrySet()) {
      String targetName=entry.getKey();
      List<DataRequest> reqs=entry.getValue();
      try {
        if (DEBUG) {
          LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + dataId+ ""String_Node_Str""+ targetName);
        }
        if (t.isFile()) {
          if (!isPersistentEnabled() && isBindingType) {
            BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getTarget());
            receivedBindingObjectAsFile(t.getFileName(),targetName);
            receivedValue(t.getDestination(),bo.getName(),bo.toString(),byTarget.remove(targetName));
          }
 else {
            Files.copy((new File(t.getFileName())).toPath(),(new File(targetName)).toPath());
            receivedValue(t.getDestination(),targetName,t.getObject(),byTarget.remove(targetName));
          }
        }
 else         if (t.isObject()) {
          Object o=Serializer.deserialize(t.getArray());
          receivedValue(t.getDestination(),targetName,o,reqs);
        }
 else {
          BindingObject bo=getTargetBindingObject(targetName,requests.get(0).getTarget());
          NIOBindingDataManager.copyCachedData(dataId,bo.getName());
          receivedValue(t.getDestination(),bo.getName(),bo.toString(),byTarget.remove(targetName));
        }
      }
 catch (      IOException|ClassNotFoundException e) {
        LOGGER.warn(""String_Node_Str"",e);
      }
    }
  }
  requestTransfers();
  if (finish == true && !hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}"
70283,"/** 
 * Adds a new task summary request
 * @param logger
 */
public void getTaskSummary(Logger logger){
  Semaphore sem=new Semaphore(0);
  TaskSummaryRequest request=new TaskSummaryRequest(LOGGER,sem);
  addRequest(request);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}","/** 
 * Adds a new task summary request
 * @param logger
 */
public void getTaskSummary(Logger logger){
  Semaphore sem=new Semaphore(0);
  TaskSummaryRequest request=new TaskSummaryRequest(logger,sem);
  addRequest(request);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
}"
70284,"@Override public void process(TaskScheduler ts) throws ShutdownException {
  ts.getTaskSummary(logger);
  sem.release();
}","@Override public void process(TaskScheduler ts) throws ShutdownException {
  ts.getTaskSummary(this.logger);
  this.sem.release();
}"
70285,"public void obtainBindingData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  BindingObject tgtBO=((BindingObjectLocation)target).getBindingObject();
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + bo.getName());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ tgtBO.getName());
      }
      BindingObject bo=BindingObject.generate(u.getPath());
      if (ld.getName().equals(tgtBO.getName())) {
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
 else {
        LOGGER.debug(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ tgtBO.getName());
        BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
      listener.notifyEnd(null);
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ tgtBO.getName());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + tgtBO.getName(),e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        BindingObject bo=BindingObject.generate(sourcePath);
        if (ld.getName().equals(tgtBO.getName())) {
          LOGGER.debug(""String_Node_Str"" + bo.getName());
          reason.setDataTarget(sourcePath);
        }
 else {
          LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
          BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
          if (tgtData != null) {
            tgtData.addLocation(target);
          }
          LOGGER.debug(""String_Node_Str"" + tgtBO.getName());
          reason.setDataTarget(sourcePath);
        }
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ tgtBO.getName());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
}","public void obtainBindingData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  BindingObject tgtBO=((BindingObjectLocation)target).getBindingObject();
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          Copy.waitForCopyTofinish(copy,this);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          Copy.waitForCopyTofinish(copy,this);
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ tgtBO.getName());
          }
          BindingObject bo=BindingObject.generate(copy.getFinalTarget());
          if (ld.getName().equals(tgtBO.getName())) {
            LOGGER.debug(""String_Node_Str"" + bo.getName());
            reason.setDataTarget(copy.getFinalTarget());
          }
 else {
            LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
            BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + copy.getFinalTarget());
            reason.setDataTarget(copy.getFinalTarget());
          }
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ tgtBO.getName());
      }
      BindingObject bo=BindingObject.generate(u.getPath());
      if (ld.getName().equals(tgtBO.getName())) {
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
 else {
        LOGGER.debug(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ tgtBO.getName());
        BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + u.getPath());
        reason.setDataTarget(u.getPath());
      }
      listener.notifyEnd(null);
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ tgtBO.getName());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + tgtBO.getName(),e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        BindingObject bo=BindingObject.generate(sourcePath);
        if (ld.getName().equals(tgtBO.getName())) {
          LOGGER.debug(""String_Node_Str"" + bo.getName());
          reason.setDataTarget(sourcePath);
        }
 else {
          LOGGER.debug(""String_Node_Str"" + bo.getName() + ""String_Node_Str""+ tgtBO.getName());
          BindingDataManager.copyCachedData(bo.getName(),tgtBO.getName());
          if (tgtData != null) {
            tgtData.addLocation(target);
          }
          LOGGER.debug(""String_Node_Str"" + tgtBO.getName());
          reason.setDataTarget(sourcePath);
        }
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ tgtBO.getName());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
}"
70286,"public void obtainFileData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      try {
        if (DEBUG) {
          LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ targetPath);
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + targetPath,e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          LOGGER.debug(""String_Node_Str"" + targetPath);
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ targetPath);
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ targetPath);
  ld.releaseHostRemoval();
}","public void obtainFileData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          Copy.waitForCopyTofinish(copy,this);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          Copy.waitForCopyTofinish(copy,this);
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      try {
        if (DEBUG) {
          LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ targetPath);
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      String sourcePath=source.getURIInHost(sourceRes).getPath();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + targetPath,e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          LOGGER.debug(""String_Node_Str"" + targetPath);
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ targetPath);
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ targetPath);
  ld.releaseHostRemoval();
}"
70287,"private void sendFile(Connection c,String path,Data d){
  if (path.startsWith(File.separator)) {
    File f=new File(path);
    if (f.exists()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ path+ ""String_Node_Str""+ d.getName());
      }
      c.sendDataFile(path);
    }
 else {
      ErrorManager.warn(""String_Node_Str"" + path + ""String_Node_Str""+ c.hashCode()+ ""String_Node_Str"");
      handleDataToSendNotAvailable(c,d);
    }
  }
 else {
    sendObject(c,path,d);
  }
}","private void sendFile(Connection c,String path,Data d){
  if (path.startsWith(File.separator)) {
    File f=new File(path);
    if (f.exists()) {
      if (DEBUG) {
        LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ path+ ""String_Node_Str""+ d.getName());
      }
      c.sendDataFile(path);
    }
 else {
      if (!f.getName().equals(d.getName())) {
        File renamed;
        if (isMaster()) {
          renamed=new File(Comm.getAppHost().getCompleteRemotePath(DataType.FILE_T,d.getName()).getPath());
        }
 else {
          renamed=new File(f.getParentFile().getAbsolutePath() + File.separator + d.getName());
        }
        if (renamed.exists()) {
          if (DEBUG) {
            LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ renamed.getAbsolutePath()+ ""String_Node_Str""+ d.getName());
          }
          c.sendDataFile(renamed.getAbsolutePath());
        }
 else {
          ErrorManager.warn(""String_Node_Str"" + path + ""String_Node_Str""+ renamed.getAbsolutePath()+ ""String_Node_Str""+ c.hashCode()+ ""String_Node_Str"");
          handleDataToSendNotAvailable(c,d);
        }
      }
 else {
        ErrorManager.warn(""String_Node_Str"" + path + ""String_Node_Str""+ c.hashCode()+ ""String_Node_Str"");
        handleDataToSendNotAvailable(c,d);
      }
    }
  }
 else {
    if (DEBUG) {
      LOGGER.debug(DBG_PREFIX + ""String_Node_Str"" + c.hashCode()+ ""String_Node_Str""+ d.getName());
    }
    sendObject(c,path,d);
  }
}"
70288,"/** 
 * Marks a location for deletion
 * @param loc
 */
public void markForDeletion(DataLocation loc){
  if (!requestQueue.offer(new DeleteFileRequest(loc))) {
    ErrorManager.error(ERROR_QUEUE_OFFER + ""String_Node_Str"");
  }
}","/** 
 * Marks a location for deletion
 * @param loc
 */
public void markForDeletion(DataLocation loc){
  LOGGER.debug(""String_Node_Str"" + loc + ""String_Node_Str"");
  Semaphore sem=new Semaphore(0);
  if (!requestQueue.offer(new DeleteFileRequest(loc,sem))) {
    ErrorManager.error(ERROR_QUEUE_OFFER + ""String_Node_Str"");
  }
  sem.acquireUninterruptibly();
  LOGGER.debug(""String_Node_Str"" + loc + ""String_Node_Str"");
}"
70289,"/** 
 * Tries to schedule the current action
 * @throws InvalidSchedulingException
 */
public final void tryToLaunch() throws InvalidSchedulingException {
  lock.lock();
  if (selectedResource != null && state == State.RUNNABLE && !hasDataPredecessors() && schedulingInfo.isExecutable()) {
    if (selectedResource.isRemoved() || (isSchedulingConstrained() && unrequiredResource() || isTargetResourceEnforced() && selectedResource != schedulingInfo.getEnforcedTargetResource())) {
      lock.unlock();
      throw new InvalidSchedulingException();
    }
    execute();
  }
 else {
    lock.unlock();
  }
}","/** 
 * Tries to schedule the current action
 * @throws InvalidSchedulingException
 */
public final void tryToLaunch() throws InvalidSchedulingException {
  lock.lock();
  if (selectedResource != null && state == State.RUNNABLE && !hasDataPredecessors() && schedulingInfo.isExecutable()) {
    if ((selectedResource.isRemoved() && !isToStopResource()) || (isSchedulingConstrained() && unrequiredResource() || isTargetResourceEnforced() && selectedResource != schedulingInfo.getEnforcedTargetResource())) {
      lock.unlock();
      throw new InvalidSchedulingException();
    }
    execute();
  }
 else {
    lock.unlock();
  }
}"
70290,"public boolean isTaskFile(String fileName){
  if (fileName == null) {
    File f=new File(fileName);
    if (taskFiles.contains(f.getAbsolutePath())) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","public boolean isTaskFile(String fileName){
  if (fileName != null) {
    File f=new File(fileName);
    if (taskFiles.contains(f.getAbsolutePath())) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
70291,"public FileInputStream newFileInputStream(FileDescriptor fd){
  StreamList list=obtainList(fd);
  FileInputStream fis=new FileInputStream(fd);
  if (list != null)   list.addStream(fis);
  return fis;
}","public FileInputStream newFileInputStream(FileDescriptor fd){
  StreamList list=obtainList(fd);
  FileInputStream fis=new FileInputStream(fd);
  if (list != null) {
    list.addStream(fis);
  }
  return fis;
}"
70292,"public boolean isTaskFile(String fileName){
  File f=new File(fileName);
  if (taskFiles.contains(f.getAbsolutePath())) {
    return true;
  }
 else {
    return false;
  }
}","public boolean isTaskFile(String fileName){
  if (fileName == null) {
    File f=new File(fileName);
    if (taskFiles.contains(f.getAbsolutePath())) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
70293,"/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,StreamSTD streamValues,File taskSandboxWorkingDir) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    process.getOutputStream().close();
    logBinaryExecution(process,exitValue,fileOutPath,fileErrPath);
    exitValue=process.waitFor();
  }
 catch (  Exception e) {
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
  return exitValue;
}","/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,StreamSTD streamValues,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    process.getOutputStream().close();
    logBinaryExecution(process,fileOutPath,fileErrPath,defaultOutStream,defaultErrStream);
    exitValue=process.waitFor();
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + exitValue);
    System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    System.err.println(ERROR_PROC_EXEC);
    e.printStackTrace();
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
  return exitValue;
}"
70294,"private static void logBinaryExecution(Process process,int exitValue,String fileOutPath,String fileErrPath) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + exitValue);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    StreamGobbler outputGobbler=new StreamGobbler(process.getInputStream(),System.out,LogManager.getLogger(Loggers.WORKER));
    outputGobbler.start();
  }
  System.out.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    StreamGobbler errorGobbler=new StreamGobbler(process.getErrorStream(),System.err,LogManager.getLogger(Loggers.WORKER));
    errorGobbler.start();
  }
  System.err.println(""String_Node_Str"");
}","private static void logBinaryExecution(Process process,String fileOutPath,String fileErrPath,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  StreamGobbler errorGobbler=null;
  StreamGobbler outputGobbler=null;
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    if (fileOutPath == null) {
      outputGobbler=new StreamGobbler(process.getInputStream(),defaultOutStream,LogManager.getLogger(Loggers.WORKER));
      outputGobbler.start();
    }
 else {
      try (FileInputStream outputStream=new FileInputStream(fileOutPath)){
        outputGobbler=new StreamGobbler(outputStream,defaultOutStream,LogManager.getLogger(Loggers.WORKER));
        outputGobbler.start();
      }
 catch (      IOException ioe) {
        System.err.println(ERROR_OUTPUTREADER);
        ioe.printStackTrace();
        throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
      }
    }
  }
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    if (fileErrPath == null) {
      errorGobbler=new StreamGobbler(process.getErrorStream(),defaultErrStream,LogManager.getLogger(Loggers.WORKER));
      errorGobbler.start();
    }
 else {
      try (FileInputStream errStream=new FileInputStream(fileErrPath)){
        errorGobbler=new StreamGobbler(errStream,defaultErrStream,LogManager.getLogger(Loggers.WORKER));
        errorGobbler.start();
      }
 catch (      IOException ioe) {
        throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
      }
    }
  }
  if (outputGobbler != null) {
    try {
      outputGobbler.join();
    }
 catch (    InterruptedException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  System.out.println(""String_Node_Str"");
  if (errorGobbler != null) {
    try {
      errorGobbler.join();
    }
 catch (    InterruptedException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
    }
  }
  System.err.println(""String_Node_Str"");
}"
70295,"/** 
 * Invokes an MPI method
 * @param mpiRunner
 * @param mpiBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numProcs;
  cmd[5]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes an MPI method
 * @param mpiRunner
 * @param mpiBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numProcs;
  cmd[5]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70296,"/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  String[] cmd;
  if (args.isEmpty()) {
    cmd=new String[NUM_BASE_DECAF_ARGS - 2];
  }
 else {
    cmd=new String[NUM_BASE_DECAF_ARGS];
  }
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  if (!args.isEmpty()) {
    cmd[9]=""String_Node_Str"";
    cmd[10]=args;
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  String[] cmd;
  if (args.isEmpty()) {
    cmd=new String[NUM_BASE_DECAF_ARGS - 2];
  }
 else {
    cmd=new String[NUM_BASE_DECAF_ARGS];
  }
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  if (!args.isEmpty()) {
    cmd[9]=""String_Node_Str"";
    cmd[10]=args;
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70297,"/** 
 * Invokes an OmpSs method
 * @param ompssBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes an OmpSs method
 * @param ompssBinary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70298,"/** 
 * Invokes a binary method
 * @param binary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeBinaryMethod(String binary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes a binary method
 * @param binary
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeBinaryMethod(String binary,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir,PrintStream defaultOutStream,PrintStream defaultErrStream) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir,defaultOutStream,defaultErrStream);
}"
70299,"public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeMPIMethod(mpiRunner,mpiBinary,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeMPIMethod(mpiRunner,mpiBinary,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70300,"public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeDecafMethod(dfRunner,dfScript,dfExecutor,dfLib,mpiRunner,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeDecafMethod(dfRunner,dfScript,dfExecutor,dfLib,mpiRunner,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70301,"public static Object invokeOmpSsMethod(String ompssBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeOmpSsMethod(ompssBinary,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeOmpSsMethod(String ompssBinary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeOmpSsMethod(ompssBinary,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70302,"public static Object invokeBinaryMethod(String binary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeBinaryMethod(binary,values,streams,prefixes,taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}","public static Object invokeBinaryMethod(String binary,Object target,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir){
  Object retValue=null;
  try {
    retValue=GenericInvoker.invokeBinaryMethod(binary,values,streams,prefixes,taskSandboxWorkingDir,System.out,System.err);
  }
 catch (  InvokeExecutionException iee) {
    ErrorManager.error(ERROR_INVOKE,iee);
  }
  return retValue;
}"
70303,"@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.binary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeBinaryMethod(this.binary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.binary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeBinaryMethod(this.binary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    LOGGER.error(""String_Node_Str"",iee);
    throw new JobExecutionException(iee);
  }
}"
70304,"private Object invokeDecafMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.dfScript + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeDecafMethod(nw.getInstallDir() + DecafImplementation.SCRIPT_PATH,this.dfScript,this.dfExecutor,this.dfLib,this.mpiRunner,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","private Object invokeDecafMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.dfScript + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeDecafMethod(nw.getInstallDir() + DecafImplementation.SCRIPT_PATH,this.dfScript,this.dfExecutor,this.dfLib,this.mpiRunner,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}"
70305,"private Object invokeMPIMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.mpiBinary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeMPIMethod(this.mpiRunner,this.mpiBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","private Object invokeMPIMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + this.mpiBinary + ""String_Node_Str""+ this.nw.getHostName());
  try {
    return GenericInvoker.invokeMPIMethod(this.mpiRunner,this.mpiBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}"
70306,"@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + ompssBinary + ""String_Node_Str""+ nw.getHostName());
  try {
    return GenericInvoker.invokeOmpSsMethod(this.ompssBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir);
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}","@Override public Object invokeMethod() throws JobExecutionException {
  LOGGER.info(""String_Node_Str"" + ompssBinary + ""String_Node_Str""+ nw.getHostName());
  try {
    return GenericInvoker.invokeOmpSsMethod(this.ompssBinary,this.values,this.streams,this.prefixes,this.taskSandboxWorkingDir,nw.getThreadOutStream(),nw.getThreadErrStream());
  }
 catch (  InvokeExecutionException iee) {
    throw new JobExecutionException(iee);
  }
}"
70307,"public void unregisterThread(){
  try {
    close();
    threadToStream.remove(Thread.currentThread().getId());
  }
 catch (  Exception e) {
    e.printStackTrace(System.err);
  }
}","public void unregisterThread(){
  try {
    flush();
    close();
    threadToStream.remove(Thread.currentThread().getId());
  }
 catch (  Exception e) {
    e.printStackTrace(System.err);
  }
}"
70308,"@Override public void run(){
  try {
    final byte[] buffer=new byte[BUFFER_SIZE];
    int nRead;
    while ((nRead=in.read(buffer,0,buffer.length)) != -1) {
      byte[] readData=new byte[nRead];
      System.arraycopy(buffer,0,readData,0,nRead);
      out.print(new String(readData));
    }
  }
 catch (  IOException ioe) {
    logger.error(""String_Node_Str"",ioe);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException ioe) {
        logger.warn(""String_Node_Str"",ioe);
      }
    }
    if (out != null) {
      out.flush();
      out.close();
    }
  }
}","@Override public void run(){
  logger.debug(""String_Node_Str"");
  try {
    final byte[] buffer=new byte[BUFFER_SIZE];
    int nRead;
    while ((nRead=in.read(buffer,0,buffer.length)) != -1) {
      byte[] readData=new byte[nRead];
      System.arraycopy(buffer,0,readData,0,nRead);
      out.print(new String(readData));
      out.flush();
    }
  }
 catch (  IOException ioe) {
    logger.error(""String_Node_Str"",ioe);
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException ioe) {
        logger.warn(""String_Node_Str"",ioe);
      }
    }
    if (out != null) {
      out.flush();
    }
  }
}"
70309,"/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
  for (  Resource r : loc.getHosts()) {
switch (loc.getType()) {
case PRIVATE:
      r.addLogicalData(this);
    break;
case SHARED:
  SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}
}","/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
switch (loc.getType()) {
case PRIVATE:
    for (    Resource r : loc.getHosts()) {
      r.addLogicalData(this);
    }
  break;
case SHARED:
SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}"
70310,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null)   return;
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
      return;
    }
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName());
  }
  orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null) {
    return;
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  if (ld.getId() != null) {
    orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
  }
 else {
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + ld.getName());
    }
    orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
  }
}"
70311,"private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,Comm.getAppHost().getName());
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}","private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,targetHostname);
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}"
70312,"/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
  for (  Resource r : loc.getHosts()) {
switch (loc.getType()) {
case PRIVATE:
      r.addLogicalData(this);
    break;
case SHARED:
  SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}
}","/** 
 * Adds a new location
 * @param loc
 */
public synchronized void addLocation(DataLocation loc){
  this.isBeingSaved=false;
  this.locations.add(loc);
switch (loc.getType()) {
case PRIVATE:
    for (    Resource r : loc.getHosts()) {
      r.addLogicalData(this);
    }
  break;
case SHARED:
SharedDiskManager.addLogicalData(loc.getSharedDisk(),this);
break;
case PERSISTENT:
this.id=((PersistentLocation)loc).getId();
break;
}
}"
70313,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null)   return;
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
      return;
    }
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName());
  }
  orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  if (ld == null) {
    return;
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target);
  }
  if (ld.getId() != null) {
    orderStorageCopy(new StorageCopy(ld,source,target,tgtData,reason,listener));
  }
 else {
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(""String_Node_Str"" + ld.getName());
    }
    orderCopy(new DeferredCopy(ld,source,target,tgtData,reason,listener));
  }
}"
70314,"private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,Comm.getAppHost().getName());
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}","private void newVersion(StorageCopy sc){
  String targetHostname=this.getName();
  LogicalData srcLD=sc.getSourceData();
  LogicalData targetLD=sc.getTargetData();
  boolean preserveSource=sc.mustPreserveSourceData();
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + srcLD.getName() + ""String_Node_Str""+ srcLD.getId()+ ""String_Node_Str""+ targetHostname+ ""String_Node_Str""+ preserveSource);
  }
  String pscoId=srcLD.getId();
  LOGGER.debug(""String_Node_Str"" + pscoId);
  if (NIOTracer.isActivated()) {
    NIOTracer.emitEvent(NIOTracer.Event.STORAGE_NEWVERSION.getId(),NIOTracer.Event.STORAGE_NEWVERSION.getType());
  }
  try {
    String newId=StorageItf.newVersion(pscoId,preserveSource,targetHostname);
    LOGGER.debug(""String_Node_Str"" + pscoId + ""String_Node_Str""+ newId);
    sc.setFinalTarget(newId);
    if (targetLD != null) {
      targetLD.setId(newId);
    }
  }
 catch (  Exception e) {
    sc.end(OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    if (NIOTracer.isActivated()) {
      NIOTracer.emitEvent(NIOTracer.EVENT_END,NIOTracer.Event.STORAGE_NEWVERSION.getType());
    }
  }
  sc.end(OpEndState.OP_OK);
}"
70315,"@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.taskId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}","@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.jobId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}"
70316,"/** 
 * New task result from a given set of   {@code params}
 * @param taskId
 * @param params
 */
public NIOTaskResult(int taskId,LinkedList<NIOParam> params){
  this.taskId=taskId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}","/** 
 * New task result from a given set of   {@code params}
 * @param jobId
 * @param params
 */
public NIOTaskResult(int jobId,LinkedList<NIOParam> params){
  this.jobId=jobId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}"
70317,"@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.taskId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}","@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.jobId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}"
70318,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.taskId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.jobId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
70319,"public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription());
  resourceUser.updatedResource(worker,modification);
}","public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription().copy());
  resourceUser.updatedResource(worker,modification);
}"
70320,"/** 
 * Selects a subset of the critical set able to execute all the cores
 */
public void defineCriticalSet(){
synchronized (this) {
    int coreCount=CoreManager.getCoreCount();
    boolean[] runnable=new boolean[coreCount];
    for (int coreId=0; coreId < coreCount; coreId++) {
      runnable[coreId]=false;
    }
    String resourceName;
    for (    Worker<? extends WorkerResourceDescription> res : staticSet.values()) {
      List<Integer> cores=res.getExecutableCores();
      for (int i=0; i < cores.size(); i++) {
        runnable[cores.get(i)]=true;
      }
    }
    for (    DynamicMethodWorker resource : criticalOrder) {
      resourceName=resource.getName();
      List<Integer> executableCores=resource.getExecutableCores();
      boolean needed=false;
      for (int i=0; i < executableCores.size() && !needed; i++) {
        needed=needed || !runnable[executableCores.get(i)];
      }
      if (needed) {
        for (int i=0; i < executableCores.size(); i++) {
          runnable[executableCores.get(i)]=true;
        }
      }
 else {
        criticalSet.remove(resourceName);
        criticalOrder.remove(resource);
        nonCriticalSet.put(resourceName,resource);
      }
    }
  }
}","/** 
 * Selects a subset of the critical set able to execute all the cores
 */
public void defineCriticalSet(){
synchronized (this) {
    int coreCount=CoreManager.getCoreCount();
    boolean[] runnable=new boolean[coreCount];
    for (int coreId=0; coreId < coreCount; coreId++) {
      runnable[coreId]=false;
    }
    String resourceName;
    for (    Worker<? extends WorkerResourceDescription> res : staticSet.values()) {
      List<Integer> cores=res.getExecutableCores();
      for (int i=0; i < cores.size(); i++) {
        runnable[cores.get(i)]=true;
      }
    }
    LinkedList<DynamicMethodWorker> criticalOrderRemovals=new LinkedList();
    for (    DynamicMethodWorker resource : criticalOrder) {
      resourceName=resource.getName();
      List<Integer> executableCores=resource.getExecutableCores();
      boolean needed=false;
      for (int i=0; i < executableCores.size() && !needed; i++) {
        needed=needed || !runnable[executableCores.get(i)];
      }
      if (needed) {
        for (int i=0; i < executableCores.size(); i++) {
          runnable[executableCores.get(i)]=true;
        }
      }
 else {
        criticalSet.remove(resourceName);
        criticalOrderRemovals.add(resource);
        nonCriticalSet.put(resourceName,resource);
      }
    }
    for (    DynamicMethodWorker resource : criticalOrderRemovals) {
      criticalOrder.remove(resource);
    }
  }
}"
70321,"public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription());
  resourceUser.updatedResource(worker,modification);
}","public static void reduceWholeWorker(MethodWorker worker){
  ResourceUpdate<MethodResourceDescription> modification=new PendingReduction<>(worker.getDescription().copy());
  resourceUser.updatedResource(worker,modification);
}"
70322,"@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.taskId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}","@Override public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(this.jobId);
  out.writeObject(this.paramTypes);
  out.writeObject(this.paramValues);
}"
70323,"/** 
 * New task result from a given set of   {@code params}
 * @param taskId
 * @param params
 */
public NIOTaskResult(int taskId,LinkedList<NIOParam> params){
  this.taskId=taskId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}","/** 
 * New task result from a given set of   {@code params}
 * @param jobId
 * @param params
 */
public NIOTaskResult(int jobId,LinkedList<NIOParam> params){
  this.jobId=jobId;
  for (  NIOParam np : params) {
    this.paramTypes.add(np.getType());
switch (np.getType()) {
case PSCO_T:
case EXTERNAL_OBJECT_T:
      this.paramValues.add(np.getValue());
    break;
default :
  this.paramValues.add(null);
break;
}
}
}"
70324,"@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.taskId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}","@SuppressWarnings(""String_Node_Str"") @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  this.jobId=in.readInt();
  this.paramTypes=(LinkedList<DataType>)in.readObject();
  this.paramValues=(LinkedList<Object>)in.readObject();
}"
70325,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.taskId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(this.jobId).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  DataType param : this.paramTypes) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (  Object param : this.paramValues) {
    sb.append(""String_Node_Str"").append(param);
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
70326,"/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String[] cmd=new String[NUM_BASE_DECAF_ARGS];
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  cmd[9]=""String_Node_Str"" + args + ""String_Node_Str"";
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}","/** 
 * Invokes a Decaf method
 * @param dfRunner
 * @param dfScript
 * @param dfExecutor
 * @param dfLib
 * @param mpiRunner
 * @param values
 * @param streams
 * @param prefixes
 * @param taskSandboxWorkingDir
 * @return
 * @throws InvokeExecutionException
 */
public static Object invokeDecafMethod(String dfRunner,String dfScript,String dfExecutor,String dfLib,String mpiRunner,Object[] values,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + dfScript);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String hostfile=writeHostfile(taskSandboxWorkingDir,workers);
  String args=new String();
  for (int i=0; i < binaryParams.size(); ++i) {
    if (i == 0) {
      args=args.concat(binaryParams.get(i));
    }
 else {
      args=args.concat(""String_Node_Str"" + binaryParams.get(i));
    }
  }
  String[] cmd;
  if (args.isEmpty()) {
    cmd=new String[NUM_BASE_DECAF_ARGS - 1];
  }
 else {
    cmd=new String[NUM_BASE_DECAF_ARGS];
  }
  cmd[0]=dfRunner;
  cmd[1]=dfScript;
  cmd[2]=dfExecutor;
  cmd[3]=dfLib;
  cmd[4]=mpiRunner;
  cmd[5]=""String_Node_Str"";
  cmd[6]=numProcs;
  cmd[7]=""String_Node_Str"";
  cmd[8]=hostfile;
  if (!args.isEmpty()) {
    cmd[9]=""String_Node_Str"" + args + ""String_Node_Str"";
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,streamValues,taskSandboxWorkingDir);
}"
70327,"@Override public Object invokeMethod() throws JobExecutionException {
  checkArguments();
  return invokeMPIMethod();
}","@Override public Object invokeMethod() throws JobExecutionException {
  checkArguments();
  return invokeDecafMethod();
}"
70328,"private static void addArguments(ArrayList<String> lArgs,NIOTask nt,NIOWorker nw) throws JobExecutionException, SerializedObjectException {
  lArgs.add(Boolean.toString(NIOTracer.isActivated()));
  lArgs.add(Integer.toString(nt.getTaskId()));
  lArgs.add(Boolean.toString(nt.isWorkerDebug()));
  lArgs.add(STORAGE_CONF);
  if (nt.getMethodType() != MethodType.METHOD) {
    throw new JobExecutionException(ERROR_UNSUPPORTED_JOB_TYPE);
  }
  MethodImplementation impl=(MethodImplementation)nt.getMethodImplementation();
  lArgs.add(String.valueOf(impl.getMethodType()));
  lArgs.add(impl.getDeclaringClass());
  lArgs.add(impl.getAlternativeMethodName());
  lArgs.add(String.valueOf(nt.getSlaveWorkersNodeNames().size()));
  lArgs.addAll(nt.getSlaveWorkersNodeNames());
  lArgs.add(String.valueOf(nt.getResourceDescription().getTotalCPUComputingUnits()));
  lArgs.add(Boolean.toString(nt.isHasTarget()));
  if (nt.isHasReturn()) {
    DataType returnType=nt.getParams().getLast().getType();
    lArgs.add(Integer.toString(returnType.ordinal()));
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Integer.toString(nt.getNumParams()));
  for (  NIOParam np : nt.getParams()) {
    DataType type=np.getType();
    lArgs.add(Integer.toString(type.ordinal()));
    lArgs.add(Integer.toString(np.getStream().ordinal()));
    lArgs.add(np.getPrefix());
switch (type) {
case FILE_T:
      String destFile=new File(np.getValue().toString()).getName();
    String originalFile=""String_Node_Str"";
  if (np.getData() != null) {
    originalFile=np.getData().getName();
  }
lArgs.add(originalFile + ""String_Node_Str"" + destFile+ ""String_Node_Str""+ np.isPreserveSourceData()+ ""String_Node_Str""+ np.isWriteFinalValue()+ ""String_Node_Str""+ np.getOriginalName());
break;
case OBJECT_T:
case PSCO_T:
case EXTERNAL_OBJECT_T:
lArgs.add(np.getValue().toString());
lArgs.add(np.isWriteFinalValue() ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case STRING_T:
String value=np.getValue().toString();
String[] vals=value.split(""String_Node_Str"");
int numSubStrings=vals.length;
lArgs.add(Integer.toString(numSubStrings));
for (String v : vals) {
lArgs.add(v);
}
break;
default :
lArgs.add(np.getValue().toString());
}
}
}","private static void addArguments(ArrayList<String> lArgs,NIOTask nt,NIOWorker nw) throws JobExecutionException, SerializedObjectException {
  lArgs.add(Boolean.toString(NIOTracer.isActivated()));
  lArgs.add(Integer.toString(nt.getTaskId()));
  lArgs.add(Boolean.toString(nt.isWorkerDebug()));
  lArgs.add(STORAGE_CONF);
  if (nt.getMethodType() != MethodType.METHOD) {
    throw new JobExecutionException(ERROR_UNSUPPORTED_JOB_TYPE);
  }
  MethodImplementation impl=(MethodImplementation)nt.getMethodImplementation();
  lArgs.add(String.valueOf(impl.getMethodType()));
  lArgs.add(impl.getDeclaringClass());
  lArgs.add(impl.getAlternativeMethodName());
  lArgs.add(String.valueOf(nt.getSlaveWorkersNodeNames().size()));
  lArgs.addAll(nt.getSlaveWorkersNodeNames());
  lArgs.add(String.valueOf(nt.getResourceDescription().getTotalCPUComputingUnits()));
  lArgs.add(Boolean.toString(nt.isHasTarget()));
  if (nt.isHasReturn()) {
    DataType returnType=nt.getParams().getLast().getType();
    lArgs.add(Integer.toString(returnType.ordinal()));
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Integer.toString(nt.getNumParams()));
  for (  NIOParam np : nt.getParams()) {
    DataType type=np.getType();
    lArgs.add(Integer.toString(type.ordinal()));
    lArgs.add(Integer.toString(np.getStream().ordinal()));
    lArgs.add(np.getPrefix());
switch (type) {
case FILE_T:
      String originalFile=""String_Node_Str"";
    if (np.getData() != null) {
      originalFile=np.getData().getName();
    }
  String destFile=new File(np.getValue().toString()).getName();
if (!isRuntimeRenamed(destFile)) {
  destFile=originalFile;
}
lArgs.add(originalFile + ""String_Node_Str"" + destFile+ ""String_Node_Str""+ np.isPreserveSourceData()+ ""String_Node_Str""+ np.isWriteFinalValue()+ ""String_Node_Str""+ np.getOriginalName());
break;
case OBJECT_T:
case PSCO_T:
case EXTERNAL_OBJECT_T:
lArgs.add(np.getValue().toString());
lArgs.add(np.isWriteFinalValue() ? ""String_Node_Str"" : ""String_Node_Str"");
break;
case STRING_T:
String value=np.getValue().toString();
String[] vals=value.split(""String_Node_Str"");
int numSubStrings=vals.length;
lArgs.add(Integer.toString(numSubStrings));
for (String v : vals) {
lArgs.add(v);
}
break;
default :
lArgs.add(np.getValue().toString());
}
}
}"
70329,"private static String writeHostfile(File taskSandboxWorkingDir,String workers) throws InvokeExecutionException {
  String filename=taskSandboxWorkingDir.getAbsolutePath() + File.separator + ""String_Node_Str"";
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(filename));
    writer.write(workers);
  }
 catch (  IOException e) {
    throw new InvokeExecutionException(""String_Node_Str"",e);
  }
 finally {
    try {
      if (writer != null)       writer.close();
    }
 catch (    IOException e) {
    }
  }
  return filename;
}","private static String writeHostfile(File taskSandboxWorkingDir,String workers) throws InvokeExecutionException {
  String filename=taskSandboxWorkingDir.getAbsolutePath() + File.separator + ""String_Node_Str"";
  String workersInLines=workers.replace(',','\n');
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(filename));
    writer.write(workersInLines);
  }
 catch (  IOException e) {
    throw new InvokeExecutionException(""String_Node_Str"",e);
  }
 finally {
    try {
      if (writer != null)       writer.close();
    }
 catch (    IOException e) {
    }
  }
  return filename;
}"
70330,"public void newCoreElementsDetected(List<Integer> newCores){
  int coreCount=CoreManager.getCoreCount();
  for (  CloudInstanceTypeDescription type : types.values()) {
    int[][] slotsI=new int[coreCount][];
    int[] slotsC=type.getSlotsCore().clone();
    for (int i=0; i < type.getSlotsImplLength(); ++i) {
      int[] slotsImpl=type.getSpecificSlotsImpl(i);
      slotsI[i]=slotsImpl.clone();
    }
    for (    int coreId : newCores) {
      List<Implementation> impls=CoreManager.getCoreImplementations(coreId);
      int implsSize=impls.size();
      slotsI[coreId]=new int[implsSize];
      for (int implId=0; implId < implsSize; ++implId) {
        Implementation impl=impls.get(implId);
        if (impl.getTaskType() == TaskType.METHOD) {
          MethodResourceDescription rd=(MethodResourceDescription)impl.getRequirements();
          Integer into=type.getResourceDescription().canHostSimultaneously(rd);
          slotsC[coreId]=Math.max(slotsC[coreId],into);
          slotsI[coreId][implId]=into;
        }
      }
    }
    type.setSlotsCore(slotsC);
    type.setSlotsImpl(slotsI);
  }
}","public void newCoreElementsDetected(List<Integer> newCores){
  int coreCount=CoreManager.getCoreCount();
  for (  CloudInstanceTypeDescription type : types.values()) {
    int[][] slotsI=new int[coreCount][];
    int[] slotsC=Arrays.copyOf(type.getSlotsCore(),coreCount);
    for (int i=0; i < type.getSlotsImplLength(); ++i) {
      int[] slotsImpl=type.getSpecificSlotsImpl(i);
      slotsI[i]=slotsImpl.clone();
    }
    for (    int coreId : newCores) {
      List<Implementation> impls=CoreManager.getCoreImplementations(coreId);
      int implsSize=impls.size();
      slotsI[coreId]=new int[implsSize];
      for (int implId=0; implId < implsSize; ++implId) {
        Implementation impl=impls.get(implId);
        if (impl.getTaskType() == TaskType.METHOD) {
          MethodResourceDescription rd=(MethodResourceDescription)impl.getRequirements();
          Integer into=type.getResourceDescription().canHostSimultaneously(rd);
          slotsC[coreId]=Math.max(slotsC[coreId],into);
          slotsI[coreId][implId]=into;
        }
      }
    }
    type.setSlotsCore(slotsC);
    type.setSlotsImpl(slotsI);
  }
}"
70331,"/** 
 * Returns the total slots per per core
 * @return
 */
public static int[] getTotalSlots(){
  int[] counts=new int[CoreManager.getCoreCount()];
  int[] cloudCount=cloudManager.getPendingCoreCounts();
synchronized (pool) {
    for (int i=0; i < counts.length; i++) {
      if (i < cloudCount.length) {
        counts[i]=poolCoreMaxConcurrentTasks[i] + cloudCount[i];
      }
 else {
        counts[i]=poolCoreMaxConcurrentTasks[i];
      }
    }
  }
  return counts;
}","/** 
 * Returns the total slots per per core
 * @return
 */
public static int[] getTotalSlots(){
  int[] counts=new int[CoreManager.getCoreCount()];
  if (CoreManager.getCoreCount() > 0) {
    int[] cloudCount=cloudManager.getPendingCoreCounts();
synchronized (pool) {
      for (int i=0; i < counts.length; i++) {
        if (i < cloudCount.length) {
          counts[i]=poolCoreMaxConcurrentTasks[i] + cloudCount[i];
        }
 else {
          counts[i]=poolCoreMaxConcurrentTasks[i];
        }
      }
    }
  }
  return counts;
}"
70332,"/** 
 * Updates the coreElement information
 * @param updatedCores
 */
public static void coreElementUpdates(List<Integer> updatedCores){
synchronized (pool) {
    pool.coreElementUpdates(updatedCores);
    cloudManager.newCoreElementsDetected(updatedCores);
  }
}","/** 
 * Updates the coreElement information
 * @param updatedCores
 */
public static void coreElementUpdates(List<Integer> updatedCores){
synchronized (pool) {
    pool.coreElementUpdates(updatedCores);
    cloudManager.newCoreElementsDetected(updatedCores);
    updateMaxConcurrentTasks(updatedCores);
  }
}"
70333,"public boolean isPreserveSourceData(){
  return readDataVersion.hasPendingLectures();
}","public boolean isPreserveSourceData(){
  return readDataVersion.isOnlyReader();
}"
70334,"/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  System.out.println(""String_Node_Str"" + MASTER_HOSTNAME);
  System.out.flush();
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new Jedis(MASTER_HOSTNAME,REDIS_PORT);
  }
}","/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new Jedis(MASTER_HOSTNAME,REDIS_PORT);
  }
}"
70335,"/** 
 * Consolidates all intermediate versions to the final id
 * @param idFinal
 * @throws StorageException
 */
public static void consolidateVersion(String idFinal) throws StorageException {
  LOGGER.info(""String_Node_Str"" + idFinal);
  idFinal=previousVersion.get(idFinal);
  previousVersion.remove(idFinal);
  while (idFinal != null) {
    removeById(idFinal);
    idFinal=previousVersion.get(idFinal);
    previousVersion.remove(idFinal);
  }
}","/** 
 * Consolidates all intermediate versions to the final id
 * @param idFinal
 * @throws StorageException
 */
public static void consolidateVersion(String idFinal) throws StorageException {
  LOGGER.info(""String_Node_Str"" + idFinal);
  idFinal=previousVersion.get(idFinal);
  while (idFinal != null) {
    LOGGER.info(""String_Node_Str"" + idFinal);
    removeById(idFinal);
    String oldId=idFinal;
    idFinal=previousVersion.get(idFinal);
    previousVersion.remove(oldId);
  }
}"
70336,"/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.get(id.getBytes());
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}","/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.get(id.getBytes());
  if (serializedObject == null) {
    throw new StorageException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}"
70337,"/** 
 * Retrieves the result of persistent storage execution
 * @param event
 * @return
 */
public static Object getResult(CallbackEvent event) throws StorageException {
  if (true)   throw new StorageException(""String_Node_Str"");
  return null;
}","/** 
 * Retrieves the result of persistent storage execution
 * @param event
 * @return
 */
public static Object getResult(CallbackEvent event) throws StorageException {
  throw new StorageException(""String_Node_Str"");
}"
70338,"/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new Jedis(MASTER_HOSTNAME,REDIS_PORT);
  }
}","/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line TODO: What to do with storage conf? StorageItf.init needs different content wrt storage_init.sh
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  LOGGER.info(""String_Node_Str"" + storageConf);
  try (BufferedReader br=new BufferedReader(new FileReader(storageConf))){
    String line;
    while ((line=br.readLine()) != null) {
      hosts.add(line.trim());
      System.out.println(""String_Node_Str"" + line.trim() + ""String_Node_Str"");
    }
  }
 catch (  FileNotFoundException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new StorageException(""String_Node_Str"",e);
  }
  assert(!hosts.isEmpty());
  try {
    redisClusterConnection=new JedisCluster(new HostAndPort(MASTER_HOSTNAME,REDIS_PORT));
  }
 catch (  JedisDataException e) {
    LOGGER.info(""String_Node_Str"");
    clusterMode=false;
    redisConnection=new JedisPool(MASTER_HOSTNAME,REDIS_PORT);
  }
}"
70339,"/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  if (clusterMode) {
    redisClusterConnection.del(id.getBytes());
  }
 else {
    redisConnection.del(id.getBytes());
  }
}","/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  if (clusterMode) {
    redisClusterConnection.del(id.getBytes());
  }
 else {
    redisConnection.getResource().del(id.getBytes());
  }
}"
70340,"/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  byte[] serializedObject=Serializer.serialize(o);
  String result=clusterMode ? redisClusterConnection.set(id.getBytes(),serializedObject) : redisConnection.set(id.getBytes(),serializedObject);
  if (!result.equals(""String_Node_Str"")) {
    throw new StorageException(""String_Node_Str"" + id);
  }
}","/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  byte[] serializedObject=Serializer.serialize(o);
  String result=clusterMode ? redisClusterConnection.set(id.getBytes(),serializedObject) : redisConnection.getResource().set(id.getBytes(),serializedObject);
  if (!result.equals(""String_Node_Str"")) {
    throw new StorageException(""String_Node_Str"" + id);
  }
}"
70341,"/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.get(id.getBytes());
  if (serializedObject == null) {
    throw new StorageException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}","/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=clusterMode ? redisClusterConnection.get(id.getBytes()) : redisConnection.getResource().get(id.getBytes());
  if (serializedObject == null) {
    throw new StorageException(""String_Node_Str"" + id + ""String_Node_Str"");
  }
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}"
70342,"/** 
 * Returns all the valid locations of a given id WARNING: Given that Redis has no immediate mechanisms to retrieve this information, we will return all the nodes instead, because a connection to any of them will grant us that we can retrieve it
 * @param id
 * @return
 * @throws StorageException
 */
public static List<String> getLocations(String id) throws StorageException {
  return hosts;
}","/** 
 * Returns all the valid locations of a given id WARNING: Given that Redis has no immediate mechanisms to retrieve this information, we will return all the nodes instead, because a connection to any of them will grant us that we can retrieve it
 * @param id
 * @return
 * @throws StorageException
 */
public static List<String> getLocations(String id) throws StorageException {
  if (clusterMode) {
    return hosts;
  }
  return hosts;
}"
70343,"@Override public ResourceDescription getDynamicCommons(ResourceDescription other){
  MethodResourceDescription otherMRD=(MethodResourceDescription)other;
  MethodResourceDescription common=new MethodResourceDescription();
  for (  Processor p : otherMRD.getProcessors()) {
    boolean isProcessorCompatible=false;
    int i=0;
    while (i < this.processors.size() && !isProcessorCompatible) {
      Processor pThis=this.processors.get(i);
      if (checkProcessorCompatibility(pThis,p)) {
        isProcessorCompatible=true;
        common.addProcessor(getDynamicCommonsProcessor(pThis,p));
      }
      i=i + 1;
    }
  }
  if (checkCompatibility(this.memoryType,otherMRD.memoryType)) {
    common.setMemoryType(this.getMemoryType());
    common.setMemorySize(Math.min(this.memorySize,otherMRD.getMemorySize()));
  }
  return common;
}","@Override public ResourceDescription getDynamicCommons(ResourceDescription other){
  MethodResourceDescription otherMRD=(MethodResourceDescription)other;
  MethodResourceDescription common=new MethodResourceDescription();
  for (  Processor p : otherMRD.getProcessors()) {
    boolean isProcessorCompatible=false;
    int i=0;
    while (i < this.processors.size() && !isProcessorCompatible) {
      Processor pThis=this.processors.get(i);
      if (checkProcessorCompatibility(pThis,p)) {
        isProcessorCompatible=true;
        Processor commonProcessor=getDynamicCommonsProcessor(pThis,p);
        if (commonProcessor.getComputingUnits() > 0) {
          common.addProcessor(commonProcessor);
        }
      }
      i=i + 1;
    }
  }
  if (checkCompatibility(this.memoryType,otherMRD.memoryType)) {
    common.setMemoryType(this.getMemoryType());
    common.setMemorySize(Math.min(this.memorySize,otherMRD.getMemorySize()));
  }
  return common;
}"
70344,"public int getSpecificSlotsImpl(int i,int j){
  return this.slotsImpl[i][j];
}","public int getSpecificSlotsImpl(int coreId,int implId){
  return this.slotsImpl[coreId][implId];
}"
70345,"/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  redisConnection=new Jedis(""String_Node_Str"",6379);
  hosts=new String[]{""String_Node_Str""};
}","/** 
 * Initializes the persistent storage Configuration file must contain all the worker hostnames, one by line
 * @param storageConf Path to the storage configuration File
 * @throws StorageException
 */
public static void init(String storageConf) throws StorageException, IOException {
  System.out.println(""String_Node_Str"" + storageConf);
  redisConnection=new Jedis(""String_Node_Str"",6379);
  hosts=new String[]{""String_Node_Str""};
}"
70346,"/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  LOGGER.debug(""String_Node_Str"" + id);
  redisConnection.del(id.getBytes());
  LOGGER.debug(""String_Node_Str"");
}","/** 
 * Removes all the occurrences of a given @id
 * @param id
 */
public static void removeById(String id){
  redisConnection.del(id.getBytes());
}"
70347,"/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  LOGGER.debug(""String_Node_Str"");
  byte[] serializedObject=Serializer.serialize(o);
  LOGGER.debug(""String_Node_Str"");
  redisConnection.set(id.getBytes(),serializedObject);
  LOGGER.debug(""String_Node_Str"");
}","/** 
 * Stores the object @o in the persistent storage with id @id
 * @param o
 * @param id
 * @throws StorageException
 */
public static void makePersistent(Object o,String id) throws StorageException, IOException {
  byte[] serializedObject=Serializer.serialize(o);
  String result=redisConnection.set(id.getBytes(),serializedObject);
  if (!result.equals(""String_Node_Str"")) {
    throw new StorageException(""String_Node_Str"" + id);
  }
}"
70348,"/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  LOGGER.debug(""String_Node_Str"");
  byte[] serializedObject=redisConnection.get(id.getBytes());
  LOGGER.debug(""String_Node_Str"");
  Object ret=Serializer.deserialize(serializedObject);
  LOGGER.debug(""String_Node_Str"");
  return ret;
}","/** 
 * Returns the object with id @id This function retrieves the object from any location
 * @param id
 * @return
 * @throws StorageException
 */
public static Object getByID(String id) throws StorageException, IOException, ClassNotFoundException {
  byte[] serializedObject=redisConnection.get(id.getBytes());
  Object ret=Serializer.deserialize(serializedObject);
  ((StorageObject)ret).setID(id);
  return ret;
}"
70349,"/** 
 * Create a new version of the PSCO id @id in the host @hostname Returns the id of the new version
 * @param id
 * @param hostName
 * @return
 * @throws StorageException
 */
public static String newVersion(String id,boolean preserveSource,String hostName) throws StorageException {
  return null;
}","/** 
 * Create a new version of the PSCO id @id in the host @hostname Returns the id of the new version
 * @param id
 * @param hostName
 * @return
 * @throws StorageException
 */
public static String newVersion(String id,boolean preserveSource,String hostName) throws StorageException, IOException, ClassNotFoundException {
  Object obj=getByID(id);
  String new_id=UUID.randomUUID().toString();
  makePersistent(obj,new_id);
  if (!preserveSource) {
    removeById(id);
  }
  return new_id;
}"
70350,"/** 
 * Sets the ID
 */
protected void setID(String id) throws IOException, StorageException {
  if (this.id != null) {
    StorageItf.removeById(id);
    StorageItf.makePersistent(this,id);
  }
  this.id=id;
}","/** 
 * Sets the ID
 */
protected void setID(String id) throws IOException, StorageException {
  this.id=id;
}"
70351,"private static String getLsCpuOutput() throws InvalidMapException {
  String cmdOutput=null;
  ProcessBuilder pb=new ProcessBuilder(""String_Node_Str"");
  try {
    Process process=pb.start();
    process.getOutputStream().close();
    int exitValue=process.waitFor();
    if (exitValue != 0) {
      throw new InvalidMapException(""String_Node_Str"" + exitValue);
    }
    StringBuilder sb=new StringBuilder();
    try (BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=br.readLine()) != null) {
        sb.append(line).append(""String_Node_Str"");
      }
    }
 catch (    IOException ioe) {
      throw new InvalidMapException(""String_Node_Str"",ioe);
    }
    cmdOutput=sb.toString();
  }
 catch (  IOException ioe) {
    throw new InvalidMapException(""String_Node_Str"",ioe);
  }
catch (  InterruptedException ie) {
    throw new InvalidMapException(""String_Node_Str"",ie);
  }
  return cmdOutput;
}","private static String getLsCpuOutput() throws InvalidMapException {
  String cmdOutput=null;
  ProcessBuilder pb=new ProcessBuilder(""String_Node_Str"");
  try {
    pb.environment().remove(Tracer.LD_PRELOAD);
    Process process=pb.start();
    process.getOutputStream().close();
    int exitValue=process.waitFor();
    if (exitValue != 0) {
      throw new InvalidMapException(""String_Node_Str"" + exitValue);
    }
    StringBuilder sb=new StringBuilder();
    try (BufferedReader br=new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=br.readLine()) != null) {
        sb.append(line).append(""String_Node_Str"");
      }
    }
 catch (    IOException ioe) {
      throw new InvalidMapException(""String_Node_Str"",ioe);
    }
    cmdOutput=sb.toString();
  }
 catch (  IOException ioe) {
    throw new InvalidMapException(""String_Node_Str"",ioe);
  }
catch (  InterruptedException ie) {
    throw new InvalidMapException(""String_Node_Str"",ie);
  }
  return cmdOutput;
}"
70352,"/** 
 * New Core Elements have been detected; the Task Scheduler needs to be notified to modify any internal structure using that information.
 */
public final void coreElementsUpdated(){
  LOGGER.info(""String_Node_Str"");
  int newCoreCount=CoreManager.getCoreCount();
  SchedulingInformation.updateCoreCount(newCoreCount);
  this.blockedActions.updateCoreCount(newCoreCount);
  this.readyCounts=new int[newCoreCount];
  for (  ResourceScheduler<P,T,I> rs : workers.values()) {
    rs.updatedCoreElements(newCoreCount);
  }
}","/** 
 * New Core Elements have been detected; the Task Scheduler needs to be notified to modify any internal structure using that information.
 */
public final void coreElementsUpdated(){
  LOGGER.info(""String_Node_Str"");
  int newCoreCount=CoreManager.getCoreCount();
  SchedulingInformation.updateCoreCount(newCoreCount);
  this.blockedActions.updateCoreCount(newCoreCount);
  this.readyCounts=new int[newCoreCount];
  for (  ResourceScheduler<P,T,I> rs : workers.values()) {
    rs.updatedCoreElements(newCoreCount);
    SchedulingInformation.updateResource(rs);
  }
}"
70353,"@SuppressWarnings(""String_Node_Str"") public static <P extends Profile,T extends WorkerResourceDescription,I extends Implementation<T>>void changesOnWorker(ResourceScheduler<P,T,I> ui){
  for (  LinkedList<ResourceScheduler<Profile,WorkerResourceDescription,Implementation<WorkerResourceDescription>>> coreToWorker : coreToWorkers) {
    coreToWorker.remove(ui);
  }
  SchedulingInformation.updateCoreCount(CoreManager.getCoreCount());
  LinkedList<Integer> executableCores=ui.getExecutableCores();
  for (  int coreId : executableCores) {
    coreToWorkers.get(coreId).add((ResourceScheduler<Profile,WorkerResourceDescription,Implementation<WorkerResourceDescription>>)ui);
  }
}","public static <P extends Profile,T extends WorkerResourceDescription,I extends Implementation<T>>void changesOnWorker(ResourceScheduler<P,T,I> ui){
  for (  LinkedList<ResourceScheduler<Profile,WorkerResourceDescription,Implementation<WorkerResourceDescription>>> coreToWorker : coreToWorkers) {
    coreToWorker.remove(ui);
  }
  SchedulingInformation.updateCoreCount(CoreManager.getCoreCount());
  updateResource(ui);
}"
70354,"@Decaf(dfScript=""String_Node_Str"",mpiRunner=""String_Node_Str"",computingNodes=""String_Node_Str"") @Constraints(computingUnits=""String_Node_Str"") Integer taskConcurrentMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);","@Constraints(computingUnits=""String_Node_Str"") Integer taskConcurrentMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);"
70355,"@Decaf(dfScript=""String_Node_Str"",mpiRunner=""String_Node_Str"",computingNodes=""String_Node_Str"") @Constraints(computingUnits=""String_Node_Str"") int taskSingleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);","@Constraints(computingUnits=""String_Node_Str"") int taskSingleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);"
70356,"@Decaf(dfScript=""String_Node_Str"",mpiRunner=""String_Node_Str"",computingNodes=""String_Node_Str"") @Constraints(computingUnits=""String_Node_Str"") Integer taskMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);","@Constraints(computingUnits=""String_Node_Str"") Integer taskMultipleDecaf(@Parameter(type=Type.FILE,direction=Direction.OUT,stream=Stream.STDOUT) String fileOut);"
70357,"/** 
 * Sets MPI / OMPSs environment variables
 */
private static void setEnvironmentVariables(){
  String hostname=""String_Node_Str"";
  try {
    hostname=InetAddress.getLocalHost().getHostName();
  }
 catch (  UnknownHostException e1) {
    ErrorManager.warn(""String_Node_Str"" + hostname);
  }
  GATWorker.hostnames.add(hostname);
  ++GATWorker.numNodes;
  boolean firstElement=true;
  StringBuilder hostnamesSTR=new StringBuilder();
  for (Iterator<String> it=GATWorker.hostnames.iterator(); it.hasNext(); ) {
    String nodeName=it.next();
    if (nodeName.endsWith(""String_Node_Str"")) {
      nodeName=nodeName.substring(0,hostname.lastIndexOf(""String_Node_Str""));
    }
    if (firstElement) {
      firstElement=false;
      hostnamesSTR.append(hostname);
      for (int i=1; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(hostname);
      }
    }
 else {
      for (int i=0; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(hostname);
      }
    }
  }
  if (GATWorker.debug) {
    System.out.println(""String_Node_Str"" + hostnamesSTR.toString());
    System.out.println(""String_Node_Str"" + GATWorker.numNodes);
    System.out.println(""String_Node_Str"" + GATWorker.cus);
  }
  System.setProperty(Constants.COMPSS_HOSTNAMES,hostnamesSTR.toString());
  System.setProperty(Constants.COMPSS_NUM_NODES,String.valueOf(GATWorker.numNodes));
  System.setProperty(Constants.COMPSS_NUM_THREADS,String.valueOf(GATWorker.cus));
}","/** 
 * Sets MPI / OMPSs environment variables
 */
private static void setEnvironmentVariables(){
  String hostname=""String_Node_Str"";
  try {
    hostname=InetAddress.getLocalHost().getHostName();
  }
 catch (  UnknownHostException e1) {
    ErrorManager.warn(""String_Node_Str"" + hostname);
  }
  GATWorker.hostnames.add(hostname);
  ++GATWorker.numNodes;
  boolean firstElement=true;
  StringBuilder hostnamesSTR=new StringBuilder();
  for (  String nodeName : GATWorker.hostnames) {
    if (nodeName.endsWith(""String_Node_Str"")) {
      nodeName=nodeName.substring(0,nodeName.lastIndexOf(""String_Node_Str""));
    }
    if (firstElement) {
      firstElement=false;
      hostnamesSTR.append(nodeName);
      for (int i=1; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(nodeName);
      }
    }
 else {
      for (int i=0; i < GATWorker.cus; ++i) {
        hostnamesSTR.append(""String_Node_Str"").append(nodeName);
      }
    }
  }
  if (GATWorker.debug) {
    System.out.println(""String_Node_Str"" + hostnamesSTR.toString());
    System.out.println(""String_Node_Str"" + GATWorker.numNodes);
    System.out.println(""String_Node_Str"" + GATWorker.cus);
  }
  System.setProperty(Constants.COMPSS_HOSTNAMES,hostnamesSTR.toString());
  System.setProperty(Constants.COMPSS_NUM_NODES,String.valueOf(GATWorker.numNodes));
  System.setProperty(Constants.COMPSS_NUM_THREADS,String.valueOf(GATWorker.cus));
}"
70358,"private void deleteFolder(File folder){
  if (folder.isDirectory()) {
    for (    File f : folder.listFiles()) {
      deleteFolder(f);
    }
  }
  if (!folder.delete()) {
    logger.error(""String_Node_Str"" + (folder == null ? ""String_Node_Str"" : folder.getName()));
  }
}","private void deleteFolder(File folder){
  if (folder.isDirectory()) {
    for (    File f : folder.listFiles()) {
      deleteFolder(f);
    }
  }
  if (!folder.delete()) {
    LOGGER.error(""String_Node_Str"" + (folder == null ? ""String_Node_Str"" : folder.getName()));
  }
}"
70359,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  logger.info(""String_Node_Str"" + ld.getName());
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      logger.debug(""String_Node_Str"" + loc.getPath());
      reason.setDataTarget(loc.getPath());
      listener.notifyEnd(null);
      return;
    }
  }
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
    if (tgtData != null) {
      tgtData.addLocation(target);
    }
    logger.debug(""String_Node_Str"" + target.getPath());
    reason.setDataTarget(target.getPath());
    listener.notifyEnd(null);
    return;
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (debug) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      logger.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
      try {
        if (debug) {
          logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        logger.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (debug) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        String sourcePath=source.getURIInHost(Comm.getAppHost()).getPath();
        String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          logger.debug(""String_Node_Str"" + target.getPath());
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        continue;
      }
      logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoval();
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,EventListener listener){
  LOGGER.info(""String_Node_Str"" + ld.getName());
  for (  DataLocation loc : ld.getLocations()) {
    if (loc.getProtocol().equals(Protocol.PERSISTENT_URI)) {
      LOGGER.debug(""String_Node_Str"" + loc.getPath());
      reason.setDataTarget(loc.getPath());
      listener.notifyEnd(null);
      return;
    }
  }
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
    if (tgtData != null) {
      tgtData.addLocation(target);
    }
    LOGGER.debug(""String_Node_Str"" + target.getPath());
    reason.setDataTarget(target.getPath());
    listener.notifyEnd(null);
    return;
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemoval();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.getAppHost())) {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.getAppHost())) {
          waitForCopyTofinish(copy);
          String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
          try {
            if (DEBUG) {
              LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ targetPath);
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            LOGGER.debug(""String_Node_Str"" + targetPath);
            reason.setDataTarget(targetPath);
            listener.notifyEnd(null);
            ld.releaseHostRemoval();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.getAppHost().getName()+ ""String_Node_Str"");
  }
  for (  MultiURI u : ld.getURIs()) {
    if (DEBUG) {
      String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
      LOGGER.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ hostname+ ""String_Node_Str"");
    }
    if (u.getHost() == Comm.getAppHost()) {
      String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
      try {
        if (DEBUG) {
          LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        LOGGER.debug(""String_Node_Str"" + targetPath);
        reason.setDataTarget(targetPath);
        listener.notifyEnd(null);
        ld.releaseHostRemoval();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ targetPath+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (DEBUG) {
        String hostname=(u.getHost() != null) ? u.getHost().getName() : ""String_Node_Str"";
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ hostname+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoval();
        return;
      }
 else {
        String sourcePath=source.getURIInHost(Comm.getAppHost()).getPath();
        String targetPath=target.getURIInHost(Comm.getAppHost()).getPath();
        try {
          if (DEBUG) {
            LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourcePath+ ""String_Node_Str""+ targetPath);
          }
          Files.copy(new File(sourcePath).toPath(),new File(targetPath).toPath(),StandardCopyOption.REPLACE_EXISTING);
          LOGGER.debug(""String_Node_Str"" + target.getPath());
          reason.setDataTarget(targetPath);
          listener.notifyEnd(null);
          ld.releaseHostRemoval();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + sourcePath + ""String_Node_Str""+ targetPath,ex);
        }
      }
    }
  }
 else {
    LOGGER.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        LOGGER.error(""String_Node_Str"",e);
        continue;
      }
      LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoval();
      return;
    }
 else {
      if (DEBUG) {
        LOGGER.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoval();
}"
70360,"private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
    Thread.currentThread().interrupt();
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + copy.getName() + ""String_Node_Str""+ copy.getId()+ ""String_Node_Str"");
  }
}","private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
    Thread.currentThread().interrupt();
  }
  if (DEBUG) {
    LOGGER.debug(""String_Node_Str"" + copy.getName() + ""String_Node_Str""+ copy.getId()+ ""String_Node_Str"");
  }
}"
70361,"@Override public void setWorkerIsReady(String nodeName){
  logger.info(""String_Node_Str"" + nodeName);
  WorkerStarter ws=WorkerStarter.getWorkerStarter(nodeName);
  if (ws != null) {
    ws.setWorkerIsReady();
  }
 else {
    logger.warn(""String_Node_Str"" + nodeName + ""String_Node_Str"");
  }
}","@Override public void setWorkerIsReady(String nodeName){
  logger.info(""String_Node_Str"" + nodeName + ""String_Node_Str"");
  WorkerStarter ws=WorkerStarter.getWorkerStarter(nodeName);
  if (ws != null) {
    ws.setWorkerIsReady();
  }
 else {
    logger.warn(""String_Node_Str"" + nodeName + ""String_Node_Str"");
  }
}"
70362,"public NIONode startWorker() throws InitNodeException {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort && !toStop) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
        throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
 else       if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
      pid=-1;
    }
    n=new NIONode(name,port);
    String nodeName=nw.getName();
    addresstoWorkerStarter.put(nodeName,this);
    logger.debug(""String_Node_Str"");
    command=getStartCommand(nw,port);
    long timer=0;
    while (pid < 0) {
      timer=timer + (WAIT_TIME_UNIT * 4);
      try {
        Thread.sleep(WAIT_TIME_UNIT * 4);
      }
 catch (      Exception e) {
      }
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
        pid=0;
      }
 else       if (po.getExitValue() == 0) {
        String output=po.getOutput();
        String[] lines=output.split(""String_Node_Str"");
        pid=Integer.parseInt(lines[lines.length - 1]);
      }
 else {
        if (timer > MAX_WAIT_FOR_SSH) {
          throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
        }
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    long delay=WAIT_TIME_UNIT;
    long totalWait=0;
    logger.debug(""String_Node_Str"");
    CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,nodeName);
    while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT) && !toStop) {
      try {
        logger.debug(""String_Node_Str"" + delay);
        Thread.sleep(delay);
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
      if (!workerIsReady) {
        if (debug) {
          logger.debug(""String_Node_Str"" + nodeName);
        }
        Connection c=NIOAdaptor.tm.startConnection(n);
        c.sendCommand(cmd);
        c.receive();
        c.finishConnection();
        totalWait+=delay;
        delay=(delay < 3900) ? delay * 2 : 4000;
      }
    }
    logger.debug(""String_Node_Str"" + nodeName + ""String_Node_Str"");
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      return n;
    }
  }
  if (toStop) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else   if (!workerIsReady) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
}","public NIONode startWorker() throws InitNodeException {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
synchronized (addresstoWorkerStarter) {
    addresstoWorkerStarter.put(name,this);
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort && !toStop) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
        throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
 else       if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
      pid=-1;
    }
    n=new NIONode(name,port);
    command=getStartCommand(nw,port);
    long timer=0;
    while (pid < 0) {
      timer=timer + (WAIT_TIME_UNIT * 4);
      try {
        Thread.sleep(WAIT_TIME_UNIT * 4);
      }
 catch (      Exception e) {
      }
      ProcessOut po=executeCommand(user,name,command);
      if (po == null) {
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
        pid=0;
      }
 else       if (po.getExitValue() == 0) {
        String output=po.getOutput();
        String[] lines=output.split(""String_Node_Str"");
        pid=Integer.parseInt(lines[lines.length - 1]);
      }
 else {
        if (timer > MAX_WAIT_FOR_SSH) {
          throw new InitNodeException(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
        }
        logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    long delay=WAIT_TIME_UNIT;
    long totalWait=0;
    logger.debug(""String_Node_Str"");
    CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,name);
    while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT) && !toStop) {
      try {
        logger.debug(""String_Node_Str"" + delay);
        Thread.sleep(delay);
      }
 catch (      InterruptedException ie) {
        Thread.currentThread().interrupt();
      }
      if (!workerIsReady) {
        if (debug) {
          logger.debug(""String_Node_Str"" + name);
        }
        Connection c=NIOAdaptor.tm.startConnection(n);
        c.sendCommand(cmd);
        c.receive();
        c.finishConnection();
        totalWait+=delay;
        delay=(delay < 3900) ? delay * 2 : 4000;
      }
    }
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      return n;
    }
  }
  if (toStop) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else   if (!workerIsReady) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
 else {
    String msg=""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"";
    logger.warn(msg);
    throw new InitNodeException(msg);
  }
}"
70363,"public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String ldLibraryPath=System.getenv(LIBRARY_PATH_ENV);
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + C_LIB_RELATIVE_PATH);
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + COMMONS_LIB_RELATIVE_PATH);
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}","public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String ldLibraryPath=System.getenv(LIBRARY_PATH_ENV);
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + C_LIB_RELATIVE_PATH);
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getInstallDir() + BINDINGS_RELATIVE_PATH);
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}"
70364,"public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String pycompssHome=nw.getInstallDir() + PYCOMPSS_RELATIVE_PATH;
  env.put(""String_Node_Str"",pycompssHome);
  String pythonPath=System.getenv(""String_Node_Str"");
  if (pythonPath == null) {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir();
  }
 else {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir()+ pythonPath;
  }
  env.put(""String_Node_Str"",pythonPath);
  String ldLibraryPath=System.getenv(""String_Node_Str"");
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}","public static Map<String,String> getEnvironment(NIOWorker nw){
  Map<String,String> env=new HashMap<>();
  String pycompssHome=nw.getInstallDir() + PYCOMPSS_RELATIVE_PATH;
  env.put(""String_Node_Str"",pycompssHome);
  String pythonPath=System.getenv(""String_Node_Str"");
  if (pythonPath == null) {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir();
  }
 else {
    pythonPath=pycompssHome + ""String_Node_Str"" + nw.getPythonpath()+ ""String_Node_Str""+ nw.getAppDir()+ pythonPath;
  }
  env.put(""String_Node_Str"",pythonPath);
  String ldLibraryPath=System.getenv(""String_Node_Str"");
  if (ldLibraryPath == null) {
    ldLibraryPath=nw.getLibPath();
  }
 else {
    ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + nw.getLibPath());
  }
  String bindingsHome=nw.getInstallDir() + BINDINGS_RELATIVE_PATH;
  ldLibraryPath=ldLibraryPath.concat(""String_Node_Str"" + bindingsHome);
  env.put(""String_Node_Str"",ldLibraryPath);
  return env;
}"
70365,"/** 
 * We have explicitly called the barrier API. STEPS: Add a new synchronization node. Add an edge from last synchronization point to barrier. Add edges from writer tasks to barrier
 */
private void addNewBarrier(){
  synchronizationId++;
  taskDetectedAfterSync=false;
  this.GM.addBarrierToGraph(synchronizationId);
  if (synchronizationId > 1) {
    this.GM.addEdgeToGraph(""String_Node_Str"" + (synchronizationId - 1),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
  }
  for (  Task writer : writers.values()) {
    this.GM.addEdgeToGraph(String.valueOf(writer.getId()),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
  }
}","/** 
 * We have explicitly called the barrier API. STEPS: Add a new synchronization node. Add an edge from last synchronization point to barrier. Add edges from writer tasks to barrier
 */
private void addNewBarrier(){
  synchronizationId++;
  taskDetectedAfterSync=false;
  this.GM.addBarrierToGraph(synchronizationId);
  if (synchronizationId > 1) {
    this.GM.addEdgeToGraph(""String_Node_Str"" + (synchronizationId - 1),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
  }
  HashSet<Task> uniqueWriters=new HashSet<>(writers.values());
  for (  Task writer : uniqueWriters) {
    if (writer.getSynchronizationId() == (synchronizationId - 1)) {
      this.GM.addEdgeToGraph(String.valueOf(writer.getId()),""String_Node_Str"" + synchronizationId,""String_Node_Str"");
    }
  }
}"
70366,"public static Integer align(String pFlag,String pMode,String dFlag,String database,String iFlag,String partitionFile,String oFlag,String partitionOutput){
  return -1;
}","/** 
 * Dummy implementation to call the BLAST binary for algin withou extra CMD args
 * @param pFlag
 * @param pMode
 * @param dFlag
 * @param database
 * @param iFlag
 * @param partitionFile
 * @param oFlag
 * @param partitionOutput
 * @return
 */
public static Integer align(String pFlag,String pMode,String dFlag,String database,String iFlag,String partitionFile,String oFlag,String partitionOutput){
  return -1;
}"
70367,"private static void parseArgs(String[] args){
  Blast.debug=Boolean.parseBoolean(args[0]);
  Blast.databasePath=args[1];
  Blast.inputFileName=args[2];
  Blast.numFragments=Integer.parseInt(args[3]);
  Blast.tmpDir=args[4];
  Blast.outputFileName=args[5];
  Blast.commandArgs=""String_Node_Str"";
  for (int i=6; i < args.length; i++) {
    Blast.commandArgs+=args[i] + ""String_Node_Str"";
  }
}","/** 
 * Parses the input parameters and initializes the class atributes
 * @param args
 */
private static void parseArgs(String[] args){
  Blast.debug=Boolean.parseBoolean(args[0]);
  Blast.databasePath=args[1];
  Blast.inputFileName=args[2];
  Blast.numFragments=Integer.parseInt(args[3]);
  Blast.tmpDir=args[4];
  Blast.outputFileName=args[5];
  Blast.commandArgs=""String_Node_Str"";
  for (int i=6; i < args.length; i++) {
    Blast.commandArgs+=args[i] + ""String_Node_Str"";
  }
}"
70368,"private static void logArgs(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + System.getenv(ENV_BLAST_BINARY));
  System.out.println(""String_Node_Str"" + Blast.debug);
  System.out.println(""String_Node_Str"" + Blast.databasePath);
  System.out.println(""String_Node_Str"" + Blast.inputFileName);
  System.out.println(""String_Node_Str"" + Blast.numFragments);
  System.out.println(""String_Node_Str"" + Blast.tmpDir);
  System.out.println(""String_Node_Str"" + Blast.outputFileName);
  System.out.println(""String_Node_Str"" + Blast.commandArgs);
  System.out.println(""String_Node_Str"");
}","/** 
 * Prints the class attributes used for the execution
 */
private static void logArgs(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + System.getenv(ENV_BLAST_BINARY));
  System.out.println(""String_Node_Str"" + Blast.debug);
  System.out.println(""String_Node_Str"" + Blast.databasePath);
  System.out.println(""String_Node_Str"" + Blast.inputFileName);
  System.out.println(""String_Node_Str"" + Blast.numFragments);
  System.out.println(""String_Node_Str"" + Blast.tmpDir);
  System.out.println(""String_Node_Str"" + Blast.outputFileName);
  System.out.println(""String_Node_Str"" + Blast.commandArgs);
  System.out.println(""String_Node_Str"");
}"
70369,"public static void main(String[] args) throws BlastException {
}","/** 
 * MAIN CODE
 * @param args
 * @throws BlastException
 */
public static void main(String[] args) throws BlastException {
}"
70370,"public BlastException(String msg,Exception e){
  super(msg,e);
}","/** 
 * Constructs a new BlastException with a nested exception @e and error message @msg
 * @param msg
 * @param e
 */
public BlastException(String msg,Exception e){
  super(msg,e);
}"
70371,"/** 
 * Bind numCUs core units to the job
 * @param jobId
 * @param numCUs
 * @return
 * @throws UnsufficientAvailableComputingUnitsException
 */
public int[] bindComputingUnits(int jobId,int numCUs) throws UnsufficientAvailableComputingUnitsException {
  int assignedCoreUnits[]=new int[numCUs];
  int numAssignedCores=0;
synchronized (this.bindedComputingUnits) {
    for (int coreId=0; coreId < this.bindedComputingUnits.length; ++coreId) {
      if (this.bindedComputingUnits[coreId] == -1) {
        this.bindedComputingUnits[coreId]=jobId;
        assignedCoreUnits[numAssignedCores]=coreId;
        numAssignedCores++;
      }
      if (numAssignedCores == numCUs) {
        break;
      }
    }
    if (numAssignedCores != numCUs) {
      releaseComputingUnits(jobId);
      throw new UnsufficientAvailableComputingUnitsException(""String_Node_Str"");
    }
  }
  return assignedCoreUnits;
}","/** 
 * Bind numCUs core units to the job
 * @param jobId
 * @param numCUs
 * @return
 * @throws UnsufficientAvailableComputingUnitsException
 */
public int[] bindComputingUnits(int jobId,int numCUs) throws UnsufficientAvailableComputingUnitsException {
  if (numCUs == 0)   return new int[0];
  int assignedCoreUnits[]=new int[numCUs];
  int numAssignedCores=0;
synchronized (this.bindedComputingUnits) {
    for (int coreId=0; coreId < this.bindedComputingUnits.length; ++coreId) {
      if (this.bindedComputingUnits[coreId] == -1) {
        this.bindedComputingUnits[coreId]=jobId;
        assignedCoreUnits[numAssignedCores]=coreId;
        numAssignedCores++;
      }
      if (numAssignedCores == numCUs) {
        break;
      }
    }
    if (numAssignedCores != numCUs) {
      releaseComputingUnits(jobId);
      throw new UnsufficientAvailableComputingUnitsException(""String_Node_Str"");
    }
  }
  return assignedCoreUnits;
}"
70372,"private static void generateTrace(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  String appName=System.getProperty(ITConstants.IT_APP_NAME);
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",System.getProperty(ITConstants.IT_APP_LOG_DIR),appName,String.valueOf(hostToSlots.size() + 1));
  Process p;
  pb.environment().remove(LD_PRELOAD);
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out);
  StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err);
  outputGobbler.start();
  errorGobbler.start();
  int exitCode=0;
  try {
    exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
  String lang=System.getProperty(ITConstants.IT_LANG);
  if (exitCode == 0 && lang.equalsIgnoreCase(ITConstants.Lang.PYTHON.name())) {
    try {
      new TraceMerger(System.getProperty(ITConstants.IT_APP_LOG_DIR),appName).merge();
    }
 catch (    IOException e) {
      ErrorManager.warn(""String_Node_Str"",e);
    }
  }
}","private static void generateTrace(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  String appName=System.getProperty(ITConstants.IT_APP_NAME);
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",System.getProperty(ITConstants.IT_APP_LOG_DIR),appName,String.valueOf(hostToSlots.size() + 1));
  Process p;
  pb.environment().remove(LD_PRELOAD);
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out,logger);
  StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err,logger);
  outputGobbler.start();
  errorGobbler.start();
  int exitCode=0;
  try {
    exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
  String lang=System.getProperty(ITConstants.IT_LANG);
  if (exitCode == 0 && lang.equalsIgnoreCase(ITConstants.Lang.PYTHON.name())) {
    try {
      new TraceMerger(System.getProperty(ITConstants.IT_APP_LOG_DIR),appName).merge();
    }
 catch (    IOException e) {
      ErrorManager.warn(""String_Node_Str"",e);
    }
  }
}"
70373,"private static void generateMasterPackage(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pb.environment().remove(LD_PRELOAD);
  Process p;
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  if (debug) {
    StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out);
    StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err);
    outputGobbler.start();
    errorGobbler.start();
  }
  try {
    int exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
}","private static void generateMasterPackage(){
  if (debug) {
    logger.debug(""String_Node_Str"");
  }
  String script=System.getenv(ITConstants.IT_HOME) + TRACE_SCRIPT_PATH;
  ProcessBuilder pb=new ProcessBuilder(script,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  pb.environment().remove(LD_PRELOAD);
  Process p;
  try {
    p=pb.start();
  }
 catch (  IOException e) {
    ErrorManager.warn(""String_Node_Str"",e);
    return;
  }
  if (debug) {
    StreamGobbler outputGobbler=new StreamGobbler(p.getInputStream(),System.out,logger);
    StreamGobbler errorGobbler=new StreamGobbler(p.getErrorStream(),System.err,logger);
    outputGobbler.start();
    errorGobbler.start();
  }
  try {
    int exitCode=p.waitFor();
    if (exitCode != 0) {
      ErrorManager.warn(""String_Node_Str"" + exitCode);
    }
  }
 catch (  InterruptedException e) {
    ErrorManager.warn(""String_Node_Str"" + e.getMessage());
  }
}"
70374,"/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param hasReturn
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,boolean hasReturn,StreamSTD streamValues,File taskSandboxWorkingDir) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    exitValue=process.waitFor();
  }
 catch (  Exception e) {
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
 finally {
    logBinaryExecution(process,exitValue,fileOutPath,fileErrPath);
  }
  return hasReturn ? exitValue : null;
}","/** 
 * Executes a given command @cmd with the stream redirections @streamValues
 * @param cmd
 * @param hasReturn
 * @param streamValues
 * @return
 * @throws InvokeExecutionException
 */
public static Object executeCMD(String[] cmd,boolean hasReturn,StreamSTD streamValues,File taskSandboxWorkingDir) throws InvokeExecutionException {
  ProcessBuilder builder=new ProcessBuilder(cmd);
  builder.directory(taskSandboxWorkingDir);
  builder.environment().remove(Tracer.LD_PRELOAD);
  String fileInPath=streamValues.getStdIn();
  if (fileInPath != null) {
    builder.redirectInput(new File(fileInPath));
  }
  String fileOutPath=streamValues.getStdOut();
  if (fileOutPath != null) {
    builder.redirectOutput(Redirect.appendTo(new File(fileOutPath)));
  }
  String fileErrPath=streamValues.getStdErr();
  if (fileErrPath != null) {
    builder.redirectError(Redirect.appendTo(new File(fileErrPath)));
  }
  Process process=null;
  int exitValue=-1;
  try {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    process=builder.start();
    exitValue=process.waitFor();
  }
 catch (  Exception e) {
    throw new InvokeExecutionException(ERROR_PROC_EXEC,e);
  }
 finally {
    logBinaryExecution(process,exitValue,fileOutPath,fileErrPath);
  }
  return hasReturn ? exitValue : null;
}"
70375,"private static void logBinaryExecution(Process process,int exitValue,String fileOutPath,String fileErrPath) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + exitValue);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader outputReader=(fileOutPath != null) ? new BufferedReader(new FileReader(fileOutPath)) : new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=outputReader.readLine()) != null) {
        System.out.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
    }
  }
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader errorReader=(fileErrPath != null) ? new BufferedReader(new FileReader(fileErrPath)) : new BufferedReader(new InputStreamReader(process.getErrorStream()))){
      String line=null;
      while ((line=errorReader.readLine()) != null) {
        System.err.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_ERRORREADER,ioe);
    }
  }
}","private static void logBinaryExecution(Process process,int exitValue,String fileOutPath,String fileErrPath) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + exitValue);
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader outputReader=(fileOutPath != null) ? new BufferedReader(new FileReader(fileOutPath)) : new BufferedReader(new InputStreamReader(process.getInputStream()))){
      String line=null;
      while ((line=outputReader.readLine()) != null) {
        System.out.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_OUTPUTREADER,ioe);
    }
  }
  System.out.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  if (process != null) {
    try (BufferedReader errorReader=(fileErrPath != null) ? new BufferedReader(new FileReader(fileErrPath)) : new BufferedReader(new InputStreamReader(process.getErrorStream()))){
      String line=null;
      while ((line=errorReader.readLine()) != null) {
        System.err.println(line);
      }
    }
 catch (    IOException ioe) {
      throw new InvokeExecutionException(ERROR_ERRORREADER,ioe);
    }
  }
  System.err.println(""String_Node_Str"");
}"
70376,"public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numNodes;
  cmd[5]=""String_Node_Str"";
  cmd[6]=""String_Node_Str"";
  cmd[7]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}","public static Object invokeMPIMethod(String mpiRunner,String mpiBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mpiBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String workers=System.getProperty(Constants.COMPSS_HOSTNAMES);
  String numNodes=System.getProperty(Constants.COMPSS_NUM_NODES);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  String numProcs=String.valueOf(Integer.valueOf(numNodes) * Integer.valueOf(computingUnits));
  System.out.println(""String_Node_Str"" + workers);
  System.out.println(""String_Node_Str"" + numNodes);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_MPI_ARGS + binaryParams.size()];
  cmd[0]=mpiRunner;
  cmd[1]=""String_Node_Str"";
  cmd[2]=workers;
  cmd[3]=""String_Node_Str"";
  cmd[4]=numProcs;
  cmd[5]=""String_Node_Str"";
  cmd[6]=""String_Node_Str"";
  cmd[7]=mpiBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_MPI_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}"
70377,"public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}","public static Object invokeOmpSsMethod(String ompssBinary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ompssBinary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  String computingUnits=System.getProperty(Constants.COMPSS_NUM_THREADS);
  System.out.println(""String_Node_Str"" + computingUnits);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_OMPSS_ARGS + binaryParams.size()];
  cmd[0]=ompssBinary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_OMPSS_ARGS + i]=binaryParams.get(i);
  }
  System.setProperty(OMP_NUM_THREADS,computingUnits);
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}"
70378,"public static Object invokeBinaryMethod(String binary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}","public static Object invokeBinaryMethod(String binary,Object[] values,boolean hasReturn,Stream[] streams,String[] prefixes,File taskSandboxWorkingDir) throws InvokeExecutionException {
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + binary);
  System.out.println(""String_Node_Str"" + taskSandboxWorkingDir.getAbsolutePath());
  StreamSTD streamValues=new StreamSTD();
  ArrayList<String> binaryParams=BinaryRunner.createCMDParametersFromValues(values,streams,prefixes,streamValues);
  String[] cmd=new String[NUM_BASE_BINARY_ARGS + binaryParams.size()];
  cmd[0]=binary;
  for (int i=0; i < binaryParams.size(); ++i) {
    cmd[NUM_BASE_BINARY_ARGS + i]=binaryParams.get(i);
  }
  System.out.print(""String_Node_Str"");
  for (int i=0; i < cmd.length; ++i) {
    System.out.print(cmd[i] + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + streamValues.getStdIn());
  System.out.println(""String_Node_Str"" + streamValues.getStdOut());
  System.out.println(""String_Node_Str"" + streamValues.getStdErr());
  return BinaryRunner.executeCMD(cmd,hasReturn,streamValues,taskSandboxWorkingDir);
}"
70379,"private JobDescription prepareJob() throws Exception {
  TaskDescription taskParams=this.taskParams;
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  ArrayList<String> symlinks=new ArrayList<String>();
  ArrayList<String> paramArgs=new ArrayList<String>();
  String sandboxDir=getResourceNode().getWorkingDir() + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ this.jobId;
  processParameters(sandboxDir,symlinks,paramArgs);
  lArgs.add(sandboxDir);
  if (symlinks.size() > 0) {
    lArgs.add(""String_Node_Str"" + symlinks.size());
    lArgs.addAll(symlinks);
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Boolean.toString(Tracer.isActivated()));
  lArgs.add(getHostName());
  if (debug) {
    logger.debug(""String_Node_Str"" + getHostName());
  }
  if (Tracer.isActivated()) {
    lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
    lArgs.add(String.valueOf(this.taskParams.getId() + 1));
    int slot=Tracer.getNextSlot(targetHost);
    lArgs.add(String.valueOf(slot));
    sd.addAttribute(""String_Node_Str"",slot);
  }
  lArgs.add(sandboxDir);
  lArgs.add(getResourceNode().getAppDir());
  lArgs.add(getClasspath());
  lArgs.add(getPythonpath());
  lArgs.add(String.valueOf(debug));
  lArgs.add(STORAGE_CONF);
  AbstractMethodImplementation absImpl=(AbstractMethodImplementation)this.impl;
  lArgs.add(String.valueOf(absImpl.getMethodType()));
switch (absImpl.getMethodType()) {
case METHOD:
    MethodImplementation methodImpl=(MethodImplementation)absImpl;
  lArgs.add(methodImpl.getDeclaringClass());
String methodName=methodImpl.getAlternativeMethodName();
if (methodName == null || methodName.isEmpty()) {
methodName=taskParams.getName();
}
lArgs.add(methodName);
break;
case MPI:
MPIImplementation mpiImpl=(MPIImplementation)absImpl;
lArgs.add(mpiImpl.getMpiRunner());
lArgs.add(mpiImpl.getBinary());
break;
case OMPSS:
OmpSsImplementation ompssImpl=(OmpSsImplementation)absImpl;
lArgs.add(ompssImpl.getBinary());
break;
case OPENCL:
OpenCLImplementation openclImpl=(OpenCLImplementation)absImpl;
lArgs.add(openclImpl.getKernel());
break;
case BINARY:
BinaryImplementation binaryImpl=(BinaryImplementation)absImpl;
lArgs.add(binaryImpl.getBinary());
break;
}
lArgs.add(String.valueOf(slaveWorkersNodeNames.size()));
lArgs.addAll(slaveWorkersNodeNames);
lArgs.add(String.valueOf(((MethodResourceDescription)this.impl.getRequirements()).getTotalCPUComputingUnits()));
lArgs.addAll(paramArgs);
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ absImpl.getMethodDefinition()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,absImpl.getRequirements().getWallClockLimit());
if (absImpl.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,absImpl.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalCPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalGPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalFPGAComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,absImpl.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI.getSchema() + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}","private JobDescription prepareJob() throws Exception {
  TaskDescription taskParams=this.taskParams;
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  boolean isSpecific=false;
  String sandboxDir=null;
  AbstractMethodImplementation absImpl=(AbstractMethodImplementation)this.impl;
switch (absImpl.getMethodType()) {
case BINARY:
    BinaryImplementation binaryImpl=(BinaryImplementation)absImpl;
  sandboxDir=binaryImpl.getWorkingDir();
isSpecific=true;
break;
case MPI:
MPIImplementation mpiImpl=(MPIImplementation)absImpl;
sandboxDir=mpiImpl.getWorkingDir();
isSpecific=true;
break;
case OMPSS:
OmpSsImplementation ompssImpl=(OmpSsImplementation)absImpl;
sandboxDir=ompssImpl.getWorkingDir();
isSpecific=true;
break;
case OPENCL:
OpenCLImplementation openclImpl=(OpenCLImplementation)absImpl;
sandboxDir=openclImpl.getWorkingDir();
isSpecific=true;
break;
case METHOD:
sandboxDir=null;
break;
}
if (sandboxDir == null || sandboxDir.isEmpty() || sandboxDir.equals(Constants.UNASSIGNED)) {
sandboxDir=getResourceNode().getWorkingDir() + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ this.jobId;
isSpecific=false;
}
ArrayList<String> symlinks=new ArrayList<>();
ArrayList<String> paramArgs=new ArrayList<>();
processParameters(sandboxDir,symlinks,paramArgs);
lArgs.add(Boolean.toString(isSpecific));
lArgs.add(sandboxDir);
if (symlinks.size() > 0) {
lArgs.add(String.valueOf(symlinks.size()));
lArgs.addAll(symlinks);
}
 else {
lArgs.add(""String_Node_Str"");
}
lArgs.add(Boolean.toString(Tracer.isActivated()));
lArgs.add(getHostName());
if (debug) {
logger.debug(""String_Node_Str"" + getHostName());
}
if (Tracer.isActivated()) {
lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
lArgs.add(String.valueOf(this.taskParams.getId() + 1));
int slot=Tracer.getNextSlot(targetHost);
lArgs.add(String.valueOf(slot));
sd.addAttribute(""String_Node_Str"",slot);
}
lArgs.add(sandboxDir);
lArgs.add(getResourceNode().getAppDir());
lArgs.add(getClasspath());
lArgs.add(getPythonpath());
lArgs.add(String.valueOf(debug));
lArgs.add(STORAGE_CONF);
lArgs.add(String.valueOf(absImpl.getMethodType()));
switch (absImpl.getMethodType()) {
case METHOD:
MethodImplementation methodImpl=(MethodImplementation)absImpl;
lArgs.add(methodImpl.getDeclaringClass());
String methodName=methodImpl.getAlternativeMethodName();
if (methodName == null || methodName.isEmpty()) {
methodName=taskParams.getName();
}
lArgs.add(methodName);
break;
case MPI:
MPIImplementation mpiImpl=(MPIImplementation)absImpl;
lArgs.add(mpiImpl.getMpiRunner());
lArgs.add(mpiImpl.getBinary());
break;
case OMPSS:
OmpSsImplementation ompssImpl=(OmpSsImplementation)absImpl;
lArgs.add(ompssImpl.getBinary());
break;
case OPENCL:
OpenCLImplementation openclImpl=(OpenCLImplementation)absImpl;
lArgs.add(openclImpl.getKernel());
break;
case BINARY:
BinaryImplementation binaryImpl=(BinaryImplementation)absImpl;
lArgs.add(binaryImpl.getBinary());
break;
}
lArgs.add(String.valueOf(slaveWorkersNodeNames.size()));
lArgs.addAll(slaveWorkersNodeNames);
lArgs.add(String.valueOf(((MethodResourceDescription)this.impl.getRequirements()).getTotalCPUComputingUnits()));
lArgs.addAll(paramArgs);
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ absImpl.getMethodDefinition()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,absImpl.getRequirements().getWallClockLimit());
if (absImpl.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,absImpl.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalCPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalGPUComputingUnits());
sd.addAttribute(""String_Node_Str"",absImpl.getRequirements().getTotalFPGAComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,absImpl.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI.getSchema() + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI.getSchema() + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}"
70380,"/** 
 * Communications initializer
 */
public static synchronized void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}","/** 
 * Communications initializer
 */
public static void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}"
70381,"/** 
 * Return the active adaptors
 * @return
 */
public static synchronized HashMap<String,CommAdaptor> getAdaptors(){
  return adaptors;
}","/** 
 * Return the active adaptors
 * @return
 */
public static Map<String,CommAdaptor> getAdaptors(){
  return adaptors;
}"
70382,"/** 
 * Stops all the submitted jobs
 */
public static synchronized void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}","/** 
 * Stops all the submitted jobs
 */
public static void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}"
70383,"/** 
 * Initializes the internal adaptor and constructs a comm configuration
 * @param adaptorName
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws ConstructConfigurationException
 */
public static synchronized Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws ConstructConfigurationException {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    try {
      Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
      adaptor=(CommAdaptor)constrAdaptor.newInstance();
    }
 catch (    NoSuchMethodException|SecurityException|ClassNotFoundException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
      throw new ConstructConfigurationException(e);
    }
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}","/** 
 * Initializes the internal adaptor and constructs a comm configuration
 * @param adaptorName
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws ConstructConfigurationException
 */
public static Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws ConstructConfigurationException {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    try {
      Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
      adaptor=(CommAdaptor)constrAdaptor.newInstance();
    }
 catch (    NoSuchMethodException|SecurityException|ClassNotFoundException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
      throw new ConstructConfigurationException(e);
    }
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}"
70384,"/** 
 * Initializes a worker with name @name and configuration @config
 * @param name
 * @param config
 * @return
 */
public static synchronized COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}","/** 
 * Initializes a worker with name @name and configuration @config
 * @param name
 * @param config
 * @return
 */
public static COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}"
70385,"/** 
 * Returns all the data stored in a host @host
 * @param host
 * @return
 */
public static synchronized HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}","/** 
 * Returns all the data stored in a host @host
 * @param host
 * @return
 */
public static HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}"
70386,"/** 
 * Stops the communication layer.  Clean FTM, Job, {GATJob, NIOJob} and WSJob
 */
public static synchronized void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}","/** 
 * Stops the communication layer.  Clean FTM, Job, {GATJob, NIOJob} and WSJob
 */
public static void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}"
70387,"public void perform(){
  Resource targetHost=tgtLoc.getHosts().getFirst();
  logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ tgtLoc);
synchronized (srcData) {
    if (tgtData != null) {
      MultiURI u;
      if ((u=srcData.alreadyAvailable(targetHost)) != null) {
        setFinalTarget(u.getPath());
        end(DataOperation.OpEndState.OP_OK);
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ targetHost+ ""String_Node_Str""+ u.getPath());
        return;
      }
      Copy copyInProgress=null;
      if ((copyInProgress=srcData.alreadyCopying(tgtLoc)) != null) {
        String path=copyInProgress.tgtLoc.getURIInHost(targetHost).getPath();
        setFinalTarget(path);
        end(DataOperation.OpEndState.OP_IN_PROGRESS);
synchronized (copyInProgress.getEventListeners()) {
          copyInProgress.addEventListeners(getEventListeners());
        }
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ path+ ""String_Node_Str"");
        return;
      }
    }
    srcData.startCopy(this,tgtLoc);
  }
  try {
    specificCopy();
  }
 catch (  CopyException e) {
    end(DataOperation.OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    DataLocation actualLocation;
synchronized (srcData) {
      actualLocation=srcData.finishedCopy(this);
    }
    if (tgtData != null) {
synchronized (tgtData) {
        tgtData.addLocation(actualLocation);
      }
    }
  }
  String path=tgtLoc.getURIInHost(targetHost).getPath();
  setFinalTarget(path);
synchronized (srcData) {
    end(DataOperation.OpEndState.OP_OK);
  }
  logger.debug(""String_Node_Str"" + getName());
}","public void perform(){
  Resource targetHost=tgtLoc.getHosts().getFirst();
  logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ tgtLoc);
synchronized (srcData) {
    if (tgtData != null) {
      MultiURI u;
      if ((u=srcData.alreadyAvailable(targetHost)) != null) {
        setFinalTarget(u.getPath());
        end(DataOperation.OpEndState.OP_OK);
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ getName()+ ""String_Node_Str""+ targetHost+ ""String_Node_Str""+ u.getPath());
        return;
      }
      Copy copyInProgress=null;
      if ((copyInProgress=srcData.alreadyCopying(tgtLoc)) != null) {
        String path=copyInProgress.tgtLoc.getURIInHost(targetHost).getPath();
        setFinalTarget(path);
        end(DataOperation.OpEndState.OP_IN_PROGRESS);
synchronized (copyInProgress.getEventListeners()) {
          copyInProgress.addEventListeners(getEventListeners());
        }
        logger.debug(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ path+ ""String_Node_Str"");
        return;
      }
    }
    srcData.startCopy(this,tgtLoc);
  }
  try {
    logger.debug(""String_Node_Str"" + getName());
    specificCopy();
  }
 catch (  CopyException e) {
    end(DataOperation.OpEndState.OP_FAILED,e);
    return;
  }
 finally {
    DataLocation actualLocation;
synchronized (srcData) {
      actualLocation=srcData.finishedCopy(this);
    }
    if (tgtData != null) {
synchronized (tgtData) {
        tgtData.addLocation(actualLocation);
      }
    }
  }
  String path=tgtLoc.getURIInHost(targetHost).getPath();
  setFinalTarget(path);
synchronized (srcData) {
    end(DataOperation.OpEndState.OP_OK);
  }
  logger.debug(""String_Node_Str"" + getName() + ""String_Node_Str"");
}"
70388,"public MultiURI(Protocol protocol,Resource host,String path){
  this.protocol=protocol;
  this.host=host;
  this.path=path;
  this.internal=new HashMap<>();
}","public MultiURI(Protocol protocol,Resource host,String path){
  this.protocol=protocol;
  this.host=host;
  this.path=path;
  this.internal=new HashMap<>();
  try {
    host.setInternalURI(this);
  }
 catch (  UnstartedNodeException e) {
    e.printStackTrace();
  }
}"
70389,"public String debugString(){
  StringBuilder sb=new StringBuilder(this.protocol.getSchema() + this.host.toString() + File.separator+ this.path+ ""String_Node_Str"");
  for (  Entry<String,Object> e : internal.entrySet()) {
    sb.append(""String_Node_Str"").append(e.getKey()).append(""String_Node_Str"").append(e.getValue()).append(""String_Node_Str"");
  }
  return sb.toString();
}","public String debugString(){
  StringBuilder sb=new StringBuilder(this.protocol.getSchema() + this.host.getName() + File.separator+ this.path+ ""String_Node_Str"");
  for (  Entry<String,Object> e : internal.entrySet()) {
    sb.append(""String_Node_Str"").append(e.getKey()).append(""String_Node_Str"").append(e.getValue()).append(""String_Node_Str"");
  }
  return sb.toString();
}"
70390,"public Object getInternalURI(String adaptor) throws UnstartedNodeException {
  Object o=internal.get(adaptor);
  if (o == null) {
    host.setInternalURI(this);
    o=internal.get(adaptor);
  }
  return o;
}","public Object getInternalURI(String adaptor) throws UnstartedNodeException {
  Object o=internal.get(adaptor);
  return o;
}"
70391,"@Override public void specificCopy() throws CopyException {
  logger.debug(DBG_PREFIX + ""String_Node_Str"" + getName());
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<>();
  for (  MultiURI uri : targetURIs) {
    try {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedTargetURIs.add(internalURI);
      }
    }
 catch (    UnstartedNodeException une) {
      throw new GATCopyException(une);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    logger.error(DBG_PREFIX + ERR_NO_TGT_URI);
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        try {
          URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
          if (internalURI != null) {
            selectedSourceURIs.add(internalURI);
          }
        }
 catch (        UnstartedNodeException une) {
          throw new GATCopyException(une);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      try {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
 catch (      UnstartedNodeException une) {
        throw new GATCopyException(une);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        logger.warn(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"",exception);
  }
  throw new GATCopyException(exception);
}","@Override public void specificCopy() throws CopyException {
  logger.debug(DBG_PREFIX + ""String_Node_Str"" + getName());
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<>();
  for (  MultiURI uri : targetURIs) {
    try {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedTargetURIs.add(internalURI);
      }
    }
 catch (    UnstartedNodeException une) {
      throw new GATCopyException(une);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    logger.error(DBG_PREFIX + ERR_NO_TGT_URI);
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  logger.debug(DBG_PREFIX + ""String_Node_Str"");
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        try {
          URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
          if (internalURI != null) {
            selectedSourceURIs.add(internalURI);
          }
        }
 catch (        UnstartedNodeException une) {
          logger.error(DBG_PREFIX + ""String_Node_Str"");
          throw new GATCopyException(une);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      try {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
 catch (      UnstartedNodeException une) {
        logger.error(DBG_PREFIX + ""String_Node_Str"" + getName());
        throw new GATCopyException(une);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        logger.debug(""String_Node_Str"" + getName() + ""String_Node_Str"");
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        logger.error(DBG_PREFIX + ERR_NO_SRC_URI);
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        logger.warn(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"",exception);
  }
  throw new GATCopyException(exception);
}"
70392,"public static synchronized void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}","/** 
 * Communications initializer
 */
public static synchronized void init(){
  appHost=new MasterResource();
  try {
    if (STORAGE_CONF == null || STORAGE_CONF.equals(""String_Node_Str"") || STORAGE_CONF.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
    }
 else {
      logger.debug(""String_Node_Str"" + STORAGE_CONF);
      StorageItf.init(STORAGE_CONF);
    }
  }
 catch (  StorageException e) {
    logger.fatal(""String_Node_Str"" + STORAGE_CONF,e);
    System.exit(1);
  }
  loadAdaptorsJars();
  if (System.getProperty(ITConstants.IT_TRACING) != null && Integer.parseInt(System.getProperty(ITConstants.IT_TRACING)) > 0) {
    logger.debug(""String_Node_Str"");
    int tracing_level=Integer.parseInt(System.getProperty(ITConstants.IT_TRACING));
    Tracer.init(tracing_level);
    Tracer.emitEvent(Tracer.Event.STATIC_IT.getId(),Tracer.Event.STATIC_IT.getType());
  }
}"
70393,"public static synchronized LogicalData registerPSCO(String dataId,String id){
  String targetPath=Protocol.PERSISTENT_URI.getSchema() + id;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}","/** 
 * Registers a new PSCO id @id for the data with id @dataId dataId must exist
 * @param dataId
 * @param id
 * @return
 */
public static synchronized LogicalData registerPSCO(String dataId,String id){
  String targetPath=Protocol.PERSISTENT_URI.getSchema() + id;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}"
70394,"public static synchronized LogicalData registerData(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=new LogicalData(dataId);
  data.put(dataId,logicalData);
  return logicalData;
}","/** 
 * Registers a new data with id @dataId
 * @param dataId
 * @return
 */
public static synchronized LogicalData registerData(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=new LogicalData(dataId);
  data.put(dataId,logicalData);
  return logicalData;
}"
70395,"public static synchronized String dataDump(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (  Map.Entry<String,LogicalData> lde : data.entrySet()) {
    sb.append(""String_Node_Str"").append(lde.getKey()).append(""String_Node_Str"");
    LogicalData ld=lde.getValue();
    for (    MultiURI u : ld.getURIs()) {
      sb.append(""String_Node_Str"").append(u.toString()).append(""String_Node_Str"");
      for (      String adaptor : adaptors.keySet()) {
        Object internal=null;
        try {
          internal=u.getInternalURI(adaptor);
          if (internal != null) {
            sb.append(""String_Node_Str"").append(internal.toString()).append(""String_Node_Str"");
          }
        }
 catch (        UnstartedNodeException une) {
        }
      }
    }
  }
  return sb.toString();
}","/** 
 * Dumps the stored data (only for testing)
 * @return
 */
public static synchronized String dataDump(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  for (  Map.Entry<String,LogicalData> lde : data.entrySet()) {
    sb.append(""String_Node_Str"").append(lde.getKey()).append(""String_Node_Str"");
    LogicalData ld=lde.getValue();
    for (    MultiURI u : ld.getURIs()) {
      sb.append(""String_Node_Str"").append(u.toString()).append(""String_Node_Str"");
      for (      String adaptor : adaptors.keySet()) {
        Object internal=null;
        try {
          internal=u.getInternalURI(adaptor);
          if (internal != null) {
            sb.append(""String_Node_Str"").append(internal.toString()).append(""String_Node_Str"");
          }
        }
 catch (        UnstartedNodeException une) {
        }
      }
    }
  }
  return sb.toString();
}"
70396,"public static MasterResource getAppHost(){
  return appHost;
}","/** 
 * Returns the resource assigned as master node
 * @return
 */
public static MasterResource getAppHost(){
  return appHost;
}"
70397,"public static synchronized HashMap<String,CommAdaptor> getAdaptors(){
  return adaptors;
}","/** 
 * Return the active adaptors
 * @return
 */
public static synchronized HashMap<String,CommAdaptor> getAdaptors(){
  return adaptors;
}"
70398,"public static synchronized void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}","/** 
 * Stops all the submitted jobs
 */
public static synchronized void stopSubmittedjobs(){
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stopSubmittedJobs();
  }
}"
70399,"public static synchronized Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws Exception {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
    adaptor=(CommAdaptor)constrAdaptor.newInstance();
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}","/** 
 * Initializes the internal adaptor and constructs a comm configuration
 * @param adaptorName
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws ConstructConfigurationException
 */
public static synchronized Configuration constructConfiguration(String adaptorName,Object project_properties,Object resources_properties) throws ConstructConfigurationException {
  CommAdaptor adaptor=adaptors.get(adaptorName);
  if (adaptor == null) {
    try {
      Constructor<?> constrAdaptor=Class.forName(adaptorName).getConstructor();
      adaptor=(CommAdaptor)constrAdaptor.newInstance();
    }
 catch (    NoSuchMethodException|SecurityException|ClassNotFoundException|InstantiationException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
      throw new ConstructConfigurationException(e);
    }
    adaptor.init();
    adaptors.put(adaptorName,adaptor);
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + adaptorName);
  }
  return adaptor.constructConfiguration(project_properties,resources_properties);
}"
70400,"public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  if (value instanceof StubItf) {
    String id=((StubItf)value).getID();
    if (id != null) {
      Comm.registerPSCO(dataId,id);
    }
  }
  return logicalData;
}","/** 
 * Registers a new value @value for the data with id @dataId dataId must exist
 * @param dataId
 * @param value
 * @return
 */
public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  if (value instanceof StubItf) {
    String id=((StubItf)value).getID();
    if (id != null) {
      Comm.registerPSCO(dataId,id);
    }
  }
  return logicalData;
}"
70401,"public static synchronized Object clearValue(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=data.get(dataId);
  return logicalData.removeValue();
}","/** 
 * Clears the value of the data id @dataId
 * @param dataId
 * @return
 */
public static synchronized Object clearValue(String dataId){
  logger.debug(""String_Node_Str"" + dataId);
  LogicalData logicalData=data.get(dataId);
  return logicalData.removeValue();
}"
70402,"public static synchronized COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}","/** 
 * Initializes a worker with name @name and configuration @config
 * @param name
 * @param config
 * @return
 */
public static synchronized COMPSsWorker initWorker(String name,Configuration config){
  String adaptorName=config.getAdaptorName();
  CommAdaptor adaptor=adaptors.get(adaptorName);
  return adaptor.initWorker(name,config);
}"
70403,"public static synchronized LogicalData registerLocation(String dataId,DataLocation location){
  logger.debug(""String_Node_Str"" + dataId + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + location);
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}","/** 
 * Registers a new location @location for the data with id @dataId dataId must exist
 * @param dataId
 * @param location
 * @return
 */
public static synchronized LogicalData registerLocation(String dataId,DataLocation location){
  logger.debug(""String_Node_Str"" + dataId + ""String_Node_Str"");
  logger.debug(""String_Node_Str"" + location);
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  return logicalData;
}"
70404,"public static synchronized HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}","/** 
 * Returns all the data stored in a host @host
 * @param host
 * @return
 */
public static synchronized HashSet<LogicalData> getAllData(Resource host){
  return host.getAllDataFromHost();
}"
70405,"public static synchronized void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}","/** 
 * Stops the communication layer.  Clean FTM, Job, {GATJob, NIOJob} and WSJob
 */
public static synchronized void stop(){
  appHost.deleteIntermediate();
  for (  CommAdaptor adaptor : adaptors.values()) {
    adaptor.stop();
  }
  if (STORAGE_CONF != null && !STORAGE_CONF.equals(""String_Node_Str"") && !STORAGE_CONF.equals(""String_Node_Str"")) {
    try {
      logger.debug(""String_Node_Str"");
      StorageItf.finish();
    }
 catch (    StorageException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  if (Tracer.isActivated()) {
    Tracer.emitEvent(Tracer.EVENT_END,Tracer.getRuntimeEventsType());
    Tracer.fini();
  }
}"
70406,"public static synchronized boolean existsData(String renaming){
  return (data.get(renaming) != null);
}","/** 
 * Checks if a given dataId @renaming exists
 * @param renaming
 * @return
 */
public static synchronized boolean existsData(String renaming){
  return (data.get(renaming) != null);
}"
70407,"public static synchronized void removeData(String renaming){
  logger.debug(""String_Node_Str"" + renaming);
  LogicalData ld=data.remove(renaming);
  ld.isObsolete();
  for (  DataLocation dl : ld.getLocations()) {
    MultiURI uri=dl.getURIInHost(appHost);
    if (uri != null) {
      File f=new File(uri.getPath());
      if (f.exists()) {
        logger.info(""String_Node_Str"" + f.getAbsolutePath());
        if (!f.delete()) {
          logger.error(""String_Node_Str"" + f.getAbsolutePath());
        }
      }
    }
  }
}","/** 
 * Removes the data with id @renaming
 * @param renaming
 */
public static synchronized void removeData(String renaming){
  logger.debug(""String_Node_Str"" + renaming);
  LogicalData ld=data.remove(renaming);
  ld.isObsolete();
  for (  DataLocation dl : ld.getLocations()) {
    MultiURI uri=dl.getURIInHost(appHost);
    if (uri != null) {
      File f=new File(uri.getPath());
      if (f.exists()) {
        logger.info(""String_Node_Str"" + f.getAbsolutePath());
        if (!f.delete()) {
          logger.error(""String_Node_Str"" + f.getAbsolutePath());
        }
      }
    }
  }
}"
70408,"public static synchronized LogicalData getData(String dataId){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + data.get(dataId));
  }
  return data.get(dataId);
}","/** 
 * Returns the data with id @dataId
 * @param dataId
 * @return
 */
public static synchronized LogicalData getData(String dataId){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + data.get(dataId));
  }
  return data.get(dataId);
}"
70409,"/** 
 * Creates a configuration instance for the specific adaptor
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws Exception
 */
public Configuration constructConfiguration(Object project_properties,Object resources_properties) throws Exception ;","/** 
 * Creates a configuration instance for the specific adaptor
 * @param project_properties
 * @param resources_properties
 * @return
 * @throws Exception
 */
public Configuration constructConfiguration(Object project_properties,Object resources_properties) throws ConstructConfigurationException ;"
70410,"public void setWorkingDir(String workingDir){
  if (workingDir == null) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (workingDir.isEmpty()) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (!workingDir.endsWith(File.separator)) {
    this.workingDir=workingDir + File.separator;
  }
 else {
    this.workingDir=workingDir;
  }
}","public void setWorkingDir(String workingDir){
  if (workingDir == null) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (workingDir.isEmpty()) {
    this.workingDir=File.separator + ""String_Node_Str"" + File.separator;
  }
 else   if (!workingDir.endsWith(File.separator)) {
    this.workingDir=workingDir + File.separator;
  }
 else {
    this.workingDir=workingDir;
  }
  String host=this.getHost().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
  String sandboxWorkingDir=this.getWorkingDir() + DEPLOYMENT_ID + File.separator+ host+ File.separator;
  this.setSandboxWorkingDir(sandboxWorkingDir);
}"
70411,"@Override public void specificCopy() throws Exception {
  logger.debug(""String_Node_Str"");
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<URI>();
  for (  MultiURI uri : targetURIs) {
    URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
    if (internalURI != null) {
      selectedTargetURIs.add(internalURI);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<URI>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedSourceURIs.add(internalURI);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"");
  }
  throw exception;
}","@Override public void specificCopy() throws Exception {
  logger.debug(""String_Node_Str"");
  LinkedList<MultiURI> targetURIs=tgtLoc.getURIs();
  LinkedList<URI> selectedTargetURIs=new LinkedList<URI>();
  for (  MultiURI uri : targetURIs) {
    URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
    if (internalURI != null) {
      selectedTargetURIs.add(internalURI);
    }
  }
  if (selectedTargetURIs.isEmpty()) {
    throw new GATCopyException(ERR_NO_TGT_URI);
  }
  LinkedList<MultiURI> sourceURIs;
  LinkedList<URI> selectedSourceURIs=new LinkedList<URI>();
synchronized (srcData) {
    if (srcLoc != null) {
      sourceURIs=srcLoc.getURIs();
      for (      MultiURI uri : sourceURIs) {
        URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
        if (internalURI != null) {
          selectedSourceURIs.add(internalURI);
        }
      }
    }
    sourceURIs=srcData.getURIs();
    for (    MultiURI uri : sourceURIs) {
      URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
      if (internalURI != null) {
        selectedSourceURIs.add(internalURI);
      }
    }
    if (selectedSourceURIs.isEmpty()) {
      if (srcData.isInMemory()) {
        try {
          srcData.writeToStorage();
          sourceURIs=srcData.getURIs();
          for (          MultiURI uri : sourceURIs) {
            URI internalURI=(URI)uri.getInternalURI(GATAdaptor.ID);
            if (internalURI != null) {
              selectedSourceURIs.add(internalURI);
            }
          }
        }
 catch (        Exception e) {
          logger.fatal(""String_Node_Str"",e);
          throw new GATCopyException(ERR_NO_SRC_URI);
        }
      }
 else {
        throw new GATCopyException(ERR_NO_SRC_URI);
      }
    }
  }
  GATInvocationException exception=new GATInvocationException(""String_Node_Str"");
  for (  URI src : selectedSourceURIs) {
    for (    URI tgt : selectedTargetURIs) {
      try {
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + src + ""String_Node_Str""+ tgt);
        }
        URI gatSrc=new URI(DataLocation.Protocol.ANY_URI.getSchema() + src.getHost() + ""String_Node_Str""+ src.getPath());
        URI gatTgt=new URI(DataLocation.Protocol.ANY_URI.getSchema() + tgt.getHost() + ""String_Node_Str""+ tgt.getPath());
        if (logger.isDebugEnabled()) {
          logger.debug(""String_Node_Str"" + gatSrc + ""String_Node_Str""+ gatTgt);
        }
        doCopy(gatSrc,gatTgt);
      }
 catch (      Exception e) {
        exception.add(""String_Node_Str"",e);
        logger.debug(""String_Node_Str"",e);
        continue;
      }
      return;
    }
  }
  if (!(this.reason instanceof WorkersDebugInfoCopyTransferable)) {
    ErrorManager.error(""String_Node_Str"" + srcData.getName() + ""String_Node_Str"",exception);
  }
  throw exception;
}"
70412,"public static boolean generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  return new CleanerExecutor(node).executeScript(traceScripts,traceParams);
}","public static boolean generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  return new GATScriptExecutor(node).executeScript(traceScripts,traceParams,""String_Node_Str"" + host);
}"
70413,"@Override public void deleteTemporary(){
}","@Override public void deleteTemporary(){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=getHost();
  String installDir=getInstallDir();
  String workingDir=getWorkingDir();
  String user=getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ GAT_SCRIPT_PATH+ CLEANER_SCRIPT_NAME));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"" + workingDir + ""String_Node_Str""+ getName(),e);
    return;
  }
  String pars=workingDir;
  traceParams.add(pars);
  logger.debug(""String_Node_Str"" + workingDir + ""String_Node_Str""+ getName());
  boolean result=new GATScriptExecutor(this).executeScript(traceScripts,traceParams,""String_Node_Str"" + host);
  if (!result) {
    logger.error(""String_Node_Str"" + workingDir + ""String_Node_Str""+ getName());
  }
}"
70414,"@Override public void updateTaskCount(int processorCoreCount){
  if (GATTracer.isActivated()) {
    System.err.println(""String_Node_Str"");
  }
}","@Override public void updateTaskCount(int processorCoreCount){
  if (GATTracer.isActivated()) {
    logger.error(""String_Node_Str"");
  }
}"
70415,"@Override public void start() throws Exception {
  if (GATTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    tracingJob=GATTracer.startTracing(this);
    waitForTracingReady();
  }
}","@Override public void start() throws Exception {
  initWorkingDir();
  if (GATTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    tracingJob=GATTracer.startTracing(this);
    waitForTracingReady();
  }
}"
70416,"public String getWorkingDir(){
  return this.config.getWorkingDir();
}","public String getWorkingDir(){
  return this.config.getSandboxWorkingDir();
}"
70417,"@Override public void stop(ShutdownListener sl){
  try {
    File workingDirRoot=new File(this.config.getWorkingDir());
    for (    File c : workingDirRoot.listFiles()) {
      delete(c);
    }
  }
 catch (  FileNotFoundException e) {
    logger.warn(""String_Node_Str"" + e);
  }
  sl.notifyEnd();
}","@Override public void stop(ShutdownListener sl){
  try {
    String workingDir=this.config.getWorkingDir();
    if (workingDir != null || !workingDir.isEmpty()) {
      File workingDirRoot=new File(workingDir);
      if (workingDirRoot != null) {
        File[] filesInFolder=workingDirRoot.listFiles();
        if (filesInFolder != null) {
          for (          File c : filesInFolder) {
            delete(c);
          }
        }
      }
    }
  }
 catch (  FileNotFoundException e) {
    logger.warn(""String_Node_Str"" + e);
  }
  sl.notifyEnd();
}"
70418,"@Test public void loadIDLTest(){
  String constraintsFile=this.getClass().getResource(""String_Node_Str"").getPath();
  LinkedList<Integer> updatedMethods=new LinkedList<Integer>();
  HashMap<Integer,LinkedList<MethodImplementation>> readMethods=new HashMap<Integer,LinkedList<MethodImplementation>>();
  int coreCount=IDLParser.parseIDLMethods(updatedMethods,readMethods,constraintsFile);
  assertEquals(coreCount,CORECOUNT_RESULT);
  assertEquals(readMethods.size(),CORECOUNT_RESULT);
  System.out.println(""String_Node_Str"");
  LinkedList<MethodImplementation> implList=readMethods.get(0);
  assertNotNull(implList);
  MethodImplementation impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  Processor p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(p.getArchitecture(),""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(1);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE1_IMPLS_RESULT);
  impl=implList.get(0);
  assertEquals(impl.getRequirements().getMemorySize(),2.0f,0);
  assertEquals(impl.getRequirements().getStorageSize(),10.0f,0);
  impl=implList.get(1);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(impl.getRequirements().getMemorySize(),4.0f,0);
  impl=implList.get(2);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),1);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(2);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(3);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(4);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(impl.getRequirements().getProcessors().size(),COMPUTING_UNITS_RESULT);
  Processor p1=impl.getRequirements().getProcessors().get(0);
  Processor p2=impl.getRequirements().getProcessors().get(1);
  System.out.println(""String_Node_Str"");
  assertEquals(p1.getType(),""String_Node_Str"");
  assertEquals(p1.getComputingUnits(),2);
  assertEquals(p1.getArchitecture(),""String_Node_Str"");
  assertEquals(p1.getInternalMemory(),0.6f,0);
  System.out.println(""String_Node_Str"");
  assertEquals(p2.getType(),""String_Node_Str"");
  assertEquals(p2.getComputingUnits(),256);
  assertEquals(p2.getArchitecture(),""String_Node_Str"");
  assertEquals(p2.getInternalMemory(),0.024f,0);
}","@Test public void loadIDLTest(){
  String constraintsFile=this.getClass().getResource(""String_Node_Str"").getPath();
  LinkedList<Integer> updatedMethods=new LinkedList<Integer>();
  HashMap<Integer,LinkedList<MethodImplementation>> readMethods=new HashMap<Integer,LinkedList<MethodImplementation>>();
  int coreCount=IDLParser.parseIDLMethods(updatedMethods,readMethods,constraintsFile);
  assertEquals(coreCount,CORECOUNT_RESULT);
  assertEquals(readMethods.size(),CORECOUNT_RESULT);
  System.out.println(""String_Node_Str"");
  LinkedList<MethodImplementation> implList=readMethods.get(0);
  assertNotNull(implList);
  MethodImplementation impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  Processor p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(p.getArchitecture(),""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(1);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE1_IMPLS_RESULT);
  impl=implList.get(0);
  assertEquals(impl.getRequirements().getMemorySize(),2.0f,0);
  assertEquals(impl.getRequirements().getStorageSize(),10.0f,0);
  impl=implList.get(1);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),COMPUTING_UNITS_RESULT);
  assertEquals(impl.getRequirements().getMemorySize(),4.0f,0);
  impl=implList.get(2);
  p=impl.getRequirements().getProcessors().get(0);
  assertEquals(p.getComputingUnits(),1);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(2);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(3);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  System.out.println(""String_Node_Str"");
  implList=readMethods.get(4);
  assertNotNull(implList);
  System.out.println(""String_Node_Str"");
  assertEquals(implList.size(),CORE0_2_3_4_IMPLS_RESULT);
  impl=implList.get(0);
  System.out.println(""String_Node_Str"");
  assertEquals(impl.getRequirements().getProcessors().size(),PROCESSOR_COUNT);
  Processor p1=impl.getRequirements().getProcessors().get(0);
  Processor p2=impl.getRequirements().getProcessors().get(1);
  System.out.println(""String_Node_Str"");
  assertEquals(p1.getType(),""String_Node_Str"");
  assertEquals(p1.getComputingUnits(),2);
  assertEquals(p1.getArchitecture(),""String_Node_Str"");
  assertEquals(p1.getInternalMemory(),0.6f,0);
  System.out.println(""String_Node_Str"");
  assertEquals(p2.getType(),""String_Node_Str"");
  assertEquals(p2.getComputingUnits(),256);
  assertEquals(p2.getArchitecture(),""String_Node_Str"");
  assertEquals(p2.getInternalMemory(),0.024f,0);
}"
70419,"public void generateWorkersDebugInfo(){
}","public boolean generateWorkersDebugInfo(){
  return false;
}"
70420,"public void generatePackage(){
}","public boolean generatePackage(){
  return false;
}"
70421,public abstract void generateWorkersDebugInfo();,public abstract boolean generateWorkersDebugInfo();
70422,public abstract void generatePackage();,public abstract boolean generatePackage();
70423,"public void retrieveData(boolean saveUniqueData){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=getAllDataFromHost();
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=null;
      String safePath=Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + ld.getName();
      try {
        SimpleURI uri=new SimpleURI(safePath);
        safeLoc=DataLocation.createLocation(Comm.appHost,uri);
      }
 catch (      Exception e) {
        ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + safePath,e);
      }
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (Tracer.isActivated()) {
      node.generatePackage();
      getTracingPackageToMaster();
      if (debug) {
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
      logger.debug(""String_Node_Str"" + this.getName());
    }
  }
}","public void retrieveData(boolean saveUniqueData){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=getAllDataFromHost();
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=null;
      String safePath=Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + ld.getName();
      try {
        SimpleURI uri=new SimpleURI(safePath);
        safeLoc=DataLocation.createLocation(Comm.appHost,uri);
      }
 catch (      Exception e) {
        ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + safePath,e);
      }
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (Tracer.isActivated()) {
      if (node.generatePackage()) {
        getTracingPackageToMaster();
        if (debug) {
          logger.debug(""String_Node_Str"" + this.getName());
        }
      }
    }
    if (debug) {
      if (node.generateWorkersDebugInfo()) {
        getWorkersDebugInfo();
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
  }
}"
70424,"public void executeScript(List<URI> cleanScripts,List<String> cleanParams){
}","public boolean executeScript(List<URI> cleanScripts,List<String> cleanParams){
}"
70425,"public static void generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  new CleanerExecutor(node).executeScript(traceScripts,traceParams);
}","public static boolean generatePackage(GATWorkerNode node){
  LinkedList<URI> traceScripts=new LinkedList<URI>();
  LinkedList<String> traceParams=new LinkedList<String>();
  String host=node.getHost();
  String installDir=node.getInstallDir();
  String workingDir=node.getWorkingDir();
  String user=node.getUser();
  if (user == null) {
    user=""String_Node_Str"";
  }
 else {
    user+=""String_Node_Str"";
  }
  try {
    traceScripts.add(new URI(Protocol.ANY_URI.getSchema() + user + host+ File.separator+ installDir+ TRACE_SCRIPT_PATH));
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    return false;
  }
  String pars=""String_Node_Str"" + workingDir + ""String_Node_Str""+ host;
  traceParams.add(pars);
  return new CleanerExecutor(node).executeScript(traceScripts,traceParams);
}"
70426,"@Override public void generateWorkersDebugInfo(){
  logger.info(""String_Node_Str"");
}","@Override public boolean generateWorkersDebugInfo(){
  logger.info(""String_Node_Str"");
  return false;
}"
70427,"@Override public void generatePackage(){
  logger.debug(""String_Node_Str"");
  GATTracer.generatePackage(this);
}","@Override public boolean generatePackage(){
  logger.debug(""String_Node_Str"");
  GATTracer.generatePackage(this);
  return true;
}"
70428,"@Override public void stop(){
  logger.debug(""String_Node_Str"");
  HashSet<NIOWorkerNode> workers=new HashSet<NIOWorkerNode>();
  workers.addAll(nodes);
  Semaphore sem=new Semaphore(0);
  ShutdownListener sl=new ShutdownListener(sem);
  for (  NIOWorkerNode worker : workers) {
    logger.debug(""String_Node_Str"" + worker.getName());
    worker.stop(sl);
  }
  logger.debug(""String_Node_Str"");
  sl.enable();
  try {
    sem.acquire();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  tm.shutdown(null);
  logger.debug(""String_Node_Str"");
}","@Override public void stop(){
  logger.debug(""String_Node_Str"");
  HashSet<NIOWorkerNode> workers=new HashSet<NIOWorkerNode>();
  workers.addAll(nodes);
  Semaphore sem=new Semaphore(0);
  ShutdownListener sl=new ShutdownListener(sem);
  for (  NIOWorkerNode worker : workers) {
    logger.debug(""String_Node_Str"" + worker.getName());
    sl.addOperation();
    worker.stop(sl);
  }
  logger.debug(""String_Node_Str"");
  sl.enable();
  try {
    sem.acquire();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  logger.debug(""String_Node_Str"");
  logger.debug(""String_Node_Str"");
  tm.shutdown(null);
  logger.debug(""String_Node_Str"");
}"
70429,"@Override public void generateWorkersDebugInfo(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles();
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  commManager.waitUntilWorkersDebugInfoGenerated();
  logger.debug(""String_Node_Str"");
}","@Override public boolean generateWorkersDebugInfo(){
  if (started) {
    logger.debug(""String_Node_Str"" + this.getHost());
    if (node == null) {
      logger.error(""String_Node_Str"");
    }
    Connection c=NIOAgent.tm.startConnection(node);
    CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles();
    c.sendCommand(cmd);
    c.receive();
    c.finishConnection();
    commManager.waitUntilWorkersDebugInfoGenerated();
    logger.debug(""String_Node_Str"");
    return true;
  }
 else {
    logger.debug(""String_Node_Str"");
    return false;
  }
}"
70430,"@Override public void generatePackage(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGeneratePackage cmd=new CommandGeneratePackage();
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  commManager.waitUntilTracingPackageGenerated();
  logger.debug(""String_Node_Str"");
}","@Override public boolean generatePackage(){
  if (started) {
    logger.debug(""String_Node_Str"" + this.getHost());
    if (node == null) {
      logger.error(""String_Node_Str"" + this.getHost() + ""String_Node_Str"");
      return false;
    }
 else {
      Connection c=NIOAgent.tm.startConnection(node);
      CommandGeneratePackage cmd=new CommandGeneratePackage();
      c.sendCommand(cmd);
      c.receive();
      c.finishConnection();
      commManager.waitUntilTracingPackageGenerated();
      logger.debug(""String_Node_Str"");
      return true;
    }
  }
 else {
    logger.debug(""String_Node_Str"" + this.getHost() + ""String_Node_Str"");
    return false;
  }
}"
70431,"@Override public void start() throws Exception {
  NIONode n=null;
  try {
    n=new WorkerStarter(this).startWorker();
  }
 catch (  Exception e) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"",e);
    throw e;
  }
  this.node=n;
  if (NIOTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    NIOTracer.startTracing(this.getName(),this.getUser(),this.getHost(),this.getLimitOfTasks());
  }
}","@Override public void start() throws Exception {
  NIONode n=null;
  try {
    workerStarter=new WorkerStarter(this);
    n=workerStarter.startWorker();
  }
 catch (  Exception e) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"",e);
    throw e;
  }
  this.node=n;
  if (NIOTracer.isActivated()) {
    logger.debug(""String_Node_Str"" + this.getName());
    NIOTracer.startTracing(this.getName(),this.getUser(),this.getHost(),this.getLimitOfTasks());
  }
}"
70432,"@Override public void stop(ShutdownListener sl){
  logger.debug(""String_Node_Str"" + this.getName());
  if (node == null) {
    sl.notifyFailure(new UnstartedNodeException());
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  commManager.shuttingDown(this,c,sl);
  CommandShutdown cmd=new CommandShutdown(null,null);
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
}","@Override public void stop(ShutdownListener sl){
  if (started) {
    logger.debug(""String_Node_Str"" + this.getName());
    if (node == null) {
      sl.notifyFailure(new UnstartedNodeException());
      logger.error(""String_Node_Str"");
    }
    Connection c=NIOAgent.tm.startConnection(node);
    commManager.shuttingDown(this,c,sl);
    CommandShutdown cmd=new CommandShutdown(null,null);
    c.sendCommand(cmd);
    c.receive();
    c.finishConnection();
  }
 else {
    logger.debug(""String_Node_Str"" + this.getName() + ""String_Node_Str"");
    workerStarter.setToStop();
    sl.notifyEnd();
  }
}"
70433,"public NIONode startWorker() throws Exception {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
    }
    command=getStartCommand(nw,port);
    ProcessOut po=executeCommand(user,name,command);
    if (po.getExitValue() == 0) {
      String output=po.getOutput();
      String[] lines=output.split(""String_Node_Str"");
      pid=Integer.parseInt(lines[lines.length - 1]);
      long delay=300;
      long totalWait=0;
      n=new NIONode(name,port);
      String nodeName=nw.getName();
      addresstoWorkerStarter.put(nodeName,this);
      logger.debug(""String_Node_Str"");
      CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,nodeName);
      while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT)) {
        Thread.sleep(delay);
        if (!workerIsReady) {
          if (debug) {
            logger.debug(""String_Node_Str"" + nodeName);
          }
          Connection c=NIOAdaptor.tm.startConnection(n);
          c.sendCommand(cmd);
          c.receive();
          c.finishConnection();
          totalWait+=delay;
          delay=(delay < 1900) ? delay * 2 : 2000;
        }
      }
    }
 else {
      throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
    }
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      return n;
    }
  }
  if (!workerIsReady) {
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
  }
 else {
    return n;
  }
}","public NIONode startWorker() throws Exception {
  String name=nw.getName();
  String user=nw.getUser();
  int minPort=nw.getConfiguration().getMinPort();
  int maxPort=nw.getConfiguration().getMaxPort();
  int port=minPort;
  NIONode n=null;
  int pid=-1;
  while (port <= maxPort && !toStop) {
    String[] command;
    if (pid != -1) {
      command=getStopCommand(pid);
      ProcessOut po=executeCommand(user,name,command);
      if (po.getExitValue() != 0) {
        logger.error(ERROR_SHUTTING_DOWN_RETRY);
      }
    }
    command=getStartCommand(nw,port);
    ProcessOut po=executeCommand(user,name,command);
    if (po.getExitValue() == 0) {
      String output=po.getOutput();
      String[] lines=output.split(""String_Node_Str"");
      pid=Integer.parseInt(lines[lines.length - 1]);
      long delay=300;
      long totalWait=0;
      n=new NIONode(name,port);
      String nodeName=nw.getName();
      addresstoWorkerStarter.put(nodeName,this);
      logger.debug(""String_Node_Str"");
      CommandCheckWorker cmd=new CommandCheckWorker(DEPLOYMENT_ID,nodeName);
      while ((!workerIsReady) && (totalWait < MAX_WAIT_FOR_INIT) && !toStop) {
        Thread.sleep(delay);
        if (!workerIsReady) {
          if (debug) {
            logger.debug(""String_Node_Str"" + nodeName);
          }
          Connection c=NIOAdaptor.tm.startConnection(n);
          c.sendCommand(cmd);
          c.receive();
          c.finishConnection();
          totalWait+=delay;
          delay=(delay < 1900) ? delay * 2 : 2000;
        }
      }
    }
 else {
      throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str""+ ""String_Node_Str""+ po.getOutput()+ ""String_Node_Str""+ ""String_Node_Str""+ po.getError()+ ""String_Node_Str"");
    }
    if (!workerIsReady) {
      ++port;
    }
 else {
      try {
        Runtime.getRuntime().addShutdownHook(new Ender(this,nw,pid));
      }
 catch (      IllegalStateException e) {
        logger.warn(""String_Node_Str"",e);
      }
      nw.setStarted(true);
      return n;
    }
  }
  if (toStop) {
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str"");
    return null;
  }
 else   if (!workerIsReady) {
    logger.debug(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"" + name + ""String_Node_Str""+ user+ ""String_Node_Str"");
  }
 else {
    return n;
  }
}"
70434,"@Override public void generateWorkersDebugInfo(){
}","@Override public boolean generateWorkersDebugInfo(){
  return false;
}"
70435,"@Override public void generatePackage(){
}","@Override public boolean generatePackage(){
  return false;
}"
70436,"public LogicalData transferObjectValue(TransferObjectRequest toRequest){
  Semaphore sem=toRequest.getSemaphore();
  DataAccessId daId=toRequest.getDaId();
  RWAccessId rwaId=(RWAccessId)daId;
  String sourceName=rwaId.getReadDataInstance().getRenaming();
  LogicalData ld=Comm.getData(sourceName);
  if (ld == null) {
    ErrorManager.error(""String_Node_Str"" + sourceName);
  }
  if (ld.isInMemory()) {
    if (!ld.isOnStorage()) {
      try {
        ld.writeToStorage();
        ld.removeValue();
      }
 catch (      Exception e) {
        ErrorManager.error(""String_Node_Str"",e);
      }
    }
 else {
      Comm.clearValue(sourceName);
    }
    toRequest.setResponse(ld.getValue());
    toRequest.getSemaphore().release();
  }
 else {
    DataLocation targetLocation=null;
    String path=DataLocation.Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + sourceName;
    try {
      SimpleURI uri=new SimpleURI(path);
      targetLocation=DataLocation.createLocation(Comm.appHost,uri);
    }
 catch (    Exception e) {
      ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + path,e);
    }
    Comm.appHost.getData(sourceName,targetLocation,new ObjectTransferable(),new OneOpWithSemListener(sem));
  }
  return ld;
}","public LogicalData transferObjectValue(TransferObjectRequest toRequest){
  Semaphore sem=toRequest.getSemaphore();
  DataAccessId daId=toRequest.getDaId();
  RWAccessId rwaId=(RWAccessId)daId;
  String sourceName=rwaId.getReadDataInstance().getRenaming();
  LogicalData ld=Comm.getData(sourceName);
  if (ld == null) {
    ErrorManager.error(""String_Node_Str"" + sourceName);
  }
  if (ld.isInMemory()) {
    if (!ld.isOnStorage()) {
      try {
        ld.writeToStorage();
        ld.removeValue();
      }
 catch (      Exception e) {
        ErrorManager.error(""String_Node_Str"",e);
      }
    }
 else {
      Comm.clearValue(sourceName);
    }
    toRequest.setResponse(ld.getValue());
    toRequest.setTargetData(ld);
    toRequest.getSemaphore().release();
  }
 else {
    DataLocation targetLocation=null;
    String path=DataLocation.Protocol.FILE_URI.getSchema() + Comm.appHost.getTempDirPath() + sourceName;
    try {
      SimpleURI uri=new SimpleURI(path);
      targetLocation=DataLocation.createLocation(Comm.appHost,uri);
    }
 catch (    Exception e) {
      ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + path,e);
    }
    Comm.appHost.getData(sourceName,targetLocation,new ObjectTransferable(),new OneOpWithSemListener(sem));
  }
  return ld;
}"
70437,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,Job.JobListener listener){
  return null;
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,Job.JobListener listener){
  return null;
}"
70438,"public abstract Job<?> newJob(int taskId,TaskParams taskparams,Implementation<?> impl,Resource res,JobListener listener);","public abstract Job<?> newJob(int taskId,TaskDescription taskparams,Implementation<?> impl,Resource res,JobListener listener);"
70439,"public TaskParams getTaskParams(){
  return taskParams;
}","public TaskDescription getTaskParams(){
  return taskParams;
}"
70440,"public Job(int taskId,TaskParams task,Implementation<?> impl,Resource res,JobListener listener){
  jobId=nextJobId++;
  this.taskId=taskId;
  this.history=JobHistory.NEW;
  this.taskParams=task;
  this.impl=impl;
  this.worker=res;
  this.listener=listener;
  classpathFromFile=getResourceNode().getClasspath();
  if (!classpathFromFile.equals(""String_Node_Str"")) {
    if (!classpathFromEnvironment.equals(""String_Node_Str"")) {
      workerClasspath=classpathFromEnvironment + ""String_Node_Str"" + classpathFromFile;
    }
 else {
      workerClasspath=classpathFromFile;
    }
  }
 else {
    workerClasspath=classpathFromEnvironment;
  }
  pythonpathFromFile=getResourceNode().getPythonpath();
  if (!pythonpathFromFile.equals(""String_Node_Str"")) {
    if (!pythonpathFromEnvironment.equals(""String_Node_Str"")) {
      workerPythonpath=pythonpathFromEnvironment + ""String_Node_Str"" + pythonpathFromFile;
    }
 else {
      workerPythonpath=pythonpathFromFile;
    }
  }
 else {
    workerPythonpath=pythonpathFromEnvironment;
  }
}","public Job(int taskId,TaskDescription task,Implementation<?> impl,Resource res,JobListener listener){
  jobId=nextJobId++;
  this.taskId=taskId;
  this.history=JobHistory.NEW;
  this.taskParams=task;
  this.impl=impl;
  this.worker=res;
  this.listener=listener;
  classpathFromFile=getResourceNode().getClasspath();
  if (!classpathFromFile.equals(""String_Node_Str"")) {
    if (!classpathFromEnvironment.equals(""String_Node_Str"")) {
      workerClasspath=classpathFromEnvironment + ""String_Node_Str"" + classpathFromFile;
    }
 else {
      workerClasspath=classpathFromFile;
    }
  }
 else {
    workerClasspath=classpathFromEnvironment;
  }
  pythonpathFromFile=getResourceNode().getPythonpath();
  if (!pythonpathFromFile.equals(""String_Node_Str"")) {
    if (!pythonpathFromEnvironment.equals(""String_Node_Str"")) {
      workerPythonpath=pythonpathFromEnvironment + ""String_Node_Str"" + pythonpathFromFile;
    }
 else {
      workerPythonpath=pythonpathFromFile;
    }
  }
 else {
    workerPythonpath=pythonpathFromEnvironment;
  }
}"
70441,"public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,JobListener listener){
  return node.newJob(taskId,taskParams,impl,this,listener);
}","public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,JobListener listener){
  return node.newJob(taskId,taskParams,impl,this,listener);
}"
70442,"public GATJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener,GATContext context,boolean userNeeded,boolean usingGlobus){
  super(taskId,taskParams,impl,res,listener);
  this.context=context;
  this.userNeeded=userNeeded;
  this.usingGlobus=usingGlobus;
}","public GATJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener,GATContext context,boolean userNeeded,boolean usingGlobus){
  super(taskId,taskParams,impl,res,listener);
  this.context=context;
  this.userNeeded=userNeeded;
  this.usingGlobus=usingGlobus;
}"
70443,"private JobDescription prepareJob() throws Exception {
  MethodImplementation method=(MethodImplementation)this.impl;
  TaskParams taskParams=this.taskParams;
  String methodName=method.getAlternativeMethodName();
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Boolean.toString(Tracer.isActivated()));
  lArgs.add(getHostName());
  if (debug) {
    logger.debug(""String_Node_Str"" + getHostName());
  }
  if (Tracer.isActivated()) {
    lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
    lArgs.add(String.valueOf(this.taskParams.getId() + 1));
    int slot=Tracer.getNextSlot(targetHost);
    lArgs.add(String.valueOf(slot));
    sd.addAttribute(""String_Node_Str"",slot);
  }
  lArgs.add(getResourceNode().getAppDir());
  lArgs.add(getClasspath());
  lArgs.add(getPythonpath());
  lArgs.add(String.valueOf(debug));
  lArgs.add(STORAGE_CONF);
  lArgs.add(method.getDeclaringClass());
  lArgs.add(methodName);
  lArgs.add(Boolean.toString(taskParams.hasTargetObject()));
  int numParams=taskParams.getParameters().length;
  if (taskParams.hasReturnValue()) {
    numParams--;
  }
  lArgs.add(Integer.toString(numParams));
  for (  Parameter param : taskParams.getParameters()) {
    DataType type=param.getType();
    lArgs.add(Integer.toString(type.ordinal()));
switch (type) {
case FILE_T:
      DependencyParameter dFilePar=(DependencyParameter)param;
    lArgs.add(dFilePar.getDataTarget());
  break;
case PSCO_T:
logger.error(""String_Node_Str"");
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
break;
case OBJECT_T:
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
lArgs.add(dPar.getDataTarget());
if (dAccId instanceof RAccessId) {
lArgs.add(""String_Node_Str"");
}
 else {
lArgs.add(""String_Node_Str"");
}
break;
case STRING_T:
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
lArgs.add(Integer.toString(numSubStrings));
lArgs.add(value);
break;
default :
BasicTypeParameter btParB=(BasicTypeParameter)param;
lArgs.add(btParB.getValue().toString());
break;
}
}
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ method.getDeclaringClass()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,method.getRequirements().getWallClockLimit());
if (method.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,method.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",method.getRequirements().getTotalComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,method.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}","private JobDescription prepareJob() throws Exception {
  MethodImplementation method=(MethodImplementation)this.impl;
  TaskDescription taskParams=this.taskParams;
  String methodName=method.getAlternativeMethodName();
  String targetPath=getResourceNode().getInstallDir();
  String targetHost=getResourceNode().getHost();
  String targetUser=getResourceNode().getUser();
  if (userNeeded && !targetUser.isEmpty()) {
    targetUser+=""String_Node_Str"";
  }
 else {
    targetUser=""String_Node_Str"";
  }
  SoftwareDescription sd=new SoftwareDescription();
  sd.setExecutable(targetPath + WORKER_SCRIPT_PATH + WORKER_SCRIPT_NAME);
  ArrayList<String> lArgs=new ArrayList<String>();
  lArgs.add(lang);
  lArgs.add(getResourceNode().getWorkingDir());
  lArgs.add(getResourceNode().getLibPath());
  LinkedList<LogicalData> obsoleteFiles=getResource().clearObsoletes();
  if (obsoleteFiles != null) {
    lArgs.add(""String_Node_Str"" + obsoleteFiles.size());
    for (    LogicalData ld : obsoleteFiles) {
      String renaming=ld.getName();
      lArgs.add(renaming);
    }
  }
 else {
    lArgs.add(""String_Node_Str"");
  }
  lArgs.add(Boolean.toString(Tracer.isActivated()));
  lArgs.add(getHostName());
  if (debug) {
    logger.debug(""String_Node_Str"" + getHostName());
  }
  if (Tracer.isActivated()) {
    lArgs.add(String.valueOf(Tracer.getTaskEventsType()));
    lArgs.add(String.valueOf(this.taskParams.getId() + 1));
    int slot=Tracer.getNextSlot(targetHost);
    lArgs.add(String.valueOf(slot));
    sd.addAttribute(""String_Node_Str"",slot);
  }
  lArgs.add(getResourceNode().getAppDir());
  lArgs.add(getClasspath());
  lArgs.add(getPythonpath());
  lArgs.add(String.valueOf(debug));
  lArgs.add(STORAGE_CONF);
  lArgs.add(method.getDeclaringClass());
  lArgs.add(methodName);
  lArgs.add(Boolean.toString(taskParams.hasTargetObject()));
  int numParams=taskParams.getParameters().length;
  if (taskParams.hasReturnValue()) {
    numParams--;
  }
  lArgs.add(Integer.toString(numParams));
  for (  Parameter param : taskParams.getParameters()) {
    DataType type=param.getType();
    lArgs.add(Integer.toString(type.ordinal()));
switch (type) {
case FILE_T:
      DependencyParameter dFilePar=(DependencyParameter)param;
    lArgs.add(dFilePar.getDataTarget());
  break;
case PSCO_T:
logger.error(""String_Node_Str"");
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
break;
case OBJECT_T:
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
lArgs.add(dPar.getDataTarget());
if (dAccId instanceof RAccessId) {
lArgs.add(""String_Node_Str"");
}
 else {
lArgs.add(""String_Node_Str"");
}
break;
case STRING_T:
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
lArgs.add(Integer.toString(numSubStrings));
lArgs.add(value);
break;
default :
BasicTypeParameter btParB=(BasicTypeParameter)param;
lArgs.add(btParB.getValue().toString());
break;
}
}
String[] arguments=new String[lArgs.size()];
arguments=lArgs.toArray(arguments);
try {
sd.setArguments(arguments);
}
 catch (NullPointerException e) {
StringBuilder sb=new StringBuilder(""String_Node_Str"" + this.jobId + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ method.getDeclaringClass()+ ""String_Node_Str"");
int i=0;
for (Parameter param : taskParams.getParameters()) {
sb.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
DataType type=param.getType();
sb.append(""String_Node_Str"").append(param.getType()).append(""String_Node_Str"");
if (type == DataType.FILE_T || type == DataType.OBJECT_T) {
DependencyParameter dPar=(DependencyParameter)param;
DataAccessId dAccId=dPar.getDataAccessId();
sb.append(""String_Node_Str"").append(dPar.getDataTarget()).append(""String_Node_Str"");
if (type == DataType.OBJECT_T) {
if (dAccId instanceof RAccessId) {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
 else {
sb.append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
}
}
}
 else if (type == DataType.STRING_T) {
BasicTypeParameter btParS=(BasicTypeParameter)param;
String value=btParS.getValue().toString();
int numSubStrings=value.split(""String_Node_Str"").length;
sb.append(""String_Node_Str"" + Integer.toString(numSubStrings)).append(""String_Node_Str"");
sb.append(""String_Node_Str"" + value).append(""String_Node_Str"");
}
 else {
BasicTypeParameter btParB=(BasicTypeParameter)param;
sb.append(""String_Node_Str"" + btParB.getValue().toString()).append(""String_Node_Str"");
}
i++;
}
logger.error(sb.toString());
listener.jobFailed(this,JobEndStatus.SUBMISSION_FAILED);
}
sd.addAttribute(""String_Node_Str"",jobId);
sd.addAttribute(SoftwareDescription.WALLTIME_MAX,method.getRequirements().getWallClockLimit());
if (method.getRequirements().getHostQueues().size() > 0) {
sd.addAttribute(SoftwareDescription.JOB_QUEUE,method.getRequirements().getHostQueues().get(0));
}
sd.addAttribute(""String_Node_Str"",method.getRequirements().getTotalComputingUnits());
sd.addAttribute(SoftwareDescription.MEMORY_MAX,method.getRequirements().getMemorySize());
sd.addAttribute(SoftwareDescription.SANDBOX_ROOT,getResourceNode().getWorkingDir());
sd.addAttribute(SoftwareDescription.SANDBOX_USEROOT,""String_Node_Str"");
sd.addAttribute(SoftwareDescription.SANDBOX_DELETE,""String_Node_Str"");
if (debug) {
File outFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStdout(outFile);
}
if (debug || usingGlobus) {
File errFile=GAT.createFile(context,Protocol.ANY_URI + File.separator + JOBS_DIR+ ""String_Node_Str""+ jobId+ ""String_Node_Str""+ this.getHistory()+ ""String_Node_Str"");
sd.setStderr(errFile);
}
Map<String,Object> attributes=new HashMap<String,Object>();
attributes.put(RES_ATTR,Protocol.ANY_URI + targetUser + targetHost);
attributes.put(""String_Node_Str"",""String_Node_Str"" + jobId);
ResourceDescription rd=new HardwareResourceDescription(attributes);
if (debug) {
logger.debug(""String_Node_Str"" + jobId + ""String_Node_Str"");
logger.debug(""String_Node_Str"" + targetHost);
logger.debug(""String_Node_Str"" + sd.getExecutable());
StringBuilder sb=new StringBuilder(""String_Node_Str"");
for (String arg : sd.getArguments()) {
sb.append(""String_Node_Str"").append(arg);
}
logger.debug(sb.toString());
}
JobDescription jd=new JobDescription(sd,rd);
return jd;
}"
70444,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new GATJob(taskId,taskParams,impl,res,listener,config.getContext(),config.isUserNeeded(),config.isUsingGlobus());
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new GATJob(taskId,taskParams,impl,res,listener,config.getContext(),config.isUserNeeded(),config.isUsingGlobus());
}"
70445,"@Override public void handle(Connection c){
  if (agent.isMyUuid(this.uuid)) {
    if (agent.getMaster() == null) {
      agent.setMaster((NIONode)c.getNode());
    }
  }
  CommandCheckWorkerACK cmd=new CommandCheckWorkerACK(uuid,nodeName);
  c.sendCommand(cmd);
  c.finishConnection();
}","@Override public void handle(Connection c){
  if (agent.isMyUuid(this.uuid)) {
    if (agent.getMaster() == null) {
      agent.setMaster((NIONode)c.getNode());
    }
    CommandCheckWorkerACK cmd=new CommandCheckWorkerACK(uuid,nodeName);
    c.sendCommand(cmd);
  }
  c.finishConnection();
}"
70446,"public NIOJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
}","public NIOJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
}"
70447,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new NIOJob(taskId,taskParams,impl,res,listener);
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new NIOJob(taskId,taskParams,impl,res,listener);
}"
70448,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob<COMPSsWorker>(taskId,taskParams,impl,res,listener);
}","@Override public Job<?> newJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob<COMPSsWorker>(taskId,taskParams,impl,res,listener);
}"
70449,"public WSJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
  this.returnValue=null;
}","public WSJob(int taskId,TaskDescription taskParams,Implementation<?> impl,Resource res,JobListener listener){
  super(taskId,taskParams,impl,res,listener);
  this.returnValue=null;
}"
70450,"@Override public void processRequests(){
  while (true) {
    WSJob<?> job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskParams taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == DataDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}","@Override public void processRequests(){
  while (true) {
    WSJob<?> job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskDescription taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == DataDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}"
70451,"private Object obtainObject(DataAccessId oaId){
  Semaphore sem=new Semaphore(0);
  TransferObjectRequest tor=new TransferObjectRequest(oaId,sem);
  requestQueue.offer(tor);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
  }
  Object oUpdated=tor.getResponse();
  if (oUpdated == null) {
    LogicalData ld=tor.getLogicalDataTarget();
    try {
      ld.loadFromStorage();
      oUpdated=ld.getValue();
    }
 catch (    Exception e) {
      logger.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ld.getName(),e);
      ErrorManager.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ld.getName(),e);
    }
  }
  return oUpdated;
}","private Object obtainObject(DataAccessId oaId){
  Semaphore sem=new Semaphore(0);
  TransferObjectRequest tor=new TransferObjectRequest(oaId,sem);
  requestQueue.offer(tor);
  try {
    sem.acquire();
  }
 catch (  InterruptedException e) {
  }
  Object oUpdated=tor.getResponse();
  if (oUpdated == null) {
    LogicalData ld=tor.getLogicalDataTarget();
    try {
      ld.loadFromStorage();
      oUpdated=ld.getValue();
    }
 catch (    Exception e) {
      logger.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ((ld == null) ? ""String_Node_Str"" : ld.getName()),e);
      ErrorManager.fatal(ERROR_OBJECT_LOAD_FROM_STORAGE + ""String_Node_Str"" + ((ld == null) ? ""String_Node_Str"" : ld.getName()),e);
    }
  }
  return oUpdated;
}"
70452,"public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  return logicalData;
}","public static synchronized LogicalData registerValue(String dataId,Object value){
  logger.debug(""String_Node_Str"" + value + ""String_Node_Str""+ dataId);
  String targetPath=Protocol.OBJECT_URI.getSchema() + dataId;
  DataLocation location=null;
  try {
    SimpleURI uri=new SimpleURI(targetPath);
    location=DataLocation.createLocation(appHost,uri);
  }
 catch (  Exception e) {
    ErrorManager.error(DataLocation.ERROR_INVALID_LOCATION + ""String_Node_Str"" + targetPath,e);
  }
  LogicalData logicalData=data.get(dataId);
  logicalData.addLocation(location);
  logicalData.setValue(value);
  if (value instanceof StubItf) {
    String id=((StubItf)value).getID();
    if (id != null) {
      Comm.registerPSCO(dataId,id);
    }
  }
  return logicalData;
}"
70453,"private static void setPropertiesFromRuntime(RuntimeConfigManager manager){
  try {
    if (manager != null) {
      if (manager.getDeploymentId() != null && System.getProperty(ITConstants.IT_DEPLOYMENT_ID) == null) {
        System.setProperty(ITConstants.IT_DEPLOYMENT_ID,manager.getDeploymentId());
      }
      if (manager.getMasterName() != null && System.getProperty(ITConstants.IT_MASTER_NAME) == null) {
        System.setProperty(ITConstants.IT_MASTER_NAME,manager.getMasterName());
      }
      if (manager.getMasterPort() != null && System.getProperty(ITConstants.IT_MASTER_PORT) == null) {
        System.setProperty(ITConstants.IT_MASTER_PORT,manager.getMasterPort());
      }
      if (manager.getAppName() != null && System.getProperty(ITConstants.IT_APP_NAME) == null) {
        System.setProperty(ITConstants.IT_APP_NAME,manager.getAppName());
      }
      if (manager.getCOMPSsBaseLogDir() != null && System.getProperty(ITConstants.IT_BASE_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_BASE_LOG_DIR,manager.getCOMPSsBaseLogDir());
      }
      if (manager.getSpecificLogDir() != null && System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_SPECIFIC_LOG_DIR,manager.getSpecificLogDir());
      }
      if (manager.getLog4jConfiguration() != null && System.getProperty(ITConstants.LOG4J) == null) {
        System.setProperty(ITConstants.LOG4J,manager.getLog4jConfiguration());
      }
      if (manager.getResourcesFile() != null && System.getProperty(ITConstants.IT_RES_FILE) == null) {
        System.setProperty(ITConstants.IT_RES_FILE,manager.getResourcesFile());
      }
      if (manager.getResourcesSchema() != null && System.getProperty(ITConstants.IT_RES_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_RES_SCHEMA,manager.getResourcesSchema());
      }
      if (manager.getProjectFile() != null && System.getProperty(ITConstants.IT_PROJ_FILE) == null) {
        System.setProperty(ITConstants.IT_PROJ_FILE,manager.getProjectFile());
      }
      if (manager.getProjectSchema() != null && System.getProperty(ITConstants.IT_PROJ_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_PROJ_SCHEMA,manager.getProjectSchema());
      }
      if (manager.getScheduler() != null && System.getProperty(ITConstants.IT_SCHEDULER) == null) {
        System.setProperty(ITConstants.IT_SCHEDULER,manager.getScheduler());
      }
      if (manager.getMonitorInterval() > 0 && System.getProperty(ITConstants.IT_MONITOR) == null) {
        System.setProperty(ITConstants.IT_MONITOR,Long.toString(manager.getMonitorInterval()));
      }
      if (manager.getGATAdaptor() != null && System.getProperty(ITConstants.GAT_ADAPTOR_PATH) == null) {
        System.setProperty(ITConstants.GAT_ADAPTOR_PATH,manager.getGATAdaptor());
      }
      if (manager.getGATBrokerAdaptor() != null && System.getProperty(ITConstants.GAT_BROKER_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_BROKER_ADAPTOR,manager.getGATBrokerAdaptor());
      }
      if (manager.getGATFileAdaptor() != null && System.getProperty(ITConstants.GAT_FILE_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_FILE_ADAPTOR,manager.getGATFileAdaptor());
      }
      if (manager.getWorkerCP() != null && System.getProperty(ITConstants.IT_WORKER_CP) == null) {
        System.setProperty(ITConstants.IT_WORKER_CP,manager.getWorkerCP());
      }
      if (manager.getServiceName() != null && System.getProperty(ITConstants.IT_SERVICE_NAME) == null) {
        System.setProperty(ITConstants.IT_SERVICE_NAME,manager.getServiceName());
      }
      if (System.getProperty(ITConstants.COMM_ADAPTOR) == null) {
        if (manager.getCommAdaptor() != null) {
          System.setProperty(ITConstants.COMM_ADAPTOR,manager.getCommAdaptor());
        }
 else {
          System.setProperty(ITConstants.COMM_ADAPTOR,ITConstants.DEFAULT_ADAPTOR);
        }
      }
      if (System.getProperty(ITConstants.GAT_DEBUG) == null) {
        System.setProperty(ITConstants.GAT_DEBUG,Boolean.toString(manager.isGATDebug()));
      }
      if (System.getProperty(ITConstants.IT_LANG) == null) {
        System.setProperty(ITConstants.IT_LANG,manager.getLang());
      }
      if (System.getProperty(ITConstants.IT_GRAPH) == null) {
        System.setProperty(ITConstants.IT_GRAPH,Boolean.toString(manager.isGraph()));
      }
      if (System.getProperty(ITConstants.IT_TRACING) == null) {
        System.setProperty(ITConstants.IT_TRACING,String.valueOf(manager.getTracing()));
      }
      if (System.getProperty(ITConstants.IT_EXTRAE_CONFIG_FILE) == null) {
        System.setProperty(ITConstants.IT_EXTRAE_CONFIG_FILE,manager.getCustomExtraeFile());
      }
      if (System.getProperty(ITConstants.IT_PRESCHED) == null) {
        System.setProperty(ITConstants.IT_PRESCHED,Boolean.toString(manager.isPresched()));
      }
      if (System.getProperty(ITConstants.IT_TASK_EXECUTION) == null || System.getProperty(ITConstants.IT_TASK_EXECUTION).equals(""String_Node_Str"")) {
        System.setProperty(ITConstants.IT_TASK_EXECUTION,ITConstants.EXECUTION_INTERNAL);
      }
      if (manager.getContext() != null) {
        System.setProperty(ITConstants.IT_CONTEXT,manager.getContext());
      }
      System.setProperty(ITConstants.IT_TO_FILE,Boolean.toString(manager.isToFile()));
    }
 else {
      setDefaultProperties();
    }
  }
 catch (  Exception e) {
    System.err.println(WARN_IT_FILE_NOT_READ);
    e.printStackTrace();
  }
}","private static void setPropertiesFromRuntime(RuntimeConfigManager manager){
  try {
    if (manager != null) {
      if (manager.getDeploymentId() != null && System.getProperty(ITConstants.IT_DEPLOYMENT_ID) == null) {
        System.setProperty(ITConstants.IT_DEPLOYMENT_ID,manager.getDeploymentId());
      }
      if (manager.getMasterName() != null && System.getProperty(ITConstants.IT_MASTER_NAME) == null) {
        System.setProperty(ITConstants.IT_MASTER_NAME,manager.getMasterName());
      }
      if (manager.getMasterPort() != null && System.getProperty(ITConstants.IT_MASTER_PORT) == null) {
        System.setProperty(ITConstants.IT_MASTER_PORT,manager.getMasterPort());
      }
      if (manager.getAppName() != null && System.getProperty(ITConstants.IT_APP_NAME) == null) {
        System.setProperty(ITConstants.IT_APP_NAME,manager.getAppName());
      }
      if (manager.getTaskSummary() != null && System.getProperty(ITConstants.IT_TASK_SUMMARY) == null) {
        System.setProperty(ITConstants.IT_TASK_SUMMARY,manager.getTaskSummary());
      }
      if (manager.getCOMPSsBaseLogDir() != null && System.getProperty(ITConstants.IT_BASE_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_BASE_LOG_DIR,manager.getCOMPSsBaseLogDir());
      }
      if (manager.getSpecificLogDir() != null && System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR) == null) {
        System.setProperty(ITConstants.IT_SPECIFIC_LOG_DIR,manager.getSpecificLogDir());
      }
      if (manager.getLog4jConfiguration() != null && System.getProperty(ITConstants.LOG4J) == null) {
        System.setProperty(ITConstants.LOG4J,manager.getLog4jConfiguration());
      }
      if (manager.getResourcesFile() != null && System.getProperty(ITConstants.IT_RES_FILE) == null) {
        System.setProperty(ITConstants.IT_RES_FILE,manager.getResourcesFile());
      }
      if (manager.getResourcesSchema() != null && System.getProperty(ITConstants.IT_RES_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_RES_SCHEMA,manager.getResourcesSchema());
      }
      if (manager.getProjectFile() != null && System.getProperty(ITConstants.IT_PROJ_FILE) == null) {
        System.setProperty(ITConstants.IT_PROJ_FILE,manager.getProjectFile());
      }
      if (manager.getProjectSchema() != null && System.getProperty(ITConstants.IT_PROJ_SCHEMA) == null) {
        System.setProperty(ITConstants.IT_PROJ_SCHEMA,manager.getProjectSchema());
      }
      if (manager.getScheduler() != null && System.getProperty(ITConstants.IT_SCHEDULER) == null) {
        System.setProperty(ITConstants.IT_SCHEDULER,manager.getScheduler());
      }
      if (manager.getMonitorInterval() > 0 && System.getProperty(ITConstants.IT_MONITOR) == null) {
        System.setProperty(ITConstants.IT_MONITOR,Long.toString(manager.getMonitorInterval()));
      }
      if (manager.getGATAdaptor() != null && System.getProperty(ITConstants.GAT_ADAPTOR_PATH) == null) {
        System.setProperty(ITConstants.GAT_ADAPTOR_PATH,manager.getGATAdaptor());
      }
      if (manager.getGATBrokerAdaptor() != null && System.getProperty(ITConstants.GAT_BROKER_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_BROKER_ADAPTOR,manager.getGATBrokerAdaptor());
      }
      if (manager.getGATFileAdaptor() != null && System.getProperty(ITConstants.GAT_FILE_ADAPTOR) == null) {
        System.setProperty(ITConstants.GAT_FILE_ADAPTOR,manager.getGATFileAdaptor());
      }
      if (manager.getWorkerCP() != null && System.getProperty(ITConstants.IT_WORKER_CP) == null) {
        System.setProperty(ITConstants.IT_WORKER_CP,manager.getWorkerCP());
      }
      if (manager.getServiceName() != null && System.getProperty(ITConstants.IT_SERVICE_NAME) == null) {
        System.setProperty(ITConstants.IT_SERVICE_NAME,manager.getServiceName());
      }
      if (System.getProperty(ITConstants.COMM_ADAPTOR) == null) {
        if (manager.getCommAdaptor() != null) {
          System.setProperty(ITConstants.COMM_ADAPTOR,manager.getCommAdaptor());
        }
 else {
          System.setProperty(ITConstants.COMM_ADAPTOR,ITConstants.DEFAULT_ADAPTOR);
        }
      }
      if (System.getProperty(ITConstants.GAT_DEBUG) == null) {
        System.setProperty(ITConstants.GAT_DEBUG,Boolean.toString(manager.isGATDebug()));
      }
      if (System.getProperty(ITConstants.IT_LANG) == null) {
        System.setProperty(ITConstants.IT_LANG,manager.getLang());
      }
      if (System.getProperty(ITConstants.IT_GRAPH) == null) {
        System.setProperty(ITConstants.IT_GRAPH,Boolean.toString(manager.isGraph()));
      }
      if (System.getProperty(ITConstants.IT_TRACING) == null) {
        System.setProperty(ITConstants.IT_TRACING,String.valueOf(manager.getTracing()));
      }
      if (System.getProperty(ITConstants.IT_EXTRAE_CONFIG_FILE) == null) {
        System.setProperty(ITConstants.IT_EXTRAE_CONFIG_FILE,manager.getCustomExtraeFile());
      }
      if (System.getProperty(ITConstants.IT_PRESCHED) == null) {
        System.setProperty(ITConstants.IT_PRESCHED,Boolean.toString(manager.isPresched()));
      }
      if (System.getProperty(ITConstants.IT_TASK_EXECUTION) == null || System.getProperty(ITConstants.IT_TASK_EXECUTION).equals(""String_Node_Str"")) {
        System.setProperty(ITConstants.IT_TASK_EXECUTION,ITConstants.EXECUTION_INTERNAL);
      }
      if (manager.getContext() != null) {
        System.setProperty(ITConstants.IT_CONTEXT,manager.getContext());
      }
      System.setProperty(ITConstants.IT_TO_FILE,Boolean.toString(manager.isToFile()));
    }
 else {
      setDefaultProperties();
    }
  }
 catch (  Exception e) {
    System.err.println(WARN_IT_FILE_NOT_READ);
    e.printStackTrace();
  }
}"
70454,"/** 
 * Stops the COMPSsRuntime
 */
@Override public void stopIT(boolean terminate){
synchronized (this) {
    if (Tracer.isActivated()) {
      Tracer.emitEvent(Tracer.Event.STOP.getId(),Tracer.Event.STOP.getType());
    }
    td.getTaskSummary(logger);
    logger.info(""String_Node_Str"");
    if (GraphGenerator.isEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    if (RuntimeMonitor.isEnabled()) {
      logger.debug(""String_Node_Str"");
      runtimeMonitor.shutdown();
    }
    logger.debug(""String_Node_Str"");
    if (ap != null) {
      ap.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    if (td != null) {
      td.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    Comm.stop();
    logger.debug(""String_Node_Str"");
  }
  logger.warn(""String_Node_Str"");
}","/** 
 * Stops the COMPSsRuntime
 */
@Override public void stopIT(boolean terminate){
synchronized (this) {
    if (Tracer.isActivated()) {
      Tracer.emitEvent(Tracer.Event.STOP.getId(),Tracer.Event.STOP.getType());
    }
    boolean taskSummaryEnabled=System.getProperty(ITConstants.IT_TASK_SUMMARY) != null && !System.getProperty(ITConstants.IT_TASK_SUMMARY).isEmpty() && Boolean.valueOf(System.getProperty(ITConstants.IT_TASK_SUMMARY));
    if (taskSummaryEnabled) {
      td.getTaskSummary(logger);
    }
    logger.info(""String_Node_Str"");
    if (GraphGenerator.isEnabled()) {
      logger.debug(""String_Node_Str"");
    }
    if (RuntimeMonitor.isEnabled()) {
      logger.debug(""String_Node_Str"");
      runtimeMonitor.shutdown();
    }
    logger.debug(""String_Node_Str"");
    if (ap != null) {
      ap.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    if (td != null) {
      td.shutdown();
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    logger.debug(""String_Node_Str"");
    Comm.stop();
    logger.debug(""String_Node_Str"");
  }
  logger.warn(""String_Node_Str"");
}"
70455,"public DataAccessId registerObjectAccess(AccessMode mode,Object value,int code,int readerId){
  DataInfo oInfo;
  Integer aoId=codeToId.get(code);
  if (aoId == null) {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=new ObjectInfo(code);
    aoId=oInfo.getDataId();
    codeToId.put(code,aoId);
    idToData.put(aoId,oInfo);
    DataInstanceId lastDID=oInfo.getCurrentDataInstanceId();
    String renaming=lastDID.getRenaming();
    if (mode != AccessMode.W) {
      Comm.registerValue(renaming,value);
      if (value instanceof StubItf) {
        String id=((StubItf)value).getID();
        if (id != null) {
          Comm.registerPSCO(renaming,id);
        }
      }
    }
  }
 else {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=idToData.get(aoId);
  }
  return willAccess(mode,oInfo);
}","public DataAccessId registerObjectAccess(AccessMode mode,Object value,int code,int readerId){
  DataInfo oInfo;
  Integer aoId=codeToId.get(code);
  if (aoId == null) {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=new ObjectInfo(code);
    aoId=oInfo.getDataId();
    codeToId.put(code,aoId);
    idToData.put(aoId,oInfo);
    DataInstanceId lastDID=oInfo.getCurrentDataInstanceId();
    String renaming=lastDID.getRenaming();
    if (mode != AccessMode.W) {
      Comm.registerValue(renaming,value);
    }
  }
 else {
    if (debug) {
      logger.debug(""String_Node_Str"" + code);
    }
    oInfo=idToData.get(aoId);
  }
  return willAccess(mode,oInfo);
}"
70456,"/** 
 * Sets the PSCO Id value (null if it is not PSCO)
 * @param id
 */
public synchronized void setId(String id){
  this.id=id;
}","/** 
 * Sets the LD id
 * @param id
 */
public synchronized void setId(String id){
  this.id=id;
}"
70457,"/** 
 * Loads the value of the LogicalData from a file
 * @throws Exception
 */
public synchronized void loadFromStorage() throws Exception {
  if (value != null) {
    return;
  }
  for (  DataLocation loc : this.locations) {
switch (loc.getType()) {
case PRIVATE:
case SHARED:
      MultiURI u=loc.getURIInHost(Comm.appHost);
    if (u == null) {
      continue;
    }
  String path=u.getPath();
if (path.startsWith(File.separator)) {
  this.value=Serializer.deserialize(path);
  String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
  SimpleURI uri=new SimpleURI(targetPath);
  DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
  addLocation(tgtLoc);
}
return;
case PERSISTENT:
PersistentLocation pLoc=(PersistentLocation)loc;
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.Event.STORAGE_GETBYID.getId(),Tracer.Event.STORAGE_GETBYID.getType());
}
try {
this.value=StorageItf.getByID(pLoc.getId());
}
 catch (StorageException se) {
throw new Exception(""String_Node_Str"" + pLoc.getId(),se);
}
 finally {
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.EVENT_END,Tracer.Event.STORAGE_GETBYID.getType());
}
}
String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
SimpleURI uri=new SimpleURI(targetPath);
DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
addLocation(tgtLoc);
return;
}
}
throw new Exception(""String_Node_Str"");
}","/** 
 * Loads the value of the LogicalData from a file
 * @throws Exception
 */
public synchronized void loadFromStorage() throws Exception {
  if (value != null) {
    return;
  }
  for (  DataLocation loc : this.locations) {
switch (loc.getType()) {
case PRIVATE:
case SHARED:
      MultiURI u=loc.getURIInHost(Comm.appHost);
    if (u == null) {
      continue;
    }
  String path=u.getPath();
if (path.startsWith(File.separator)) {
  this.value=Serializer.deserialize(path);
  String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
  SimpleURI uri=new SimpleURI(targetPath);
  DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
  addLocation(tgtLoc);
}
return;
case PERSISTENT:
PersistentLocation pLoc=(PersistentLocation)loc;
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.Event.STORAGE_GETBYID.getId(),Tracer.Event.STORAGE_GETBYID.getType());
}
try {
this.value=StorageItf.getByID(pLoc.getId());
this.id=pLoc.getId();
}
 catch (StorageException se) {
throw new Exception(""String_Node_Str"" + pLoc.getId(),se);
}
 finally {
if (Tracer.isActivated()) {
Tracer.emitEvent(Tracer.EVENT_END,Tracer.Event.STORAGE_GETBYID.getType());
}
}
String targetPath=Protocol.OBJECT_URI.getSchema() + this.name;
SimpleURI uri=new SimpleURI(targetPath);
DataLocation tgtLoc=DataLocation.createLocation(Comm.appHost,uri);
addLocation(tgtLoc);
return;
}
}
throw new Exception(""String_Node_Str"");
}"
70458,"/** 
 * Prints in a file the final task graph
 */
public void commitGraph(){
  logger.debug(""String_Node_Str"");
  try {
    full_graph.close();
    try (FileInputStream sourceStream=new FileInputStream(COMPLETE_GRAPH_TMP_FILE);FileOutputStream destStream=new FileOutputStream(COMPLETE_GRAPH_FILE);FileChannel sourceChannel=sourceStream.getChannel();FileChannel destChannel=destStream.getChannel()){
      destChannel.transferFrom(sourceChannel,0,sourceChannel.size());
    }
     full_graph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_TMP_FILE,true));
    BufferedWriter finalGraph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_FILE,true));
    closeDependenceGraph(finalGraph);
    openLegend(finalGraph);
    legend.close();
    try (FileInputStream sourceStream=new FileInputStream(COMPLETE_LEGEND_TMP_FILE);FileOutputStream destStream=new FileOutputStream(COMPLETE_GRAPH_FILE);FileChannel sourceChannel=sourceStream.getChannel();FileChannel destChannel=destStream.getChannel()){
      destChannel.position(destChannel.size());
      sourceChannel.transferTo(0,sourceChannel.size(),destChannel);
    }
     legend=new BufferedWriter(new FileWriter(COMPLETE_LEGEND_TMP_FILE,true));
    closeLegend(finalGraph);
    closeGraphFile(finalGraph);
    finalGraph.close();
  }
 catch (  Exception e) {
    logger.error(ERROR_COMMIT_FINAL_GRAPH,e);
  }
}","/** 
 * Prints in a file the final task graph
 */
public void commitGraph(){
  logger.debug(""String_Node_Str"");
  try {
    full_graph.close();
    FileInputStream sourceFIS=null;
    FileOutputStream destFOS=null;
    FileChannel sourceChannel=null;
    FileChannel destChannel=null;
    try {
      sourceFIS=new FileInputStream(COMPLETE_GRAPH_TMP_FILE);
      destFOS=new FileOutputStream(COMPLETE_GRAPH_FILE);
      sourceChannel=sourceFIS.getChannel();
      destChannel=destFOS.getChannel();
      destChannel.transferFrom(sourceChannel,0,sourceChannel.size());
    }
  finally {
      sourceChannel.close();
      sourceFIS.close();
      destChannel.close();
      destFOS.close();
    }
    full_graph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_TMP_FILE,true));
    BufferedWriter finalGraph=new BufferedWriter(new FileWriter(COMPLETE_GRAPH_FILE,true));
    closeDependenceGraph(finalGraph);
    openLegend(finalGraph);
    legend.close();
    try {
      sourceFIS=new FileInputStream(COMPLETE_LEGEND_TMP_FILE);
      sourceChannel=sourceFIS.getChannel();
      destFOS=new FileOutputStream(COMPLETE_GRAPH_FILE,true);
      destChannel=destFOS.getChannel();
      destChannel.position(destChannel.size());
      sourceChannel.transferTo(0,sourceChannel.size(),destChannel);
    }
  finally {
      sourceChannel.close();
      sourceFIS.close();
      destChannel.close();
      destFOS.close();
    }
    legend=new BufferedWriter(new FileWriter(COMPLETE_LEGEND_TMP_FILE,true));
    closeLegend(finalGraph);
    closeGraphFile(finalGraph);
    finalGraph.close();
  }
 catch (  Exception e) {
    logger.error(ERROR_COMMIT_FINAL_GRAPH,e);
  }
}"
70459,"public MethodConfiguration(MethodConfiguration clone){
  super(clone);
  host=clone.host;
  user=clone.host;
  installDir=clone.installDir;
  workingDir=clone.workingDir;
  totalComputingUnits=clone.totalComputingUnits;
  appDir=clone.appDir;
  classpath=clone.classpath;
  pythonpath=clone.pythonpath;
  libraryPath=clone.libraryPath;
}","public MethodConfiguration(MethodConfiguration clone){
  super(clone);
  host=clone.host;
  user=clone.user;
  installDir=clone.installDir;
  workingDir=clone.workingDir;
  totalComputingUnits=clone.totalComputingUnits;
  appDir=clone.appDir;
  classpath=clone.classpath;
  pythonpath=clone.pythonpath;
  libraryPath=clone.libraryPath;
}"
70460,"public final void getWorkloadState(ResourceUser.WorkloadStatus response){
  int coreCount=CoreManager.getCoreCount();
  Profile[] coreProfile=new Profile[coreCount];
  for (int coreId=0; coreId < coreCount; coreId++) {
    coreProfile[coreId]=new Profile();
  }
  for (  ResourceScheduler<P,T> ui : workers.values()) {
    if (ui == null) {
      continue;
    }
    LinkedList<Implementation<T>>[] impls=ui.getExecutableImpls();
    for (int coreId=0; coreId < coreCount; coreId++) {
      for (      Implementation<T> impl : impls[coreId]) {
        coreProfile[coreId].accumulate(ui.getProfile(impl));
      }
    }
    LinkedList<AllocatableAction<P,T>> runningActions=ui.getHostedActions();
    long now=System.currentTimeMillis();
    for (    AllocatableAction<P,T> running : runningActions) {
      if (running.getImplementations().length > 0) {
        int coreId=running.getImplementations()[0].getCoreId();
        response.registerRunning(coreId,now - running.getStartTime());
      }
    }
  }
  for (int coreId=0; coreId < coreCount; coreId++) {
    response.registerNoResources(coreId,blockedActions.getActionCounts()[coreId]);
    response.registerReady(coreId,readyCounts[coreId]);
    response.registerTimes(coreId,coreProfile[coreId].getMinExecutionTime(),coreProfile[coreId].getAverageExecutionTime(),coreProfile[coreId].getMaxExecutionTime());
  }
}","public final void getWorkloadState(ResourceUser.WorkloadStatus response){
  int coreCount=CoreManager.getCoreCount();
  Profile[] coreProfile=new Profile[coreCount];
  for (int coreId=0; coreId < coreCount; coreId++) {
    coreProfile[coreId]=new Profile();
  }
  for (  ResourceScheduler<P,T> ui : workers.values()) {
    if (ui == null) {
      continue;
    }
    LinkedList<Implementation<T>>[] impls=ui.getExecutableImpls();
    for (int coreId=0; coreId < coreCount; coreId++) {
      for (      Implementation<T> impl : impls[coreId]) {
        coreProfile[coreId].accumulate(ui.getProfile(impl));
      }
    }
    LinkedList<AllocatableAction<P,T>> runningActions=ui.getHostedActions();
    long now=System.currentTimeMillis();
    for (    AllocatableAction<P,T> running : runningActions) {
      if (running.getImplementations().length > 0) {
        Integer coreId=running.getImplementations()[0].getCoreId();
        if (coreId != null) {
          response.registerRunning(coreId,now - running.getStartTime());
        }
      }
    }
  }
  for (int coreId=0; coreId < coreCount; coreId++) {
    response.registerNoResources(coreId,blockedActions.getActionCounts()[coreId]);
    response.registerReady(coreId,readyCounts[coreId]);
    response.registerTimes(coreId,coreProfile[coreId].getMinExecutionTime(),coreProfile[coreId].getAverageExecutionTime(),coreProfile[coreId].getMaxExecutionTime());
  }
}"
70461,"public TaskAnalyser(){
  currentTaskCount=new HashMap<Integer,Integer>();
  writers=new TreeMap<Integer,Task>();
  appIdToTaskCount=new HashMap<Long,Integer>();
  appIdToTotalTaskCount=new HashMap<Long,Integer>();
  appIdToSemaphore=new HashMap<Long,Semaphore>();
  appIdToWrittenFiles=new HashMap<Long,TreeSet<Integer>>();
  waitedTasks=new Hashtable<Task,List<Semaphore>>();
  synchronizationId=0;
  logger.info(""String_Node_Str"");
}","public TaskAnalyser(){
  currentTaskCount=new HashMap<Integer,Integer>();
  writers=new TreeMap<Integer,Task>();
  appIdToTaskCount=new HashMap<Long,Integer>();
  appIdToTotalTaskCount=new HashMap<Long,Integer>();
  appIdToSemaphore=new HashMap<Long,Semaphore>();
  appIdToWrittenFiles=new HashMap<Long,TreeSet<Integer>>();
  appIdToSCOWrittenIds=new HashMap<Long,TreeSet<Integer>>();
  waitedTasks=new Hashtable<Task,List<Semaphore>>();
  synchronizationId=0;
  logger.info(""String_Node_Str"");
}"
70462,"/** 
 * Registers and action as completed and releases all the resource and data dependencies.
 * @param action action that has finished
 */
public final void actionCompleted(AllocatableAction<P,T> action){
  ResourceScheduler<P,T> resource=action.getAssignedResource();
  if (action.getImplementations().length > 0) {
    int coreId=action.getImplementations()[0].getCoreId();
    readyCounts[coreId]--;
  }
  LinkedList<AllocatableAction<P,T>> dataFreeActions=action.completed();
  for (  AllocatableAction<P,T> dataFreeAction : dataFreeActions) {
    if (dataFreeAction.getImplementations().length > 0) {
      int coreId=dataFreeAction.getImplementations()[0].getCoreId();
      readyCounts[coreId]++;
    }
    try {
      dependencyFreeAction(dataFreeAction);
    }
 catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
  LinkedList<AllocatableAction<P,T>> resourceFree=resource.unscheduleAction(action);
  workerLoadUpdate((ResourceScheduler<P,T>)action.getAssignedResource());
  HashSet<AllocatableAction<P,T>> freeTasks=new HashSet<AllocatableAction<P,T>>();
  freeTasks.addAll(dataFreeActions);
  freeTasks.addAll(resourceFree);
  for (  AllocatableAction<P,T> a : freeTasks) {
    try {
      try {
        a.tryToLaunch();
      }
 catch (      InvalidSchedulingException ise) {
        Score aScore=a.schedulingScore(this);
        a.schedule(action.getConstrainingPredecessor().getAssignedResource(),aScore);
        try {
          a.tryToLaunch();
        }
 catch (        InvalidSchedulingException ise2) {
        }
      }
    }
 catch (    UnassignedActionException ure) {
      StringBuilder info=new StringBuilder(""String_Node_Str"");
      info.append(action.toString());
      ErrorManager.fatal(info.toString());
    }
catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
}","/** 
 * Registers and action as completed and releases all the resource and data dependencies.
 * @param action action that has finished
 */
public final void actionCompleted(AllocatableAction<P,T> action){
  ResourceScheduler<P,T> resource=action.getAssignedResource();
  if (action.getImplementations().length > 0) {
    int coreId=action.getImplementations()[0].getCoreId();
    readyCounts[coreId]--;
  }
  LinkedList<AllocatableAction<P,T>> dataFreeActions=action.completed();
  for (  AllocatableAction<P,T> dataFreeAction : dataFreeActions) {
    if (dataFreeAction.getImplementations().length > 0) {
      int coreId=dataFreeAction.getImplementations()[0].getCoreId();
      readyCounts[coreId]++;
    }
    try {
      dependencyFreeAction(dataFreeAction);
    }
 catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
  LinkedList<AllocatableAction<P,T>> resourceFree=resource.unscheduleAction(action);
  workerLoadUpdate((ResourceScheduler<P,T>)action.getAssignedResource());
  for (  AllocatableAction<P,T> a : resourceFree) {
    try {
      try {
        a.tryToLaunch();
      }
 catch (      InvalidSchedulingException ise) {
        Score aScore=a.schedulingScore(this);
        a.schedule(action.getConstrainingPredecessor().getAssignedResource(),aScore);
        try {
          a.tryToLaunch();
        }
 catch (        InvalidSchedulingException ise2) {
        }
      }
    }
 catch (    UnassignedActionException ure) {
      StringBuilder info=new StringBuilder(""String_Node_Str"");
      info.append(action.toString());
      ErrorManager.fatal(info.toString());
    }
catch (    BlockedActionException bae) {
      logger.info(""String_Node_Str"" + action);
      blockedActions.addAction(action);
    }
  }
}"
70463,"@Override public void dependencyFreeAction(AllocatableAction<P,T> action) throws BlockedActionException {
  dependingActions.removeAction(action);
  try {
    Score actionScore=action.schedulingScore(this);
    action.schedule(actionScore);
  }
 catch (  UnassignedActionException ex) {
    unassignedReadyActions.addAction(action);
  }
}","@Override public void dependencyFreeAction(AllocatableAction<P,T> action) throws BlockedActionException {
  dependingActions.removeAction(action);
  try {
    Score actionScore=action.schedulingScore(this);
    action.schedule(actionScore);
    try {
      action.tryToLaunch();
    }
 catch (    InvalidSchedulingException ise) {
      action.schedule(action.getConstrainingPredecessor().getAssignedResource(),actionScore);
      try {
        action.tryToLaunch();
      }
 catch (      InvalidSchedulingException ise2) {
      }
    }
  }
 catch (  UnassignedActionException ex) {
    unassignedReadyActions.addAction(action);
  }
}"
70464,"public MasterResource(){
  super(new COMPSsMaster());
  userExecutionDirPath=System.getProperty(""String_Node_Str"");
  boolean mustCreateExecutionSandbox=true;
  String specificOpt=System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR);
  if (specificOpt != null && !specificOpt.isEmpty()) {
    COMPSsLogBaseDirPath=specificOpt.endsWith(File.separator) ? specificOpt : specificOpt + File.separator;
    mustCreateExecutionSandbox=false;
  }
 else {
    String baseOpt=System.getProperty(ITConstants.IT_BASE_LOG_DIR);
    if (baseOpt != null && !baseOpt.isEmpty()) {
      baseOpt=baseOpt.endsWith(File.separator) ? baseOpt : baseOpt + File.separator;
      COMPSsLogBaseDirPath=baseOpt + ""String_Node_Str"" + File.separator;
    }
 else {
      COMPSsLogBaseDirPath=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator;
    }
  }
  if (!new File(COMPSsLogBaseDirPath).exists()) {
    if (!new File(COMPSsLogBaseDirPath).mkdir()) {
      ErrorManager.error(ERROR_COMPSs_LOG_BASE_DIR);
    }
  }
  if (mustCreateExecutionSandbox) {
    String appName=System.getProperty(ITConstants.IT_APP_NAME);
    if (System.getProperty(ITConstants.IT_SERVICE_NAME) != null) {
      String serviceName=System.getProperty(ITConstants.IT_SERVICE_NAME);
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
 else {
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
  }
 else {
    appLogDirPath=COMPSsLogBaseDirPath;
    System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
  }
  tempDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(tempDirPath).mkdir()) {
    ErrorManager.error(ERROR_TEMP_DIR);
  }
  jobsDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(jobsDirPath).mkdir()) {
    ErrorManager.error(ERROR_JOBS_DIR);
  }
  workersDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(workersDirPath).mkdir()) {
    System.err.println(ERROR_WORKERS_DIR);
    System.exit(1);
  }
}","public MasterResource(){
  super(new COMPSsMaster(),null);
  userExecutionDirPath=System.getProperty(""String_Node_Str"");
  boolean mustCreateExecutionSandbox=true;
  String specificOpt=System.getProperty(ITConstants.IT_SPECIFIC_LOG_DIR);
  if (specificOpt != null && !specificOpt.isEmpty()) {
    COMPSsLogBaseDirPath=specificOpt.endsWith(File.separator) ? specificOpt : specificOpt + File.separator;
    mustCreateExecutionSandbox=false;
  }
 else {
    String baseOpt=System.getProperty(ITConstants.IT_BASE_LOG_DIR);
    if (baseOpt != null && !baseOpt.isEmpty()) {
      baseOpt=baseOpt.endsWith(File.separator) ? baseOpt : baseOpt + File.separator;
      COMPSsLogBaseDirPath=baseOpt + ""String_Node_Str"" + File.separator;
    }
 else {
      COMPSsLogBaseDirPath=System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str""+ File.separator;
    }
  }
  if (!new File(COMPSsLogBaseDirPath).exists()) {
    if (!new File(COMPSsLogBaseDirPath).mkdir()) {
      ErrorManager.error(ERROR_COMPSs_LOG_BASE_DIR);
    }
  }
  if (mustCreateExecutionSandbox) {
    String appName=System.getProperty(ITConstants.IT_APP_NAME);
    if (System.getProperty(ITConstants.IT_SERVICE_NAME) != null) {
      String serviceName=System.getProperty(ITConstants.IT_SERVICE_NAME);
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + serviceName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
 else {
      int overloadCode=1;
      String appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
      String oldest=appLog;
      while ((new File(appLog).exists()) && (overloadCode <= MAX_OVERLOAD)) {
        if (new File(oldest).lastModified() > new File(appLog).lastModified()) {
          oldest=appLog;
        }
        overloadCode=overloadCode + 1;
        if (overloadCode < 10) {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
 else {
          appLog=COMPSsLogBaseDirPath + appName + ""String_Node_Str""+ String.valueOf(overloadCode)+ File.separator;
        }
      }
      if (overloadCode > MAX_OVERLOAD) {
        appLog=oldest;
        System.err.println(WARN_FOLDER_OVERLOAD);
        System.err.println(""String_Node_Str"" + appLog);
        if (!deleteDirectory(new File(appLog))) {
          ErrorManager.error(ERROR_APP_OVERLOAD);
        }
      }
      appLogDirPath=appLog;
      if (!new File(appLogDirPath).mkdir()) {
        ErrorManager.error(ERROR_APP_LOG_DIR);
      }
      System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
    }
  }
 else {
    appLogDirPath=COMPSsLogBaseDirPath;
    System.setProperty(ITConstants.IT_APP_LOG_DIR,appLogDirPath);
  }
  tempDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(tempDirPath).mkdir()) {
    ErrorManager.error(ERROR_TEMP_DIR);
  }
  jobsDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(jobsDirPath).mkdir()) {
    ErrorManager.error(ERROR_JOBS_DIR);
  }
  workersDirPath=appLogDirPath + ""String_Node_Str"" + File.separator;
  if (!new File(workersDirPath).mkdir()) {
    System.err.println(ERROR_WORKERS_DIR);
    System.exit(1);
  }
}"
70465,"public void start(HashMap<String,String> disks) throws Exception {
  this.node.start();
  for (  java.util.Map.Entry<String,String> disk : disks.entrySet()) {
    addSharedDisk(disk.getKey(),disk.getValue());
  }
}","public void start() throws Exception {
  this.node.start();
  if (sharedDisks != null) {
    for (    java.util.Map.Entry<String,String> disk : sharedDisks.entrySet()) {
      SharedDiskManager.addSharedToMachine(disk.getKey(),disk.getValue(),this);
    }
  }
}"
70466,"public void run(){
  Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
  try {
    selectedResource.getResource().start(new HashMap<String,String>());
    notifyCompleted();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ErrorManager.warn(""String_Node_Str"",e);
    notifyError();
  }
}","public void run(){
  Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
  try {
    selectedResource.getResource().start();
    notifyCompleted();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    ErrorManager.warn(""String_Node_Str"",e);
    notifyError();
  }
}"
70467,"@Override protected void doAction(){
  (new Thread(){
    public void run(){
      Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
      try {
        selectedResource.getResource().start(new HashMap<String,String>());
        notifyCompleted();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        ErrorManager.warn(""String_Node_Str"",e);
        notifyError();
      }
    }
  }
).start();
}","@Override protected void doAction(){
  (new Thread(){
    public void run(){
      Thread.currentThread().setName(selectedResource.getResource().getName() + ""String_Node_Str"");
      try {
        selectedResource.getResource().start();
        notifyCompleted();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        ErrorManager.warn(""String_Node_Str"",e);
        notifyError();
      }
    }
  }
).start();
}"
70468,"public FakeWorker(WorkerResourceDescription description,int limitOfTasks){
  super(""String_Node_Str"",(T)description,new FakeNode(),limitOfTasks);
}","public FakeWorker(WorkerResourceDescription description,int limitOfTasks){
  super(""String_Node_Str"",(T)description,new FakeNode(),limitOfTasks,null);
}"
70469,"public void run(){
  boolean check=operations.getCheck();
  runtimeLogger.debug(""String_Node_Str"" + check);
  CloudMethodResourceDescription requested=rcr.getRequested();
  VM granted;
  if (reused == null) {
    this.setName(""String_Node_Str"" + name);
    try {
      granted=createResourceOnProvider(requested);
    }
 catch (    Exception e) {
      notifyFailure();
      return;
    }
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
 else {
    granted=reused;
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + reused.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
  this.setName(""String_Node_Str"" + granted.getName());
  CloudMethodWorker r=ResourceManager.getDynamicResource(granted.getName());
  if (r == null) {
    if (reused == null) {
      try {
        if (debug) {
          runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
        }
        r=prepareNewResource(granted);
        operations.vmReady(granted);
      }
 catch (      Exception e) {
        runtimeLogger.error(""String_Node_Str"",e);
        powerOff(granted);
        notifyFailure();
        return;
      }
    }
 else {
      int limitOfTasks=granted.getDescription().getTotalComputingUnits();
      r=new CloudMethodWorker(granted.getDescription(),granted.getNode(),limitOfTasks);
      if (debug) {
        runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
      }
    }
    granted.setWorker(r);
    ResourceManager.addCloudWorker(rcr,r);
  }
 else {
    ResourceManager.increasedCloudWorker(rcr,r,granted.getDescription());
  }
synchronized (count) {
    count--;
  }
}","public void run(){
  boolean check=operations.getCheck();
  runtimeLogger.debug(""String_Node_Str"" + check);
  CloudMethodResourceDescription requested=rcr.getRequested();
  VM granted;
  if (reused == null) {
    this.setName(""String_Node_Str"" + name);
    try {
      granted=createResourceOnProvider(requested);
    }
 catch (    Exception e) {
      runtimeLogger.error(""String_Node_Str"",e);
      notifyFailure();
      return;
    }
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
 else {
    granted=reused;
    if (debug) {
      runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
    }
    resourceLogger.info(""String_Node_Str"" + reused.getName() + ""String_Node_Str""+ granted.getEnvId()+ ""String_Node_Str"");
  }
  this.setName(""String_Node_Str"" + granted.getName());
  CloudMethodWorker r=ResourceManager.getDynamicResource(granted.getName());
  if (r == null) {
    if (reused == null) {
      try {
        if (debug) {
          runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
        }
        r=prepareNewResource(granted);
        operations.vmReady(granted);
      }
 catch (      Exception e) {
        runtimeLogger.error(""String_Node_Str"",e);
        powerOff(granted);
        notifyFailure();
        return;
      }
    }
 else {
      int limitOfTasks=granted.getDescription().getTotalComputingUnits();
      r=new CloudMethodWorker(granted.getDescription(),granted.getNode(),limitOfTasks,rcr.getRequested().getImage().getSharedDisks());
      try {
        r.start();
      }
 catch (      Exception e) {
        runtimeLogger.error(""String_Node_Str"",e);
        powerOff(granted);
        notifyFailure();
        return;
      }
      if (debug) {
        runtimeLogger.debug(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
      }
    }
    granted.setWorker(r);
    ResourceManager.addCloudWorker(rcr,r);
  }
 else {
    ResourceManager.increasedCloudWorker(rcr,r,granted.getDescription());
  }
synchronized (count) {
    count--;
  }
}"
70470,"private CloudMethodWorker prepareNewResource(VM vm) throws Exception {
  CloudMethodResourceDescription granted=vm.getDescription();
  CloudImageDescription cid=granted.getImage();
  HashMap<String,String> workerProperties=cid.getProperties();
  String user=cid.getConfig().getUser();
  String password=workerProperties.get(ITConstants.PASSWORD);
  try {
    operations.configureAccess(granted.getName(),user,password);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  try {
    operations.prepareMachine(granted.getName(),cid);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    throw e;
  }
  CloudMethodWorker worker;
  MethodConfiguration mc=new MethodConfiguration(cid.getConfig());
  try {
    int limitOfTasks=mc.getLimitOfTasks();
    int computingUnits=granted.getTotalComputingUnits();
    if (limitOfTasks < 0 && computingUnits < 0) {
      mc.setLimitOfTasks(0);
    }
 else {
      mc.setLimitOfTasks(Math.max(limitOfTasks,computingUnits));
    }
    worker=new CloudMethodWorker(granted.getName(),granted,mc);
    worker.start(cid.getSharedDisks());
  }
 catch (  Exception e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"",e);
  }
  try {
    worker.announceCreation();
  }
 catch (  Exception e) {
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e2) {
      resourceLogger.error(""String_Node_Str"",e2);
    }
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  if (operations.getTerminate()) {
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    try {
      worker.announceDestruction();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    }
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"");
  }
  for (  java.util.Map.Entry<String,String> disk : cid.getSharedDisks().entrySet()) {
    String diskName=disk.getKey();
    String mounpoint=disk.getValue();
    worker.addSharedDisk(diskName,mounpoint);
  }
  return worker;
}","private CloudMethodWorker prepareNewResource(VM vm) throws Exception {
  CloudMethodResourceDescription granted=vm.getDescription();
  CloudImageDescription cid=granted.getImage();
  HashMap<String,String> workerProperties=cid.getProperties();
  String user=cid.getConfig().getUser();
  String password=workerProperties.get(ITConstants.PASSWORD);
  try {
    operations.configureAccess(granted.getName(),user,password);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  try {
    operations.prepareMachine(granted.getName(),cid);
  }
 catch (  ConnectorException e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    throw e;
  }
  CloudMethodWorker worker;
  MethodConfiguration mc=new MethodConfiguration(cid.getConfig());
  try {
    int limitOfTasks=mc.getLimitOfTasks();
    int computingUnits=granted.getTotalComputingUnits();
    if (limitOfTasks < 0 && computingUnits < 0) {
      mc.setLimitOfTasks(0);
    }
 else {
      mc.setLimitOfTasks(Math.max(limitOfTasks,computingUnits));
    }
    worker=new CloudMethodWorker(granted.getName(),granted,mc,cid.getSharedDisks());
    worker.start();
  }
 catch (  Exception e) {
    runtimeLogger.error(""String_Node_Str"" + granted.getName(),e);
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"");
    throw new Exception(""String_Node_Str"",e);
  }
  try {
    worker.announceCreation();
  }
 catch (  Exception e) {
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e2) {
      resourceLogger.error(""String_Node_Str"",e2);
    }
    runtimeLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str""+ provider+ ""String_Node_Str"",e);
    throw e;
  }
  if (operations.getTerminate()) {
    resourceLogger.info(""String_Node_Str"" + granted.getName() + ""String_Node_Str"");
    try {
      worker.announceDestruction();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"" + granted.getName() + ""String_Node_Str"",e);
    }
    Semaphore sem=new Semaphore(0);
    ShutdownListener sl=new ShutdownListener(sem);
    worker.stop(sl);
    sl.enable();
    try {
      sem.acquire();
    }
 catch (    Exception e) {
      resourceLogger.error(""String_Node_Str"");
    }
    throw new Exception(""String_Node_Str"");
  }
  return worker;
}"
70471,"/** 
 * Reconfigures the master node adding its shared disks
 * @param sharedDisks Shared Disk descriptions (diskName->mountpoint)
 */
public static void updateMasterConfiguration(HashMap<String,String> sharedDisks){
  for (  java.util.Map.Entry<String,String> disk : sharedDisks.entrySet()) {
    String diskName=disk.getKey();
    String mountPoint=disk.getValue();
    Comm.appHost.addSharedDisk(diskName,mountPoint);
  }
}","/** 
 * Reconfigures the master node adding its shared disks
 * @param sharedDisks Shared Disk descriptions (diskName->mountpoint)
 */
public static void updateMasterConfiguration(HashMap<String,String> sharedDisks){
  Comm.appHost.updateSharedDisk(sharedDisks);
  try {
    Comm.appHost.start();
  }
 catch (  Exception e) {
    ErrorManager.error(""String_Node_Str"",e);
  }
}"
70472,"/** 
 * Initializes a new Method Worker
 * @param name
 * @param rd
 * @param sharedDisks
 * @param mc
 */
public static void newMethodWorker(String name,MethodResourceDescription rd,HashMap<String,String> sharedDisks,MethodConfiguration mc){
  int taskCount;
  int limitOfTasks=mc.getLimitOfTasks();
  int computingUnits=rd.getTotalComputingUnits();
  if (limitOfTasks < 0 && computingUnits < 0) {
    taskCount=0;
  }
 else {
    taskCount=Math.max(limitOfTasks,computingUnits);
  }
  mc.setLimitOfTasks(taskCount);
  MethodWorker newResource=new MethodWorker(name,rd,mc);
  addStaticResource(newResource);
}","/** 
 * Initializes a new Method Worker
 * @param name
 * @param rd
 * @param sharedDisks
 * @param mc
 */
public static void newMethodWorker(String name,MethodResourceDescription rd,HashMap<String,String> sharedDisks,MethodConfiguration mc){
  int taskCount;
  int limitOfTasks=mc.getLimitOfTasks();
  int computingUnits=rd.getTotalComputingUnits();
  if (limitOfTasks < 0 && computingUnits < 0) {
    taskCount=0;
  }
 else {
    taskCount=Math.max(limitOfTasks,computingUnits);
  }
  mc.setLimitOfTasks(taskCount);
  MethodWorker newResource=new MethodWorker(name,rd,mc,sharedDisks);
  addStaticResource(newResource);
}"
70473,"@Override protected void doFailed(){
  String taskName=task.getTaskParams().getName();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Comm.appHost.getJobsDirPath()).append(""String_Node_Str"");
  Iterator<Integer> j=jobs.iterator();
  while (true) {
    sb.append(j.next());
    if (!j.hasNext()) {
      break;
    }
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  ErrorManager.warn(sb.toString());
  task.setStatus(Task.TaskState.FAILED);
  producer.notifyTaskEnd(task);
}","@Override protected void doFailed(){
  String taskName=task.getTaskParams().getName();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(taskName).append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(Comm.appHost.getJobsDirPath()).append(""String_Node_Str"");
  Iterator<Integer> j=jobs.iterator();
  while (j.hasNext()) {
    sb.append(j.next());
    if (!j.hasNext()) {
      break;
    }
    sb.append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  ErrorManager.warn(sb.toString());
  task.setStatus(Task.TaskState.FAILED);
  producer.notifyTaskEnd(task);
}"
70474,"private void transferJobData(DependencyParameter param,JobTransfersListener listener){
  Worker<?> w=selectedResource.getResource();
  DataAccessId access=param.getDataAccessId();
  if (access instanceof DataAccessId.WAccessId) {
    String tgtName=((DataAccessId.WAccessId)access).getWrittenDataInstance().getRenaming();
    param.setDataTarget(w.getCompleteRemotePath(param.getType(),tgtName));
    return;
  }
  listener.addOperation();
  if (access instanceof DataAccessId.RAccessId) {
    String srcName=((DataAccessId.RAccessId)access).getReadDataInstance().getRenaming();
    w.getData(srcName,srcName,param,listener);
  }
 else {
    String srcName=((DataAccessId.RWAccessId)access).getReadDataInstance().getRenaming();
    String tgtName=((DataAccessId.RWAccessId)access).getWrittenDataInstance().getRenaming();
    w.getData(srcName,tgtName,(LogicalData)null,param,listener);
  }
}","private void transferJobData(DependencyParameter param,JobTransfersListener listener){
  Worker<?> w=selectedResource.getResource();
  DataAccessId access=param.getDataAccessId();
  if (access instanceof DataAccessId.WAccessId) {
    String tgtName=((DataAccessId.WAccessId)access).getWrittenDataInstance().getRenaming();
    if (debug) {
      jobLogger.debug(""String_Node_Str"" + w.getCompleteRemotePath(param.getType(),tgtName));
    }
    param.setDataTarget(w.getCompleteRemotePath(param.getType(),tgtName));
    return;
  }
  listener.addOperation();
  if (access instanceof DataAccessId.RAccessId) {
    String srcName=((DataAccessId.RAccessId)access).getReadDataInstance().getRenaming();
    w.getData(srcName,srcName,param,listener);
  }
 else {
    String srcName=((DataAccessId.RWAccessId)access).getReadDataInstance().getRenaming();
    String tgtName=((DataAccessId.RWAccessId)access).getWrittenDataInstance().getRenaming();
    w.getData(srcName,tgtName,(LogicalData)null,param,listener);
  }
}"
70475,"private static String[] getStartCommand(NIOWorkerNode node,int workerPort){
  String libPath=node.getLibPath();
  String appDir=node.getAppDir();
  String[] jvmFlags=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String workingDir=node.getWorkingDir();
  String cp=(System.getProperty(ITConstants.IT_WORKER_CP) != null && System.getProperty(ITConstants.IT_WORKER_CP).compareTo(""String_Node_Str"") != 0) ? System.getProperty(ITConstants.IT_WORKER_CP) : ""String_Node_Str"";
  String installDir=node.getInstallDir();
  String workerDebug=Boolean.toString(Logger.getLogger(Loggers.WORKER).isDebugEnabled());
  String storageConf=System.getProperty(ITConstants.IT_STORAGE_CONF);
  if ((storageConf == null) || (storageConf.compareTo(""String_Node_Str"") == 0) || (storageConf.compareTo(""String_Node_Str"") == 0)) {
    storageConf=""String_Node_Str"";
    logger.warn(""String_Node_Str"");
  }
  String executionType=System.getProperty(ITConstants.IT_TASK_EXECUTION);
  String[] cmd=new String[19 + jvmFlags.length];
  cmd[0]=installDir + (installDir.endsWith(File.separator) ? ""String_Node_Str"" : File.separator) + STARTER_SCRIPT_PATH+ STARTER_SCRIPT_NAME;
  cmd[1]=libPath.isEmpty() ? ""String_Node_Str"" : libPath;
  cmd[2]=appDir.isEmpty() ? ""String_Node_Str"" : appDir;
  cmd[3]=cp.isEmpty() ? ""String_Node_Str"" : cp;
  cmd[4]=String.valueOf(jvmFlags.length);
  for (int i=0; i < jvmFlags.length; ++i) {
    cmd[5 + i]=jvmFlags[i];
  }
  int nextPosition=5 + jvmFlags.length;
  cmd[nextPosition++]=workerDebug;
  cmd[nextPosition++]=(node.getLimitOfTasks() >= 0) ? String.valueOf(node.getLimitOfTasks()) : String.valueOf(NUM_THREADS);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_SEND_WORKER);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_RECEIVE_WORKER);
  cmd[nextPosition++]=node.getName();
  cmd[nextPosition++]=String.valueOf(workerPort);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MASTER_PORT);
  cmd[nextPosition++]=DEPLOYMENT_ID;
  cmd[nextPosition++]=workingDir;
  cmd[nextPosition++]=node.getInstallDir();
  cmd[nextPosition++]=String.valueOf(tracing_level);
  if (tracing) {
    Integer hostId=NIOTracer.registerHost(node.getName(),NUM_THREADS);
    cmd[nextPosition++]=String.valueOf(hostId.toString());
  }
 else {
    cmd[nextPosition++]=""String_Node_Str"";
  }
  cmd[nextPosition++]=storageConf;
  cmd[nextPosition++]=executionType;
  return cmd;
}","private static String[] getStartCommand(NIOWorkerNode node,int workerPort){
  String libPath=node.getLibPath();
  String appDir=node.getAppDir();
  String workerJVMflags=(System.getProperty(ITConstants.IT_WORKER_JVM_OPTS) != null) ? System.getProperty(ITConstants.IT_WORKER_JVM_OPTS) : ""String_Node_Str"";
  String[] jvmFlags=workerJVMflags.split(""String_Node_Str"");
  String workingDir=node.getWorkingDir();
  String cp=(System.getProperty(ITConstants.IT_WORKER_CP) != null && System.getProperty(ITConstants.IT_WORKER_CP).compareTo(""String_Node_Str"") != 0) ? System.getProperty(ITConstants.IT_WORKER_CP) : ""String_Node_Str"";
  String installDir=node.getInstallDir();
  String workerDebug=Boolean.toString(Logger.getLogger(Loggers.WORKER).isDebugEnabled());
  String storageConf=System.getProperty(ITConstants.IT_STORAGE_CONF);
  if ((storageConf == null) || (storageConf.compareTo(""String_Node_Str"") == 0) || (storageConf.compareTo(""String_Node_Str"") == 0)) {
    storageConf=""String_Node_Str"";
    logger.warn(""String_Node_Str"");
  }
  String executionType=System.getProperty(ITConstants.IT_TASK_EXECUTION);
  String[] cmd=new String[19 + jvmFlags.length];
  cmd[0]=installDir + (installDir.endsWith(File.separator) ? ""String_Node_Str"" : File.separator) + STARTER_SCRIPT_PATH+ STARTER_SCRIPT_NAME;
  cmd[1]=libPath.isEmpty() ? ""String_Node_Str"" : libPath;
  cmd[2]=appDir.isEmpty() ? ""String_Node_Str"" : appDir;
  cmd[3]=cp.isEmpty() ? ""String_Node_Str"" : cp;
  cmd[4]=String.valueOf(jvmFlags.length);
  for (int i=0; i < jvmFlags.length; ++i) {
    cmd[5 + i]=jvmFlags[i];
  }
  int nextPosition=5 + jvmFlags.length;
  cmd[nextPosition++]=workerDebug;
  cmd[nextPosition++]=(node.getLimitOfTasks() >= 0) ? String.valueOf(node.getLimitOfTasks()) : String.valueOf(NUM_THREADS);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_SEND_WORKER);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MAX_RECEIVE_WORKER);
  cmd[nextPosition++]=node.getName();
  cmd[nextPosition++]=String.valueOf(workerPort);
  cmd[nextPosition++]=String.valueOf(NIOAdaptor.MASTER_PORT);
  cmd[nextPosition++]=DEPLOYMENT_ID;
  cmd[nextPosition++]=workingDir;
  cmd[nextPosition++]=node.getInstallDir();
  cmd[nextPosition++]=String.valueOf(tracing_level);
  if (tracing) {
    Integer hostId=NIOTracer.registerHost(node.getName(),NUM_THREADS);
    cmd[nextPosition++]=String.valueOf(hostId.toString());
  }
 else {
    cmd[nextPosition++]=""String_Node_Str"";
  }
  cmd[nextPosition++]=storageConf;
  cmd[nextPosition++]=executionType;
  return cmd;
}"
70476,"@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,DataOperation.EventListener listener){
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
      if (tgtData != null) {
        tgtData.addLocation(target);
      }
      reason.setDataTarget(target.getPath());
      listener.notifyEnd(null);
      return;
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemove();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.appHost)) {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getTargetLoc().getPath())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + target.getPath() + ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.appHost)) {
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + target.getPath() + ""String_Node_Str"",ex);
          }
        }
 else {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  for (  URI u : ld.getURIs()) {
    if (u.getHost() == Comm.appHost) {
      try {
        if (debug) {
          logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        reason.setDataTarget(target.getPath());
        listener.notifyEnd(null);
        ld.releaseHostRemoveLock();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + target.getPath() + ""String_Node_Str"",ex);
      }
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost()+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoveLock();
        return;
      }
 else {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          Files.copy(new File(source.getPath()).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
          listener.notifyEnd(null);
          ld.releaseHostRemoveLock();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + source.getPath() + ""String_Node_Str""+ target.getPath(),ex);
        }
      }
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        continue;
      }
      logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoveLock();
      return;
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoveLock();
}","@Override public void obtainData(LogicalData ld,DataLocation source,DataLocation target,LogicalData tgtData,Transferable reason,DataOperation.EventListener listener){
  if (ld.isInMemory()) {
    try {
      Serializer.serialize(ld.getValue(),target.getPath());
      if (tgtData != null) {
        tgtData.addLocation(target);
      }
      logger.debug(""String_Node_Str"" + target.getPath());
      reason.setDataTarget(target.getPath());
      listener.notifyEnd(null);
      return;
    }
 catch (    IOException ex) {
      ErrorManager.warn(""String_Node_Str"" + target.getPath(),ex);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
  }
  ld.lockHostRemove();
  Collection<Copy> copiesInProgress=ld.getCopiesInProgress();
  if (copiesInProgress != null && !copiesInProgress.isEmpty()) {
    for (    Copy copy : copiesInProgress) {
      if (copy != null) {
        if (copy.getTargetLoc() != null && copy.getTargetLoc().getHosts().contains(Comm.appHost)) {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + target.getPath());
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ target.getPath()+ ""String_Node_Str"",ex);
          }
        }
 else         if (copy.getTargetData() != null && copy.getTargetData().getAllHosts().contains(Comm.appHost)) {
          waitForCopyTofinish(copy);
          try {
            if (debug) {
              logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ copy.getFinalTarget()+ ""String_Node_Str""+ target.getPath());
            }
            Files.copy((new File(copy.getFinalTarget())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
            if (tgtData != null) {
              tgtData.addLocation(target);
            }
            logger.debug(""String_Node_Str"" + target.getPath());
            reason.setDataTarget(target.getPath());
            listener.notifyEnd(null);
            ld.releaseHostRemoveLock();
            return;
          }
 catch (          IOException ex) {
            ErrorManager.warn(""String_Node_Str"" + copy.getFinalTarget() + ""String_Node_Str""+ target.getPath()+ ""String_Node_Str"",ex);
          }
        }
 else {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
          }
        }
      }
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ Comm.appHost+ ""String_Node_Str"");
  }
  for (  URI u : ld.getURIs()) {
    logger.debug(ld.getName() + ""String_Node_Str"" + u.toString()+ ""String_Node_Str""+ u.getHost()+ ""String_Node_Str"");
    if (u.getHost() == Comm.appHost) {
      try {
        if (debug) {
          logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost().getName()+ ""String_Node_Str""+ target.getPath());
        }
        Files.copy((new File(u.getPath())).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
        if (tgtData != null) {
          tgtData.addLocation(target);
        }
        logger.debug(""String_Node_Str"" + target.getPath());
        reason.setDataTarget(target.getPath());
        listener.notifyEnd(null);
        ld.releaseHostRemoveLock();
        return;
      }
 catch (      IOException ex) {
        ErrorManager.warn(""String_Node_Str"" + u.getPath() + ""String_Node_Str""+ target.getPath()+ ""String_Node_Str"",ex);
      }
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ u.getHost()+ ""String_Node_Str"");
      }
    }
  }
  if (source != null) {
    for (    Resource sourceRes : source.getHosts()) {
      COMPSsNode node=sourceRes.getNode();
      if (node != this) {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          node.sendData(ld,source,target,tgtData,reason,listener);
        }
 catch (        Exception e) {
          ErrorManager.warn(""String_Node_Str"" + target.getPath(),e);
          continue;
        }
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
        ld.releaseHostRemoveLock();
        return;
      }
 else {
        try {
          if (debug) {
            logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ source.getPath()+ ""String_Node_Str""+ target.getPath());
          }
          Files.copy(new File(source.getPath()).toPath(),new File(target.getPath()).toPath(),StandardCopyOption.REPLACE_EXISTING);
          logger.debug(""String_Node_Str"" + target.getPath());
          reason.setDataTarget(target.getPath());
          listener.notifyEnd(null);
          ld.releaseHostRemoveLock();
          return;
        }
 catch (        IOException ex) {
          ErrorManager.warn(""String_Node_Str"" + source.getPath() + ""String_Node_Str""+ target.getPath(),ex);
        }
      }
    }
  }
 else {
    logger.debug(""String_Node_Str"");
  }
  for (  Resource sourceRes : ld.getAllHosts()) {
    COMPSsNode node=sourceRes.getNode();
    if (node != this) {
      try {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str""+ target.getPath());
        node.sendData(ld,source,target,tgtData,reason,listener);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        continue;
      }
      logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str"");
      ld.releaseHostRemoveLock();
      return;
    }
 else {
      if (debug) {
        logger.debug(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ sourceRes.getName()+ ""String_Node_Str"");
      }
    }
  }
  ErrorManager.warn(""String_Node_Str"" + ld.getName() + ""String_Node_Str""+ target.getPath());
  ld.releaseHostRemoveLock();
}"
70477,"private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
}","private void waitForCopyTofinish(Copy copy){
  Semaphore sem=new Semaphore(0);
  SafeCopyListener currentCopylistener=new SafeCopyListener(sem);
  copy.addEventListener(currentCopylistener);
  currentCopylistener.addOperation();
  currentCopylistener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    ErrorManager.warn(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + copy.getName() + ""String_Node_Str""+ copy.getId()+ ""String_Node_Str"");
  }
}"
70478,"private synchronized void addLocation_private(DataLocation loc){
  isBeingSaved=false;
  locations.add(loc);
switch (loc.getType()) {
case PRIVATE:
    for (    Resource host : loc.getHosts()) {
      if (host == null) {
        host=Comm.appHost;
      }
      boolean done=false;
      HashSet<LogicalData> files=null;
      while (!done) {
        try {
          files=hostToPrivateFiles.get(host);
          if (files == null) {
            files=new HashSet<LogicalData>();
            hostToPrivateFiles.put(host,files);
          }
          done=true;
        }
 catch (        ConcurrentModificationException cme) {
          logger.debug(""String_Node_Str"");
        }
      }
      files.add(this);
    }
  if (loc.getPath().startsWith(File.separator)) {
    onFile=true;
  }
break;
case SHARED:
String shared=loc.getSharedDisk();
boolean done=false;
HashSet<LogicalData> files=null;
while (!done) {
try {
files=sharedDiskToSharedFiles.get(shared);
if (files == null) {
files=new HashSet<LogicalData>();
sharedDiskToSharedFiles.put(shared,files);
}
done=true;
}
 catch (ConcurrentModificationException cme) {
logger.debug(""String_Node_Str"");
}
}
files.add(this);
onFile=true;
break;
}
}","private synchronized void addLocation_private(DataLocation loc){
  isBeingSaved=false;
  locations.add(loc);
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + this.getName() + ""String_Node_Str""+ loc.getLocationKey()+ ""String_Node_Str"");
  }
switch (loc.getType()) {
case PRIVATE:
    for (    Resource host : loc.getHosts()) {
      if (host == null) {
        host=Comm.appHost;
      }
      boolean done=false;
      HashSet<LogicalData> files=null;
      while (!done) {
        try {
          files=hostToPrivateFiles.get(host);
          if (files == null) {
            files=new HashSet<LogicalData>();
            hostToPrivateFiles.put(host,files);
          }
          done=true;
        }
 catch (        ConcurrentModificationException cme) {
          logger.debug(""String_Node_Str"");
        }
      }
      files.add(this);
    }
  if (loc.getPath().startsWith(File.separator)) {
    onFile=true;
  }
break;
case SHARED:
String shared=loc.getSharedDisk();
boolean done=false;
HashSet<LogicalData> files=null;
while (!done) {
try {
files=sharedDiskToSharedFiles.get(shared);
if (files == null) {
files=new HashSet<LogicalData>();
sharedDiskToSharedFiles.put(shared,files);
}
done=true;
}
 catch (ConcurrentModificationException cme) {
logger.debug(""String_Node_Str"");
}
}
files.add(this);
onFile=true;
break;
}
}"
70479,"public Copy(LogicalData srcData,DataLocation prefSrc,DataLocation prefTgt,LogicalData tgtData,Transferable reason,EventListener listener){
  super(srcData,listener);
  this.srcData=srcData;
  this.srcLoc=prefSrc;
  this.tgtData=tgtData;
  this.tgtLoc=prefTgt;
  this.reason=reason;
}","public Copy(LogicalData srcData,DataLocation prefSrc,DataLocation prefTgt,LogicalData tgtData,Transferable reason,EventListener listener){
  super(srcData,listener);
  this.srcData=srcData;
  this.srcLoc=prefSrc;
  this.tgtData=tgtData;
  this.tgtLoc=prefTgt;
  this.reason=reason;
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName() + ""String_Node_Str""+ this.getId()+ ""String_Node_Str"");
  }
}"
70480,"public void setFinalTarget(String targetAbsolutePath){
  reason.setDataTarget(targetAbsolutePath);
}","public void setFinalTarget(String targetAbsolutePath){
  if (debug) {
    logger.debug(""String_Node_Str"" + targetAbsolutePath);
  }
  reason.setDataTarget(targetAbsolutePath);
}"
70481,"public void stop(boolean saveUniqueData,ShutdownListener sl){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=LogicalData.getAllDataFromHost(this);
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=DataLocation.getLocation(Comm.appHost,Comm.appHost.getTempDirPath() + ld.getName());
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (tracing) {
      node.generatePackage();
      getTracingPackageToMaster();
      if (debug) {
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
      logger.debug(""String_Node_Str"" + this.getName());
    }
  }
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}","public void stop(ShutdownListener sl){
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}"
70482,"public void copiedData(int transferGroupId){
  LinkedList<Copy> copies=groupToCopy.remove(transferGroupId);
  if (copies == null) {
    return;
  }
  for (  Copy c : copies) {
    if (!c.isRegistered()) {
      continue;
    }
    DataLocation actualLocation=c.getSourceData().finishedCopy(c);
    LogicalData tgtData=c.getTargetData();
    if (tgtData != null) {
      tgtData.addLocation(actualLocation);
    }
  }
}","public void copiedData(int transferGroupId){
  logger.debug(""String_Node_Str"");
  LinkedList<Copy> copies=groupToCopy.remove(transferGroupId);
  if (copies == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  for (  Copy c : copies) {
    logger.debug(""String_Node_Str"" + c.getName());
    if (!c.isRegistered()) {
      logger.debug(""String_Node_Str"" + c.getName());
      continue;
    }
    DataLocation actualLocation=c.getSourceData().finishedCopy(c);
    if (actualLocation != null) {
      logger.debug(""String_Node_Str"" + actualLocation.getPath());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    LogicalData tgtData=c.getTargetData();
    if (tgtData != null) {
      logger.debug(""String_Node_Str"");
      if (actualLocation.getType().equals(DataLocation.Type.PRIVATE)) {
        logger.debug(""String_Node_Str"" + actualLocation.getPath() + ""String_Node_Str""+ tgtData.getName());
        tgtData.addLocation(actualLocation);
      }
 else {
        logger.debug(""String_Node_Str"" + tgtData.getName());
      }
      logger.debug(""String_Node_Str"" + tgtData.getName() + ""String_Node_Str""+ tgtData.getURIs());
    }
 else {
      logger.warn(""String_Node_Str"" + c.getName());
    }
  }
}"
70483,"public long getMonitorInterval(){
  return config.getLong(ITConstants.IT_MONITOR);
}","public long getMonitorInterval(){
  return config.getLong(ITConstants.IT_MONITOR,ITConstants.DEFAULT_MONITOR_INTERVAL);
}"
70484,"public String getDeploymentId(){
  return config.getString(ITConstants.IT_DEPLOYMENT_ID);
}","public String getDeploymentId(){
  return config.getString(ITConstants.IT_DEPLOYMENT_ID,ITConstants.DEFAULT_DEPLOYMENT_ID);
}"
70485,"public void stop(boolean saveUniqueData,ShutdownListener sl){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=LogicalData.getAllDataFromHost(this);
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=DataLocation.getLocation(Comm.appHost,Comm.appHost.getTempDirPath() + ld.getName());
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (this.getType() != Type.SERVICE) {
    if (tracing) {
      node.generatePackage();
      getTracingPackageToMaster();
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
    }
  }
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}","public void stop(boolean saveUniqueData,ShutdownListener sl){
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  Semaphore sem=new Semaphore(0);
  SafeCopyListener listener=new SafeCopyListener(sem);
  HashSet<LogicalData> lds=LogicalData.getAllDataFromHost(this);
  HashMap<String,String> disks=SharedDiskManager.terminate(this);
  COMPSsNode masterNode=Comm.appHost.getNode();
  for (  LogicalData ld : lds) {
    ld.notifyToInProgressCopiesEnd(listener);
    DataLocation lastLoc=ld.removeHostAndCheckLocationToSave(this,disks);
    if (lastLoc != null && saveUniqueData) {
      listener.addOperation();
      DataLocation safeLoc=DataLocation.getLocation(Comm.appHost,Comm.appHost.getTempDirPath() + ld.getName());
      masterNode.obtainData(ld,lastLoc,safeLoc,ld,new SafeCopyTransferable(),listener);
    }
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  listener.enable();
  try {
    sem.acquire();
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + getName() + ""String_Node_Str"");
  }
  if (debug) {
    logger.debug(""String_Node_Str"" + this.getName());
  }
  if (this.getType() != Type.SERVICE) {
    if (tracing) {
      node.generatePackage();
      getTracingPackageToMaster();
      if (debug) {
        logger.debug(""String_Node_Str"" + this.getName());
      }
    }
    if (debug) {
      node.generateWorkersDebugInfo();
      getWorkersDebugInfo();
      logger.debug(""String_Node_Str"" + this.getName());
    }
  }
  this.deleteIntermediate();
  sl.addOperation();
  node.stop(sl);
}"
70486,"public void receivedShutdown(Connection requester,LinkedList<Data> filesToSend){
  closingConnection=requester;
  finish=true;
  if (!hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}","public void receivedShutdown(Connection requester,LinkedList<Data> filesToSend){
  logger.debug(""String_Node_Str"");
  closingConnection=requester;
  finish=true;
  if (!hasPendingTransfers()) {
    shutdown(closingConnection);
  }
}"
70487,"@Override public void generateWorkersDebugInfo(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles(this.getHost(),this.getInstallDir(),this.getWorkingDir(),this.getName());
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  logger.debug(""String_Node_Str"");
}","@Override public void generateWorkersDebugInfo(){
  logger.debug(""String_Node_Str"" + this.getHost());
  if (node == null) {
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  CommandGenerateWorkerDebugFiles cmd=new CommandGenerateWorkerDebugFiles(this.getHost(),this.getInstallDir(),this.getWorkingDir(),this.getName());
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
  commManager.waitUntilWorkersDebugInfoGenerated();
  logger.debug(""String_Node_Str"");
}"
70488,"@Override public void stop(ShutdownListener sl){
  logger.info(""String_Node_Str"" + this.getName());
  if (node == null) {
    sl.notifyFailure(new Exception());
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  commManager.shuttingDown(this,c,sl);
  CommandShutdown cmd=new CommandShutdown(null,null);
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
}","@Override public void stop(ShutdownListener sl){
  logger.debug(""String_Node_Str"" + this.getName());
  if (node == null) {
    sl.notifyFailure(new Exception());
    logger.error(""String_Node_Str"");
  }
  Connection c=NIOAgent.tm.startConnection(node);
  commManager.shuttingDown(this,c,sl);
  CommandShutdown cmd=new CommandShutdown(null,null);
  c.sendCommand(cmd);
  c.receive();
  c.finishConnection();
}"
70489,"public void processRequests(){
  while (true) {
    Job<?> job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      job.submit();
      if (debug) {
        logger.debug(""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      logger.error(SUBMISSION_ERROR + job.getJobId(),ex);
      job.getListener().jobFailed(job,Job.JobListener.JobEndStatus.SUBMISSION_FAILED);
    }
  }
}","public void processRequests(){
  while (true) {
    Job<?> job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      job.submit();
      if (debug) {
        logger.debug(""String_Node_Str"" + job.getJobId() + ""String_Node_Str"");
      }
    }
 catch (    Exception ex) {
      logger.error(SUBMISSION_ERROR + job.getJobId(),ex);
      job.getListener().jobFailed(job,Job.JobListener.JobEndStatus.SUBMISSION_FAILED);
    }
  }
  logger.debug(""String_Node_Str"");
}"
70490,"@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob(taskId,taskParams,impl,res,listener);
}","@Override public Job<?> newJob(int taskId,TaskParams taskParams,Implementation<?> impl,Resource res,JobListener listener){
  return new WSJob<COMPSsWorker>(taskId,taskParams,impl,res,listener);
}"
70491,"public static void init() throws Exception {
  if (callerQueue == null) {
    callerQueue=new RequestQueue<WSJob>();
  }
 else {
    callerQueue.clear();
  }
  caller=new WSCaller(callerQueue);
  callerPool=new ThreadPool(POOL_SIZE,POOL_NAME,caller);
  try {
    callerPool.startThreads();
  }
 catch (  Exception e) {
    logger.error(THREAD_POOL_ERR,e);
    throw e;
  }
}","public static void init() throws Exception {
  if (callerQueue == null) {
    callerQueue=new RequestQueue<WSJob<?>>();
  }
 else {
    callerQueue.clear();
  }
  caller=new WSCaller(callerQueue);
  callerPool=new ThreadPool(POOL_SIZE,POOL_NAME,caller);
  try {
    callerPool.startThreads();
  }
 catch (  Exception e) {
    logger.error(THREAD_POOL_ERR,e);
    throw e;
  }
}"
70492,"public WSCaller(RequestQueue<WSJob> queue){
  super(queue);
}","public WSCaller(RequestQueue<WSJob<?>> queue){
  super(queue);
}"
70493,"public void processRequests(){
  while (true) {
    WSJob job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskParams taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == ParamDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case SCO_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}","public void processRequests(){
  while (true) {
    WSJob<?> job=null;
    job=queue.dequeue();
    if (job == null) {
      break;
    }
    try {
      ArrayList<Object> input=new ArrayList<Object>();
      TaskParams taskParams=job.taskParams;
      ServiceImplementation service=(ServiceImplementation)job.impl;
      Parameter[] parameters=taskParams.getParameters();
      for (int i=0; i < taskParams.getParameters().length; i++) {
        if (parameters[i].getDirection() == ParamDirection.IN) {
switch (parameters[i].getType()) {
case OBJECT_T:
case SCO_T:
case PSCO_T:
            DependencyParameter dp=(DependencyParameter)parameters[i];
          Object o=getObjectValue(dp);
        input.add(o);
      break;
case FILE_T:
    break;
default :
  BasicTypeParameter btParB=(BasicTypeParameter)parameters[i];
input.add(btParB.getValue());
}
}
}
ServiceInstance si=(ServiceInstance)job.getResourceNode();
String portName=service.getRequirements().getPort();
String operationName=service.getOperation();
if (operationName.compareTo(""String_Node_Str"") == 0) {
operationName=taskParams.getName();
}
Client client=getClient(si,portName);
ClientCallback cb=new ClientCallback();
client.invoke(cb,operationName,input.toArray());
Object[] result=cb.get();
if (result.length > 0) {
job.returnValue=result[0];
}
job.listener.jobCompleted(job);
}
 catch (Exception e) {
job.listener.jobFailed(job,JobEndStatus.EXECUTION_FAILED);
logger.error(SUBMIT_ERROR,e);
return;
}
}
}"
70494,"@Override public void reduceDynamic(ResourceDescription rd){
}","@Override public ResourceDescription reduceDynamic(ResourceDescription rd){
  return null;
}"
70495,"private static void testImmutableObjects(){
  Integer i=ObjectTestImpl.createInteger(5);
  String s=ObjectTestImpl.createString(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + i);
  System.out.println(""String_Node_Str"" + s);
  ObjectTestImpl.printObjects(i,s);
}","private static void testImmutableObjects(){
  Integer i=ObjectTestImpl.createInteger(5);
  String s=ObjectTestImpl.createString(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + i);
  System.out.println(""String_Node_Str"" + s);
  ObjectTestImpl.printContent(i,s);
}"
70496,"public static void printObjects(Integer i,String s){
  System.out.println(""String_Node_Str"" + i);
  System.out.println(""String_Node_Str"" + s);
}","public static void printObjects(A a,B b){
  System.out.println(""String_Node_Str"" + a.getIntField());
  System.out.println(""String_Node_Str"" + b.getStringField());
}"
70497,"@Method(declaringClass=""String_Node_Str"") void printObjects(@Parameter(type=Type.OBJECT,direction=Direction.IN) Integer i,@Parameter(type=Type.OBJECT,direction=Direction.IN) String s);","@Method(declaringClass=""String_Node_Str"") void printObjects(@Parameter(type=Type.OBJECT,direction=Direction.IN) A a,@Parameter(type=Type.OBJECT,direction=Direction.IN) B b);"
70498,"public AbstractCustomCardWithType(String id,String name,String img,String bgTexture,String bgTexture_p,int cost,String rawDescription,CardType type,CardColor color,CardRarity rarity,CardTarget target,int cardPool,CardColorType damageType,boolean willApplyPowers){
  super(id,name,img,bgTexture,bgTexture_p,cost,rawDescription,type,color,rarity,target,cardPool);
  colorType=damageType;
  this.willApplyPowers=willApplyPowers;
}","public AbstractCustomCardWithType(String id,String name,String img,String bgTexture,String bgTexture_p,int cost,String rawDescription,CardType type,CardColor color,CardRarity rarity,CardTarget target,int cardPool,CardColorType damageType,boolean willApplyPowers){
  super(id,name,img,bgTexture,bgTexture_p,cost,rawDescription,type,color,rarity,target,cardPool);
  colorType=damageType;
  this.willApplyPowers=willApplyPowers;
  assignOrbTexture();
}"
70499,"public ShadowStrike(){
  super(ID,NAME,IMG,BG_IMG,BG_IMG_P,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1);
  this.baseDamage=ATK_DMG;
}","public ShadowStrike(){
  super(ID,NAME,IMG,BG_IMG,BG_IMG_P,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1,COLOR_TYPE);
  this.baseDamage=ATK_DMG;
}"
70500,"public ShadowWall(){
  super(ID,NAME,IMG,BG_IMG,BG_IMG_P,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1);
  this.baseDamage=ATK_DMG;
  this.baseBlock=BLOCK;
}","public ShadowWall(){
  super(ID,NAME,IMG,BG_IMG,BG_IMG_P,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1,COLOR_TYPE);
  this.baseDamage=ATK_DMG;
  this.baseBlock=BLOCK;
}"
70501,"@Override public void update(){
  if (!AbstractDungeon.isScreenUp) {
    this.duration-=Gdx.graphics.getDeltaTime();
    updateBlackScreenColor();
  }
  if ((!this.selectedCard) && (!AbstractDungeon.gridSelectScreen.selectedCards.isEmpty())) {
    CardCrawlGame.sound.play(""String_Node_Str"");
    AbstractCustomCardWithType card=(AbstractCustomCardWithType)AbstractDungeon.gridSelectScreen.selectedCards.get(0);
    AbstractCustomCardWithType newCard=card.getOpposite(card.upgraded);
    AbstractDungeon.player.masterDeck.removeCard(card);
    AbstractDungeon.effectsQueue.add(new ShowCardAndObtainEffect(newCard,Settings.WIDTH / 2,Settings.HEIGHT / 2));
    AbstractDungeon.gridSelectScreen.selectedCards.clear();
    this.selectedCard=true;
    ((RestRoom)AbstractDungeon.getCurrRoom()).fadeIn();
  }
  if ((this.duration < 1.0F) && (!this.openedScreen)) {
    this.openedScreen=true;
    CardGroup fire_ice_cards=new CardGroup(CardGroup.CardGroupType.UNSPECIFIED);
    for (    AbstractCard card : AbstractDungeon.player.masterDeck.group) {
      if (card instanceof AbstractCustomCardWithType) {
        AbstractCustomCardWithType typeCard=(AbstractCustomCardWithType)card;
        if (typeCard.colorType == AbstractCustomCardWithType.CardColorType.ICE || typeCard.colorType == AbstractCustomCardWithType.CardColorType.FIRE) {
          fire_ice_cards.group.add(card);
        }
      }
    }
    AbstractDungeon.gridSelectScreen.open(fire_ice_cards,1,ExchangeOption.LABEL,false);
  }
  if (this.duration < 0.0F) {
    this.isDone=true;
    if (CampfireUI.hidden) {
      com.megacrit.cardcrawl.rooms.AbstractRoom.waitTimer=0.0F;
      AbstractDungeon.getCurrRoom().phase=AbstractRoom.RoomPhase.COMPLETE;
      ((RestRoom)AbstractDungeon.getCurrRoom()).cutFireSound();
    }
  }
}","@Override public void update(){
  if (!AbstractDungeon.isScreenUp) {
    this.duration-=Gdx.graphics.getDeltaTime();
    updateBlackScreenColor();
  }
  if ((!this.selectedCard) && (!AbstractDungeon.gridSelectScreen.selectedCards.isEmpty())) {
    CardCrawlGame.sound.play(""String_Node_Str"");
    AbstractCustomCardWithType card=(AbstractCustomCardWithType)AbstractDungeon.gridSelectScreen.selectedCards.get(0);
    AbstractCustomCardWithType newCard=card.getOpposite(card.upgraded);
    AbstractDungeon.player.masterDeck.removeCard(card);
    AbstractDungeon.effectsQueue.add(new ShowCardAndObtainEffect(newCard,Settings.WIDTH / 2,Settings.HEIGHT / 2));
    AbstractDungeon.gridSelectScreen.selectedCards.clear();
    this.selectedCard=true;
    ((RestRoom)AbstractDungeon.getCurrRoom()).fadeIn();
  }
  if ((this.duration < 1.0F) && (!this.openedScreen)) {
    this.openedScreen=true;
    CardGroup fire_ice_cards=new CardGroup(CardGroup.CardGroupType.UNSPECIFIED);
    for (    AbstractCard card : AbstractDungeon.player.masterDeck.group) {
      if (card instanceof AbstractCustomCardWithType) {
        AbstractCustomCardWithType typeCard=(AbstractCustomCardWithType)card;
        if (typeCard.colorType == AbstractCustomCardWithType.CardColorType.ICE || typeCard.colorType == AbstractCustomCardWithType.CardColorType.FIRE) {
          fire_ice_cards.group.add(card);
        }
      }
    }
    AbstractDungeon.gridSelectScreen.open(fire_ice_cards,1,ExchangeOption.LABEL,false,false,true,true);
  }
  if (this.duration < 0.0F) {
    this.isDone=true;
    if (CampfireUI.hidden) {
      com.megacrit.cardcrawl.rooms.AbstractRoom.waitTimer=0.0F;
      AbstractDungeon.getCurrRoom().phase=AbstractRoom.RoomPhase.COMPLETE;
      ((RestRoom)AbstractDungeon.getCurrRoom()).cutFireSound();
    }
  }
}"
70502,"public RemoveDebuffAction(AbstractCreature target,AbstractCreature owner,int debuffsRemoved){
  for (int i=0; i < debuffsRemoved; i++) {
    ArrayList<AbstractPower> debuffs=new ArrayList<AbstractPower>();
    for (    AbstractPower p : target.powers) {
      if (p.type == AbstractPower.PowerType.DEBUFF) {
        debuffs.add(p);
      }
    }
    if (!debuffs.isEmpty()) {
      AbstractPower randDebuff=debuffs.get((new Random()).random(debuffs.size()));
      randDebuff.flash();
      AbstractDungeon.actionManager.addToBottom(new RemoveSpecificPowerAction(target,target,randDebuff.ID));
    }
  }
}","public RemoveDebuffAction(AbstractCreature target,AbstractCreature owner,int debuffsRemoved){
  for (int i=0; i < debuffsRemoved; i++) {
    ArrayList<AbstractPower> debuffs=new ArrayList<AbstractPower>();
    for (    AbstractPower p : target.powers) {
      if (p.type == AbstractPower.PowerType.DEBUFF) {
        debuffs.add(p);
      }
    }
    if (!debuffs.isEmpty()) {
      AbstractPower randDebuff=debuffs.get((new Random()).random(debuffs.size() - 1));
      randDebuff.flash();
      AbstractDungeon.actionManager.addToBottom(new RemoveSpecificPowerAction(target,target,randDebuff.ID));
    }
  }
}"
70503,"public Cauterize(){
  super(ID,NAME,IMG,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,POOL);
  this.isInnate=true;
  tips=new ArrayList<TooltipInfo>();
  tips.add(new TooltipInfo(""String_Node_Str"",""String_Node_Str""));
  this.exhaust=true;
}","public Cauterize(){
  super(ID,NAME,IMG,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,POOL);
  tips=new ArrayList<TooltipInfo>();
  tips.add(new TooltipInfo(""String_Node_Str"",""String_Node_Str""));
  this.exhaust=true;
}"
70504,"public void upgrade(){
  if (!this.upgraded) {
    this.upgradeName();
    this.exhaust=false;
    this.EXHAUST_TEXT=""String_Node_Str"";
  }
}","public void upgrade(){
  if (!this.upgraded) {
    this.upgradeName();
    this.exhaust=false;
    this.rawDescription=""String_Node_Str"";
    this.initializeDescription();
  }
}"
70505,"@Override public void use(AbstractPlayer p,AbstractMonster arg1){
  AbstractDungeon.actionManager.addToBottom(new GainEnergyAction(magicNumber));
}","@Override public void use(AbstractPlayer p,AbstractMonster arg1){
  if (p.hasPower(""String_Node_Str""))   AbstractDungeon.actionManager.addToBottom(new RemoveSpecificPowerAction(p,p,""String_Node_Str""));
  if (p.hasPower(""String_Node_Str""))   AbstractDungeon.actionManager.addToBottom(new RemoveSpecificPowerAction(p,p,""String_Node_Str""));
  BlackMageMod.resetOrbColor((CustomPlayer)p);
  AbstractDungeon.actionManager.addToBottom(new GainEnergyAction(magicNumber));
}"
70506,"@Override public void use(AbstractPlayer p,AbstractMonster m){
  AbstractDungeon.actionManager.addToBottom(new DiscardAction(p,p,1,false));
  AbstractDungeon.actionManager.addToBottom(new ApplyPowerAction(p,m,new WeakPower(m,magicNumber,false),magicNumber));
}","@Override public void use(AbstractPlayer p,AbstractMonster m){
  AbstractDungeon.actionManager.addToBottom(new DiscardAction(p,p,1,false));
  AbstractDungeon.actionManager.addToBottom(new ApplyPowerAction(m,p,new WeakPower(m,magicNumber,false),magicNumber));
}"
70507,"public HotCoals(){
  super(ID,NAME,IMG,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1,COLOR_TYPE);
  this.baseMagicNumber=MAGIC;
  this.magicNumber=MAGIC;
}","public HotCoals(){
  super(ID,NAME,IMG,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1,COLOR_TYPE);
  this.baseMagicNumber=MAGIC;
  this.magicNumber=MAGIC;
  this.bonus=0;
}"
70508,"@Override public void upgrade(){
  if (!upgraded) {
    this.upgradeName();
    this.upgradeBaseCost(0);
  }
}","@Override public void upgrade(){
  if (!upgraded) {
    this.upgradeName();
    bonus=1;
  }
}"
70509,"@Override public void use(AbstractPlayer p,AbstractMonster m){
  if (p.hasPower(""String_Node_Str"")) {
    int amt=p.getPower(""String_Node_Str"").amount;
    AbstractDungeon.actionManager.addToBottom(new ApplyPowerAction(p,p,new GainAshNextTurnPower(p,amt),amt));
    AbstractDungeon.actionManager.addToBottom(new RemoveSpecificPowerAction(p,p,""String_Node_Str""));
  }
}","@Override public void use(AbstractPlayer p,AbstractMonster m){
  if (p.hasPower(""String_Node_Str"")) {
    int amt=p.getPower(""String_Node_Str"").amount + bonus;
    AbstractDungeon.actionManager.addToBottom(new ApplyPowerAction(p,p,new GainAshNextTurnPower(p,amt),amt));
    AbstractDungeon.actionManager.addToBottom(new RemoveSpecificPowerAction(p,p,""String_Node_Str""));
  }
}"
70510,"public SheerCold(){
  super(ID,NAME,IMG,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1,COLOR_TYPE);
}","public SheerCold(){
  super(ID,NAME,IMG,COST,DESCRIPTION,TYPE,COLOR,RARITY,TARGET,1,COLOR_TYPE);
  this.exhaust=true;
}"
70511,"public static CharSelectInfo getLoadout(){
  CharSelectInfo selectInfo=new CharSelectInfo(""String_Node_Str"",""String_Node_Str"",START_HP,START_HP,1,99,5,EnumPatch.BLACK_MAGE_CLASS,getStartingRelics(),getStartingDeck(),false);
  return selectInfo;
}","public static CharSelectInfo getLoadout(){
  CharSelectInfo selectInfo=new CharSelectInfo(""String_Node_Str"",""String_Node_Str"",START_HP,START_HP,2,99,5,EnumPatch.BLACK_MAGE_CLASS,getStartingRelics(),getStartingDeck(),false);
  return selectInfo;
}"
70512,"public void stackPower(int stackAmount){
  this.amount+=stackAmount;
  if (this.amount >= 5) {
    this.flash();
    AbstractDungeon.actionManager.addToBottom(new DamageRandomEnemyAction(new DamageInfo(owner,5,DamageInfo.DamageType.THORNS),AttackEffect.FIRE));
    this.amount=1;
  }
}","public void stackPower(int stackAmount){
  this.amount+=stackAmount;
  if (this.amount >= cap) {
    this.flash();
    AbstractDungeon.actionManager.addToBottom(new DamageRandomEnemyAction(new DamageInfo(owner,5,DamageInfo.DamageType.THORNS),AttackEffect.FIRE));
    this.amount=1;
  }
}"
70513,"@Override public void updateDescription(){
  if (this.amount > 0) {
    this.description=(""String_Node_Str"" + DESCRIPTIONS[0] + this.amount+ ""String_Node_Str"");
  }
}","@Override public void updateDescription(){
  if (this.amount > 0) {
    this.description=(""String_Node_Str"" + DESCRIPTIONS[0] + this.amount+ ""String_Node_Str""+ cap+ ""String_Node_Str"");
  }
}"
70514,"public FreezePower(AbstractCreature owner){
  this.name=""String_Node_Str"";
  this.ID=""String_Node_Str"";
  this.owner=owner;
  this.amount=-1;
  this.updateDescription();
  this.type=AbstractPower.PowerType.DEBUFF;
  this.img=BlackMageMod.getTexture(""String_Node_Str"");
  moveByte=1;
  moveIntent=AbstractMonster.Intent.UNKNOWN;
  if (owner instanceof AbstractMonster) {
    AbstractMonster m=(AbstractMonster)owner;
    moveByte=Byte.valueOf(m.nextMove);
    moveIntent=AbstractMonster.Intent.valueOf(m.intent.name());
    m.setMove(Byte.MAX_VALUE,AbstractMonster.Intent.STUN);
    m.createIntent();
    AbstractDungeon.actionManager.addToBottom(new SetMoveAction(m,Byte.MAX_VALUE,AbstractMonster.Intent.STUN));
  }
}","public FreezePower(AbstractCreature owner){
  this.name=""String_Node_Str"";
  this.ID=""String_Node_Str"";
  this.owner=owner;
  this.amount=-1;
  this.updateDescription();
  this.type=AbstractPower.PowerType.DEBUFF;
  this.img=BlackMageMod.getTexture(""String_Node_Str"");
  moveByte=1;
  moveIntent=AbstractMonster.Intent.UNKNOWN;
  if (owner instanceof AbstractMonster && !owner.hasPower(""String_Node_Str"")) {
    AbstractMonster m=(AbstractMonster)owner;
    moveByte=Byte.valueOf(m.nextMove);
    moveIntent=AbstractMonster.Intent.valueOf(m.intent.name());
    m.setMove(Byte.MAX_VALUE,AbstractMonster.Intent.STUN);
    m.createIntent();
    AbstractDungeon.actionManager.addToBottom(new SetMoveAction(m,Byte.MAX_VALUE,AbstractMonster.Intent.STUN));
  }
}"
70515,"public void stackPower(int stackAmount){
  this.amount+=stackAmount;
  if (this.amount >= 5) {
    this.flash();
    AbstractDungeon.actionManager.addToBottom(new GainBlockAction(owner,owner,5));
    this.amount=1;
  }
}","public void stackPower(int stackAmount){
  this.amount+=stackAmount;
  if (this.amount >= cap) {
    this.flash();
    AbstractDungeon.actionManager.addToBottom(new GainBlockAction(owner,owner,5));
    this.amount=1;
  }
}"
70516,"@Override public void updateDescription(){
  if (this.amount > 0) {
    this.description=(""String_Node_Str"" + DESCRIPTIONS[0] + this.amount+ ""String_Node_Str"");
  }
}","@Override public void updateDescription(){
  if (this.amount > 0) {
    this.description=(""String_Node_Str"" + DESCRIPTIONS[0] + this.amount+ ""String_Node_Str""+ cap+ ""String_Node_Str"");
  }
}"
70517,"private void createGetHandledValuesMethod(TypeSpec.Builder builder,Set<KnitModelMirror> modelMirrors){
  int c;
  StringBuilder stringBuilder;
  ParameterizedTypeName returnTypeForGeneratedVals=ParameterizedTypeName.get(TYPE_NAME_LIST,TYPE_NAME_STRING);
  MethodSpec.Builder getGeneratedValuesMethodBuilder=MethodSpec.methodBuilder(""String_Node_Str"").addParameter(TYPE_NAME_CLASS,""String_Node_Str"").addAnnotation(Override.class).returns(returnTypeForGeneratedVals).addModifiers(Modifier.PUBLIC);
  for (  KnitModelMirror knitModelMirror : modelMirrors) {
    c=0;
    stringBuilder=new StringBuilder();
    stringBuilder.append(""String_Node_Str"");
    for (    String field : knitModelMirror.vals) {
      stringBuilder.append(""String_Node_Str"");
      stringBuilder.append(field);
      stringBuilder.append(""String_Node_Str"");
      if (c < knitModelMirror.vals.size() - 1) {
        stringBuilder.append(""String_Node_Str"");
      }
      c++;
    }
    stringBuilder.append(""String_Node_Str"");
    getGeneratedValuesMethodBuilder.beginControlFlow(""String_Node_Str"",knitModelMirror.enclosingClass.getQualifiedName(),""String_Node_Str"");
    getGeneratedValuesMethodBuilder.addStatement(""String_Node_Str"",stringBuilder.toString());
    getGeneratedValuesMethodBuilder.endControlFlow();
  }
  getGeneratedValuesMethodBuilder.addStatement(""String_Node_Str"");
  builder.addMethod(getGeneratedValuesMethodBuilder.build());
}","private void createGetHandledValuesMethod(TypeSpec.Builder builder,Set<KnitModelMirror> modelMirrors){
  int c;
  StringBuilder stringBuilder;
  ParameterizedTypeName returnTypeForGeneratedVals=ParameterizedTypeName.get(TYPE_NAME_LIST,TYPE_NAME_STRING);
  MethodSpec.Builder getGeneratedValuesMethodBuilder=MethodSpec.methodBuilder(""String_Node_Str"").addParameter(TYPE_NAME_CLASS,""String_Node_Str"").addAnnotation(Override.class).returns(returnTypeForGeneratedVals).addModifiers(Modifier.PUBLIC);
  for (  KnitModelMirror knitModelMirror : modelMirrors) {
    c=0;
    stringBuilder=new StringBuilder();
    stringBuilder.append(""String_Node_Str"");
    for (    String field : knitModelMirror.vals) {
      stringBuilder.append(""String_Node_Str"");
      stringBuilder.append(field);
      stringBuilder.append(""String_Node_Str"");
      c++;
      if (c < knitModelMirror.vals.size() - 1) {
        stringBuilder.append(""String_Node_Str"");
      }
    }
    stringBuilder.append(""String_Node_Str"");
    getGeneratedValuesMethodBuilder.beginControlFlow(""String_Node_Str"",knitModelMirror.enclosingClass.getQualifiedName(),""String_Node_Str"");
    getGeneratedValuesMethodBuilder.addStatement(""String_Node_Str"",stringBuilder.toString());
    getGeneratedValuesMethodBuilder.endControlFlow();
  }
  getGeneratedValuesMethodBuilder.addStatement(""String_Node_Str"");
  builder.addMethod(getGeneratedValuesMethodBuilder.build());
}"
70518,"private void createGetAllMethod(TypeSpec.Builder builder,Set<KnitModelMirror> modelMirrors){
  WildcardTypeName wildcardTypeName=WildcardTypeName.subtypeOf(ClassName.bestGuess(KnitFileStrings.KNIT_MODEL));
  ParameterizedTypeName classTypeName=ParameterizedTypeName.get(TYPE_NAME_CLASS,wildcardTypeName);
  ParameterizedTypeName returnTypeForGetAll=ParameterizedTypeName.get(TYPE_NAME_LIST,classTypeName);
  int c=0;
  StringBuilder stringBuilder=new StringBuilder();
  stringBuilder.append(""String_Node_Str"");
  for (  KnitModelMirror modelMirror : modelMirrors) {
    stringBuilder.append(modelMirror.enclosingClass.getQualifiedName());
    stringBuilder.append(""String_Node_Str"");
    stringBuilder.append(""String_Node_Str"");
    if (c < modelMirrors.size() - 1) {
      stringBuilder.append(""String_Node_Str"");
    }
    c++;
  }
  stringBuilder.append(""String_Node_Str"");
  builder.addMethod(MethodSpec.methodBuilder(""String_Node_Str"").addAnnotation(Override.class).returns(returnTypeForGetAll).addStatement(""String_Node_Str"" + stringBuilder.toString()).addModifiers(Modifier.PUBLIC).build());
}","private void createGetAllMethod(TypeSpec.Builder builder,Set<KnitModelMirror> modelMirrors){
  WildcardTypeName wildcardTypeName=WildcardTypeName.subtypeOf(ClassName.bestGuess(KnitFileStrings.KNIT_MODEL));
  ParameterizedTypeName classTypeName=ParameterizedTypeName.get(TYPE_NAME_CLASS,wildcardTypeName);
  ParameterizedTypeName returnTypeForGetAll=ParameterizedTypeName.get(TYPE_NAME_LIST,classTypeName);
  int c=0;
  StringBuilder stringBuilder=new StringBuilder();
  stringBuilder.append(""String_Node_Str"");
  for (  KnitModelMirror modelMirror : modelMirrors) {
    stringBuilder.append(modelMirror.enclosingClass.getQualifiedName());
    stringBuilder.append(""String_Node_Str"");
    stringBuilder.append(""String_Node_Str"");
    c++;
    if (c < modelMirrors.size() - 1) {
      stringBuilder.append(""String_Node_Str"");
    }
  }
  stringBuilder.append(""String_Node_Str"");
  builder.addMethod(MethodSpec.methodBuilder(""String_Node_Str"").addAnnotation(Override.class).returns(returnTypeForGetAll).addStatement(""String_Node_Str"" + stringBuilder.toString()).addModifiers(Modifier.PUBLIC).build());
}"
70519,"private void createGetRequiredValuesMethod(TypeSpec.Builder builder,Set<KnitModelMirror> modelMirrors){
  int c;
  StringBuilder stringBuilder;
  ParameterizedTypeName returnTypeForGeneratedVals=ParameterizedTypeName.get(TYPE_NAME_LIST,TYPE_NAME_STRING);
  MethodSpec.Builder getRequiredValuesMethodBuilder=MethodSpec.methodBuilder(""String_Node_Str"").addParameter(TYPE_NAME_CLASS,""String_Node_Str"").addAnnotation(Override.class).returns(returnTypeForGeneratedVals).addModifiers(Modifier.PUBLIC);
  for (  KnitModelMirror knitModelMirror : modelMirrors) {
    c=0;
    stringBuilder=new StringBuilder();
    stringBuilder.append(""String_Node_Str"");
    for (    String field : knitModelMirror.reqs) {
      stringBuilder.append(""String_Node_Str"");
      stringBuilder.append(field);
      stringBuilder.append(""String_Node_Str"");
      if (c < knitModelMirror.vals.size() - 1) {
        stringBuilder.append(""String_Node_Str"");
      }
      c++;
    }
    stringBuilder.append(""String_Node_Str"");
    getRequiredValuesMethodBuilder.beginControlFlow(""String_Node_Str"",knitModelMirror.enclosingClass.getQualifiedName(),""String_Node_Str"");
    getRequiredValuesMethodBuilder.addStatement(""String_Node_Str"",stringBuilder.toString());
    getRequiredValuesMethodBuilder.endControlFlow();
  }
  getRequiredValuesMethodBuilder.addStatement(""String_Node_Str"");
  builder.addMethod(getRequiredValuesMethodBuilder.build());
}","private void createGetRequiredValuesMethod(TypeSpec.Builder builder,Set<KnitModelMirror> modelMirrors){
  int c;
  StringBuilder stringBuilder;
  ParameterizedTypeName returnTypeForGeneratedVals=ParameterizedTypeName.get(TYPE_NAME_LIST,TYPE_NAME_STRING);
  MethodSpec.Builder getRequiredValuesMethodBuilder=MethodSpec.methodBuilder(""String_Node_Str"").addParameter(TYPE_NAME_CLASS,""String_Node_Str"").addAnnotation(Override.class).returns(returnTypeForGeneratedVals).addModifiers(Modifier.PUBLIC);
  for (  KnitModelMirror knitModelMirror : modelMirrors) {
    c=0;
    stringBuilder=new StringBuilder();
    stringBuilder.append(""String_Node_Str"");
    for (    String field : knitModelMirror.reqs) {
      stringBuilder.append(""String_Node_Str"");
      stringBuilder.append(field);
      stringBuilder.append(""String_Node_Str"");
      if (c < knitModelMirror.reqs.size() - 1) {
        stringBuilder.append(""String_Node_Str"");
      }
      c++;
    }
    stringBuilder.append(""String_Node_Str"");
    getRequiredValuesMethodBuilder.beginControlFlow(""String_Node_Str"",knitModelMirror.enclosingClass.getQualifiedName(),""String_Node_Str"");
    getRequiredValuesMethodBuilder.addStatement(""String_Node_Str"",stringBuilder.toString());
    getRequiredValuesMethodBuilder.endControlFlow();
  }
  getRequiredValuesMethodBuilder.addStatement(""String_Node_Str"");
  builder.addMethod(getRequiredValuesMethodBuilder.build());
}"
70520,"@Override public void onResponse(Call<StackAnswer> call,Response<StackAnswer> response){
  Log.e(""String_Node_Str"",""String_Node_Str"" + response.code());
  if (response.code() == 400) {
    if (!response.isSuccessful()) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      JSONObject jsonObject=null;
      Log.e(""String_Node_Str"",""String_Node_Str"" + response.errorBody().toString());
    }
    if (response.isSuccessful()) {
      StackAnswer stackAnswer=response.body();
      Log.e(""String_Node_Str"",""String_Node_Str"" + stackAnswer.getItems().get(0).getLink());
    }
 else     Log.e(""String_Node_Str"",""String_Node_Str"" + response.message());
  }
}","@Override public void onResponse(Call<StackAnswer> call,Response<StackAnswer> response){
  Log.e(""String_Node_Str"",""String_Node_Str"" + response.code());
  if (response.isSuccessful()) {
    StackAnswer stackAnswer=response.body();
    Log.e(""String_Node_Str"",""String_Node_Str"" + stackAnswer.getItems().get(0).getLink());
  }
 else   Log.e(""String_Node_Str"",""String_Node_Str"");
}"
70521,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  Log.e(""String_Node_Str"",""String_Node_Str"");
  APIService service=Client.getService();
  Call<StackAnswer> call=service.getAnswer(""String_Node_Str"",""String_Node_Str"");
  call.enqueue(new Callback<StackAnswer>(){
    @Override public void onResponse(    Call<StackAnswer> call,    Response<StackAnswer> response){
      Log.e(""String_Node_Str"",""String_Node_Str"" + response.code());
      if (response.code() == 400) {
        if (!response.isSuccessful()) {
          Log.e(""String_Node_Str"",""String_Node_Str"");
          JSONObject jsonObject=null;
          Log.e(""String_Node_Str"",""String_Node_Str"" + response.errorBody().toString());
        }
        if (response.isSuccessful()) {
          StackAnswer stackAnswer=response.body();
          Log.e(""String_Node_Str"",""String_Node_Str"" + stackAnswer.getItems().get(0).getLink());
        }
 else         Log.e(""String_Node_Str"",""String_Node_Str"" + response.message());
      }
    }
    @Override public void onFailure(    Call<StackAnswer> call,    Throwable t){
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  return START_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  Log.e(""String_Node_Str"",""String_Node_Str"");
  APIService service=Client.getService();
  Call<StackAnswer> call=service.getAnswer();
  call.enqueue(new Callback<StackAnswer>(){
    @Override public void onResponse(    Call<StackAnswer> call,    Response<StackAnswer> response){
      Log.e(""String_Node_Str"",""String_Node_Str"" + response.code());
      if (response.isSuccessful()) {
        StackAnswer stackAnswer=response.body();
        Log.e(""String_Node_Str"",""String_Node_Str"" + stackAnswer.getItems().get(0).getLink());
      }
 else       Log.e(""String_Node_Str"",""String_Node_Str"");
    }
    @Override public void onFailure(    Call<StackAnswer> call,    Throwable t){
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
  return START_STICKY;
}"
70522,"public void uncaughtException(final Thread thread,final Throwable ex){
  Log.e(""String_Node_Str"",""String_Node_Str"");
  Intent intent=new Intent(context,MyService.class);
  context.startService(intent);
  Log.e(""String_Node_Str"",""String_Node_Str"");
  androidDefaultUEH.uncaughtException(thread,ex);
}","public void uncaughtException(final Thread thread,final Throwable ex){
  Intent intent=new Intent(context,MyService.class);
  context.startService(intent);
  androidDefaultUEH.uncaughtException(thread,ex);
}"
70523,"@GET(""String_Node_Str"") Call<StackAnswer> getAnswer(@Query(""String_Node_Str"") String title,@Query(""String_Node_Str"") String site);","@GET(""String_Node_Str"" + ""String_Node_Str"") Call<StackAnswer> getAnswer();"
70524,"public void runService(){
  try {
    ((ArrayList<BruteForce>)((ArrayList)vHackOSBot.api.getTaskManager().getActiveBrutes()).clone()).forEach(bruteForce -> {
      if (cache.asMap().containsKey(bruteForce.getIp()))       return;
      if (bruteForce.getState() == BruteForceState.SUCCESS) {
        cache.put(bruteForce.getIp(),""String_Node_Str"");
        ExploitedTarget etarget=bruteForce.exploit();
        ExploitedTarget.Banking banking=etarget.getBanking();
        if (banking.isBruteForced()) {
          long av=banking.getAvaliableMoney();
          if (av > 0 && banking.withdraw()) {
            LOG.info(""String_Node_Str"" + av + ""String_Node_Str""+ banking.getTotal()+ ""String_Node_Str""+ etarget.getIp()+ ""String_Node_Str"");
          }
 else {
            LOG.error(""String_Node_Str"" + etarget.getIp() + ""String_Node_Str"");
          }
          if (eval(etarget)) {
            LOG.info(""String_Node_Str"" + etarget.getIp() + ""String_Node_Str"");
            bruteForce.remove();
          }
        }
 else {
          if (banking.startBruteForce()) {
            LOG.info(""String_Node_Str"" + etarget.getIp());
          }
 else {
            LOG.error(""String_Node_Str"" + etarget.getIp());
          }
        }
        etarget.setSystemLog(NetworkingConfigValues.logMessage.replaceAll(""String_Node_Str"",vHackOSBot.api.getStats().getUsername()));
      }
 else       if (bruteForce.getState() == BruteForceState.FAILED) {
switch (NetworkingConfigValues.onFail) {
case ""String_Node_Str"":
          LOG.info(""String_Node_Str"" + bruteForce.getIp() + ""String_Node_Str"");
        ((BruteForceImpl)bruteForce).retry();
case ""String_Node_Str"":
      LOG.info(""String_Node_Str"" + bruteForce.getIp() + ""String_Node_Str"");
    bruteForce.remove();
}
}
}
);
if (vHackOSBot.api.getStats().getExploits() > 0) {
int success=0;
while (success < 6) {
success+=scan();
}
}
}
 catch (Exception e) {
Sentry.capture(e);
e.printStackTrace();
networkingService.shutdownNow();
LOG.warn(""String_Node_Str"");
}
}","public void runService(){
  try {
    ((ArrayList<BruteForce>)((ArrayList)vHackOSBot.api.getTaskManager().getActiveBrutes()).clone()).forEach(bruteForce -> {
      if (cache.asMap().containsKey(bruteForce.getIp()))       return;
      if (bruteForce.getState() == BruteForceState.SUCCESS) {
        cache.put(bruteForce.getIp(),""String_Node_Str"");
        ExploitedTarget etarget=bruteForce.exploit();
        ExploitedTarget.Banking banking=etarget.getBanking();
        if (banking.isBruteForced()) {
          long av=banking.getAvaliableMoney();
          if (av > 0 && banking.withdraw(NetworkingConfigValues.withdrawPorcentage)) {
            LOG.info(""String_Node_Str"" + av + ""String_Node_Str""+ banking.getTotal()+ ""String_Node_Str""+ etarget.getIp()+ ""String_Node_Str"");
          }
 else {
            LOG.error(""String_Node_Str"" + etarget.getIp() + ""String_Node_Str"");
          }
          if (eval(etarget)) {
            LOG.info(""String_Node_Str"" + etarget.getIp() + ""String_Node_Str"");
            bruteForce.remove();
          }
        }
 else {
          if (banking.startBruteForce()) {
            LOG.info(""String_Node_Str"" + etarget.getIp());
          }
 else {
            LOG.error(""String_Node_Str"" + etarget.getIp());
          }
        }
        etarget.setSystemLog(NetworkingConfigValues.logMessage.replaceAll(""String_Node_Str"",vHackOSBot.api.getStats().getUsername()));
      }
 else       if (bruteForce.getState() == BruteForceState.FAILED) {
switch (NetworkingConfigValues.onFail) {
case ""String_Node_Str"":
          LOG.info(""String_Node_Str"" + bruteForce.getIp() + ""String_Node_Str"");
        bruteForce.retry();
case ""String_Node_Str"":
      LOG.info(""String_Node_Str"" + bruteForce.getIp() + ""String_Node_Str"");
    bruteForce.remove();
}
}
}
);
if (vHackOSBot.api.getStats().getExploits() > 0) {
int success=0;
while (success < 6) {
success+=scan();
}
}
}
 catch (Exception e) {
Sentry.capture(e);
e.printStackTrace();
networkingService.shutdownNow();
LOG.warn(""String_Node_Str"");
}
}"
70525,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_profile_setup);
switch (getIntent().getIntExtra(EXTRA_SETUP_METHOD,-1)) {
case PROFILE_SETUP_WITH_GOOGLE:
    bind.method.setImageResource(R.drawable.logo_google);
  break;
case PROFILE_SETUP_WITH_FACEBOOK:
bind.method.setImageResource(R.drawable.logo_facebook);
break;
case PROFILE_SETUP_WITH_TWITTER:
bind.method.setImageResource(R.drawable.logo_twitter);
break;
case PROFILE_SETUP_WITH_PHONE:
bind.method.setImageResource(R.drawable.logo_phone);
break;
default :
PROFILE_SETUP_WITH_EMAIL_AND_PASSWORD: bind.method.setImageResource(R.drawable.logo_login);
}
auth=FirebaseAuth.getInstance();
database=FirebaseDatabase.getInstance();
FirebaseUser user=auth.getCurrentUser();
if (user != null) {
if (user.getEmail() != null) bind.info.setText(user.getEmail());
 else if (user.getPhoneNumber() != null) bind.info.setText(user.getPhoneNumber());
if (user.getDisplayName() != null) bind.nickname.setText(user.getDisplayName());
}
 else finish();
bind.done.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
String nickname=bind.nickname.getText().toString();
FirebaseUser user=auth.getCurrentUser();
if (nickname.isEmpty()) {
showToast(R.string.empty_field);
return;
}
UserProfileChangeRequest profileChangeRequest=new UserProfileChangeRequest.Builder().setDisplayName(nickname).build();
user.updateProfile(profileChangeRequest);
database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").setValue(nickname);
String email=auth.getCurrentUser().getEmail();
if (email == null) email=auth.getCurrentUser().getPhoneNumber();
database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").setValue(email);
startActivity(new Intent(ProfileSetupActivity.this,MainActivity.class));
finish();
}
}
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_profile_setup);
switch (getIntent().getIntExtra(EXTRA_SETUP_METHOD,-1)) {
case PROFILE_SETUP_WITH_GOOGLE:
    bind.methodImg.setImageResource(R.drawable.logo_google);
  bind.methodTv.setText(R.string.google);
break;
case PROFILE_SETUP_WITH_FACEBOOK:
bind.methodImg.setImageResource(R.drawable.logo_facebook);
bind.methodTv.setText(R.string.facebook);
break;
case PROFILE_SETUP_WITH_TWITTER:
bind.methodImg.setImageResource(R.drawable.logo_twitter);
bind.methodTv.setText(R.string.twitter);
break;
case PROFILE_SETUP_WITH_PHONE:
bind.methodImg.setImageResource(R.drawable.logo_phone);
bind.methodTv.setText(R.string.phone_sms);
break;
default :
PROFILE_SETUP_WITH_EMAIL_AND_PASSWORD: bind.methodImg.setImageResource(R.drawable.logo_login);
bind.methodTv.setText(R.string.email_and_password);
}
auth=FirebaseAuth.getInstance();
database=FirebaseDatabase.getInstance();
FirebaseUser user=auth.getCurrentUser();
if (user != null) {
if (user.getEmail() != null) bind.info.setText(user.getEmail());
 else if (user.getPhoneNumber() != null) bind.info.setText(user.getPhoneNumber());
if (user.getDisplayName() != null) bind.nickname.setText(user.getDisplayName());
}
 else finish();
bind.done.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
String nickname=bind.nickname.getText().toString();
FirebaseUser user=auth.getCurrentUser();
if (nickname.isEmpty()) {
showToast(R.string.empty_field);
return;
}
UserProfileChangeRequest profileChangeRequest=new UserProfileChangeRequest.Builder().setDisplayName(nickname).build();
user.updateProfile(profileChangeRequest);
database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").setValue(nickname);
String email=auth.getCurrentUser().getEmail();
if (email == null) email=auth.getCurrentUser().getPhoneNumber();
database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").setValue(email);
startActivity(new Intent(ProfileSetupActivity.this,MainActivity.class));
finish();
}
}
);
}"
70526,"@Override public void onClick(View v){
  lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_GOOGLE;
  lastOpen=bind.google;
  dialog.show();
  startActivityForResult(Auth.GoogleSignInApi.getSignInIntent(client),GOOGLE_REQUEST_CODE);
}","@Override public void onClick(View v){
  lastOpenImg=bind.googleImg;
  lastOpenTv=bind.googleTv;
  lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_GOOGLE;
  dialog.show();
  startActivityForResult(Auth.GoogleSignInApi.getSignInIntent(client),GOOGLE_REQUEST_CODE);
}"
70527,"@Override public void onDataChange(DataSnapshot dataSnapshot){
  dialog.cancel();
  if (dataSnapshot.getValue() == null) {
    if (lastOpen == null) {
      startActivity(new Intent(SigninActivity.this,ProfileSetupActivity.class));
      return;
    }
    Intent i=new Intent(SigninActivity.this,ProfileSetupActivity.class);
    i.putExtra(ProfileSetupActivity.EXTRA_SETUP_METHOD,lastOpenId);
    startActivity(i,ActivityOptionsCompat.makeSceneTransitionAnimation(SigninActivity.this,lastOpen,""String_Node_Str"").toBundle());
  }
 else {
    startActivity(new Intent(SigninActivity.this,MainActivity.class));
  }
  finish();
}","@Override public void onDataChange(DataSnapshot dataSnapshot){
  dialog.cancel();
  if (dataSnapshot.getValue() == null) {
    if (lastOpenImg == null || lastOpenTv == null) {
      startActivity(new Intent(SigninActivity.this,ProfileSetupActivity.class));
      return;
    }
    Intent i=new Intent(SigninActivity.this,ProfileSetupActivity.class);
    i.putExtra(ProfileSetupActivity.EXTRA_SETUP_METHOD,lastOpenId);
    startActivity(i,ActivityOptionsCompat.makeSceneTransitionAnimation(SigninActivity.this,new Pair<View,String>(lastOpenImg,""String_Node_Str""),new Pair<View,String>(lastOpenTv,""String_Node_Str"")).toBundle());
  }
 else {
    startActivity(new Intent(SigninActivity.this,MainActivity.class));
  }
  finish();
}"
70528,"private void googleSetup(){
  GoogleSignInOptions gso=new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN).requestIdToken(getString(R.string.default_web_client_id)).requestEmail().build();
  client=new GoogleApiClient.Builder(this).enableAutoManage(this,new GoogleApiClient.OnConnectionFailedListener(){
    @Override public void onConnectionFailed(    @NonNull ConnectionResult connectionResult){
      dialog.cancel();
      showToast(R.string.error);
    }
  }
).addApi(Auth.GOOGLE_SIGN_IN_API,gso).build();
  bind.googleBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_GOOGLE;
      lastOpen=bind.google;
      dialog.show();
      startActivityForResult(Auth.GoogleSignInApi.getSignInIntent(client),GOOGLE_REQUEST_CODE);
    }
  }
);
}","private void googleSetup(){
  GoogleSignInOptions gso=new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN).requestIdToken(getString(R.string.default_web_client_id)).requestEmail().build();
  client=new GoogleApiClient.Builder(this).enableAutoManage(this,new GoogleApiClient.OnConnectionFailedListener(){
    @Override public void onConnectionFailed(    @NonNull ConnectionResult connectionResult){
      dialog.cancel();
      showToast(R.string.error);
    }
  }
).addApi(Auth.GOOGLE_SIGN_IN_API,gso).build();
  bind.google.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenImg=bind.googleImg;
      lastOpenTv=bind.googleTv;
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_GOOGLE;
      dialog.show();
      startActivityForResult(Auth.GoogleSignInApi.getSignInIntent(client),GOOGLE_REQUEST_CODE);
    }
  }
);
}"
70529,"private void twitterSetup(){
  TwitterConfig config=new TwitterConfig.Builder(this).twitterAuthConfig(new TwitterAuthConfig(getResources().getString(R.string.com_twitter_sdk_android_CONSUMER_KEY),getResources().getString(R.string.com_twitter_sdk_android_CONSUMER_SECRET))).build();
  Twitter.initialize(config);
  twitterClient=new TwitterAuthClient();
  bind.twitterBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_TWITTER;
      lastOpen=bind.twitter;
      twitterClient.authorize(SigninActivity.this,new Callback<TwitterSession>(){
        @Override public void success(        Result<TwitterSession> result){
          TwitterAuthToken token=result.data.getAuthToken();
          auth.signInWithCredential(TwitterAuthProvider.getCredential(token.token,token.secret)).addOnCompleteListener(signInCallback);
        }
        @Override public void failure(        TwitterException exception){
          showToast(R.string.error);
          dialog.cancel();
        }
      }
);
    }
  }
);
}","private void twitterSetup(){
  TwitterConfig config=new TwitterConfig.Builder(this).twitterAuthConfig(new TwitterAuthConfig(getResources().getString(R.string.com_twitter_sdk_android_CONSUMER_KEY),getResources().getString(R.string.com_twitter_sdk_android_CONSUMER_SECRET))).build();
  Twitter.initialize(config);
  twitterClient=new TwitterAuthClient();
  bind.twitter.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_TWITTER;
      lastOpenImg=bind.twitterImg;
      lastOpenTv=bind.twitterTv;
      twitterClient.authorize(SigninActivity.this,new Callback<TwitterSession>(){
        @Override public void success(        Result<TwitterSession> result){
          TwitterAuthToken token=result.data.getAuthToken();
          auth.signInWithCredential(TwitterAuthProvider.getCredential(token.token,token.secret)).addOnCompleteListener(signInCallback);
        }
        @Override public void failure(        TwitterException exception){
          showToast(R.string.error);
          dialog.cancel();
        }
      }
);
    }
  }
);
}"
70530,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_signin);
  auth=FirebaseAuth.getInstance();
  database=FirebaseDatabase.getInstance();
  isAnimated=false;
  dialog=new ProgressDialog(this);
  dialog.setMessage(getResources().getString(R.string.loading));
  dialog.setCancelable(false);
  signInCallback=new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      final FirebaseUser user=auth.getCurrentUser();
      if (task.isSuccessful() && user != null) {
        database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
          @Override public void onDataChange(          DataSnapshot dataSnapshot){
            dialog.cancel();
            if (dataSnapshot.getValue() == null) {
              if (lastOpen == null) {
                startActivity(new Intent(SigninActivity.this,ProfileSetupActivity.class));
                return;
              }
              Intent i=new Intent(SigninActivity.this,ProfileSetupActivity.class);
              i.putExtra(ProfileSetupActivity.EXTRA_SETUP_METHOD,lastOpenId);
              startActivity(i,ActivityOptionsCompat.makeSceneTransitionAnimation(SigninActivity.this,lastOpen,""String_Node_Str"").toBundle());
            }
 else {
              startActivity(new Intent(SigninActivity.this,MainActivity.class));
            }
            finish();
          }
          @Override public void onCancelled(          DatabaseError databaseError){
            dialog.cancel();
          }
        }
);
      }
 else {
        dialog.cancel();
        showToast(R.string.error);
        bind.password.setText(""String_Node_Str"");
      }
    }
  }
;
  bind.center.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isAnimated)       return;
      isAnimated=true;
      showAnimation();
    }
  }
);
  googleSetup();
  emailPasswordSetup();
  facebookSetup();
  phoneSetup();
  loginSetup();
  twitterSetup();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_signin);
  auth=FirebaseAuth.getInstance();
  database=FirebaseDatabase.getInstance();
  isAnimated=false;
  dialog=new ProgressDialog(this);
  dialog.setMessage(getResources().getString(R.string.loading));
  dialog.setCancelable(false);
  signInCallback=new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      final FirebaseUser user=auth.getCurrentUser();
      if (task.isSuccessful() && user != null) {
        database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
          @Override public void onDataChange(          DataSnapshot dataSnapshot){
            dialog.cancel();
            if (dataSnapshot.getValue() == null) {
              if (lastOpenImg == null || lastOpenTv == null) {
                startActivity(new Intent(SigninActivity.this,ProfileSetupActivity.class));
                return;
              }
              Intent i=new Intent(SigninActivity.this,ProfileSetupActivity.class);
              i.putExtra(ProfileSetupActivity.EXTRA_SETUP_METHOD,lastOpenId);
              startActivity(i,ActivityOptionsCompat.makeSceneTransitionAnimation(SigninActivity.this,new Pair<View,String>(lastOpenImg,""String_Node_Str""),new Pair<View,String>(lastOpenTv,""String_Node_Str"")).toBundle());
            }
 else {
              startActivity(new Intent(SigninActivity.this,MainActivity.class));
            }
            finish();
          }
          @Override public void onCancelled(          DatabaseError databaseError){
            dialog.cancel();
          }
        }
);
      }
 else {
        dialog.cancel();
        showToast(R.string.error);
        bind.password.setText(""String_Node_Str"");
      }
    }
  }
;
  bind.center.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (isAnimated)       return;
      isAnimated=true;
      showAnimation();
    }
  }
);
  googleSetup();
  emailPasswordSetup();
  facebookSetup();
  phoneSetup();
  loginSetup();
  twitterSetup();
}"
70531,"@Override public void onComplete(@NonNull Task<AuthResult> task){
  final FirebaseUser user=auth.getCurrentUser();
  if (task.isSuccessful() && user != null) {
    database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
      @Override public void onDataChange(      DataSnapshot dataSnapshot){
        dialog.cancel();
        if (dataSnapshot.getValue() == null) {
          if (lastOpen == null) {
            startActivity(new Intent(SigninActivity.this,ProfileSetupActivity.class));
            return;
          }
          Intent i=new Intent(SigninActivity.this,ProfileSetupActivity.class);
          i.putExtra(ProfileSetupActivity.EXTRA_SETUP_METHOD,lastOpenId);
          startActivity(i,ActivityOptionsCompat.makeSceneTransitionAnimation(SigninActivity.this,lastOpen,""String_Node_Str"").toBundle());
        }
 else {
          startActivity(new Intent(SigninActivity.this,MainActivity.class));
        }
        finish();
      }
      @Override public void onCancelled(      DatabaseError databaseError){
        dialog.cancel();
      }
    }
);
  }
 else {
    dialog.cancel();
    showToast(R.string.error);
    bind.password.setText(""String_Node_Str"");
  }
}","@Override public void onComplete(@NonNull Task<AuthResult> task){
  final FirebaseUser user=auth.getCurrentUser();
  if (task.isSuccessful() && user != null) {
    database.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
      @Override public void onDataChange(      DataSnapshot dataSnapshot){
        dialog.cancel();
        if (dataSnapshot.getValue() == null) {
          if (lastOpenImg == null || lastOpenTv == null) {
            startActivity(new Intent(SigninActivity.this,ProfileSetupActivity.class));
            return;
          }
          Intent i=new Intent(SigninActivity.this,ProfileSetupActivity.class);
          i.putExtra(ProfileSetupActivity.EXTRA_SETUP_METHOD,lastOpenId);
          startActivity(i,ActivityOptionsCompat.makeSceneTransitionAnimation(SigninActivity.this,new Pair<View,String>(lastOpenImg,""String_Node_Str""),new Pair<View,String>(lastOpenTv,""String_Node_Str"")).toBundle());
        }
 else {
          startActivity(new Intent(SigninActivity.this,MainActivity.class));
        }
        finish();
      }
      @Override public void onCancelled(      DatabaseError databaseError){
        dialog.cancel();
      }
    }
);
  }
 else {
    dialog.cancel();
    showToast(R.string.error);
    bind.password.setText(""String_Node_Str"");
  }
}"
70532,"private void loginSetup(){
  bind.login.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_EMAIL_AND_PASSWORD;
      lastOpen=bind.login;
      AlertDialog.Builder builder=new AlertDialog.Builder(SigninActivity.this);
      View view=getLayoutInflater().inflate(R.layout.dialog_email_password_holder,null);
      final EditText emailHolder=(EditText)view.findViewById(R.id.email_holder);
      final EditText passwordHolder=(EditText)view.findViewById(R.id.password_holder);
      final TextView done=(TextView)view.findViewById(R.id.done);
      builder.setView(view);
      final AlertDialog d=builder.create();
      d.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
      d.show();
      done.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          dialog.show();
          d.cancel();
          emailPasswordSignin(emailHolder.getText().toString(),passwordHolder.getText().toString());
        }
      }
);
    }
  }
);
}","private void loginSetup(){
  bind.loginImg.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_EMAIL_AND_PASSWORD;
      lastOpenImg=bind.loginImg;
      AlertDialog.Builder builder=new AlertDialog.Builder(SigninActivity.this);
      View view=getLayoutInflater().inflate(R.layout.dialog_email_password_holder,null);
      final EditText emailHolder=(EditText)view.findViewById(R.id.email_holder);
      final EditText passwordHolder=(EditText)view.findViewById(R.id.password_holder);
      final TextView done=(TextView)view.findViewById(R.id.done);
      builder.setView(view);
      final AlertDialog d=builder.create();
      d.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
      d.show();
      done.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          dialog.show();
          d.cancel();
          emailPasswordSignin(emailHolder.getText().toString(),passwordHolder.getText().toString());
        }
      }
);
    }
  }
);
}"
70533,"private void showLoginText(){
  bind.loginTv.setX(bind.area.getMeasuredWidth() / 2 - bind.loginTv.getMeasuredWidth() / 2);
  bind.loginTv.setY(3 * bind.area.getMeasuredHeight() / 4 + bind.login.getMeasuredHeight() / 2 + bind.loginTv.getMeasuredHeight() / 2);
  bind.loginTv.setVisibility(View.VISIBLE);
  ObjectAnimator animator=ObjectAnimator.ofFloat(bind.loginTv,""String_Node_Str"",0f,1f).setDuration(Const.LOGIN_SHOW_DURATION);
  ObjectAnimator animatorScaleX=ObjectAnimator.ofFloat(bind.loginTv,""String_Node_Str"",0.7f,1f).setDuration(Const.LOGIN_SHOW_DURATION);
  ObjectAnimator animatorScaleY=ObjectAnimator.ofFloat(bind.loginTv,""String_Node_Str"",0.7f,1f).setDuration(Const.LOGIN_SHOW_DURATION);
  animator.setInterpolator(new AccelerateInterpolator());
  animatorScaleX.setInterpolator(new DecelerateInterpolator());
  animatorScaleY.setInterpolator(new DecelerateInterpolator());
  animator.start();
  animatorScaleX.start();
  animatorScaleY.start();
}","private void showLoginText(){
  bind.loginTv.setX(bind.area.getMeasuredWidth() / 2 - bind.loginTv.getMeasuredWidth() / 2);
  bind.loginTv.setY(3 * bind.area.getMeasuredHeight() / 4 + bind.loginImg.getMeasuredHeight() / 2 + bind.loginTv.getMeasuredHeight() / 2);
  bind.loginTv.setVisibility(View.VISIBLE);
  ObjectAnimator animator=ObjectAnimator.ofFloat(bind.loginTv,""String_Node_Str"",0f,1f).setDuration(Const.LOGIN_SHOW_DURATION);
  ObjectAnimator animatorScaleX=ObjectAnimator.ofFloat(bind.loginTv,""String_Node_Str"",0.7f,1f).setDuration(Const.LOGIN_SHOW_DURATION);
  ObjectAnimator animatorScaleY=ObjectAnimator.ofFloat(bind.loginTv,""String_Node_Str"",0.7f,1f).setDuration(Const.LOGIN_SHOW_DURATION);
  animator.setInterpolator(new AccelerateInterpolator());
  animatorScaleX.setInterpolator(new DecelerateInterpolator());
  animatorScaleY.setInterpolator(new DecelerateInterpolator());
  animator.start();
  animatorScaleX.start();
  animatorScaleY.start();
}"
70534,"private void phoneSetup(){
  bind.phoneBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_PHONE;
      lastOpen=bind.phone;
      AlertDialog.Builder builder=new AlertDialog.Builder(SigninActivity.this);
      View view=getLayoutInflater().inflate(R.layout.dialog_phone_holder,null);
      final EditText phoneHolder=(EditText)view.findViewById(R.id.phone_holder);
      final TextView done=(TextView)view.findViewById(R.id.done);
      builder.setView(view);
      final AlertDialog d=builder.create();
      d.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
      d.show();
      done.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          d.cancel();
          phoneSignin(phoneHolder.getText().toString());
        }
      }
);
    }
  }
);
}","private void phoneSetup(){
  bind.phone.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_PHONE;
      lastOpenImg=bind.phoneImg;
      lastOpenTv=bind.phoneTv;
      AlertDialog.Builder builder=new AlertDialog.Builder(SigninActivity.this);
      View view=getLayoutInflater().inflate(R.layout.dialog_phone_holder,null);
      final EditText phoneHolder=(EditText)view.findViewById(R.id.phone_holder);
      final TextView done=(TextView)view.findViewById(R.id.done);
      builder.setView(view);
      final AlertDialog d=builder.create();
      d.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
      d.show();
      done.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          d.cancel();
          phoneSignin(phoneHolder.getText().toString());
        }
      }
);
    }
  }
);
}"
70535,"private void facebookSetup(){
  callbackManager=CallbackManager.Factory.create();
  loginManager=LoginManager.getInstance();
  loginManager.registerCallback(callbackManager,new FacebookCallback<LoginResult>(){
    @Override public void onSuccess(    LoginResult loginResult){
      auth.signInWithCredential(FacebookAuthProvider.getCredential(loginResult.getAccessToken().getToken())).addOnCompleteListener(signInCallback);
    }
    @Override public void onCancel(){
      dialog.cancel();
    }
    @Override public void onError(    FacebookException error){
      showToast(R.string.error);
      dialog.cancel();
    }
  }
);
  bind.facebookBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_FACEBOOK;
      lastOpen=bind.facebook;
      loginManager.logInWithReadPermissions(SigninActivity.this,Arrays.asList(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
}","private void facebookSetup(){
  callbackManager=CallbackManager.Factory.create();
  loginManager=LoginManager.getInstance();
  loginManager.registerCallback(callbackManager,new FacebookCallback<LoginResult>(){
    @Override public void onSuccess(    LoginResult loginResult){
      auth.signInWithCredential(FacebookAuthProvider.getCredential(loginResult.getAccessToken().getToken())).addOnCompleteListener(signInCallback);
    }
    @Override public void onCancel(){
      dialog.cancel();
    }
    @Override public void onError(    FacebookException error){
      showToast(R.string.error);
      dialog.cancel();
    }
  }
);
  bind.facebook.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      lastOpenId=ProfileSetupActivity.PROFILE_SETUP_WITH_FACEBOOK;
      lastOpenImg=bind.facebookImg;
      lastOpenTv=bind.facebookTv;
      loginManager.logInWithReadPermissions(SigninActivity.this,Arrays.asList(""String_Node_Str"",""String_Node_Str""));
    }
  }
);
}"
70536,"public Message(String owner_id,String owner_nickname,String content){
  this.owner_nickname=owner_nickname;
  this.content=content;
  this.owner_id=owner_id;
  date=new SimpleDateFormat(""String_Node_Str"").format(new Date()).toString();
}","public Message(String owner_id,String owner_nickname,String content,String owner_photo_url){
  this.owner_nickname=owner_nickname;
  this.content=content;
  this.owner_id=owner_id;
  this.owner_photo_url=owner_photo_url;
  date=new SimpleDateFormat(""String_Node_Str"").format(new Date()).toString();
}"
70537,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_chat);
  chatId=getIntent().getStringExtra(EXTRA_CHAT_ID);
  if (chatId == null)   finish();
  db=FirebaseDatabase.getInstance();
  auth=FirebaseAuth.getInstance();
  bind.send.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      createMessage(bind.content.getText().toString());
      bind.content.setText(""String_Node_Str"");
    }
  }
);
  adapter=new MessageAdapter(bind.messageList,auth.getCurrentUser().getUid());
  LinearLayoutManager linearLayoutManager=new LinearLayoutManager(this);
  linearLayoutManager.setReverseLayout(true);
  bind.messageList.setLayoutManager(linearLayoutManager);
  bind.messageList.setAdapter(adapter);
  db.getReference().child(""String_Node_Str"").child(chatId).child(""String_Node_Str"").addChildEventListener(new ChildEventListener(){
    @Override public void onChildAdded(    DataSnapshot dataSnapshot,    String s){
      db.getReference().child(""String_Node_Str"").child((String)dataSnapshot.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          adapter.addMessage(dataSnapshot.getValue(Message.class));
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
    @Override public void onChildChanged(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onChildRemoved(    DataSnapshot dataSnapshot){
    }
    @Override public void onChildMoved(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_chat);
  chatId=getIntent().getStringExtra(EXTRA_CHAT_ID);
  if (chatId == null)   finish();
  db=FirebaseDatabase.getInstance();
  auth=FirebaseAuth.getInstance();
  bind.send.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      createMessage(bind.content.getText().toString());
      bind.content.setText(""String_Node_Str"");
    }
  }
);
  adapter=new MessageAdapter(this,bind.messageList,auth.getCurrentUser().getUid());
  LinearLayoutManager linearLayoutManager=new LinearLayoutManager(this);
  linearLayoutManager.setReverseLayout(true);
  bind.messageList.setLayoutManager(linearLayoutManager);
  bind.messageList.setAdapter(adapter);
  db.getReference().child(""String_Node_Str"").child(chatId).child(""String_Node_Str"").addChildEventListener(new ChildEventListener(){
    @Override public void onChildAdded(    DataSnapshot dataSnapshot,    String s){
      db.getReference().child(""String_Node_Str"").child((String)dataSnapshot.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          adapter.addMessage(dataSnapshot.getValue(Message.class));
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
    @Override public void onChildChanged(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onChildRemoved(    DataSnapshot dataSnapshot){
    }
    @Override public void onChildMoved(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
}"
70538,"public void createMessage(String content){
  String key=db.getReference().child(""String_Node_Str"").push().getKey();
  db.getReference().child(""String_Node_Str"").child(chatId).child(""String_Node_Str"").push().setValue(key);
  db.getReference().child(""String_Node_Str"").child(key).setValue(new Message(auth.getCurrentUser().getUid(),auth.getCurrentUser().getDisplayName(),content));
}","public void createMessage(String content){
  String key=db.getReference().child(""String_Node_Str"").push().getKey();
  db.getReference().child(""String_Node_Str"").child(chatId).child(""String_Node_Str"").push().setValue(key);
  db.getReference().child(""String_Node_Str"").child(key).setValue(new Message(auth.getCurrentUser().getUid(),auth.getCurrentUser().getDisplayName(),content,auth.getCurrentUser().getPhotoUrl().toString()));
}"
70539,"public MessageAdapter(RecyclerView view,String auth){
  this.view=view;
  this.auth=auth;
  list=new ArrayList<>();
}","public MessageAdapter(Context context,RecyclerView view,String auth){
  this.view=view;
  this.auth=auth;
  list=new ArrayList<>();
  this.context=context;
}"
70540,"public void bind(Chat chat){
  chatId=chat.getChat_id();
  bind.chatName.setText(chat.getChat_name());
  bind.lastMessage.setText(chat.getLast_message());
  bind.time.setText(chat.getTime());
}","public void bind(Chat chat){
  chatId=chat.getChat_id();
  bind.chatName.setText(chat.getChat_name());
  bind.lastMessage.setText(chat.getLast_message());
  bind.time.setText(chat.getTime());
  if (chat.getPhoto_url() != null) {
    Picasso.with(context).load(chat.getPhoto_url()).resize(ImageUtils.SIZE_XL,ImageUtils.SIZE_XL).into(bind.photo);
  }
}"
70541,"@Override public void onChildAdded(DataSnapshot dataSnapshot,String s){
  final Chat chat=new Chat((String)dataSnapshot.getValue());
  db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").limitToLast(1).addValueEventListener(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      for (      DataSnapshot snap : dataSnapshot.getChildren()) {
        db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
          @Override public void onDataChange(          DataSnapshot dataSnapshot){
            chat.setLast_message((String)dataSnapshot.child(""String_Node_Str"").getValue());
            chat.setTime((String)dataSnapshot.child(""String_Node_Str"").getValue());
            db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
              @Override public void onDataChange(              DataSnapshot dataSnapshot){
                for (                DataSnapshot snap : dataSnapshot.getChildren())                 if (!auth.getCurrentUser().getUid().equals((String)snap.getValue())) {
                  db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
                    @Override public void onDataChange(                    DataSnapshot dataSnapshot){
                      chat.setChat_name((String)dataSnapshot.getValue());
                      adapter.update(chat);
                    }
                    @Override public void onCancelled(                    DatabaseError databaseError){
                    }
                  }
);
                  break;
                }
              }
              @Override public void onCancelled(              DatabaseError databaseError){
              }
            }
);
          }
          @Override public void onCancelled(          DatabaseError databaseError){
          }
        }
);
        break;
      }
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
}","@Override public void onChildAdded(DataSnapshot dataSnapshot,String s){
  final Chat chat=new Chat((String)dataSnapshot.getValue());
  db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      chat.setPhoto_url((String)dataSnapshot.getValue());
      db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").limitToLast(1).addValueEventListener(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          for (          DataSnapshot snap : dataSnapshot.getChildren()) {
            db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
              @Override public void onDataChange(              DataSnapshot dataSnapshot){
                chat.setLast_message((String)dataSnapshot.child(""String_Node_Str"").getValue());
                chat.setTime((String)dataSnapshot.child(""String_Node_Str"").getValue());
                db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
                  @Override public void onDataChange(                  DataSnapshot dataSnapshot){
                    for (                    DataSnapshot snap : dataSnapshot.getChildren())                     if (!auth.getCurrentUser().getUid().equals((String)snap.getValue())) {
                      db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
                        @Override public void onDataChange(                        DataSnapshot dataSnapshot){
                          chat.setChat_name((String)dataSnapshot.getValue());
                          adapter.update(chat);
                        }
                        @Override public void onCancelled(                        DatabaseError databaseError){
                        }
                      }
);
                      break;
                    }
                  }
                  @Override public void onCancelled(                  DatabaseError databaseError){
                  }
                }
);
              }
              @Override public void onCancelled(              DatabaseError databaseError){
              }
            }
);
            break;
          }
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
}"
70542,"@Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  bind=FragmentChatBinding.inflate(inflater);
  bind.chatList.setLayoutManager(new LinearLayoutManager(getContext()));
  adapter=new ChatAdapter(getContext());
  bind.chatList.setAdapter(adapter);
  auth=FirebaseAuth.getInstance();
  db=FirebaseDatabase.getInstance();
  db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").addChildEventListener(new ChildEventListener(){
    @Override public void onChildAdded(    DataSnapshot dataSnapshot,    String s){
      final Chat chat=new Chat((String)dataSnapshot.getValue());
      db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").limitToLast(1).addValueEventListener(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          for (          DataSnapshot snap : dataSnapshot.getChildren()) {
            db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
              @Override public void onDataChange(              DataSnapshot dataSnapshot){
                chat.setLast_message((String)dataSnapshot.child(""String_Node_Str"").getValue());
                chat.setTime((String)dataSnapshot.child(""String_Node_Str"").getValue());
                db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
                  @Override public void onDataChange(                  DataSnapshot dataSnapshot){
                    for (                    DataSnapshot snap : dataSnapshot.getChildren())                     if (!auth.getCurrentUser().getUid().equals((String)snap.getValue())) {
                      db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
                        @Override public void onDataChange(                        DataSnapshot dataSnapshot){
                          chat.setChat_name((String)dataSnapshot.getValue());
                          adapter.update(chat);
                        }
                        @Override public void onCancelled(                        DatabaseError databaseError){
                        }
                      }
);
                      break;
                    }
                  }
                  @Override public void onCancelled(                  DatabaseError databaseError){
                  }
                }
);
              }
              @Override public void onCancelled(              DatabaseError databaseError){
              }
            }
);
            break;
          }
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
    @Override public void onChildChanged(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onChildRemoved(    DataSnapshot dataSnapshot){
    }
    @Override public void onChildMoved(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
  return bind.getRoot();
}","@Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  bind=FragmentChatBinding.inflate(inflater);
  bind.chatList.setLayoutManager(new LinearLayoutManager(getContext()));
  adapter=new ChatAdapter(getContext());
  bind.chatList.setAdapter(adapter);
  auth=FirebaseAuth.getInstance();
  db=FirebaseDatabase.getInstance();
  db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").addChildEventListener(new ChildEventListener(){
    @Override public void onChildAdded(    DataSnapshot dataSnapshot,    String s){
      final Chat chat=new Chat((String)dataSnapshot.getValue());
      db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          chat.setPhoto_url((String)dataSnapshot.getValue());
          db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").limitToLast(1).addValueEventListener(new ValueEventListener(){
            @Override public void onDataChange(            DataSnapshot dataSnapshot){
              for (              DataSnapshot snap : dataSnapshot.getChildren()) {
                db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
                  @Override public void onDataChange(                  DataSnapshot dataSnapshot){
                    chat.setLast_message((String)dataSnapshot.child(""String_Node_Str"").getValue());
                    chat.setTime((String)dataSnapshot.child(""String_Node_Str"").getValue());
                    db.getReference().child(""String_Node_Str"").child(chat.getChat_id()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
                      @Override public void onDataChange(                      DataSnapshot dataSnapshot){
                        for (                        DataSnapshot snap : dataSnapshot.getChildren())                         if (!auth.getCurrentUser().getUid().equals((String)snap.getValue())) {
                          db.getReference().child(""String_Node_Str"").child((String)snap.getValue()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
                            @Override public void onDataChange(                            DataSnapshot dataSnapshot){
                              chat.setChat_name((String)dataSnapshot.getValue());
                              adapter.update(chat);
                            }
                            @Override public void onCancelled(                            DatabaseError databaseError){
                            }
                          }
);
                          break;
                        }
                      }
                      @Override public void onCancelled(                      DatabaseError databaseError){
                      }
                    }
);
                  }
                  @Override public void onCancelled(                  DatabaseError databaseError){
                  }
                }
);
                break;
              }
            }
            @Override public void onCancelled(            DatabaseError databaseError){
            }
          }
);
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
    @Override public void onChildChanged(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onChildRemoved(    DataSnapshot dataSnapshot){
    }
    @Override public void onChildMoved(    DataSnapshot dataSnapshot,    String s){
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
  return bind.getRoot();
}"
70543,"public void bindData(BlogPost post){
  this.post=post;
  bind.nickname.setText(post.getOwner_name());
  bind.content.setText(UtilsManager.cut(post.getContent(),500));
  bind.date.setText(post.getDate());
  bind.like.setText(context.getResources().getString(R.string.like_cnt,post.getLike()));
  bind.comment.setText(context.getResources().getString(R.string.comment_cnt,post.getComment()));
  bind.view.setText(context.getResources().getString(R.string.view_cnt,post.getView()));
  if (post.getOwner_photo_url() != null)   Picasso.with(context).load(post.getOwner_photo_url()).into(bind.photo);
}","public void bindData(BlogPost post){
  this.post=post;
  bind.nickname.setText(post.getOwner_name());
  bind.content.setText(UtilsManager.cut(post.getContent(),500));
  bind.date.setText(post.getDate());
  bind.like.setText(context.getResources().getString(R.string.like_cnt,post.getLike()));
  bind.comment.setText(context.getResources().getString(R.string.comment_cnt,post.getComment()));
  bind.view.setText(context.getResources().getString(R.string.view_cnt,post.getView()));
  if (post.getOwner_photo_url() != null)   Picasso.with(context).load(post.getOwner_photo_url()).resize(ImageUtils.SIZE_L,ImageUtils.SIZE_L).into(bind.photo);
}"
70544,"@Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  bind=FragmentProfileBinding.inflate(inflater,container,false);
  auth=FirebaseAuth.getInstance();
  db=FirebaseDatabase.getInstance();
  adapter=new ListAdapter(getContext(),getActivity(),bind.postList,new OnLikeCallback(){
    @Override public void onLike(    final String postId){
      db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          for (          DataSnapshot data : dataSnapshot.getChildren())           if (auth.getCurrentUser().getUid().equals((String)data.getValue()))           return;
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
            @Override public void onDataChange(            DataSnapshot dataSnapshot){
              final long x=(long)dataSnapshot.getValue() + 1;
              db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").setValue(x).addOnCompleteListener(new OnCompleteListener<Void>(){
                @Override public void onComplete(                @NonNull Task<Void> task){
                  adapter.updateLike(postId,x);
                }
              }
);
            }
            @Override public void onCancelled(            DatabaseError databaseError){
            }
          }
);
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
  }
);
  if (childEventListener == null) {
    childEventListener=new ChildEventListener(){
      @Override public void onChildAdded(      DataSnapshot dataSnapshot,      String s){
        db.getReference().child(""String_Node_Str"").child((String)dataSnapshot.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
          @Override public void onDataChange(          DataSnapshot dataSnapshot){
            BlogPost post=dataSnapshot.getValue(BlogPost.class);
            post.setId(dataSnapshot.getKey());
            adapter.addPost(post);
          }
          @Override public void onCancelled(          DatabaseError databaseError){
          }
        }
);
      }
      @Override public void onChildChanged(      DataSnapshot dataSnapshot,      String s){
      }
      @Override public void onChildRemoved(      DataSnapshot dataSnapshot){
      }
      @Override public void onChildMoved(      DataSnapshot dataSnapshot,      String s){
      }
      @Override public void onCancelled(      DatabaseError databaseError){
      }
    }
;
    db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").addChildEventListener(childEventListener);
  }
  bind.postList.setLayoutManager(new LinearLayoutManager(getContext()));
  bind.postList.setAdapter(adapter);
  bind.addPost.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (user == null)       return;
      AlertDialog.Builder builder=new AlertDialog.Builder(ProfileFragment.this.getContext());
      View view=getLayoutInflater().inflate(R.layout.dialog_add_post,null);
      final EditText content=(EditText)view.findViewById(R.id.content);
      final TextView post=(TextView)view.findViewById(R.id.post);
      builder.setView(view);
      final AlertDialog d=builder.create();
      d.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
      d.show();
      post.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          d.cancel();
          createPost(content.getText().toString());
        }
      }
);
    }
  }
);
  dialog=new ProgressDialog(getContext());
  dialog.setMessage(getResources().getString(R.string.loading));
  dialog.setCancelable(false);
  runningDialog=true;
  dialog.show();
  db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      user=dataSnapshot.getValue(User.class);
      if (user == null) {
        auth.signOut();
        getActivity().finish();
        startActivity(new Intent(getContext(),SigninActivity.class));
        return;
      }
      user.setUid(auth.getCurrentUser().getUid());
      bind.userEmail.setText(user.getEmail());
      bind.userName.setText(user.getName());
      if (user.getPhoto_url() != null)       Picasso.with(getActivity()).load(user.getPhoto_url()).into(bind.photo);
      dialog.cancel();
      runningDialog=false;
      Toast.makeText(getContext(),getResources().getString(R.string.welcome),Toast.LENGTH_SHORT).show();
    }
    @Override public void onCancelled(    DatabaseError databaseError){
      dialog.cancel();
      Toast.makeText(getContext(),getResources().getString(R.string.error),Toast.LENGTH_SHORT).show();
    }
  }
);
  String userEmail=""String_Node_Str"";
  if (auth.getCurrentUser().getEmail() != null)   userEmail=auth.getCurrentUser().getEmail();
 else   userEmail=auth.getCurrentUser().getPhoneNumber();
  bind.userEmail.setText(userEmail);
  bind.logout.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      auth.signOut();
      startActivity(new Intent(getContext(),SigninActivity.class));
      getActivity().finish();
    }
  }
);
  return bind.getRoot();
}","@Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater,@Nullable ViewGroup container,@Nullable Bundle savedInstanceState){
  bind=FragmentProfileBinding.inflate(inflater,container,false);
  auth=FirebaseAuth.getInstance();
  db=FirebaseDatabase.getInstance();
  adapter=new ListAdapter(getContext(),getActivity(),bind.postList,new OnLikeCallback(){
    @Override public void onLike(    final String postId){
      db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          for (          DataSnapshot data : dataSnapshot.getChildren())           if (auth.getCurrentUser().getUid().equals((String)data.getValue()))           return;
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
            @Override public void onDataChange(            DataSnapshot dataSnapshot){
              final long x=(long)dataSnapshot.getValue() + 1;
              db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").setValue(x).addOnCompleteListener(new OnCompleteListener<Void>(){
                @Override public void onComplete(                @NonNull Task<Void> task){
                  adapter.updateLike(postId,x);
                }
              }
);
            }
            @Override public void onCancelled(            DatabaseError databaseError){
            }
          }
);
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
  }
);
  if (childEventListener == null) {
    childEventListener=new ChildEventListener(){
      @Override public void onChildAdded(      DataSnapshot dataSnapshot,      String s){
        db.getReference().child(""String_Node_Str"").child((String)dataSnapshot.getValue()).addListenerForSingleValueEvent(new ValueEventListener(){
          @Override public void onDataChange(          DataSnapshot dataSnapshot){
            BlogPost post=dataSnapshot.getValue(BlogPost.class);
            post.setId(dataSnapshot.getKey());
            adapter.addPost(post);
          }
          @Override public void onCancelled(          DatabaseError databaseError){
          }
        }
);
      }
      @Override public void onChildChanged(      DataSnapshot dataSnapshot,      String s){
      }
      @Override public void onChildRemoved(      DataSnapshot dataSnapshot){
      }
      @Override public void onChildMoved(      DataSnapshot dataSnapshot,      String s){
      }
      @Override public void onCancelled(      DatabaseError databaseError){
      }
    }
;
    db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").addChildEventListener(childEventListener);
  }
  bind.postList.setLayoutManager(new LinearLayoutManager(getContext()));
  bind.postList.setAdapter(adapter);
  bind.addPost.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (user == null)       return;
      AlertDialog.Builder builder=new AlertDialog.Builder(ProfileFragment.this.getContext());
      View view=getLayoutInflater().inflate(R.layout.dialog_add_post,null);
      final EditText content=(EditText)view.findViewById(R.id.content);
      final TextView post=(TextView)view.findViewById(R.id.post);
      builder.setView(view);
      final AlertDialog d=builder.create();
      d.getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
      d.show();
      post.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View v){
          d.cancel();
          createPost(content.getText().toString());
        }
      }
);
    }
  }
);
  dialog=new ProgressDialog(getContext());
  dialog.setMessage(getResources().getString(R.string.loading));
  dialog.setCancelable(false);
  runningDialog=true;
  dialog.show();
  db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      user=dataSnapshot.getValue(User.class);
      if (user == null) {
        auth.signOut();
        getActivity().finish();
        startActivity(new Intent(getContext(),SigninActivity.class));
        return;
      }
      user.setUid(auth.getCurrentUser().getUid());
      bind.userEmail.setText(user.getEmail());
      bind.userName.setText(user.getName());
      if (user.getPhoto_url() != null)       Picasso.with(getActivity()).load(user.getPhoto_url()).resize(ImageUtils.SIZE_XXL,ImageUtils.SIZE_XXL).into(bind.photo);
      dialog.cancel();
      runningDialog=false;
      Toast.makeText(getContext(),getResources().getString(R.string.welcome),Toast.LENGTH_SHORT).show();
    }
    @Override public void onCancelled(    DatabaseError databaseError){
      dialog.cancel();
      Toast.makeText(getContext(),getResources().getString(R.string.error),Toast.LENGTH_SHORT).show();
    }
  }
);
  String userEmail=""String_Node_Str"";
  if (auth.getCurrentUser().getEmail() != null)   userEmail=auth.getCurrentUser().getEmail();
 else   userEmail=auth.getCurrentUser().getPhoneNumber();
  bind.userEmail.setText(userEmail);
  bind.logout.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      auth.signOut();
      startActivity(new Intent(getContext(),SigninActivity.class));
      getActivity().finish();
    }
  }
);
  return bind.getRoot();
}"
70545,"public void bind(User user){
  this.user=user;
  bind.userName.setText(user.getName());
  bind.userEmail.setText(user.getEmail());
  if (user.getPhoto_url() != null)   Picasso.with(context).load(user.getPhoto_url()).into(bind.photo);
}","public void bind(User user){
  this.user=user;
  bind.userName.setText(user.getName());
  bind.userEmail.setText(user.getEmail());
  if (user.getPhoto_url() != null)   Picasso.with(context).load(user.getPhoto_url()).resize(ImageUtils.SIZE_XXL,ImageUtils.SIZE_XXL).into(bind.photo);
}"
70546,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_post_detail);
  db=FirebaseDatabase.getInstance();
  auth=FirebaseAuth.getInstance();
  Intent i=getIntent();
  if (i != null) {
    bind.nickname.setText(i.getStringExtra(EXTRA_NAME));
    bind.date.setText(i.getStringExtra(EXTRA_DATE));
    bind.content.setText(i.getStringExtra(EXTRA_CONTENT));
    ownerId=i.getStringExtra(EXTRA_OWNER_ID);
    postId=i.getStringExtra(EXTRA_ID);
    bind.like.setText(getResources().getString(R.string.like_cnt,i.getLongExtra(EXTRA_LIKE,0)));
    bind.comment.setText(getResources().getString(R.string.comment_cnt,i.getLongExtra(EXTRA_COMMENT,0)));
    bind.view.setText(getResources().getString(R.string.view_cnt,i.getLongExtra(EXTRA_VIEW,0)));
    String photo=i.getStringExtra(EXTRA_OWNER_PHOTO_URL);
    if (photo != null)     Picasso.with(this).load(photo).into(bind.photo);
    db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
      @Override public void onDataChange(      DataSnapshot dataSnapshot){
        for (        DataSnapshot snap : dataSnapshot.getChildren())         if (auth.getCurrentUser().getUid().equals((String)snap.getValue()))         return;
        db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
        db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
          @Override public void onDataChange(          DataSnapshot dataSnapshot){
            final long x=(long)dataSnapshot.getValue() + 1;
            db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").setValue(x).addOnCompleteListener(new OnCompleteListener<Void>(){
              @Override public void onComplete(              @NonNull Task<Void> task){
                bind.view.setText(getResources().getString(R.string.view_cnt,x));
                updateResult();
              }
            }
);
          }
          @Override public void onCancelled(          DatabaseError databaseError){
          }
        }
);
      }
      @Override public void onCancelled(      DatabaseError databaseError){
      }
    }
);
  }
  bind.nickname.setOnClickListener(onClickShowUser);
  bind.photo.setOnClickListener(onClickShowUser);
  dialogComments=CommentsDialog.getDialog(postId);
  dialogComments.setCallback(new CommentsDialog.OnCloseListener(){
    @Override public void onClose(){
      updateResult();
    }
  }
);
  dialogLikes=LikesDialog.getDialogInstance(postId);
  bind.like.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          for (          DataSnapshot snap : dataSnapshot.getChildren())           if (auth.getCurrentUser().getUid().equals((String)snap.getValue()))           return;
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
            @Override public void onDataChange(            DataSnapshot dataSnapshot){
              final long x=(long)dataSnapshot.getValue() + 1;
              db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").setValue(x).addOnCompleteListener(new OnCompleteListener<Void>(){
                @Override public void onComplete(                @NonNull Task<Void> task){
                  bind.like.setText(getResources().getString(R.string.like_cnt,x));
                  updateResult();
                }
              }
);
            }
            @Override public void onCancelled(            DatabaseError databaseError){
            }
          }
);
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
  }
);
  bind.showComments.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      dialogComments.show(getSupportFragmentManager(),""String_Node_Str"");
    }
  }
);
  bind.showLikes.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      dialogLikes.show(getSupportFragmentManager(),""String_Node_Str"");
    }
  }
);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  bind=DataBindingUtil.setContentView(this,R.layout.activity_post_detail);
  db=FirebaseDatabase.getInstance();
  auth=FirebaseAuth.getInstance();
  Intent i=getIntent();
  if (i != null) {
    bind.nickname.setText(i.getStringExtra(EXTRA_NAME));
    bind.date.setText(i.getStringExtra(EXTRA_DATE));
    bind.content.setText(i.getStringExtra(EXTRA_CONTENT));
    ownerId=i.getStringExtra(EXTRA_OWNER_ID);
    postId=i.getStringExtra(EXTRA_ID);
    bind.like.setText(getResources().getString(R.string.like_cnt,i.getLongExtra(EXTRA_LIKE,0)));
    bind.comment.setText(getResources().getString(R.string.comment_cnt,i.getLongExtra(EXTRA_COMMENT,0)));
    bind.view.setText(getResources().getString(R.string.view_cnt,i.getLongExtra(EXTRA_VIEW,0)));
    String photo=i.getStringExtra(EXTRA_OWNER_PHOTO_URL);
    if (photo != null)     Picasso.with(this).load(photo).resize(ImageUtils.SIZE_XL,ImageUtils.SIZE_XL).into(bind.photo);
    db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
      @Override public void onDataChange(      DataSnapshot dataSnapshot){
        for (        DataSnapshot snap : dataSnapshot.getChildren())         if (auth.getCurrentUser().getUid().equals((String)snap.getValue()))         return;
        db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
        db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
          @Override public void onDataChange(          DataSnapshot dataSnapshot){
            final long x=(long)dataSnapshot.getValue() + 1;
            db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").setValue(x).addOnCompleteListener(new OnCompleteListener<Void>(){
              @Override public void onComplete(              @NonNull Task<Void> task){
                bind.view.setText(getResources().getString(R.string.view_cnt,x));
                updateResult();
              }
            }
);
          }
          @Override public void onCancelled(          DatabaseError databaseError){
          }
        }
);
      }
      @Override public void onCancelled(      DatabaseError databaseError){
      }
    }
);
  }
  bind.nickname.setOnClickListener(onClickShowUser);
  bind.photo.setOnClickListener(onClickShowUser);
  dialogComments=CommentsDialog.getDialog(postId);
  dialogComments.setCallback(new CommentsDialog.OnCloseListener(){
    @Override public void onClose(){
      updateResult();
    }
  }
);
  dialogLikes=LikesDialog.getDialogInstance(postId);
  bind.like.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          for (          DataSnapshot snap : dataSnapshot.getChildren())           if (auth.getCurrentUser().getUid().equals((String)snap.getValue()))           return;
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
          db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
            @Override public void onDataChange(            DataSnapshot dataSnapshot){
              final long x=(long)dataSnapshot.getValue() + 1;
              db.getReference().child(""String_Node_Str"").child(postId).child(""String_Node_Str"").setValue(x).addOnCompleteListener(new OnCompleteListener<Void>(){
                @Override public void onComplete(                @NonNull Task<Void> task){
                  bind.like.setText(getResources().getString(R.string.like_cnt,x));
                  updateResult();
                }
              }
);
            }
            @Override public void onCancelled(            DatabaseError databaseError){
            }
          }
);
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
  }
);
  bind.showComments.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      dialogComments.show(getSupportFragmentManager(),""String_Node_Str"");
    }
  }
);
  bind.showLikes.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      dialogLikes.show(getSupportFragmentManager(),""String_Node_Str"");
    }
  }
);
}"
70547,"public void bind(Comment comment){
  this.comment=comment;
  bind.nickname.setText(comment.getOwner_name());
  bind.context.setText(comment.getContext());
  bind.nickname.setOnClickListener(onClickShowUser);
  bind.photo.setOnClickListener(onClickShowUser);
  if (comment.getOwner_photo_url() != null)   Picasso.with(context).load(comment.getOwner_photo_url()).into(bind.photo);
}","public void bind(Comment comment){
  this.comment=comment;
  bind.nickname.setText(comment.getOwner_name());
  bind.context.setText(comment.getContext());
  bind.nickname.setOnClickListener(onClickShowUser);
  bind.photo.setOnClickListener(onClickShowUser);
  if (comment.getOwner_photo_url() != null)   Picasso.with(context).load(comment.getOwner_photo_url()).resize(ImageUtils.SIZE_L,ImageUtils.SIZE_L).into(bind.photo);
}"
70548,"public void bind(User user){
  bind.nickname.setText(user.getName());
  if (user.getPhoto_url() != null)   Picasso.with(context).load(user.getPhoto_url()).into(bind.photo);
}","public void bind(User user){
  bind.nickname.setText(user.getName());
  if (user.getPhoto_url() != null)   Picasso.with(context).load(user.getPhoto_url()).resize(ImageUtils.SIZE_XXL,ImageUtils.SIZE_XXL).into(bind.photo);
}"
70549,"private void setupStatus(){
  if (user.getUid().equals(auth.getCurrentUser().getUid())) {
    status=1;
    bind.statusImg.setImageResource(R.drawable.icon_home);
    bind.statusTv.setText(R.string.you);
    bind.status.setVisibility(View.VISIBLE);
    bind.chatBtn.setVisibility(View.INVISIBLE);
    return;
  }
  db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      bind.status.setVisibility(View.VISIBLE);
      for (      DataSnapshot snap : dataSnapshot.getChildren()) {
        if (auth.getCurrentUser().getUid().equals((String)snap.getValue())) {
          status=2;
          bind.statusImg.setImageResource(R.drawable.icon_friend);
          bind.statusTv.setText(R.string.friend);
          return;
        }
      }
      status=3;
      bind.statusImg.setImageResource(R.drawable.icon_follow);
      bind.statusTv.setText(R.string.follow);
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
  bind.chatBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          if (dataSnapshot.getValue() == null) {
            String key=db.getReference().child(""String_Node_Str"").push().getKey();
            db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).setValue(key);
            db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").child(user.getUid()).setValue(key);
            db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(user.getUid());
            db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
            startActivity(ChatActivity.getIntent(key,ProfileActivity.this));
          }
 else {
            startActivity(ChatActivity.getIntent((String)dataSnapshot.getValue(),ProfileActivity.this));
          }
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
  }
);
}","private void setupStatus(){
  if (user.getUid().equals(auth.getCurrentUser().getUid())) {
    status=1;
    bind.statusImg.setImageResource(R.drawable.icon_home);
    bind.statusTv.setText(R.string.you);
    bind.status.setVisibility(View.VISIBLE);
    bind.chatBtn.setVisibility(View.INVISIBLE);
    return;
  }
  db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      bind.status.setVisibility(View.VISIBLE);
      for (      DataSnapshot snap : dataSnapshot.getChildren()) {
        if (auth.getCurrentUser().getUid().equals((String)snap.getValue())) {
          status=2;
          bind.statusImg.setImageResource(R.drawable.icon_friend);
          bind.statusTv.setText(R.string.friend);
          return;
        }
      }
      status=3;
      bind.statusImg.setImageResource(R.drawable.icon_follow);
      bind.statusTv.setText(R.string.follow);
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
  bind.chatBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).addListenerForSingleValueEvent(new ValueEventListener(){
        @Override public void onDataChange(        DataSnapshot dataSnapshot){
          if (dataSnapshot.getValue() == null) {
            String key=db.getReference().child(""String_Node_Str"").push().getKey();
            db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).setValue(key);
            db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").child(user.getUid()).setValue(key);
            db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(user.getUid());
            db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").setValue(user.getPhoto_url());
            db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
            startActivity(ChatActivity.getIntent(key,ProfileActivity.this));
          }
 else {
            startActivity(ChatActivity.getIntent((String)dataSnapshot.getValue(),ProfileActivity.this));
          }
        }
        @Override public void onCancelled(        DatabaseError databaseError){
        }
      }
);
    }
  }
);
}"
70550,"@Override public void onClick(View v){
  db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      if (dataSnapshot.getValue() == null) {
        String key=db.getReference().child(""String_Node_Str"").push().getKey();
        db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).setValue(key);
        db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").child(user.getUid()).setValue(key);
        db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(user.getUid());
        db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
        startActivity(ChatActivity.getIntent(key,ProfileActivity.this));
      }
 else {
        startActivity(ChatActivity.getIntent((String)dataSnapshot.getValue(),ProfileActivity.this));
      }
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
}","@Override public void onClick(View v){
  db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      if (dataSnapshot.getValue() == null) {
        String key=db.getReference().child(""String_Node_Str"").push().getKey();
        db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).setValue(key);
        db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").child(user.getUid()).setValue(key);
        db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(user.getUid());
        db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").setValue(user.getPhoto_url());
        db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
        startActivity(ChatActivity.getIntent(key,ProfileActivity.this));
      }
 else {
        startActivity(ChatActivity.getIntent((String)dataSnapshot.getValue(),ProfileActivity.this));
      }
    }
    @Override public void onCancelled(    DatabaseError databaseError){
    }
  }
);
}"
70551,"@Override public void onDataChange(DataSnapshot dataSnapshot){
  if (dataSnapshot.getValue() == null) {
    String key=db.getReference().child(""String_Node_Str"").push().getKey();
    db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).setValue(key);
    db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").child(user.getUid()).setValue(key);
    db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(user.getUid());
    db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
    startActivity(ChatActivity.getIntent(key,ProfileActivity.this));
  }
 else {
    startActivity(ChatActivity.getIntent((String)dataSnapshot.getValue(),ProfileActivity.this));
  }
}","@Override public void onDataChange(DataSnapshot dataSnapshot){
  if (dataSnapshot.getValue() == null) {
    String key=db.getReference().child(""String_Node_Str"").push().getKey();
    db.getReference().child(""String_Node_Str"").child(user.getUid()).child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).setValue(key);
    db.getReference().child(""String_Node_Str"").child(auth.getCurrentUser().getUid()).child(""String_Node_Str"").child(user.getUid()).setValue(key);
    db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(user.getUid());
    db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").setValue(user.getPhoto_url());
    db.getReference().child(""String_Node_Str"").child(key).child(""String_Node_Str"").push().setValue(auth.getCurrentUser().getUid());
    startActivity(ChatActivity.getIntent(key,ProfileActivity.this));
  }
 else {
    startActivity(ChatActivity.getIntent((String)dataSnapshot.getValue(),ProfileActivity.this));
  }
}"
70552,"private void showUserProfile(final String uid){
  dialog.show();
  db.getReference().child(""String_Node_Str"").child(uid).addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      user=dataSnapshot.getValue(User.class);
      user.setUid(uid);
      bind.userEmail.setText(user.getEmail());
      bind.userName.setText(user.getName());
      if (user.getPhoto_url() != null)       Picasso.with(ProfileActivity.this).load(user.getPhoto_url()).into(bind.photo);
      setupStatus();
      dialog.cancel();
      loadPosts();
    }
    @Override public void onCancelled(    DatabaseError databaseError){
      dialog.cancel();
      Toast.makeText(ProfileActivity.this,getResources().getString(R.string.error),Toast.LENGTH_SHORT).show();
    }
  }
);
}","private void showUserProfile(final String uid){
  dialog.show();
  db.getReference().child(""String_Node_Str"").child(uid).addListenerForSingleValueEvent(new ValueEventListener(){
    @Override public void onDataChange(    DataSnapshot dataSnapshot){
      user=dataSnapshot.getValue(User.class);
      user.setUid(uid);
      bind.userEmail.setText(user.getEmail());
      bind.userName.setText(user.getName());
      if (user.getPhoto_url() != null)       Picasso.with(ProfileActivity.this).load(user.getPhoto_url()).resize(ImageUtils.SIZE_XXL,ImageUtils.SIZE_XXL).into(bind.photo);
      setupStatus();
      dialog.cancel();
      loadPosts();
    }
    @Override public void onCancelled(    DatabaseError databaseError){
      dialog.cancel();
      Toast.makeText(ProfileActivity.this,getResources().getString(R.string.error),Toast.LENGTH_SHORT).show();
    }
  }
);
}"
70553,"private void phoneSignin(String number){
  dialog.show();
  PhoneAuthProvider.getInstance().verifyPhoneNumber(number,60,TimeUnit.SECONDS,this,new PhoneAuthProvider.OnVerificationStateChangedCallbacks(){
    @Override public void onVerificationCompleted(    PhoneAuthCredential phoneAuthCredential){
      auth.signInWithCredential(phoneAuthCredential).addOnCompleteListener(signInCallback);
    }
    @Override public void onVerificationFailed(    FirebaseException e){
      showToast(R.string.error);
    }
  }
);
}","private void phoneSignin(String number){
  if (number.isEmpty())   return;
  dialog.show();
  PhoneAuthProvider.getInstance().verifyPhoneNumber(number,60,TimeUnit.SECONDS,this,new PhoneAuthProvider.OnVerificationStateChangedCallbacks(){
    @Override public void onVerificationCompleted(    PhoneAuthCredential phoneAuthCredential){
      auth.signInWithCredential(phoneAuthCredential).addOnCompleteListener(signInCallback);
    }
    @Override public void onVerificationFailed(    FirebaseException e){
      showToast(R.string.error);
    }
  }
);
}"
70554,"private synchronized byte[] generateTsFiles(final String reqFileName,final long streamId) throws InterruptedException {
  final String wavFileName=reqFileName.replace(""String_Node_Str"",""String_Node_Str"");
  final OssUtil ossOperation=new OssUtil();
  ObjectMetadata objectMetadata=ossOperation.getObjectMetadata(wavFileName,streamId);
  final AacTranscodingTsSegmenter tsSegmenter=new AacTranscodingTsSegmenter();
  final int tsNum=tsSegmenter.calcTsNum((int)objectMetadata.getContentLength());
  StringBuilder m3u8=new StringBuilder();
  m3u8.append(""String_Node_Str"" + AacTranscodingTsSegmenter.TS_DURATION + ""String_Node_Str""+ 1);
  for (int i=0; i < tsNum; i++) {
    m3u8.append(""String_Node_Str"" + tsSegmenter.getTsSegTime() + ""String_Node_Str""+ reqFileName.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ i+ ""String_Node_Str"");
  }
  m3u8.append(""String_Node_Str"");
  ossOperation.uploadObject(m3u8.toString().getBytes(),reqFileName,streamId);
  executor.execute(new Runnable(){
    private int readBytes(    InputStream inputStream,    byte[] outputBuf) throws IOException {
      int length=outputBuf.length;
      int frameBufPtr=0;
      int len;
      while (frameBufPtr < length) {
        len=inputStream.read(outputBuf,frameBufPtr,length - frameBufPtr);
        if (len == -1) {
          if (frameBufPtr == 0) {
            return -1;
          }
          Arrays.fill(outputBuf,frameBufPtr,length,(byte)0x0);
          break;
        }
        frameBufPtr+=len;
      }
      return frameBufPtr;
    }
    @Override public void run(){
      List<String> cachedTsName=new ArrayList<>();
      byte[] frameBuf=new byte[2048];
      byte[] tsSegment;
      InputStream inputStream=ossOperation.readObject(wavFileName,streamId);
      try {
        long beginTime=System.currentTimeMillis();
        for (int i=0; i < tsNum; ) {
          if (readBytes(inputStream,frameBuf) > 0) {
            tsSegment=tsSegmenter.getTsBuf(V5PacketType.PCM_STREAM,frameBuf,null);
          }
 else {
            tsSegment=tsSegmenter.getTsBuf(V5PacketType.PCM_STREAM,FaacUtils.ZERO_PCM_DATA,null);
          }
          if (tsSegment != null) {
            StringBuffer tsNameSb=new StringBuffer();
            tsNameSb.append(reqFileName.replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"").append(i).append(""String_Node_Str"");
            String tsName=tsNameSb.toString();
            if (i < 5) {
              cachedTsName.add(tsName);
              cachedVodTsFiles.put(tsName,tsSegment);
              if (i == 4) {
synchronized (_lock) {
                  _lock.notifyAll();
                }
              }
            }
 else {
              ossOperation.uploadObject(tsSegment,tsName,streamId);
            }
            i++;
          }
        }
synchronized (_lock) {
          _lock.notifyAll();
        }
        for (        String name : cachedTsName) {
          byte[] ts=cachedVodTsFiles.get(name);
          ossOperation.uploadObject(ts,name,streamId);
          cachedVodTsFiles.remove(name);
        }
        long endTime=System.currentTimeMillis();
        LOGGER.debug(""String_Node_Str"" + reqFileName + ""String_Node_Str""+ tsNum+ ""String_Node_Str""+ ((endTime - beginTime) / 1000.0)+ ""String_Node_Str"");
      }
 catch (      IOException e1) {
        LOGGER.error(""String_Node_Str"",e1);
        ossOperation.deleteObject(reqFileName,streamId);
      }
 finally {
        ossOperation.closeOSSClient();
        tsSegmenter.close();
      }
    }
  }
);
synchronized (_lock) {
    _lock.wait(1000);
  }
synchronized (m3u8WaiteSet) {
    m3u8WaiteSet.remove(reqFileName);
    m3u8WaiteSet.notifyAll();
  }
  return m3u8.toString().getBytes();
}","private synchronized byte[] generateTsFiles(final String reqFileName,final long streamId) throws InterruptedException {
  final String wavFileName=reqFileName.replace(""String_Node_Str"",""String_Node_Str"");
  final OssUtil ossOperation=new OssUtil();
  ObjectMetadata objectMetadata=ossOperation.getObjectMetadata(wavFileName,streamId);
  final AacTranscodingTsSegmenter tsSegmenter=new AacTranscodingTsSegmenter();
  final int tsNum=tsSegmenter.calcTsNum((int)objectMetadata.getContentLength());
  HlsLiveStream stream=HlsLiveStreamMagr.INSTANCE().getHlsLiveStreamById(streamId);
  float sampleRate=stream != null ? stream.getSampleRate() : 8000F;
  StringBuilder m3u8=new StringBuilder();
  m3u8.append(""String_Node_Str"" + AacTranscodingTsSegmenter.TS_DURATION + ""String_Node_Str""+ 1);
  for (int i=0; i < tsNum; i++) {
    m3u8.append(""String_Node_Str"" + tsSegmenter.calcTsSegTime(sampleRate) + ""String_Node_Str""+ reqFileName.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ i+ ""String_Node_Str"");
  }
  m3u8.append(""String_Node_Str"");
  ossOperation.uploadObject(m3u8.toString().getBytes(),reqFileName,streamId);
  executor.execute(new Runnable(){
    private int readBytes(    InputStream inputStream,    byte[] outputBuf) throws IOException {
      int length=outputBuf.length;
      int frameBufPtr=0;
      int len;
      while (frameBufPtr < length) {
        len=inputStream.read(outputBuf,frameBufPtr,length - frameBufPtr);
        if (len == -1) {
          if (frameBufPtr == 0) {
            return -1;
          }
          Arrays.fill(outputBuf,frameBufPtr,length,(byte)0x0);
          break;
        }
        frameBufPtr+=len;
      }
      return frameBufPtr;
    }
    @Override public void run(){
      List<String> cachedTsName=new ArrayList<>();
      byte[] frameBuf=new byte[2048];
      byte[] tsSegment;
      InputStream inputStream=ossOperation.readObject(wavFileName,streamId);
      try {
        long beginTime=System.currentTimeMillis();
        for (int i=0; i < tsNum; ) {
          if (readBytes(inputStream,frameBuf) > 0) {
            tsSegment=tsSegmenter.getTsBuf(V5PacketType.PCM_STREAM,frameBuf,null);
          }
 else {
            tsSegment=tsSegmenter.getTsBuf(V5PacketType.PCM_STREAM,FaacUtils.ZERO_PCM_DATA,null);
          }
          if (tsSegment != null) {
            StringBuffer tsNameSb=new StringBuffer();
            tsNameSb.append(reqFileName.replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"").append(i).append(""String_Node_Str"");
            String tsName=tsNameSb.toString();
            if (i < 5) {
              cachedTsName.add(tsName);
              cachedVodTsFiles.put(tsName,tsSegment);
              if (i == 4) {
synchronized (_lock) {
                  _lock.notifyAll();
                }
              }
            }
 else {
              ossOperation.uploadObject(tsSegment,tsName,streamId);
            }
            i++;
          }
        }
synchronized (_lock) {
          _lock.notifyAll();
        }
        for (        String name : cachedTsName) {
          byte[] ts=cachedVodTsFiles.get(name);
          ossOperation.uploadObject(ts,name,streamId);
          cachedVodTsFiles.remove(name);
        }
        long endTime=System.currentTimeMillis();
        LOGGER.debug(""String_Node_Str"" + reqFileName + ""String_Node_Str""+ tsNum+ ""String_Node_Str""+ ((endTime - beginTime) / 1000.0)+ ""String_Node_Str"");
      }
 catch (      IOException e1) {
        LOGGER.error(""String_Node_Str"",e1);
        ossOperation.deleteObject(reqFileName,streamId);
      }
 finally {
        ossOperation.closeOSSClient();
        tsSegmenter.close();
      }
    }
  }
);
synchronized (_lock) {
    _lock.wait(1000);
  }
synchronized (m3u8WaiteSet) {
    m3u8WaiteSet.remove(reqFileName);
    m3u8WaiteSet.notifyAll();
  }
  return m3u8.toString().getBytes();
}"
70555,"public byte[] write(boolean isFirstPes,FrameDataType frameDataType,FrameData... frames){
  byte[] tsFileBuffer=null;
  byte[] patTsBuf=write_pat();
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,patTsBuf);
  byte[] pmtTsBuf=write_pmt(frameDataType);
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,pmtTsBuf);
  for (  FrameData frame : frames) {
    boolean isFristTs=true;
    boolean isAudio=frame.isAudio;
    long pts=frame.pts;
    long dts=frame.dts;
    byte[] frameBuf=frame.buf;
    int frameBufSize=frameBuf.length;
    int frameBufPtr=0;
    int pid=isAudio ? TS_AUDIO_PID : TS_VIDEO_PID;
    while (frameBufPtr < frameBufSize) {
      int frameBufRemaining=frameBufSize - frameBufPtr;
      boolean isAdaptationField=(isFristTs || (frameBufRemaining < TS_PAYLOAD_SIZE)) ? true : false;
      byte[] tsBuf=new byte[TS_PACKET_SIZE];
      int offset=0;
      tsBuf[offset++]=0x47;
      tsBuf[offset++]=(byte)((isFristTs ? 0x40 : 0x00) | ((pid >> 8) & 0x1f));
      tsBuf[offset++]=(byte)(pid & 0xff);
      tsBuf[offset++]=(byte)((isAdaptationField ? 0x30 : 0x10) | ((isAudio ? mAudioContinuityCounter++ : mVideoContinuityCounter++) & 0xF));
      if (isFristTs) {
        tsBuf[offset++]=0x07;
        tsBuf[offset++]|=isFirstPes ? 0x50 : (isAudio && frameDataType == FrameDataType.MIXED ? 0x50 : 0x10);
        long pcr=pts;
        tsBuf[offset++]=(byte)((pcr >> 25) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 17) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 9) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 1) & 0xFF);
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x01;
        tsBuf[offset++]=isAudio ? (byte)0xc0 : (byte)0xe0;
        int header_size=5 + 5;
        if (isAudio) {
          int pes_size=frameBufSize + header_size + 3;
          tsBuf[offset++]=(byte)((pes_size >> 8) & 0xFF);
          tsBuf[offset++]=(byte)(pes_size & 0xFF);
        }
 else {
          tsBuf[offset++]=0x00;
          tsBuf[offset++]=0x00;
        }
        tsBuf[offset++]=(byte)0x80;
        tsBuf[offset++]=(byte)0xc0;
        tsBuf[offset++]=(byte)header_size;
        tsBuf[offset++]=(byte)(((pts >> 30) & 0xFE) | 0x31);
        tsBuf[offset++]=(byte)((pts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((pts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((pts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((pts << 1) & 0xFE | 0x01);
        tsBuf[offset++]=(byte)(((dts >> 29) & 0xFE) | 0x11);
        tsBuf[offset++]=(byte)((dts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((dts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((dts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((dts << 1) & 0xFE | 0x01);
        if (!isAudio && Bytes.indexOf(frameBuf,H264_NAL) == -1) {
          System.arraycopy(H264_NAL,0,tsBuf,offset++,H264_NAL.length);
          offset+=H264_NAL.length;
        }
      }
 else {
        if (isAdaptationField) {
          tsBuf[offset++]=1;
          tsBuf[offset++]=(byte)0x00;
        }
 else {
        }
      }
      int tsBufRemaining=TS_PACKET_SIZE - offset;
      if (frameBufRemaining >= tsBufRemaining) {
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,offset,tsBufRemaining);
        offset+=tsBufRemaining;
        frameBufPtr+=tsBufRemaining;
      }
 else {
        int paddingSize=tsBufRemaining - frameBufRemaining;
        if (isAdaptationField) {
          int adaptationFieldLength=(tsBuf[4] & 0xFF);
          int start=TS_HEADER_SIZE + adaptationFieldLength + 1;
          int end=offset - 1;
          for (int i=end; i >= start; i--) {
            tsBuf[i + paddingSize]=tsBuf[i];
          }
          for (int i=0; i < paddingSize; i++) {
            tsBuf[start + i]=(byte)0xff;
          }
          tsBuf[4]+=paddingSize;
        }
 else {
          tsBuf[3]|=0x20;
          tsBuf[4]=(byte)paddingSize;
          tsBuf[5]=0;
          for (int i=0; i < paddingSize; i++) {
            tsBuf[6 + i]=(byte)0xFF;
          }
        }
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,(int)(offset + paddingSize),frameBufRemaining);
        frameBufPtr+=frameBufRemaining;
      }
      isFristTs=false;
      tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,tsBuf);
    }
  }
  return tsFileBuffer;
}","public byte[] write(boolean isFirstPes,FrameDataType frameDataType,FrameData... frames){
  byte[] tsFileBuffer=null;
  byte[] patTsBuf=write_pat();
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,patTsBuf);
  byte[] pmtTsBuf=write_pmt(frameDataType);
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,pmtTsBuf);
  for (  FrameData frame : frames) {
    boolean isFristTs=true;
    boolean isAudio=frame.isAudio;
    long pts=frame.pts;
    long dts=frame.dts;
    byte[] frameBuf=frame.buf;
    int frameBufSize=frameBuf.length;
    int frameBufPtr=0;
    int pid=isAudio ? TS_AUDIO_PID : TS_VIDEO_PID;
    while (frameBufPtr < frameBufSize) {
      int frameBufRemaining=frameBufSize - frameBufPtr;
      boolean isAdaptationField=(isFristTs || (frameBufRemaining < TS_PAYLOAD_SIZE)) ? true : false;
      byte[] tsBuf=new byte[TS_PACKET_SIZE];
      int offset=0;
      tsBuf[offset++]=0x47;
      tsBuf[offset++]=(byte)((isFristTs ? 0x40 : 0x00) | ((pid >> 8) & 0x1f));
      tsBuf[offset++]=(byte)(pid & 0xff);
      tsBuf[offset++]=(byte)((isAdaptationField ? 0x30 : 0x10) | ((isAudio ? mAudioContinuityCounter++ : mVideoContinuityCounter++) & 0xF));
      if (isFristTs) {
        tsBuf[offset++]=0x07;
        tsBuf[offset++]|=isFirstPes ? 0x50 : (isAudio && frameDataType == FrameDataType.MIXED ? 0x50 : 0x10);
        long pcr=pts;
        tsBuf[offset++]=(byte)((pcr >> 25) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 17) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 9) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 1) & 0xFF);
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x01;
        tsBuf[offset++]=isAudio ? (byte)0xc0 : (byte)0xe0;
        int header_size=5 + 5;
        if (isAudio) {
          int pes_size=frameBufSize + header_size + 3;
          tsBuf[offset++]=(byte)((pes_size >> 8) & 0xFF);
          tsBuf[offset++]=(byte)(pes_size & 0xFF);
        }
 else {
          tsBuf[offset++]=0x00;
          tsBuf[offset++]=0x00;
        }
        tsBuf[offset++]=(byte)0x80;
        tsBuf[offset++]=(byte)0xc0;
        tsBuf[offset++]=(byte)header_size;
        tsBuf[offset++]=(byte)(((pts >> 29) & 0xFE) | 0x31);
        tsBuf[offset++]=(byte)((pts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((pts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((pts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((pts << 1) & 0xFE | 0x01);
        tsBuf[offset++]=(byte)(((dts >> 29) & 0xFE) | 0x11);
        tsBuf[offset++]=(byte)((dts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((dts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((dts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((dts << 1) & 0xFE | 0x01);
        if (!isAudio && Bytes.indexOf(frameBuf,H264_NAL) == -1) {
          System.arraycopy(H264_NAL,0,tsBuf,offset++,H264_NAL.length);
          offset+=H264_NAL.length;
        }
      }
 else {
        if (isAdaptationField) {
          tsBuf[offset++]=1;
          tsBuf[offset++]=(byte)0x00;
        }
 else {
        }
      }
      int tsBufRemaining=TS_PACKET_SIZE - offset;
      if (frameBufRemaining >= tsBufRemaining) {
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,offset,tsBufRemaining);
        offset+=tsBufRemaining;
        frameBufPtr+=tsBufRemaining;
      }
 else {
        int paddingSize=tsBufRemaining - frameBufRemaining;
        if (isAdaptationField) {
          int adaptationFieldLength=(tsBuf[4] & 0xFF);
          int start=TS_HEADER_SIZE + adaptationFieldLength + 1;
          int end=offset - 1;
          for (int i=end; i >= start; i--) {
            tsBuf[i + paddingSize]=tsBuf[i];
          }
          for (int i=0; i < paddingSize; i++) {
            tsBuf[start + i]=(byte)0xff;
          }
          tsBuf[4]+=paddingSize;
        }
 else {
          tsBuf[3]|=0x20;
          tsBuf[4]=(byte)paddingSize;
          tsBuf[5]=0;
          for (int i=0; i < paddingSize; i++) {
            tsBuf[6 + i]=(byte)0xFF;
          }
        }
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,(int)(offset + paddingSize),frameBufRemaining);
        frameBufPtr+=frameBufRemaining;
      }
      isFristTs=false;
      tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,tsBuf);
    }
  }
  return tsFileBuffer;
}"
70556,"public long[] fetchTsIndexs(){
  Set<Long> indexSET=tsSegments.keySet();
  if (indexSET.size() < 3) {
    return null;
  }
  Long[] indexArr=indexSET.toArray(new Long[indexSET.size()]);
  Arrays.sort(indexArr);
  if (indexArr.length > 5) {
    Long[] tmpArr=new Long[5];
    System.arraycopy(indexArr,indexArr.length - 5,tmpArr,0,5);
    return ArrayUtils.toPrimitive(tmpArr);
  }
 else {
    return ArrayUtils.toPrimitive(indexArr);
  }
}","public long[] fetchTsIndexs(){
  Set<Long> indexSET=ImmutableSet.copyOf(tsSegments.keySet());
  if (indexSET.size() < 3) {
    return null;
  }
  Long[] indexArr=indexSET.toArray(new Long[indexSET.size()]);
  Arrays.sort(indexArr);
  if (indexArr.length > 5) {
    Long[] tmpArr=new Long[5];
    System.arraycopy(indexArr,indexArr.length - 5,tmpArr,0,5);
    return ArrayUtils.toPrimitive(tmpArr);
  }
 else {
    return ArrayUtils.toPrimitive(indexArr);
  }
}"
70557,"private boolean isFilter(ChannelHandlerContext ctx,MessageEvent messageEvent,IRequestHandler requestHandler){
  List<IFilter> filters=filterChain.get(requestHandler.getType());
  for (  IFilter filter : filters) {
    if (filter.doFilter(ctx,messageEvent)) {
      continue;
    }
 else {
      return false;
    }
  }
  return true;
}","private boolean isFilter(ChannelHandlerContext ctx,MessageEvent messageEvent,IRequestHandler requestHandler){
  List<IFilter> filters=filterChain.get(requestHandler.getType());
  if (filters != null) {
    for (    IFilter filter : filters) {
      if (filter.doFilter(ctx,messageEvent)) {
        continue;
      }
 else {
        return false;
      }
    }
  }
  return true;
}"
70558,"public TsSegment fetchTsSegmentByIndex(long index){
  if (index < 0)   return null;
  TsSegment tsSegment=null;
  if (index < 4) {
    String type=""String_Node_Str"";
switch (streamType) {
case HlsLiveStreamType.YUV:
case HlsLiveStreamType.H264:
      type=""String_Node_Str"";
    break;
case HlsLiveStreamType.AAC_H264_MIXED:
  type=""String_Node_Str"";
break;
}
List<TsSegment> adTsSegments=adsMagr.getAdsTsSegments(type,sampleRate,sampleSizeInBits,channels,fps);
tsSegment=adTsSegments.get((int)index - 1);
}
 else {
tsSegment=tsSegments.get(index);
}
if (tsSegment != null) {
tsSegment.setLasttime(System.currentTimeMillis());
}
return tsSegment;
}","public TsSegment fetchTsSegmentByIndex(long index){
  if (index < 0)   return null;
  TsSegment tsSegment=null;
  if (index < 4) {
    String type=""String_Node_Str"";
switch (streamType) {
case HlsLiveStreamType.YUV:
case HlsLiveStreamType.H264:
      type=""String_Node_Str"";
    break;
case HlsLiveStreamType.AAC_H264_MIXED:
  type=""String_Node_Str"";
break;
}
List<TsSegment> adTsSegments=AdsMagr.getAdsTsSegments(type,sampleRate,sampleSizeInBits,channels,fps);
tsSegment=adTsSegments.get((int)index - 1);
}
 else {
tsSegment=tsSegments.get(index);
}
if (tsSegment != null) {
tsSegment.setLasttime(System.currentTimeMillis());
}
return tsSegment;
}"
70559,"public static boolean isHasAds(){
  return isHasAds;
}","public static boolean isHasAds(){
  if (isLoading.get()) {
    return false;
  }
  return isHasAds;
}"
70560,"public static void initialize(){
  String adsPath=HlsCtx.INSTANCE().getHomePath() + File.separator + ""String_Node_Str"";
  File adsDirectory=new File(adsPath);
  if (adsDirectory.exists() && adsDirectory.isDirectory()) {
    List<AdsCfg> adsCfgs=HlsCtx.INSTANCE().getAdsCfgs();
    for (    AdsCfg adsCfg : adsCfgs) {
      String md5=null;
      String filePath=adsPath + File.separator + adsCfg.getName();
      File file=new File(filePath);
      if (file.isFile() && file.exists()) {
        InputStream in=null;
        try {
          in=new FileInputStream(file);
          byte[] adRawData=new byte[(int)file.length()];
          in.read(adRawData,0,adRawData.length);
switch (adsCfg.getType()) {
case ""String_Node_Str"":
            md5=Md5.md5_32(adsCfg.getType() + adsCfg.getSampleRate() + adsCfg.getSampleSizeInBits()+ adsCfg.getChannels());
          if (adRawData != null) {
            AacTsSegmenter aacTsSegmenter=new AacTsSegmenter();
            aacTsSegmenter.initialize(adsCfg.getSampleRate(),adsCfg.getSampleSizeInBits(),adsCfg.getChannels(),adsCfg.getFps());
            List<TsSegment> aacTsSegs=new ArrayList<TsSegment>();
            List<Integer> list=ByteUtil.kmp(adRawData,new byte[]{(byte)0xff,(byte)0xf1});
            int index=1;
            for (int k=0; k < list.size(); k++) {
              byte[] frameBuf=null;
              if (k < list.size() - 1) {
                frameBuf=Arrays.copyOfRange(adRawData,list.get(k),list.get(k + 1));
              }
 else {
                frameBuf=Arrays.copyOfRange(adRawData,list.get(k),adRawData.length);
              }
              byte[] tsSegment=aacTsSegmenter.getTsBuf(V5PacketType.AAC_STREAM,frameBuf,null);
              if (tsSegment != null)               aacTsSegs.add(new TsSegment((index++) + ""String_Node_Str"",tsSegment,aacTsSegmenter.getTsSegTime(),true));
            }
            adsSegs.put(md5,aacTsSegs);
          }
        break;
case ""String_Node_Str"":
      md5=Md5.md5_32(adsCfg.getType() + adsCfg.getFps());
    H264TsSegmenter h264TsSegmenter=new H264TsSegmenter();
  h264TsSegmenter.initialize(adsCfg.getSampleRate(),adsCfg.getSampleSizeInBits(),adsCfg.getChannels(),adsCfg.getFps());
if (adRawData != null) {
  List<TsSegment> h264TsSegs=new ArrayList<TsSegment>();
  h264TsSegmenter=new H264TsSegmenter();
  int index=0;
  int ptr=0;
  while (ptr < adRawData.length) {
    int len=ptr + 2048 < adRawData.length ? 2048 : adRawData.length - ptr;
    byte[] dest=new byte[len];
    System.arraycopy(adRawData,ptr,dest,0,len);
    byte[] tsSegment=h264TsSegmenter.getTsBuf(V5PacketType.H264_STREAM,dest,null);
    if (tsSegment != null)     h264TsSegs.add(new TsSegment((++index) + ""String_Node_Str"",tsSegment,h264TsSegmenter.getTsSegTime(),true));
    ptr+=2048;
  }
  adsSegs.put(md5,h264TsSegs);
}
break;
case ""String_Node_Str"":
md5=Md5.md5_32(adsCfg.getType() + adsCfg.getSampleRate() + adsCfg.getSampleSizeInBits()+ adsCfg.getChannels()+ adsCfg.getFps());
AacH264MixedTsSegmenter mixedTsSegmenter=new AacH264MixedTsSegmenter();
mixedTsSegmenter.initialize(adsCfg.getSampleRate(),adsCfg.getSampleSizeInBits(),adsCfg.getChannels(),adsCfg.getFps());
if (adRawData != null) {
List<TsSegment> mixedTsSegs=new ArrayList<TsSegment>();
adsSegs.put(md5,mixedTsSegs);
}
break;
default :
continue;
}
}
 catch (Exception e) {
LOGGER.error(e.getMessage());
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
}
}
}
}
}
}
}","public static void initialize(){
  if (!isLoading.compareAndSet(false,true)) {
    return;
  }
  try {
    String adsPath=HlsCtx.INSTANCE().getHomePath() + File.separator + ""String_Node_Str"";
    File adsDirectory=new File(adsPath);
    if (adsDirectory.exists() && adsDirectory.isDirectory()) {
      List<AdsCfg> adsCfgs=HlsCtx.INSTANCE().getAdsCfgs();
      for (      AdsCfg adsCfg : adsCfgs) {
        String md5=null;
        String filePath=adsPath + File.separator + adsCfg.getName();
        File file=new File(filePath);
        if (file.isFile() && file.exists()) {
          InputStream in=null;
          try {
            in=new FileInputStream(file);
            byte[] adRawData=new byte[(int)file.length()];
            in.read(adRawData,0,adRawData.length);
switch (adsCfg.getType()) {
case ""String_Node_Str"":
              md5=Md5.md5_32(adsCfg.getType() + adsCfg.getSampleRate() + adsCfg.getSampleSizeInBits()+ adsCfg.getChannels());
            if (adRawData != null) {
              AacTsSegmenter aacTsSegmenter=new AacTsSegmenter();
              aacTsSegmenter.initialize(adsCfg.getSampleRate(),adsCfg.getSampleSizeInBits(),adsCfg.getChannels(),adsCfg.getFps());
              List<TsSegment> aacTsSegs=new ArrayList<TsSegment>();
              List<Integer> list=ByteUtil.kmp(adRawData,new byte[]{(byte)0xff,(byte)0xf1});
              int index=1;
              for (int k=0; k < list.size(); k++) {
                byte[] frameBuf=null;
                if (k < list.size() - 1) {
                  frameBuf=Arrays.copyOfRange(adRawData,list.get(k),list.get(k + 1));
                }
 else {
                  frameBuf=Arrays.copyOfRange(adRawData,list.get(k),adRawData.length);
                }
                byte[] tsSegment=aacTsSegmenter.getTsBuf(V5PacketType.AAC_STREAM,frameBuf,null);
                if (tsSegment != null)                 aacTsSegs.add(new TsSegment((index++) + ""String_Node_Str"",tsSegment,aacTsSegmenter.getTsSegTime(),true));
              }
              adsSegs.put(md5,aacTsSegs);
            }
          break;
case ""String_Node_Str"":
        md5=Md5.md5_32(adsCfg.getType() + adsCfg.getFps());
      H264TsSegmenter h264TsSegmenter=new H264TsSegmenter();
    h264TsSegmenter.initialize(adsCfg.getSampleRate(),adsCfg.getSampleSizeInBits(),adsCfg.getChannels(),adsCfg.getFps());
  if (adRawData != null) {
    List<TsSegment> h264TsSegs=new ArrayList<TsSegment>();
    h264TsSegmenter=new H264TsSegmenter();
    int index=0;
    int ptr=0;
    while (ptr < adRawData.length) {
      int len=ptr + 2048 < adRawData.length ? 2048 : adRawData.length - ptr;
      byte[] dest=new byte[len];
      System.arraycopy(adRawData,ptr,dest,0,len);
      byte[] tsSegment=h264TsSegmenter.getTsBuf(V5PacketType.H264_STREAM,dest,null);
      if (tsSegment != null)       h264TsSegs.add(new TsSegment((++index) + ""String_Node_Str"",tsSegment,h264TsSegmenter.getTsSegTime(),true));
      ptr+=2048;
    }
    adsSegs.put(md5,h264TsSegs);
  }
break;
case ""String_Node_Str"":
md5=Md5.md5_32(adsCfg.getType() + adsCfg.getSampleRate() + adsCfg.getSampleSizeInBits()+ adsCfg.getChannels()+ adsCfg.getFps());
AacH264MixedTsSegmenter mixedTsSegmenter=new AacH264MixedTsSegmenter();
mixedTsSegmenter.initialize(adsCfg.getSampleRate(),adsCfg.getSampleSizeInBits(),adsCfg.getChannels(),adsCfg.getFps());
if (adRawData != null) {
List<TsSegment> mixedTsSegs=new ArrayList<TsSegment>();
adsSegs.put(md5,mixedTsSegs);
}
break;
default :
continue;
}
}
 catch (Exception e) {
LOGGER.error(e.getMessage());
}
 finally {
if (in != null) {
try {
in.close();
}
 catch (IOException e) {
}
}
}
}
}
}
}
  finally {
isLoading.lazySet(false);
}
}"
70561,"public List<TsSegment> getAdsTsSegments(String type,float sampleRate,int sampleSizeInBits,int channels,int fps){
  String md5Key=""String_Node_Str"";
switch (type) {
case ""String_Node_Str"":
    md5Key=Md5.md5_32(type + sampleRate + sampleSizeInBits+ channels);
  break;
case ""String_Node_Str"":
md5Key=Md5.md5_32(type + fps);
break;
case ""String_Node_Str"":
md5Key=Md5.md5_32(type + sampleRate + sampleSizeInBits+ channels+ fps);
break;
}
return adsSegs.get(md5Key);
}","public static List<TsSegment> getAdsTsSegments(String type,float sampleRate,int sampleSizeInBits,int channels,int fps){
  String md5Key=""String_Node_Str"";
switch (type) {
case ""String_Node_Str"":
    md5Key=Md5.md5_32(type + sampleRate + sampleSizeInBits+ channels);
  break;
case ""String_Node_Str"":
md5Key=Md5.md5_32(type + fps);
break;
case ""String_Node_Str"":
md5Key=Md5.md5_32(type + sampleRate + sampleSizeInBits+ channels+ fps);
break;
}
return adsSegs.get(md5Key);
}"
70562,"public M3U8 getM3u8File(String filename) throws Exception {
  boolean isTsModified=false;
  if (ctime == mtime && AdsMagr.isHasAds()) {
    tsIndexs=new long[]{1,2,3};
  }
 else {
    long[] newTsIndexs=liveStream.fetchTsIndexs();
    if (tsIndexs != null && tsIndexs[0] < 4) {
      if (newTsIndexs != null && tsIndexs[tsIndexs.length - 1] < newTsIndexs[newTsIndexs.length - 1]) {
        for (int i=0; i < tsIndexs.length - 1; i++) {
          tsIndexs[i]=tsIndexs[i + 1];
        }
        if (tsIndexs.length < 5) {
          tsIndexs=Arrays.copyOf(tsIndexs,5);
          tsIndexs[2]=newTsIndexs[newTsIndexs.length - 3];
          tsIndexs[3]=newTsIndexs[newTsIndexs.length - 2];
          tsIndexs[4]=newTsIndexs[newTsIndexs.length - 1];
        }
        tsIndexs[tsIndexs.length - 1]=newTsIndexs[newTsIndexs.length - 1];
        isTsModified=true;
      }
    }
 else     if (tsIndexs == null && newTsIndexs != null) {
      tsIndexs=newTsIndexs;
      isTsModified=true;
    }
 else     if (tsIndexs != null && newTsIndexs != null) {
      if (tsIndexs[tsIndexs.length - 1] < newTsIndexs[newTsIndexs.length - 1]) {
        for (int i=0; i < tsIndexs.length - 1; i++) {
          tsIndexs[i]=tsIndexs[i + 1];
        }
        tsIndexs[tsIndexs.length - 1]=tsIndexs[tsIndexs.length - 2] + 1;
        isTsModified=true;
      }
    }
  }
  this.mtime=System.currentTimeMillis();
  LOGGER.info(""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(tsIndexs),filename);
  List<TsSegment> tsSegments=new LinkedList<TsSegment>();
  if (tsIndexs != null) {
    for (    long tsIndex : tsIndexs) {
      TsSegment tsSegment=liveStream.fetchTsSegment(tsIndex);
      if (tsSegment != null) {
        if (tsSegment.isAds())         tsSegment.setDiscontinue(true);
        tsSegments.add(tsSegment);
      }
    }
  }
  long m3u8Seq=m3u8 == null ? 0 : m3u8.getSeq();
  m3u8Seq++;
  m3u8=m3u8Builder.generateM3u8(isTsModified ? m3u8Seq++ : m3u8Seq,tsSegments);
  LOGGER.info(""String_Node_Str"",m3u8);
  return m3u8;
}","public M3U8 getM3u8File(String filename) throws Exception {
  boolean isTsModified=false;
  if (ctime == mtime && AdsMagr.isHasAds()) {
    oldTsIndexs=new long[]{1,2,3};
  }
 else {
    if (oldTsIndexs == null) {
      long[] newTsIndexs=liveStream.fetchTsIndexs();
      if (newTsIndexs != null) {
        int len=Math.min(newTsIndexs.length,5);
        long[] tmpTsIndexs=new long[len];
        System.arraycopy(newTsIndexs,newTsIndexs.length - len,tmpTsIndexs,0,len);
        oldTsIndexs=tmpTsIndexs;
        isTsModified=true;
      }
    }
 else {
      long[] newTsIndexs=liveStream.fetchTsIndexs();
      if (newTsIndexs != null) {
        long lastOldIndex=oldTsIndexs[oldTsIndexs.length - 1];
        long lastNewIndex=newTsIndexs[newTsIndexs.length - 1];
        int p1=(int)(lastNewIndex - lastOldIndex);
        int p2=(5 - oldTsIndexs.length);
        if (p2 > 0) {
          if (p1 > 0) {
            int paddingLen=Math.min(p1,p2);
            long[] tmpTsIndexs1=new long[oldTsIndexs.length + paddingLen];
            System.arraycopy(oldTsIndexs,0,tmpTsIndexs1,0,oldTsIndexs.length);
            long tmpOldLastIndex=lastOldIndex;
            for (int i=oldTsIndexs.length; i < tmpTsIndexs1.length; i++) {
              tmpOldLastIndex++;
              tmpTsIndexs1[i]=tmpOldLastIndex;
            }
            long[] tmpTsIndexs2=new long[tmpTsIndexs1.length - 1];
            System.arraycopy(tmpTsIndexs1,1,tmpTsIndexs2,0,tmpTsIndexs1.length - 1);
            long lastTmpTsIndex2=tmpTsIndexs2[tmpTsIndexs2.length - 1];
            if (lastNewIndex > lastTmpTsIndex2) {
              long[] tmpTsIndexs3=new long[tmpTsIndexs1.length];
              System.arraycopy(tmpTsIndexs2,0,tmpTsIndexs3,0,tmpTsIndexs2.length);
              tmpTsIndexs3[tmpTsIndexs3.length - 1]=lastTmpTsIndex2 + 1;
              oldTsIndexs=tmpTsIndexs3;
            }
 else {
              oldTsIndexs=tmpTsIndexs2;
            }
            isTsModified=true;
          }
        }
 else {
          if (p1 > 0) {
            long[] tmpTsIndexs=new long[5];
            System.arraycopy(oldTsIndexs,1,tmpTsIndexs,0,oldTsIndexs.length - 1);
            tmpTsIndexs[4]=lastOldIndex + 1;
            oldTsIndexs=tmpTsIndexs;
            isTsModified=true;
          }
        }
      }
    }
  }
  this.mtime=System.currentTimeMillis();
  LOGGER.info(""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(oldTsIndexs),filename);
  List<TsSegment> tsSegments=new LinkedList<TsSegment>();
  if (oldTsIndexs != null) {
    for (    long tsIndex : oldTsIndexs) {
      TsSegment tsSegment=liveStream.fetchTsSegmentByIndex(tsIndex);
      if (tsSegment != null) {
        if (tsSegment.isAds())         tsSegment.setDiscontinue(true);
        tsSegments.add(tsSegment);
      }
    }
  }
  long m3u8Seq=m3u8 == null ? 0 : m3u8.getSeq();
  m3u8Seq++;
  m3u8=m3u8Builder.generateM3u8(isTsModified ? m3u8Seq++ : m3u8Seq,tsSegments);
  LOGGER.info(""String_Node_Str"",m3u8);
  return m3u8;
}"
70563,"public HlsLiveStream(Long streamId,Integer streamType,List<String> aliasNames,Float sampleRate,Integer sampleSizeInBits,Integer channels,Integer fps){
  this.mtime=System.currentTimeMillis();
  this.streamId=streamId;
  this.streamType=streamType;
  this.aliasNames=aliasNames;
  this.sampleRate=sampleRate == null ? 8000F : sampleRate;
  this.sampleSizeInBits=sampleSizeInBits == null ? 16 : sampleSizeInBits;
  this.channels=channels == null ? 1 : channels;
  this.fps=fps == null ? 25 : fps;
switch (streamType) {
case HlsLiveStreamType.PCM:
    tsSegmenter=new AacTranscodingTsSegmenter();
  break;
case HlsLiveStreamType.AAC:
tsSegmenter=new AacTsSegmenter();
break;
case HlsLiveStreamType.YUV:
tsSegmenter=new H264TranscodingTsSegmenter();
break;
case HlsLiveStreamType.H264:
tsSegmenter=new H264TsSegmenter();
break;
case HlsLiveStreamType.AAC_H264_MIXED:
tsSegmenter=new AacH264MixedTsSegmenter();
break;
}
tsSegmenter.initialize(sampleRate,sampleSizeInBits,channels,fps);
scheduledExecutor.scheduleAtFixedRate(new Runnable(){
@Override public void run(){
long minTsIndex=-1;
for (HlsClientSession clientSession : clientSessions.values()) {
long[] tsIndexs=clientSession.getTsIndexs();
if (tsIndexs != null) {
long tmpTsIndex=Longs.min(tsIndexs);
if (minTsIndex == -1 || minTsIndex > tmpTsIndex) {
minTsIndex=tmpTsIndex;
}
}
}
if (minTsIndex - 1 > 3 || minTsIndex == -1) {
for (Map.Entry<Long,TsSegment> entry : tsSegments.entrySet()) {
long idx=entry.getKey();
TsSegment tsSegment=entry.getValue();
if ((idx < minTsIndex || minTsIndex == -1) && (System.currentTimeMillis() - tsSegment.getLasttime() > 30 * 1000)) {
tsSegments.remove(idx);
LOGGER.info(""String_Node_Str"",tsSegment,minTsIndex);
}
}
}
}
}
,10,10,TimeUnit.SECONDS);
}","public HlsLiveStream(Long streamId,Integer streamType,List<String> aliasNames,Float sampleRate,Integer sampleSizeInBits,Integer channels,Integer fps){
  this.mtime=System.currentTimeMillis();
  this.streamId=streamId;
  this.streamType=streamType;
  this.aliasNames=aliasNames;
  this.sampleRate=sampleRate == null ? 8000F : sampleRate;
  this.sampleSizeInBits=sampleSizeInBits == null ? 16 : sampleSizeInBits;
  this.channels=channels == null ? 1 : channels;
  this.fps=fps == null ? 25 : fps;
switch (streamType) {
case HlsLiveStreamType.PCM:
    tsSegmenter=new AacTranscodingTsSegmenter();
  break;
case HlsLiveStreamType.AAC:
tsSegmenter=new AacTsSegmenter();
break;
case HlsLiveStreamType.YUV:
tsSegmenter=new H264TranscodingTsSegmenter();
break;
case HlsLiveStreamType.H264:
tsSegmenter=new H264TsSegmenter();
break;
case HlsLiveStreamType.AAC_H264_MIXED:
tsSegmenter=new AacH264MixedTsSegmenter();
break;
}
tsSegmenter.initialize(sampleRate,sampleSizeInBits,channels,fps);
}"
70564,"public void startup(){
  scheduledExecutor.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      List<Long> expiredStreamIds=new ArrayList<>();
      long now=System.currentTimeMillis();
      for (      HlsLiveStream hlsLiveStream : streamIdToLiveStreamCache.values()) {
        if (now - hlsLiveStream.getMtime() > LIVE_STREAM_TIMEOUT_MS) {
          hlsLiveStream.close();
          expiredStreamIds.add(hlsLiveStream.getStreamId());
        }
 else {
          Map<String,HlsClientSession> clientSessions=hlsLiveStream.getAllClientSession();
          for (          String sessionId : clientSessions.keySet()) {
            HlsClientSession clientSession=clientSessions.get(sessionId);
            if (now - clientSession.getMtime() > SESSION_TIMEOUT_MS) {
              hlsLiveStream.removeClientSessionById(sessionId);
            }
          }
        }
      }
      for (      Long tmpStreamId : expiredStreamIds) {
        streamIdToLiveStreamCache.remove(tmpStreamId);
        Iterator<Long> iter=aliasToStreamIdCache.values().iterator();
        while (iter.hasNext()) {
          if (tmpStreamId == iter.next())           iter.remove();
        }
        streamIdToVolumeControlCache.remove(tmpStreamId);
      }
    }
  }
,10,10,TimeUnit.SECONDS);
}","public void startup(){
  scheduledExecutor.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      List<Long> expiredStreamIds=new ArrayList<>();
      long now=System.currentTimeMillis();
      for (      HlsLiveStream hlsLiveStream : streamIdToLiveStreamCache.values()) {
        if (now - hlsLiveStream.getMtime() > LIVE_STREAM_TIMEOUT_MS) {
          hlsLiveStream.close();
          expiredStreamIds.add(hlsLiveStream.getStreamId());
        }
 else {
          hlsLiveStream.removeTimeoutSessionAndTsSegments(now,SESSION_TIMEOUT_MS);
        }
      }
      for (      Long tmpStreamId : expiredStreamIds) {
        streamIdToLiveStreamCache.remove(tmpStreamId);
        Iterator<Long> iter=aliasToStreamIdCache.values().iterator();
        while (iter.hasNext()) {
          if (tmpStreamId == iter.next())           iter.remove();
        }
        streamIdToVolumeControlCache.remove(tmpStreamId);
      }
    }
  }
,10,10,TimeUnit.SECONDS);
}"
70565,"@Override public void execute(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  HttpRequest request=(DefaultHttpRequest)e.getMessage();
  String uri=request.getUri();
  String path=uri.split(""String_Node_Str"")[0].trim();
  String[] pathArray=path.split(""String_Node_Str"");
  String alias=pathArray[2];
  String requestFile=pathArray[3];
  if (alias == null || requestFile == null) {
    HttpUtil.sendError(ctx,HttpResponseStatus.NOT_FOUND);
    return;
  }
  HlsLiveStream liveStream=HlsLiveStreamMagr.INSTANCE().getHlsLiveStreamByAlias(alias);
  if (liveStream == null) {
    HttpUtil.sendError(ctx,HttpResponseStatus.NOT_FOUND);
    return;
  }
  if (requestFile.equals(LIVE_M3U8)) {
    HlsClientSession clientSession=null;
    QueryStringDecoder decoder=new QueryStringDecoder(request.getUri());
    List<String> sessionId=decoder.getParameters().get(""String_Node_Str"");
    if (sessionId != null && !sessionId.isEmpty()) {
      clientSession=liveStream.getClientSessionsById(sessionId.get(0));
    }
    LOGGER.info(""String_Node_Str"",uri,clientSession);
    if (clientSession == null) {
      clientSession=liveStream.newClientSession();
      StringBuffer url=new StringBuffer(50);
      url.append(path).append(""String_Node_Str"").append(clientSession.getId());
      LOGGER.info(""String_Node_Str"",url.toString());
      HttpResponse response=HttpUtil.redirectFound(url.toString());
      e.getChannel().write(response);
      return;
    }
    M3U8 m3u8=clientSession.getM3u8File(requestFile);
    DefaultHttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);
    byte[] content=m3u8.getBuf();
    long fileMTime=m3u8.getTime();
    response.headers().add(HttpHeaders.Names.SERVER,Versions.SERVER_VERSION);
    response.headers().add(HttpHeaders.Names.DATE,HttpUtil.getDateString(fileMTime));
    response.headers().add(HttpHeaders.Names.CONTENT_TYPE,HttpUtil.getMimeType(requestFile));
    response.headers().add(HttpHeaders.Names.CONTENT_LENGTH,content.length);
    response.headers().add(HttpHeaders.Names.CACHE_CONTROL,""String_Node_Str"");
    response.setContent(ChannelBuffers.copiedBuffer(content));
    e.getChannel().write(response);
  }
 else {
    LOGGER.info(""String_Node_Str"",uri);
    int tsIndex=Integer.valueOf(requestFile.substring(0,requestFile.indexOf(""String_Node_Str""))).intValue();
    String ifModifiedSince=request.headers().get(HttpHeaders.Names.IF_MODIFIED_SINCE);
    if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
      SimpleDateFormat dateFormatter=new SimpleDateFormat(HttpUtil.HTTP_DATE_FORMAT,Locale.US);
      Date mdate=dateFormatter.parse(ifModifiedSince);
      int mdateSec=(int)(mdate.getTime() / 1000L);
      TsSegment tsSegment=liveStream.fetchTsSegment(tsIndex);
      int fileMTimeSec=tsSegment != null ? (int)(tsSegment.getCtime() / 1000L) : 0;
      if (mdateSec == fileMTimeSec) {
        HttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.NOT_MODIFIED);
        response.headers().add(HttpHeaders.Names.CACHE_CONTROL,""String_Node_Str"");
        HttpUtil.sendNotModified(ctx,response);
        return;
      }
    }
    TsSegment tsSegment=liveStream.fetchTsSegment(tsIndex);
    if (tsSegment == null) {
      HttpUtil.sendError(ctx,HttpResponseStatus.NOT_FOUND);
      return;
    }
    DefaultHttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);
    byte[] content=tsSegment.getData();
    long fileMTime=tsSegment.getCtime();
    response.headers().add(HttpHeaders.Names.SERVER,Versions.SERVER_VERSION);
    response.headers().add(HttpHeaders.Names.DATE,HttpUtil.getDateString(fileMTime));
    response.headers().add(HttpHeaders.Names.CONTENT_TYPE,HttpUtil.getMimeType(requestFile));
    response.headers().add(HttpHeaders.Names.CONTENT_LENGTH,content.length);
    response.headers().add(HttpHeaders.Names.LAST_MODIFIED,HttpUtil.getDateString(fileMTime));
    response.headers().add(HttpHeaders.Names.EXPIRES,HttpUtil.getDateString(fileMTime + LIVE_CACHE_TIME));
    response.headers().add(HttpHeaders.Names.CACHE_CONTROL,""String_Node_Str"" + (LIVE_CACHE_TIME / 1000));
    response.setContent(ChannelBuffers.copiedBuffer(content));
    e.getChannel().write(response);
  }
}","@Override public void execute(ChannelHandlerContext ctx,MessageEvent e) throws Exception {
  HttpRequest request=(DefaultHttpRequest)e.getMessage();
  String uri=request.getUri();
  String path=uri.split(""String_Node_Str"")[0].trim();
  String[] pathArray=path.split(""String_Node_Str"");
  String alias=pathArray[2];
  String requestFile=pathArray[3];
  if (alias == null || requestFile == null) {
    HttpUtil.sendError(ctx,HttpResponseStatus.NOT_FOUND);
    return;
  }
  HlsLiveStream liveStream=HlsLiveStreamMagr.INSTANCE().getHlsLiveStreamByAlias(alias);
  if (liveStream == null) {
    HttpUtil.sendError(ctx,HttpResponseStatus.NOT_FOUND);
    return;
  }
  if (requestFile.equals(LIVE_M3U8)) {
    HlsClientSession clientSession=null;
    QueryStringDecoder decoder=new QueryStringDecoder(request.getUri());
    List<String> sessionId=decoder.getParameters().get(""String_Node_Str"");
    if (sessionId != null && !sessionId.isEmpty()) {
      clientSession=liveStream.getClientSessionsById(sessionId.get(0));
    }
    LOGGER.info(""String_Node_Str"",uri,clientSession);
    if (clientSession == null) {
      clientSession=liveStream.newClientSession();
      StringBuffer url=new StringBuffer(50);
      url.append(path).append(""String_Node_Str"").append(clientSession.getId());
      LOGGER.info(""String_Node_Str"",url.toString());
      HttpResponse response=HttpUtil.redirectFound(url.toString());
      e.getChannel().write(response);
      return;
    }
    M3U8 m3u8=clientSession.getM3u8File(requestFile);
    DefaultHttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);
    byte[] content=m3u8.getBuf();
    long fileMTime=m3u8.getTime();
    response.headers().add(HttpHeaders.Names.SERVER,Versions.SERVER_VERSION);
    response.headers().add(HttpHeaders.Names.DATE,HttpUtil.getDateString(fileMTime));
    response.headers().add(HttpHeaders.Names.CONTENT_TYPE,HttpUtil.getMimeType(requestFile));
    response.headers().add(HttpHeaders.Names.CONTENT_LENGTH,content.length);
    response.headers().add(HttpHeaders.Names.CACHE_CONTROL,""String_Node_Str"");
    response.setContent(ChannelBuffers.copiedBuffer(content));
    e.getChannel().write(response);
  }
 else {
    LOGGER.info(""String_Node_Str"",uri);
    int tsIndex=Integer.valueOf(requestFile.substring(0,requestFile.indexOf(""String_Node_Str""))).intValue();
    String ifModifiedSince=request.headers().get(HttpHeaders.Names.IF_MODIFIED_SINCE);
    if (ifModifiedSince != null && !ifModifiedSince.isEmpty()) {
      SimpleDateFormat dateFormatter=new SimpleDateFormat(HttpUtil.HTTP_DATE_FORMAT,Locale.US);
      Date mdate=dateFormatter.parse(ifModifiedSince);
      int mdateSec=(int)(mdate.getTime() / 1000L);
      TsSegment tsSegment=liveStream.fetchTsSegmentByIndex(tsIndex);
      int fileMTimeSec=tsSegment != null ? (int)(tsSegment.getCtime() / 1000L) : 0;
      if (mdateSec == fileMTimeSec) {
        HttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.NOT_MODIFIED);
        response.headers().add(HttpHeaders.Names.CACHE_CONTROL,""String_Node_Str"");
        HttpUtil.sendNotModified(ctx,response);
        return;
      }
    }
    TsSegment tsSegment=liveStream.fetchTsSegmentByIndex(tsIndex);
    if (tsSegment == null) {
      HttpUtil.sendError(ctx,HttpResponseStatus.NOT_FOUND);
      return;
    }
    DefaultHttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);
    byte[] content=tsSegment.getData();
    long fileMTime=tsSegment.getCtime();
    response.headers().add(HttpHeaders.Names.SERVER,Versions.SERVER_VERSION);
    response.headers().add(HttpHeaders.Names.DATE,HttpUtil.getDateString(fileMTime));
    response.headers().add(HttpHeaders.Names.CONTENT_TYPE,HttpUtil.getMimeType(requestFile));
    response.headers().add(HttpHeaders.Names.CONTENT_LENGTH,content.length);
    response.headers().add(HttpHeaders.Names.LAST_MODIFIED,HttpUtil.getDateString(fileMTime));
    response.headers().add(HttpHeaders.Names.EXPIRES,HttpUtil.getDateString(fileMTime + LIVE_CACHE_TIME));
    response.headers().add(HttpHeaders.Names.CACHE_CONTROL,""String_Node_Str"" + (LIVE_CACHE_TIME / 1000));
    response.setContent(ChannelBuffers.copiedBuffer(content));
    e.getChannel().write(response);
  }
}"
70566,"public void startup(){
  scheduledExecutor.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      List<Long> expiredStreamIds=new ArrayList<>();
      long now=System.currentTimeMillis();
      for (      HlsLiveStream hlsLiveStream : streamIdToLiveStreamCache.values()) {
        if (now - hlsLiveStream.getMtime() > LIVE_STREAM_TIMEOUT_MS) {
          hlsLiveStream.close();
          expiredStreamIds.add(hlsLiveStream.getStreamId());
        }
 else {
          hlsLiveStream.removeTimeoutSessionAndTsSegments(now,SESSION_TIMEOUT_MS);
        }
      }
      for (      Long tmpStreamId : expiredStreamIds) {
        streamIdToLiveStreamCache.remove(tmpStreamId);
        Iterator<Long> iter=aliasToStreamIdCache.values().iterator();
        while (iter.hasNext()) {
          if (tmpStreamId == iter.next())           iter.remove();
        }
        streamIdToVolumeControlCache.remove(tmpStreamId);
      }
    }
  }
,10,10,TimeUnit.SECONDS);
}","public void startup(){
  scheduledExecutor.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      try {
        long now=System.currentTimeMillis();
        for (        HlsLiveStream liveStream : streamIdToLiveStreamCache.values()) {
          if (now - liveStream.getMtime() > LIVE_STREAM_TIMEOUT_MS) {
            long streamId=liveStream.getStreamId();
            streamIdToLiveStreamCache.remove(streamId);
            Iterator<Long> iter=aliasToStreamIdCache.values().iterator();
            while (iter.hasNext()) {
              if (streamId == iter.next())               iter.remove();
            }
            streamIdToVolumeControlCache.remove(streamId);
            liveStream.close();
          }
 else {
            liveStream.removeTimeoutClientSessionAndTsSegments(now,SESSION_TIMEOUT_MS);
          }
        }
      }
 catch (      Throwable e) {
        LOGGER.warn(""String_Node_Str"",e);
      }
    }
  }
,10,10,TimeUnit.SECONDS);
}"
70567,"public byte[] write(boolean isFirstPes,FrameDataType frameDataType,FrameData... frames){
  byte[] tsFileBuffer=null;
  byte[] patTsBuf=write_pat();
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,patTsBuf);
  byte[] pmtTsBuf=write_pmt(frameDataType);
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,pmtTsBuf);
  for (  FrameData frame : frames) {
    boolean isFristTs=true;
    boolean isAudio=frame.isAudio;
    long pts=frame.pts;
    long dts=frame.dts;
    byte[] frameBuf=frame.buf;
    int frameBufSize=frameBuf.length;
    int frameBufPtr=0;
    int pid=isAudio ? TS_AUDIO_PID : TS_VIDEO_PID;
    while (frameBufPtr < frameBufSize) {
      int frameBufRemaining=frameBufSize - frameBufPtr;
      boolean isAdaptationField=(isFristTs || (frameBufRemaining < TS_PAYLOAD_SIZE)) ? true : false;
      byte[] tsBuf=new byte[TS_PACKET_SIZE];
      int offset=0;
      tsBuf[offset++]=0x47;
      tsBuf[offset++]=(byte)((isFristTs ? 0x40 : 0x00) | ((pid >> 8) & 0x1f));
      tsBuf[offset++]=(byte)(pid & 0xff);
      tsBuf[offset++]=(byte)((isAdaptationField ? 0x30 : 0x10) | ((isAudio ? mAudioContinuityCounter++ : mVideoContinuityCounter++) & 0xF));
      if (isFristTs) {
        tsBuf[offset++]=0x07;
        tsBuf[offset++]|=isFirstPes ? 0x50 : (isAudio ? 0x05 : 0x10);
        long pcr=pts;
        tsBuf[offset++]=(byte)((pcr >> 25) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 17) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 9) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 1) & 0xFF);
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x01;
        tsBuf[offset++]=isAudio ? (byte)0xc0 : (byte)0xe0;
        int header_size=5 + 5;
        if (isAudio) {
          int pes_size=frameBufSize + header_size + 3;
          tsBuf[offset++]=(byte)((pes_size >> 8) & 0xFF);
          tsBuf[offset++]=(byte)(pes_size & 0xFF);
        }
 else {
          tsBuf[offset++]=0x00;
          tsBuf[offset++]=0x00;
        }
        tsBuf[offset++]=(byte)0x80;
        tsBuf[offset++]=(byte)0xc0;
        tsBuf[offset++]=(byte)header_size;
        tsBuf[offset++]=(byte)(((pts >> 30) & 0xFE) | 0x31);
        tsBuf[offset++]=(byte)((pts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((pts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((pts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((pts << 1) & 0xFE | 0x01);
        tsBuf[offset++]=(byte)(((dts >> 29) & 0xFE) | 0x11);
        tsBuf[offset++]=(byte)((dts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((dts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((dts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((dts << 1) & 0xFE | 0x01);
        if (!isAudio && Bytes.indexOf(frameBuf,H264_NAL) == -1) {
          System.arraycopy(H264_NAL,0,tsBuf,offset++,H264_NAL.length);
          offset+=H264_NAL.length;
        }
      }
 else {
        if (isAdaptationField) {
          tsBuf[offset++]=1;
          tsBuf[offset++]=(byte)0x00;
        }
 else {
        }
      }
      int tsBufRemaining=TS_PACKET_SIZE - offset;
      if (frameBufRemaining >= tsBufRemaining) {
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,offset,tsBufRemaining);
        offset+=tsBufRemaining;
        frameBufPtr+=tsBufRemaining;
      }
 else {
        int paddingSize=tsBufRemaining - frameBufRemaining;
        if (isAdaptationField) {
          int adaptationFieldLength=(tsBuf[4] & 0xFF);
          int start=TS_HEADER_SIZE + adaptationFieldLength + 1;
          int end=offset - 1;
          for (int i=end; i >= start; i--) {
            tsBuf[i + paddingSize]=tsBuf[i];
          }
          for (int i=0; i < paddingSize; i++) {
            tsBuf[start + i]=(byte)0xff;
          }
          tsBuf[4]+=paddingSize;
        }
 else {
          tsBuf[3]|=0x20;
          tsBuf[4]=(byte)paddingSize;
          tsBuf[5]=0;
          for (int i=0; i < paddingSize; i++) {
            tsBuf[6 + i]=(byte)0xFF;
          }
        }
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,(int)(offset + paddingSize),frameBufRemaining);
        frameBufPtr+=frameBufRemaining;
      }
      isFristTs=false;
      tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,tsBuf);
    }
  }
  return tsFileBuffer;
}","public byte[] write(boolean isFirstPes,FrameDataType frameDataType,FrameData... frames){
  byte[] tsFileBuffer=null;
  byte[] patTsBuf=write_pat();
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,patTsBuf);
  byte[] pmtTsBuf=write_pmt(frameDataType);
  tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,pmtTsBuf);
  for (  FrameData frame : frames) {
    boolean isFristTs=true;
    boolean isAudio=frame.isAudio;
    long pts=frame.pts;
    long dts=frame.dts;
    byte[] frameBuf=frame.buf;
    int frameBufSize=frameBuf.length;
    int frameBufPtr=0;
    int pid=isAudio ? TS_AUDIO_PID : TS_VIDEO_PID;
    while (frameBufPtr < frameBufSize) {
      int frameBufRemaining=frameBufSize - frameBufPtr;
      boolean isAdaptationField=(isFristTs || (frameBufRemaining < TS_PAYLOAD_SIZE)) ? true : false;
      byte[] tsBuf=new byte[TS_PACKET_SIZE];
      int offset=0;
      tsBuf[offset++]=0x47;
      tsBuf[offset++]=(byte)((isFristTs ? 0x40 : 0x00) | ((pid >> 8) & 0x1f));
      tsBuf[offset++]=(byte)(pid & 0xff);
      tsBuf[offset++]=(byte)((isAdaptationField ? 0x30 : 0x10) | ((isAudio ? mAudioContinuityCounter++ : mVideoContinuityCounter++) & 0xF));
      if (isFristTs) {
        tsBuf[offset++]=0x07;
        tsBuf[offset++]|=isFirstPes ? 0x50 : (isAudio ? 0x50 : 0x10);
        long pcr=pts;
        tsBuf[offset++]=(byte)((pcr >> 25) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 17) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 9) & 0xFF);
        tsBuf[offset++]=(byte)((pcr >> 1) & 0xFF);
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x00;
        tsBuf[offset++]=0x01;
        tsBuf[offset++]=isAudio ? (byte)0xc0 : (byte)0xe0;
        int header_size=5 + 5;
        if (isAudio) {
          int pes_size=frameBufSize + header_size + 3;
          tsBuf[offset++]=(byte)((pes_size >> 8) & 0xFF);
          tsBuf[offset++]=(byte)(pes_size & 0xFF);
        }
 else {
          tsBuf[offset++]=0x00;
          tsBuf[offset++]=0x00;
        }
        tsBuf[offset++]=(byte)0x80;
        tsBuf[offset++]=(byte)0xc0;
        tsBuf[offset++]=(byte)header_size;
        tsBuf[offset++]=(byte)(((pts >> 30) & 0xFE) | 0x31);
        tsBuf[offset++]=(byte)((pts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((pts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((pts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((pts << 1) & 0xFE | 0x01);
        tsBuf[offset++]=(byte)(((dts >> 29) & 0xFE) | 0x11);
        tsBuf[offset++]=(byte)((dts >> 22) & 0xff);
        tsBuf[offset++]=(byte)(((dts >> 14) & 0xFE) | 0x01);
        tsBuf[offset++]=(byte)((dts >> 7) & 0xff);
        tsBuf[offset++]=(byte)((dts << 1) & 0xFE | 0x01);
        if (!isAudio && Bytes.indexOf(frameBuf,H264_NAL) == -1) {
          System.arraycopy(H264_NAL,0,tsBuf,offset++,H264_NAL.length);
          offset+=H264_NAL.length;
        }
      }
 else {
        if (isAdaptationField) {
          tsBuf[offset++]=1;
          tsBuf[offset++]=(byte)0x00;
        }
 else {
        }
      }
      int tsBufRemaining=TS_PACKET_SIZE - offset;
      if (frameBufRemaining >= tsBufRemaining) {
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,offset,tsBufRemaining);
        offset+=tsBufRemaining;
        frameBufPtr+=tsBufRemaining;
      }
 else {
        int paddingSize=tsBufRemaining - frameBufRemaining;
        if (isAdaptationField) {
          int adaptationFieldLength=(tsBuf[4] & 0xFF);
          int start=TS_HEADER_SIZE + adaptationFieldLength + 1;
          int end=offset - 1;
          for (int i=end; i >= start; i--) {
            tsBuf[i + paddingSize]=tsBuf[i];
          }
          for (int i=0; i < paddingSize; i++) {
            tsBuf[start + i]=(byte)0xff;
          }
          tsBuf[4]+=paddingSize;
        }
 else {
          tsBuf[3]|=0x20;
          tsBuf[4]=(byte)paddingSize;
          tsBuf[5]=0;
          for (int i=0; i < paddingSize; i++) {
            tsBuf[6 + i]=(byte)0xFF;
          }
        }
        System.arraycopy(frameBuf,frameBufPtr,tsBuf,(int)(offset + paddingSize),frameBufRemaining);
        frameBufPtr+=frameBufRemaining;
      }
      isFristTs=false;
      tsFileBuffer=TsUtil.margeByteArray(tsFileBuffer,tsBuf);
    }
  }
  return tsFileBuffer;
}"
70568,"@Override protected void onProgressUpdate(Integer... values){
  super.onProgressUpdate(values);
  if (UserPreferences.getStoredLanguage(mContext).equals(""String_Node_Str"")) {
    mProgressInfo.setText(""String_Node_Str"" + ""String_Node_Str"" + mSupportedCountryLab.getSupportedCountries().get(mProgressBar.getProgress()).getName() + ""String_Node_Str""+ mContext.getString(R.string.getting_price_from));
  }
 else {
    mProgressInfo.setText(mContext.getString(R.string.getting_price_from) + ""String_Node_Str"" + mSupportedCountryLab.getSupportedCountries().get(mProgressBar.getProgress()).getName());
  }
  mProgressBar.setProgress(mProgressBar.getProgress() + 1);
}","@Override protected void onProgressUpdate(Integer... values){
  super.onProgressUpdate(values);
  mProgressBar.setMax(mCountries.size());
  if (UserPreferences.getStoredLanguage(mContext).equals(""String_Node_Str"")) {
    mProgressInfo.setText(""String_Node_Str"" + ""String_Node_Str"" + mCountries.get(mProgressBar.getProgress()).getName() + ""String_Node_Str""+ mContext.getString(R.string.getting_price_from));
  }
 else {
    mProgressInfo.setText(mContext.getString(R.string.getting_price_from) + ""String_Node_Str"" + mCountries.get(mProgressBar.getProgress()).getName());
  }
  mProgressBar.setProgress(mProgressBar.getProgress() + 1);
}"
70569,"@Override protected Integer doInBackground(Game... params){
  mGame=params[0];
  if (mGame.getGameCode() == null) {
    return TYPE_FAILED;
  }
  HashMap<String,Double> ratesMap=mGameLab.mRatesMap;
  List<SupportedCountry> supportedCountryList=mSupportedCountryLab.getSupportedCountries();
  List<SupportedCountry> usCountryList=new ArrayList<>();
  List<SupportedCountry> euCountryList=new ArrayList<>();
  List<SupportedCountry> jpCountryList=new ArrayList<>();
  for (  SupportedCountry supportedCountry : supportedCountryList) {
switch (supportedCountry.getBelong()) {
case ""String_Node_Str"":
      usCountryList.add(supportedCountry);
    break;
case ""String_Node_Str"":
  euCountryList.add(supportedCountry);
break;
default :
jpCountryList.add(supportedCountry);
break;
}
}
String usNsuid=mGame.getUsNsUid();
String euNsuid=mGame.getEuNsUid();
String jpNsuid=mGame.getJpNsUid();
List<HttpUrl> httpUrls=new ArrayList<>();
if (usNsuid != null) {
for (SupportedCountry country : usCountryList) {
HttpUrl url=buildHttpUrl(country.getCode(),usNsuid);
httpUrls.add(url);
}
}
if (euNsuid != null) {
for (SupportedCountry country : euCountryList) {
HttpUrl url=buildHttpUrl(country.getCode(),euNsuid);
httpUrls.add(url);
}
}
if (jpNsuid != null) {
for (SupportedCountry country : jpCountryList) {
HttpUrl url=buildHttpUrl(country.getCode(),jpNsuid);
httpUrls.add(url);
}
}
List<Price> priceList=queryPrice(httpUrls);
if (priceList == null || priceList.size() == 0) {
return TYPE_FAILED;
}
for (Price price : priceList) {
String currency=price.getCurrency();
double rates=ratesMap.get(currency);
if (price.getDiscountPrice() != null) {
price.setDiscount(String.valueOf(String.format(""String_Node_Str"",(1 - Double.parseDouble(price.getDiscountPrice()) / Double.parseDouble(price.getPrice())) * 100)) + ""String_Node_Str"");
price.setDiscountPriceByCurrency(String.valueOf(String.format(""String_Node_Str"",Double.parseDouble(price.getDiscountPrice()) / rates)));
}
price.setPriceByCurrency(String.valueOf(String.format(""String_Node_Str"",Double.parseDouble(price.getPrice()) / rates)));
}
Collections.sort(priceList,new Comparator<Price>(){
public int compare(Price arg0,Price arg1){
if (arg0.getDiscountPriceByCurrency() != null) {
if (arg1.getDiscountPriceByCurrency() != null) {
return arg0.getDiscountPriceByCurrency().compareTo(arg1.getDiscountPriceByCurrency());
}
 else {
return arg0.getDiscountPriceByCurrency().compareTo(arg1.getPriceByCurrency());
}
}
 else {
if (arg1.getDiscountPriceByCurrency() != null) {
return arg0.getPriceByCurrency().compareTo(arg1.getDiscountPriceByCurrency());
}
 else {
return arg0.getPriceByCurrency().compareTo(arg1.getPriceByCurrency());
}
}
}
}
);
Price price=priceList.get(0);
price.setCountryName(mSupportedCountryLab.getSupportedCountry(price.getCountryCode()).getName());
mGame.setPrice(price);
return TYPE_SUCCESS;
}","@Override protected Integer doInBackground(Game... params){
  mGame=params[0];
  if (mGame.getGameCode() == null) {
    return TYPE_FAILED;
  }
  HashMap<String,Double> ratesMap=mGameLab.mRatesMap;
  List<SupportedCountry> supportedCountryList=mSupportedCountryLab.getSupportedCountries();
  List<SupportedCountry> usCountryList=new ArrayList<>();
  List<SupportedCountry> euCountryList=new ArrayList<>();
  List<SupportedCountry> jpCountryList=new ArrayList<>();
  for (  SupportedCountry supportedCountry : supportedCountryList) {
switch (supportedCountry.getBelong()) {
case ""String_Node_Str"":
      usCountryList.add(supportedCountry);
    break;
case ""String_Node_Str"":
  euCountryList.add(supportedCountry);
break;
default :
jpCountryList.add(supportedCountry);
break;
}
}
mCountries.addAll(usCountryList);
mCountries.addAll(euCountryList);
mCountries.addAll(jpCountryList);
String usNsuid=mGame.getUsNsUid();
String euNsuid=mGame.getEuNsUid();
String jpNsuid=mGame.getJpNsUid();
List<HttpUrl> httpUrls=new ArrayList<>();
if (usNsuid != null) {
for (SupportedCountry country : usCountryList) {
HttpUrl url=buildHttpUrl(country.getCode(),usNsuid);
httpUrls.add(url);
}
}
if (euNsuid != null) {
for (SupportedCountry country : euCountryList) {
HttpUrl url=buildHttpUrl(country.getCode(),euNsuid);
httpUrls.add(url);
}
}
if (jpNsuid != null) {
for (SupportedCountry country : jpCountryList) {
HttpUrl url=buildHttpUrl(country.getCode(),jpNsuid);
httpUrls.add(url);
}
}
List<Price> priceList=queryPrice(httpUrls);
if (priceList == null || priceList.size() == 0) {
return TYPE_FAILED;
}
Iterator<Price> iterator=priceList.iterator();
while (iterator.hasNext()) {
Price price=iterator.next();
String currency=price.getCurrency();
if (currency == null) {
iterator.remove();
}
 else {
double rates=ratesMap.get(currency);
if (price.getDiscountPrice() != null) {
price.setDiscount(String.valueOf(String.format(""String_Node_Str"",(1 - Double.parseDouble(price.getDiscountPrice()) / Double.parseDouble(price.getPrice())) * 100)) + ""String_Node_Str"");
price.setDiscountPriceByCurrency(String.valueOf(String.format(""String_Node_Str"",Double.parseDouble(price.getDiscountPrice()) / rates)));
}
price.setPriceByCurrency(String.valueOf(String.format(""String_Node_Str"",Double.parseDouble(price.getPrice()) / rates)));
}
}
Collections.sort(priceList,new Comparator<Price>(){
public int compare(Price arg0,Price arg1){
if (arg0.getDiscountPriceByCurrency() != null) {
if (arg1.getDiscountPriceByCurrency() != null) {
return arg0.getDiscountPriceByCurrency().compareTo(arg1.getDiscountPriceByCurrency());
}
 else {
return arg0.getDiscountPriceByCurrency().compareTo(arg1.getPriceByCurrency());
}
}
 else {
if (arg1.getDiscountPriceByCurrency() != null) {
return arg0.getPriceByCurrency().compareTo(arg1.getDiscountPriceByCurrency());
}
 else {
return arg0.getPriceByCurrency().compareTo(arg1.getPriceByCurrency());
}
}
}
}
);
Price price=priceList.get(0);
price.setCountryName(mSupportedCountryLab.getSupportedCountry(price.getCountryCode()).getName());
mGame.setPrice(price);
return TYPE_SUCCESS;
}"
70570,"private Price parsePriceJsonData(String jsonData){
  Price price=new Price();
  try {
    JSONObject jsonObject=new JSONObject(jsonData);
    JSONArray pricesArray=jsonObject.getJSONArray(""String_Node_Str"");
    JSONObject priceObject=pricesArray.getJSONObject(0);
    if (priceObject.getString(""String_Node_Str"").equals(""String_Node_Str"") || priceObject.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
      JSONObject regularPriceObject=priceObject.getJSONObject(""String_Node_Str"");
      price.setPrice(regularPriceObject.getString(""String_Node_Str""));
      price.setCountryCode(jsonObject.getString(""String_Node_Str""));
      price.setCurrency(regularPriceObject.getString(""String_Node_Str""));
      if (priceObject.has(""String_Node_Str"")) {
        JSONObject discountPriceObject=priceObject.getJSONObject(""String_Node_Str"");
        price.setDiscountPrice(discountPriceObject.getString(""String_Node_Str""));
        price.setStartTime(DateFormatter.ParseStringToDate(discountPriceObject.getString(""String_Node_Str"")));
        price.setEndTime(DateFormatter.ParseStringToDate(discountPriceObject.getString(""String_Node_Str"")));
      }
    }
 else {
      return null;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return price;
}","private Price parsePriceJsonData(String jsonData){
  Price price=new Price();
  try {
    JSONObject jsonObject=new JSONObject(jsonData);
    JSONArray pricesArray=jsonObject.getJSONArray(""String_Node_Str"");
    JSONObject priceObject=pricesArray.getJSONObject(0);
    if (priceObject.has(""String_Node_Str"")) {
      JSONObject regularPriceObject=priceObject.getJSONObject(""String_Node_Str"");
      price.setPrice(regularPriceObject.getString(""String_Node_Str""));
      price.setCountryCode(jsonObject.getString(""String_Node_Str""));
      price.setCurrency(regularPriceObject.getString(""String_Node_Str""));
      if (priceObject.has(""String_Node_Str"")) {
        JSONObject discountPriceObject=priceObject.getJSONObject(""String_Node_Str"");
        price.setDiscountPrice(discountPriceObject.getString(""String_Node_Str""));
        price.setStartTime(DateFormatter.ParseStringToDate(discountPriceObject.getString(""String_Node_Str"")));
        price.setEndTime(DateFormatter.ParseStringToDate(discountPriceObject.getString(""String_Node_Str"")));
      }
    }
 else {
      return null;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return price;
}"
70571,"public static String ParseDateToString(Date date,Locale locale){
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"",locale);
  return dateFormat.format(date);
}","public static String ParseDateToString(Date date,Locale locale,Context context){
  SimpleDateFormat dateFormat;
  if (UserPreferences.getStoredLanguage(context).equals(""String_Node_Str"")) {
    dateFormat=new SimpleDateFormat(""String_Node_Str"",locale);
  }
 else {
    dateFormat=new SimpleDateFormat(""String_Node_Str"",locale);
  }
  return dateFormat.format(date);
}"
70572,"public List<Game> getNewGames(){
  List<Game> games=getGames();
  List<Game> newGames=new ArrayList<>();
  List<Date> dates=new ArrayList<>();
  for (  Game game : games) {
    Date date=game.getReleaseDate();
    dates.add(date);
  }
  Date currentDate=Calendar.getInstance(Locale.US).getTime();
  for (int i=0; i < dates.size(); i++) {
    if (dates.get(i).after(currentDate)) {
      newGames.add(games.get(i));
    }
  }
  return newGames;
}","public List<Game> getNewGames(){
  List<Game> games=getGames();
  List<Game> newGames=new ArrayList<>();
  List<Date> dates=new ArrayList<>();
  for (  Game game : games) {
    Date date=game.getReleaseDate();
    dates.add(date);
  }
  Date currentDate=Calendar.getInstance(Locale.US).getTime();
  for (int i=0; i < dates.size(); i++) {
    if (dates.get(i) != null && dates.get(i).after(currentDate)) {
      newGames.add(games.get(i));
    }
  }
  return newGames;
}"
70573,"private javax.swing.JToolBar buildToolBar(){
  panelToolbar=new javax.swing.JToolBar();
  panelToolbar.setLayout(new java.awt.GridBagLayout());
  panelToolbar.setEnabled(true);
  panelToolbar.setFloatable(false);
  panelToolbar.setRollover(true);
  panelToolbar.setPreferredSize(new java.awt.Dimension(1000,30));
  panelToolbar.setFont(new java.awt.Font(""String_Node_Str"",java.awt.Font.PLAIN,12));
  panelToolbar.setName(""String_Node_Str"");
  viewSelectedButton=new JButton(""String_Node_Str"");
  viewSelectedButton.setEnabled(false);
  ZapPropertiesManager.INSTANCE.setViewSelectedButton(viewSelectedButton);
  JButton optionsButton=new JButton(""String_Node_Str"");
  JButton importFromSourceButton=new JButton(""String_Node_Str"");
  importFromSourceButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      boolean configured=OptionsDialog.ValidateSource(view);
      boolean completed=false;
      viewSelectedButton.setEnabled(false);
      ZapPropertiesManager.INSTANCE.setEndpointDecorator(null);
      if (configured) {
        try {
          EndpointDecorator[] endpoints=getEndpointsFromSource(ZapPropertiesManager.INSTANCE.getSourceFolder());
          EndpointDecorator comparePoints[]=null;
          String oldSourceFolder=ZapPropertiesManager.INSTANCE.getOldSourceFolder();
          if (oldSourceFolder != null && !oldSourceFolder.isEmpty())           comparePoints=getEndpointsFromSource(oldSourceFolder);
          if ((endpoints == null) || (endpoints.length == 0))           view.showWarningDialog(""String_Node_Str"");
 else {
            if (comparePoints != null && comparePoints.length != 0)             endpoints=compareEndpoints(endpoints,comparePoints,view);
            fillEndpointsToTable(endpoints);
            buildNodesFromEndpoints(endpoints);
            String url=ZapPropertiesManager.INSTANCE.getTargetUrl();
            if (url != null) {
              completed=attackUrl(url,view);
              if (!completed)               view.showWarningDialog(""String_Node_Str"");
            }
 else             view.showMessageDialog(""String_Node_Str"");
          }
        }
 catch (        Exception ex) {
          LOGGER.debug(ex.getStackTrace());
          JOptionPane.showMessageDialog(view.getMainFrame(),""String_Node_Str"");
        }
      }
      if (completed)       view.showMessageDialog(""String_Node_Str"");
    }
  }
);
  JButton importFromJsonButton=new JButton(""String_Node_Str"");
  importFromJsonButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      boolean configured=OptionsDialog.ValidateJson(view);
      boolean completed=false;
      viewSelectedButton.setEnabled(false);
      ZapPropertiesManager.INSTANCE.setEndpointDecorator(null);
      if (configured) {
        try {
          EndpointDecorator[] endpoints=getEndpointsFromJson(ZapPropertiesManager.INSTANCE.getJsonFile());
          EndpointDecorator comparePoints[]=null;
          String oldJsonFile=ZapPropertiesManager.INSTANCE.getOldJsonFile();
          if (oldJsonFile != null && !oldJsonFile.isEmpty())           comparePoints=getEndpointsFromJson(oldJsonFile);
          if ((endpoints == null) || (endpoints.length == 0))           view.showWarningDialog(""String_Node_Str"");
 else {
            if (comparePoints != null && comparePoints.length != 0)             endpoints=compareEndpoints(endpoints,comparePoints,view);
            fillEndpointsToTable(endpoints);
            buildNodesFromEndpoints(endpoints);
            String url=ZapPropertiesManager.INSTANCE.getTargetUrl();
            if (url != null) {
              completed=attackUrl(url,view);
              if (!completed)               view.showWarningDialog(""String_Node_Str"");
            }
 else             view.showMessageDialog(""String_Node_Str"");
          }
        }
 catch (        Exception ex) {
          LOGGER.debug(ex.getStackTrace());
          JOptionPane.showMessageDialog(view.getMainFrame(),""String_Node_Str"");
        }
      }
      if (completed)       view.showMessageDialog(""String_Node_Str"");
    }
  }
);
  optionsButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      boolean shouldContinue=OptionsDialog.show(view);
    }
  }
);
  viewSelectedButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      JPanel detailPanel=new JPanel();
      detailPanel.setLayout(new GridBagLayout());
      JLabel displayArea=new JLabel();
      String displayStr=new String();
      int y=0;
      GridBagConstraints gridBagConstraints1=new GridBagConstraints();
      gridBagConstraints1.gridx=0;
      gridBagConstraints1.gridy=y++;
      gridBagConstraints1.weightx=1.0D;
      gridBagConstraints1.insets=new java.awt.Insets(4,4,4,4);
      gridBagConstraints1.fill=java.awt.GridBagConstraints.HORIZONTAL;
      gridBagConstraints1.anchor=java.awt.GridBagConstraints.NORTHWEST;
      EndpointDecorator decorator=ZapPropertiesManager.INSTANCE.getEndpointDecorator();
      Endpoint.Info endpoint=decorator.getEndpoint();
      if (endpoint != null) {
        if (decorator.getStatus() == EndpointDecorator.Status.NEW) {
          displayStr=""String_Node_Str"";
          displayStr=displayStr + ""String_Node_Str"";
        }
 else         displayStr=displayStr + ""String_Node_Str"";
        displayStr=displayStr + ""String_Node_Str"" + endpoint.getUrlPath()+ ""String_Node_Str"";
        if (endpoint.getHttpMethod().length() > 4)         displayStr=displayStr + endpoint.getHttpMethod().substring(14);
 else         displayStr=displayStr + endpoint.getHttpMethod();
        displayStr=displayStr + ""String_Node_Str"";
        if (decorator.getStatus() == EndpointDecorator.Status.CHANGED) {
          for (          Map.Entry<String,RouteParameter> parameter : endpoint.getParameters().entrySet()) {
            boolean found=false;
            for (            Map.Entry<String,RouteParameter> compParameter : decorator.getComparePoint().getParameters().entrySet()) {
              if (parameter.getKey().equalsIgnoreCase(compParameter.getKey())) {
                found=true;
                if (!parameter.getValue().getDataType().getDisplayName().equals(compParameter.getValue().getDataType().getDisplayName()))                 displayStr=displayStr + ""String_Node_Str"" + parameter.getKey()+ ""String_Node_Str""+ compParameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str"";
 else                 displayStr=displayStr + parameter.getKey() + ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName()+ ""String_Node_Str"";
                break;
              }
            }
            if (!found)             displayStr=displayStr + ""String_Node_Str"" + parameter.getKey()+ ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str"";
          }
          for (          Map.Entry<String,RouteParameter> compParameter : decorator.getComparePoint().getParameters().entrySet()) {
            boolean found=false;
            for (            Map.Entry<String,RouteParameter> parameter : endpoint.getParameters().entrySet()) {
              if (parameter.getKey().equalsIgnoreCase(compParameter.getKey())) {
                found=true;
                break;
              }
            }
            if (!found)             displayStr=displayStr + ""String_Node_Str"" + compParameter.getKey()+ ""String_Node_Str""+ compParameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str"";
          }
        }
 else {
          for (          Map.Entry<String,RouteParameter> parameter : endpoint.getParameters().entrySet()) {
            displayStr=displayStr + parameter.getKey() + ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName()+ ""String_Node_Str"";
          }
        }
        displayStr=displayStr + ""String_Node_Str"";
        displayArea.setText(displayStr);
        detailPanel.add(displayArea,gridBagConstraints1);
      }
 else       detailPanel.add(new JLabel(""String_Node_Str""));
      JOptionPane.showMessageDialog(view.getMainFrame(),detailPanel,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
    }
  }
);
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridBagLayout());
  int x=0;
  GridBagConstraints gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(4,4,4,4);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  buttonPanel.add(importFromSourceButton,gridBagConstraints);
  gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(4,4,4,4);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  buttonPanel.add(importFromJsonButton,gridBagConstraints);
  gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(0,0,0,0);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  gridBagConstraints.weightx=1.0;
  gridBagConstraints.weighty=1.0;
  buttonPanel.add(viewSelectedButton,gridBagConstraints);
  gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(0,0,0,0);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  buttonPanel.add(optionsButton,gridBagConstraints);
  GridBagConstraints toolConstraints=new GridBagConstraints();
  toolConstraints.gridx=0;
  toolConstraints.gridy=0;
  toolConstraints.insets=new java.awt.Insets(4,4,4,4);
  toolConstraints.anchor=GridBagConstraints.WEST;
  toolConstraints.weightx=1.0;
  toolConstraints.weighty=1.0;
  panelToolbar.add(buttonPanel,toolConstraints);
  return panelToolbar;
}","private javax.swing.JToolBar buildToolBar(){
  panelToolbar=new javax.swing.JToolBar();
  panelToolbar.setLayout(new java.awt.GridBagLayout());
  panelToolbar.setEnabled(true);
  panelToolbar.setFloatable(false);
  panelToolbar.setRollover(true);
  panelToolbar.setPreferredSize(new java.awt.Dimension(1000,30));
  panelToolbar.setMinimumSize(new java.awt.Dimension(1000,30));
  panelToolbar.setMaximumSize(new java.awt.Dimension(1000,30));
  panelToolbar.setFont(new java.awt.Font(""String_Node_Str"",java.awt.Font.PLAIN,12));
  panelToolbar.setName(""String_Node_Str"");
  viewSelectedButton=new JButton(""String_Node_Str"");
  viewSelectedButton.setEnabled(false);
  ZapPropertiesManager.INSTANCE.setViewSelectedButton(viewSelectedButton);
  JButton optionsButton=new JButton(""String_Node_Str"");
  JButton importFromSourceButton=new JButton(""String_Node_Str"");
  importFromSourceButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      boolean configured=OptionsDialog.ValidateSource(view);
      boolean completed=false;
      viewSelectedButton.setEnabled(false);
      ZapPropertiesManager.INSTANCE.setEndpointDecorator(null);
      if (configured) {
        try {
          EndpointDecorator[] endpoints=getEndpointsFromSource(ZapPropertiesManager.INSTANCE.getSourceFolder());
          EndpointDecorator comparePoints[]=null;
          String oldSourceFolder=ZapPropertiesManager.INSTANCE.getOldSourceFolder();
          if (oldSourceFolder != null && !oldSourceFolder.isEmpty())           comparePoints=getEndpointsFromSource(oldSourceFolder);
          if ((endpoints == null) || (endpoints.length == 0))           view.showWarningDialog(""String_Node_Str"");
 else {
            if (comparePoints != null && comparePoints.length != 0)             endpoints=compareEndpoints(endpoints,comparePoints,view);
            fillEndpointsToTable(endpoints);
            buildNodesFromEndpoints(endpoints);
            String url=ZapPropertiesManager.INSTANCE.getTargetUrl();
            if (url != null) {
              completed=attackUrl(url,view);
              if (!completed)               view.showWarningDialog(""String_Node_Str"");
            }
 else             view.showMessageDialog(""String_Node_Str"");
          }
        }
 catch (        Exception ex) {
          LOGGER.debug(ex.getStackTrace());
          JOptionPane.showMessageDialog(view.getMainFrame(),""String_Node_Str"");
        }
      }
      if (completed)       view.showMessageDialog(""String_Node_Str"");
    }
  }
);
  JButton importFromJsonButton=new JButton(""String_Node_Str"");
  importFromJsonButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      boolean configured=OptionsDialog.ValidateJson(view);
      boolean completed=false;
      viewSelectedButton.setEnabled(false);
      ZapPropertiesManager.INSTANCE.setEndpointDecorator(null);
      if (configured) {
        try {
          EndpointDecorator[] endpoints=getEndpointsFromJson(ZapPropertiesManager.INSTANCE.getJsonFile());
          EndpointDecorator comparePoints[]=null;
          String oldJsonFile=ZapPropertiesManager.INSTANCE.getOldJsonFile();
          if (oldJsonFile != null && !oldJsonFile.isEmpty())           comparePoints=getEndpointsFromJson(oldJsonFile);
          if ((endpoints == null) || (endpoints.length == 0))           view.showWarningDialog(""String_Node_Str"");
 else {
            if (comparePoints != null && comparePoints.length != 0)             endpoints=compareEndpoints(endpoints,comparePoints,view);
            fillEndpointsToTable(endpoints);
            buildNodesFromEndpoints(endpoints);
            String url=ZapPropertiesManager.INSTANCE.getTargetUrl();
            if (url != null) {
              completed=attackUrl(url,view);
              if (!completed)               view.showWarningDialog(""String_Node_Str"");
            }
 else             view.showMessageDialog(""String_Node_Str"");
          }
        }
 catch (        Exception ex) {
          LOGGER.debug(ex.getStackTrace());
          JOptionPane.showMessageDialog(view.getMainFrame(),""String_Node_Str"");
        }
      }
      if (completed)       view.showMessageDialog(""String_Node_Str"");
    }
  }
);
  optionsButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      boolean shouldContinue=OptionsDialog.show(view);
    }
  }
);
  viewSelectedButton.addActionListener(new java.awt.event.ActionListener(){
    @Override public void actionPerformed(    java.awt.event.ActionEvent e){
      JPanel detailPanel=new JPanel();
      detailPanel.setLayout(new GridBagLayout());
      JLabel displayArea=new JLabel();
      String displayStr=new String();
      int y=0;
      GridBagConstraints gridBagConstraints1=new GridBagConstraints();
      gridBagConstraints1.gridx=0;
      gridBagConstraints1.gridy=y++;
      gridBagConstraints1.weightx=1.0D;
      gridBagConstraints1.insets=new java.awt.Insets(4,4,4,4);
      gridBagConstraints1.fill=java.awt.GridBagConstraints.HORIZONTAL;
      gridBagConstraints1.anchor=java.awt.GridBagConstraints.NORTHWEST;
      EndpointDecorator decorator=ZapPropertiesManager.INSTANCE.getEndpointDecorator();
      Endpoint.Info endpoint=decorator.getEndpoint();
      if (endpoint != null) {
        if (decorator.getStatus() == EndpointDecorator.Status.NEW) {
          displayStr=""String_Node_Str"";
          displayStr=displayStr + ""String_Node_Str"";
        }
 else         displayStr=displayStr + ""String_Node_Str"";
        displayStr=displayStr + ""String_Node_Str"" + endpoint.getUrlPath()+ ""String_Node_Str"";
        if (endpoint.getHttpMethod().length() > 4)         displayStr=displayStr + endpoint.getHttpMethod().substring(14);
 else         displayStr=displayStr + endpoint.getHttpMethod();
        displayStr=displayStr + ""String_Node_Str"";
        if (decorator.getStatus() == EndpointDecorator.Status.CHANGED) {
          for (          Map.Entry<String,RouteParameter> parameter : endpoint.getParameters().entrySet()) {
            boolean found=false;
            for (            Map.Entry<String,RouteParameter> compParameter : decorator.getComparePoint().getParameters().entrySet()) {
              if (parameter.getKey().equalsIgnoreCase(compParameter.getKey())) {
                found=true;
                if (!parameter.getValue().getDataType().getDisplayName().equals(compParameter.getValue().getDataType().getDisplayName()))                 displayStr=displayStr + ""String_Node_Str"" + parameter.getKey()+ ""String_Node_Str""+ compParameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str"";
 else                 displayStr=displayStr + parameter.getKey() + ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName()+ ""String_Node_Str"";
                break;
              }
            }
            if (!found)             displayStr=displayStr + ""String_Node_Str"" + parameter.getKey()+ ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str"";
          }
          for (          Map.Entry<String,RouteParameter> compParameter : decorator.getComparePoint().getParameters().entrySet()) {
            boolean found=false;
            for (            Map.Entry<String,RouteParameter> parameter : endpoint.getParameters().entrySet()) {
              if (parameter.getKey().equalsIgnoreCase(compParameter.getKey())) {
                found=true;
                break;
              }
            }
            if (!found)             displayStr=displayStr + ""String_Node_Str"" + compParameter.getKey()+ ""String_Node_Str""+ compParameter.getValue().getDataType().getDisplayName().toUpperCase()+ ""String_Node_Str"";
          }
        }
 else {
          for (          Map.Entry<String,RouteParameter> parameter : endpoint.getParameters().entrySet()) {
            displayStr=displayStr + parameter.getKey() + ""String_Node_Str""+ parameter.getValue().getDataType().getDisplayName()+ ""String_Node_Str"";
          }
        }
        displayStr=displayStr + ""String_Node_Str"";
        displayArea.setText(displayStr);
        detailPanel.add(displayArea,gridBagConstraints1);
      }
 else       detailPanel.add(new JLabel(""String_Node_Str""));
      JOptionPane.showMessageDialog(view.getMainFrame(),detailPanel,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
    }
  }
);
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridBagLayout());
  int x=0;
  GridBagConstraints gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(0,0,0,0);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  buttonPanel.add(importFromSourceButton,gridBagConstraints);
  gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(0,0,0,0);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  buttonPanel.add(importFromJsonButton,gridBagConstraints);
  gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(0,0,0,0);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  gridBagConstraints.weightx=1.0;
  gridBagConstraints.weighty=1.0;
  buttonPanel.add(viewSelectedButton,gridBagConstraints);
  gridBagConstraints=new GridBagConstraints();
  gridBagConstraints.gridx=x++;
  gridBagConstraints.gridy=0;
  gridBagConstraints.insets=new java.awt.Insets(0,0,0,0);
  gridBagConstraints.anchor=GridBagConstraints.WEST;
  buttonPanel.add(optionsButton,gridBagConstraints);
  GridBagConstraints toolConstraints=new GridBagConstraints();
  toolConstraints.gridx=0;
  toolConstraints.gridy=0;
  toolConstraints.insets=new java.awt.Insets(4,4,4,4);
  toolConstraints.anchor=GridBagConstraints.WEST;
  toolConstraints.weightx=1.0;
  toolConstraints.weighty=1.0;
  panelToolbar.add(buttonPanel,toolConstraints);
  return panelToolbar;
}"
70574,"public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              Log.d(TAG,""String_Node_Str"" + leaderboardScore.getRawScore() + ""String_Node_Str""+ leaderboardScore.getRank());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboardScore.getRawScore(),leaderboardScore.getRank()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{String.valueOf(leaderboardScore.getRawScore()),String.valueOf(leaderboardScore.getRank())});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70575,"public void leaderboard_load_top_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_top_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70576,"@Override public void onComplete(@NonNull Task<AnnotatedData<LeaderboardScores>> task){
  if (task.isSuccessful()) {
    JSONObject leaderboard_result=new JSONObject();
    AnnotatedData<LeaderboardScores> result=task.getResult();
    LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    try {
      for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
        LeaderboardScore leaderboardScore=iterator.next();
        String displayName=leaderboardScore.getScoreHolderDisplayName();
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
        googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
      }
    }
 catch (    JSONException e) {
      Log.w(TAG,""String_Node_Str"" + e);
    }
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result});
  }
 else {
    Log.e(TAG,""String_Node_Str"" + task.getException());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
  }
}","@Override public void onComplete(@NonNull Task<AnnotatedData<LeaderboardScores>> task){
  if (task.isSuccessful()) {
    JSONObject leaderboard_result=new JSONObject();
    AnnotatedData<LeaderboardScores> result=task.getResult();
    LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    try {
      for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
        LeaderboardScore leaderboardScore=iterator.next();
        String displayName=leaderboardScore.getScoreHolderDisplayName();
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
        googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
      }
    }
 catch (    JSONException e) {
      Log.w(TAG,""String_Node_Str"" + e);
    }
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
  }
 else {
    Log.e(TAG,""String_Node_Str"" + task.getException());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
  }
}"
70577,"public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboardScore.getRawScore()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboardScore.getRawScore(),leaderboardScore.getRank()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70578,"public void leaderboard_load_player_centered_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadPlayerCenteredScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_player_centered_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadPlayerCenteredScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70579,"@Override protected Void doInBackground(Void... params){
  LeaderboardsClient leaderboardsClient=get_leaderboard_client();
  leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
    @Override public void onFailure(    @NonNull Exception e){
      String message=e.getMessage();
      Log.e(TAG,""String_Node_Str"" + message);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
    }
  }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
    @Override public void onComplete(    @NonNull Task<AnnotatedData<LeaderboardScores>> task){
      if (task.isSuccessful()) {
        JSONObject leaderboard_result=new JSONObject();
        AnnotatedData<LeaderboardScores> result=task.getResult();
        LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
        GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
        try {
          for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
            LeaderboardScore leaderboardScore=iterator.next();
            String displayName=leaderboardScore.getScoreHolderDisplayName();
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
            googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
          }
        }
 catch (        JSONException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result});
      }
 else {
        Log.e(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
      }
    }
  }
);
  return null;
}","@Override protected Void doInBackground(Void... params){
  LeaderboardsClient leaderboardsClient=get_leaderboard_client();
  leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
    @Override public void onFailure(    @NonNull Exception e){
      String message=e.getMessage();
      Log.e(TAG,""String_Node_Str"" + message);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
    }
  }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
    @Override public void onComplete(    @NonNull Task<AnnotatedData<LeaderboardScores>> task){
      if (task.isSuccessful()) {
        JSONObject leaderboard_result=new JSONObject();
        AnnotatedData<LeaderboardScores> result=task.getResult();
        LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
        GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
        try {
          for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
            LeaderboardScore leaderboardScore=iterator.next();
            String displayName=leaderboardScore.getScoreHolderDisplayName();
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
            googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
          }
        }
 catch (        JSONException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
      }
 else {
        Log.e(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
      }
    }
  }
);
  return null;
}"
70580,"public void share(final String title,final String message,final String image_filename){
  Intent shareIntent=new Intent();
  shareIntent.setAction(Intent.ACTION_SEND);
  if (image_filename.length() > 0) {
    File imagePath=new File(context.getFilesDir(),get_shared_directory());
    File imageFile=new File(imagePath,image_filename);
    Uri contentUri=FileProvider.getUriForFile(context,BuildConfig.APPLICATION_ID + ""String_Node_Str"",imageFile);
    if (contentUri != null) {
      shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
      shareIntent.setDataAndType(contentUri,context.getContentResolver().getType(contentUri));
      shareIntent.putExtra(Intent.EXTRA_STREAM,contentUri);
    }
 else {
      Log.w(TAG,""String_Node_Str"" + get_shared_directory() + ""String_Node_Str""+ image_filename);
    }
  }
  shareIntent.putExtra(Intent.EXTRA_TEXT,message);
  shareIntent.setType(""String_Node_Str"");
  activity.startActivityForResult(Intent.createChooser(shareIntent,title),GodotAndroidRequest.GODOT_SHARE_REQUEST);
}","public void share(final String title,final String message,final String image_filename){
  Intent shareIntent=new Intent();
  String type=""String_Node_Str"";
  shareIntent.setAction(Intent.ACTION_SEND);
  if (image_filename.length() > 0) {
    File imagePath=new File(context.getFilesDir(),get_shared_directory());
    File imageFile=new File(imagePath,image_filename);
    Uri contentUri=FileProvider.getUriForFile(context,BuildConfig.APPLICATION_ID + ""String_Node_Str"",imageFile);
    if (contentUri != null) {
      shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
      shareIntent.setDataAndType(contentUri,context.getContentResolver().getType(contentUri));
      shareIntent.putExtra(Intent.EXTRA_STREAM,contentUri);
      type=""String_Node_Str"";
    }
 else {
      Log.w(TAG,""String_Node_Str"" + get_shared_directory() + ""String_Node_Str""+ image_filename);
    }
  }
  shareIntent.putExtra(Intent.EXTRA_TEXT,message);
  shareIntent.setType(type);
  activity.startActivityForResult(Intent.createChooser(shareIntent,title),GodotAndroidRequest.GODOT_SHARE_REQUEST);
}"
70581,"public void leaderboard_load_top_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_top_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName + ""String_Node_Str"");
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName + ""String_Node_Str"");
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70582,"@Override public void onComplete(@NonNull Task<AnnotatedData<LeaderboardScores>> task){
  if (task.isSuccessful()) {
    JSONObject leaderboard_result=new JSONObject();
    AnnotatedData<LeaderboardScores> result=task.getResult();
    LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    try {
      for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
        LeaderboardScore leaderboardScore=iterator.next();
        String displayName=leaderboardScore.getScoreHolderDisplayName();
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
        googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
      }
    }
 catch (    JSONException e) {
      Log.w(TAG,""String_Node_Str"" + e);
    }
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
  }
 else {
    Log.e(TAG,""String_Node_Str"" + task.getException());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
  }
}","@Override public void onComplete(@NonNull Task<AnnotatedData<LeaderboardScores>> task){
  if (task.isSuccessful()) {
    JSONObject leaderboard_result=new JSONObject();
    AnnotatedData<LeaderboardScores> result=task.getResult();
    LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    try {
      for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
        LeaderboardScore leaderboardScore=iterator.next();
        String displayName=leaderboardScore.getScoreHolderDisplayName();
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
        leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName + ""String_Node_Str"");
        googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName + ""String_Node_Str"");
      }
    }
 catch (    JSONException e) {
      Log.w(TAG,""String_Node_Str"" + e);
    }
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
  }
 else {
    Log.e(TAG,""String_Node_Str"" + task.getException());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
  }
}"
70583,"public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboardScore.getRawScore(),leaderboardScore.getRank()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              Log.d(TAG,""String_Node_Str"" + leaderboardScore.getRawScore() + ""String_Node_Str""+ leaderboardScore.getRank());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboardScore.getRawScore(),leaderboardScore.getRank()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70584,"public void leaderboard_load_player_centered_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadPlayerCenteredScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_player_centered_scores(final String leaderboard_id,final int time_span,final int max_results,final boolean force_reload){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadPlayerCenteredScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScores>> task){
            if (task.isSuccessful()) {
              JSONObject leaderboard_result=new JSONObject();
              AnnotatedData<LeaderboardScores> result=task.getResult();
              LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
              GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
              try {
                for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
                  LeaderboardScore leaderboardScore=iterator.next();
                  String displayName=leaderboardScore.getScoreHolderDisplayName();
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
                  leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName + ""String_Node_Str"");
                  googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName + ""String_Node_Str"");
                }
              }
 catch (              JSONException e) {
                Log.w(TAG,""String_Node_Str"" + e);
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70585,"@Override protected Void doInBackground(Void... params){
  LeaderboardsClient leaderboardsClient=get_leaderboard_client();
  leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
    @Override public void onFailure(    @NonNull Exception e){
      String message=e.getMessage();
      Log.e(TAG,""String_Node_Str"" + message);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
    }
  }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
    @Override public void onComplete(    @NonNull Task<AnnotatedData<LeaderboardScores>> task){
      if (task.isSuccessful()) {
        JSONObject leaderboard_result=new JSONObject();
        AnnotatedData<LeaderboardScores> result=task.getResult();
        LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
        GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
        try {
          for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
            LeaderboardScore leaderboardScore=iterator.next();
            String displayName=leaderboardScore.getScoreHolderDisplayName();
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName);
            googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName);
          }
        }
 catch (        JSONException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
      }
 else {
        Log.e(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
      }
    }
  }
);
  return null;
}","@Override protected Void doInBackground(Void... params){
  LeaderboardsClient leaderboardsClient=get_leaderboard_client();
  leaderboardsClient.loadTopScores(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC,max_results,force_reload).addOnFailureListener(new OnFailureListener(){
    @Override public void onFailure(    @NonNull Exception e){
      String message=e.getMessage();
      Log.e(TAG,""String_Node_Str"" + message);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
    }
  }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScores>>(){
    @Override public void onComplete(    @NonNull Task<AnnotatedData<LeaderboardScores>> task){
      if (task.isSuccessful()) {
        JSONObject leaderboard_result=new JSONObject();
        AnnotatedData<LeaderboardScores> result=task.getResult();
        LeaderboardScoreBuffer leaderboardScores=result.get().getScores();
        GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
        try {
          for (Iterator<LeaderboardScore> iterator=leaderboardScores.iterator(); iterator.hasNext(); ) {
            LeaderboardScore leaderboardScore=iterator.next();
            String displayName=leaderboardScore.getScoreHolderDisplayName();
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",leaderboardScore.getRawScore());
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",displayName);
            leaderboard_result.put(String.valueOf(leaderboardScore.getRank()) + ""String_Node_Str"",""String_Node_Str"" + displayName + ""String_Node_Str"");
            googlePlayer.copy_user_picture(leaderboardScore.getScoreHolderIconImageUri(),displayName + ""String_Node_Str"");
          }
        }
 catch (        JSONException e) {
          Log.w(TAG,""String_Node_Str"" + e);
        }
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{leaderboard_result.toString()});
      }
 else {
        Log.e(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
      }
    }
  }
);
  return null;
}"
70586,"public void godot_initialize(final int instance_id){
  activity.runOnUiThread(new Runnable(){
    public void run(){
      godotAndroidShare.init(instance_id);
      godotAndroidNetwork.init(instance_id);
    }
  }
);
}","public void godot_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      godotAndroidShare.init(instance_id);
      godotAndroidNetwork.init(instance_id);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}"
70587,"public void facebook_initialize(final int instance_id){
  activity.runOnUiThread(new Runnable(){
    public void run(){
      facebookAuthentication.init(instance_id);
      facebookShare.init(instance_id);
    }
  }
);
}","public void facebook_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      facebookAuthentication.init(instance_id);
      facebookShare.init(instance_id);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}"
70588,"public void google_initialize(final int instance_id){
  activity.runOnUiThread(new Runnable(){
    public void run(){
      googleAchievements.init(instance_id);
      googleAuthentication.init(instance_id);
      googlePlayer.init(instance_id);
      googleLeaderboard.init(instance_id);
      googleSnapshot.init(instance_id);
    }
  }
);
}","public void google_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      googleAchievements.init(instance_id);
      googleAuthentication.init(instance_id);
      googlePlayer.init(instance_id);
      googleLeaderboard.init(instance_id);
      googleSnapshot.init(instance_id);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}"
70589,"public void firebase_initialize(final int instance_id){
  activity.runOnUiThread(new Runnable(){
    public void run(){
      firebaseCurrentUser.init(instance_id);
      firebaseCurrentAnalytics.init(instance_id);
      firebaseCurrentInvite.init(instance_id);
      firebaseCurrentAuthentication.init(instance_id);
      FirebaseCurrentNotification.init(instance_id);
    }
  }
);
}","public void firebase_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      firebaseCurrentUser.init(instance_id);
      firebaseCurrentAnalytics.init(instance_id);
      firebaseCurrentInvite.init(instance_id);
      firebaseCurrentAuthentication.init(instance_id);
      FirebaseCurrentNotification.init(instance_id);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}"
70590,"private void silentConnectHandler(GoogleSignInResult result){
  if (result == null) {
    String message=""String_Node_Str"";
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
    Log.w(TAG,message);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
 else   if (result.isSuccess()) {
    GoogleSignInAccount account=result.getSignInAccount();
    firebaseAuthWithGoogle(account);
  }
 else   if (result.getStatus().getStatusCode() == GoogleSignInStatusCodes.SIGN_IN_CANCELLED) {
    Log.i(TAG,""String_Node_Str"" + result.getStatus());
    onDisconnected();
  }
 else {
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
    Log.w(TAG,""String_Node_Str"" + result.getStatus());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{result.getStatus().getStatusMessage()});
  }
}","private void silentConnectHandler(GoogleSignInResult result){
  if (result == null) {
    String message=""String_Node_Str"";
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
    Log.w(TAG,message);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
 else   if (result.isSuccess()) {
    GoogleSignInAccount account=result.getSignInAccount();
    firebaseAuthWithGoogle(account);
  }
 else   if (result.getStatus().getStatusCode() == GoogleSignInStatusCodes.SIGN_IN_CURRENTLY_IN_PROGRESS) {
    Log.i(TAG,""String_Node_Str"");
    onDisconnected();
  }
 else   if (result.getStatus().getStatusCode() == GoogleSignInStatusCodes.SIGN_IN_CANCELLED) {
    Log.i(TAG,""String_Node_Str"" + result.getStatus());
    onDisconnected();
  }
 else {
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
    Log.w(TAG,""String_Node_Str"" + result.getStatus());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{result.getStatus().getStatusMessage()});
  }
}"
70591,"public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{String.valueOf(leaderboardScore.getRawScore()),String.valueOf(leaderboardScore.getRank())});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void leaderboard_load_player_score(final String leaderboard_id,final int time_span){
  if (is_connected()) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        LeaderboardsClient leaderboardsClient=get_leaderboard_client();
        leaderboardsClient.loadCurrentPlayerLeaderboardScore(leaderboard_id,time_span,LeaderboardVariant.COLLECTION_PUBLIC).addOnFailureListener(new OnFailureListener(){
          @Override public void onFailure(          @NonNull Exception e){
            String message=e.getMessage();
            Log.e(TAG,""String_Node_Str"" + message);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
).addOnCompleteListener(new OnCompleteListener<AnnotatedData<LeaderboardScore>>(){
          @Override public void onComplete(          @NonNull Task<AnnotatedData<LeaderboardScore>> task){
            if (task.isSuccessful()) {
              AnnotatedData<LeaderboardScore> result=task.getResult();
              LeaderboardScore leaderboardScore=result.get();
              long score=-1;
              long rank=-1;
              if (leaderboardScore != null) {
                score=leaderboardScore.getRawScore();
                rank=leaderboardScore.getRank();
              }
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{String.valueOf(score),String.valueOf(rank)});
            }
 else {
              Log.e(TAG,""String_Node_Str"" + task.getException());
              GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
            }
          }
        }
);
        return null;
      }
    }
;
    task.execute();
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70592,"public void achievement_unlock(final String achievement_id){
  if (is_connected()) {
    AchievementsClient achievementsClient=get_achivement_client();
    achievementsClient.unlock(achievement_id);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{achievement_id});
  }
 else {
    String message=""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"");
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void achievement_unlock(final String achievement_id){
  if (is_connected()) {
    AchievementsClient achievementsClient=get_achievement_client();
    achievementsClient.unlock(achievement_id);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{achievement_id});
  }
 else {
    String message=""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"");
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70593,"public void achievement_increment(final String achievement_id,final int amount){
  if (is_connected()) {
    AchievementsClient achievementsClient=get_achivement_client();
    achievementsClient.increment(achievement_id,amount);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{achievement_id,amount});
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void achievement_increment(final String achievement_id,final int amount){
  if (is_connected()) {
    AchievementsClient achievementsClient=get_achievement_client();
    achievementsClient.increment(achievement_id,amount);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{achievement_id,amount});
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70594,"public void achievement_show_list(){
  if (is_connected()) {
    AchievementsClient achievementsClient=get_achivement_client();
    achievementsClient.getAchievementsIntent().addOnSuccessListener(new OnSuccessListener<Intent>(){
      @Override public void onSuccess(      Intent intent){
        activity.startActivityForResult(intent,GodotAndroidRequest.GOOGLE_ACHIEVEMENT_REQUEST);
      }
    }
).addOnFailureListener(new OnFailureListener(){
      @Override public void onFailure(      @NonNull Exception e){
        Log.d(TAG,""String_Node_Str"" + e.toString());
      }
    }
);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
}","public void achievement_show_list(){
  if (is_connected()) {
    AchievementsClient achievementsClient=get_achievement_client();
    achievementsClient.getAchievementsIntent().addOnSuccessListener(new OnSuccessListener<Intent>(){
      @Override public void onSuccess(      Intent intent){
        activity.startActivityForResult(intent,GodotAndroidRequest.GOOGLE_ACHIEVEMENT_REQUEST);
      }
    }
).addOnFailureListener(new OnFailureListener(){
      @Override public void onFailure(      @NonNull Exception e){
        Log.d(TAG,""String_Node_Str"" + e.toString());
      }
    }
);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
}"
70595,"@Override public void onComplete(@NonNull Task<AuthResult> task){
  if (task.isSuccessful()) {
    mAccount=account;
    onConnected();
  }
 else {
    String message=task.getException().getMessage();
    Log.w(TAG,""String_Node_Str"" + task.getException());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
  }
}","@Override public void onComplete(@NonNull Task<AuthResult> task){
  if (task.isSuccessful()) {
    Log.i(TAG,""String_Node_Str"");
    mAccount=account;
    onConnected();
  }
 else {
    String message=task.getException().getMessage();
    Log.w(TAG,""String_Node_Str"" + task.getException());
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
  }
}"
70596,"private void firebaseAuthWithGoogle(final GoogleSignInAccount account){
  AuthCredential credential=GoogleAuthProvider.getCredential(account.getIdToken(),null);
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    for (    UserInfo userInfo : firebaseUser.getProviderData()) {
      if (userInfo.getProviderId().equals(GoogleAuthProvider.PROVIDER_ID)) {
        if (userInfo.getUid().equals(account.getId())) {
          Log.i(TAG,""String_Node_Str"");
          mAccount=account;
          onConnected();
        }
 else {
          String message=""String_Node_Str"" + userInfo.getUid() + ""String_Node_Str""+ account.getId()+ ""String_Node_Str"";
          Log.w(TAG,message);
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
        }
        return;
      }
    }
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        mAccount=account;
        onConnected();
      }
 else {
        String message=task.getException().getMessage();
        Log.w(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
        updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
      }
    }
  }
);
}","private void firebaseAuthWithGoogle(final GoogleSignInAccount account){
  AuthCredential credential=GoogleAuthProvider.getCredential(account.getIdToken(),null);
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    for (    UserInfo userInfo : firebaseUser.getProviderData()) {
      if (userInfo.getProviderId().equals(GoogleAuthProvider.PROVIDER_ID)) {
        if (userInfo.getUid().equals(account.getId())) {
          Log.i(TAG,""String_Node_Str"");
          mAccount=account;
          onConnected();
        }
 else {
          String message=""String_Node_Str"" + userInfo.getUid() + ""String_Node_Str""+ account.getId()+ ""String_Node_Str"";
          Log.w(TAG,message);
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
        }
        return;
      }
    }
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        Log.i(TAG,""String_Node_Str"");
        mAccount=account;
        onConnected();
      }
 else {
        String message=task.getException().getMessage();
        Log.w(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
        updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
      }
    }
  }
);
}"
70597,"public void snapshot_load(final String snapshotName,final int conflictResolutionPolicy){
  if (is_connected()) {
    SnapshotsClient snapshotsClient=get_snapshot_client();
    snapshotsClient.open(snapshotName,true,conflictResolutionPolicy).addOnFailureListener(new OnFailureListener(){
      @Override public void onFailure(      @NonNull Exception e){
        String message=e.getMessage();
        Log.e(TAG,""String_Node_Str"" + message);
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
      }
    }
).continueWith(new Continuation<SnapshotsClient.DataOrConflict<Snapshot>,String>(){
      @Override public String then(      @NonNull Task<SnapshotsClient.DataOrConflict<Snapshot>> task) throws Exception {
        SnapshotsClient.DataOrConflict<Snapshot> result=task.getResult();
        if (result.isConflict()) {
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{""String_Node_Str""});
          return null;
        }
        try {
          Snapshot snapshot=result.getData();
          return new String(snapshot.getSnapshotContents().readFully());
        }
 catch (        IOException e) {
          String message=e.getMessage();
          Log.e(TAG,""String_Node_Str"" + message);
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
        }
        return null;
      }
    }
).addOnCompleteListener(new OnCompleteListener<String>(){
      @Override public void onComplete(      @NonNull Task<String> task){
        String result=task.getResult();
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{result});
      }
    }
);
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}","public void snapshot_load(final String snapshotName,final int conflictResolutionPolicy){
  if (is_connected()) {
    SnapshotsClient snapshotsClient=get_snapshot_client();
    snapshotsClient.open(snapshotName,true,conflictResolutionPolicy).addOnFailureListener(new OnFailureListener(){
      @Override public void onFailure(      @NonNull Exception e){
        String message=e.getMessage();
        Log.e(TAG,""String_Node_Str"" + message);
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
      }
    }
).continueWith(new Continuation<SnapshotsClient.DataOrConflict<Snapshot>,String>(){
      @Override public String then(      @NonNull Task<SnapshotsClient.DataOrConflict<Snapshot>> task) throws Exception {
        SnapshotsClient.DataOrConflict<Snapshot> result=task.getResult();
        if (result.isConflict()) {
          throw new Exception(""String_Node_Str"");
        }
        Snapshot snapshot=result.getData();
        return new String(snapshot.getSnapshotContents().readFully());
      }
    }
).addOnCompleteListener(new OnCompleteListener<String>(){
      @Override public void onComplete(      @NonNull Task<String> task){
        if (task.isSuccessful()) {
          String result=task.getResult();
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{result});
        }
 else {
          Log.e(TAG,""String_Node_Str"" + task.getException());
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().getMessage()});
        }
      }
    }
);
    Log.i(TAG,""String_Node_Str"");
  }
 else {
    String message=""String_Node_Str"";
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70598,"public void firebase_initialize(final int instance_id){
  activity.runOnUiThread(new Runnable(){
    public void run(){
      firebaseCurrentUser.init(instance_id);
      firebaseCurrentAnalytics.init(instance_id);
      firebaseCurrentInvite.init(instance_id);
      FirebaseCurrentNotification.init(instance_id);
    }
  }
);
}","public void firebase_initialize(final int instance_id){
  activity.runOnUiThread(new Runnable(){
    public void run(){
      firebaseCurrentUser.init(instance_id);
      firebaseCurrentAnalytics.init(instance_id);
      firebaseCurrentInvite.init(instance_id);
      firebaseCurrentAuthentication.init(instance_id);
      FirebaseCurrentNotification.init(instance_id);
    }
  }
);
}"
70599,"public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    mAuth.signOut();
    if (mGoogleApiClient.isConnected()) {
      Auth.GoogleSignInApi.signOut(mGoogleApiClient).setResultCallback(new ResultCallback<Status>(){
        @Override public void onResult(        @NonNull Status status){
          onDisconnected();
        }
      }
);
    }
  }
}","public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    mAuth.signOut();
    if (mGoogleApiClient.isConnected()) {
      Auth.GoogleSignInApi.signOut(mGoogleApiClient).setResultCallback(new ResultCallback<Status>(){
        @Override public void onResult(        @NonNull Status status){
          onDisconnected();
        }
      }
);
    }
 else {
      onDisconnected();
    }
  }
}"
70600,"public GodotAndroid(Activity p_activity){
  registerClass(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  activity=p_activity;
  context=activity.getApplicationContext();
  firebaseCurrentUser=FirebaseCurrentUser.getInstance(activity);
  firebaseCurrentAnalytics=FirebaseCurrentAnalytics.getInstance(activity);
  firebaseCurrentInvite=FirebaseCurrentInvite.getInstance(activity);
  firebaseCurrentAuthentication=FirebaseCurrentAuthentication.getInstance(activity);
  googleAchievements=GoogleAchievements.getInstance(activity);
  googleAuthentication=GoogleAuthentication.getInstance(activity);
  googleLeaderboard=GoogleLeaderboard.getInstance(activity);
  googleSnapshot=GoogleSnapshot.getInstance(activity);
  facebookAuthentication=FacebookAuthentication.getInstance(activity);
  facebookShare=FacebookShare.getInstance(activity);
}","public GodotAndroid(Activity p_activity){
  registerClass(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  activity=p_activity;
  context=activity.getApplicationContext();
  firebaseCurrentUser=FirebaseCurrentUser.getInstance(activity);
  firebaseCurrentAnalytics=FirebaseCurrentAnalytics.getInstance(activity);
  firebaseCurrentInvite=FirebaseCurrentInvite.getInstance(activity);
  firebaseCurrentAuthentication=FirebaseCurrentAuthentication.getInstance(activity);
  googleAchievements=GoogleAchievements.getInstance(activity);
  googleAuthentication=GoogleAuthentication.getInstance(activity);
  googleLeaderboard=GoogleLeaderboard.getInstance(activity);
  googleSnapshot=GoogleSnapshot.getInstance(activity);
  facebookAuthentication=FacebookAuthentication.getInstance(activity);
  facebookShare=FacebookShare.getInstance(activity);
}"
70601,"public void onStart(){
  signInAnonymously();
}","public void onStart(){
}"
70602,"public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    mAuth.signOut();
    if (mGoogleApiClient.isConnected()) {
      Auth.GoogleSignInApi.signOut(mGoogleApiClient).setResultCallback(new ResultCallback<Status>(){
        @Override public void onResult(        @NonNull Status status){
          onDisconnected();
        }
      }
);
    }
 else {
      onDisconnected();
    }
  }
}","public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    if (firebaseUser != null) {
      firebaseUser.unlink(GoogleAuthProvider.PROVIDER_ID).addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
        @Override public void onComplete(        @NonNull Task<AuthResult> task){
          if (task.isSuccessful()) {
            disconnect_from_google();
          }
 else {
            String message=task.getException().getMessage();
            Log.w(TAG,""String_Node_Str"" + task.getException());
            updateConnectionStatus(GodotConnectStatus.CONNECTED);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
      }
);
    }
 else {
      disconnect_from_google();
    }
  }
}"
70603,"public void onConnected(){
  if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    googlePlayer.load_current_player();
  }
}","public void onConnected(){
  if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
    Games.getGamesClient(activity,mAccount).setViewForPopups(activity.getWindow().getDecorView().findViewById(android.R.id.content));
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    googlePlayer.load_current_player();
  }
}"
70604,"protected void onMainDestroy(){
  googleAchievements.onStop();
  googlePlayer.onStop();
  googleAuthentication.onStop();
  googleLeaderboard.onStop();
  googleSnapshot.onStop();
  firebaseCurrentUser.onStop();
  firebaseCurrentAnalytics.onStop();
  firebaseCurrentInvite.onStop();
  firebaseCurrentAuthentication.onStop();
  godotAndroidShare.onStop();
  godotAndroidNetwork.onStop();
}","protected void onMainDestroy(){
  if (google_initialized) {
    googleAchievements.onStop();
    googlePlayer.onStop();
    googleAuthentication.onStop();
    googleLeaderboard.onStop();
    googleSnapshot.onStop();
  }
  if (firebase_initialized) {
    firebaseCurrentUser.onStop();
    firebaseCurrentAnalytics.onStop();
    firebaseCurrentInvite.onStop();
    firebaseCurrentAuthentication.onStop();
  }
  if (godot_generic_initialized) {
    godotAndroidShare.onStop();
    godotAndroidNetwork.onStop();
  }
}"
70605,"protected void onMainPause(){
  googleAchievements.onPause();
  googlePlayer.onPause();
  googleAuthentication.onPause();
  googleLeaderboard.onPause();
  googleSnapshot.onPause();
  firebaseCurrentUser.onPause();
  firebaseCurrentAnalytics.onPause();
  firebaseCurrentInvite.onPause();
  firebaseCurrentAuthentication.onPause();
  godotAndroidShare.onPause();
  godotAndroidNetwork.onPause();
}","protected void onMainPause(){
  if (google_initialized) {
    googleAchievements.onPause();
    googlePlayer.onPause();
    googleAuthentication.onPause();
    googleLeaderboard.onPause();
    googleSnapshot.onPause();
  }
  if (firebase_initialized) {
    firebaseCurrentUser.onPause();
    firebaseCurrentAnalytics.onPause();
    firebaseCurrentInvite.onPause();
    firebaseCurrentAuthentication.onPause();
  }
  if (godot_generic_initialized) {
    godotAndroidShare.onPause();
    godotAndroidNetwork.onPause();
  }
}"
70606,"protected void onMainResume(){
  googleAchievements.onResume();
  googlePlayer.onResume();
  googleAuthentication.onResume();
  googleLeaderboard.onResume();
  googleSnapshot.onResume();
  firebaseCurrentUser.onResume();
  firebaseCurrentAnalytics.onResume();
  firebaseCurrentInvite.onResume();
  firebaseCurrentAuthentication.onResume();
  godotAndroidShare.onResume();
  godotAndroidNetwork.onResume();
}","protected void onMainResume(){
  if (google_initialized) {
    googleAchievements.onResume();
    googlePlayer.onResume();
    googleAuthentication.onResume();
    googleLeaderboard.onResume();
    googleSnapshot.onResume();
  }
  if (firebase_initialized) {
    firebaseCurrentUser.onResume();
    firebaseCurrentAnalytics.onResume();
    firebaseCurrentInvite.onResume();
    firebaseCurrentAuthentication.onResume();
  }
  if (godot_generic_initialized) {
    godotAndroidShare.onResume();
    godotAndroidNetwork.onResume();
  }
}"
70607,"public void google_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      googleAchievements.init(instance_id);
      googleAuthentication.init(instance_id);
      googlePlayer.init(instance_id);
      googleLeaderboard.init(instance_id);
      googleSnapshot.init(instance_id);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}","public void google_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      googleAchievements.init(instance_id);
      googleAuthentication.init(instance_id);
      googlePlayer.init(instance_id);
      googleLeaderboard.init(instance_id);
      googleSnapshot.init(instance_id);
      google_initialized=true;
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}"
70608,"@Override protected Void doInBackground(Void... params){
  googleAchievements.init(instance_id);
  googleAuthentication.init(instance_id);
  googlePlayer.init(instance_id);
  googleLeaderboard.init(instance_id);
  googleSnapshot.init(instance_id);
  GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  return null;
}","@Override protected Void doInBackground(Void... params){
  googleAchievements.init(instance_id);
  googleAuthentication.init(instance_id);
  googlePlayer.init(instance_id);
  googleLeaderboard.init(instance_id);
  googleSnapshot.init(instance_id);
  google_initialized=true;
  GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  return null;
}"
70609,"protected void onMainActivityResult(int requestCode,int resultCode,Intent data){
  googleAchievements.onActivityResult(requestCode,resultCode,data);
  googlePlayer.onActivityResult(requestCode,resultCode,data);
  googleAuthentication.onActivityResult(requestCode,resultCode,data);
  googleLeaderboard.onActivityResult(requestCode,resultCode,data);
  googleSnapshot.onActivityResult(requestCode,resultCode,data);
  firebaseCurrentUser.onActivityResult(requestCode,resultCode,data);
  firebaseCurrentAnalytics.onActivityResult(requestCode,resultCode,data);
  firebaseCurrentInvite.onActivityResult(requestCode,resultCode,data);
  firebaseCurrentAuthentication.onActivityResult(requestCode,resultCode,data);
  godotAndroidShare.onActivityResult(requestCode,resultCode,data);
  godotAndroidNetwork.onActivityResult(requestCode,resultCode,data);
}","protected void onMainActivityResult(int requestCode,int resultCode,Intent data){
  if (google_initialized) {
    googleAchievements.onActivityResult(requestCode,resultCode,data);
    googlePlayer.onActivityResult(requestCode,resultCode,data);
    googleAuthentication.onActivityResult(requestCode,resultCode,data);
    googleLeaderboard.onActivityResult(requestCode,resultCode,data);
    googleSnapshot.onActivityResult(requestCode,resultCode,data);
  }
  if (firebase_initialized) {
    firebaseCurrentUser.onActivityResult(requestCode,resultCode,data);
    firebaseCurrentAnalytics.onActivityResult(requestCode,resultCode,data);
    firebaseCurrentInvite.onActivityResult(requestCode,resultCode,data);
    firebaseCurrentAuthentication.onActivityResult(requestCode,resultCode,data);
  }
  if (godot_generic_initialized) {
    godotAndroidShare.onActivityResult(requestCode,resultCode,data);
    godotAndroidNetwork.onActivityResult(requestCode,resultCode,data);
  }
}"
70610,"public void godot_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      godotAndroidShare.init(instance_id);
      godotAndroidNetwork.init(instance_id);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}","public void godot_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      godotAndroidShare.init(instance_id);
      godotAndroidNetwork.init(instance_id);
      godot_generic_initialized=true;
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}"
70611,"public void firebase_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      firebaseCurrentUser.init(instance_id);
      firebaseCurrentInvite.init(instance_id);
      firebaseCurrentAnalytics.init(instance_id);
      firebaseCurrentAuthentication.init(instance_id);
      FirebaseCurrentNotification.init(instance_id);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}","public void firebase_initialize(final int instance_id){
  AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
    @Override protected Void doInBackground(    Void... params){
      firebaseCurrentUser.init(instance_id);
      firebaseCurrentInvite.init(instance_id);
      firebaseCurrentAnalytics.init(instance_id);
      firebaseCurrentAuthentication.init(instance_id);
      FirebaseCurrentNotification.init(instance_id);
      firebase_initialized=true;
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
      return null;
    }
  }
;
  task.execute();
}"
70612,"protected boolean is_connected(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  return googleAuthentication.isConnected();
}","protected boolean is_connected(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  boolean isConnected=googleAuthentication.isConnected();
  if (!isConnected) {
    mAchievementsClient=null;
  }
  return isConnected;
}"
70613,"protected AchievementsClient get_achievement_client(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  return Games.getAchievementsClient(activity,googleAuthentication.get_account());
}","protected AchievementsClient get_achievement_client(){
  if (mAchievementsClient == null) {
    GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
    mAchievementsClient=Games.getAchievementsClient(activity,googleAuthentication.get_account());
  }
  return mAchievementsClient;
}"
70614,"public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    if (mAuth == null) {
      return disconnect_from_google();
    }
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    if (firebaseUser != null) {
      firebaseUser.unlink(GoogleAuthProvider.PROVIDER_ID).addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
        @Override public void onComplete(        @NonNull Task<AuthResult> task){
          if (task != null && task.isSuccessful()) {
            disconnect_from_google();
          }
 else {
            String message=task.getException().getMessage();
            Log.w(TAG,""String_Node_Str"" + task.getException());
            updateConnectionStatus(GodotConnectStatus.CONNECTED);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
      }
);
    }
 else {
      disconnect_from_google();
    }
  }
}","public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    if (mAuth == null) {
      disconnect_from_google();
      return;
    }
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    if (firebaseUser != null) {
      firebaseUser.unlink(GoogleAuthProvider.PROVIDER_ID).addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
        @Override public void onComplete(        @NonNull Task<AuthResult> task){
          if (task != null && task.isSuccessful()) {
            disconnect_from_google();
          }
 else {
            String message=task.getException().getMessage();
            Log.w(TAG,""String_Node_Str"" + task.getException());
            updateConnectionStatus(GodotConnectStatus.CONNECTED);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
      }
);
    }
 else {
      disconnect_from_google();
    }
  }
}"
70615,"public synchronized void onDisconnected(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
    Log.i(TAG,""String_Node_Str"");
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  }
}","public synchronized void onDisconnected(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
    Log.i(TAG,""String_Node_Str"");
    GoogleAchievements.getInstance(activity).disconnected();
    GoogleLeaderboard.getInstance(activity).disconnected();
    GooglePlayer.getInstance(activity).disconnected();
    GoogleSnapshot.getInstance(activity).disconnected();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  }
}"
70616,"protected boolean is_connected(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  return googleAuthentication.isConnected();
}","protected boolean is_connected(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  boolean isConnected=googleAuthentication.isConnected();
  if (!isConnected) {
    mLeaderboardsClient=null;
  }
  return isConnected;
}"
70617,"protected LeaderboardsClient get_leaderboard_client(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  return Games.getLeaderboardsClient(activity,googleAuthentication.get_account());
}","protected LeaderboardsClient get_leaderboard_client(){
  if (mLeaderboardsClient == null) {
    GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
    mLeaderboardsClient=Games.getLeaderboardsClient(activity,googleAuthentication.get_account());
  }
  return mLeaderboardsClient;
}"
70618,"protected boolean is_connected(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  return googleAuthentication.isConnected();
}","protected boolean is_connected(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  boolean isConnected=googleAuthentication.isConnected();
  if (!isConnected) {
    mPlayersClient=null;
  }
  return isConnected;
}"
70619,"protected PlayersClient get_player_client(){
  GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
  return Games.getPlayersClient(activity,googleAuthentication.get_account());
}","protected PlayersClient get_player_client(){
  if (mPlayersClient == null) {
    GoogleAuthentication googleAuthentication=GoogleAuthentication.getInstance(activity);
    mPlayersClient=Games.getPlayersClient(activity,googleAuthentication.get_account());
  }
  return mPlayersClient;
}"
70620,"public void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == GodotAndroidRequest.GOOGLE_AUTHENTICATION_REQUEST) {
    GoogleSignInResult result=Auth.GoogleSignInApi.getSignInResultFromIntent(data);
    if (result.isSuccess()) {
      GoogleSignInAccount account=result.getSignInAccount();
      firebaseAuthWithGoogle(account);
    }
 else {
      onDisconnected();
      Log.w(TAG,""String_Node_Str"" + result.getStatus());
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{result.getStatus().getStatusMessage()});
    }
  }
}","public void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == GodotAndroidRequest.GOOGLE_AUTHENTICATION_REQUEST) {
    GoogleSignInResult result=Auth.GoogleSignInApi.getSignInResultFromIntent(data);
    if (result != null && result.isSuccess()) {
      GoogleSignInAccount account=result.getSignInAccount();
      firebaseAuthWithGoogle(account);
    }
 else {
      onDisconnected();
      Log.w(TAG,""String_Node_Str"" + result.getStatus());
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{result.getStatus().getStatusMessage()});
    }
  }
}"
70621,"public void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == GodotAndroidRequest.GODOT_SHARE_REQUEST) {
    if (resultCode == activity.RESULT_OK) {
      Log.e(TAG,""String_Node_Str"");
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
    }
 else {
      String message=""String_Node_Str"" + resultCode;
      Log.e(TAG,message);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
    }
  }
}","public void onActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == GodotAndroidRequest.GODOT_SHARE_REQUEST) {
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  }
}"
70622,"public void onConnected(){
  if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
    Games.getGamesClient(activity,mAccount).setViewForPopups(activity.getWindow().getDecorView().findViewById(android.R.id.content));
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    googlePlayer.load_current_player();
  }
}","public synchronized void onConnected(){
  if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
    Games.getGamesClient(activity,mAccount).setViewForPopups(activity.getWindow().getDecorView().findViewById(android.R.id.content));
    GooglePlayer googlePlayer=GooglePlayer.getInstance(activity);
    googlePlayer.load_current_player();
  }
}"
70623,"public void onDisconnected(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
    Log.i(TAG,""String_Node_Str"");
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  }
}","public synchronized void onDisconnected(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
    Log.i(TAG,""String_Node_Str"");
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  }
}"
70624,"public String godot_get_country_code_iso(){
  try {
    final TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
    final String simCountry=telephonyManager.getSimCountryIso();
    if (simCountry != null && simCountry.length() == 2) {
      return simCountry.toLowerCase(Locale.US);
    }
 else     if (telephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_CDMA) {
      String networkCountry=telephonyManager.getNetworkCountryIso();
      if (networkCountry != null && networkCountry.length() == 2) {
        return networkCountry.toLowerCase(Locale.US);
      }
    }
  }
 catch (  Exception ex) {
    Log.i(TAG,""String_Node_Str"" + ex.getMessage());
  }
  return ""String_Node_Str"";
}","public String godot_get_country_code_iso(){
  try {
    final TelephonyManager telephonyManager=(TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
    if (telephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_CDMA) {
      String networkCountry=telephonyManager.getNetworkCountryIso();
      if (networkCountry != null && networkCountry.length() == 2) {
        return networkCountry.toLowerCase(Locale.US);
      }
    }
    final String simCountry=telephonyManager.getSimCountryIso();
    if (simCountry != null && simCountry.length() == 2) {
      return simCountry.toLowerCase(Locale.US);
    }
  }
 catch (  Exception ex) {
    Log.i(TAG,""String_Node_Str"" + ex.getMessage());
  }
  return ""String_Node_Str"";
}"
70625,"private void firebaseAuthWithGoogle(final GoogleSignInAccount account){
  AuthCredential credential=GoogleAuthProvider.getCredential(account.getIdToken(),null);
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    for (    UserInfo userInfo : firebaseUser.getProviderData()) {
      if (userInfo.getProviderId().equals(GoogleAuthProvider.PROVIDER_ID)) {
        if (userInfo.getUid().equals(account.getId())) {
          Log.i(TAG,""String_Node_Str"");
          onConnected();
        }
 else {
          String message=""String_Node_Str"" + userInfo.getUid() + ""String_Node_Str""+ account.getId()+ ""String_Node_Str"";
          Log.w(TAG,message);
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          onDisconnected();
        }
        return;
      }
    }
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        mAccount=account;
        onConnected();
      }
 else {
        String message=task.getException().getMessage();
        Log.w(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
        onDisconnected();
      }
    }
  }
);
}","private void firebaseAuthWithGoogle(final GoogleSignInAccount account){
  AuthCredential credential=GoogleAuthProvider.getCredential(account.getIdToken(),null);
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    for (    UserInfo userInfo : firebaseUser.getProviderData()) {
      if (userInfo.getProviderId().equals(GoogleAuthProvider.PROVIDER_ID)) {
        if (userInfo.getUid().equals(account.getId())) {
          Log.i(TAG,""String_Node_Str"");
          mAccount=account;
          onConnected();
        }
 else {
          String message=""String_Node_Str"" + userInfo.getUid() + ""String_Node_Str""+ account.getId()+ ""String_Node_Str"";
          Log.w(TAG,message);
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          onDisconnected();
        }
        return;
      }
    }
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        mAccount=account;
        onConnected();
      }
 else {
        String message=task.getException().getMessage();
        Log.w(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
        onDisconnected();
      }
    }
  }
);
}"
70626,"@Override public void onMessageReceived(RemoteMessage remoteMessage){
  RemoteMessage.Notification notification=remoteMessage.getNotification();
  if (notification != null) {
    Map<String,String> payloadMap=remoteMessage.getData();
    Dictionary payload=new Dictionary();
    payload.putAll(payloadMap);
    String title=notification.getTitle();
    String body=notification.getBody();
    String tag=notification.getTag();
    String link=notification.getLink().toString();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{title,body,tag,link,payload});
  }
}","@Override public void onMessageReceived(RemoteMessage remoteMessage){
}"
70627,"private void firebaseAuthWithFacebook(final AccessToken accessToken){
  Log.d(TAG,""String_Node_Str"");
  AuthCredential credential=FacebookAuthProvider.getCredential(accessToken.getToken());
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
          FirebaseUser firebaseUser=mAuth.getCurrentUser();
          Log.d(TAG,""String_Node_Str"");
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
        }
      }
 else {
        if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
          Log.w(TAG,task.getException());
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().toString()});
        }
      }
    }
  }
);
}","private void firebaseAuthWithFacebook(final AccessToken accessToken){
  Log.d(TAG,""String_Node_Str"");
  AuthCredential credential=FacebookAuthProvider.getCredential(accessToken.getToken());
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    for (    UserInfo userInfo : firebaseUser.getProviderData()) {
      if (userInfo.getProviderId().equals(FacebookAuthProvider.PROVIDER_ID)) {
        if (userInfo.getUid().equals(accessToken.getUserId())) {
          onConnected();
        }
 else {
          onConnectionFailed(""String_Node_Str"" + userInfo.getUid() + ""String_Node_Str""+ accessToken.getUserId()+ ""String_Node_Str"");
        }
        return;
      }
    }
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  if (authResultTask != null) {
    authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
      @Override public void onComplete(      @NonNull Task<AuthResult> task){
        if (task.isSuccessful()) {
          onConnected();
        }
 else {
          onConnectionFailed(task.getException().toString());
        }
      }
    }
);
  }
 else {
    onConnected();
  }
}"
70628,"public void onStart(){
  if (updateConnectionStatus(GodotConnectStatus.CONNECTING)) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        Log.d(TAG,""String_Node_Str"");
        AccessToken accessToken=AccessToken.getCurrentAccessToken();
        if (accessToken != null && !accessToken.isExpired()) {
          firebaseAuthWithFacebook(accessToken);
        }
 else {
          updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
          Log.d(TAG,""String_Node_Str"");
        }
        return null;
      }
    }
;
    task.execute();
  }
}","public void onStart(){
  if (updateConnectionStatus(GodotConnectStatus.CONNECTING)) {
    AsyncTask<Void,Void,Void> task=new AsyncTask<Void,Void,Void>(){
      @Override protected Void doInBackground(      Void... params){
        Log.d(TAG,""String_Node_Str"");
        AccessToken accessToken=AccessToken.getCurrentAccessToken();
        if (accessToken != null && !accessToken.isExpired()) {
          firebaseAuthWithFacebook(accessToken);
        }
 else {
          refreshToken();
        }
        return null;
      }
    }
;
    task.execute();
  }
}"
70629,"@Override protected Void doInBackground(Void... params){
  Log.d(TAG,""String_Node_Str"");
  AccessToken accessToken=AccessToken.getCurrentAccessToken();
  if (accessToken != null && !accessToken.isExpired()) {
    firebaseAuthWithFacebook(accessToken);
  }
 else {
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
    Log.d(TAG,""String_Node_Str"");
  }
  return null;
}","@Override protected Void doInBackground(Void... params){
  Log.d(TAG,""String_Node_Str"");
  AccessToken accessToken=AccessToken.getCurrentAccessToken();
  if (accessToken != null && !accessToken.isExpired()) {
    firebaseAuthWithFacebook(accessToken);
  }
 else {
    refreshToken();
  }
  return null;
}"
70630,"@Override public void onMessageReceived(RemoteMessage remoteMessage){
  RemoteMessage.Notification notification=remoteMessage.getNotification();
  if (notification != null) {
    Map<String,String> payloadMap=remoteMessage.getData();
    Dictionary payload=new Dictionary();
    payload.putAll(payloadMap);
    String title=notification.getTitle();
    String body=notification.getBody();
    String tag=notification.getTag();
    Uri link_uri=notification.getLink();
    String link=""String_Node_Str"";
    if (link_uri != null) {
      link=link_uri.toString();
    }
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{title,body,tag,link,payload});
  }
}","@Override public void onMessageReceived(RemoteMessage remoteMessage){
  RemoteMessage.Notification notification=remoteMessage.getNotification();
  if (notification != null) {
    Map<String,String> payloadMap=remoteMessage.getData();
    Dictionary payload=new Dictionary();
    payload.putAll(payloadMap);
    String title=notification.getTitle();
    String body=notification.getBody();
    Log.d(TAG,""String_Node_Str"" + title + ""String_Node_Str""+ body+ ""String_Node_Str""+ payload);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{title,body,payload});
  }
}"
70631,"public FirebaseCurrentNotification(Activity p_activity){
  activity=p_activity;
  mAuth=FirebaseAuth.getInstance();
}","public FirebaseCurrentNotification(Activity p_activity){
  activity=p_activity;
}"
70632,"@Override public void onMessageReceived(RemoteMessage remoteMessage){
  Bundle notification=remoteMessage.getNotification();
  if (notification != null) {
    Map<String,String> payloadMap=remoteMessage.getData();
    Dictionary payload=new Dictionary();
    payload.putAll(payloadMap);
    String title=notification.geTitle();
    String body=notification.getBody();
    String tag=notification.getTag();
    String link=notification.getLink().toString();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{title,body,tag,link,payload});
  }
}","@Override public void onMessageReceived(RemoteMessage remoteMessage){
  RemoteMessage.Notification notification=remoteMessage.getNotification();
  if (notification != null) {
    Map<String,String> payloadMap=remoteMessage.getData();
    Dictionary payload=new Dictionary();
    payload.putAll(payloadMap);
    String title=notification.getTitle();
    String body=notification.getBody();
    String tag=notification.getTag();
    String link=notification.getLink().toString();
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{title,body,tag,link,payload});
  }
}"
70633,"public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    Log.d(TAG,""String_Node_Str"");
    mLoginManager.logOut();
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  }
}","public void disconnect(){
  if (updateConnectionStatus(GodotConnectStatus.DISCONNECTING)) {
    Log.d(TAG,""String_Node_Str"");
    mLoginManager.logOut();
    FirebaseUser firebaseUser=mAuth.getCurrentUser();
    if (firebaseUser != null) {
      firebaseUser.unlink(FacebookAuthProvider.PROVIDER_ID).addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
        @Override public void onComplete(        @NonNull Task<AuthResult> task){
          if (task.isSuccessful()) {
            updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
          }
 else {
            String message=task.getException().getMessage();
            Log.w(TAG,""String_Node_Str"" + task.getException());
            updateConnectionStatus(GodotConnectStatus.CONNECTED);
            GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
          }
        }
      }
);
    }
 else {
      updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
    }
  }
}"
70634,"@Override public void onComplete(@NonNull Task<AuthResult> task){
  if (task.isSuccessful()) {
    if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
      FirebaseUser firebaseUser=mAuth.getCurrentUser();
      Log.d(TAG,""String_Node_Str"");
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
    }
  }
 else {
    if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
      Log.w(TAG,task.getException());
      GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().toString()});
    }
  }
}","@Override public void onComplete(@NonNull Task<AuthResult> task){
  if (task.isSuccessful()) {
    updateConnectionStatus(GodotConnectStatus.DISCONNECTED);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{});
  }
 else {
    String message=task.getException().getMessage();
    Log.w(TAG,""String_Node_Str"" + task.getException());
    updateConnectionStatus(GodotConnectStatus.CONNECTED);
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
  }
}"
70635,"private void firebaseAuthWithFacebook(final AccessToken accessToken){
  Log.d(TAG,""String_Node_Str"");
  AuthCredential credential=FacebookAuthProvider.getCredential(accessToken.getToken());
  mAuth.signInWithCredential(credential).addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
          FirebaseUser firebaseUser=mAuth.getCurrentUser();
          Log.d(TAG,""String_Node_Str"");
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
        }
      }
 else {
        if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
          Log.w(TAG,task.getException());
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().toString()});
        }
      }
    }
  }
);
}","private void firebaseAuthWithFacebook(final AccessToken accessToken){
  Log.d(TAG,""String_Node_Str"");
  AuthCredential credential=FacebookAuthProvider.getCredential(accessToken.getToken());
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        if (updateConnectionStatus(GodotConnectStatus.CONNECTED)) {
          FirebaseUser firebaseUser=mAuth.getCurrentUser();
          Log.d(TAG,""String_Node_Str"");
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{firebaseUser.getDisplayName()});
        }
      }
 else {
        if (updateConnectionStatus(GodotConnectStatus.DISCONNECTED)) {
          Log.w(TAG,task.getException());
          GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{task.getException().toString()});
        }
      }
    }
  }
);
}"
70636,"private void firebaseAuthWithGoogle(final GoogleSignInAccount account){
  AuthCredential credential=GoogleAuthProvider.getCredential(account.getIdToken(),null);
  mAuth.signInWithCredential(credential).addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        mAccount=account;
        onConnected();
      }
 else {
        String message=task.getException().getMessage();
        Log.w(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
        onDisconnected();
      }
    }
  }
);
}","private void firebaseAuthWithGoogle(final GoogleSignInAccount account){
  AuthCredential credential=GoogleAuthProvider.getCredential(account.getIdToken(),null);
  FirebaseUser firebaseUser=mAuth.getCurrentUser();
  Task<AuthResult> authResultTask;
  if (firebaseUser != null) {
    authResultTask=firebaseUser.linkWithCredential(credential);
  }
 else {
    authResultTask=mAuth.signInWithCredential(credential);
  }
  authResultTask.addOnCompleteListener(activity,new OnCompleteListener<AuthResult>(){
    @Override public void onComplete(    @NonNull Task<AuthResult> task){
      if (task.isSuccessful()) {
        mAccount=account;
        onConnected();
      }
 else {
        String message=task.getException().getMessage();
        Log.w(TAG,""String_Node_Str"" + task.getException());
        GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{message});
        onDisconnected();
      }
    }
  }
);
}"
70637,"@Override public void onMessageReceived(RemoteMessage remoteMessage){
}","@Override public void onMessageReceived(RemoteMessage remoteMessage){
  RemoteMessage.Notification notification=remoteMessage.getNotification();
  if (notification != null) {
    Map<String,String> payloadMap=remoteMessage.getData();
    Dictionary payload=new Dictionary();
    payload.putAll(payloadMap);
    String title=notification.getTitle();
    String body=notification.getBody();
    String tag=notification.getTag();
    Uri link_uri=notification.getLink();
    String link=""String_Node_Str"";
    if (link_uri != null) {
      link=link_uri.toString();
    }
    GodotLib.calldeferred(instance_id,""String_Node_Str"",new Object[]{title,body,tag,link,payload});
  }
}"
70638,"private static void appendAttributeValue(StringBuilder buffer,Object value){
  if (value instanceof String) {
    char[] v=value.toString().replace('\n',' ').replace('\r',' ').replace(""String_Node_Str"",""String_Node_Str"").toCharArray();
    logCharTypes(v);
    char[] decoded=new char[v.length];
    for (int i=0; i < v.length; i++) {
      decoded[i]=toPrintable(v[i]);
    }
    buffer.append(decoded);
  }
 else {
    buffer.append(value.getClass().getName());
  }
}","private static void appendAttributeValue(StringBuilder buffer,Object value){
  if (value instanceof String) {
    char[] v=value.toString().replace('\n',' ').replace('\r',' ').replace(""String_Node_Str"",""String_Node_Str"").toCharArray();
    logCharTypes(v);
    char[] decoded=new char[v.length];
    for (int i=0; i < v.length; i++) {
      logCharType(v[i]);
      decoded[i]=toPrintable(v[i]);
    }
    buffer.append(decoded);
  }
 else {
    buffer.append(value.getClass().getName());
  }
}"
70639,"public String getTableName(){
  return this.getClass().getSimpleName();
}","public String getTableName(){
  return this.getClass().getSimpleName().toLowerCase();
}"
70640,"protected <T extends Model>ArrayList<T> hasMany(Class<T> theClass) throws ModelException {
  try {
    return hasMany(theClass,this.getClass().getSimpleName() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    throw new ModelException(""String_Node_Str"");
  }
}","protected <T extends Model>ArrayList<T> hasMany(Class<T> theClass) throws ModelException {
  try {
    return hasMany(theClass,this.getClass().getSimpleName().toLowerCase() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    throw new ModelException(""String_Node_Str"");
  }
}"
70641,"@Override public synchronized void run(){
  logSize=logSize + m_logStr.length();
  logOutView.append(m_logStr);
  if (logSize >= 20000) {
    String logStr=logOutView.getText().toString();
    logStr=logStr.substring(logSize - 10000);
    logSize=logStr.length();
    logOutView.setText(logStr);
  }
  logOutView.setSelection(logSize);
  scrollView.fullScroll(ScrollView.FOCUS_DOWN);
  setTitle(""String_Node_Str"" + DNSFilterService.openConnectionsCount() + ""String_Node_Str"");
  dnsField.setText(DNSCommunicator.getInstance().getLastDNSAddress());
}","@Override public synchronized void run(){
  logSize=logSize + m_logStr.length();
  logOutView.append(m_logStr);
  if (logSize >= 20000) {
    String logStr=logOutView.getText().toString();
    logStr=logStr.substring(logSize - 10000);
    logSize=logStr.length();
    logOutView.setText(logStr);
  }
  logOutView.setSelection(logOutView.getText().length());
  scrollView.fullScroll(ScrollView.FOCUS_DOWN);
  setTitle(""String_Node_Str"" + DNSFilterService.openConnectionsCount() + ""String_Node_Str"");
  dnsField.setText(DNSCommunicator.getInstance().getLastDNSAddress());
}"
70642,"@Override public void onClick(View destination){
  persistConfig();
  if (destination == startBtn)   handleStart();
  if (destination == stopBtn)   handleStop();
  if (destination == reloadFilterBtn)   handlefilterReload();
  if (destination == advancedConfigCheck || destination == editAdditionalHostsCheck || destination == editFilterLoadCheck) {
    handleAdvancedConfig();
  }
  if (destination == keepAwakeCheck) {
    if (keepAwakeCheck.isChecked()) {
      wifiLock=((WifiManager)getApplicationContext().getSystemService(Context.WIFI_SERVICE)).createWifiLock(WifiManager.WIFI_MODE_FULL,""String_Node_Str"");
      wifiLock.acquire();
      wakeLock=((PowerManager)getSystemService(Context.POWER_SERVICE)).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      wakeLock.acquire();
      Logger.getLogger().logLine(""String_Node_Str"");
    }
 else {
      if (wifiLock != null && wakeLock != null) {
        wifiLock.release();
        wakeLock.release();
        wifiLock=null;
        wakeLock=null;
        Logger.getLogger().logLine(""String_Node_Str"");
      }
    }
  }
}","@Override public void onClick(View destination){
  persistConfig();
  if (destination == startBtn || destination == enableAdFilterCheck)   handleStart();
  if (destination == stopBtn)   handleStop();
  if (destination == reloadFilterBtn)   handlefilterReload();
  if (destination == advancedConfigCheck || destination == editAdditionalHostsCheck || destination == editFilterLoadCheck) {
    handleAdvancedConfig();
  }
  if (destination == keepAwakeCheck) {
    if (keepAwakeCheck.isChecked()) {
      wifiLock=((WifiManager)getApplicationContext().getSystemService(Context.WIFI_SERVICE)).createWifiLock(WifiManager.WIFI_MODE_FULL,""String_Node_Str"");
      wifiLock.acquire();
      wakeLock=((PowerManager)getSystemService(Context.POWER_SERVICE)).newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      wakeLock.acquire();
      Logger.getLogger().logLine(""String_Node_Str"");
    }
 else {
      if (wifiLock != null && wakeLock != null) {
        wifiLock.release();
        wakeLock.release();
        wifiLock=null;
        wakeLock=null;
        Logger.getLogger().logLine(""String_Node_Str"");
      }
    }
  }
}"
70643,"private String getFormattedAdvCfgText(Properties config){
  String advCfg=""String_Node_Str"";
  String filterReloadURL=config.getProperty(""String_Node_Str"",""String_Node_Str"");
  StringTokenizer urlTokens=new StringTokenizer(filterReloadURL,""String_Node_Str"");
  int urlCnt=urlTokens.countTokens();
  for (int i=0; i < urlCnt; i++) {
    String url=urlTokens.nextToken().trim();
    advCfg=advCfg + ""String_Node_Str"" + url;
    if (i < urlCnt)     advCfg=advCfg + ""String_Node_Str"";
  }
  advCfg=advCfg + ""String_Node_Str"" + config.getProperty(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  return advCfg;
}","private String getFormattedAdvCfgText(Properties config){
  String advCfg=""String_Node_Str"";
  String filterReloadURL=config.getProperty(""String_Node_Str"",""String_Node_Str"");
  StringTokenizer urlTokens=new StringTokenizer(filterReloadURL,""String_Node_Str"");
  int urlCnt=urlTokens.countTokens();
  for (int i=0; i < urlCnt; i++) {
    String url=urlTokens.nextToken().trim();
    advCfg=advCfg + ""String_Node_Str"" + url;
    if (i + 1 < urlCnt)     advCfg=advCfg + ""String_Node_Str"";
 else     advCfg=advCfg + ""String_Node_Str"";
  }
  advCfg=advCfg + ""String_Node_Str"" + config.getProperty(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"";
  return advCfg;
}"
70644,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_detail);
  MAX_DRAG=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,150,getResources().getDisplayMetrics());
  detail=getIntent().getParcelableExtra(PAR_DETAIL);
  initViews();
  pager.setAdapter(new InfoPageAdapter(getSupportFragmentManager(),detail.detailInfoPages()));
  tabStrip.setViewPager(pager);
  mainLay.addDragView(iv_icon,iv_icon_cover);
  mainLay.setDragController(new DraggableConstraintLayout.DragController(){
    @Override public void onDragDrop(    View view,    boolean captured){
    }
    @Override public void onDrag(    int dy){
      Log.d(TAG,""String_Node_Str"" + dy + ""String_Node_Str"");
      if (dy > 0 && dy <= MAX_DRAG) {
        iv_cover.setRampDy(dy);
      }
    }
  }
);
  bindViews();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_detail);
  MAX_DRAG=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,150,getResources().getDisplayMetrics());
  detail=getIntent().getParcelableExtra(PAR_DETAIL);
  initViews();
  pager.setAdapter(new InfoPageAdapter(getSupportFragmentManager(),detail.detailInfoPages()));
  tabStrip.setViewPager(pager);
  mainLay.addDragView(iv_icon,iv_icon_cover);
  mainLay.setDragController(new DraggableConstraintLayout.DragController(){
    @Override public void onDragDrop(    View view,    boolean captured){
    }
    @Override public void onDrag(    int dy){
      Log.d(TAG,""String_Node_Str"" + dy + ""String_Node_Str"");
      if (dy > 0 && dy <= MAX_DRAG) {
        iv_cover.setRampDy(dy);
        cv.setTranslationY(dy);
      }
    }
  }
);
  bindViews();
}"
70645,"@Override public void onDrag(int dy){
  Log.d(TAG,""String_Node_Str"" + dy + ""String_Node_Str"");
  if (dy > 0 && dy <= MAX_DRAG) {
    iv_cover.setRampDy(dy);
  }
}","@Override public void onDrag(int dy){
  Log.d(TAG,""String_Node_Str"" + dy + ""String_Node_Str"");
  if (dy > 0 && dy <= MAX_DRAG) {
    iv_cover.setRampDy(dy);
    cv.setTranslationY(dy);
  }
}"
70646,"@Override public void requestLayout(){
  super.requestLayout();
  if (releasedChild != null && startX != 0) {
    Log.d(TAG,""String_Node_Str"");
    releasedChild.post(() -> {
      mDragViewCover.setVisibility(INVISIBLE);
      releasedChild.setVisibility(VISIBLE);
      releasedChild.setX(startX);
      releasedChild.setY(startY);
      releasedChild.setTranslationX(startTX);
      releasedChild.setTranslationX(startTY);
    }
);
  }
}","@Override public void requestLayout(){
  super.requestLayout();
  if (releasedChild != null && startX != 0) {
    Log.d(TAG,""String_Node_Str"");
    releasedChild.post(() -> {
      mDragViewCover.setVisibility(INVISIBLE);
      releasedChild.setVisibility(VISIBLE);
      releasedChild.setX(startX);
      releasedChild.setY(startY);
      for (int i=0; i < getChildCount(); i++) {
        getChildAt(i).setTranslationY(0);
        getChildAt(i).setTranslationX(0);
      }
    }
);
  }
}"
70647,"@Override public void actionPerformed(ActionEvent e){
  if (!myMasked) {
    Font base=(Font)myComboBox.getSelectedItem();
    Float f=(Float)(myFontSize.getSelectedItem());
    int size=(int)f.intValue();
    int style=0;
    if (myBold.isSelected()) {
      style|=Font.BOLD;
    }
    if (myItalic.isSelected()) {
      style|=Font.ITALIC;
    }
    Font value=base.deriveFont(style,size);
    Object validValue=validateValue(value,null);
    if (validValue != value) {
      updateDisplay();
    }
    if (updateValue(validValue)) {
      updateDisplay();
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
  if (!myMasked) {
    Font base=(Font)myComboBox.getSelectedItem();
    int size=(int)((Number)(myFontSize.getSelectedItem())).intValue();
    int style=0;
    if (myBold.isSelected()) {
      style|=Font.BOLD;
    }
    if (myItalic.isSelected()) {
      style|=Font.ITALIC;
    }
    Font value=base.deriveFont(style,size);
    Object validValue=validateValue(value,null);
    if (validValue != value) {
      updateDisplay();
    }
    if (updateValue(validValue)) {
      updateDisplay();
    }
  }
}"
70648,"public FontField(String label){
  super(label,new JComboBox<Font>());
  myBold=new JToggleButton(""String_Node_Str"");
  myBold.setFont(new Font(Font.SERIF,Font.BOLD,myBold.getFont().getSize()));
  myItalic=new JToggleButton(""String_Node_Str"");
  myItalic.setFont(new Font(Font.SERIF,Font.ITALIC,myItalic.getFont().getSize()));
  myFontSize=new JComboBox<Integer>();
  int[] fontSizes={8,9,10,11,12,14,16,18,20,22,24,26,28,32,36,48,64,72};
  myFontSize.setSelectedItem(DEFAULT_FONT_SIZE);
  Dimension dim=myFontSize.getPreferredSize();
  myFontSize.setPreferredSize(new Dimension(48,(int)(dim.getHeight())));
  for (  int i : fontSizes) {
    myFontSize.addItem(i);
  }
  myFontSize.setEditable(true);
  super.add(myFontSize);
  super.add(myBold);
  super.add(myItalic);
  Font[] systemFonts=GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
  ArrayList<Font> fonts=new ArrayList<Font>(systemFonts.length + 3);
  fonts.add(new Font(Font.SERIF,0,FONT_DISPLAY_SIZE));
  fonts.add(new Font(Font.SANS_SERIF,0,FONT_DISPLAY_SIZE));
  fonts.add(new Font(Font.MONOSPACED,0,FONT_DISPLAY_SIZE));
  for (  Font f : systemFonts) {
    fonts.add(f.deriveFont((float)FONT_DISPLAY_SIZE));
  }
  @SuppressWarnings(""String_Node_Str"") JComboBox<Font> fontBox=(JComboBox<Font>)getMajorComponent(label == null ? 0 : 1);
  myComboBox=fontBox;
  myComboBox.setRenderer(new DefaultListCellRenderer(){
    private static final long serialVersionUID=-755738510066156775L;
    @Override public Component getListCellRendererComponent(    JList<?> list,    Object value,    int index,    boolean isSelected,    boolean cellHasFocus){
      Font font=null;
      if (value != null) {
        font=(Font)value;
        value=font.getName();
      }
      Component comp=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
      if (font != null) {
        comp.setFont(font);
      }
      return comp;
    }
  }
);
  for (  Font f : fonts) {
    myComboBox.addItem(f);
  }
  dim=myComboBox.getPreferredSize();
  myComboBox.setPreferredSize(dim);
  myComboBox.repaint();
  fontBase=fonts.get(0);
  fontSize=DEFAULT_FONT_SIZE;
  fontStyle=DEFAULT_FONT_STYLE;
  updateDisplay();
  ActionListener fontUpdate=new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!myMasked) {
        Font base=(Font)myComboBox.getSelectedItem();
        Float f=(Float)(myFontSize.getSelectedItem());
        int size=(int)f.intValue();
        int style=0;
        if (myBold.isSelected()) {
          style|=Font.BOLD;
        }
        if (myItalic.isSelected()) {
          style|=Font.ITALIC;
        }
        Font value=base.deriveFont(style,size);
        Object validValue=validateValue(value,null);
        if (validValue != value) {
          updateDisplay();
        }
        if (updateValue(validValue)) {
          updateDisplay();
        }
      }
    }
  }
;
  myComboBox.addActionListener(fontUpdate);
  myComboBox.setFocusable(false);
  myFontSize.addActionListener(fontUpdate);
  myFontSize.setFocusable(false);
  myBold.addActionListener(fontUpdate);
  myBold.setFocusable(false);
  myItalic.addActionListener(fontUpdate);
  myItalic.setFocusable(false);
}","public FontField(String label){
  super(label,new JComboBox<Font>());
  myBold=new JToggleButton(""String_Node_Str"");
  myBold.setFont(new Font(Font.SERIF,Font.BOLD,myBold.getFont().getSize()));
  myItalic=new JToggleButton(""String_Node_Str"");
  myItalic.setFont(new Font(Font.SERIF,Font.ITALIC,myItalic.getFont().getSize()));
  myFontSize=new JComboBox<Integer>();
  int[] fontSizes={8,9,10,11,12,14,16,18,20,22,24,26,28,32,36,48,64,72};
  myFontSize.setSelectedItem(DEFAULT_FONT_SIZE);
  Dimension dim=myFontSize.getPreferredSize();
  myFontSize.setPreferredSize(new Dimension(48,(int)(dim.getHeight())));
  for (  int i : fontSizes) {
    myFontSize.addItem(i);
  }
  myFontSize.setEditable(true);
  super.add(myFontSize);
  super.add(myBold);
  super.add(myItalic);
  Font[] systemFonts=GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
  ArrayList<Font> fonts=new ArrayList<Font>(systemFonts.length + 3);
  fonts.add(new Font(Font.SERIF,0,FONT_DISPLAY_SIZE));
  fonts.add(new Font(Font.SANS_SERIF,0,FONT_DISPLAY_SIZE));
  fonts.add(new Font(Font.MONOSPACED,0,FONT_DISPLAY_SIZE));
  for (  Font f : systemFonts) {
    fonts.add(f.deriveFont((float)FONT_DISPLAY_SIZE));
  }
  @SuppressWarnings(""String_Node_Str"") JComboBox<Font> fontBox=(JComboBox<Font>)getMajorComponent(label == null ? 0 : 1);
  myComboBox=fontBox;
  myComboBox.setRenderer(new DefaultListCellRenderer(){
    private static final long serialVersionUID=-755738510066156775L;
    @Override public Component getListCellRendererComponent(    JList<?> list,    Object value,    int index,    boolean isSelected,    boolean cellHasFocus){
      Font font=null;
      if (value != null) {
        font=(Font)value;
        value=font.getName();
      }
      Component comp=super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
      if (font != null) {
        comp.setFont(font);
      }
      return comp;
    }
  }
);
  for (  Font f : fonts) {
    myComboBox.addItem(f);
  }
  dim=myComboBox.getPreferredSize();
  myComboBox.setPreferredSize(dim);
  myComboBox.repaint();
  fontBase=fonts.get(0);
  fontSize=DEFAULT_FONT_SIZE;
  fontStyle=DEFAULT_FONT_STYLE;
  updateDisplay();
  ActionListener fontUpdate=new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!myMasked) {
        Font base=(Font)myComboBox.getSelectedItem();
        int size=(int)((Number)(myFontSize.getSelectedItem())).intValue();
        int style=0;
        if (myBold.isSelected()) {
          style|=Font.BOLD;
        }
        if (myItalic.isSelected()) {
          style|=Font.ITALIC;
        }
        Font value=base.deriveFont(style,size);
        Object validValue=validateValue(value,null);
        if (validValue != value) {
          updateDisplay();
        }
        if (updateValue(validValue)) {
          updateDisplay();
        }
      }
    }
  }
;
  myComboBox.addActionListener(fontUpdate);
  myComboBox.setFocusable(false);
  myFontSize.addActionListener(fontUpdate);
  myFontSize.setFocusable(false);
  myBold.addActionListener(fontUpdate);
  myBold.setFocusable(false);
  myItalic.addActionListener(fontUpdate);
  myItalic.setFocusable(false);
}"
70649,"/** 
 * Sqrt-3 subdivision
 * @param mesh mesh to subdivide
 * @param even set first iteration to an ""even"" split, where borders are not divided
 * @param niters number of iterations
 */
public static void sqrt3Subdivide(PolygonalMesh mesh,boolean even,int niters){
  if (!mesh.isTriangular()) {
    mesh.triangulate();
  }
  boolean splitBorders=!even;
  ArrayList<VertexData> vdata=new ArrayList<VertexData>(mesh.numVertices());
  HashMap<Vertex3d,HashSet<Vertex3d>> borderNeighbors=new HashMap<>();
  for (  Vertex3d vtx : mesh.getVertices()) {
    Vertex3d[] nbrs=new Vertex3d[2];
    int nborders=0;
    HalfEdgeNode hen=vtx.incidentHedges;
    while (hen != null) {
      HalfEdge he=hen.he;
      if (isBorderEdge(he)) {
        if (nborders == 0) {
          nbrs[0]=he.tail;
          ++nborders;
        }
 else         if (nborders == 1) {
          if (he.tail != nbrs[0]) {
            nbrs[1]=he.tail;
            ++nborders;
          }
        }
 else {
          ++nborders;
          break;
        }
      }
      if (he.next.opposite == null) {
        if (nborders == 0) {
          nbrs[0]=he.next.head;
          ++nborders;
        }
 else         if (nborders == 1) {
          if (he.next.head != nbrs[0]) {
            nbrs[1]=he.next.head;
            ++nborders;
          }
        }
 else {
          ++nborders;
          break;
        }
      }
      hen=hen.next;
    }
    if (nborders == 0) {
      vdata.add(new CentralVertexData(vtx));
    }
 else     if (nborders == 1) {
      vdata.add(new BorderVertexData(null,vtx,nbrs[0]));
    }
 else     if (nborders == 2) {
      vdata.add(new BorderVertexData(nbrs[0],vtx,nbrs[1]));
    }
 else {
      vdata.add(new BorderVertexData(null,vtx,null));
    }
  }
  for (  Face face : mesh.getFaces()) {
    HalfEdge he0=face.he0;
    HalfEdge he=he0;
    do {
      he.clearVisited();
      he=he.next;
    }
 while (he != he0);
  }
  for (int k=0; k < niters; ++k) {
    int oldNumVertices=mesh.numVertices();
    int nFaces=mesh.numFaces();
    for (int i=0; i < nFaces; ++i) {
      Face face=mesh.getFace(i);
      if (splitBorders && isBorderEdge(face.he0)) {
        HalfEdge he=face.he0;
        if (he.opposite == null || he.opposite.face.getIndex() < face.getIndex()) {
          Vertex3d head=he.head;
          Vertex3d tail=he.tail;
          BorderVertexData headData=(BorderVertexData)vdata.get(head.getIndex());
          BorderVertexData tailData=(BorderVertexData)vdata.get(tail.getIndex());
          Vertex3d left=tailData.getOtherNeighbour(head);
          Vertex3d right=headData.getOtherNeighbour(tail);
          HalfEdge be0=edgeSplit3(face.he0);
          HalfEdge be1=be0.next.opposite.next;
          HalfEdge be2=be1.next.opposite.next;
          if (left != null) {
            Point3d b0=be0.head.getPosition();
            Point3d lpos=left.getPosition();
            Point3d cpos=tail.getPosition();
            Point3d rpos=head.getPosition();
            b0.x=(1.0 * lpos.x + 16.0 * cpos.x + 10.0 * rpos.x) / 27.0;
            b0.y=(1.0 * lpos.y + 16.0 * cpos.y + 10.0 * rpos.y) / 27.0;
            b0.z=(1.0 * lpos.z + 16.0 * cpos.z + 10.0 * rpos.z) / 27.0;
          }
          if (right != null) {
            Point3d b1=be1.head.getPosition();
            Point3d lpos=tail.getPosition();
            Point3d cpos=head.getPosition();
            Point3d rpos=right.getPosition();
            b1.x=(1.0 * rpos.x + 16.0 * cpos.x + 10.0 * lpos.x) / 27.0;
            b1.y=(1.0 * rpos.y + 16.0 * cpos.y + 10.0 * lpos.y) / 27.0;
            b1.z=(1.0 * rpos.z + 16.0 * cpos.z + 10.0 * lpos.z) / 27.0;
          }
          headData.queueNeighbour(tail,be2.tail);
          tailData.queueNeighbour(head,be0.head);
          vdata.add(new BorderVertexData(be0.tail,be0.head,be1.tail));
          vdata.add(new BorderVertexData(be1.tail,be1.head,be2.tail));
        }
      }
 else {
        Vertex3d vtxm=midpointSplit(face);
        vdata.add(new CentralVertexData(vtxm));
      }
    }
    for (    Face f : mesh.getFaces()) {
      HalfEdge he0=f.he0;
      if (!isBorderEdge(he0)) {
        he0.setVisited();
      }
    }
    nFaces=mesh.numFaces();
    for (int i=0; i < nFaces; ++i) {
      Face face=mesh.getFace(i);
      HalfEdge he=face.he0;
      if (he.isVisited() && (he.opposite.face.getIndex() < face.getIndex() || isBorderEdge(he.opposite.face.he0))) {
        rotateEdge(he);
        he.clearVisited();
        he.opposite.clearVisited();
        if (he.face.he0 != he) {
          he.face.he0=he;
        }
        HalfEdge be=he.next;
        do {
          if (isBorderEdge(be)) {
            he.face.he0=be;
            break;
          }
          be=be.next;
        }
 while (be != he);
        HalfEdge te=he.opposite;
        if (te.face.he0 != te) {
          te.face.he0=te;
        }
        be=te.next;
        do {
          if (isBorderEdge(be)) {
            te.face.he0=be;
            break;
          }
          be=be.next;
        }
 while (be != te);
      }
    }
    for (int i=0; i < oldNumVertices; ++i) {
      VertexData dat=vdata.get(i);
      if (splitBorders || !dat.isBorder()) {
        dat.relax();
      }
    }
    splitBorders=!splitBorders;
  }
  mesh.notifyStructureChanged();
  mesh.notifyVertexPositionsModified();
}","/** 
 * Sqrt-3 subdivision
 * @param mesh mesh to subdivide
 * @param even set first iteration to an ""even"" split, where borders are not divided
 * @param niters number of iterations
 */
public static void sqrt3Subdivide(PolygonalMesh mesh,boolean even,int niters){
  if (!mesh.isTriangular()) {
    mesh.triangulate();
  }
  boolean splitBorders=!even;
  ArrayList<VertexData> vdata=new ArrayList<VertexData>(mesh.numVertices());
  HashMap<Vertex3d,HashSet<Vertex3d>> borderNeighbors=new HashMap<>();
  for (  Vertex3d vtx : mesh.getVertices()) {
    Vertex3d[] nbrs=new Vertex3d[2];
    int nborders=0;
    HashSet<Vertex3d> opposites=new HashSet<>();
    HalfEdgeNode hen=vtx.incidentHedges;
    while (hen != null) {
      HalfEdge he=hen.he;
      if (opposites.contains(he.tail)) {
        nborders=-1;
        break;
      }
 else {
        opposites.add(he.tail);
      }
      if (isBorderEdge(he)) {
        if (nborders == 0) {
          nbrs[0]=he.tail;
          ++nborders;
        }
 else         if (nborders == 1) {
          if (he.tail != nbrs[0]) {
            nbrs[1]=he.tail;
            ++nborders;
          }
        }
 else {
          ++nborders;
          break;
        }
      }
      if (he.next.opposite == null) {
        if (opposites.contains(he.next.head)) {
          nborders=-1;
          break;
        }
 else {
          opposites.add(he.next.head);
        }
        if (nborders == 0) {
          nbrs[0]=he.next.head;
          ++nborders;
        }
 else         if (nborders == 1) {
          if (he.next.head != nbrs[0]) {
            nbrs[1]=he.next.head;
            ++nborders;
          }
        }
 else {
          ++nborders;
          break;
        }
      }
      hen=hen.next;
    }
    if (nborders == 0) {
      vdata.add(new CentralVertexData(vtx));
    }
 else     if (nborders == 1) {
      vdata.add(new BorderVertexData(null,vtx,nbrs[0]));
    }
 else     if (nborders == 2) {
      vdata.add(new BorderVertexData(nbrs[0],vtx,nbrs[1]));
    }
 else {
      vdata.add(new BorderVertexData(null,vtx,null));
    }
  }
  for (  Face face : mesh.getFaces()) {
    HalfEdge he0=face.he0;
    HalfEdge he=he0;
    do {
      he.clearVisited();
      he=he.next;
    }
 while (he != he0);
  }
  for (int k=0; k < niters; ++k) {
    int oldNumVertices=mesh.numVertices();
    int nFaces=mesh.numFaces();
    for (int i=0; i < nFaces; ++i) {
      Face face=mesh.getFace(i);
      if (splitBorders && isBorderEdge(face.he0)) {
        HalfEdge he=face.he0;
        if (he.opposite == null || he.opposite.face.getIndex() < face.getIndex()) {
          Vertex3d head=he.head;
          Vertex3d tail=he.tail;
          Vertex3d left=null;
          Vertex3d right=null;
          VertexData vdat=vdata.get(head.getIndex());
          BorderVertexData headData=null;
          if (vdat.isBorder()) {
            headData=(BorderVertexData)vdat;
            right=headData.getOtherNeighbour(tail);
          }
 else {
            System.out.println(""String_Node_Str"" + head.getIndex());
          }
          vdat=vdata.get(tail.getIndex());
          BorderVertexData tailData=null;
          if (vdat.isBorder()) {
            tailData=(BorderVertexData)vdat;
            left=tailData.getOtherNeighbour(head);
          }
 else {
            System.out.println(""String_Node_Str"" + tail.getIndex());
          }
          HalfEdge be0=edgeSplit3(face.he0);
          HalfEdge be1=be0.next.opposite.next;
          HalfEdge be2=be1.next.opposite.next;
          if (left != null) {
            Point3d b0=be0.head.getPosition();
            Point3d lpos=left.getPosition();
            Point3d cpos=tail.getPosition();
            Point3d rpos=head.getPosition();
            b0.x=(1.0 * lpos.x + 16.0 * cpos.x + 10.0 * rpos.x) / 27.0;
            b0.y=(1.0 * lpos.y + 16.0 * cpos.y + 10.0 * rpos.y) / 27.0;
            b0.z=(1.0 * lpos.z + 16.0 * cpos.z + 10.0 * rpos.z) / 27.0;
          }
          if (right != null) {
            Point3d b1=be1.head.getPosition();
            Point3d lpos=tail.getPosition();
            Point3d cpos=head.getPosition();
            Point3d rpos=right.getPosition();
            b1.x=(1.0 * rpos.x + 16.0 * cpos.x + 10.0 * lpos.x) / 27.0;
            b1.y=(1.0 * rpos.y + 16.0 * cpos.y + 10.0 * lpos.y) / 27.0;
            b1.z=(1.0 * rpos.z + 16.0 * cpos.z + 10.0 * lpos.z) / 27.0;
          }
          if (headData != null) {
            headData.queueNeighbour(tail,be2.tail);
          }
          if (tailData != null) {
            tailData.queueNeighbour(head,be0.head);
          }
          vdata.add(new BorderVertexData(be0.tail,be0.head,be1.tail));
          vdata.add(new BorderVertexData(be1.tail,be1.head,be2.tail));
        }
      }
 else {
        Vertex3d vtxm=midpointSplit(face);
        vdata.add(new CentralVertexData(vtxm));
      }
    }
    for (    Face f : mesh.getFaces()) {
      HalfEdge he0=f.he0;
      if (!isBorderEdge(he0)) {
        he0.setVisited();
      }
    }
    nFaces=mesh.numFaces();
    for (int i=0; i < nFaces; ++i) {
      Face face=mesh.getFace(i);
      HalfEdge he=face.he0;
      if (he.isVisited() && (he.opposite.face.getIndex() < face.getIndex() || isBorderEdge(he.opposite.face.he0))) {
        rotateEdge(he);
        he.clearVisited();
        he.opposite.clearVisited();
        if (he.face.he0 != he) {
          he.face.he0=he;
        }
        HalfEdge be=he.next;
        do {
          if (isBorderEdge(be)) {
            he.face.he0=be;
            break;
          }
          be=be.next;
        }
 while (be != he);
        HalfEdge te=he.opposite;
        if (te.face.he0 != te) {
          te.face.he0=te;
        }
        be=te.next;
        do {
          if (isBorderEdge(be)) {
            te.face.he0=be;
            break;
          }
          be=be.next;
        }
 while (be != te);
      }
    }
    for (int i=0; i < oldNumVertices; ++i) {
      VertexData dat=vdata.get(i);
      if (splitBorders || !dat.isBorder()) {
        dat.relax();
      }
    }
    splitBorders=!splitBorders;
  }
  mesh.notifyStructureChanged();
  mesh.notifyVertexPositionsModified();
}"
70650,"private static HalfEdge edgeSplit3(HalfEdge edge){
  Face f=edge.face;
  f.he0=edge;
  Vertex3d head=edge.head;
  Vertex3d tail=edge.tail;
  Vertex3d vtp=edge.next.head;
  HalfEdge edgeOpp=edge.opposite;
  boolean hard=edge.isHard();
  Point3d tpos=tail.getPosition();
  Vector3d dir=new Vector3d(head.getPosition());
  dir.sub(tpos);
  dir.scale(1.0 / 3);
  Vertex3d vt0=new Vertex3d(tpos.x + dir.x,tpos.y + dir.y,tpos.z + dir.z);
  Vertex3d vt1=new Vertex3d(tpos.x + 2 * dir.x,tpos.y + 2 * dir.y,tpos.z + 2 * dir.z);
  PolygonalMesh mesh=f.getMesh();
  mesh.addVertex(vt0);
  mesh.addVertex(vt1);
  if (edgeOpp != null) {
    edge.opposite=null;
    edgeOpp.opposite=null;
    edge.setPrimary(true);
    edgeOpp.setPrimary(true);
    Face of=edgeOpp.getFace();
    Vertex3d ovtp=edgeOpp.next.head;
    if (of.isTriangle()) {
      HalfEdge hprev=edgeOpp.next.next;
      if (hprev.opposite != null) {
        hprev.opposite.setPrimary(true);
        hprev.opposite.opposite=null;
        hprev.opposite=null;
        hprev.setPrimary(true);
      }
      hprev.setHard(false);
      head.removeIncidentHalfEdge(hprev);
      hprev.head=vt0;
      edgeOpp.tail=vt0;
      vt0.addIncidentHalfEdge(hprev);
    }
 else {
      mesh.removeFaceFast(of);
      Face f0=mesh.addFace(tail,ovtp,vt0);
      edgeOpp=f0.he0;
      edgeOpp.setHard(hard);
    }
    Face f1=mesh.addFace(vt1,ovtp,head);
    f1.he0.setHard(hard);
    Face f2=mesh.addFace(vt0,ovtp,vt1);
    f2.he0.setHard(hard);
  }
  if (f.isTriangle()) {
    HalfEdge hnext=edge.next;
    if (hnext.opposite != null) {
      hnext.opposite.setPrimary(true);
      hnext.opposite.opposite=null;
      hnext.opposite=null;
      hnext.setPrimary(true);
    }
    hnext.setHard(false);
    head.removeIncidentHalfEdge(edge);
    edge.head=vt0;
    hnext.tail=vt0;
    vt0.addIncidentHalfEdge(edge);
  }
 else {
    mesh.removeFaceFast(f);
    Face f0=mesh.addFace(vt0,vtp,tail);
    edge=f0.he0;
    edge.setHard(hard);
  }
  Face f1=mesh.addFace(vt1,vtp,vt0);
  f1.he0.setHard(hard);
  Face f2=mesh.addFace(head,vtp,vt1);
  f2.he0.setHard(hard);
  edge.opposite=edgeOpp;
  if (edgeOpp != null) {
    edgeOpp.opposite=edge;
    edgeOpp.setPrimary(false);
  }
  return edge;
}","private static HalfEdge edgeSplit3(HalfEdge edge){
  Face f=edge.face;
  f.he0=edge;
  Vertex3d head=edge.head;
  Vertex3d tail=edge.tail;
  Vertex3d vtp=edge.next.head;
  HalfEdge edgeOpp=edge.opposite;
  boolean hard=edge.isHard();
  Point3d tpos=tail.getPosition();
  Vector3d dir=new Vector3d(head.getPosition());
  dir.sub(tpos);
  dir.scale(1.0 / 3);
  Vertex3d vt0=new Vertex3d(tpos.x + dir.x,tpos.y + dir.y,tpos.z + dir.z);
  Vertex3d vt1=new Vertex3d(tpos.x + 2 * dir.x,tpos.y + 2 * dir.y,tpos.z + 2 * dir.z);
  PolygonalMesh mesh=f.getMesh();
  mesh.addVertex(vt0);
  mesh.addVertex(vt1);
  if (edgeOpp != null) {
    edge.opposite=null;
    edgeOpp.opposite=null;
    edge.setPrimary(true);
    edgeOpp.setPrimary(true);
    Face of=edgeOpp.getFace();
    Vertex3d ovtp=edgeOpp.next.head;
    if (of.isTriangle()) {
      HalfEdge hprev=edgeOpp.next.next;
      if (hprev.opposite != null) {
        hprev.opposite.setPrimary(true);
        hprev.opposite.opposite=null;
        hprev.opposite=null;
        hprev.setPrimary(true);
      }
      hprev.setHard(false);
      head.removeIncidentHalfEdge(hprev);
      hprev.head=vt0;
      edgeOpp.tail=vt0;
      vt0.addIncidentHalfEdge(hprev);
    }
 else {
      mesh.removeFaceFast(of);
      Face f0=mesh.addFace(tail,ovtp,vt0);
      edgeOpp=f0.he0;
      edgeOpp.setHard(hard);
    }
    Face f1=mesh.addFace(vt1,ovtp,head);
    f1.he0.setHard(hard);
    Face f2=mesh.addFace(vt0,ovtp,vt1);
    f2.he0.setHard(hard);
  }
  if (f.isTriangle()) {
    HalfEdge hnext=edge.next;
    if (hnext.opposite != null) {
      hnext.opposite.setPrimary(true);
      hnext.opposite.opposite=null;
      hnext.opposite=null;
      hnext.setPrimary(true);
    }
    hnext.setHard(false);
    head.removeIncidentHalfEdge(edge);
    edge.head=vt0;
    hnext.tail=vt0;
    vt0.addIncidentHalfEdge(edge);
  }
 else {
    mesh.removeFaceFast(f);
    Face f0=mesh.addFace(vt0,vtp,tail);
    edge=f0.he0;
    edge.setHard(hard);
  }
  Face f1=mesh.addFace(vt1,vtp,vt0);
  f1.he0.setHard(hard);
  Face f2=mesh.addFace(head,vtp,vt1);
  f2.he0.setHard(hard);
  edge.opposite=edgeOpp;
  edge.setPrimary(true);
  if (edgeOpp != null) {
    edgeOpp.opposite=edge;
    edgeOpp.setPrimary(false);
  }
  return edge;
}"
70651,"private static boolean canCollapseEdge(HalfEdge he){
  Vertex3d head=he.head;
  Vertex3d tail=he.tail;
  HalfEdge hprev=he.face.getPreviousEdge(he);
  if (hprev.tail == head) {
    return false;
  }
  HalfEdgeNode node=tail.incidentHedges;
  while (node != null) {
    HalfEdge ee=node.he;
    if (ee != he.opposite) {
      if (ee.tail == head) {
        return false;
      }
      if (ee.next.tail == head) {
        return false;
      }
    }
    node=node.next;
  }
  return true;
}","private static boolean canCollapseEdge(HalfEdge he){
  Vertex3d head=he.head;
  Vertex3d tail=he.tail;
  HalfEdge hprev=he.face.getPreviousEdge(he);
  if (hprev.tail == head) {
    return false;
  }
  HalfEdge hopp=he.opposite;
  if (hopp != null) {
    HalfEdge hnext=hopp.next;
    if (hnext.head == hopp.tail) {
      return false;
    }
  }
  HalfEdgeNode node=tail.incidentHedges;
  while (node != null) {
    HalfEdge ee=node.he;
    if (ee != he.opposite) {
      if (ee.tail == head) {
        return false;
      }
      if (ee.next != he && ee.next.head == head) {
        return false;
      }
    }
    node=node.next;
  }
  return true;
}"
70652,"private static boolean disconnectFaceIfDegenerate(Face face){
  HalfEdge he=face.firstHalfEdge();
  HalfEdge hn=he.next;
  if (hn.next == he) {
    he.head.removeIncidentHalfEdge(he);
    hn.head.removeIncidentHalfEdge(hn);
    HalfEdge heOpp=he.opposite;
    HalfEdge hnOpp=hn.opposite;
    if (heOpp != null) {
      heOpp.opposite=hnOpp;
      he.opposite=null;
    }
    if (hnOpp != null) {
      hnOpp.opposite=heOpp;
      hn.opposite=null;
    }
    if (heOpp != null && hnOpp != null) {
      if (heOpp.isHard() || hnOpp.isHard()) {
        heOpp.setHard(true);
        hnOpp.setHard(true);
      }
      if (heOpp.isPrimary() == hnOpp.isPrimary()) {
        hnOpp.setPrimary(!hnOpp.isPrimary());
      }
    }
 else {
      if (heOpp != null) {
        heOpp.setHard(false);
      }
      if (hnOpp != null) {
        hnOpp.setHard(false);
      }
    }
    return true;
  }
 else {
    return false;
  }
}","private static boolean disconnectFaceIfDegenerate(Face face){
  HalfEdge he=face.firstHalfEdge();
  HalfEdge hn=he.next;
  if (hn.next == he) {
    he.head.removeIncidentHalfEdge(he);
    hn.head.removeIncidentHalfEdge(hn);
    HalfEdge heOpp=he.opposite;
    HalfEdge hnOpp=hn.opposite;
    if (heOpp != null) {
      heOpp.opposite=hnOpp;
      he.opposite=null;
    }
    if (hnOpp != null) {
      hnOpp.opposite=heOpp;
      hn.opposite=null;
    }
    if (heOpp != null && hnOpp != null) {
      if (heOpp.isHard() || hnOpp.isHard()) {
        heOpp.setHard(true);
        hnOpp.setHard(true);
      }
      if (heOpp.isPrimary() == hnOpp.isPrimary()) {
        hnOpp.setPrimary(!hnOpp.isPrimary());
      }
    }
 else {
      if (heOpp != null) {
        heOpp.setHard(false);
        heOpp.setPrimary(true);
      }
      if (hnOpp != null) {
        hnOpp.setHard(false);
        hnOpp.setPrimary(true);
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
70653,"public PointAttachment getAttachment(Vertex3d vtx){
  if (getGrandParent() instanceof RigidBody) {
    RigidBody rb=(RigidBody)getGrandParent();
    return new PointFrameAttachment(rb,null,vtx.getWorldPoint());
  }
  return null;
}","public PointAttachment getAttachment(Vertex3d vtx){
  if (getGrandParent() instanceof RigidBody) {
    RigidBody rb=(RigidBody)getGrandParent();
    return new PointFrameAttachment(rb,null,vtx.getPosition());
  }
  return null;
}"
70654,"/** 
 * Find and collect objects starting at the nearest and working outwards  until a given criteria is met
 * @param bvh bounding object hierarchy
 * @param dcalc distance calculator
 * @param cond distance condition
 */
public void nearestObjects(BVTree bvh,ObjectDistanceCalculator dcalc,ObjectDistanceCollector cond){
  dcalc.reset();
  PriorityQueue<BVCheckRequest> queue=new PriorityQueue<BVCheckRequest>(11,new BVCheckComparator());
  double d=dcalc.nearestDistance(bvh.getRoot());
  if (d != -1) {
    queue.add(new BVCheckRequest(bvh.getRoot(),d));
  }
  while (!queue.isEmpty()) {
    BVCheckRequest req=queue.poll();
    if (!cond.check(req)) {
      break;
    }
    BVNode node=req.myNode;
    if (node.isLeaf()) {
      Boundable[] elems=node.getElements();
      for (int i=0; i < elems.length; i++) {
        d=dcalc.nearestDistance(elems[i]);
        if (d != -1) {
          cond.add(elems[i],d);
        }
      }
    }
 else {
      BVNode child;
      for (child=node.myFirstChild; child != null; child=child.myNext) {
        d=dcalc.nearestDistance(child);
        if (d != -1) {
          queue.add(new BVCheckRequest(child,d));
        }
      }
    }
  }
}","/** 
 * Find and collect objects starting at the nearest and working outwards  until a given criteria is met
 * @param bvh bounding object hierarchy
 * @param dcalc distance calculator
 * @param coll distance condition
 */
public void nearestObjects(BVTree bvh,ObjectDistanceCalculator dcalc,ObjectDistanceCollector coll){
  dcalc.reset();
  PriorityQueue<BVCheckRequest> queue=new PriorityQueue<BVCheckRequest>(11,new BVCheckComparator());
  double d=dcalc.nearestDistance(bvh.getRoot());
  if (d != -1) {
    queue.add(new BVCheckRequest(bvh.getRoot(),d));
  }
  while (!queue.isEmpty()) {
    BVCheckRequest req=queue.poll();
    if (!coll.check(req)) {
      break;
    }
    BVNode node=req.myNode;
    if (node.isLeaf()) {
      Boundable[] elems=node.getElements();
      for (int i=0; i < elems.length; i++) {
        d=dcalc.nearestDistance(elems[i]);
        if (d != -1) {
          coll.add(elems[i],d);
        }
      }
    }
 else {
      BVNode child;
      for (child=node.myFirstChild; child != null; child=child.myNext) {
        d=dcalc.nearestDistance(child);
        if (d != -1) {
          queue.add(new BVCheckRequest(child,d));
        }
      }
    }
  }
}"
70655,"@Override public void nearestPoint(Point3d nearest,Point3d pnt){
  nearest.set(getWorldPoint());
}","@Override public void nearestPoint(Point3d nearest,Point3d pnt){
  nearest.set(getPosition());
}"
70656,"/** 
 * Searches through all ""subdirectories"" of a URL, gathering classes of type T that match regex
 */
public static ArrayList<Class<?>> findClasses(URL url,String pkg,Pattern regex,Class<?> T){
  ArrayList<Class<?>> classList=new ArrayList<Class<?>>();
  if (pkg.startsWith(""String_Node_Str"")) {
    pkg=pkg.substring(1);
  }
  if (""String_Node_Str"".equals(url.getProtocol())) {
    File file=new File(url.getPath());
    return findClasses(file,pkg,regex,T);
  }
 else   if (""String_Node_Str"".equals(url.getProtocol())) {
    JarFile jar=null;
    JarEntry jarEntry=null;
    try {
      JarURLConnection connection=(JarURLConnection)(url.openConnection());
      jar=connection.getJarFile();
      jarEntry=connection.getJarEntry();
    }
 catch (    IOException ioe) {
      Logger logger=getLogger();
      logger.debug(""String_Node_Str"" + url.toString());
      logger.trace(ioe);
      return classList;
    }
    if (jarEntry.getName().endsWith(""String_Node_Str"")) {
      String className=jarEntry.getName();
      className=className.substring(0,className.length() - 6);
      maybeAddClass(className,regex,T,classList);
    }
 else {
      Enumeration<JarEntry> entries=jar.entries();
      while (entries.hasMoreElements()) {
        JarEntry entry=entries.nextElement();
        if (entry.getName().startsWith(jarEntry.getName())) {
          if (entry.getName().endsWith(""String_Node_Str"")) {
            String className=entry.getName();
            className=className.substring(0,className.length() - 6);
            className=className.replace('/','.');
            maybeAddClass(className,regex,T,classList);
          }
        }
      }
    }
  }
  return classList;
}","/** 
 * Searches through all ""subdirectories"" of a URL, gathering classes of type T that match regex
 */
public static ArrayList<Class<?>> findClasses(URL url,String pkg,Pattern regex,Class<?> T){
  ArrayList<Class<?>> classList=new ArrayList<Class<?>>();
  if (pkg.startsWith(""String_Node_Str"")) {
    pkg=pkg.substring(1);
  }
  if (""String_Node_Str"".equals(url.getProtocol())) {
    File file=new File(getPathDecoded(url));
    return findClasses(file,pkg,regex,T);
  }
 else   if (""String_Node_Str"".equals(url.getProtocol())) {
    JarFile jar=null;
    JarEntry jarEntry=null;
    try {
      JarURLConnection connection=(JarURLConnection)(url.openConnection());
      jar=connection.getJarFile();
      jarEntry=connection.getJarEntry();
    }
 catch (    IOException ioe) {
      Logger logger=getLogger();
      logger.debug(""String_Node_Str"" + url.toString());
      logger.trace(ioe);
      return classList;
    }
    if (jarEntry.getName().endsWith(""String_Node_Str"")) {
      String className=jarEntry.getName();
      className=className.substring(0,className.length() - 6);
      maybeAddClass(className,regex,T,classList);
    }
 else {
      Enumeration<JarEntry> entries=jar.entries();
      while (entries.hasMoreElements()) {
        JarEntry entry=entries.nextElement();
        if (entry.getName().startsWith(jarEntry.getName())) {
          if (entry.getName().endsWith(""String_Node_Str"")) {
            String className=entry.getName();
            className=className.substring(0,className.length() - 6);
            className=className.replace('/','.');
            maybeAddClass(className,regex,T,classList);
          }
        }
      }
    }
  }
  return classList;
}"
70657,"protected void clearCachedData(ComponentChangeEvent e){
  super.clearCachedData(e);
  myForcesNeedUpdating=true;
  invalidateStressAndStiffness();
  invalidateIntegrationIndices();
  myBVTreeValid=false;
}","protected void clearCachedData(ComponentChangeEvent e){
  super.clearCachedData(e);
  myForcesNeedUpdating=true;
  invalidateStressAndStiffness();
  invalidateIntegrationIndices();
  myAABBTree=null;
  myBVTreeValid=false;
}"
70658,"/** 
 * Renders captured data to a movie with the specified file name.
 */
public void render(String fn) throws Exception {
  if (lastFrameCount == 0) {
    Main.getMain().getLogger().info(""String_Node_Str"");
    return;
  }
  myViewer.awaitScreenShotCompletion();
  Method method=myMethodMap.get(myMethodName);
  if (myMethodName.equals(INTERNAL_METHOD)) {
    String frameFileNames[]=new String[lastFrameCount];
    for (int i=1; i <= lastFrameCount; i++) {
      frameFileNames[i - 1]=getFrameFileName(i);
    }
    new MakeMovieFromData(frameFileNames,dataPath,fn + ""String_Node_Str"");
  }
 else   if (myMethodName.equals(ANIMATED_GIF_METHOD)) {
    String opts=method.command;
    opts=opts.replaceAll(""String_Node_Str"",""String_Node_Str"" + frameRate);
    String frameFileNames[]=new String[lastFrameCount];
    for (int i=1; i <= lastFrameCount; i++) {
      frameFileNames[i - 1]=getFrameFileName(i);
    }
    File outFile=new File(dataPath + File.separator + fn+ ""String_Node_Str"");
    DoubleHolder delayHolder=new DoubleHolder(0);
    IntHolder loopHolder=new IntHolder(0);
    AnimatedGifWriter.parseArgs(opts,delayHolder,loopHolder);
    AnimatedGifWriter.write(outFile,frameFileNames,delayHolder.value,loopHolder.value);
  }
 else {
    String cmd=method.command;
    cmd=cmd.replaceAll(""String_Node_Str"",""String_Node_Str"" + frameRate);
    cmd=cmd.replaceAll(""String_Node_Str"",myFormat);
    String[] cmdArray=cmd.split(""String_Node_Str"");
    String finalCmd=""String_Node_Str"";
    for (int i=0; i < cmdArray.length; i++) {
      cmdArray[i]=cmdArray[i].replaceAll(""String_Node_Str"",fn);
      finalCmd=finalCmd + ""String_Node_Str"" + cmdArray[i];
    }
    Main.getMain().getLogger().info(""String_Node_Str"" + finalCmd);
    ProcessBuilder procBuild=new ProcessBuilder(cmdArray);
    procBuild.directory(new File(dataPath));
    Process proc=procBuild.start();
    StreamGobbler errorGobbler=new StreamGobbler(proc.getErrorStream(),System.err,""String_Node_Str"");
    StreamGobbler outputGobbler=new StreamGobbler(proc.getInputStream(),System.out,""String_Node_Str"");
    outputGobbler.start();
    errorGobbler.start();
    int exitVal=proc.waitFor();
    if (exitVal != 0) {
      Main.getMain().getLogger().error(""String_Node_Str"" + exitVal + ""String_Node_Str"");
    }
  }
}","/** 
 * Renders captured data to a movie with the specified file name.
 */
public void render(String fn) throws Exception {
  if (lastFrameCount == 0) {
    Main.getMain().getLogger().info(""String_Node_Str"");
    return;
  }
  myViewer.awaitScreenShotCompletion();
  Method method=myMethodMap.get(myMethodName);
  if (myMethodName.equals(INTERNAL_METHOD)) {
    String frameFileNames[]=new String[lastFrameCount];
    for (int i=1; i <= lastFrameCount; i++) {
      frameFileNames[i - 1]=getFrameFileName(i);
    }
    new MakeMovieFromData(frameFileNames,dataPath,fn + ""String_Node_Str"");
  }
 else   if (myMethodName.equals(ANIMATED_GIF_METHOD)) {
    String opts=method.command;
    opts=opts.replace(""String_Node_Str"",""String_Node_Str"" + frameRate);
    String frameFileNames[]=new String[lastFrameCount];
    for (int i=1; i <= lastFrameCount; i++) {
      frameFileNames[i - 1]=getFrameFileName(i);
    }
    File outFile=new File(dataPath,fn + ""String_Node_Str"");
    DoubleHolder delayHolder=new DoubleHolder(0);
    IntHolder loopHolder=new IntHolder(0);
    AnimatedGifWriter.parseArgs(opts,delayHolder,loopHolder);
    AnimatedGifWriter.write(outFile,frameFileNames,delayHolder.value,loopHolder.value);
  }
 else {
    String cmd=method.command;
    cmd=cmd.replace(""String_Node_Str"",""String_Node_Str"" + frameRate);
    cmd=cmd.replace(""String_Node_Str"",myFormat);
    String[] cmdArray=cmd.split(""String_Node_Str"");
    String finalCmd=""String_Node_Str"";
    for (int i=0; i < cmdArray.length; i++) {
      cmdArray[i]=cmdArray[i].replace(""String_Node_Str"",fn);
      finalCmd=finalCmd + ""String_Node_Str"" + cmdArray[i];
    }
    Main.getMain().getLogger().info(""String_Node_Str"" + finalCmd);
    ProcessBuilder procBuild=new ProcessBuilder(cmdArray);
    procBuild.directory(new File(dataPath));
    Process proc=procBuild.start();
    StreamGobbler errorGobbler=new StreamGobbler(proc.getErrorStream(),System.err,""String_Node_Str"");
    StreamGobbler outputGobbler=new StreamGobbler(proc.getInputStream(),System.out,""String_Node_Str"");
    outputGobbler.start();
    errorGobbler.start();
    int exitVal=proc.waitFor();
    if (exitVal != 0) {
      Main.getMain().getLogger().error(""String_Node_Str"" + exitVal + ""String_Node_Str"");
    }
  }
}"
70659,"public void run(){
  String movieFileName=filename.getText();
  myMain.setFrameRate(savedFrameRate);
  myMovieMaker.setGrabbing(false);
  myFrame.getViewer().cleanupScreenShots();
  stopButton.setEnabled(false);
  frameButton.setEnabled(false);
  startButton.setEnabled(true);
  myFrame.setAlwaysOnTop(false);
  if (myMain.getScheduler().isPlaying() == true && endRecordOnStop.isSelected()) {
    myMain.getScheduler().pause();
  }
  try {
    System.out.println(""String_Node_Str"");
    int frameCount=myMovieMaker.close();
    if (frameCount > 0) {
      if (!myMovieMaker.isRenderingAudioToFile()) {
        myMovieMaker.render(movieFileName);
      }
 else {
        ((HasAudio)myMain.getRootModel()).onStop();
        String tmpMovieFn=""String_Node_Str"" + tmpDirectory + ""String_Node_Str"";
        String finalMovieFn=""String_Node_Str"" + ArtisynthPath.getHomeDir() + ""String_Node_Str""+ movieFileName;
        System.out.println(""String_Node_Str"");
        myMovieMaker.render(tmpMovieFn);
        String waveFn=""String_Node_Str"" + ConvertRawToWav.convert(myMovieMaker.getAudioSampleRate(),myMovieMaker.getAudioFileName());
        String[] args={tmpMovieFn,waveFn,""String_Node_Str"",finalMovieFn};
        System.out.println(""String_Node_Str"" + finalMovieFn);
        new Merge(args);
      }
      if (saveMovieImage.isSelected()) {
        myMovieMaker.saveFirstFrame(movieFileName);
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    if (removeImages.isSelected()) {
      System.out.println(""String_Node_Str"");
      myMovieMaker.clean();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if ((myMain.getRootModel() instanceof HasAudio) && ((recordAudio.isSelected()) || recordAudioTxt.isSelected())) {
    System.out.println(""String_Node_Str"");
    myMovieMaker.setRenderingAudioToFile(false);
    myMovieMaker.setRenderingAudioToText(false);
    recordAudio.setSelected(false);
    recordAudioTxt.setSelected(false);
    normalizeAudio.setSelected(false);
    normalizeAudio.setEnabled(false);
    ((HasAudio)myMain.getRootModel()).setRenderAudioToFile(false);
  }
  System.out.println(""String_Node_Str"");
}","public void run(){
  String movieFileName=filename.getText();
  File mfile=new File(myMovieMaker.getDataPath(),movieFileName);
  mfile.getParentFile().mkdirs();
  myMain.setFrameRate(savedFrameRate);
  myMovieMaker.setGrabbing(false);
  myFrame.getViewer().cleanupScreenShots();
  stopButton.setEnabled(false);
  frameButton.setEnabled(false);
  startButton.setEnabled(true);
  myFrame.setAlwaysOnTop(false);
  if (myMain.getScheduler().isPlaying() == true && endRecordOnStop.isSelected()) {
    myMain.getScheduler().pause();
  }
  try {
    System.out.println(""String_Node_Str"");
    int frameCount=myMovieMaker.close();
    if (frameCount > 0) {
      if (!myMovieMaker.isRenderingAudioToFile()) {
        myMovieMaker.render(movieFileName);
      }
 else {
        ((HasAudio)myMain.getRootModel()).onStop();
        String tmpMovieFn=""String_Node_Str"" + tmpDirectory + ""String_Node_Str"";
        String finalMovieFn=""String_Node_Str"" + ArtisynthPath.getHomeDir() + ""String_Node_Str""+ movieFileName;
        System.out.println(""String_Node_Str"");
        myMovieMaker.render(tmpMovieFn);
        String waveFn=""String_Node_Str"" + ConvertRawToWav.convert(myMovieMaker.getAudioSampleRate(),myMovieMaker.getAudioFileName());
        String[] args={tmpMovieFn,waveFn,""String_Node_Str"",finalMovieFn};
        System.out.println(""String_Node_Str"" + finalMovieFn);
        new Merge(args);
      }
      if (saveMovieImage.isSelected()) {
        myMovieMaker.saveFirstFrame(movieFileName);
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    if (removeImages.isSelected()) {
      System.out.println(""String_Node_Str"");
      myMovieMaker.clean();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if ((myMain.getRootModel() instanceof HasAudio) && ((recordAudio.isSelected()) || recordAudioTxt.isSelected())) {
    System.out.println(""String_Node_Str"");
    myMovieMaker.setRenderingAudioToFile(false);
    myMovieMaker.setRenderingAudioToText(false);
    recordAudio.setSelected(false);
    recordAudioTxt.setSelected(false);
    normalizeAudio.setSelected(false);
    normalizeAudio.setEnabled(false);
    ((HasAudio)myMain.getRootModel()).setRenderAudioToFile(false);
  }
  System.out.println(""String_Node_Str"");
}"
70660,"private void takeScreenshot(){
  String movieFileName=filename.getText();
  if (movieFileName.equals(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    filename.requestFocusInWindow();
  }
 else {
    boolean stopEnabled=stopButton.isEnabled();
    boolean startEnabled=startButton.isEnabled();
    stopButton.setEnabled(false);
    startButton.setEnabled(false);
    tmpDirectory=ArtisynthPath.getTempDir().getAbsolutePath();
    File testdir=new File(tmpDirectory);
    if (!testdir.exists()) {
      System.out.println(""String_Node_Str"" + tmpDirectory);
      testdir.mkdir();
    }
 else     if (!testdir.isDirectory()) {
      System.err.println(""String_Node_Str"" + tmpDirectory + ""String_Node_Str"");
      filename.requestFocusInWindow();
      return;
    }
    setAreaSelectionFrame(null);
    showCaptureFrame.setSelected(false);
    try {
      myMovieMaker.grab(tmpDirectory + ""String_Node_Str"" + movieFileName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    stopButton.setEnabled(stopEnabled);
    startButton.setEnabled(startEnabled);
  }
}","private void takeScreenshot(){
  String movieFileName=filename.getText();
  if (movieFileName.equals(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    filename.requestFocusInWindow();
  }
 else {
    boolean stopEnabled=stopButton.isEnabled();
    boolean startEnabled=startButton.isEnabled();
    stopButton.setEnabled(false);
    startButton.setEnabled(false);
    tmpDirectory=workingDirField.getText();
    File testdir=new File(tmpDirectory);
    if (!testdir.exists()) {
      System.out.println(""String_Node_Str"" + tmpDirectory);
      testdir.mkdir();
    }
 else     if (!testdir.isDirectory()) {
      System.err.println(""String_Node_Str"" + tmpDirectory + ""String_Node_Str"");
      filename.requestFocusInWindow();
      return;
    }
    setAreaSelectionFrame(null);
    showCaptureFrame.setSelected(false);
    try {
      myMovieMaker.grab(tmpDirectory + ""String_Node_Str"" + movieFileName);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    stopButton.setEnabled(stopEnabled);
    startButton.setEnabled(startEnabled);
  }
}"
70661,"private void startMovie(){
  String movieFileName=filename.getText();
  myMovieMaker.setRenderingAudioToFile(recordAudio.isSelected());
  myMovieMaker.setRenderingAudioToText(recordAudioTxt.isSelected());
  myMovieMaker.setAudioNormalized(normalizeAudio.isSelected());
  if (movieFileName.equals(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    filename.requestFocusInWindow();
  }
 else {
    stopButton.setEnabled(true);
    startButton.setEnabled(false);
    frameButton.setEnabled(true);
    tmpDirectory=ArtisynthPath.getTempDir().getAbsolutePath();
    File testdir=new File(tmpDirectory);
    if (!testdir.exists()) {
      System.out.println(""String_Node_Str"" + tmpDirectory);
      testdir.mkdirs();
    }
 else     if (!testdir.isDirectory()) {
      System.err.println(""String_Node_Str"" + tmpDirectory + ""String_Node_Str"");
      filename.requestFocusInWindow();
      return;
    }
    if (myMain.getRootModel() instanceof HasAudio) {
      if (recordAudio.isSelected()) {
        myMovieMaker.setAudioFileName(tmpDirectory + ""String_Node_Str"");
      }
      if (recordAudioTxt.isSelected()) {
        System.out.println(""String_Node_Str"");
        myMovieMaker.setAudioFileName(ArtisynthPath.getHomeDir() + ""String_Node_Str"" + filename.getText()+ ""String_Node_Str"");
      }
      boolean renderToFile=recordAudio.isSelected() || recordAudioTxt.isSelected();
      ((HasAudio)myMain.getRootModel()).setRenderAudioToFile(renderToFile);
    }
    System.out.println(myMovieMaker.getCaptureArea());
    if (automaticFrames.isSelected()) {
      myMovieMaker.setGrabbing(true);
    }
    savedFrameRate=myMain.getFrameRate();
    myMain.setFrameRate(myMovieMaker.getFrameRate() / myMovieMaker.getSpeed());
    myFrame.setAlwaysOnTop(myMovieMaker.isAlwaysOnTop());
    setAreaSelectionFrame(null);
    showCaptureFrame.setSelected(false);
    try {
      myMovieMaker.setDataPath(tmpDirectory);
      if (myMain.getScheduler().isPlaying() == false && beginRecordOnStart.isSelected()) {
        myMain.getScheduler().play();
      }
      isRecordingStarted=true;
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + e);
      myMain.setFrameRate(savedFrameRate);
      myMovieMaker.setGrabbing(false);
      myFrame.setAlwaysOnTop(false);
    }
  }
}","private void startMovie(){
  String movieFileName=filename.getText();
  myMovieMaker.setRenderingAudioToFile(recordAudio.isSelected());
  myMovieMaker.setRenderingAudioToText(recordAudioTxt.isSelected());
  myMovieMaker.setAudioNormalized(normalizeAudio.isSelected());
  if (movieFileName.equals(""String_Node_Str"")) {
    JOptionPane.showMessageDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    filename.requestFocusInWindow();
  }
 else {
    stopButton.setEnabled(true);
    startButton.setEnabled(false);
    frameButton.setEnabled(true);
    tmpDirectory=workingDirField.getText();
    File testdir=new File(tmpDirectory);
    if (!testdir.exists()) {
      System.out.println(""String_Node_Str"" + tmpDirectory);
      testdir.mkdirs();
    }
 else     if (!testdir.isDirectory()) {
      System.err.println(""String_Node_Str"" + tmpDirectory + ""String_Node_Str"");
      filename.requestFocusInWindow();
      return;
    }
    if (myMain.getRootModel() instanceof HasAudio) {
      if (recordAudio.isSelected()) {
        myMovieMaker.setAudioFileName(tmpDirectory + ""String_Node_Str"");
      }
      if (recordAudioTxt.isSelected()) {
        System.out.println(""String_Node_Str"");
        myMovieMaker.setAudioFileName(ArtisynthPath.getHomeDir() + ""String_Node_Str"" + filename.getText()+ ""String_Node_Str"");
      }
      boolean renderToFile=recordAudio.isSelected() || recordAudioTxt.isSelected();
      ((HasAudio)myMain.getRootModel()).setRenderAudioToFile(renderToFile);
    }
    System.out.println(myMovieMaker.getCaptureArea());
    if (automaticFrames.isSelected()) {
      myMovieMaker.setGrabbing(true);
    }
    savedFrameRate=myMain.getFrameRate();
    myMain.setFrameRate(myMovieMaker.getFrameRate() / myMovieMaker.getSpeed());
    myFrame.setAlwaysOnTop(myMovieMaker.isAlwaysOnTop());
    setAreaSelectionFrame(null);
    showCaptureFrame.setSelected(false);
    try {
      myMovieMaker.setDataPath(tmpDirectory);
      if (myMain.getScheduler().isPlaying() == false && beginRecordOnStart.isSelected()) {
        myMain.getScheduler().play();
      }
      isRecordingStarted=true;
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + e);
      myMain.setFrameRate(savedFrameRate);
      myMovieMaker.setGrabbing(false);
      myFrame.setAlwaysOnTop(false);
    }
  }
}"
70662,"/** 
 * Create a dialog box to set the movie making options.
 */
public MovieMakerDialog(MovieMaker movieMaker,Main main){
  super();
  myMain=main;
  myFrame=myMain.getMainFrame();
  myMovieMaker=movieMaker;
  JPanel contentPane=new JPanel();
  contentPane.setLayout(new BorderLayout());
  setContentPane(contentPane);
  setTitle(""String_Node_Str"");
  JTabbedPane tabbedPane=new JTabbedPane();
  Box recOptionsBox=Box.createVerticalBox();
  LabeledComponentPanel captureOptions=new LabeledComponentPanel();
  captureOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  LabeledComponentPanel recOptions=new LabeledComponentPanel();
  recOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  windowButtons=new OptionPanel(""String_Node_Str"",this);
  viewWindowButton=windowButtons.getButton(""String_Node_Str"");
  viewWindowButton.setActionCommand(VIEW_WINDOW_CMD);
  viewWindowButton.setToolTipText(""String_Node_Str"");
  GuiUtils.setFixedSize(viewWindowButton,viewWindowButton.getPreferredSize());
  viewWindowButton.setBorder(new BevelBorder(BevelBorder.LOWERED));
  fullWindowButton=windowButtons.getButton(""String_Node_Str"");
  fullWindowButton.setToolTipText(""String_Node_Str"");
  fullWindowButton.setActionCommand(FULL_WINDOW_CMD);
  GuiUtils.setFixedSize(fullWindowButton,fullWindowButton.getPreferredSize());
  fullWindowButton.setBorder(new BevelBorder(BevelBorder.RAISED));
  customWindowButton=windowButtons.getButton(""String_Node_Str"");
  customWindowButton.setToolTipText(""String_Node_Str"");
  customWindowButton.setActionCommand(CUSTOM_WINDOW_CMD);
  GuiUtils.setFixedSize(customWindowButton,customWindowButton.getPreferredSize());
  customWindowButton.setBorder(new BevelBorder(BevelBorder.RAISED));
  captureOptions.addWidget(windowButtons);
  windowXPosition=new IntegerField(""String_Node_Str"",0);
  windowXPosition.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowXPosition);
  windowYPosition=new IntegerField(""String_Node_Str"",0);
  windowYPosition.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowYPosition);
  windowWidth=new IntegerField(""String_Node_Str"",0);
  windowWidth.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowWidth);
  windowHeight=new IntegerField(""String_Node_Str"",0);
  windowHeight.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowHeight);
  recOptionsBox.add(captureOptions);
  beginRecordOnStart=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(beginRecordOnStart);
  endRecordOnStop=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(endRecordOnStop);
  automaticFrames=new JCheckBox(""String_Node_Str"",null,true);
  automaticFrames.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      JCheckBox box=(JCheckBox)e.getSource();
      if (isStarted()) {
        if (box.isSelected()) {
          myMovieMaker.setGrabbing(true);
        }
 else {
          myMovieMaker.setGrabbing(false);
        }
      }
    }
  }
);
  recOptions.addWidget(automaticFrames);
  removeImages=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(removeImages);
  saveMovieImage=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(saveMovieImage);
  showCaptureFrame=new JCheckBox(""String_Node_Str"",null,true);
  showCaptureFrame.addActionListener(this);
  showCaptureFrame.setEnabled(false);
  recOptions.addWidget(showCaptureFrame);
  alwaysOnTop=new JCheckBox(""String_Node_Str"",null,myMovieMaker.isAlwaysOnTop());
  recOptions.add(alwaysOnTop);
  alwaysOnTop.addActionListener(this);
  recordAudio=new JCheckBox(REC_AUDIO_CMD,null,false);
  recordAudio.addActionListener(this);
  normalizeAudio=new JCheckBox(""String_Node_Str"",null,false);
  recordAudioTxt=new JCheckBox(REC_AUDIO_TO_TXT_CMD,null,false);
  recordAudioTxt.addActionListener(this);
  setAudioOptions(myMain.getRootModel() instanceof HasAudio);
  recOptionsBox.add(recOptions);
  filename=new StringField(""String_Node_Str"",""String_Node_Str"",10);
  filename.setStretchable(true);
  filename.setBorder(BorderFactory.createEmptyBorder(5,0,5,0));
  recOptionsBox.add(filename);
  Box encOptionsBox=Box.createVerticalBox();
  LabeledComponentPanel outputOptions=new LabeledComponentPanel();
  outputOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  LabeledComponentPanel sizeOptions=new LabeledComponentPanel();
  sizeOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  frameRateField=new DoubleField(""String_Node_Str"",myMovieMaker.getFrameRate());
  frameRateField.addValueChangeListener(this);
  frameRateField.setRange(1,Integer.MAX_VALUE);
  outputOptions.addWidget(frameRateField);
  speedField=new DoubleField(""String_Node_Str"",myMovieMaker.getSpeed());
  speedField.addValueChangeListener(this);
  speedField.setRange(1e-6,Double.POSITIVE_INFINITY);
  outputOptions.addWidget(speedField);
  formatSelector=new StringSelector(""String_Node_Str"",ImageIO.getWriterFormatNames());
  String imageFmt=movieMaker.getFormat();
  if (imageFmt == null) {
    formatSelector.setValue(""String_Node_Str"");
  }
 else {
    formatSelector.setValue(imageFmt);
  }
  formatSelector.addValueChangeListener(this);
  GuiUtils.setFixedSize(formatSelector.getComboBox(),new Dimension(125,25));
  outputOptions.addWidget(formatSelector);
  HashMap<String,MovieMaker.Method> methodMap=movieMaker.getMethodMap();
  methodSelector=new StringSelector(""String_Node_Str"",methodMap.keySet().toArray(new String[0]));
  String currentMethod=movieMaker.getMethod();
  if (currentMethod == null) {
    methodSelector.setValue(MovieMaker.INTERNAL_METHOD);
  }
 else {
    methodSelector.setValue(currentMethod);
  }
  methodSelector.addValueChangeListener(this);
  GuiUtils.setFixedSize(methodSelector.getComboBox(),new Dimension(125,25));
  customizeButton=new JButton(""String_Node_Str"");
  customizeButton.setActionCommand(CUSTOMIZE_CMD);
  customizeButton.addActionListener(this);
  customizeButton.setMargin(new Insets(3,3,3,3));
  GuiUtils.setFixedSize(customizeButton,new Dimension(125,25));
  outputOptions.addWidget(methodSelector);
  outputOptions.addWidget(customizeButton);
  encOptionsBox.add(outputOptions);
  originalSize=new JCheckBox(""String_Node_Str"",true);
  originalSize.addActionListener(this);
  sizeOptions.addWidget(originalSize);
  constrainSize=new JCheckBox(""String_Node_Str"",true);
  constrainSize.addActionListener(this);
  constrainSize.setEnabled(false);
  sizeOptions.addWidget(constrainSize);
  resizeWidth=new IntegerField(""String_Node_Str"",0);
  resizeWidth.getTextField().setEnabled(false);
  resizeWidth.addValueChangeListener(new ValueChangeListener(){
    public void valueChange(    ValueChangeEvent e){
      if (constrainSize.isSelected()) {
        double scale=resizeWidth.getDoubleValue() / windowWidth.getDoubleValue();
        resizeHeight.setValue(scale * windowHeight.getIntValue());
      }
      myMovieMaker.setCaptureArea(myMovieMaker.getCaptureArea(),new Dimension((Integer)resizeWidth.getIntValue(),(Integer)resizeHeight.getIntValue()),viewerCapture);
    }
  }
);
  sizeOptions.addWidget(resizeWidth);
  resizeHeight=new IntegerField(""String_Node_Str"",0);
  resizeHeight.getTextField().setEnabled(false);
  resizeHeight.addValueChangeListener(new ValueChangeListener(){
    public void valueChange(    ValueChangeEvent e){
      if (constrainSize.isSelected()) {
        double scale=resizeHeight.getDoubleValue() / windowHeight.getDoubleValue();
        resizeWidth.setValue(scale * windowWidth.getIntValue());
      }
      myMovieMaker.setCaptureArea(myMovieMaker.getCaptureArea(),new Dimension((Integer)resizeWidth.getIntValue(),(Integer)resizeHeight.getIntValue()),viewerCapture);
    }
  }
);
  sizeOptions.addWidget(resizeHeight);
  int nDefaultSamples=FrameBufferObject.defaultMultiSamples;
  resizeSamples=new IntegerField(""String_Node_Str"",nDefaultSamples);
  resizeSamples.setToolTipText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  resizeSamples.getTextField().setEnabled(false);
  resizeSamples.setRange(new IntegerInterval(1,16));
  resizeSamples.addValueChangeListener(this);
  sizeOptions.addWidget(resizeSamples);
  encOptionsBox.add(sizeOptions);
  Box extraBox=Box.createVerticalBox();
  LabeledComponentPanel extraCommands=new LabeledComponentPanel();
  extraCommands.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  extraCommands.setName(""String_Node_Str"");
  JButton waypointButton=new JButton(""String_Node_Str"");
  waypointButton.setActionCommand(WAYPOINT_CMD);
  waypointButton.addActionListener(this);
  extraCommands.addWidget(waypointButton);
  extraBox.add(extraCommands);
  tabbedPane.addTab(""String_Node_Str"",recOptionsBox);
  tabbedPane.addTab(""String_Node_Str"",encOptionsBox);
  tabbedPane.addTab(""String_Node_Str"",extraBox);
  if (myMain.getModelName() != null) {
    setMovieName(myMain.getModelName());
  }
  add(tabbedPane,BorderLayout.NORTH);
  updateMethodSelectors();
  controlPanel=new OptionPanel(""String_Node_Str"" + START_CMD + ""String_Node_Str""+ FRAME_CMD+ ""String_Node_Str""+ STOP_CMD+ ""String_Node_Str""+ CLOSE_CMD,this);
  startButton=controlPanel.getButton(START_CMD);
  stopButton=controlPanel.getButton(STOP_CMD);
  stopButton.setEnabled(false);
  frameButton=controlPanel.getButton(FRAME_CMD);
  frameButton.setEnabled(false);
  add(controlPanel,BorderLayout.CENTER);
  viewerCapture=true;
  customCapture=false;
  final Component displayComponent=myFrame.getViewer().getCanvas().getComponent();
  setCaptureArea(displayComponent);
  displayComponent.addComponentListener(new ComponentListener(){
    public void componentHidden(    ComponentEvent c_evt){
    }
    public void componentMoved(    ComponentEvent c_evt){
      if (!customCapture && viewerCapture) {
        setCaptureArea(displayComponent);
      }
 else       if (!customCapture && !viewerCapture) {
        setCaptureArea(myFrame);
      }
    }
    public void componentResized(    ComponentEvent c_evt){
      if (!customCapture && viewerCapture) {
        setCaptureArea(displayComponent);
      }
 else       if (!customCapture && !viewerCapture) {
        setCaptureArea(myFrame);
      }
    }
    public void componentShown(    ComponentEvent c_evt){
    }
  }
);
  pack();
  setMinimumSize(getPreferredSize());
}","/** 
 * Create a dialog box to set the movie making options.
 */
public MovieMakerDialog(MovieMaker movieMaker,Main main){
  super();
  myMain=main;
  myFrame=myMain.getMainFrame();
  myMovieMaker=movieMaker;
  JPanel contentPane=new JPanel();
  contentPane.setLayout(new BorderLayout());
  setContentPane(contentPane);
  setTitle(""String_Node_Str"");
  JTabbedPane tabbedPane=new JTabbedPane();
  Box recOptionsBox=Box.createVerticalBox();
  LabeledComponentPanel captureOptions=new LabeledComponentPanel();
  captureOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  LabeledComponentPanel recOptions=new LabeledComponentPanel();
  recOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  windowButtons=new OptionPanel(""String_Node_Str"",this);
  viewWindowButton=windowButtons.getButton(""String_Node_Str"");
  viewWindowButton.setActionCommand(VIEW_WINDOW_CMD);
  viewWindowButton.setToolTipText(""String_Node_Str"");
  GuiUtils.setFixedSize(viewWindowButton,viewWindowButton.getPreferredSize());
  viewWindowButton.setBorder(new BevelBorder(BevelBorder.LOWERED));
  fullWindowButton=windowButtons.getButton(""String_Node_Str"");
  fullWindowButton.setToolTipText(""String_Node_Str"");
  fullWindowButton.setActionCommand(FULL_WINDOW_CMD);
  GuiUtils.setFixedSize(fullWindowButton,fullWindowButton.getPreferredSize());
  fullWindowButton.setBorder(new BevelBorder(BevelBorder.RAISED));
  customWindowButton=windowButtons.getButton(""String_Node_Str"");
  customWindowButton.setToolTipText(""String_Node_Str"");
  customWindowButton.setActionCommand(CUSTOM_WINDOW_CMD);
  GuiUtils.setFixedSize(customWindowButton,customWindowButton.getPreferredSize());
  customWindowButton.setBorder(new BevelBorder(BevelBorder.RAISED));
  captureOptions.addWidget(windowButtons);
  windowXPosition=new IntegerField(""String_Node_Str"",0);
  windowXPosition.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowXPosition);
  windowYPosition=new IntegerField(""String_Node_Str"",0);
  windowYPosition.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowYPosition);
  windowWidth=new IntegerField(""String_Node_Str"",0);
  windowWidth.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowWidth);
  windowHeight=new IntegerField(""String_Node_Str"",0);
  windowHeight.addValueChangeListener(new AreaHandler());
  captureOptions.addWidget(windowHeight);
  recOptionsBox.add(captureOptions);
  beginRecordOnStart=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(beginRecordOnStart);
  endRecordOnStop=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(endRecordOnStop);
  automaticFrames=new JCheckBox(""String_Node_Str"",null,true);
  automaticFrames.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      JCheckBox box=(JCheckBox)e.getSource();
      if (isStarted()) {
        if (box.isSelected()) {
          myMovieMaker.setGrabbing(true);
        }
 else {
          myMovieMaker.setGrabbing(false);
        }
      }
    }
  }
);
  recOptions.addWidget(automaticFrames);
  removeImages=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(removeImages);
  saveMovieImage=new JCheckBox(""String_Node_Str"",null,true);
  recOptions.addWidget(saveMovieImage);
  showCaptureFrame=new JCheckBox(""String_Node_Str"",null,true);
  showCaptureFrame.addActionListener(this);
  showCaptureFrame.setEnabled(false);
  recOptions.addWidget(showCaptureFrame);
  alwaysOnTop=new JCheckBox(""String_Node_Str"",null,myMovieMaker.isAlwaysOnTop());
  recOptions.add(alwaysOnTop);
  alwaysOnTop.addActionListener(this);
  recordAudio=new JCheckBox(REC_AUDIO_CMD,null,false);
  recordAudio.addActionListener(this);
  normalizeAudio=new JCheckBox(""String_Node_Str"",null,false);
  recordAudioTxt=new JCheckBox(REC_AUDIO_TO_TXT_CMD,null,false);
  recordAudioTxt.addActionListener(this);
  setAudioOptions(myMain.getRootModel() instanceof HasAudio);
  recOptionsBox.add(recOptions);
  filename=new StringField(""String_Node_Str"",""String_Node_Str"",10);
  filename.setStretchable(true);
  filename.setBorder(BorderFactory.createEmptyBorder(5,0,5,0));
  recOptionsBox.add(filename);
  Box encOptionsBox=Box.createVerticalBox();
  LabeledComponentPanel outputOptions=new LabeledComponentPanel();
  outputOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  LabeledComponentPanel sizeOptions=new LabeledComponentPanel();
  sizeOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  frameRateField=new DoubleField(""String_Node_Str"",myMovieMaker.getFrameRate());
  frameRateField.addValueChangeListener(this);
  frameRateField.setRange(1,Integer.MAX_VALUE);
  outputOptions.addWidget(frameRateField);
  speedField=new DoubleField(""String_Node_Str"",myMovieMaker.getSpeed());
  speedField.addValueChangeListener(this);
  speedField.setRange(1e-6,Double.POSITIVE_INFINITY);
  outputOptions.addWidget(speedField);
  formatSelector=new StringSelector(""String_Node_Str"",ImageIO.getWriterFormatNames());
  String imageFmt=movieMaker.getFormat();
  if (imageFmt == null) {
    formatSelector.setValue(""String_Node_Str"");
  }
 else {
    formatSelector.setValue(imageFmt);
  }
  formatSelector.addValueChangeListener(this);
  GuiUtils.setFixedSize(formatSelector.getComboBox(),new Dimension(125,25));
  outputOptions.addWidget(formatSelector);
  HashMap<String,MovieMaker.Method> methodMap=movieMaker.getMethodMap();
  methodSelector=new StringSelector(""String_Node_Str"",methodMap.keySet().toArray(new String[0]));
  String currentMethod=movieMaker.getMethod();
  if (currentMethod == null) {
    methodSelector.setValue(MovieMaker.INTERNAL_METHOD);
  }
 else {
    methodSelector.setValue(currentMethod);
  }
  methodSelector.addValueChangeListener(this);
  GuiUtils.setFixedSize(methodSelector.getComboBox(),new Dimension(125,25));
  customizeButton=new JButton(""String_Node_Str"");
  customizeButton.setActionCommand(CUSTOMIZE_CMD);
  customizeButton.addActionListener(this);
  customizeButton.setMargin(new Insets(3,3,3,3));
  GuiUtils.setFixedSize(customizeButton,new Dimension(125,25));
  outputOptions.addWidget(methodSelector);
  outputOptions.addWidget(customizeButton);
  encOptionsBox.add(outputOptions);
  originalSize=new JCheckBox(""String_Node_Str"",true);
  originalSize.addActionListener(this);
  sizeOptions.addWidget(originalSize);
  constrainSize=new JCheckBox(""String_Node_Str"",true);
  constrainSize.addActionListener(this);
  constrainSize.setEnabled(false);
  sizeOptions.addWidget(constrainSize);
  resizeWidth=new IntegerField(""String_Node_Str"",0);
  resizeWidth.getTextField().setEnabled(false);
  resizeWidth.addValueChangeListener(new ValueChangeListener(){
    public void valueChange(    ValueChangeEvent e){
      if (constrainSize.isSelected()) {
        double scale=resizeWidth.getDoubleValue() / windowWidth.getDoubleValue();
        resizeHeight.setValue(scale * windowHeight.getIntValue());
      }
      myMovieMaker.setCaptureArea(myMovieMaker.getCaptureArea(),new Dimension((Integer)resizeWidth.getIntValue(),(Integer)resizeHeight.getIntValue()),viewerCapture);
    }
  }
);
  sizeOptions.addWidget(resizeWidth);
  resizeHeight=new IntegerField(""String_Node_Str"",0);
  resizeHeight.getTextField().setEnabled(false);
  resizeHeight.addValueChangeListener(new ValueChangeListener(){
    public void valueChange(    ValueChangeEvent e){
      if (constrainSize.isSelected()) {
        double scale=resizeHeight.getDoubleValue() / windowHeight.getDoubleValue();
        resizeWidth.setValue(scale * windowWidth.getIntValue());
      }
      myMovieMaker.setCaptureArea(myMovieMaker.getCaptureArea(),new Dimension((Integer)resizeWidth.getIntValue(),(Integer)resizeHeight.getIntValue()),viewerCapture);
    }
  }
);
  sizeOptions.addWidget(resizeHeight);
  int nDefaultSamples=FrameBufferObject.defaultMultiSamples;
  resizeSamples=new IntegerField(""String_Node_Str"",nDefaultSamples);
  resizeSamples.setToolTipText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  resizeSamples.getTextField().setEnabled(false);
  resizeSamples.setRange(new IntegerInterval(1,16));
  resizeSamples.addValueChangeListener(this);
  sizeOptions.addWidget(resizeSamples);
  encOptionsBox.add(sizeOptions);
  Box extraBox=Box.createVerticalBox();
  LabeledComponentPanel advancedOptions=new LabeledComponentPanel();
  advancedOptions.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  advancedOptions.setName(""String_Node_Str"");
  workingDirField=new FileNameField(""String_Node_Str"",ArtisynthPath.getTempDir().getAbsolutePath(),10);
  workingDirField.getFileChooser().setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  workingDirField.getFileChooser().setCurrentDirectory(ArtisynthPath.getTempDir());
  advancedOptions.add(workingDirField);
  extraBox.add(advancedOptions);
  LabeledComponentPanel extraCommands=new LabeledComponentPanel();
  extraCommands.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED),""String_Node_Str""));
  extraCommands.setName(""String_Node_Str"");
  JButton waypointButton=new JButton(""String_Node_Str"");
  waypointButton.setActionCommand(WAYPOINT_CMD);
  waypointButton.addActionListener(this);
  extraCommands.addWidget(waypointButton);
  extraBox.add(extraCommands);
  tabbedPane.addTab(""String_Node_Str"",recOptionsBox);
  tabbedPane.addTab(""String_Node_Str"",encOptionsBox);
  tabbedPane.addTab(""String_Node_Str"",extraBox);
  if (myMain.getModelName() != null) {
    setMovieName(myMain.getModelName());
  }
  add(tabbedPane,BorderLayout.NORTH);
  updateMethodSelectors();
  controlPanel=new OptionPanel(""String_Node_Str"" + START_CMD + ""String_Node_Str""+ FRAME_CMD+ ""String_Node_Str""+ STOP_CMD+ ""String_Node_Str""+ CLOSE_CMD,this);
  startButton=controlPanel.getButton(START_CMD);
  stopButton=controlPanel.getButton(STOP_CMD);
  stopButton.setEnabled(false);
  frameButton=controlPanel.getButton(FRAME_CMD);
  frameButton.setEnabled(false);
  add(controlPanel,BorderLayout.CENTER);
  viewerCapture=true;
  customCapture=false;
  final Component displayComponent=myFrame.getViewer().getCanvas().getComponent();
  setCaptureArea(displayComponent);
  displayComponent.addComponentListener(new ComponentListener(){
    public void componentHidden(    ComponentEvent c_evt){
    }
    public void componentMoved(    ComponentEvent c_evt){
      if (!customCapture && viewerCapture) {
        setCaptureArea(displayComponent);
      }
 else       if (!customCapture && !viewerCapture) {
        setCaptureArea(myFrame);
      }
    }
    public void componentResized(    ComponentEvent c_evt){
      if (!customCapture && viewerCapture) {
        setCaptureArea(displayComponent);
      }
 else       if (!customCapture && !viewerCapture) {
        setCaptureArea(myFrame);
      }
    }
    public void componentShown(    ComponentEvent c_evt){
    }
  }
);
  pack();
  setMinimumSize(getPreferredSize());
}"
70663,"public void stopMovie(){
  Thread stopThread=new Thread(){
    public void run(){
      String movieFileName=filename.getText();
      myMain.setFrameRate(savedFrameRate);
      myMovieMaker.setGrabbing(false);
      myFrame.getViewer().cleanupScreenShots();
      stopButton.setEnabled(false);
      frameButton.setEnabled(false);
      startButton.setEnabled(true);
      myFrame.setAlwaysOnTop(false);
      if (myMain.getScheduler().isPlaying() == true && endRecordOnStop.isSelected()) {
        myMain.getScheduler().pause();
      }
      try {
        System.out.println(""String_Node_Str"");
        int frameCount=myMovieMaker.close();
        if (frameCount > 0) {
          if (!myMovieMaker.isRenderingAudioToFile()) {
            myMovieMaker.render(movieFileName);
          }
 else {
            ((HasAudio)myMain.getRootModel()).onStop();
            String tmpMovieFn=""String_Node_Str"" + tmpDirectory + ""String_Node_Str"";
            String finalMovieFn=""String_Node_Str"" + ArtisynthPath.getHomeDir() + ""String_Node_Str""+ movieFileName;
            System.out.println(""String_Node_Str"");
            myMovieMaker.render(tmpMovieFn);
            String waveFn=""String_Node_Str"" + ConvertRawToWav.convert(myMovieMaker.getAudioSampleRate(),myMovieMaker.getAudioFileName());
            String[] args={tmpMovieFn,waveFn,""String_Node_Str"",finalMovieFn};
            System.out.println(""String_Node_Str"" + finalMovieFn);
            new Merge(args);
          }
          if (saveMovieImage.isSelected()) {
            myMovieMaker.saveFirstFrame(movieFileName);
          }
        }
 else {
          System.out.println(""String_Node_Str"");
        }
        if (removeImages.isSelected()) {
          System.out.println(""String_Node_Str"");
          myMovieMaker.clean();
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      if ((myMain.getRootModel() instanceof HasAudio) && ((recordAudio.isSelected()) || recordAudioTxt.isSelected())) {
        System.out.println(""String_Node_Str"");
        myMovieMaker.setRenderingAudioToFile(false);
        myMovieMaker.setRenderingAudioToText(false);
        recordAudio.setSelected(false);
        recordAudioTxt.setSelected(false);
        normalizeAudio.setSelected(false);
        normalizeAudio.setEnabled(false);
        ((HasAudio)myMain.getRootModel()).setRenderAudioToFile(false);
      }
      System.out.println(""String_Node_Str"");
    }
  }
;
  stopThread.start();
  isRecordingStarted=false;
}","public void stopMovie(){
  Thread stopThread=new Thread(){
    public void run(){
      String movieFileName=filename.getText();
      File mfile=new File(myMovieMaker.getDataPath(),movieFileName);
      mfile.getParentFile().mkdirs();
      myMain.setFrameRate(savedFrameRate);
      myMovieMaker.setGrabbing(false);
      myFrame.getViewer().cleanupScreenShots();
      stopButton.setEnabled(false);
      frameButton.setEnabled(false);
      startButton.setEnabled(true);
      myFrame.setAlwaysOnTop(false);
      if (myMain.getScheduler().isPlaying() == true && endRecordOnStop.isSelected()) {
        myMain.getScheduler().pause();
      }
      try {
        System.out.println(""String_Node_Str"");
        int frameCount=myMovieMaker.close();
        if (frameCount > 0) {
          if (!myMovieMaker.isRenderingAudioToFile()) {
            myMovieMaker.render(movieFileName);
          }
 else {
            ((HasAudio)myMain.getRootModel()).onStop();
            String tmpMovieFn=""String_Node_Str"" + tmpDirectory + ""String_Node_Str"";
            String finalMovieFn=""String_Node_Str"" + ArtisynthPath.getHomeDir() + ""String_Node_Str""+ movieFileName;
            System.out.println(""String_Node_Str"");
            myMovieMaker.render(tmpMovieFn);
            String waveFn=""String_Node_Str"" + ConvertRawToWav.convert(myMovieMaker.getAudioSampleRate(),myMovieMaker.getAudioFileName());
            String[] args={tmpMovieFn,waveFn,""String_Node_Str"",finalMovieFn};
            System.out.println(""String_Node_Str"" + finalMovieFn);
            new Merge(args);
          }
          if (saveMovieImage.isSelected()) {
            myMovieMaker.saveFirstFrame(movieFileName);
          }
        }
 else {
          System.out.println(""String_Node_Str"");
        }
        if (removeImages.isSelected()) {
          System.out.println(""String_Node_Str"");
          myMovieMaker.clean();
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      if ((myMain.getRootModel() instanceof HasAudio) && ((recordAudio.isSelected()) || recordAudioTxt.isSelected())) {
        System.out.println(""String_Node_Str"");
        myMovieMaker.setRenderingAudioToFile(false);
        myMovieMaker.setRenderingAudioToText(false);
        recordAudio.setSelected(false);
        recordAudioTxt.setSelected(false);
        normalizeAudio.setSelected(false);
        normalizeAudio.setEnabled(false);
        ((HasAudio)myMain.getRootModel()).setRenderAudioToFile(false);
      }
      System.out.println(""String_Node_Str"");
    }
  }
;
  stopThread.start();
  isRecordingStarted=false;
}"
70664,"public void resetProbes(RootModel root,TrackingController controller){
  if (root != null) {
    findOrCreateProbes(root,controller);
    configureProbes(controller);
  }
}","public void resetProbes(RootModel root,TrackingController controller){
  if (root != null) {
    root.removeAllInputProbes();
    root.removeAllOutputProbes();
    findOrCreateProbes(root,controller);
    configureProbes(controller);
  }
}"
70665,"/** 
 * Returns <code>t0</code> modulo <code>t1</code>,  within the tolerance specified by   {@link #PRECISION}.
 * @return t0 % t1 within {@link #PRECISION}.
 */
public static double modulo(double t0,double t1){
  long l0=(long)Math.rint(t0 * PRECISION);
  long l1=(long)Math.rint(t1 * PRECISION);
  return (l0 % l1) / PRECISION;
}","/** 
 * Returns <code>t0</code> modulo <code>t1</code>,  within the tolerance specified by   {@link #PRECISION}.
 * @return t0 % t1 within {@link #PRECISION}.
 */
public static double modulo(double t0,double t1){
  long l0=(long)Math.round(t0 * PRECISION);
  long l1=(long)Math.round(t1 * PRECISION);
  return (l0 % l1) / PRECISION;
}"
70666,"public void transformGeometry(GeometryTransformer gt,RigidTransform3d TFW,RigidTransform3d TDW){
  if (doCouplingTransform) {
    for (int i=0; i < myPoints.size(); i++) {
      Point3d pnt=myPoints.get(i);
      pnt.transform(TDW);
      gt.transformPnt(pnt);
      pnt.inverseTransform(TDW);
    }
    makePlanesFromSegments(myPoints);
  }
}","public void transformGeometry(GeometryTransformer gt,RigidTransform3d TFW,RigidTransform3d TDW){
  if (doCouplingTransform) {
    RigidTransform3d TDWnew=new RigidTransform3d(TDW);
    gt.transform(TDWnew);
    Vector3d del0=new Vector3d();
    del0.set(myPoints.get(0));
    for (int i=0; i < myPoints.size(); i++) {
      Point3d pnt=myPoints.get(i);
      pnt.transform(TDW);
      gt.transformPnt(pnt);
      pnt.inverseTransform(TDWnew);
    }
    makePlanesFromSegments(myPoints);
  }
}"
70667,"protected void maybeUpdateMaterials(GL3 gl){
  if (isSelecting()) {
    if (mySelectingColorModified && myCommittedProgramInfo != null && myCommittedProgramInfo.isSelecting()) {
      myProgManager.setSelectionColor(gl,myCommittedProgram,mySelectingColor);
      mySelectingColorModified=false;
    }
  }
 else {
    if (myCurrentMaterial.getAlpha() != myHighlightColor[3]) {
      myHighlightColor[3]=myCurrentMaterial.getAlpha();
      myHighlightColorModified=true;
    }
    if (myCurrentMaterialModified || myHighlightColorModified || myCommittedColor != myActiveColor) {
      if (myActiveColor == ActiveColor.HIGHLIGHT) {
        myProgManager.setMaterials(gl,myCurrentMaterial,myHighlightColor,myCurrentMaterial,myHighlightColor);
        myHighlightColorModified=false;
      }
 else {
        myProgManager.setMaterials(gl,myCurrentMaterial,myCurrentMaterial.getDiffuse(),myCurrentMaterial,myBackColor);
      }
      myCurrentMaterialModified=false;
      myCommittedColor=myActiveColor;
    }
  }
}","protected void maybeUpdateMaterials(GL3 gl){
  if (isSelecting()) {
    if (mySelectingColorModified && myCommittedProgram != null && myCommittedProgramInfo.isSelecting()) {
      myProgManager.setSelectionColor(gl,myCommittedProgram,mySelectingColor);
      mySelectingColorModified=false;
    }
  }
 else {
    if (myCurrentMaterial.getAlpha() != myHighlightColor[3]) {
      myHighlightColor[3]=myCurrentMaterial.getAlpha();
      myHighlightColorModified=true;
    }
    if (myCurrentMaterialModified || myHighlightColorModified || myCommittedColor != myActiveColor) {
      if (myActiveColor == ActiveColor.HIGHLIGHT) {
        myProgManager.setMaterials(gl,myCurrentMaterial,myHighlightColor,myCurrentMaterial,myHighlightColor);
        myHighlightColorModified=false;
      }
 else {
        myProgManager.setMaterials(gl,myCurrentMaterial,myCurrentMaterial.getDiffuse(),myCurrentMaterial,myBackColor);
      }
      myCurrentMaterialModified=false;
      myCommittedColor=myActiveColor;
    }
  }
}"
70668,"private static void addVertexOutputs(StringBuilder hb,GLProgramInfo info){
  RenderingMode instanced=info.getMode();
  boolean hasColors=(!info.isSelecting()) && (info.getVertexColorMixing() != ColorMixing.NONE) && (info.hasVertexColors() || ((instanced == RenderingMode.INSTANCED_POINTS || instanced == RenderingMode.INSTANCED_FRAMES || instanced == RenderingMode.INSTANCED_AFFINES) && info.hasInstanceColors()) || (instanced == RenderingMode.INSTANCED_LINES && info.hasLineColors()));
  boolean hasTextures=!info.isSelecting() && info.hasVertexTextures() && info.hasTextureMap();
  if (hasColors) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    if (info.getColorInterpolation() == ColorInterpolation.NONE) {
      appendln(hb,""String_Node_Str"");
    }
 else {
      appendln(hb,""String_Node_Str"");
    }
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
  if (hasTextures) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
}","private static void addVertexOutputs(StringBuilder hb,GLProgramInfo info){
  RenderingMode instanced=info.getMode();
  boolean hasColors=(!info.isSelecting()) && (info.getVertexColorMixing() != ColorMixing.NONE) && (info.hasVertexColors() || ((instanced == RenderingMode.INSTANCED_POINTS || instanced == RenderingMode.INSTANCED_FRAMES || instanced == RenderingMode.INSTANCED_AFFINES) && info.hasInstanceColors()) || (instanced == RenderingMode.INSTANCED_LINES && info.hasLineColors()));
  boolean hasTextures=hasTextures(info);
  if (hasColors) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    if (info.getColorInterpolation() == ColorInterpolation.NONE) {
      appendln(hb,""String_Node_Str"");
    }
 else {
      appendln(hb,""String_Node_Str"");
    }
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
  if (hasTextures) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
}"
70669,"private static void buildFragmentShaderMain(StringBuilder mb,GLProgramInfo info){
  RenderingMode mode=info.getMode();
  ColorInterpolation cinterp=info.getColorInterpolation();
  boolean hasTextures=info.hasVertexTextures();
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  if (mode == RenderingMode.POINTS && info.hasRoundPoints()) {
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
  }
  boolean lights=false;
  if (!info.isSelecting()) {
    if (info.getShading() != Shading.NONE && info.numLights() > 0) {
      lights=true;
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
switch (info.getShading()) {
case FLAT:
        appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
break;
case SMOOTH:
case METAL:
appendln(mb,""String_Node_Str"");
if (!info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (hasTextures) {
if (info.hasNormalMap()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
if (info.hasBumpMap()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
break;
case NONE:
break;
}
}
 else {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
boolean hasFragmentColors=(info.getVertexColorMixing() != ColorMixing.NONE) && (info.hasVertexColors() || ((mode == RenderingMode.INSTANCED_POINTS || mode == RenderingMode.INSTANCED_FRAMES || mode == RenderingMode.INSTANCED_AFFINES) && info.hasInstanceColors()) || (mode == RenderingMode.INSTANCED_LINES && info.hasLineColors()));
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
if (hasFragmentColors) {
appendln(mb,""String_Node_Str"");
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getVertexColorMixing();
switch (cmix) {
case DECAL:
if (info.isMixVertexColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case MODULATE:
if (info.isMixVertexColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case REPLACE:
if (info.isMixVertexColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
default :
}
}
if (hasTextures && info.hasColorMap()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getTextureColorMixing();
switch (cmix) {
case DECAL:
if (info.isMixTextureColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case MODULATE:
if (info.isMixTextureColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case REPLACE:
if (info.isMixTextureColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
break;
default :
}
appendln(mb);
}
}
if (info.isSelecting()) {
appendln(mb,""String_Node_Str"");
}
 else if (lights) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
appendln(mb,""String_Node_Str"");
}","private static void buildFragmentShaderMain(StringBuilder mb,GLProgramInfo info){
  RenderingMode mode=info.getMode();
  ColorInterpolation cinterp=info.getColorInterpolation();
  boolean hasTextures=hasTextures(info);
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  if (mode == RenderingMode.POINTS && info.hasRoundPoints()) {
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
  }
  boolean lights=false;
  if (!info.isSelecting()) {
    if (info.getShading() != Shading.NONE && info.numLights() > 0) {
      lights=true;
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
switch (info.getShading()) {
case FLAT:
        appendln(mb,""String_Node_Str"");
      appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
break;
case SMOOTH:
case METAL:
appendln(mb,""String_Node_Str"");
if (!info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (hasTextures) {
if (info.hasNormalMap()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
if (info.hasBumpMap()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
break;
case NONE:
break;
}
}
 else {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
boolean hasFragmentColors=(info.getVertexColorMixing() != ColorMixing.NONE) && (info.hasVertexColors() || ((mode == RenderingMode.INSTANCED_POINTS || mode == RenderingMode.INSTANCED_FRAMES || mode == RenderingMode.INSTANCED_AFFINES) && info.hasInstanceColors()) || (mode == RenderingMode.INSTANCED_LINES && info.hasLineColors()));
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
if (hasFragmentColors) {
appendln(mb,""String_Node_Str"");
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getVertexColorMixing();
switch (cmix) {
case DECAL:
if (info.isMixVertexColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case MODULATE:
if (info.isMixVertexColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case REPLACE:
if (info.isMixVertexColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixVertexColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
default :
}
}
if (hasTextures && info.hasColorMap()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getTextureColorMixing();
switch (cmix) {
case DECAL:
if (info.isMixTextureColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case MODULATE:
if (info.isMixTextureColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case REPLACE:
if (info.isMixTextureColorDiffuse()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorSpecular()) {
appendln(mb,""String_Node_Str"");
}
if (info.isMixTextureColorEmission()) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
break;
default :
}
appendln(mb);
}
}
if (info.isSelecting()) {
appendln(mb,""String_Node_Str"");
}
 else if (lights) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
appendln(mb,""String_Node_Str"");
}"
70670,"private static void addFragmentInfo(StringBuilder hb,GLProgramInfo info){
  appendln(hb,""String_Node_Str"");
  appendln(hb,""String_Node_Str"");
  appendln(hb);
  if (info.isSelecting()) {
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
  RenderingMode instanced=info.getMode();
  boolean hasColors=!info.isSelecting() && (info.getVertexColorMixing() != ColorMixing.NONE) && (info.hasVertexColors() || ((instanced == RenderingMode.INSTANCED_POINTS || instanced == RenderingMode.INSTANCED_FRAMES || instanced == RenderingMode.INSTANCED_AFFINES) && info.hasInstanceColors()) || (instanced == RenderingMode.INSTANCED_LINES && info.hasLineColors()));
  boolean hasTextures=!info.isSelecting() && info.hasVertexTextures();
  if (hasColors) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    if (info.getColorInterpolation() == ColorInterpolation.NONE) {
      appendln(hb,""String_Node_Str"");
    }
 else {
      appendln(hb,""String_Node_Str"");
    }
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
  if (hasTextures) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    if (info.hasColorMap()) {
      appendln(hb,""String_Node_Str"");
    }
    if (hasFragmentLighting(info.getShading())) {
      if (info.hasNormalMap()) {
        appendln(hb,""String_Node_Str"");
        appendln(hb,""String_Node_Str"");
      }
      if (info.hasBumpMap()) {
        appendln(hb,""String_Node_Str"");
        appendln(hb,""String_Node_Str"");
      }
    }
    appendln(hb);
  }
}","private static void addFragmentInfo(StringBuilder hb,GLProgramInfo info){
  appendln(hb,""String_Node_Str"");
  appendln(hb,""String_Node_Str"");
  appendln(hb);
  if (info.isSelecting()) {
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
  RenderingMode instanced=info.getMode();
  boolean hasColors=!info.isSelecting() && (info.getVertexColorMixing() != ColorMixing.NONE) && (info.hasVertexColors() || ((instanced == RenderingMode.INSTANCED_POINTS || instanced == RenderingMode.INSTANCED_FRAMES || instanced == RenderingMode.INSTANCED_AFFINES) && info.hasInstanceColors()) || (instanced == RenderingMode.INSTANCED_LINES && info.hasLineColors()));
  boolean hasTextures=hasTextures(info);
  if (hasColors) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    if (info.getColorInterpolation() == ColorInterpolation.NONE) {
      appendln(hb,""String_Node_Str"");
    }
 else {
      appendln(hb,""String_Node_Str"");
    }
    appendln(hb,""String_Node_Str"");
    appendln(hb);
  }
  if (hasTextures) {
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    appendln(hb,""String_Node_Str"");
    if (info.hasColorMap()) {
      appendln(hb,""String_Node_Str"");
    }
    if (hasFragmentLighting(info.getShading())) {
      if (info.hasNormalMap()) {
        appendln(hb,""String_Node_Str"");
        appendln(hb,""String_Node_Str"");
      }
      if (info.hasBumpMap()) {
        appendln(hb,""String_Node_Str"");
        appendln(hb,""String_Node_Str"");
      }
    }
    appendln(hb);
  }
}"
70671,"private static void buildVertexShaderMain(StringBuilder mb,GLProgramInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb);
  appendln(mb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(mb,""String_Node_Str"");
  }
  appendln(mb);
  RenderingMode mode=info.getMode();
  boolean computeNormals=!info.isSelecting() && info.hasVertexNormals() && info.getShading() != Shading.NONE;
switch (mode) {
case INSTANCED_AFFINES:
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
if (computeNormals) {
  appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case INSTANCED_FRAMES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (computeNormals) {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case INSTANCED_LINES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
}
if (computeNormals) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
}
appendln(mb);
break;
case INSTANCED_POINTS:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (!info.isSelecting() && info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
case DEFAULT:
case POINTS:
appendln(mb,""String_Node_Str"");
if (computeNormals) {
appendln(mb,""String_Node_Str"");
}
break;
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
ColorInterpolation cinterp=info.getColorInterpolation();
if (!info.isSelecting() && info.getVertexColorMixing() != ColorMixing.NONE) {
switch (mode) {
case INSTANCED_POINTS:
case INSTANCED_FRAMES:
case INSTANCED_AFFINES:
if (info.hasInstanceColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case INSTANCED_LINES:
if (info.hasLineColors()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case DEFAULT:
case POINTS:
if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
}
}
if (!info.isSelecting()) {
switch (info.getShading()) {
case FLAT:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case SMOOTH:
case METAL:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
break;
}
}
boolean hasTextures=!info.isSelecting() && info.hasVertexTextures() && info.hasTextureMap();
if (hasTextures) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
if (info.numClipPlanes() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numClipPlanes() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
appendln(mb,""String_Node_Str"");
}","private static void buildVertexShaderMain(StringBuilder mb,GLProgramInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb);
  appendln(mb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(mb,""String_Node_Str"");
  }
  appendln(mb);
  RenderingMode mode=info.getMode();
  boolean computeNormals=!info.isSelecting() && info.hasVertexNormals() && info.getShading() != Shading.NONE;
switch (mode) {
case INSTANCED_AFFINES:
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
if (computeNormals) {
  appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case INSTANCED_FRAMES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (computeNormals) {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case INSTANCED_LINES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
}
if (computeNormals) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
}
appendln(mb);
break;
case INSTANCED_POINTS:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (!info.isSelecting() && info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
case DEFAULT:
case POINTS:
appendln(mb,""String_Node_Str"");
if (computeNormals) {
appendln(mb,""String_Node_Str"");
}
break;
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
ColorInterpolation cinterp=info.getColorInterpolation();
if (!info.isSelecting() && info.getVertexColorMixing() != ColorMixing.NONE) {
switch (mode) {
case INSTANCED_POINTS:
case INSTANCED_FRAMES:
case INSTANCED_AFFINES:
if (info.hasInstanceColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case INSTANCED_LINES:
if (info.hasLineColors()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineScaleOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case DEFAULT:
case POINTS:
if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
}
}
if (!info.isSelecting()) {
switch (info.getShading()) {
case FLAT:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case SMOOTH:
case METAL:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
break;
}
}
boolean hasTextures=hasTextures(info);
if (hasTextures) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
if (info.numClipPlanes() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numClipPlanes() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
appendln(mb,""String_Node_Str"");
}"
70672,"/** 
 * Checks each knot in this segment to see if it is intersecting any wrappables, and if so, computes the contact normal and distance. If a knot intersects multiple wrappables, then the one with the deepest penetration is used. <p>This method returns <code>true</code> if the contact configuration has changed.
 * @param getStiffness TODO
 */
boolean updateContacts(int[] contactCnts,boolean getStiffness){
  boolean changed=false;
  Vector3d nrml=new Vector3d();
  Matrix3d dnrm=getStiffness ? new Matrix3d() : null;
  if (contactCnts != null) {
    for (int i=0; i < contactCnts.length; i++) {
      contactCnts[i]=0;
    }
  }
  for (int k=0; k < myNumKnots; k++) {
    WrapKnot knot=myKnots[k];
    Wrappable lastWrappable=knot.getWrappable();
    knot.myPrevDist=knot.myDist;
    knot.myPrevWrappableIdx=knot.myWrappableIdx;
    knot.setWrappableIdx(-1);
    knot.myDist=Wrappable.OUTSIDE;
    for (int i=0; i < myWrappables.size(); i++) {
      Wrappable wrappable=myWrappables.get(i);
      double d=wrappable.penetrationDistance(nrml,dnrm,knot.myPos);
      if (d < knot.myDist) {
        knot.myDist=d;
        if (d < 0) {
          knot.setWrappableIdx(i);
          if (contactCnts != null) {
            contactCnts[i]++;
          }
          knot.myNrml.set(nrml);
          if (dnrm != null) {
            knot.myDnrm.set(dnrm);
          }
        }
      }
    }
    if (knot.getWrappable() != lastWrappable) {
      changed=true;
    }
  }
  return changed;
}","/** 
 * Checks each knot in this segment to see if it is intersecting any wrappables, and if so, computes the contact normal and distance. If a knot intersects multiple wrappables, then the one with the deepest penetration is used. <p>This method returns <code>true</code> if the contact configuration has changed.
 * @param getStiffness TODO
 */
boolean updateContacts(int[] contactCnts,boolean getStiffness){
  boolean changed=false;
  Vector3d nrml=new Vector3d();
  Matrix3d dnrm=getStiffness ? new Matrix3d() : null;
  if (contactCnts != null) {
    for (int i=0; i < contactCnts.length; i++) {
      contactCnts[i]=0;
    }
  }
  for (int k=0; k < myNumKnots; k++) {
    WrapKnot knot=myKnots[k];
    Wrappable lastWrappable=knot.getWrappable();
    if (contactCnts != null) {
      knot.myPrevDist=knot.myDist;
      knot.myPrevWrappableIdx=knot.myWrappableIdx;
    }
    knot.setWrappableIdx(-1);
    knot.myDist=Wrappable.OUTSIDE;
    for (int i=0; i < myWrappables.size(); i++) {
      Wrappable wrappable=myWrappables.get(i);
      double d=wrappable.penetrationDistance(nrml,dnrm,knot.myPos);
      if (d < knot.myDist) {
        knot.myDist=d;
        if (d < 0) {
          knot.setWrappableIdx(i);
          if (contactCnts != null) {
            contactCnts[i]++;
          }
          knot.myNrml.set(nrml);
          if (dnrm != null) {
            knot.myDnrm.set(dnrm);
          }
        }
      }
    }
    if (knot.getWrappable() != lastWrappable) {
      changed=true;
    }
  }
  return changed;
}"
70673,"/** 
 * Updates the knot points in this wrappable segment. This is done by iterating until the first order physics resulting from the attractive forces between adjacent knots and repulsive forces from contacting wrappables results in a stable configuration.
 */
protected int updateWrapStrand(int maxIter){
  int icnt=0;
  boolean converged=false;
  double dscale=myDscale;
  updateContactingKnotPositions();
  int[] contactCnts=getContactCnts();
  int[] newContactCnts=new int[myWrappables.size()];
  updateForces();
  double prevEnergy=computeEnergy();
  double prevForceSqr=computeForceSqr();
  double prevForce=forceNorm();
  boolean wroteR=false;
  boolean wroteRx=false;
  do {
    double prevLength=myLength;
    if (inContact()) {
    }
    updateStiffness(0,dscale);
    boolean clipped=(factorAndSolve() < 1.0);
    double r0=forceDotDisp();
    double denom=forceNorm() * computeDvecLength();
    double cos=r0 / denom;
    double mincos=0.1;
    if (cos < mincos) {
      double lam=(denom * (mincos - cos) / computeForceSqr());
      modifyDvec(lam);
      r0=forceDotDisp();
      if (debugLevel > 0) {
        System.out.println(""String_Node_Str"" + cos + ""String_Node_Str""+ r0 / (forceNorm() * computeDvecLength()));
      }
    }
    double computedFSqr=computeForceSqrDeriv();
    savePosToPrev();
    LineSearchFunc func=new EnergyFunc();
    double f0, df0;
    if (func instanceof ForceSqrFunc) {
      f0=computeForceSqr();
      df0=computeForceSqrDeriv();
    }
 else {
      f0=computeEnergy();
      df0=-forceDotDisp();
    }
    double h=1e-8;
    prevEnergy=computeEnergy();
    advancePosByDvec(h);
    updateContacts(null,false);
    updateForces();
    double forceSqr=computeForceSqr();
    double energy=computeEnergy();
    double ederiv=(energy - prevEnergy) / h;
    double fsqrDeriv=(forceSqr - prevForceSqr) / h;
    double s=1.0;
    advancePosByDvec(s);
    contactDebug=(icnt == 0);
    boolean contactChanged=updateContacts(newContactCnts,true);
    contactDebug=false;
    boolean contactBroken=checkForBrokenContact(contactCnts,newContactCnts);
    updateForces();
    energy=computeEnergy();
    forceSqr=computeForceSqr();
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + prevEnergy + ""String_Node_Str""+ energy+ ""String_Node_Str""+ ederiv);
    }
    double r1=forceDotDisp();
    DoubleHolder deriv=new DoubleHolder();
    double f1=func.eval(deriv,s);
    double df1=deriv.value;
    if (contactBroken) {
      saveDvecToVtmp();
      updateStiffness(0,dscale);
      factorAndSolve();
      double scale=1.0;
      for (int k=0; k < myNumKnots; k++) {
        WrapKnot knot=myKnots[k];
        int widx=knot.myPrevWrappableIdx;
        if (widx != -1 && newContactCnts[widx] != 0) {
          if (knot.myDvec.dot(knot.myVtmp) < 0) {
            if (debugLevel > 0)             System.out.println(""String_Node_Str"");
            double dist=knot.myDist;
            double prev=knot.myPrevDist;
            if (dist != Wrappable.OUTSIDE && dist > 0 && prev < 0) {
              double r=dist / (dist - prev);
              if (r < scale) {
                scale=r;
              }
            }
          }
        }
      }
      if (scale < 1.0) {
        if (myContactRescaling) {
          if (debugLevel > 0) {
            System.out.println(""String_Node_Str"" + (1 - scale));
          }
          advancePosByVtmp(1 - scale);
          s=1 - scale;
          updateContacts(contactCnts,true);
          updateForces();
          f1=computeEnergy();
          df1=-forceDotDisp();
        }
      }
 else {
        restoreDvecFromVtmp();
      }
    }
    double ltol=myLength * myLengthConvTol;
    if (!contactChanged) {
      double maxLatDisp=maxLateralDisplacement();
      if (debugLevel > 0) {
      }
      if (maxLatDisp / myLength < 1e-4 && Math.abs(prevLength - myLength) < ltol) {
        converged=true;
      }
    }
    if (!converged && myLineSearchP) {
      ResidualFunc rfunc=new ResidualFunc();
      double maxs=(contactChanged ? s : 3.0);
      if (df0 >= 0) {
        System.out.println(""String_Node_Str"" + df0);
        printStuckDebugInfo(maxs);
      }
 else {
        double snew=lineSearch(f0,df0,f1,df1,func,0.1,2.0,s,maxs);
        if (snew != s) {
          if (debugLevel > 0) {
            System.out.printf(""String_Node_Str"",snew);
          }
          rfunc.eval(snew);
          updateContacts(null,true);
          energy=computeEnergy();
          forceSqr=computeForceSqr();
        }
 else {
          rfunc.eval(s);
          updateContacts(null,true);
        }
      }
      if (false) {
      }
    }
    double newEnergy=computeEnergy();
    if (debugLevel > 0) {
      System.out.printf(""String_Node_Str"",(newEnergy - prevEnergy));
    }
    prevEnergy=energy;
    prevForceSqr=forceSqr;
    prevForce=forceNorm();
  }
 while (++icnt < maxIter && !converged);
  saveContactingKnotPositions();
  totalIterations+=icnt;
  totalCalls++;
  if (converged) {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + icnt);
    }
  }
 else {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"");
    }
    totalFails++;
  }
  if ((totalCalls % 100) == 0) {
  }
  myDscale=dscale;
  return icnt;
}","/** 
 * Updates the knot points in this wrappable segment. This is done by iterating until the first order physics resulting from the attractive forces between adjacent knots and repulsive forces from contacting wrappables results in a stable configuration.
 */
protected int updateWrapStrand(int maxIter){
  int icnt=0;
  boolean converged=false;
  double dscale=myDscale;
  updateContactingKnotPositions();
  int[] contactCnts=getContactCnts();
  int[] newContactCnts=new int[myWrappables.size()];
  updateForces();
  double prevEnergy=computeEnergy();
  double prevForceSqr=computeForceSqr();
  double prevForce=forceNorm();
  boolean wroteR=false;
  boolean wroteRx=false;
  do {
    double prevLength=myLength;
    if (inContact()) {
    }
    updateStiffness(0,dscale);
    boolean clipped=(factorAndSolve() < 1.0);
    double r0=forceDotDisp();
    double denom=forceNorm() * computeDvecLength();
    double cos=r0 / denom;
    double mincos=0.1;
    if (cos < mincos) {
      double lam=(denom * (mincos - cos) / computeForceSqr());
      modifyDvec(lam);
      r0=forceDotDisp();
      if (debugLevel > 0) {
        System.out.println(""String_Node_Str"" + cos + ""String_Node_Str""+ r0 / (forceNorm() * computeDvecLength()));
      }
    }
    double computedFSqr=computeForceSqrDeriv();
    savePosToPrev();
    LineSearchFunc func=new EnergyFunc();
    double f0, df0;
    if (func instanceof ForceSqrFunc) {
      f0=computeForceSqr();
      df0=computeForceSqrDeriv();
    }
 else {
      f0=computeEnergy();
      df0=-forceDotDisp();
    }
    getContactCounts(contactCnts);
    double h=1e-8;
    prevEnergy=computeEnergy();
    advancePosByDvec(h);
    updateContacts(null,false);
    updateForces();
    double forceSqr=computeForceSqr();
    double energy=computeEnergy();
    double ederiv=(energy - prevEnergy) / h;
    double fsqrDeriv=(forceSqr - prevForceSqr) / h;
    double s=1.0;
    advancePosByDvec(s);
    contactDebug=(icnt == 0);
    boolean contactChanged=updateContacts(newContactCnts,true);
    contactDebug=false;
    boolean contactBroken=checkForBrokenContact(contactCnts,newContactCnts);
    updateForces();
    energy=computeEnergy();
    forceSqr=computeForceSqr();
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + prevEnergy + ""String_Node_Str""+ energy+ ""String_Node_Str""+ ederiv);
    }
    double r1=forceDotDisp();
    DoubleHolder deriv=new DoubleHolder();
    double f1=func.eval(deriv,s);
    double df1=deriv.value;
    WrapKnot pullbackKnot=null;
    if (contactBroken) {
      saveDvecToVtmp();
      updateStiffness(0,dscale);
      factorAndSolve();
      double pullback=1.0;
      for (int k=0; k < myNumKnots; k++) {
        WrapKnot knot=myKnots[k];
        int widx=knot.myPrevWrappableIdx;
        if (widx != -1 && newContactCnts[widx] != 0) {
          if (knot.myDvec.dot(knot.myVtmp) < 0) {
            double dist=knot.myDist;
            double prev=knot.myPrevDist;
            if (dist != Wrappable.OUTSIDE && dist > 0 && prev < 0) {
              double r=dist / (dist - prev);
              if (r < pullback) {
                pullback=r;
                pullbackKnot=knot;
              }
            }
          }
        }
      }
      if (pullbackKnot != null) {
        if (myContactRescaling) {
          s=computeRescale(pullbackKnot,pullback);
          advancePosByVtmp(s);
          updateContacts(null,true);
          updateForces();
          if (debugLevel > 0) {
            System.out.println(""String_Node_Str"" + s);
          }
          f1=computeEnergy();
          df1=-forceDotDisp();
        }
      }
      restoreDvecFromVtmp();
    }
    double ltol=myLength * myLengthConvTol;
    if (!contactChanged) {
      double maxLatDisp=maxLateralDisplacement();
      if (debugLevel > 0) {
      }
      if (maxLatDisp / myLength < 1e-4 && Math.abs(prevLength - myLength) < ltol) {
        converged=true;
      }
    }
    if (!converged && myLineSearchP) {
      ResidualFunc rfunc=new ResidualFunc();
      double maxs=(contactChanged ? s : 3.0);
      if (df0 >= 0) {
        System.out.println(""String_Node_Str"" + df0);
        printStuckDebugInfo(maxs);
      }
 else {
        double snew=lineSearch(f0,df0,f1,df1,func,0.1,2.0,s,maxs);
        if (snew != s) {
          if (debugLevel > 0) {
            System.out.printf(""String_Node_Str"",snew);
          }
          rfunc.eval(snew);
          updateContacts(null,true);
          energy=computeEnergy();
          forceSqr=computeForceSqr();
        }
 else {
          rfunc.eval(s);
          updateContacts(null,true);
        }
      }
      if (false) {
      }
    }
    double newEnergy=computeEnergy();
    if (debugLevel > 0) {
      System.out.printf(""String_Node_Str"",(newEnergy - prevEnergy));
    }
    prevEnergy=energy;
    prevForceSqr=forceSqr;
    prevForce=forceNorm();
  }
 while (++icnt < maxIter && !converged);
  saveContactingKnotPositions();
  totalIterations+=icnt;
  totalCalls++;
  if (converged) {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + icnt + ""String_Node_Str""+ numContacts());
    }
  }
 else {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + icnt + ""String_Node_Str""+ numContacts());
    }
    totalFails++;
  }
  if ((totalCalls % 100) == 0) {
  }
  myDscale=dscale;
  return icnt;
}"
70674,"void updateStiffnessNumerically(double dscale){
  double d=dscale * myWrapDamping / (myNumKnots * myNumKnots);
  MatrixNd KN=computeNumericStiffness();
  int numk=myNumKnots;
  Matrix3d B=new Matrix3d();
  for (int k=0; k < numk; k++) {
    KN.getSubMatrix(3 * k,3 * k,B);
    B.negate();
    B.m00+=d;
    B.m11+=d;
    B.m22+=d;
    myKnots[k].myBmat.set(B);
  }
}","void updateStiffnessNumerically(double dscale){
  double d=dscale * getWrapDamping() / (myNumKnots * myNumKnots);
  MatrixNd KN=computeNumericStiffness();
  int numk=myNumKnots;
  Matrix3d B=new Matrix3d();
  for (int k=0; k < numk; k++) {
    KN.getSubMatrix(3 * k,3 * k,B);
    B.negate();
    B.m00+=d;
    B.m11+=d;
    B.m22+=d;
    myKnots[k].myBmat.set(B);
  }
}"
70675,"double factorAndSolve(){
  double c=-myWrapStiffness;
  double d=myWrapDamping / (myNumKnots * myNumKnots);
  WrapKnot knot=myKnots[0];
  addToDiagonal(knot.myBinv,knot.myBmat,d);
  knot.myBinv.invert();
  knot.myCinv.scale(c,knot.myBinv);
  for (int i=1; i < myNumKnots; i++) {
    knot=myKnots[i];
    Matrix3d Binv=knot.myBinv;
    addToDiagonal(Binv,knot.myBmat,d);
    Binv.scaledAdd(-c,myKnots[i - 1].myCinv);
    Binv.invert();
    if (i < myNumKnots - 1) {
      knot.myCinv.scale(c,Binv);
    }
  }
  Vector3d vec=new Vector3d();
  Vector3d tmp=new Vector3d();
  knot=myKnots[0];
  knot.myBinv.mul(knot.myDvec,knot.myForce);
  for (int i=1; i < myNumKnots; i++) {
    knot=myKnots[i];
    vec.set(knot.myForce);
    vec.scaledAdd(-c,myKnots[i - 1].myDvec);
    knot.myBinv.mul(knot.myDvec,vec);
  }
  int k=myNumKnots - 1;
  vec.set(myKnots[k].myDvec);
  double maxd=0;
  while (--k >= 0) {
    knot=myKnots[k];
    knot.myCinv.mul(tmp,vec);
    vec.sub(knot.myDvec,tmp);
    knot.myDvec.set(vec);
    double m=vec.infinityNorm();
    if (m > maxd) {
      maxd=m;
    }
  }
  double s=1.0;
  if (maxd > getMaxWrapDisplacement()) {
    s=getMaxWrapDisplacement() / maxd;
    for (int i=0; i < myNumKnots; i++) {
      myKnots[i].myDvec.scale(s);
    }
  }
  return s;
}","double factorAndSolve(){
  double c=-myWrapStiffness;
  double d=getWrapDamping() / (myNumKnots * myNumKnots);
  WrapKnot knot=myKnots[0];
  addToDiagonal(knot.myBinv,knot.myBmat,d);
  knot.myBinv.invert();
  knot.myCinv.scale(c,knot.myBinv);
  for (int i=1; i < myNumKnots; i++) {
    knot=myKnots[i];
    Matrix3d Binv=knot.myBinv;
    addToDiagonal(Binv,knot.myBmat,d);
    Binv.scaledAdd(-c,myKnots[i - 1].myCinv);
    Binv.invert();
    if (i < myNumKnots - 1) {
      knot.myCinv.scale(c,Binv);
    }
  }
  Vector3d vec=new Vector3d();
  Vector3d tmp=new Vector3d();
  knot=myKnots[0];
  knot.myBinv.mul(knot.myDvec,knot.myForce);
  for (int i=1; i < myNumKnots; i++) {
    knot=myKnots[i];
    vec.set(knot.myForce);
    vec.scaledAdd(-c,myKnots[i - 1].myDvec);
    knot.myBinv.mul(knot.myDvec,vec);
  }
  int k=myNumKnots - 1;
  vec.set(myKnots[k].myDvec);
  double maxd=0;
  while (--k >= 0) {
    knot=myKnots[k];
    knot.myCinv.mul(tmp,vec);
    vec.sub(knot.myDvec,tmp);
    knot.myDvec.set(vec);
    double m=vec.infinityNorm();
    if (m > maxd) {
      maxd=m;
    }
  }
  double s=1.0;
  if (maxd > getMaxWrapDisplacement()) {
    s=getMaxWrapDisplacement() / maxd;
    for (int i=0; i < myNumKnots; i++) {
      myKnots[i].myDvec.scale(s);
    }
  }
  return s;
}"
70676,"/** 
 * Updates the stiffness matrix terms associated with each knot point. These give the force derivatives with respect to changes in knot position. The stiffness matrix structure is block-tridiagonal, where the diagonal blocks account for self-motion and changes wrappable repulsion forces, while the off-diagonal blocks account for the coupling between adjacent blocks.
 */
protected void updateStiffness(double dnrmGain,double dscale){
  double stiffness=myWrapStiffness;
  double cstiffness=myContactStiffness;
  double d=dscale * myWrapDamping / (myNumKnots * myNumKnots);
  double cd=dscale * myContactDamping / (myNumKnots * myNumKnots);
  for (int k=0; k < myNumKnots; k++) {
    WrapKnot knot=myKnots[k];
    double s=2 * stiffness;
    knot.myBmat.setDiagonal(s,s,s);
    if (knot.myDist < 0) {
      if (knot.getWrappable() instanceof RigidMesh) {
        knot.myBmat.scaledAdd(cstiffness,knot.myDnrm);
      }
 else {
        knot.myBmat.addScaledOuterProduct(cd + cstiffness,knot.myNrml,knot.myNrml);
        if (dnrmGain != 0) {
          knot.myBmat.scaledAdd(dnrmGain * knot.myDist * cstiffness,knot.myDnrm);
        }
      }
    }
  }
}","/** 
 * Updates the stiffness matrix terms associated with each knot point. These give the force derivatives with respect to changes in knot position. The stiffness matrix structure is block-tridiagonal, where the diagonal blocks account for self-motion and changes wrappable repulsion forces, while the off-diagonal blocks account for the coupling between adjacent blocks.
 */
protected void updateStiffness(double dnrmGain,double dscale){
  double stiffness=myWrapStiffness;
  double cstiffness=myContactStiffness;
  double d=dscale * getWrapDamping() / (myNumKnots * myNumKnots);
  double cd=dscale * myContactDamping / (myNumKnots * myNumKnots);
  for (int k=0; k < myNumKnots; k++) {
    WrapKnot knot=myKnots[k];
    double s=2 * stiffness;
    knot.myBmat.setDiagonal(s,s,s);
    if (knot.myDist < 0) {
      if (knot.getWrappable() instanceof RigidMesh) {
        knot.myBmat.scaledAdd(cstiffness,knot.myDnrm);
      }
 else {
        knot.myBmat.addScaledOuterProduct(cd + cstiffness,knot.myNrml,knot.myNrml);
        if (dnrmGain != 0) {
          knot.myBmat.scaledAdd(dnrmGain * knot.myDist * cstiffness,knot.myDnrm);
        }
      }
    }
  }
}"
70677,"/** 
 * Updates the knot points in this wrappable segment. This is done by iterating until the first order physics resulting from the attractive forces between adjacent knots and repulsive forces from contacting wrappables results in a stable configuration.
 */
protected void updateWrapStrand(int maxIter){
  int icnt=0;
  boolean converged=false;
  double dscale=myDscale;
  updateContactingKnotPositions();
  int[] contactCnts=getContactCnts();
  int[] newContactCnts=new int[myWrappables.size()];
  updateForces();
  double prevEnergy=computeEnergy();
  double prevForceSqr=computeForceSqr();
  double prevForce=forceNorm();
  boolean wroteR=false;
  boolean wroteRx=false;
  do {
    double prevLength=myLength;
    if (inContact()) {
    }
    updateStiffness(0,dscale);
    boolean clipped=(factorAndSolve() < 1.0);
    double r0=forceDotDisp();
    double denom=forceNorm() * computeDvecLength();
    double cos=r0 / denom;
    double mincos=0.1;
    if (cos < mincos) {
      double lam=(denom * (mincos - cos) / computeForceSqr());
      modifyDvec(lam);
      r0=forceDotDisp();
      if (debugLevel > 0) {
        System.out.println(""String_Node_Str"" + cos + ""String_Node_Str""+ r0 / (forceNorm() * computeDvecLength()));
      }
    }
    double computedFSqr=computeForceSqrDeriv();
    savePosToPrev();
    LineSearchFunc func=new EnergyFunc();
    double f0, df0;
    if (func instanceof ForceSqrFunc) {
      f0=computeForceSqr();
      df0=computeForceSqrDeriv();
    }
 else {
      f0=computeEnergy();
      df0=-forceDotDisp();
    }
    double h=1e-8;
    prevEnergy=computeEnergy();
    advancePosByDvec(h);
    updateContacts(null,false);
    updateForces();
    double forceSqr=computeForceSqr();
    double energy=computeEnergy();
    double ederiv=(energy - prevEnergy) / h;
    double fsqrDeriv=(forceSqr - prevForceSqr) / h;
    double s=1.0;
    advancePosByDvec(s);
    contactDebug=(icnt == 0);
    boolean contactChanged=updateContacts(newContactCnts,true);
    contactDebug=false;
    boolean contactBroken=checkForBrokenContact(contactCnts,newContactCnts);
    updateForces();
    energy=computeEnergy();
    forceSqr=computeForceSqr();
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + prevEnergy + ""String_Node_Str""+ energy+ ""String_Node_Str""+ ederiv);
    }
    double r1=forceDotDisp();
    DoubleHolder deriv=new DoubleHolder();
    double f1=func.eval(deriv,s);
    double df1=deriv.value;
    if (contactBroken) {
      saveDvecToVtmp();
      updateStiffness(0,dscale);
      factorAndSolve();
      double scale=1.0;
      for (int k=0; k < myNumKnots; k++) {
        WrapKnot knot=myKnots[k];
        int widx=knot.myPrevWrappableIdx;
        if (widx != -1 && newContactCnts[widx] != 0) {
          if (knot.myDvec.dot(knot.myVtmp) < 0) {
            double dist=knot.myDist;
            double prev=knot.myPrevDist;
            if (dist != Wrappable.OUTSIDE && dist > 0 && prev < 0) {
              double r=dist / (dist - prev);
              if (r < scale) {
                scale=r;
              }
            }
          }
        }
      }
      if (scale < 1.0) {
        if (myContactRescaling) {
          if (debugLevel > 0) {
            System.out.println(""String_Node_Str"" + (1 - scale));
          }
          advancePosByVtmp(1 - scale);
          s=1 - scale;
          updateContacts(contactCnts,true);
          updateForces();
          f1=computeEnergy();
          df1=-forceDotDisp();
        }
      }
    }
    double ltol=myLength * myLengthConvTol;
    if (!contactChanged) {
      double maxLatDisp=maxLateralDisplacement();
      if (debugLevel > 0) {
      }
      if (maxLatDisp / myLength < 1e-4 && Math.abs(prevLength - myLength) < ltol) {
        converged=true;
      }
    }
    if (!converged && myLineSearchP) {
      ResidualFunc rfunc=new ResidualFunc();
      double maxs=(contactChanged ? s : 3.0);
      if (df0 >= 0) {
        System.out.println(""String_Node_Str"" + df0);
        printStuckDebugInfo(maxs);
      }
 else {
        double snew=lineSearch(f0,df0,f1,df1,func,0.1,2.0,s,maxs);
        if (snew != s) {
          if (debugLevel > 0) {
            System.out.printf(""String_Node_Str"",snew);
          }
          rfunc.eval(snew);
          updateContacts(null,true);
          energy=computeEnergy();
          forceSqr=computeForceSqr();
        }
 else {
          rfunc.eval(s);
          updateContacts(null,true);
        }
      }
      if (false) {
      }
    }
    double newEnergy=computeEnergy();
    if (debugLevel > 0) {
      System.out.printf(""String_Node_Str"",(newEnergy - prevEnergy));
    }
    prevEnergy=energy;
    prevForceSqr=forceSqr;
    prevForce=forceNorm();
  }
 while (++icnt < maxIter && !converged);
  saveContactingKnotPositions();
  totalIterations+=icnt;
  totalCalls++;
  if (converged) {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + icnt);
    }
  }
 else {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"");
    }
    totalFails++;
  }
  if ((totalCalls % 100) == 0) {
  }
  myDscale=dscale;
}","/** 
 * Updates the knot points in this wrappable segment. This is done by iterating until the first order physics resulting from the attractive forces between adjacent knots and repulsive forces from contacting wrappables results in a stable configuration.
 */
protected int updateWrapStrand(int maxIter){
  int icnt=0;
  boolean converged=false;
  double dscale=myDscale;
  updateContactingKnotPositions();
  int[] contactCnts=getContactCnts();
  int[] newContactCnts=new int[myWrappables.size()];
  updateForces();
  double prevEnergy=computeEnergy();
  double prevForceSqr=computeForceSqr();
  double prevForce=forceNorm();
  boolean wroteR=false;
  boolean wroteRx=false;
  do {
    double prevLength=myLength;
    if (inContact()) {
    }
    updateStiffness(0,dscale);
    boolean clipped=(factorAndSolve() < 1.0);
    double r0=forceDotDisp();
    double denom=forceNorm() * computeDvecLength();
    double cos=r0 / denom;
    double mincos=0.1;
    if (cos < mincos) {
      double lam=(denom * (mincos - cos) / computeForceSqr());
      modifyDvec(lam);
      r0=forceDotDisp();
      if (debugLevel > 0) {
        System.out.println(""String_Node_Str"" + cos + ""String_Node_Str""+ r0 / (forceNorm() * computeDvecLength()));
      }
    }
    double computedFSqr=computeForceSqrDeriv();
    savePosToPrev();
    LineSearchFunc func=new EnergyFunc();
    double f0, df0;
    if (func instanceof ForceSqrFunc) {
      f0=computeForceSqr();
      df0=computeForceSqrDeriv();
    }
 else {
      f0=computeEnergy();
      df0=-forceDotDisp();
    }
    double h=1e-8;
    prevEnergy=computeEnergy();
    advancePosByDvec(h);
    updateContacts(null,false);
    updateForces();
    double forceSqr=computeForceSqr();
    double energy=computeEnergy();
    double ederiv=(energy - prevEnergy) / h;
    double fsqrDeriv=(forceSqr - prevForceSqr) / h;
    double s=1.0;
    advancePosByDvec(s);
    contactDebug=(icnt == 0);
    boolean contactChanged=updateContacts(newContactCnts,true);
    contactDebug=false;
    boolean contactBroken=checkForBrokenContact(contactCnts,newContactCnts);
    updateForces();
    energy=computeEnergy();
    forceSqr=computeForceSqr();
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + prevEnergy + ""String_Node_Str""+ energy+ ""String_Node_Str""+ ederiv);
    }
    double r1=forceDotDisp();
    DoubleHolder deriv=new DoubleHolder();
    double f1=func.eval(deriv,s);
    double df1=deriv.value;
    if (contactBroken) {
      saveDvecToVtmp();
      updateStiffness(0,dscale);
      factorAndSolve();
      double scale=1.0;
      for (int k=0; k < myNumKnots; k++) {
        WrapKnot knot=myKnots[k];
        int widx=knot.myPrevWrappableIdx;
        if (widx != -1 && newContactCnts[widx] != 0) {
          if (knot.myDvec.dot(knot.myVtmp) < 0) {
            if (debugLevel > 0)             System.out.println(""String_Node_Str"");
            double dist=knot.myDist;
            double prev=knot.myPrevDist;
            if (dist != Wrappable.OUTSIDE && dist > 0 && prev < 0) {
              double r=dist / (dist - prev);
              if (r < scale) {
                scale=r;
              }
            }
          }
        }
      }
      if (scale < 1.0) {
        if (myContactRescaling) {
          if (debugLevel > 0) {
            System.out.println(""String_Node_Str"" + (1 - scale));
          }
          advancePosByVtmp(1 - scale);
          s=1 - scale;
          updateContacts(contactCnts,true);
          updateForces();
          f1=computeEnergy();
          df1=-forceDotDisp();
        }
      }
 else {
        restoreDvecFromVtmp();
      }
    }
    double ltol=myLength * myLengthConvTol;
    if (!contactChanged) {
      double maxLatDisp=maxLateralDisplacement();
      if (debugLevel > 0) {
      }
      if (maxLatDisp / myLength < 1e-4 && Math.abs(prevLength - myLength) < ltol) {
        converged=true;
      }
    }
    if (!converged && myLineSearchP) {
      ResidualFunc rfunc=new ResidualFunc();
      double maxs=(contactChanged ? s : 3.0);
      if (df0 >= 0) {
        System.out.println(""String_Node_Str"" + df0);
        printStuckDebugInfo(maxs);
      }
 else {
        double snew=lineSearch(f0,df0,f1,df1,func,0.1,2.0,s,maxs);
        if (snew != s) {
          if (debugLevel > 0) {
            System.out.printf(""String_Node_Str"",snew);
          }
          rfunc.eval(snew);
          updateContacts(null,true);
          energy=computeEnergy();
          forceSqr=computeForceSqr();
        }
 else {
          rfunc.eval(s);
          updateContacts(null,true);
        }
      }
      if (false) {
      }
    }
    double newEnergy=computeEnergy();
    if (debugLevel > 0) {
      System.out.printf(""String_Node_Str"",(newEnergy - prevEnergy));
    }
    prevEnergy=energy;
    prevForceSqr=forceSqr;
    prevForce=forceNorm();
  }
 while (++icnt < maxIter && !converged);
  saveContactingKnotPositions();
  totalIterations+=icnt;
  totalCalls++;
  if (converged) {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"" + icnt);
    }
  }
 else {
    if (debugLevel > 0) {
      System.out.println(""String_Node_Str"");
    }
    totalFails++;
  }
  if ((totalCalls % 100) == 0) {
  }
  myDscale=dscale;
  return icnt;
}"
70678,"@Override public void drawTriangles(RenderObject robj,int gidx,RenderInstances rinst){
  boolean selecting=isSelecting();
  boolean hasColors=((robj.hasColors() || rinst.hasColors()) && hasVertexColoring());
  boolean useColors=hasColors && !selecting && (myActiveColor == ActiveColor.DEFAULT);
  boolean useHSV=isHSVColorInterpolationEnabled();
  maybeUpdateState(gl);
  int savedShading=0;
  if (useColors) {
    savedShading=enableVertexColoring(useHSV);
  }
  boolean useDisplayList=(!selecting || !hasColors) && (!robj.isTransient());
  GL2VersionedObject gvo=null;
  boolean compile=true;
  if (useDisplayList) {
    RenderInstancesKey key=new RenderInstancesKey(rinst.getIdentifier(),robj.getIdentifier(),DrawType.TRIANGLES,gidx);
    RenderInstancesFingerprint fingerprint=new RenderInstancesFingerprint(rinst.getVersionInfo(),robj.getVersionInfo());
    gvo=myGLResources.getVersionedObject(key);
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    rinst.readLock();
    int ninstances=rinst.numInstances();
    int[] instances=rinst.getInstances();
    int ipos=rinst.getInstanceTypeOffset();
    int tpos=rinst.getInstanceTransformOffset();
    int cpos=rinst.getInstanceColorOffset();
    int spos=rinst.getInstanceScaleOffset();
    int stride=rinst.getInstanceStride();
    InstanceTransformType[] type=RenderInstances.getTransformTypes();
    boolean hasInstanceScales=rinst.hasScales();
    boolean hasInstanceColors=useColors && rinst.hasColors();
    gl.glPushMatrix();
    for (int i=0; i < ninstances; ++i) {
      int iidx=instances[ipos];
      int tidx=instances[tpos];
      int cidx=instances[cpos];
      int sidx=instances[spos];
switch (type[iidx]) {
case AFFINE:
{
          AffineTransform3d aff=rinst.getAffine(tidx);
          mulTransform(gl,aff);
          break;
        }
case FRAME:
{
        RigidTransform3d frame=rinst.getFrame(tidx);
        mulTransform(gl,frame);
        break;
      }
case POINT:
{
      float[] trans=rinst.getPoint(tidx);
      gl.glTranslatef(trans[0],trans[1],trans[2]);
      break;
    }
}
if (hasInstanceScales && (sidx >= 0)) {
  Double s=rinst.getScale(sidx);
  gl.glScaled(s,s,s);
}
if (hasInstanceColors && (cidx >= 0)) {
  byte[] c=rinst.getColor(cidx);
  gl.glColor4ub(c[0],c[1],c[2],c[3]);
}
drawRawTriangles(gl,robj,gidx,0,robj.numTriangles(gidx),robj.hasNormals(),!hasInstanceColors && useColors,!selecting & robj.hasTextureCoords(),useHSV);
ipos+=stride;
tpos+=stride;
cpos+=stride;
spos+=stride;
}
gl.glPopMatrix();
robj.readUnlock();
rinst.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
disableVertexColoring(useHSV,savedShading);
}
}","@Override public void drawTriangles(RenderObject robj,int gidx,RenderInstances rinst){
  boolean selecting=isSelecting();
  boolean hasColors=((robj.hasColors() || rinst.hasColors()) && hasVertexColoring());
  boolean useColors=hasColors && !selecting && (myActiveColor == ActiveColor.DEFAULT);
  boolean useHSV=isHSVColorInterpolationEnabled();
  maybeUpdateState(gl);
  int savedShading=0;
  if (useColors) {
    savedShading=enableVertexColoring(useHSV);
  }
  boolean useDisplayList=(!selecting || !hasColors) && (!robj.isTransient());
  GL2VersionedObject gvo=null;
  boolean compile=true;
  if (useDisplayList) {
    RenderInstancesKey key=new RenderInstancesKey(rinst.getIdentifier(),robj.getIdentifier(),DrawType.TRIANGLES,gidx);
    RenderInstancesFingerprint fingerprint=new RenderInstancesFingerprint(rinst.getVersionInfo(),robj.getVersionInfo());
    gvo=myGLResources.getVersionedObject(key);
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    rinst.readLock();
    int ninstances=rinst.numInstances();
    int[] instances=rinst.getInstances();
    int ipos=rinst.getInstanceTypeOffset();
    int tpos=rinst.getInstanceTransformOffset();
    int cpos=rinst.getInstanceColorOffset();
    int spos=rinst.getInstanceScaleOffset();
    int stride=rinst.getInstanceStride();
    InstanceTransformType[] type=RenderInstances.getTransformTypes();
    boolean hasInstanceScales=rinst.hasScales();
    boolean hasInstanceColors=useColors && rinst.hasColors();
    for (int i=0; i < ninstances; ++i) {
      int iidx=instances[ipos];
      int tidx=instances[tpos];
      int cidx=instances[cpos];
      int sidx=instances[spos];
      gl.glPushMatrix();
switch (type[iidx]) {
case AFFINE:
{
          AffineTransform3d aff=rinst.getAffine(tidx);
          mulTransform(gl,aff);
          break;
        }
case FRAME:
{
        RigidTransform3d frame=rinst.getFrame(tidx);
        mulTransform(gl,frame);
        break;
      }
case POINT:
{
      float[] trans=rinst.getPoint(tidx);
      gl.glTranslatef(trans[0],trans[1],trans[2]);
      break;
    }
}
if (hasInstanceScales && (sidx >= 0)) {
  Double s=rinst.getScale(sidx);
  gl.glScaled(s,s,s);
}
if (hasInstanceColors && (cidx >= 0)) {
  byte[] c=rinst.getColor(cidx);
  gl.glColor4ub(c[0],c[1],c[2],c[3]);
}
drawRawTriangles(gl,robj,gidx,0,robj.numTriangles(gidx),robj.hasNormals(),!hasInstanceColors && useColors,!selecting & robj.hasTextureCoords(),useHSV);
gl.glPopMatrix();
ipos+=stride;
tpos+=stride;
cpos+=stride;
spos+=stride;
}
robj.readUnlock();
rinst.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
disableVertexColoring(useHSV,savedShading);
}
}"
70679,"@Override public void drawPoints(RenderObject robj,int gidx,RenderInstances rinst){
  boolean selecting=isSelecting();
  boolean hasColors=((robj.hasColors() || rinst.hasColors()) && hasVertexColoring());
  boolean useColors=hasColors && !selecting && (myActiveColor == ActiveColor.DEFAULT);
  boolean useHSV=isHSVColorInterpolationEnabled();
  maybeUpdateState(gl);
  int savedShading=0;
  if (useColors) {
    savedShading=enableVertexColoring(useHSV);
  }
  boolean useDisplayList=(!selecting || !hasColors) && (!robj.isTransient());
  GL2VersionedObject gvo=null;
  boolean compile=true;
  if (useDisplayList) {
    RenderInstancesKey key=new RenderInstancesKey(rinst.getIdentifier(),robj.getIdentifier(),DrawType.POINTS,gidx);
    RenderInstancesFingerprint fingerprint=new RenderInstancesFingerprint(rinst.getVersionInfo(),robj.getVersionInfo());
    gvo=myGLResources.getVersionedObject(key);
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    rinst.readLock();
    int ninstances=rinst.numInstances();
    int[] instances=rinst.getInstances();
    int ipos=rinst.getInstanceTypeOffset();
    int tpos=rinst.getInstanceTransformOffset();
    int cpos=rinst.getInstanceColorOffset();
    int spos=rinst.getInstanceScaleOffset();
    int stride=rinst.getInstanceStride();
    InstanceTransformType[] type=RenderInstances.getTransformTypes();
    boolean hasInstanceScales=rinst.hasScales();
    boolean hasInstanceColors=useColors && rinst.hasColors();
    gl.glPushMatrix();
    for (int i=0; i < ninstances; ++i) {
      int iidx=instances[ipos];
      int tidx=instances[tpos];
      int cidx=instances[cpos];
      int sidx=instances[spos];
switch (type[iidx]) {
case AFFINE:
{
          AffineTransform3d aff=rinst.getAffine(tidx);
          mulTransform(gl,aff);
          break;
        }
case FRAME:
{
        RigidTransform3d frame=rinst.getFrame(tidx);
        mulTransform(gl,frame);
        break;
      }
case POINT:
{
      float[] trans=rinst.getPoint(tidx);
      gl.glTranslatef(trans[0],trans[1],trans[2]);
      break;
    }
}
if (hasInstanceScales && (sidx >= 0)) {
  Double s=rinst.getScale(sidx);
  gl.glScaled(s,s,s);
}
if (hasInstanceColors && (cidx >= 0)) {
  byte[] c=rinst.getColor(cidx);
  gl.glColor4ub(c[0],c[1],c[2],c[3]);
}
drawRawPoints(gl,robj,gidx,0,robj.numPoints(gidx),robj.hasNormals(),!hasInstanceColors && useColors,!selecting & robj.hasTextureCoords(),useHSV);
ipos+=stride;
tpos+=stride;
cpos+=stride;
spos+=stride;
}
gl.glPopMatrix();
robj.readUnlock();
rinst.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
disableVertexColoring(useHSV,savedShading);
}
}","@Override public void drawPoints(RenderObject robj,int gidx,RenderInstances rinst){
  boolean selecting=isSelecting();
  boolean hasColors=((robj.hasColors() || rinst.hasColors()) && hasVertexColoring());
  boolean useColors=hasColors && !selecting && (myActiveColor == ActiveColor.DEFAULT);
  boolean useHSV=isHSVColorInterpolationEnabled();
  maybeUpdateState(gl);
  int savedShading=0;
  if (useColors) {
    savedShading=enableVertexColoring(useHSV);
  }
  boolean useDisplayList=(!selecting || !hasColors) && (!robj.isTransient());
  GL2VersionedObject gvo=null;
  boolean compile=true;
  if (useDisplayList) {
    RenderInstancesKey key=new RenderInstancesKey(rinst.getIdentifier(),robj.getIdentifier(),DrawType.POINTS,gidx);
    RenderInstancesFingerprint fingerprint=new RenderInstancesFingerprint(rinst.getVersionInfo(),robj.getVersionInfo());
    gvo=myGLResources.getVersionedObject(key);
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    rinst.readLock();
    int ninstances=rinst.numInstances();
    int[] instances=rinst.getInstances();
    int ipos=rinst.getInstanceTypeOffset();
    int tpos=rinst.getInstanceTransformOffset();
    int cpos=rinst.getInstanceColorOffset();
    int spos=rinst.getInstanceScaleOffset();
    int stride=rinst.getInstanceStride();
    InstanceTransformType[] type=RenderInstances.getTransformTypes();
    boolean hasInstanceScales=rinst.hasScales();
    boolean hasInstanceColors=useColors && rinst.hasColors();
    for (int i=0; i < ninstances; ++i) {
      int iidx=instances[ipos];
      int tidx=instances[tpos];
      int cidx=instances[cpos];
      int sidx=instances[spos];
      gl.glPushMatrix();
switch (type[iidx]) {
case AFFINE:
{
          AffineTransform3d aff=rinst.getAffine(tidx);
          mulTransform(gl,aff);
          break;
        }
case FRAME:
{
        RigidTransform3d frame=rinst.getFrame(tidx);
        mulTransform(gl,frame);
        break;
      }
case POINT:
{
      float[] trans=rinst.getPoint(tidx);
      gl.glTranslatef(trans[0],trans[1],trans[2]);
      break;
    }
}
if (hasInstanceScales && (sidx >= 0)) {
  Double s=rinst.getScale(sidx);
  gl.glScaled(s,s,s);
}
if (hasInstanceColors && (cidx >= 0)) {
  byte[] c=rinst.getColor(cidx);
  gl.glColor4ub(c[0],c[1],c[2],c[3]);
}
drawRawPoints(gl,robj,gidx,0,robj.numPoints(gidx),robj.hasNormals(),!hasInstanceColors && useColors,!selecting & robj.hasTextureCoords(),useHSV);
gl.glPopMatrix();
ipos+=stride;
tpos+=stride;
cpos+=stride;
spos+=stride;
}
robj.readUnlock();
rinst.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
disableVertexColoring(useHSV,savedShading);
}
}"
70680,"@Override public void drawLines(RenderObject robj,int gidx,RenderInstances rinst){
  boolean selecting=isSelecting();
  boolean hasColors=((robj.hasColors() || rinst.hasColors()) && hasVertexColoring());
  boolean useColors=hasColors && !selecting && (myActiveColor == ActiveColor.DEFAULT);
  boolean useHSV=isHSVColorInterpolationEnabled();
  maybeUpdateState(gl);
  int savedShading=0;
  if (useColors) {
    savedShading=enableVertexColoring(useHSV);
  }
  boolean useDisplayList=(!selecting || !hasColors) && (!robj.isTransient());
  GL2VersionedObject gvo=null;
  boolean compile=true;
  if (useDisplayList) {
    RenderInstancesKey key=new RenderInstancesKey(rinst.getIdentifier(),robj.getIdentifier(),DrawType.LINES,gidx);
    RenderInstancesFingerprint fingerprint=new RenderInstancesFingerprint(rinst.getVersionInfo(),robj.getVersionInfo());
    gvo=myGLResources.getVersionedObject(key);
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    rinst.readLock();
    int ninstances=rinst.numInstances();
    int[] instances=rinst.getInstances();
    int ipos=rinst.getInstanceTypeOffset();
    int tpos=rinst.getInstanceTransformOffset();
    int cpos=rinst.getInstanceColorOffset();
    int spos=rinst.getInstanceScaleOffset();
    int stride=rinst.getInstanceStride();
    InstanceTransformType[] type=RenderInstances.getTransformTypes();
    boolean hasInstanceScales=rinst.hasScales();
    boolean hasInstanceColors=useColors && rinst.hasColors();
    gl.glPushMatrix();
    for (int i=0; i < ninstances; ++i) {
      int iidx=instances[ipos];
      int tidx=instances[tpos];
      int cidx=instances[cpos];
      int sidx=instances[spos];
switch (type[iidx]) {
case AFFINE:
{
          AffineTransform3d aff=rinst.getAffine(tidx);
          mulTransform(gl,aff);
          break;
        }
case FRAME:
{
        RigidTransform3d frame=rinst.getFrame(tidx);
        mulTransform(gl,frame);
        break;
      }
case POINT:
{
      float[] trans=rinst.getPoint(tidx);
      gl.glTranslatef(trans[0],trans[1],trans[2]);
      break;
    }
}
if (hasInstanceScales && (sidx >= 0)) {
  Double s=rinst.getScale(sidx);
  gl.glScaled(s,s,s);
}
if (hasInstanceColors && (cidx >= 0)) {
  byte[] c=rinst.getColor(cidx);
  gl.glColor4ub(c[0],c[1],c[2],c[3]);
}
drawRawLines(gl,robj,gidx,0,robj.numLines(gidx),robj.hasNormals(),!hasInstanceColors && useColors,!selecting & robj.hasTextureCoords(),useHSV);
ipos+=stride;
tpos+=stride;
cpos+=stride;
spos+=stride;
}
gl.glPopMatrix();
robj.readUnlock();
rinst.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
disableVertexColoring(useHSV,savedShading);
}
}","@Override public void drawLines(RenderObject robj,int gidx,RenderInstances rinst){
  boolean selecting=isSelecting();
  boolean hasColors=((robj.hasColors() || rinst.hasColors()) && hasVertexColoring());
  boolean useColors=hasColors && !selecting && (myActiveColor == ActiveColor.DEFAULT);
  boolean useHSV=isHSVColorInterpolationEnabled();
  maybeUpdateState(gl);
  int savedShading=0;
  if (useColors) {
    savedShading=enableVertexColoring(useHSV);
  }
  boolean useDisplayList=(!selecting || !hasColors) && (!robj.isTransient());
  GL2VersionedObject gvo=null;
  boolean compile=true;
  if (useDisplayList) {
    RenderInstancesKey key=new RenderInstancesKey(rinst.getIdentifier(),robj.getIdentifier(),DrawType.LINES,gidx);
    RenderInstancesFingerprint fingerprint=new RenderInstancesFingerprint(rinst.getVersionInfo(),robj.getVersionInfo());
    gvo=myGLResources.getVersionedObject(key);
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    rinst.readLock();
    int ninstances=rinst.numInstances();
    int[] instances=rinst.getInstances();
    int ipos=rinst.getInstanceTypeOffset();
    int tpos=rinst.getInstanceTransformOffset();
    int cpos=rinst.getInstanceColorOffset();
    int spos=rinst.getInstanceScaleOffset();
    int stride=rinst.getInstanceStride();
    InstanceTransformType[] type=RenderInstances.getTransformTypes();
    boolean hasInstanceScales=rinst.hasScales();
    boolean hasInstanceColors=useColors && rinst.hasColors();
    for (int i=0; i < ninstances; ++i) {
      int iidx=instances[ipos];
      int tidx=instances[tpos];
      int cidx=instances[cpos];
      int sidx=instances[spos];
      gl.glPushMatrix();
switch (type[iidx]) {
case AFFINE:
{
          AffineTransform3d aff=rinst.getAffine(tidx);
          mulTransform(gl,aff);
          break;
        }
case FRAME:
{
        RigidTransform3d frame=rinst.getFrame(tidx);
        mulTransform(gl,frame);
        break;
      }
case POINT:
{
      float[] trans=rinst.getPoint(tidx);
      gl.glTranslatef(trans[0],trans[1],trans[2]);
      break;
    }
}
if (hasInstanceScales && (sidx >= 0)) {
  Double s=rinst.getScale(sidx);
  gl.glScaled(s,s,s);
}
if (hasInstanceColors && (cidx >= 0)) {
  byte[] c=rinst.getColor(cidx);
  gl.glColor4ub(c[0],c[1],c[2],c[3]);
}
drawRawLines(gl,robj,gidx,0,robj.numLines(gidx),robj.hasNormals(),!hasInstanceColors && useColors,!selecting & robj.hasTextureCoords(),useHSV);
gl.glPopMatrix();
ipos+=stride;
tpos+=stride;
cpos+=stride;
spos+=stride;
}
robj.readUnlock();
rinst.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
disableVertexColoring(useHSV,savedShading);
}
}"
70681,"/** 
 * Apply a function to each instance, separating points, frames, and affines.  Each instance type is assigned an index corresponding to its position within its own group in order of appearance  (i.e. point index 0 is the first point, 1 the second point, ...,  frame index 0 is the first frame, ...). order.
 * @param consumer
 */
public void forEachInstance(RenderInstanceConsumer consumer){
  int idx=0;
  int[] buff=instances.getArray();
  InstanceTransformType[] types=InstanceTransformType.values();
  int pidx=0;
  int fidx=0;
  int aidx=0;
  for (int i=0; i < stateInfo.numInstances; ++i) {
    int type=buff[idx++];
    int tidx=buff[idx++];
    int sidx=buff[idx++];
    int cidx=buff[idx++];
    InstanceTransformType tt=types[type];
switch (tt) {
case POINT:
      consumer.point(pidx,getPoint(tidx),getScale(sidx),getColor(cidx));
    ++pidx;
  break;
case FRAME:
consumer.frame(fidx,getFrame(tidx),getScale(sidx),getColor(cidx));
++fidx;
break;
case AFFINE:
consumer.affine(aidx,getAffine(tidx),getScale(sidx),getColor(cidx));
++aidx;
break;
}
}
}","/** 
 * Apply a function to each instance, separating points, frames, and affines.  Each instance type is assigned an index corresponding to its position within its own group in order of appearance  (i.e. point index 0 is the first point, 1 the second point, ...,  frame index 0 is the first frame, ...). order.
 * @param consumer
 */
public void forEachInstance(RenderInstanceConsumer consumer){
  int idx=0;
  int[] buff=getInstances();
  InstanceTransformType[] types=InstanceTransformType.values();
  int pidx=0;
  int fidx=0;
  int aidx=0;
  for (int i=0; i < stateInfo.numInstances; ++i) {
    int type=buff[idx++];
    int tidx=buff[idx++];
    int sidx=buff[idx++];
    int cidx=buff[idx++];
    InstanceTransformType tt=types[type];
switch (tt) {
case POINT:
      consumer.point(pidx,getPoint(tidx),getScale(sidx),getColor(cidx));
    ++pidx;
  break;
case FRAME:
consumer.frame(fidx,getFrame(tidx),getScale(sidx),getColor(cidx));
++fidx;
break;
case AFFINE:
consumer.affine(aidx,getAffine(tidx),getScale(sidx),getColor(cidx));
++aidx;
break;
}
}
}"
70682,"/** 
 * Number of instances defined
 */
public int numInstances(){
  return stateInfo.numScales;
}","/** 
 * Number of instances defined
 */
public int numInstances(){
  return stateInfo.numInstances;
}"
70683,"public int[] getInstances(){
  return instances.getArray();
}","public int[] getInstances(){
  if (instances == null) {
    instances=new DynamicIntArray();
  }
  return instances.getArray();
}"
70684,"/** 
 * Gets the mass for this spatial inertia.
 * @return mass
 */
public double getMass(){
  return mass;
}","/** 
 * Gets the mass for this spatial inertia.
 * @return mass
 */
public double getMass(){
  if (componentUpdateNeeded) {
    updateComponents();
  }
  return mass;
}"
70685,"public void setFaceColoring(RenderProps props,float[] rgba,boolean highlight){
  if (rgba != null) {
    setFrontColor(rgba);
    if (rgba.length == 3) {
      setFrontAlpha((float)props.getAlpha());
    }
  }
 else {
    setFrontColor(props.getFaceColorF());
  }
  setBackColor(props.getBackColorF());
  setShininess(props.getShininess());
  setEmission(DEFAULT_MATERIAL_EMISSION);
  float[] specular=props.getSpecularF();
  setSpecular(specular != null ? specular : DEFAULT_MATERIAL_SPECULAR);
  setHighlighting(highlight);
}","public void setFaceColoring(RenderProps props,float[] rgba,boolean highlight){
  setFrontColor(rgba);
  if (rgba.length == 3) {
    setFrontAlpha((float)props.getAlpha());
  }
  setBackColor(props.getBackColorF());
  setShininess(props.getShininess());
  setEmission(DEFAULT_MATERIAL_EMISSION);
  float[] specular=props.getSpecularF();
  setSpecular(specular != null ? specular : DEFAULT_MATERIAL_SPECULAR);
  setHighlighting(highlight);
}"
70686,"private void useProgram(GL3 gl,GLShaderProgram prog){
  if (prog != myCommittedProgram) {
    prog.use(gl);
    if (isSelecting()) {
      myProgManager.setSelectionColor(gl,prog,mySelectingColor);
      mySelectingColorModified=false;
    }
    myCommittedProgram=prog;
    if (shaderOverride != null) {
      myCommittedProgramInfo=myProgramInfo.clone();
    }
 else {
      myCommittedProgramInfo=null;
    }
  }
  maybeBindTextures(gl,prog);
}","private void useProgram(GL3 gl,GLShaderProgram prog){
  if (prog != myCommittedProgram) {
    prog.use(gl);
    if (isSelecting()) {
      myProgManager.setSelectionColor(gl,prog,mySelectingColor);
      mySelectingColorModified=false;
    }
    myCommittedProgram=prog;
    if (shaderOverride == null) {
      myCommittedProgramInfo=myProgramInfo.clone();
    }
 else {
      myCommittedProgramInfo=null;
    }
  }
  maybeBindTextures(gl,prog);
}"
70687,"private void offscreenCapture(GLFrameCapture fc,int flags){
  boolean savedSelecting=selectEnabled;
  selectEnabled=false;
  gl.setSwapInterval(1);
  fc.activateFBO(gl);
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  fc.capture(gl);
  fc.deactivateFBO(gl);
  selectEnabled=savedSelecting;
}","private void offscreenCapture(GLFrameCapture fc,int flags){
  boolean savedSelecting=selectEnabled;
  selectEnabled=false;
  fc.activateFBO(gl);
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  fc.capture(gl);
  fc.deactivateFBO(gl);
  selectEnabled=savedSelecting;
}"
70688,"public void setContent(TextureContent content){
  setFileName(defaultFileName);
  myContent=content;
}","public void setContent(TextureContent content){
  setFileName(defaultFileName);
  myContent=content.acquire();
}"
70689,"@Override public long releaseAndCount(){
  long ac=acquireCount.decrementAndGet();
  if (ac == -1) {
    System.err.println(""String_Node_Str"");
  }
  return ac;
}","@Override public long releaseAndCount(){
  long ac=acquireCount.decrementAndGet();
  if (ac == -1) {
    System.err.println(""String_Node_Str"" + this.getClass() + ""String_Node_Str"");
  }
  return ac;
}"
70690,"public void set(ColorMapProps props){
  super.set(props);
  myColorMixing=props.myColorMixing;
  myColorMixingMode=props.myColorMixingMode;
  myDiffuseColoring=props.myDiffuseColoring;
  myDiffuseColoringMode=props.myDiffuseColoringMode;
  mySpecularColoring=props.mySpecularColoring;
  mySpecularColoringMode=props.mySpecularColoringMode;
}","public void set(ColorMapProps props){
  super.set(props);
  myColorMixing=props.myColorMixing;
  myColorMixingMode=props.myColorMixingMode;
  myDiffuseColoring=props.myDiffuseColoring;
  myDiffuseColoringMode=props.myDiffuseColoringMode;
  mySpecularColoring=props.mySpecularColoring;
  mySpecularColoringMode=props.mySpecularColoringMode;
  myEmissionColoring=props.myEmissionColoring;
  myEmissionColoringMode=props.myEmissionColoringMode;
}"
70691,"public ColorMapProps clone(){
  ColorMapProps props=(ColorMapProps)super.clone();
  myColorMixing=props.myColorMixing;
  myColorMixingMode=props.myColorMixingMode;
  myDiffuseColoring=props.myDiffuseColoring;
  myDiffuseColoringMode=props.myDiffuseColoringMode;
  mySpecularColoring=props.mySpecularColoring;
  mySpecularColoringMode=props.mySpecularColoringMode;
  return props;
}","public ColorMapProps clone(){
  ColorMapProps props=(ColorMapProps)super.clone();
  myColorMixing=props.myColorMixing;
  myColorMixingMode=props.myColorMixingMode;
  myDiffuseColoring=props.myDiffuseColoring;
  myDiffuseColoringMode=props.myDiffuseColoringMode;
  mySpecularColoring=props.mySpecularColoring;
  mySpecularColoringMode=props.mySpecularColoringMode;
  myEmissionColoring=props.myEmissionColoring;
  myEmissionColoringMode=props.myEmissionColoringMode;
  return props;
}"
70692,"public String toString(){
  return (super.toString() + ""String_Node_Str"" + myColorMixing+ ""String_Node_Str""+ myDiffuseColoring+ ""String_Node_Str""+ mySpecularColoring);
}","public String toString(){
  return (super.toString() + ""String_Node_Str"" + myColorMixing+ ""String_Node_Str""+ myDiffuseColoring+ ""String_Node_Str""+ mySpecularColoring+ ""String_Node_Str""+ myEmissionColoring);
}"
70693,"@Override public boolean isValid(){
  return ibo.isValid();
}","@Override public boolean isValid(){
  if (ibo == null) {
    return false;
  }
  return ibo.isValid();
}"
70694,"public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  maybeUpdateState(gl);
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
    myGLColorCount=0;
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
    Logger.getSystemLogger().debug(""String_Node_Str"" + myGLColorCount);
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  gl.glFlush();
  GLFrameCapture fc=frameCapture;
  if (fc != null) {
synchronized (fc) {
      if (grab) {
        offscreenCapture(fc,flags);
        grab=false;
      }
      if (grabWaitComplete) {
        fc.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        fc.waitForCompletion();
        fc.dispose(gl);
        frameCapture=null;
      }
    }
  }
  garbage(gl);
  this.drawable=null;
  this.gl=null;
}","public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  maybeUpdateState(gl);
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
    myGLColorCount=0;
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
    Logger.getSystemLogger().debug(""String_Node_Str"" + myGLColorCount);
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  gl.glFlush();
  GLFrameCapture fc=frameCapture;
  if (fc != null && (grab || grabClose)) {
synchronized (fc) {
      if (grab) {
        offscreenCapture(fc,flags);
        fc.unlock();
        grab=false;
      }
      if (grabClose) {
        fc.waitForCompletion();
        fc.dispose(gl);
        frameCapture=null;
        grabClose=false;
      }
    }
  }
  garbage(gl);
  this.drawable=null;
  this.gl=null;
}"
70695,"public void awaitScreenShotCompletion(){
  if (frameCapture != null) {
    grabWaitComplete=true;
    repaint();
  }
}","public void awaitScreenShotCompletion(){
  if (frameCapture != null) {
    frameCapture.waitForCompletion();
  }
}"
70696,"@Override public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL3();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  GLFrameCapture fc=frameCapture;
  if (fc != null) {
synchronized (fc) {
      if (grab) {
        offscreenCapture(fc,flags);
        grab=false;
      }
      if (grabWaitComplete) {
        fc.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        fc.waitForCompletion();
        fc.dispose(gl);
        frameCapture=null;
      }
    }
  }
  long time=System.currentTimeMillis();
  if (time - lastGarbageTime > myGLResources.getGarbageCollectionInterval()) {
    garbage(gl);
  }
  myGLResources.maybeRunGarbageCollection(gl);
  this.drawable=null;
  this.gl=null;
}","@Override public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL3();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  GLFrameCapture fc=frameCapture;
  if (fc != null && (grab || grabClose)) {
synchronized (fc) {
      if (grab) {
        offscreenCapture(fc,flags);
        fc.unlock();
        grab=false;
      }
      if (grabClose) {
        fc.waitForCompletion();
        fc.dispose(gl);
        frameCapture=null;
        grabClose=false;
      }
    }
  }
  long time=System.currentTimeMillis();
  if (time - lastGarbageTime > myGLResources.getGarbageCollectionInterval()) {
    garbage(gl);
  }
  myGLResources.maybeRunGarbageCollection(gl);
  this.drawable=null;
  this.gl=null;
}"
70697,"private void offscreenCapture(GLFrameCapture fc,int flags){
  boolean savedSelecting=selectEnabled;
  selectEnabled=false;
  gl.setSwapInterval(1);
  fc.activateFBO(gl);
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  fc.deactivateFBO(gl);
  fc.capture(gl);
  selectEnabled=savedSelecting;
}","private void offscreenCapture(GLFrameCapture fc,int flags){
  boolean savedSelecting=selectEnabled;
  selectEnabled=false;
  fc.activateFBO(gl);
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  fc.deactivateFBO(gl);
  fc.capture(gl);
  selectEnabled=savedSelecting;
}"
70698,"public void awaitScreenShotCompletion(){
  if (frameCapture != null) {
    grabWaitComplete=true;
    repaint();
  }
}","public void awaitScreenShotCompletion(){
  if (frameCapture != null) {
    frameCapture.waitForCompletion();
  }
}"
70699,"public GLFrameCapture(int x,int y,int w,int h,int nsamples,boolean gammaCorrected,File file,String format){
  this.file=file;
  this.format=format;
  fbo=new FrameBufferObject(x,y,w,h,nsamples,gammaCorrected);
}","public GLFrameCapture(int x,int y,int w,int h,int nsamples,boolean gammaCorrected,File file,String format){
  this.file=file;
  this.format=format;
  fbo=new FrameBufferObject(x,y,w,h,nsamples,gammaCorrected);
  lock=false;
}"
70700,"@Override public void run(){
  if (menuFile != null) {
    ArtisynthModelMenu generator=readDemoMenu(menuFile.getAbsolutePath());
    populateModelMenu(menu);
    File cachedMenu=getMenuCacheFile(menuFile);
    generator.write(cachedMenu);
    myModelsMenuGenerator=generator;
  }
}","@Override public void run(){
  if (menuFilename != null) {
    ArtisynthModelMenu generator=readDemoMenu(menuFilename);
    populateModelMenu(menu);
    File cachedMenu=getMenuCacheFile(menuFilename);
    generator.write(cachedMenu);
    myModelsMenuGenerator=generator;
  }
}"
70701,"public BackgroundModelMenuThread(File file,JMenu menu){
  super(""String_Node_Str"");
  menuFile=file;
  this.menu=menu;
}","public BackgroundModelMenuThread(String filename,JMenu menu){
  super(""String_Node_Str"");
  menuFilename=filename;
  this.menu=menu;
}"
70702,"private File getMenuCacheFile(File file){
  String cacheFileName=ArtisynthPath.getHomeDir() + ""String_Node_Str"" + file.getName();
  File cachedMenu=new File(cacheFileName);
  return cachedMenu;
}","private File getMenuCacheFile(String menuFilename){
  String cacheFileName=ArtisynthPath.getHomeDir() + ""String_Node_Str"" + menuFilename;
  File cachedMenu=new File(cacheFileName);
  return cachedMenu;
}"
70703,"private void createDemosMenu(JMenu menu){
  myModelsMenuGenerator=null;
  String menuFilename=myMain.getDemosMenuFilename();
  File menuFile=new File(menuFilename);
  File cachedMenu=getMenuCacheFile(menuFile);
  if (cachedMenu.exists()) {
    myModelsMenuGenerator=readDemoMenu(cachedMenu.getAbsolutePath());
    populateModelMenu(menu);
    BackgroundModelMenuThread thread=new BackgroundModelMenuThread(menuFile,menu);
    thread.start();
  }
 else {
    myModelsMenuGenerator=readDemoMenu(menuFile.getAbsolutePath());
    populateModelMenu(menu);
    myModelsMenuGenerator.write(cachedMenu);
  }
}","private void createDemosMenu(JMenu menu){
  myModelsMenuGenerator=null;
  String menuFilename=myMain.getDemosMenuFilename();
  File menuFile=new File(menuFilename);
  File cachedMenu=getMenuCacheFile(menuFilename);
  if (cachedMenu.exists()) {
    myModelsMenuGenerator=readDemoMenu(menuFilename);
    populateModelMenu(menu);
    BackgroundModelMenuThread thread=new BackgroundModelMenuThread(menuFilename,menu);
    thread.start();
  }
 else {
    myModelsMenuGenerator=readDemoMenu(menuFilename);
    populateModelMenu(menu);
    myModelsMenuGenerator.write(cachedMenu);
  }
}"
70704,"/** 
 * Adds a weighted node-to-node stiffness to the matrix Kij via the formula <pre> Kij = Bi^T D Bj dv </pre> where gi and gj are the gradients for shape functions i and j, Bi and Bj are the B matrices formed from gi and gj, D is the linear stiffness relationship associated with Youngs modulus E and Poissons ratio nu, and dv is the weighting term.
 */
public static void addMaterialStiffness(Matrix3d K,Vector3d gi,double E,double nu,Vector3d gj,double dv){
  double s=E / (1 + nu);
  double dia=s * (1 - nu) / (1 - 2 * nu);
  double off=s * nu / (1 - 2 * nu);
  double di2=0.5 * s;
  double gjx=gj.x * dv;
  double gjy=gj.y * dv;
  double gjz=gj.z * dv;
  double dm00=dia * gjx;
  double dm01=off * gjy;
  double dm02=off * gjz;
  double dm10=off * gjx;
  double dm11=dia * gjy;
  double dm22=dia * gjz;
  double dm30=di2 * gjy;
  double dm31=di2 * gjx;
  double dm41=di2 * gjz;
  double gix=gi.x;
  double giy=gi.y;
  double giz=gi.z;
  double giy_dm30=giy * dm30;
  double gix_dm31=gix * dm31;
  double giz_dm22=giz * dm22;
  K.m00+=gix * dm00 + giy_dm30 + giz_dm22;
  K.m01+=gix * dm01 + giy * dm31;
  K.m02+=gix * dm02 + giz * dm31;
  K.m10+=giy * dm10 + gix * dm30;
  K.m11+=giy * dm11 + gix_dm31 + giz * dm41;
  K.m12+=giy * dm02 + giz * dm30;
  K.m20+=giz * dm10 + gix * dm22;
  K.m21+=giz * dm01 + giy * dm41;
  K.m22+=giz_dm22 + giy_dm30 + gix_dm31;
}","/** 
 * Adds a weighted node-to-node stiffness to the matrix Kij via the formula <pre> Kij = Bi^T D Bj dv </pre> where gi and gj are the gradients for shape functions i and j, Bi and Bj are the B matrices formed from gi and gj, D is the linear stiffness relationship associated with Youngs modulus E and Poissons ratio nu, and dv is the weighting term.
 */
public static void addMaterialStiffness(Matrix3d K,Vector3d gi,double E,double nu,Vector3d gj,double dv){
  double s=E / (1 + nu);
  double dia=s * (1 - nu) / (1 - 2 * nu);
  double off=s * nu / (1 - 2 * nu);
  double di2=0.5 * s;
  double gjx=gj.x * dv;
  double gjy=gj.y * dv;
  double gjz=gj.z * dv;
  double dgjx=dia * gjx;
  double dgjy=dia * gjy;
  double dgjz=dia * gjz;
  double ogjx=off * gjx;
  double ogjy=off * gjy;
  double ogjz=off * gjz;
  double d2gjx=di2 * gjx;
  double d2gjy=di2 * gjy;
  double d2gjz=di2 * gjz;
  double gix=gi.x;
  double giy=gi.y;
  double giz=gi.z;
  double gixd2gjx=gix * d2gjx;
  double giyd2gjy=giy * d2gjy;
  double gizd2gjz=giz * d2gjz;
  K.m00+=gix * dgjx + giyd2gjy + gizd2gjz;
  K.m01+=gix * ogjy + giy * d2gjx;
  K.m02+=gix * ogjz + giz * d2gjx;
  K.m10+=giy * ogjx + gix * d2gjy;
  K.m11+=giy * dgjy + gixd2gjx + gizd2gjz;
  K.m12+=giy * ogjz + giz * d2gjy;
  K.m20+=giz * ogjx + gix * d2gjz;
  K.m21+=giz * ogjy + giy * d2gjz;
  K.m22+=giz * dgjz + giyd2gjy + gixd2gjx;
}"
70705,"public void updateTargetForce(double t0,double t1){
  if (!isEnabled()) {
    return;
  }
  if (myTargetFor == null || myTargetFor.size() != myTargetForSize)   myTargetFor=new VectorNd(myTargetForSize);
  double[] buf=myTargetFor.getBuffer();
  int idx=0;
  for (int i=0; i < myForceTargets.size(); i++) {
    ForceTarget target=myForceTargets.get(i);
    VectorNd lambda=target.getTargetLambda();
    lambda.get(buf,idx);
  }
}","public void updateTargetForce(double t0,double t1){
  if (!isEnabled()) {
    return;
  }
  if (myTargetFor == null || myTargetFor.size() != myTargetForSize)   myTargetFor=new VectorNd(myTargetForSize);
  double[] buf=myTargetFor.getBuffer();
  int idx=0;
  for (int i=0; i < myForceTargets.size(); i++) {
    ForceTarget target=myForceTargets.get(i);
    VectorNd lambda=target.getTargetLambda();
    lambda.get(buf,idx);
    idx+=lambda.size();
  }
}"
70706,"/** 
 * Solves the Quadratic Program of the form: min { x^T*Q*x + x^T*L }, subject to A*x &lt;= b, Aeq*x = beq
 * @return x
 */
public VectorNd solve(double t0,double t1){
  Q.setZero();
  P.setZero();
  for (  QPTerm term : myCostTerms) {
    term.getQP(Q,P,t0,t1);
  }
  int rowoff=0;
  for (  LeastSquaresTerm term : myInequalityTerms) {
    if (term.isEnabled())     term.getTerm(A,b,rowoff,t0,t1);
  }
  rowoff=0;
  for (  LeastSquaresTerm term : myEqualityTerms) {
    if (term.isEnabled())     term.getTerm(Aeq,beq,rowoff,t0,t1);
  }
  try {
    if (Aeq.rowSize() == 0 || beq.size() == 0) {
      mySolver.solve(x,Q,P,A,b);
    }
 else {
      Status qpStatus=mySolver.solve(x,Q,P,A,b,Aeq,beq);
      if (qpStatus != Status.SOLVED) {
        System.err.println(""String_Node_Str"" + qpStatus.toString());
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return x;
}","/** 
 * Solves the Quadratic Program of the form: min { x^T*Q*x + x^T*L }, subject to A*x &lt;= b, Aeq*x = beq
 * @return x
 */
public VectorNd solve(double t0,double t1){
  Q.setZero();
  P.setZero();
  for (  QPTerm term : myCostTerms) {
    term.getQP(Q,P,t0,t1);
  }
  int rowoff=0;
  for (  LeastSquaresTerm term : myInequalityTerms) {
    if (term.isEnabled())     rowoff=term.getTerm(A,b,rowoff,t0,t1);
  }
  rowoff=0;
  for (  LeastSquaresTerm term : myEqualityTerms) {
    if (term.isEnabled())     rowoff=term.getTerm(Aeq,beq,rowoff,t0,t1);
  }
  try {
    if (Aeq.rowSize() == 0 || beq.size() == 0) {
      mySolver.solve(x,Q,P,A,b);
    }
 else {
      Status qpStatus=mySolver.solve(x,Q,P,A,b,Aeq,beq);
      if (qpStatus != Status.SOLVED) {
        System.err.println(""String_Node_Str"" + qpStatus.toString());
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return x;
}"
70707,"/** 
 * to create the new window frame
 * @param windowName
 * @param width
 * @param height
 */
public Main(String windowName,int width,int height,GLVersion glVersion){
  myMain=this;
  if (glVersion == GLVersion.GL3) {
    GLVersionInfo vinfo=GLSupport.getGLVersionSupported();
    if ((vinfo.getMajorVersion() < myGLVersion.getMajorVersion()) || ((vinfo.getMajorVersion() == myGLVersion.getMajorVersion()) && (vinfo.getMinorVersion() < myGLVersion.getMinorVersion()))) {
      System.err.println(""String_Node_Str"" + glVersion.toString() + ""String_Node_Str"");
      System.err.println(""String_Node_Str"" + glVersion.getMajorVersion() + ""String_Node_Str""+ glVersion.getMinorVersion());
      System.err.println(""String_Node_Str"" + vinfo.getMajorVersion() + ""String_Node_Str""+ vinfo.getMinorVersion());
      glVersion=GLVersion.GL2;
    }
  }
  myGLVersion=glVersion;
  if (demosFilename.value != null) {
    readDemoNames(demosFilename.value);
  }
 else {
    myDemoModels=new AliasTable();
  }
  readScriptNames();
  if (historyFilename.value != null) {
    readModelHistory(historyFilename.value);
  }
  myEditorManager=new EditorManager(this);
  myUndoManager=new UndoManager();
  myInverseManager=new InverseManager(this);
  mySelectionManager=new SelectionManager();
  if (width > 0) {
    ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
    try {
      SwingUtilities.invokeAndWait(new MainFrameConstructor(windowName,this,width,height));
    }
 catch (    InvocationTargetException|InterruptedException e) {
      e.printStackTrace();
    }
    myMenuBarHandler=myFrame.getMenuBarHandler();
    mySelectionManager.setNavPanel(myFrame.getNavPanel());
    myFrame.getNavPanel().setSelectionManager(mySelectionManager);
    myKeyHandler=new GenericKeyHandler(this);
    myViewer=myFrame.getViewer();
    myViewer.addRenderListener(myMenuBarHandler);
    myViewerManager=new ViewerManager(myViewer);
    myViewerManager.setDefaultOrthographic(orthographic.value);
    myViewerManager.setDefaultDrawGrid(drawGrid.value);
    myViewerManager.setDefaultDrawAxes(drawAxes.value);
    myViewerManager.setDefaultAxisLength(axisLength.value);
    AxisAngle REW=getDefaultViewOrientation(getRootModel());
    myViewer.setDefaultAxialView(AxisAlignedRotation.getNearest(new RotationMatrix3d(REW)));
    initializeViewer(myViewer,REW);
    setSelectionMode(SelectionMode.Select);
    addSelectionListener(new SelectionHandler());
    Dragger3dHandler draggerHandler=new Dragger3dHandler();
    translator3d.addListener(draggerHandler);
    scalar3d.addListener(draggerHandler);
    rotator3d.addListener(draggerHandler);
    transrotator3d.addListener(draggerHandler);
    constrainedTranslator3d.addListener(draggerHandler);
    myViewerManager.addDragger(translator3d);
    myViewerManager.addDragger(scalar3d);
    myViewerManager.addDragger(rotator3d);
    myViewerManager.addDragger(transrotator3d);
    myViewerManager.addDragger(constrainedTranslator3d);
    setViewerSize(width,height);
    myPullController=new PullController(mySelectionManager);
  }
  createWorkspace();
}","/** 
 * to create the new window frame
 * @param windowName
 * @param width
 * @param height
 */
public Main(String windowName,int width,int height,GLVersion glVersion){
  myMain=this;
  if (glVersion == GLVersion.GL3) {
    GLVersionInfo vinfo=GLSupport.getMaxGLVersionSupported();
    if ((vinfo.getMajorVersion() < myGLVersion.getMajorVersion()) || ((vinfo.getMajorVersion() == myGLVersion.getMajorVersion()) && (vinfo.getMinorVersion() < myGLVersion.getMinorVersion()))) {
      System.err.println(""String_Node_Str"" + glVersion.toString() + ""String_Node_Str"");
      System.err.println(""String_Node_Str"" + glVersion.getMajorVersion() + ""String_Node_Str""+ glVersion.getMinorVersion());
      System.err.println(""String_Node_Str"" + vinfo.getMajorVersion() + ""String_Node_Str""+ vinfo.getMinorVersion());
      glVersion=GLVersion.GL2;
    }
  }
  myGLVersion=glVersion;
  if (demosFilename.value != null) {
    readDemoNames(demosFilename.value);
  }
 else {
    myDemoModels=new AliasTable();
  }
  readScriptNames();
  if (historyFilename.value != null) {
    readModelHistory(historyFilename.value);
  }
  myEditorManager=new EditorManager(this);
  myUndoManager=new UndoManager();
  myInverseManager=new InverseManager(this);
  mySelectionManager=new SelectionManager();
  if (width > 0) {
    ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
    try {
      SwingUtilities.invokeAndWait(new MainFrameConstructor(windowName,this,width,height));
    }
 catch (    InvocationTargetException|InterruptedException e) {
      e.printStackTrace();
    }
    myMenuBarHandler=myFrame.getMenuBarHandler();
    mySelectionManager.setNavPanel(myFrame.getNavPanel());
    myFrame.getNavPanel().setSelectionManager(mySelectionManager);
    myKeyHandler=new GenericKeyHandler(this);
    myViewer=myFrame.getViewer();
    myViewer.addRenderListener(myMenuBarHandler);
    myViewerManager=new ViewerManager(myViewer);
    myViewerManager.setDefaultOrthographic(orthographic.value);
    myViewerManager.setDefaultDrawGrid(drawGrid.value);
    myViewerManager.setDefaultDrawAxes(drawAxes.value);
    myViewerManager.setDefaultAxisLength(axisLength.value);
    AxisAngle REW=getDefaultViewOrientation(getRootModel());
    myViewer.setDefaultAxialView(AxisAlignedRotation.getNearest(new RotationMatrix3d(REW)));
    initializeViewer(myViewer,REW);
    setSelectionMode(SelectionMode.Select);
    addSelectionListener(new SelectionHandler());
    Dragger3dHandler draggerHandler=new Dragger3dHandler();
    translator3d.addListener(draggerHandler);
    scalar3d.addListener(draggerHandler);
    rotator3d.addListener(draggerHandler);
    transrotator3d.addListener(draggerHandler);
    constrainedTranslator3d.addListener(draggerHandler);
    myViewerManager.addDragger(translator3d);
    myViewerManager.addDragger(scalar3d);
    myViewerManager.addDragger(rotator3d);
    myViewerManager.addDragger(transrotator3d);
    myViewerManager.addDragger(constrainedTranslator3d);
    setViewerSize(width,height);
    myPullController=new PullController(mySelectionManager);
  }
  createWorkspace();
}"
70708,"private void maybeCreateMaster(){
  if (masterDrawable == null) {
    final GLProfile glp=glCapabilities.getGLProfile();
    masterDrawable=GLDrawableFactory.getFactory(glp).createDummyAutoDrawable(null,true,glCapabilities,null);
    masterDrawable.addGLEventListener(this);
    masterDrawable.addGLEventListener(garbageman);
    masterDrawable.display();
    if (garbageTimerEnabled) {
      masterRedrawThread=new MasterRedrawThread(masterDrawable,garbageCollectionInterval);
      masterRedrawThread.setName(""String_Node_Str"" + masterDrawable.getHandle());
      masterRedrawThread.start();
    }
  }
}","private void maybeCreateMaster(){
  if (masterDrawable == null) {
    final GLProfile glp=glCapabilities.getGLProfile();
    masterDrawable=GLDrawableFactory.getFactory(glp).createDummyAutoDrawable(null,true,glCapabilities,null);
    GLVersionListener glv=new GLVersionListener();
    masterDrawable.addGLEventListener(this);
    masterDrawable.addGLEventListener(garbageman);
    masterDrawable.addGLEventListener(glv);
    masterDrawable.display();
    while (!glv.isValid()) {
    }
    GLVersionInfo version=glv.getVersionInfo();
    System.out.println(version.getVersionString());
    masterDrawable.removeGLEventListener(glv);
    if (garbageTimerEnabled) {
      masterRedrawThread=new MasterRedrawThread(masterDrawable,garbageCollectionInterval);
      masterRedrawThread.setName(""String_Node_Str"" + masterDrawable.getHandle());
      masterRedrawThread.start();
    }
  }
}"
70709,"@Override public void init(GLAutoDrawable drawable){
  GL gl=drawable.getGL();
  String renderer=gl.glGetString(GL.GL_RENDERER);
  String version=gl.glGetString(GL.GL_VERSION);
  int[] buff=new int[2];
  gl.glGetIntegerv(GL3.GL_MAJOR_VERSION,buff,0);
  gl.glGetIntegerv(GL3.GL_MINOR_VERSION,buff,1);
  int major=buff[0];
  int minor=buff[1];
  vinfo=new GLVersionInfo(renderer,version,major,minor);
  valid=true;
}","@Override public void init(GLAutoDrawable drawable){
  GL gl=drawable.getGL();
  String renderer=gl.glGetString(GL.GL_RENDERER);
  GLSupport.checkAndPrintGLError(gl);
  String version=gl.glGetString(GL.GL_VERSION);
  GLSupport.checkAndPrintGLError(gl);
  Scanner scanf=new Scanner(version.trim().split(""String_Node_Str"",2)[0]);
  scanf.useDelimiter(""String_Node_Str"");
  int major=scanf.nextInt();
  int minor=scanf.nextInt();
  scanf.close();
  vinfo=new GLVersionInfo(renderer,version,major,minor);
  valid=true;
}"
70710,"public GLVersionInfo getVersionInfo(){
  return vinfo;
}","public static GLVersionInfo getVersionInfo(GLProfile glp){
  GLCapabilities glc=new GLCapabilities(glp);
  GLAutoDrawable dummy=GLDrawableFactory.getFactory(glp).createDummyAutoDrawable(null,true,glc,null);
  GLVersionListener listener=new GLVersionListener();
  dummy.addGLEventListener(listener);
  dummy.display();
  while (!listener.isValid()) {
  }
  GLVersionInfo vinfo=listener.getVersionInfo();
  dummy.disposeGLEventListener(listener,true);
  dummy.destroy();
  return vinfo;
}"
70711,"/** 
 * Called any time GL context is switched! e.g. moving window to new display
 */
public void init(GLAutoDrawable drawable){
  GL gl=drawable.getGL();
  String renderer=gl.glGetString(GL.GL_RENDERER);
  String version=gl.glGetString(GL.GL_VERSION);
  int[] buff=new int[2];
  gl.glGetIntegerv(GL3.GL_MAJOR_VERSION,buff,0);
  gl.glGetIntegerv(GL3.GL_MINOR_VERSION,buff,1);
  System.out.println(""String_Node_Str"" + renderer);
  System.out.println(""String_Node_Str"" + version + ""String_Node_Str""+ buff[0]+ ""String_Node_Str""+ buff[1]+ ""String_Node_Str"");
  setMultiSampleEnabled(true);
  myActiveColor=ActiveColor.DEFAULT;
}","/** 
 * Called any time GL context is switched! e.g. moving window to new display
 */
public void init(GLAutoDrawable drawable){
  GL gl=drawable.getGL();
  String renderer=gl.glGetString(GL.GL_RENDERER);
  String version=gl.glGetString(GL.GL_VERSION);
  System.out.println(""String_Node_Str"" + renderer);
  System.out.println(""String_Node_Str"" + version);
  setMultiSampleEnabled(true);
  myActiveColor=ActiveColor.DEFAULT;
}"
70712,"public void setRotationMode(RotationMode mode){
  myRotationMode=mode;
}","public void setRotationMode(RotationMode mode){
  if (myRotationMode != mode) {
    myRotationMode=mode;
    if (mode == RotationMode.DEFAULT) {
      setEyeToWorld(getEye(),myViewState.myCenter,getUpVector());
    }
  }
}"
70713,"/** 
 * Translate the eye position with respect to the x-y plane of the eye frame. The center point is translated by the same amount.
 * @param delx x translation amount
 * @param dely y translation amount
 */
protected void translate(double delx,double dely){
  Vector3d xCam=new Vector3d(), yCam=new Vector3d();
synchronized (viewMatrix) {
    viewMatrix.R.getRow(0,xCam);
    viewMatrix.R.getRow(1,yCam);
  }
  Vector3d offset=new Vector3d();
  offset.scale(-delx,xCam);
  offset.scaledAdd(-dely,yCam,offset);
  myViewState.myCenter.add(offset);
  Point3d eye=getEye();
  eye.add(offset);
  setEye(eye);
  repaint();
}","/** 
 * Translate the eye position with respect to the x-y plane of the eye frame. The center point is translated by the same amount.
 * @param delx x translation amount
 * @param dely y translation amount
 */
protected void translate(double delx,double dely){
  Vector3d xCam=new Vector3d(), yCam=new Vector3d();
synchronized (viewMatrix) {
    viewMatrix.R.getRow(0,xCam);
    viewMatrix.R.getRow(1,yCam);
  }
  Vector3d offset=new Vector3d();
  offset.scale(-delx,xCam);
  offset.scaledAdd(-dely,yCam,offset);
  myViewState.myCenter.add(offset);
  Point3d eye=getEye();
  eye.add(offset);
  setEyeToWorld(eye,myViewState.myCenter,getActualUpVector());
  repaint();
}"
70714,"/** 
 * Zoom in or out by a specified scale factor. A factor larger than one zooms out, while a factor less than one zooms in. In orthographic projection, zoom is accomplished changing the frustum size. In perspective projection, it is accomplished by moving the eye position along the z axis of the eye frame.
 * @param s scale factor
 */
public void zoom(double s){
  if (myFrustum.orthographic) {
    myFrustum.fieldHeight*=s;
    myFrustum.top*=s;
    myFrustum.bottom*=s;
    myFrustum.left*=s;
    myFrustum.right*=s;
    computeProjectionMatrix();
  }
 else {
    Vector3d reye=new Vector3d();
    Point3d eye=getEye();
synchronized (viewMatrix) {
      reye.sub(eye,myViewState.myCenter);
      reye.transform(viewMatrix);
      reye.x=reye.y=0;
      reye.inverseTransform(viewMatrix);
    }
    eye.scaledAdd(s - 1,reye);
    setEye(eye);
  }
  repaint();
}","/** 
 * Zoom in or out by a specified scale factor. A factor larger than one zooms out, while a factor less than one zooms in. In orthographic projection, zoom is accomplished changing the frustum size. In perspective projection, it is accomplished by moving the eye position along the z axis of the eye frame.
 * @param s scale factor
 */
public void zoom(double s){
  if (myFrustum.orthographic) {
    myFrustum.fieldHeight*=s;
    myFrustum.top*=s;
    myFrustum.bottom*=s;
    myFrustum.left*=s;
    myFrustum.right*=s;
    computeProjectionMatrix();
  }
 else {
    Vector3d reye=new Vector3d();
    Point3d eye=getEye();
synchronized (viewMatrix) {
      reye.sub(eye,myViewState.myCenter);
      reye.transform(viewMatrix);
      reye.x=reye.y=0;
      reye.inverseTransform(viewMatrix);
    }
    eye.scaledAdd(s - 1,reye);
    setEyeToWorld(eye,myViewState.myCenter,getActualUpVector());
  }
  repaint();
}"
70715,"public void activateFBO(GL2GL3 gl){
  fbo.activate(gl);
}","public void activateFBO(GL2GL3 gl){
  fbo.activate(gl);
  gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
}"
70716,"public void run(){
  BufferedImage image=null;
  if (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str"")) {
    image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
  }
 else {
    image=new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
  }
  image.setRGB(0,0,width,height,pixelsARGB,0,width);
  try {
    ImageIO.write(image,format,file);
  }
 catch (  IOException io_e) {
    io_e.printStackTrace();
  }
}","public void run(){
  BufferedImage image=null;
  if (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str"")) {
    image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
  }
 else {
    image=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
  }
  image.setRGB(0,0,width,height,pixelsARGB,0,width);
  try {
    ImageIO.write(image,format,file);
  }
 catch (  IOException io_e) {
    io_e.printStackTrace();
  }
}"
70717,"private void flushQueries(GL gl){
  if (myQueryCount == 0) {
    return;
  }
  gl.glFlush();
  ByteBuffer pixels=fbo.getPixels(myGl,GL.GL_RGBA);
  int w=fbo.getWidth();
  int h=fbo.getHeight();
  boolean badIdWarningIssued=false;
  int idx=0;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int lcolorId=a;
      lcolorId<<=8;
      lcolorId+=b;
      lcolorId<<=8;
      lcolorId+=g;
      lcolorId<<=8;
      lcolorId+=r;
      int colorId=(int)(lcolorId & (0xFFFFFFFF));
      if (colorId != 0) {
        int id=colorId / ID_STEP - ID_OFFSET + myQueryBase;
        if (id < 0 || id >= myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          myQueryBuffer[idx]=id;
        }
      }
      ++idx;
    }
  }
  BufferUtilities.freeDirectBuffer(pixels);
  gl.glClear(GL.GL_COLOR_BUFFER_BIT);
  myQueryBase+=myQueryCount;
  myQueryTotal+=myQueryCount;
  myQueryCount=0;
}","private void flushQueries(GL gl){
  if (myQueryCount == 0) {
    return;
  }
  gl.glFlush();
  ByteBuffer pixels=fbo.getPixels(myGl,GL.GL_RGBA);
  int w=fbo.getWidth();
  int h=fbo.getHeight();
  boolean badIdWarningIssued=false;
  int idx=0;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int lcolorId=a;
      lcolorId<<=8;
      lcolorId+=b;
      lcolorId<<=8;
      lcolorId+=g;
      lcolorId<<=8;
      lcolorId+=r;
      int colorId=(int)(lcolorId & (0xFFFFFFFF));
      if (colorId != 0) {
        int id=colorId / ID_STEP - ID_OFFSET + myQueryBase;
        if (id < 0 || id > myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          myQueryBuffer[idx]=id;
        }
      }
      ++idx;
    }
  }
  BufferUtilities.freeDirectBuffer(pixels);
  gl.glClear(GL.GL_COLOR_BUFFER_BIT);
  myQueryBase+=myQueryCount;
  myQueryTotal+=myQueryCount;
  myQueryCount=0;
}"
70718,"public ForceTargetTerm(TrackingController trackingController){
  super();
  myMech=trackingController.getMech();
  myController=trackingController;
  myForceTargets=new ArrayList<ForceTarget>();
  myTargetForceWeights=new ArrayList<Double>();
  initTargetRenderProps();
  initSourceRenderProps();
}","public ForceTargetTerm(TrackingController trackingController){
  super();
  myMech=trackingController.getMech();
  myController=trackingController;
  myForceTargets=new ArrayList<ForceTarget>();
  myTargetForceWeights=new ArrayList<Double>();
}"
70719,"/** 
 * Fills <code>H</code> and <code>b</code> with this motion term
 * @param H LHS matrix to fill
 * @param b RHS vector to fill
 * @param rowoff row offset to start filling term
 * @param t0 starting time of time step
 * @param t1 ending time of time step
 * @return next row offset
 */
public int getTerm(MatrixNd H,VectorNd b,int rowoff,double t0,double t1){
  double h=TimeBase.round(t1 - t0);
  updateTarget(t0,t1);
  updateModelVelocity();
  VectorNd cbar=new VectorNd(myTargetForSize);
  cbar.sub(myTargetFor,myController.getData().getC0());
  MatrixNd Hc=new MatrixNd(myTargetForSize,myController.numExcitations());
  Hc.set(myController.getData().getHc());
  if (myController.getData().normalizeH) {
    double fn=1.0 / Hc.frobeniusNorm();
    Hc.scale(fn);
    cbar.scale(fn);
  }
  if (myController.getData().useTimestepScaling) {
    Hc.scale(1 / h);
    cbar.scale(1 / h);
  }
  if (myForTargetWgts != null) {
    MotionForceInverseData.diagMul(myForTargetWgts,Hc,Hc);
    MotionForceInverseData.pointMul(myForTargetWgts,cbar,cbar);
  }
  if (myWeight >= 0) {
    Hc.scale(myWeight);
    cbar.scale(myWeight);
  }
  H.setSubMatrix(rowoff,0,Hc);
  b.setSubVector(rowoff,cbar);
  if (myController.isDebugTimestep(t0,t1)) {
    System.out.println(""String_Node_Str"" + myTargetFor);
    System.out.println(""String_Node_Str"" + getForceJacobian());
    System.out.println(""String_Node_Str"" + Hc);
    System.out.println(""String_Node_Str"" + cbar);
  }
  return rowoff + Hc.rowSize();
}","/** 
 * Fills <code>H</code> and <code>b</code> with this motion term
 * @param H LHS matrix to fill
 * @param b RHS vector to fill
 * @param rowoff row offset to start filling term
 * @param t0 starting time of time step
 * @param t1 ending time of time step
 * @return next row offset
 */
public int getTerm(MatrixNd H,VectorNd b,int rowoff,double t0,double t1){
  double h=TimeBase.round(t1 - t0);
  updateTargetForce(t0,t1);
  VectorNd cbar=new VectorNd(myTargetForSize);
  cbar.sub(myTargetFor,myController.getData().getC0());
  MatrixNd Hc=new MatrixNd(myTargetForSize,myController.numExcitations());
  Hc.set(myController.getData().getHc());
  if (myController.getData().normalizeH) {
    double fn=1.0 / Hc.frobeniusNorm();
    Hc.scale(fn);
    cbar.scale(fn);
  }
  if (myController.getData().useTimestepScaling) {
    Hc.scale(1 / h);
    cbar.scale(1 / h);
  }
  if (myForTargetWgts != null) {
    MotionForceInverseData.diagMul(myForTargetWgts,Hc,Hc);
    MotionForceInverseData.pointMul(myForTargetWgts,cbar,cbar);
  }
  if (myWeight >= 0) {
    Hc.scale(myWeight);
    cbar.scale(myWeight);
  }
  H.setSubMatrix(rowoff,0,Hc);
  b.setSubVector(rowoff,cbar);
  if (myController.isDebugTimestep(t0,t1)) {
    System.out.println(""String_Node_Str"" + myTargetFor);
    System.out.println(""String_Node_Str"" + getForceJacobian());
    System.out.println(""String_Node_Str"" + Hc);
    System.out.println(""String_Node_Str"" + cbar);
  }
  return rowoff + Hc.rowSize();
}"
70720,"public void updateTargetForce(){
  if (myTargetFor == null || myTargetFor.size() != myTargetForSize)   myTargetFor=new VectorNd(myTargetForSize);
  double[] buf=myTargetFor.getBuffer();
  int idx=0;
  for (int i=0; i < myForceTargets.size(); i++) {
    ForceTarget target=myForceTargets.get(i);
    VectorNd lambda=target.getTargetLambda();
    buf[i]=lambda.get(0);
  }
}","public void updateTargetForce(double t0,double t1){
  if (myTargetFor == null || myTargetFor.size() != myTargetForSize)   myTargetFor=new VectorNd(myTargetForSize);
  double[] buf=myTargetFor.getBuffer();
  int idx=0;
  for (int i=0; i < myForceTargets.size(); i++) {
    ForceTarget target=myForceTargets.get(i);
    VectorNd lambda=target.getTargetLambda();
    lambda.get(buf,idx);
  }
}"
70721,"public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  maybeUpdateState(gl);
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
    myGLColorCount=0;
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + myGLColorCount);
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  if (frameCapture != null) {
synchronized (frameCapture) {
      if (grab) {
        offscreenCapture(flags);
        grab=false;
      }
      if (grabWaitComplete) {
        frameCapture.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        frameCapture.waitForCompletion();
        frameCapture.dispose(gl);
        frameCapture=null;
      }
    }
  }
  garbage(gl);
  this.drawable=null;
  this.gl=null;
}","public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  maybeUpdateState(gl);
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
    myGLColorCount=0;
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + myGLColorCount);
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  GLFrameCapture fc=frameCapture;
  if (fc != null) {
synchronized (fc) {
      if (grab) {
        offscreenCapture(fc,flags);
        grab=false;
      }
      if (grabWaitComplete) {
        fc.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        fc.waitForCompletion();
        fc.dispose(gl);
        frameCapture=null;
      }
    }
  }
  garbage(gl);
  this.drawable=null;
  this.gl=null;
}"
70722,"private void offscreenCapture(int flags){
  gl.setSwapInterval(1);
  frameCapture.activateFBO(gl);
  gl.glPushMatrix();
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  gl.glPopMatrix();
  frameCapture.deactivateFBO(gl);
  frameCapture.capture(gl);
}","private void offscreenCapture(GLFrameCapture fc,int flags){
  gl.setSwapInterval(1);
  fc.activateFBO(gl);
  gl.glPushMatrix();
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  gl.glPopMatrix();
  fc.deactivateFBO(gl);
  fc.capture(gl);
}"
70723,"@Override public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL3();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  if (frameCapture != null) {
synchronized (frameCapture) {
      if (grab) {
        offscreenCapture(flags);
        grab=false;
      }
      if (grabWaitComplete) {
        frameCapture.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        frameCapture.waitForCompletion();
        frameCapture.dispose(gl);
        frameCapture=null;
      }
    }
  }
  long time=System.currentTimeMillis();
  if (time - lastGarbageTime > myGLResources.getGarbageCollectionInterval()) {
    garbage(gl);
  }
  myGLResources.maybeRunGarbageCollection(gl);
  this.drawable=null;
  this.gl=null;
}","@Override public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL3();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  if (selectTrigger) {
    mySelector.setupSelection(gl);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  if (myProfiling) {
    myTimer.start();
  }
  doDisplay(drawable,flags);
  if (myProfiling) {
    myTimer.stop();
    System.out.printf(""String_Node_Str"",myTimer.getTimeUsec() / 1000.0,isSelecting() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(gl);
  }
 else {
    fireRerenderListeners();
  }
  GLFrameCapture fc=frameCapture;
  if (fc != null) {
synchronized (fc) {
      if (grab) {
        offscreenCapture(fc,flags);
        grab=false;
      }
      if (grabWaitComplete) {
        fc.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        fc.waitForCompletion();
        fc.dispose(gl);
        frameCapture=null;
      }
    }
  }
  long time=System.currentTimeMillis();
  if (time - lastGarbageTime > myGLResources.getGarbageCollectionInterval()) {
    garbage(gl);
  }
  myGLResources.maybeRunGarbageCollection(gl);
  this.drawable=null;
  this.gl=null;
}"
70724,"private void offscreenCapture(int flags){
  boolean savedSelecting=selectEnabled;
  selectEnabled=false;
  gl.setSwapInterval(1);
  frameCapture.activateFBO(gl);
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  frameCapture.deactivateFBO(gl);
  frameCapture.capture(gl);
  selectEnabled=savedSelecting;
}","private void offscreenCapture(GLFrameCapture fc,int flags){
  boolean savedSelecting=selectEnabled;
  selectEnabled=false;
  gl.setSwapInterval(1);
  fc.activateFBO(gl);
  boolean autoResize=setAutoResizeEnabled(false);
  boolean autoViewport=setAutoViewportEnabled(false);
  doDisplay(drawable,flags);
  setAutoResizeEnabled(autoResize);
  setAutoViewportEnabled(autoViewport);
  fireRerenderListeners();
  fc.deactivateFBO(gl);
  fc.capture(gl);
  selectEnabled=savedSelecting;
}"
70725,"public void processSelection(GLAutoDrawable drawable){
  GL2GL3 gl=(GL2GL3)(drawable.getGL());
  myViewer.setColorEnabled(true);
  myViewer.setDepthEnabled(true);
  myViewer.setLightingEnabled(true);
  myViewer.setMultiSampleEnabled(savedMultisampled);
  if (changeViewport) {
    gl.glViewport(mySavedViewport[0],mySavedViewport[1],mySavedViewport[2],mySavedViewport[3]);
  }
  myViewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  flushQueries(myGl);
  if (myGLQueryTotal == 0) {
    myViewer.setSelected(null);
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    Iterator<IsRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      IsRenderable r=it.next();
      if (r instanceof IsSelectable) {
        IsSelectable s=(IsSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            if (myQuerySamples[qid + i] > 0) {
              HitRecord rec=new HitRecord(myQuerySamples[qid + i]);
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    ArrayList<LinkedList<?>> selObjs=new ArrayList<>(records.size());
    for (int i=0; i < records.size(); i++) {
      selObjs.add(records.get(i).objs);
    }
    myViewer.setSelected(selObjs);
  }
  gl.glDeleteQueries(myTotalMaxQ,myGLQueries,0);
  myGLQueries=null;
  myGLQueryIds=null;
  myGl=null;
  ViewerSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.getSelectionEvent());
  }
  myViewer.getCanvas().repaint();
}","public void processSelection(GLAutoDrawable drawable){
  GL2GL3 gl=(GL2GL3)(drawable.getGL());
  myViewer.setColorEnabled(true);
  myViewer.setDepthEnabled(true);
  myViewer.setLightingEnabled(true);
  myViewer.setMultiSampleEnabled(savedMultisampled);
  if (changeViewport) {
    gl.glViewport(mySavedViewport[0],mySavedViewport[1],mySavedViewport[2],mySavedViewport[3]);
  }
  myViewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  flushQueries(myGl);
  if (myGLQueryTotal == 0) {
    myViewer.setSelected(null);
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    Iterator<IsRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      IsRenderable r=it.next();
      if (r instanceof IsSelectable) {
        IsSelectable s=(IsSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            if (myQuerySamples[qid + i] > 0) {
              HitRecord rec=new HitRecord(myQuerySamples[qid + i]);
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    ArrayList<LinkedList<?>> selObjs=new ArrayList<>(records.size());
    for (int i=0; i < records.size(); i++) {
      selObjs.add(records.get(i).objs);
    }
    myViewer.setSelected(selObjs);
  }
  gl.glDeleteQueries(myGLQueries.length,myGLQueries,0);
  myGLQueries=null;
  myGLQueryIds=null;
  myGl=null;
  ViewerSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.getSelectionEvent());
  }
  myViewer.getCanvas().repaint();
}"
70726,"public void setupSelection(GLAutoDrawable drawable){
  if (!(myViewer instanceof GLViewer)) {
    return;
  }
  GLViewer viewer=(GLViewer)myViewer;
  GL2GL3 gl=(GL2GL3)drawable.getGL();
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  if (myTotalMaxQ == 0) {
    return;
  }
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  myQuerySamples=new int[myTotalMaxQ];
  int maxGLQueries=Math.min(myTotalMaxQ,MAX_OCCLUSION_QUERIES);
  myGLQueries=new int[maxGLQueries];
  myGLQueryIds=new int[maxGLQueries];
  myGLQueryCount=0;
  myGLQueryTotal=0;
  gl.glGenQueries(myTotalMaxQ,myGLQueries,0);
  mySavedViewport=viewer.getViewport(gl);
  if (changeViewport) {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
    viewer.setViewport(gl,0,0,(int)Math.ceil(myRectW),(int)Math.ceil(myRectH));
  }
 else {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
  }
  Vector2d zRange=new Vector2d();
  myViewer.getZRange(zRange);
  myViewer.setViewVolume(zRange.x,zRange.y);
  viewer.setLightingEnabled(false);
  viewer.setColorEnabled(false);
  viewer.setDepthEnabled(false);
  savedMultisampled=myViewer.isMultiSampleEnabled();
  if (savedMultisampled) {
    myViewer.setMultiSampleEnabled(false);
  }
}","public void setupSelection(GLAutoDrawable drawable){
  if (!(myViewer instanceof GLViewer)) {
    return;
  }
  GLViewer viewer=(GLViewer)myViewer;
  GL2GL3 gl=(GL2GL3)drawable.getGL();
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  if (myTotalMaxQ == 0) {
    return;
  }
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  myQuerySamples=new int[myTotalMaxQ];
  int maxGLQueries=Math.min(myTotalMaxQ,MAX_OCCLUSION_QUERIES);
  myGLQueries=new int[maxGLQueries];
  myGLQueryIds=new int[maxGLQueries];
  myGLQueryCount=0;
  myGLQueryTotal=0;
  gl.glGenQueries(myGLQueries.length,myGLQueries,0);
  mySavedViewport=viewer.getViewport(gl);
  if (changeViewport) {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
    viewer.setViewport(gl,0,0,(int)Math.ceil(myRectW),(int)Math.ceil(myRectH));
  }
 else {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
  }
  Vector2d zRange=new Vector2d();
  myViewer.getZRange(zRange);
  myViewer.setViewVolume(zRange.x,zRange.y);
  viewer.setLightingEnabled(false);
  viewer.setColorEnabled(false);
  viewer.setDepthEnabled(false);
  savedMultisampled=myViewer.isMultiSampleEnabled();
  if (savedMultisampled) {
    myViewer.setMultiSampleEnabled(false);
  }
}"
70727,"public void addRenderables(SphericalJointForceBound bounds,Point3d p0){
  Iterator<Vector3d> viter;
  Iterator<Point3d> piter;
  Vector3d prev, first;
  Point3d prevPt, firstPt;
  Vector3d tmp=new Vector3d();
  ArrayList<Point3d> polyPts=new ArrayList<Point3d>();
  viter=bounds.getBoundNormals().iterator();
  prev=viter.next();
  while (viter.hasNext()) {
    Vector3d cur=viter.next();
    tmp.cross(prev,cur);
    tmp.normalize();
    polyPts.add(new Point3d(tmp));
    lines.add(new LineInfo(p0,tmp,Color.ORANGE));
    prev=cur;
  }
  piter=polyPts.iterator();
  firstPt=piter.next();
  prevPt=firstPt;
  while (piter.hasNext()) {
    Point3d curPt=piter.next();
    planes.add(new TriInfo(p0,prevPt,curPt,Color.MAGENTA));
    prevPt=curPt;
  }
  planes.add(new TriInfo(p0,prevPt,firstPt,Color.MAGENTA));
}","public void addRenderables(SphericalJointForceBound bounds,Point3d p0){
  Iterator<Vector3d> viter;
  Iterator<Point3d> piter;
  Vector3d prev, first;
  Point3d prevPt, firstPt;
  Vector3d tmp=new Vector3d();
  ArrayList<Point3d> polyPts=new ArrayList<Point3d>();
  viter=bounds.getBoundNormals().iterator();
  prev=bounds.getBoundNormals().get(bounds.getBoundNormals().size() - 1);
  while (viter.hasNext()) {
    Vector3d cur=viter.next();
    tmp.cross(prev,cur);
    tmp.normalize();
    polyPts.add(new Point3d(tmp));
    lines.add(new LineInfo(p0,tmp,Color.ORANGE));
    prev=cur;
  }
  piter=polyPts.iterator();
  firstPt=piter.next();
  prevPt=firstPt;
  while (piter.hasNext()) {
    Point3d curPt=piter.next();
    planes.add(new TriInfo(p0,prevPt,curPt,Color.LIGHT_GRAY));
    lines.add(new LineInfo(p0,tmp,Color.RED));
    prevPt=curPt;
  }
  planes.add(new TriInfo(p0,prevPt,firstPt,Color.LIGHT_GRAY));
}"
70728,"private void createForceJacobian(){
  MechModel mechMod=(MechModel)myMech;
  int[] target_idx=new int[myForceTargets.size()];
  int idx=0;
  int cons_ind=0;
  System.out.println(mechMod.bodyConnectors().size());
  SparseBlockMatrix GT=new SparseBlockMatrix();
  VectorNd dg=new VectorNd();
  mechMod.getBilateralConstraints(GT,dg);
  System.out.println(GT.colSize());
  System.out.println(GT.rowSize());
  System.out.println(GT.getSize());
  System.out.println(GT.numBlocks());
  System.out.println(GT.getBlock(0,0));
  System.out.println(GT.getBlock(0,1));
  System.out.println(GT.getBlock(0,2));
  System.out.println(GT.getBlock(1,0));
  int[] constraint_blocksize=new int[mechMod.bodyConnectors().size()];
  for (int i=0; i < myForceTargets.size(); i++) {
    cons_ind=0;
    for (int j=0; j < mechMod.bodyConnectors().size(); j++) {
      System.out.println(mechMod.bodyConnectors().get(j).getName());
      if (mechMod.bodyConnectors().get(j).getName() == myForceTargets.get(i).getName()) {
        target_idx[idx]=cons_ind;
        idx++;
      }
      if (mechMod.bodyConnectors().get(j).isEnabled() == true) {
        System.out.println(mechMod.bodyConnectors().get(j).numBilateralConstraints());
        constraint_blocksize[cons_ind]=mechMod.bodyConnectors().get(j).numBilateralConstraints();
        cons_ind++;
      }
    }
  }
  int[] dynsize=new int[cons_ind];
  Arrays.fill(dynsize,1);
  myForJacobian=new SparseBlockMatrix(new int[0],constraint_blocksize);
  for (int i=0; i < myForceTargets.size(); i++) {
    ForceTarget target=myForceTargets.get(i);
    target.addForceJacobian(myForJacobian,i,target_idx[i]);
  }
}","private void createForceJacobian(){
  MechModel mechMod=(MechModel)myMech;
  int[] target_idx=new int[myForceTargets.size()];
  int idx=0;
  int cons_ind=0;
  System.out.println(mechMod.bodyConnectors().size());
  SparseBlockMatrix GT=new SparseBlockMatrix();
  VectorNd dg=new VectorNd();
  mechMod.getBilateralConstraints(GT,dg);
  System.out.println(GT.colSize());
  System.out.println(GT.rowSize());
  System.out.println(GT.getSize());
  System.out.println(GT.numBlocks());
  System.out.println(GT.getBlock(0,0));
  System.out.println(GT.getBlock(0,1));
  System.out.println(GT.getBlock(0,2));
  System.out.println(GT.getBlock(1,0));
  int[] constraint_blocksize=new int[mechMod.bodyConnectors().size()];
  for (int i=0; i < myForceTargets.size(); i++) {
    cons_ind=0;
    for (int j=0; j < mechMod.bodyConnectors().size(); j++) {
      if (myForceTargets.get(i).getName().startsWith(mechMod.bodyConnectors().get(j).getName())) {
        target_idx[idx]=cons_ind;
        idx++;
      }
      if (mechMod.bodyConnectors().get(j).isEnabled() == true) {
        System.out.println(mechMod.bodyConnectors().get(j).numBilateralConstraints());
        constraint_blocksize[cons_ind]=mechMod.bodyConnectors().get(j).numBilateralConstraints();
        cons_ind++;
      }
    }
  }
  int[] dynsize=new int[cons_ind];
  Arrays.fill(dynsize,1);
  myForJacobian=new SparseBlockMatrix(new int[0],constraint_blocksize);
  for (int i=0; i < myForceTargets.size(); i++) {
    ForceTarget target=myForceTargets.get(i);
    target.addForceJacobian(myForJacobian,i,target_idx[i]);
  }
}"
70729,"private void configureTargetForceProbe(NumericProbeBase probe,ArrayList<ForceTarget> targets,String filename){
  System.out.println(""String_Node_Str"");
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ForceTarget target : targets) {
    props.add(target.getProperty(""String_Node_Str""));
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}","private void configureTargetForceProbe(NumericProbeBase probe,ArrayList<ForceTarget> targets,String filename){
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ForceTarget target : targets) {
    props.add(target.getProperty(""String_Node_Str""));
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}"
70730,"private void configureTargetMotionProbe(NumericProbeBase probe,ArrayList<MotionTargetComponent> targets,String filename){
  System.out.println(""String_Node_Str"");
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ModelComponent target : targets) {
    if (target instanceof Point) {
      props.add(target.getProperty(""String_Node_Str""));
    }
 else     if (target instanceof Frame) {
      props.add(target.getProperty(""String_Node_Str""));
      props.add(target.getProperty(""String_Node_Str""));
    }
 else {
      System.err.println(""String_Node_Str"" + target.getClass().toString());
    }
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}","private void configureTargetMotionProbe(NumericProbeBase probe,ArrayList<MotionTargetComponent> targets,String filename){
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ModelComponent target : targets) {
    if (target instanceof Point) {
      props.add(target.getProperty(""String_Node_Str""));
    }
 else     if (target instanceof Frame) {
      props.add(target.getProperty(""String_Node_Str""));
      props.add(target.getProperty(""String_Node_Str""));
    }
 else {
      System.err.println(""String_Node_Str"" + target.getClass().toString());
    }
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}"
70731,"/** 
 * Adds a target to the term for trajectory error
 * @param source
 * @param weight
 * @return the created target body or point
 */
private MotionTargetComponent doAddTarget(MotionTargetComponent source,double weight){
  mySources.add(source);
  source.setTargetActivity(TargetActivity.None);
  MotionTargetComponent target=null;
  if (source instanceof Point) {
    myTargetVelSize+=POINT_ENTRY_SIZE;
    myTargetPosSize+=POINT_ENTRY_SIZE;
    target=addTargetPoint((Point)source);
  }
 else   if (source instanceof Frame) {
    myTargetVelSize+=FRAME_POS_SIZE;
    myTargetPosSize+=FRAME_VEL_SIZE;
    target=addTargetFrame((RigidBody)source);
  }
  myTargetWeights.add(weight);
  updateWeightsVector();
  myVelJacobian=null;
  return target;
}","/** 
 * Adds a target to the term for trajectory error
 * @param source
 * @param weight
 * @return the created target body or point
 */
private MotionTargetComponent doAddTarget(MotionTargetComponent source,double weight){
  mySources.add(source);
  source.setTargetActivity(TargetActivity.None);
  MotionTargetComponent target=null;
  if (source instanceof Point) {
    myTargetVelSize+=POINT_VEL_SIZE;
    myTargetPosSize+=POINT_POS_SIZE;
    target=addTargetPoint((Point)source);
  }
 else   if (source instanceof Frame) {
    myTargetVelSize+=FRAME_VEL_SIZE;
    myTargetPosSize+=FRAME_POS_SIZE;
    target=addTargetFrame((RigidBody)source);
  }
  myTargetWeights.add(weight);
  updateWeightsVector();
  myVelJacobian=null;
  return target;
}"
70732,"/** 
 * Creates and adds a target frame, returning the created frame to track
 * @param source to drive toward target 
 * @return the created target frame
 */
private TargetFrame addTargetFrame(RigidBody source){
  TargetFrame tframe=new TargetFrame();
  tframe.setName((source.getName() != null ? source.getName() : String.format(""String_Node_Str"",source.getNumber())) + ""String_Node_Str"");
  tframe.setState(source);
  tframe.setTargetActivity(TargetActivity.PositionVelocity);
  tframe.setAxisLength(1.0);
  myTargets.add(tframe);
  myController.targetFrames.add(tframe);
  return tframe;
}","/** 
 * Creates and adds a target frame, returning the created frame to track
 * @param source to drive toward target 
 * @return the created target frame
 */
private TargetFrame addTargetFrame(RigidBody source){
  TargetFrame tframe=new TargetFrame();
  tframe.setPose(source.getPose());
  tframe.setName((source.getName() != null ? source.getName() : String.format(""String_Node_Str"",source.getNumber())) + ""String_Node_Str"");
  tframe.setState(source);
  tframe.setTargetActivity(TargetActivity.PositionVelocity);
  tframe.setAxisLength(1.0);
  myTargets.add(tframe);
  if (source.getMesh() != null) {
    tframe.setMesh(new PolygonalMesh(source.getMesh()),source.getMeshFileName());
    tframe.setRenderProps(source.getRenderProps());
    RenderProps.setDrawEdges(tframe,true);
    RenderProps.setFaceStyle(tframe,Faces.NONE);
  }
  myController.targetFrames.add(tframe);
  return tframe;
}"
70733,"private void updateWeightsVector(){
  myTargetWgts=new VectorNd(myTargetVelSize);
  int idx=0;
  for (int t=0; t < mySources.size(); t++) {
    MotionTargetComponent target=mySources.get(t);
    double w=myTargetWeights.get(t);
    if (target instanceof Point) {
      for (int i=0; i < POINT_ENTRY_SIZE; i++) {
        myTargetWgts.set(idx++,w);
      }
    }
 else     if (target instanceof Frame) {
      for (int i=0; i < FRAME_VEL_SIZE; i++) {
        myTargetWgts.set(idx++,w);
      }
    }
  }
}","private void updateWeightsVector(){
  myTargetWgts=new VectorNd(myTargetVelSize);
  int idx=0;
  for (int t=0; t < mySources.size(); t++) {
    MotionTargetComponent target=mySources.get(t);
    double w=myTargetWeights.get(t);
    if (target instanceof Point) {
      for (int i=0; i < POINT_VEL_SIZE; i++) {
        myTargetWgts.set(idx++,w);
      }
    }
 else     if (target instanceof Frame) {
      for (int i=0; i < FRAME_VEL_SIZE; i++) {
        myTargetWgts.set(idx++,w);
      }
    }
  }
}"
70734,"/** 
 * Removes a target to the term for trajectory error
 * @param source
 */
protected void removeTarget(MotionTargetComponent source){
  int idx=mySources.indexOf(source);
  if (idx == -1) {
    return;
  }
  if (source instanceof Point) {
    myTargetVelSize-=POINT_ENTRY_SIZE;
    myTargetPosSize-=POINT_ENTRY_SIZE;
    removeTargetPoint((Point)myTargets.get(idx));
  }
 else   if (source instanceof Frame) {
    myTargetVelSize-=FRAME_POS_SIZE;
    myTargetPosSize-=FRAME_VEL_SIZE;
    removeTargetFrame((Frame)myTargets.get(idx));
  }
  myTargetWeights.remove(idx);
  mySources.remove(idx);
  myTargets.remove(idx);
  updateWeightsVector();
  myVelJacobian=null;
}","/** 
 * Removes a target to the term for trajectory error
 * @param source
 */
protected void removeTarget(MotionTargetComponent source){
  int idx=mySources.indexOf(source);
  if (idx == -1) {
    return;
  }
  if (source instanceof Point) {
    myTargetVelSize-=POINT_VEL_SIZE;
    myTargetPosSize-=POINT_POS_SIZE;
    removeTargetPoint((Point)myTargets.get(idx));
  }
 else   if (source instanceof Frame) {
    myTargetVelSize-=FRAME_VEL_SIZE;
    myTargetPosSize-=FRAME_POS_SIZE;
    removeTargetFrame((Frame)myTargets.get(idx));
  }
  myTargetWeights.remove(idx);
  mySources.remove(idx);
  myTargets.remove(idx);
  updateWeightsVector();
  myVelJacobian=null;
}"
70735,"public TargetFrame(RigidTransform3d X){
  super(X);
}","public TargetFrame(RigidTransform3d X){
  super();
  setPose(X);
}"
70736,"/** 
 * Prepare framebuffer for use. Width and height should be set to rational values before calling this function. Creates framebuffer with depth buffer and one texture.
 */
public void setupFBO(){
  setup=true;
  IntBuffer handle=allocInts(1);
  gl.glGenFramebuffers(1,handle);
  FBOhandle=handle.get(0);
  if (samples > 1) {
    gl.glGenFramebuffers(1,handle);
    FBNhandle=handle.get(0);
  }
  addDepthBuffer();
  addRgbBuffer();
  checkStatus();
}","/** 
 * Prepare framebuffer for use. Width and height should be set to rational values before calling this function. Creates framebuffer with depth buffer and one texture.
 */
public void setupFBO(){
  IntBuffer handle=allocInts(1);
  gl.glGenFramebuffers(1,handle);
  FBOhandle=handle.get(0);
  if (samples > 1) {
    gl.glGenFramebuffers(1,handle);
    FBNhandle=handle.get(0);
  }
  addDepthBuffer();
  addRgbBuffer();
  checkStatus();
  setup=true;
}"
70737,"/** 
 * Create a framebuffer with the given dimensions
 */
public FrameBufferObject(int x,int y,int w,int h,File file,String format,GL2 gl){
  width=w;
  height=h;
  this.x=x;
  this.y=y;
  this.gl=gl;
  this.file=file;
  this.format=format;
}","/** 
 * Create a framebuffer with the given dimensions
 */
public FrameBufferObject(int x,int y,int w,int h,int nsamples,File file,String format,GL2 gl){
  width=w;
  height=h;
  this.x=x;
  this.y=y;
  this.gl=gl;
  this.file=file;
  this.format=format;
  this.samples=nsamples;
  this.setup=false;
}"
70738,"/** 
 * Create a renderBuffer configured as an RGB buffer and attach it to the FBO
 */
private void addRgbBuffer(){
  System.out.println(""String_Node_Str"");
  IntBuffer rboId=allocInts(1);
  gl.glGenRenderbuffers(1,rboId);
  CBhandle=rboId.get(0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,FBOhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,CBhandle);
  if (samples > 1) {
    gl.glGenRenderbuffers(1,rboId);
    CBNhandle=rboId.get(0);
    gl.glRenderbufferStorageMultisample(GL2.GL_RENDERBUFFER,samples,GL2.GL_RGBA8,width,height);
  }
 else {
    gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER,GL2.GL_RGBA8,width,height);
  }
  gl.glFramebufferRenderbuffer(GL2.GL_FRAMEBUFFER,GL2.GL_COLOR_ATTACHMENT0,GL2.GL_RENDERBUFFER,CBhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,ActiveFBO);
}","/** 
 * Create a renderBuffer configured as an RGB buffer and attach it to the FBO
 */
private void addRgbBuffer(){
  IntBuffer rboId=allocInts(1);
  gl.glGenRenderbuffers(1,rboId);
  CBhandle=rboId.get(0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,FBOhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,CBhandle);
  if (samples > 1) {
    gl.glGenRenderbuffers(1,rboId);
    CBNhandle=rboId.get(0);
    gl.glRenderbufferStorageMultisample(GL2.GL_RENDERBUFFER,samples,GL2.GL_RGBA8,width,height);
  }
 else {
    gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER,GL2.GL_RGBA8,width,height);
  }
  gl.glFramebufferRenderbuffer(GL2.GL_FRAMEBUFFER,GL2.GL_COLOR_ATTACHMENT0,GL2.GL_RENDERBUFFER,CBhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,ActiveFBO);
}"
70739,"/** 
 * Return the error code from the FBO
 */
public int checkStatus(){
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,FBOhandle);
  status=gl.glCheckFramebufferStatus(GL2.GL_FRAMEBUFFER);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,ActiveFBO);
  System.out.println(""String_Node_Str"" + status + ""String_Node_Str""+ framebuffer_status_string(status));
  return status;
}","/** 
 * Return the error code from the FBO
 */
public int checkStatus(){
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,FBOhandle);
  status=gl.glCheckFramebufferStatus(GL2.GL_FRAMEBUFFER);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,ActiveFBO);
  if (status != GL2.GL_FRAMEBUFFER_COMPLETE) {
    System.err.println(""String_Node_Str"" + status + ""String_Node_Str""+ framebuffer_status_string(status));
  }
  return status;
}"
70740,"/** 
 * Create a renderBuffer configured as a depth buffer and attach it to the FBO
 */
private void addDepthBuffer(){
  System.out.println(""String_Node_Str"");
  IntBuffer rboId=allocInts(1);
  gl.glGenRenderbuffers(1,rboId);
  DBhandle=rboId.get(0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,FBOhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,DBhandle);
  if (samples > 1) {
    gl.glRenderbufferStorageMultisample(GL2.GL_RENDERBUFFER,samples,GL2.GL_DEPTH_COMPONENT,width,height);
  }
 else {
    gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER,GL2.GL_DEPTH_COMPONENT,width,height);
  }
  gl.glFramebufferRenderbuffer(GL2.GL_FRAMEBUFFER,GL2.GL_DEPTH_ATTACHMENT,GL2.GL_RENDERBUFFER,DBhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,ActiveFBO);
}","/** 
 * Create a renderBuffer configured as a depth buffer and attach it to the FBO
 */
private void addDepthBuffer(){
  IntBuffer rboId=allocInts(1);
  gl.glGenRenderbuffers(1,rboId);
  DBhandle=rboId.get(0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,FBOhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,DBhandle);
  if (samples > 1) {
    gl.glRenderbufferStorageMultisample(GL2.GL_RENDERBUFFER,samples,GL2.GL_DEPTH_COMPONENT,width,height);
  }
 else {
    gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER,GL2.GL_DEPTH_COMPONENT,width,height);
  }
  gl.glFramebufferRenderbuffer(GL2.GL_FRAMEBUFFER,GL2.GL_DEPTH_ATTACHMENT,GL2.GL_RENDERBUFFER,DBhandle);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,ActiveFBO);
}"
70741,"public void processSelection(GLAutoDrawable drawable){
  GL2 gl=myGl;
  gl.glEnable(GL2.GL_LIGHTING);
  if (savedBlend) {
    gl.glEnable(GL.GL_BLEND);
  }
  if (savedMulti) {
    gl.glEnable(GL.GL_MULTISAMPLE);
  }
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int w=myViewW;
  int h=myViewH;
  ByteBuffer pixels=ByteBuffer.allocate(4 * w * h);
  gl.glReadPixels(0,0,w,h,GL2.GL_RGBA,GL2.GL_UNSIGNED_BYTE,pixels);
  HitRecord[] hits=null;
  boolean badIdWarningIssued=false;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int colorId=r;
      colorId<<=8;
      colorId+=g;
      colorId<<=8;
      colorId+=b;
      if (colorId != 0) {
        int id=colorId - 1;
        if (id < 0 || id >= myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          if (hits == null) {
            hits=new HitRecord[myTotalMaxQ];
          }
          HitRecord rec=hits[id];
          if (rec == null) {
            rec=new HitRecord(0);
            hits[id]=rec;
          }
          rec.size++;
        }
      }
    }
  }
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,0);
  gl.glDeleteFramebuffers(1,frameBufferId,0);
  gl.glDeleteRenderbuffers(1,renderBufferId,0);
  gl.glDeleteRenderbuffers(1,depthBufferId,0);
  gl.glViewport(mySavedViewport[0],mySavedViewport[1],mySavedViewport[2],mySavedViewport[3]);
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  if (hits == null) {
    myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    int[] result=new int[1];
    Iterator<GLRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      GLRenderable r=it.next();
      if (r instanceof GLSelectable) {
        GLSelectable s=(GLSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            HitRecord rec;
            if ((rec=hits[qid + i]) != null) {
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    LinkedList<Object>[] selObjs=new LinkedList[records.size()];
    for (int i=0; i < records.size(); i++) {
      selObjs[i]=records.get(i).objs;
    }
    myViewer.selectionEvent.mySelectedObjects=selObjs;
  }
  GLSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.selectionEvent);
  }
  myViewer.getCanvas().repaint();
}","public void processSelection(GLAutoDrawable drawable){
  GL2 gl=myGl;
  gl.glEnable(GL2.GL_LIGHTING);
  if (savedBlend) {
    gl.glEnable(GL.GL_BLEND);
  }
  if (savedMulti) {
    gl.glEnable(GL.GL_MULTISAMPLE);
  }
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int w=myViewW;
  int h=myViewH;
  ByteBuffer pixels=ByteBuffer.allocateDirect(4 * w * h);
  pixels.order(ByteOrder.nativeOrder());
  fbo.getPixelsRGBA(pixels);
  fbo.deactivate();
  fbo.cleanup();
  fbo=null;
  HitRecord[] hits=null;
  boolean badIdWarningIssued=false;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int colorId=r;
      colorId<<=8;
      colorId+=g;
      colorId<<=8;
      colorId+=b;
      if (colorId != 0) {
        int id=colorId - 1;
        if (id < 0 || id >= myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          if (hits == null) {
            hits=new HitRecord[myTotalMaxQ];
          }
          HitRecord rec=hits[id];
          if (rec == null) {
            rec=new HitRecord(0);
            hits[id]=rec;
          }
          rec.size++;
        }
      }
    }
  }
  pixels.clear();
  if (myViewer.isMultiSampleEnabled()) {
    FrameBufferObject dummy=new FrameBufferObject(0,0,myViewer.getWidth(),myViewer.getHeight(),8,null,null,gl);
    dummy.setupFBO();
    dummy.activate();
    dummy.deactivate();
    dummy.cleanup();
  }
  gl.glViewport(mySavedViewport[0],mySavedViewport[1],mySavedViewport[2],mySavedViewport[3]);
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  if (hits == null) {
    myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    int[] result=new int[1];
    Iterator<GLRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      GLRenderable r=it.next();
      if (r instanceof GLSelectable) {
        GLSelectable s=(GLSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            HitRecord rec;
            if ((rec=hits[qid + i]) != null) {
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    LinkedList<Object>[] selObjs=new LinkedList[records.size()];
    for (int i=0; i < records.size(); i++) {
      selObjs[i]=records.get(i).objs;
    }
    myViewer.selectionEvent.mySelectedObjects=selObjs;
  }
  GLSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.selectionEvent);
  }
  myViewer.getCanvas().repaint();
}"
70742,"public void setupSelection(GLAutoDrawable drawable){
  GL2 gl=myViewer.getGL().getGL2();
  GLU glu=myViewer.getGLU();
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  gl.glGetIntegerv(GL2.GL_VIEWPORT,mySavedViewport,0);
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  myViewW=(int)Math.ceil(myRectW);
  myViewH=(int)Math.ceil(myRectH);
  int[] viewport=new int[]{0,0,myViewW,myViewH};
  glu.gluPickMatrix(myRectX,mySavedViewport[3] - myRectY,myRectW,myRectH,mySavedViewport,0);
  gl.glViewport(viewport[0],viewport[1],viewport[2],viewport[3]);
  Vector2d zRange=new Vector2d();
  myViewer.getZRange(zRange);
  myViewer.setViewVolume(zRange.x,zRange.y);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glDisable(GL2.GL_LIGHTING);
  gl.glColor4f(0,0,0,0);
  gl.glGenFramebuffers(1,frameBufferId,0);
  gl.glBindFramebuffer(GL2.GL_FRAMEBUFFER,frameBufferId[0]);
  gl.glGenRenderbuffers(1,renderBufferId,0);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,renderBufferId[0]);
  gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER,GL2.GL_RGBA8,myViewW,myViewH);
  gl.glFramebufferRenderbuffer(GL2.GL_FRAMEBUFFER,GL2.GL_COLOR_ATTACHMENT0,GL2.GL_RENDERBUFFER,renderBufferId[0]);
  gl.glGenRenderbuffers(1,depthBufferId,0);
  gl.glBindRenderbuffer(GL2.GL_RENDERBUFFER,depthBufferId[0]);
  gl.glRenderbufferStorage(GL2.GL_RENDERBUFFER,GL2.GL_DEPTH_COMPONENT16,myViewW,myViewH);
  gl.glFramebufferRenderbuffer(GL2.GL_FRAMEBUFFER,GL2.GL_DEPTH_ATTACHMENT,GL2.GL_RENDERBUFFER,depthBufferId[0]);
  int status=gl.glCheckFramebufferStatus(GL2.GL_FRAMEBUFFER);
  if (status != GL2.GL_FRAMEBUFFER_COMPLETE) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  savedBlend=gl.glIsEnabled(GL.GL_BLEND);
  if (savedBlend) {
    gl.glDisable(GL.GL_BLEND);
  }
  savedMulti=gl.glIsEnabled(GL.GL_MULTISAMPLE);
  if (savedMulti) {
    gl.glDisable(GL.GL_MULTISAMPLE);
  }
}","public void setupSelection(GLAutoDrawable drawable){
  GL2 gl=myViewer.getGL().getGL2();
  GLU glu=myViewer.getGLU();
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  gl.glGetIntegerv(GL2.GL_VIEWPORT,mySavedViewport,0);
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  myViewW=(int)Math.ceil(myRectW);
  myViewH=(int)Math.ceil(myRectH);
  int[] viewport=new int[]{0,0,myViewW,myViewH};
  glu.gluPickMatrix(myRectX,mySavedViewport[3] - myRectY,myRectW,myRectH,mySavedViewport,0);
  gl.glViewport(viewport[0],viewport[1],viewport[2],viewport[3]);
  Vector2d zRange=new Vector2d();
  myViewer.getZRange(zRange);
  myViewer.setViewVolume(zRange.x,zRange.y);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glDisable(GL2.GL_LIGHTING);
  gl.glColor4f(0,0,0,0);
  fbo=new FrameBufferObject(0,0,myViewW,myViewH,1,null,null,gl);
  fbo.setupFBO();
  fbo.activate();
  savedBlend=gl.glIsEnabled(GL.GL_BLEND);
  if (savedBlend) {
    gl.glDisable(GL.GL_BLEND);
  }
  savedMulti=gl.glIsEnabled(GL.GL_MULTISAMPLE);
  if (savedMulti) {
    gl.glDisable(GL.GL_MULTISAMPLE);
  }
}"
70743,"private synchronized void display(GLAutoDrawable drawable,int flags){
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  gl.glPushMatrix();
  if (selectEnabled) {
    mySelector.setupSelection(drawable);
  }
  doDisplay(drawable,flags);
  if (selectEnabled) {
    mySelector.processSelection(drawable);
    selectEnabled=false;
  }
 else {
    fireRerenderListeners();
  }
  gl.glPopMatrix();
  if (FBO != null && grab) {
    offscreenCapture(flags);
    grab=false;
  }
}","private synchronized void display(GLAutoDrawable drawable,int flags){
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  boolean ms=gl.glIsEnabled(GL.GL_MULTISAMPLE);
  if (!ms) {
    System.out.println(""String_Node_Str"");
    gl.glEnable(GL.GL_MULTISAMPLE);
    myMultiSampleEnabled=true;
  }
  gl.glPushMatrix();
  if (selectEnabled) {
    mySelector.setupSelection(drawable);
  }
  doDisplay(drawable,flags);
  if (selectEnabled) {
    mySelector.processSelection(drawable);
    selectEnabled=false;
  }
 else {
    fireRerenderListeners();
  }
  gl.glPopMatrix();
  if (FBO != null && grab) {
    offscreenCapture(flags);
    grab=false;
  }
}"
70744,"public void processSelection(GLAutoDrawable drawable){
  GL2GL3 gl=myGl;
  GLSupport.checkAndPrintGLError(gl);
  int w=myViewW;
  int h=myViewH;
  fbo.deactivate(gl);
  ByteBuffer pixels=fbo.getPixels(gl,GL.GL_RGBA);
  fbo.dispose(gl);
  fbo=null;
  myViewer.setLightingEnabled(true);
  myViewer.setBackgroundColor(savedBackgroundColor[0],savedBackgroundColor[1],savedBackgroundColor[2],savedBackgroundColor[3]);
  if (savedBlend) {
    gl.glEnable(GL.GL_BLEND);
  }
  if (savedMulti) {
    gl.glEnable(GL.GL_MULTISAMPLE);
  }
  myViewer.setViewport(gl,savedViewport[0],savedViewport[1],savedViewport[2],savedViewport[3]);
  myViewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  HitRecord[] hits=null;
  boolean badIdWarningIssued=false;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int lcolorId=a;
      lcolorId=0;
      lcolorId<<=8;
      lcolorId+=b;
      lcolorId<<=8;
      lcolorId+=g;
      lcolorId<<=8;
      lcolorId+=r;
      int colorId=(int)(lcolorId & (0xFFFFFFFF));
      if (colorId != 0) {
        int id=colorId / ID_STEP - 1 - ID_OFFSET;
        if (id < 0 || id >= myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          if (hits == null) {
            hits=new HitRecord[myTotalMaxQ];
          }
          HitRecord rec=hits[id];
          if (rec == null) {
            rec=new HitRecord(0);
            hits[id]=rec;
          }
          rec.size++;
        }
      }
    }
  }
  BufferUtilities.freeDirectBuffer(pixels);
  myViewer.selectionEvent.setSelectedObjects(null);
  if (hits == null) {
    myViewer.selectionEvent.setSelectedObjects(null);
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    Iterator<IsRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      IsRenderable r=it.next();
      if (r instanceof IsSelectable) {
        IsSelectable s=(IsSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            HitRecord rec;
            if ((rec=hits[qid + i]) != null) {
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    ArrayList<LinkedList<?>> selObjs=new ArrayList<>(records.size());
    for (int i=0; i < records.size(); i++) {
      selObjs.add(records.get(i).objs);
    }
    myViewer.selectionEvent.setSelectedObjects(selObjs);
  }
  ViewerSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.selectionEvent);
  }
  myViewer.repaint();
}","public void processSelection(GLAutoDrawable drawable){
  GL2GL3 gl=myGl;
  GLSupport.checkAndPrintGLError(gl);
  int w=myViewW;
  int h=myViewH;
  fbo.deactivate(gl);
  ByteBuffer pixels=fbo.getPixels(gl,GL.GL_RGBA);
  fbo.dispose(gl);
  fbo=null;
  myViewer.setLightingEnabled(true);
  myViewer.setBackgroundColor(savedBackgroundColor[0],savedBackgroundColor[1],savedBackgroundColor[2],savedBackgroundColor[3]);
  if (savedBlend) {
    gl.glEnable(GL.GL_BLEND);
  }
  if (savedMulti) {
    gl.glEnable(GL.GL_MULTISAMPLE);
  }
  myViewer.setColor(savedColor);
  myViewer.setViewport(gl,savedViewport[0],savedViewport[1],savedViewport[2],savedViewport[3]);
  myViewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  HitRecord[] hits=null;
  boolean badIdWarningIssued=false;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int lcolorId=a;
      lcolorId=0;
      lcolorId<<=8;
      lcolorId+=b;
      lcolorId<<=8;
      lcolorId+=g;
      lcolorId<<=8;
      lcolorId+=r;
      int colorId=(int)(lcolorId & (0xFFFFFFFF));
      if (colorId != 0) {
        int id=colorId / ID_STEP - 1 - ID_OFFSET;
        if (id < 0 || id >= myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          if (hits == null) {
            hits=new HitRecord[myTotalMaxQ];
          }
          HitRecord rec=hits[id];
          if (rec == null) {
            rec=new HitRecord(0);
            hits[id]=rec;
          }
          rec.size++;
        }
      }
    }
  }
  BufferUtilities.freeDirectBuffer(pixels);
  myViewer.selectionEvent.setSelectedObjects(null);
  if (hits == null) {
    myViewer.selectionEvent.setSelectedObjects(null);
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    Iterator<IsRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      IsRenderable r=it.next();
      if (r instanceof IsSelectable) {
        IsSelectable s=(IsSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            HitRecord rec;
            if ((rec=hits[qid + i]) != null) {
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    ArrayList<LinkedList<?>> selObjs=new ArrayList<>(records.size());
    for (int i=0; i < records.size(); i++) {
      selObjs.add(records.get(i).objs);
    }
    myViewer.selectionEvent.setSelectedObjects(selObjs);
  }
  ViewerSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.selectionEvent);
  }
  myViewer.repaint();
}"
70745,"public void setupSelection(GLAutoDrawable drawable){
  GL2GL3 gl=(GL2GL3)(drawable.getGL());
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  savedViewport=myViewer.getViewport(gl);
  myViewW=(int)Math.ceil(myRectW);
  myViewH=(int)Math.ceil(myRectH);
  myViewer.setPickMatrix((float)(myRectX),(float)(savedViewport[3] - myRectY),(float)myRectW,(float)myRectH,savedViewport);
  myViewer.setViewport(gl,0,0,myViewW,myViewH);
  myViewer.setLightingEnabled(false);
  myViewer.getBackgroundColor(savedBackgroundColor);
  myViewer.setBackgroundColor(0,0,0,0);
  savedBlend=gl.glIsEnabled(GL.GL_BLEND);
  if (savedBlend) {
    gl.glDisable(GL.GL_BLEND);
  }
  savedMulti=gl.glIsEnabled(GL.GL_MULTISAMPLE);
  if (savedMulti) {
    gl.glDisable(GL.GL_MULTISAMPLE);
  }
  myViewer.setColor(0,0,0,0);
  fbo=new FrameBufferObject(myViewW,myViewH,1);
  fbo.activate(gl);
}","public void setupSelection(GLAutoDrawable drawable){
  GL2GL3 gl=(GL2GL3)(drawable.getGL());
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  savedViewport=myViewer.getViewport(gl);
  myViewW=(int)Math.ceil(myRectW);
  myViewH=(int)Math.ceil(myRectH);
  myViewer.setPickMatrix((float)(myRectX),(float)(savedViewport[3] - myRectY),(float)myRectW,(float)myRectH,savedViewport);
  myViewer.setViewport(gl,0,0,myViewW,myViewH);
  myViewer.setLightingEnabled(false);
  myViewer.getBackgroundColor(savedBackgroundColor);
  myViewer.setBackgroundColor(0,0,0,0);
  savedBlend=gl.glIsEnabled(GL.GL_BLEND);
  if (savedBlend) {
    gl.glDisable(GL.GL_BLEND);
  }
  savedMulti=gl.glIsEnabled(GL.GL_MULTISAMPLE);
  if (savedMulti) {
    gl.glDisable(GL.GL_MULTISAMPLE);
  }
  myViewer.getFrontColor(savedColor);
  myViewer.setColor(0,0,0,0);
  fbo=new FrameBufferObject(myViewW,myViewH,1);
  fbo.activate(gl);
}"
70746,"public void restoreDefaultState(boolean strictChecking){
  if (myMappingsSet) {
    if (myColorMapProps != null) {
      setColorMap(null);
    }
    if (myNormalMapProps != null) {
      setNormalMap(null);
    }
    if (myBumpMapProps != null) {
      setBumpMap(null);
    }
    myMappingsSet=false;
  }
  if (myNonDefaultColorSettings != 0) {
    if (myBackColor != null) {
      setBackColor(null);
    }
    if ((myNonDefaultColorSettings & EMISSION_BIT) != 0) {
      setEmission(DEFAULT_MATERIAL_EMISSION);
    }
    if ((myNonDefaultColorSettings & SPECULAR_BIT) != 0) {
      setSpecular(DEFAULT_MATERIAL_SPECULAR);
    }
    if ((myNonDefaultColorSettings & SHININESS_BIT) != 0) {
      setShininess(DEFAULT_MATERIAL_SHININESS);
    }
    if (getColorInterpolation() != DEFAULT_COLOR_INTERPOLATION) {
      setColorInterpolation(DEFAULT_COLOR_INTERPOLATION);
    }
    if (myHighlightColorActive) {
      setHighlighting(false);
    }
    myNonDefaultColorSettings=0;
  }
  if (myNonDefaultGeneralSettings != 0) {
    if (myViewerState.faceMode != DEFAULT_FACE_STYLE) {
      setFaceStyle(DEFAULT_FACE_STYLE);
    }
    if ((myNonDefaultGeneralSettings & LINE_WIDTH_BIT) != 0) {
      setLineWidth(DEFAULT_LINE_WIDTH);
    }
    if ((myNonDefaultGeneralSettings & POINT_SIZE_BIT) != 0) {
      setPointSize(DEFAULT_POINT_SIZE);
    }
    if (myViewerState.shading != DEFAULT_SHADING) {
      setShading(DEFAULT_SHADING);
    }
    if (mySurfaceResolution != DEFAULT_SURFACE_RESOLUTION) {
      setSurfaceResolution(DEFAULT_SURFACE_RESOLUTION);
    }
    if (myViewerState.colorMixing != DEFAULT_COLOR_MIXING) {
      setVertexColorMixing(DEFAULT_COLOR_MIXING);
    }
    myNonDefaultGeneralSettings=0;
  }
  if (myModelMatrixSet) {
    if (modelMatrixStack.size() > 0) {
      if (strictChecking) {
        throw new IllegalStateException(""String_Node_Str"" + modelMatrixStack.size());
      }
 else {
        modelMatrixStack.clear();
      }
    }
    if (!modelMatrix.isIdentity()) {
      resetModelMatrix();
    }
    myModelMatrixSet=false;
  }
  if (myDrawMode != null) {
    if (strictChecking) {
      throw new IllegalStateException(""String_Node_Str"" + myDrawMode);
    }
 else {
      resetDraw();
    }
  }
}","public void restoreDefaultState(boolean strictChecking){
  if (myMappingsSet) {
    if (myColorMapProps != null) {
      setColorMap(null);
    }
    if (myNormalMapProps != null) {
      setNormalMap(null);
    }
    if (myBumpMapProps != null) {
      setBumpMap(null);
    }
    myMappingsSet=false;
  }
  if (myNonDefaultColorSettings != 0) {
    if (myBackColor != null) {
      setBackColor(null);
    }
    if ((myNonDefaultColorSettings & EMISSION_BIT) != 0) {
      setEmission(DEFAULT_MATERIAL_EMISSION);
    }
    if ((myNonDefaultColorSettings & SPECULAR_BIT) != 0) {
      setSpecular(DEFAULT_MATERIAL_SPECULAR);
    }
    if ((myNonDefaultColorSettings & SHININESS_BIT) != 0) {
      setShininess(DEFAULT_MATERIAL_SHININESS);
    }
    if (getColorInterpolation() != DEFAULT_COLOR_INTERPOLATION) {
      setColorInterpolation(DEFAULT_COLOR_INTERPOLATION);
    }
    if (myHighlightColorActive) {
      setHighlighting(false);
    }
    myNonDefaultColorSettings=0;
  }
  if (myNonDefaultGeneralSettings != 0) {
    if (myViewerState.faceMode != DEFAULT_FACE_STYLE) {
      setFaceStyle(DEFAULT_FACE_STYLE);
    }
    if ((myNonDefaultGeneralSettings & LINE_WIDTH_BIT) != 0) {
      setLineWidth(DEFAULT_LINE_WIDTH);
    }
    if ((myNonDefaultGeneralSettings & POINT_SIZE_BIT) != 0) {
      setPointSize(DEFAULT_POINT_SIZE);
    }
    if (myViewerState.shading != DEFAULT_SHADING) {
      setShading(DEFAULT_SHADING);
    }
    if (mySurfaceResolution != DEFAULT_SURFACE_RESOLUTION) {
      setSurfaceResolution(DEFAULT_SURFACE_RESOLUTION);
    }
    if (myViewerState.colorMixing != DEFAULT_COLOR_MIXING) {
      setVertexColorMixing(DEFAULT_COLOR_MIXING);
    }
    myNonDefaultGeneralSettings=0;
  }
  if (myModelMatrixSet) {
    if (!modelMatrix.isIdentity()) {
      resetModelMatrix();
    }
    myModelMatrixSet=false;
  }
  if (myDrawMode != null) {
    if (strictChecking) {
      throw new IllegalStateException(""String_Node_Str"" + myDrawMode);
    }
 else {
      resetDraw();
    }
  }
}"
70747,"public boolean updateFaceLines(int[] faceIdxs,int offset,int len,FeatureIndexArray features){
  int nFaces=len;
  int nFeatures=features.numFeatures();
  PolygonalMesh mesh=getMesh();
  boolean modified=false;
  if (nFeatures > 0) {
    for (int i=0; i < nFaces; ++i) {
      if (i >= nFeatures) {
        break;
      }
      if (faceIdxs[i + offset] != features.getFeature(i)) {
        features.chop(0,i);
        nFeatures=i;
        modified=true;
        break;
      }
    }
  }
  if (nFaces < nFeatures) {
    features.chop(0,nFaces);
    nFeatures=nFaces;
    modified=true;
  }
  int[] offsets=mesh.getFeatureIndexOffsets();
  for (int i=nFeatures; i < nFaces; ++i) {
    int faceIdx=faceIdxs[i + offset];
    int v0=offsets[faceIdx];
    int nv=offsets[faceIdx + 1] - offsets[faceIdx];
    features.beginFeature(faceIdx);
    for (int j=1; j < nv; ++j) {
      int v1=v0 + j;
      features.addVertex(v0);
      features.addVertex(v1);
      v0=v1;
    }
    features.addVertex(v0);
    features.addVertex(offsets[faceIdx]);
    features.endFeature();
    modified=true;
  }
  return modified;
}","public boolean updateFaceLines(int[] faceIdxs,int offset,int len,FeatureIndexArray features){
  int nFaces=len;
  int nFeatures=features.numFeatures();
  PolygonalMesh mesh=getMesh();
  boolean modified=false;
  if (nFeatures > 0) {
    for (int i=0; i < nFaces; ++i) {
      if (i >= nFeatures) {
        break;
      }
      if (faceIdxs[i + offset] != features.getFeature(i)) {
        features.chop(0,i);
        nFeatures=i;
        modified=true;
        break;
      }
    }
  }
  if (nFaces < nFeatures) {
    features.chop(0,nFaces);
    nFeatures=nFaces;
    modified=true;
  }
  int[] offsets=mesh.getFeatureIndexOffsets();
  for (int i=nFeatures; i < nFaces; ++i) {
    int faceIdx=faceIdxs[i + offset];
    int v0=offsets[faceIdx];
    int nv=offsets[faceIdx + 1] - offsets[faceIdx];
    features.beginFeature(faceIdx);
    for (int j=1; j < nv; ++j) {
      int v1=v0 + 1;
      features.addVertex(v0);
      features.addVertex(v1);
      v0=v1;
    }
    features.addVertex(v0);
    features.addVertex(offsets[faceIdx]);
    features.endFeature();
    modified=true;
  }
  return modified;
}"
70748,"@Override public void setVerticalAlignment(VerticalAlignment vAlignment){
  if (!isFullScreen) {
    setVerticalAlignment(vAlignment);
  }
 else {
    lastVAlignment=vAlignment;
  }
}","@Override public void setVerticalAlignment(VerticalAlignment vAlignment){
  if (!isFullScreen) {
    super.setVerticalAlignment(vAlignment);
  }
 else {
    lastVAlignment=vAlignment;
  }
}"
70749,"public GLPipelineRendererBase(){
  normalsEnabled=false;
  colorsEnabled=false;
  texcoordsEnabled=false;
  color=new byte[4];
  normal=new float[3];
  texcoord=new float[2];
  maxverts=0;
  mode=0;
  drawing=false;
  nverts=0;
  vbuff=null;
}","public GLPipelineRendererBase(){
  normalsEnabled=false;
  colorsEnabled=false;
  texcoordsEnabled=false;
  color=new byte[4];
  normal=new float[3];
  texcoord=new float[2];
  maxverts=0;
  mode=0;
  drawing=false;
  nverts=0;
  vbuff=null;
  loopBuff=null;
}"
70750,"@Override public void vertex(float x,float y,float z){
  if (normalsEnabled) {
    vbuff.putFloat(normal[0]);
    vbuff.putFloat(normal[1]);
    vbuff.putFloat(normal[2]);
  }
  if (colorsEnabled) {
    vbuff.putFloat(color[0]);
    vbuff.putFloat(color[1]);
    vbuff.putFloat(color[2]);
    vbuff.putFloat(color[3]);
  }
  if (texcoordsEnabled) {
    vbuff.putFloat(texcoord[0]);
    vbuff.putFloat(texcoord[1]);
  }
  vbuff.putFloat(x);
  vbuff.putFloat(y);
  vbuff.putFloat(z);
  ++nverts;
  if (vbuff.position() == vbuff.capacity()) {
    flush();
  }
}","@Override public void vertex(float x,float y,float z){
  if (normalsEnabled) {
    vbuff.putFloat(normal[0]);
    vbuff.putFloat(normal[1]);
    vbuff.putFloat(normal[2]);
  }
  if (colorsEnabled) {
    vbuff.putFloat(color[0]);
    vbuff.putFloat(color[1]);
    vbuff.putFloat(color[2]);
    vbuff.putFloat(color[3]);
  }
  if (texcoordsEnabled) {
    vbuff.putFloat(texcoord[0]);
    vbuff.putFloat(texcoord[1]);
  }
  vbuff.putFloat(x);
  vbuff.putFloat(y);
  vbuff.putFloat(z);
  if (mode == GL.GL_LINE_LOOP && loopBuff == null) {
    loopBuff=new byte[vertexStride];
    int pos=vbuff.position();
    vbuff.position(pos - vertexStride);
    vbuff.get(loopBuff,0,vertexStride);
    vbuff.position(pos);
  }
  ++nverts;
  if (vbuff.position() == vbuff.capacity()) {
    flush();
  }
}"
70751,"@Override public void flush(){
  vbuff.flip();
  draw(gl,mode,vbuff,nverts);
  vbuff.clear();
  nverts=0;
}","@Override public void flush(){
  vbuff.flip();
  int glMode=mode;
  if (mode == GL.GL_LINE_LOOP) {
    glMode=GL.GL_LINE_STRIP;
  }
  int nv=nverts;
switch (glMode) {
case GL.GL_LINE_STRIP:
case GL.GL_LINE_LOOP:
    if (nverts < 2) {
      nv=0;
    }
case GL.GL_TRIANGLE_STRIP:
case GL.GL_TRIANGLE_FAN:
  if (nverts < 3) {
    nv=0;
  }
case GL.GL_LINES:
if ((nverts % 2) == 1) {
  nv=nverts - 1;
}
case GL.GL_TRIANGLES:
{
int off=nverts % 3;
nv=nverts - off;
}
}
draw(gl,glMode,vbuff,nv);
byte[] front=null;
int nfront=0;
switch (glMode) {
case GL.GL_LINE_STRIP:
case GL.GL_LINE_LOOP:
{
if (nverts < 2) {
front=new byte[vertexStride * nverts];
vbuff.rewind();
vbuff.get(front);
nfront=nverts;
}
 else {
nfront=nverts - nv + 1;
front=new byte[vertexStride * nfront];
vbuff.position((nv - 1) * vertexStride);
vbuff.get(front);
}
break;
}
case GL.GL_TRIANGLE_STRIP:
{
if (nverts < 3) {
front=new byte[vertexStride * nverts];
vbuff.rewind();
vbuff.get(front);
nfront=nverts;
}
 else {
int nt=nv - 2;
nfront=nverts - nv + 2;
if ((nt % 2) == 1) {
++nfront;
vbuff.position((nv - 2) * vertexStride);
front=new byte[vertexStride * nfront];
vbuff.get(front,0,vertexStride);
vbuff.position((nv - 2) * vertexStride);
vbuff.get(front,vertexStride,(nfront - 1) * vertexStride);
}
 else {
vbuff.position((nv - 2) * vertexStride);
front=new byte[vertexStride * nfront];
vbuff.get(front);
}
}
break;
}
case GL.GL_TRIANGLE_FAN:
{
if (nverts < 3) {
front=new byte[vertexStride * nverts];
vbuff.rewind();
vbuff.get(front);
nfront=nverts;
}
 else {
int nrem=nverts - nv;
front=new byte[vertexStride * (2 + nrem)];
vbuff.rewind();
vbuff.get(front,0,vertexStride);
vbuff.position((nv - 1) * vertexStride);
vbuff.get(front,vertexStride,(nrem + 1) * vertexStride);
nfront=2 + nrem;
}
break;
}
case GL.GL_LINES:
{
if ((nverts % 2) == 1) {
nfront=1;
front=new byte[vertexStride];
vbuff.position(nv * vertexStride);
vbuff.get(front);
}
break;
}
case GL.GL_TRIANGLES:
{
int off=nverts - nv;
if (off > 0) {
nfront=off;
front=new byte[nfront * vertexStride];
vbuff.position(nv * vertexStride);
vbuff.get(front);
}
break;
}
}
vbuff.clear();
nverts=0;
if (nfront > 0) {
vbuff.put(front);
nverts=nfront;
}
}"
70752,"@Override public void end(){
  flush();
  mode=0;
  maxverts=0;
  gl=null;
  drawing=false;
}","@Override public void end(){
  flush();
  if (mode == GL.GL_LINE_LOOP && loopBuff != null) {
    vbuff.put(loopBuff);
    vbuff.flip();
    draw(gl,GL.GL_LINE_STRIP,vbuff,nverts + 1);
  }
  vbuff.clear();
  nverts=0;
  mode=0;
  maxverts=0;
  gl=null;
  drawing=false;
  loopBuff=null;
}"
70753,"@Override public void begin(GL gl,int glMode,int maxVertices){
  this.gl=(GL2GL3)gl;
  this.mode=glMode;
  this.maxverts=maxVertices;
  drawing=true;
  vertexStride=0;
  if (normalsEnabled) {
    normalOffset=vertexStride;
    vertexStride+=NORMAL_BYTES;
  }
 else {
    normalOffset=-1;
  }
  if (colorsEnabled) {
    colorOffset=vertexStride;
    vertexStride+=COLOR_BYTES;
  }
 else {
    colorOffset=-1;
  }
  if (texcoordsEnabled) {
    texcoordOffset=vertexStride;
    vertexStride+=TEXCOORD_BYTES;
  }
 else {
    texcoordOffset=-1;
  }
  positionOffset=vertexStride;
  vertexStride+=POSITION_BYTES;
  ensureBufferCapacity(maxVertices * vertexStride);
  bind(gl,vbuff,normalOffset,colorOffset,texcoordOffset,positionOffset,vertexStride);
}","@Override public void begin(GL gl,int glMode,int maxVertices){
  this.gl=(GL2GL3)gl;
  this.mode=glMode;
  if (maxVertices < 12) {
    maxVertices=12;
  }
switch (glMode) {
case GL.GL_POINTS:
case GL.GL_LINE_STRIP:
case GL.GL_LINE_LOOP:
case GL.GL_TRIANGLE_STRIP:
case GL.GL_TRIANGLE_FAN:
    break;
case GL.GL_LINES:
  if ((maxVertices % 2) == 1) {
    ++maxVertices;
  }
break;
case GL.GL_TRIANGLES:
{
int off=(3 - maxVertices % 3) % 3;
maxVertices+=off;
break;
}
}
this.maxverts=maxVertices;
drawing=true;
vertexStride=0;
if (normalsEnabled) {
normalOffset=vertexStride;
vertexStride+=NORMAL_BYTES;
}
 else {
normalOffset=-1;
}
if (colorsEnabled) {
colorOffset=vertexStride;
vertexStride+=COLOR_BYTES;
}
 else {
colorOffset=-1;
}
if (texcoordsEnabled) {
texcoordOffset=vertexStride;
vertexStride+=TEXCOORD_BYTES;
}
 else {
texcoordOffset=-1;
}
positionOffset=vertexStride;
vertexStride+=POSITION_BYTES;
ensureBufferCapacity(maxVertices * vertexStride);
loopBuff=null;
bind(gl,vbuff,normalOffset,colorOffset,texcoordOffset,positionOffset,vertexStride);
}"
70754,"public void setSurfaceRendering(SurfaceRender mode){
  if (mySurfaceRendering != mode) {
    if (myStressPlotRanging == Ranging.Auto) {
      myStressPlotRange.set(0,0);
    }
    SurfaceRender oldMode=mySurfaceRendering;
    if (myFem != null) {
switch (mode) {
case Strain:
        myFem.setComputeNodalStrain(true);
      myFem.updateStressAndStiffness();
    break;
case Stress:
  myFem.setComputeNodalStress(true);
myFem.updateStressAndStiffness();
break;
default :
{
myFem.setComputeNodalStrain(false);
myFem.setComputeNodalStress(false);
break;
}
}
}
MeshBase mesh=getMesh();
if (mesh != null) {
boolean oldStressOrStrain=isStressOrStrainRendering(oldMode);
boolean newStressOrStrain=isStressOrStrainRendering(mode);
if (newStressOrStrain != oldStressOrStrain) {
if (newStressOrStrain) {
saveMeshColoring(mesh);
mesh.setVertexColoringEnabled();
mySurfaceRendering=mode;
updateVertexColors();
}
 else {
mySurfaceRendering=mode;
restoreMeshColoring(mesh);
}
}
}
mySurfaceRendering=mode;
}
mySurfaceRenderingMode=PropertyUtils.propagateValue(this,""String_Node_Str"",mode,mySurfaceRenderingMode);
}","public void setSurfaceRendering(SurfaceRender mode){
  if (mySurfaceRendering != mode) {
    if (myStressPlotRanging == Ranging.Auto) {
      myStressPlotRange.set(0,0);
    }
    SurfaceRender oldMode=mySurfaceRendering;
    if (myFem != null) {
switch (mode) {
case Strain:
        myFem.setComputeNodalStrain(true);
      myFem.updateStressAndStiffness();
    break;
case Stress:
  myFem.setComputeNodalStress(true);
myFem.updateStressAndStiffness();
break;
default :
{
myFem.setComputeNodalStrain(false);
myFem.setComputeNodalStress(false);
break;
}
}
}
MeshBase mesh=getMesh();
if (mesh != null) {
boolean oldStressOrStrain=isStressOrStrainRendering(oldMode);
boolean newStressOrStrain=isStressOrStrainRendering(mode);
if (newStressOrStrain != oldStressOrStrain) {
if (newStressOrStrain) {
saveShading();
saveMeshColoring(mesh);
mesh.setVertexColoringEnabled();
mesh.setVertexColorMixing(ColorMixing.REPLACE);
myRenderProps.setShading(Shading.NONE);
mySurfaceRendering=mode;
updateVertexColors();
}
 else {
mySurfaceRendering=mode;
restoreMeshColoring(mesh);
restoreShading();
}
}
}
mySurfaceRendering=mode;
}
mySurfaceRenderingMode=PropertyUtils.propagateValue(this,""String_Node_Str"",mode,mySurfaceRenderingMode);
}"
70755,"protected void restoreMeshColoring(MeshBase mesh){
  if (mySavedColors == null) {
    mesh.clearColors();
  }
 else {
    mesh.setColors(mySavedColors,mySavedColorIndices);
    if (mySavedVertexColoring) {
      mesh.setVertexColoringEnabled();
    }
 else     if (mySavedFeatureColoring) {
      mesh.setFeatureColoringEnabled();
    }
  }
}","protected void restoreMeshColoring(MeshBase mesh){
  if (mySavedColors == null) {
    mesh.clearColors();
  }
 else {
    mesh.setColors(mySavedColors,mySavedColorIndices);
    if (mySavedVertexColoring) {
      mesh.setVertexColoringEnabled();
    }
 else     if (mySavedFeatureColoring) {
      mesh.setFeatureColoringEnabled();
    }
  }
  mesh.setVertexColorMixing(mySavedColorMixing);
}"
70756,"@Override public FemMeshBase copy(int flags,Map<ModelComponent,ModelComponent> copyMap){
  FemMeshBase fmb=(FemMeshBase)super.copy(flags,copyMap);
  if (mySurfaceRenderingMode == PropertyMode.Explicit) {
    fmb.setSurfaceRendering(mySurfaceRendering);
  }
  if (myStressPlotRangingMode == PropertyMode.Explicit) {
    fmb.setStressPlotRanging(myStressPlotRanging);
  }
  if (myStressPlotRangeMode == PropertyMode.Explicit) {
    fmb.setStressPlotRange(myStressPlotRange);
  }
  if (myColorMapMode == PropertyMode.Explicit) {
    fmb.setColorMap(myColorMap);
  }
  FemModel3d newFem=(FemModel3d)copyMap.get(myFem);
  if (newFem != null) {
    fmb.myFem=newFem;
  }
 else {
    fmb.myFem=myFem;
  }
  return fmb;
}","@Override public FemMeshBase copy(int flags,Map<ModelComponent,ModelComponent> copyMap){
  FemMeshBase fmb=(FemMeshBase)super.copy(flags,copyMap);
  if (mySurfaceRenderingMode == PropertyMode.Explicit) {
    fmb.setSurfaceRendering(mySurfaceRendering);
  }
  if (myStressPlotRangingMode == PropertyMode.Explicit) {
    fmb.setStressPlotRanging(myStressPlotRanging);
  }
  if (myStressPlotRangeMode == PropertyMode.Explicit) {
    fmb.setStressPlotRange(myStressPlotRange);
  }
  if (myColorMapMode == PropertyMode.Explicit) {
    fmb.setColorMap(myColorMap);
  }
  FemModel3d newFem=(FemModel3d)copyMap.get(myFem);
  if (newFem != null) {
    fmb.myFem=newFem;
  }
 else {
    fmb.myFem=myFem;
  }
  if (mySavedColors != null) {
    fmb.mySavedColors=new ArrayList<float[]>(mySavedColors.size());
    for (    float[] c : mySavedColors) {
      fmb.mySavedColors.add(Arrays.copyOf(c,c.length));
    }
  }
 else {
    fmb.mySavedColors=null;
  }
  if (mySavedColorIndices != null) {
    fmb.mySavedColorIndices=Arrays.copyOf(mySavedColorIndices,mySavedColorIndices.length);
  }
 else {
    fmb.mySavedColorIndices=null;
  }
  fmb.mySavedVertexColoring=mySavedVertexColoring;
  fmb.mySavedFeatureColoring=mySavedFeatureColoring;
  fmb.mySavedColorMixing=mySavedColorMixing;
  fmb.mySavedShading=mySavedShading;
  fmb.mySavedShadingMode=mySavedShadingMode;
  return fmb;
}"
70757,"@Override public void render(Renderer renderer,RenderProps props,int flags){
  if (isSelected() || (myFem != null && myFem.isSelected())) {
    flags|=Renderer.HIGHLIGHT;
  }
  PropertyMode oldShadingMode=null;
  Shading oldShading=null;
  if (isStressOrStrainRendering(mySurfaceRendering)) {
    renderer.setVertexColorMixing(ColorMixing.REPLACE);
    oldShadingMode=props.getShadingMode();
    oldShading=props.getShading();
    props.setShading(Shading.NONE);
  }
 else   if (mySurfaceRendering == SurfaceRender.None) {
    return;
  }
  if (renderer.isSelecting()) {
    renderer.beginSelectionQuery(0);
  }
  super.render(renderer,props,flags);
  if (renderer.isSelecting()) {
    renderer.endSelectionQuery();
  }
  if (oldShading != null) {
    props.setShading(oldShading);
    props.setShadingMode(oldShadingMode);
  }
}","@Override public void render(Renderer renderer,RenderProps props,int flags){
  if (isSelected() || (myFem != null && myFem.isSelected())) {
    flags|=Renderer.HIGHLIGHT;
  }
  if (mySurfaceRendering == SurfaceRender.None) {
    return;
  }
  if (renderer.isSelecting()) {
    renderer.beginSelectionQuery(0);
  }
  super.render(renderer,props,flags);
  if (renderer.isSelecting()) {
    renderer.endSelectionQuery();
  }
}"
70758,"protected void saveMeshColoring(MeshBase mesh){
  mySavedColors=mesh.getColors();
  mySavedColorIndices=mesh.getColorIndices();
  mySavedVertexColoring=mesh.getVertexColoringEnabled();
  mySavedFeatureColoring=mesh.getFeatureColoringEnabled();
}","protected void saveMeshColoring(MeshBase mesh){
  mySavedColors=mesh.getColors();
  mySavedColorIndices=mesh.getColorIndices();
  mySavedVertexColoring=mesh.getVertexColoringEnabled();
  mySavedFeatureColoring=mesh.getFeatureColoringEnabled();
  mySavedColorMixing=mesh.getVertexColorMixing();
}"
70759,"public void doDisplay(GLAutoDrawable drawable,int flags){
  GL2 gl=drawable.getGL().getGL2();
  if (resetViewVolume && resizeEnabled) {
    resetViewVolume(gl);
    resetViewVolume=false;
  }
  if (isSelecting()) {
    gl.glClearColor(0f,0f,0f,0f);
  }
 else {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
  maybeUpdateState(gl);
  setupLights(gl);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  int nclips=0;
  int clipIdx=GL2.GL_CLIP_PLANE0;
  for (  GLClipPlane cp : myClipPlanes) {
    if (cp.isClippingEnabled()) {
      cp.getPlaneValues(myClipPlaneValues);
      myClipPlaneValues[3]+=cp.getOffset();
      gl.glClipPlane(clipIdx,myClipPlaneValues,0);
      gl.glEnable(clipIdx);
      clipIdx++;
      nclips++;
      if (nclips >= maxClipPlanes) {
        break;
      }
      if (cp.isSlicingEnabled()) {
        myClipPlaneValues[0]=-myClipPlaneValues[0];
        myClipPlaneValues[1]=-myClipPlaneValues[1];
        myClipPlaneValues[2]=-myClipPlaneValues[2];
        myClipPlaneValues[3]=-myClipPlaneValues[3] + 2 * cp.getOffset();
        gl.glClipPlane(clipIdx,myClipPlaneValues,0);
        gl.glEnable(clipIdx);
        clipIdx++;
        nclips++;
        if (nclips >= maxClipPlanes) {
          break;
        }
      }
    }
  }
  int qid=0;
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
  }
  RenderList elist=myExternalRenderList;
  if (elist != null) {
synchronized (elist) {
      qid=elist.renderOpaque(this,qid,flags);
    }
  }
  if (hasTransparent3d()) {
    boolean transparencyEnabled=false;
    if (!isSelecting()) {
      enableTransparency(gl);
      transparencyEnabled=true;
    }
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderTransparent(this,qid,flags);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderTransparent(this,qid,flags);
      }
    }
    if (transparencyEnabled) {
      disableTransparency(gl);
      transparencyEnabled=false;
    }
  }
  for (int i=GL2.GL_CLIP_PLANE0; i < clipIdx; ++i) {
    gl.glDisable(i);
  }
  if (has2d()) {
    begin2DRendering(width,height);
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderOpaque2d(this,qid,0);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderOpaque2d(this,qid,0);
      }
    }
    if (hasTransparent2d()) {
      boolean transparencyEnabled=false;
      if (!isSelecting()) {
        enableTransparency(gl);
        transparencyEnabled=true;
      }
synchronized (myInternalRenderList) {
        qid=myInternalRenderList.renderTransparent2d(this,qid,0);
      }
      if (elist != null) {
synchronized (elist) {
          qid=elist.renderTransparent2d(this,qid,0);
        }
      }
      if (transparencyEnabled) {
        disableTransparency(gl);
        transparencyEnabled=false;
      }
    }
    end2DRendering();
  }
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(gl);
    }
  }
  gl.glFlush();
}","public void doDisplay(GLAutoDrawable drawable,int flags){
  GL2 gl=drawable.getGL().getGL2();
  if (resetViewVolume && resizeEnabled) {
    resetViewVolume(gl);
    resetViewVolume=false;
  }
  if (isSelecting()) {
    gl.glClearColor(0f,0f,0f,0f);
  }
 else {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
  maybeUpdateState(gl);
  setupLights(gl);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  int nclips=0;
  int clipIdx=GL2.GL_CLIP_PLANE0;
  for (  GLClipPlane cp : myClipPlanes) {
    if (cp.isClippingEnabled()) {
      cp.getPlaneValues(myClipPlaneValues);
      myClipPlaneValues[3]+=cp.getOffset();
      gl.glClipPlane(clipIdx,myClipPlaneValues,0);
      gl.glEnable(clipIdx);
      clipIdx++;
      nclips++;
      if (nclips >= maxClipPlanes) {
        break;
      }
      if (cp.isSlicingEnabled()) {
        myClipPlaneValues[0]=-myClipPlaneValues[0];
        myClipPlaneValues[1]=-myClipPlaneValues[1];
        myClipPlaneValues[2]=-myClipPlaneValues[2];
        myClipPlaneValues[3]=-myClipPlaneValues[3] + 2 * cp.getOffset();
        gl.glClipPlane(clipIdx,myClipPlaneValues,0);
        gl.glEnable(clipIdx);
        clipIdx++;
        nclips++;
        if (nclips >= maxClipPlanes) {
          break;
        }
      }
    }
  }
  if (!isSelecting()) {
    setFrontColor(DEFAULT_MATERIAL_COLOR);
  }
  int qid=0;
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
  }
  RenderList elist=myExternalRenderList;
  if (elist != null) {
synchronized (elist) {
      qid=elist.renderOpaque(this,qid,flags);
    }
  }
  if (hasTransparent3d()) {
    boolean transparencyEnabled=false;
    if (!isSelecting()) {
      enableTransparency(gl);
      transparencyEnabled=true;
    }
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderTransparent(this,qid,flags);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderTransparent(this,qid,flags);
      }
    }
    if (transparencyEnabled) {
      disableTransparency(gl);
      transparencyEnabled=false;
    }
  }
  for (int i=GL2.GL_CLIP_PLANE0; i < clipIdx; ++i) {
    gl.glDisable(i);
  }
  if (has2d()) {
    begin2DRendering(width,height);
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderOpaque2d(this,qid,0);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderOpaque2d(this,qid,0);
      }
    }
    if (hasTransparent2d()) {
      boolean transparencyEnabled=false;
      if (!isSelecting()) {
        enableTransparency(gl);
        transparencyEnabled=true;
      }
synchronized (myInternalRenderList) {
        qid=myInternalRenderList.renderTransparent2d(this,qid,0);
      }
      if (elist != null) {
synchronized (elist) {
          qid=elist.renderTransparent2d(this,qid,0);
        }
      }
      if (transparencyEnabled) {
        disableTransparency(gl);
        transparencyEnabled=false;
      }
    }
    end2DRendering();
  }
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(gl);
    }
  }
  gl.glFlush();
}"
70760,"private void doDisplay(GLAutoDrawable drawable,int flags){
  GLSupport.checkAndPrintGLError(drawable.getGL());
  int nclips=Math.min(2 * myClipPlanes.size(),maxClipPlanes);
  myProgramInfo.setNumClipPlanes(nclips);
  myProgManager.reconfigure(gl,lightManager.numLights(),nclips);
  myProgManager.setLights(gl,lightManager.getLights(),1.0f / lightManager.getMaxIntensity(),viewMatrix);
  maybeUpdateState(gl);
  if (!isSelecting()) {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  for (int i=0; i < myProgManager.numClipPlanes(); ++i) {
    boolean enabled=gl.glIsEnabled(GL3.GL_CLIP_DISTANCE0 + i);
    if (enabled) {
      System.out.println(""String_Node_Str"");
    }
  }
  int iclips=0;
  if (nclips > 0) {
    iclips=myProgManager.setClipPlanes(gl,myClipPlanes);
    for (int i=0; i < iclips; ++i) {
      gl.glEnable(GL3.GL_CLIP_DISTANCE0 + i);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  int qid=0;
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
  }
  RenderList elist=myExternalRenderList;
  if (elist != null) {
synchronized (elist) {
      qid=elist.renderOpaque(this,qid,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  if (hasTransparent3d()) {
    if (!isSelecting()) {
      enableTransparency(gl);
    }
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderTransparent(this,qid,flags);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderTransparent(this,qid,flags);
      }
    }
    if (!isSelecting()) {
      disableTransparency(gl);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  for (int i=0; i < nclips; ++i) {
    gl.glDisable(GL3.GL_CLIP_DISTANCE0 + i);
  }
  GLSupport.checkAndPrintGLError(gl);
  if (has2d()) {
    begin2DRendering(width,height);
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderOpaque2d(this,qid,0);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderOpaque2d(this,qid,0);
      }
    }
    if (hasTransparent2d()) {
      if (!isSelecting()) {
        enableTransparency(gl);
      }
synchronized (myInternalRenderList) {
        qid=myInternalRenderList.renderTransparent2d(this,qid,0);
      }
      if (elist != null) {
synchronized (elist) {
          qid=elist.renderTransparent2d(this,qid,0);
        }
      }
      if (!isSelecting()) {
        disableTransparency(gl);
      }
    }
    end2DRendering();
  }
  GLSupport.checkAndPrintGLError(gl);
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(gl);
    }
  }
 else {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  GLSupport.checkAndPrintGLError(gl);
  gl.glFlush();
  GLSupport.checkAndPrintGLError(gl);
}","private void doDisplay(GLAutoDrawable drawable,int flags){
  GLSupport.checkAndPrintGLError(drawable.getGL());
  int nclips=Math.min(2 * myClipPlanes.size(),maxClipPlanes);
  myProgramInfo.setNumClipPlanes(nclips);
  myProgManager.reconfigure(gl,lightManager.numLights(),nclips);
  myProgManager.setLights(gl,lightManager.getLights(),1.0f / lightManager.getMaxIntensity(),viewMatrix);
  maybeUpdateState(gl);
  if (!isSelecting()) {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  gl.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  for (int i=0; i < myProgManager.numClipPlanes(); ++i) {
    boolean enabled=gl.glIsEnabled(GL3.GL_CLIP_DISTANCE0 + i);
    if (enabled) {
      System.out.println(""String_Node_Str"");
    }
  }
  int iclips=0;
  if (nclips > 0) {
    iclips=myProgManager.setClipPlanes(gl,myClipPlanes);
    for (int i=0; i < iclips; ++i) {
      gl.glEnable(GL3.GL_CLIP_DISTANCE0 + i);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  if (!isSelecting()) {
    setFrontColor(DEFAULT_MATERIAL_COLOR);
  }
  int qid=0;
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
  }
  RenderList elist=myExternalRenderList;
  if (elist != null) {
synchronized (elist) {
      qid=elist.renderOpaque(this,qid,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  if (hasTransparent3d()) {
    if (!isSelecting()) {
      enableTransparency(gl);
    }
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderTransparent(this,qid,flags);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderTransparent(this,qid,flags);
      }
    }
    if (!isSelecting()) {
      disableTransparency(gl);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  for (int i=0; i < nclips; ++i) {
    gl.glDisable(GL3.GL_CLIP_DISTANCE0 + i);
  }
  GLSupport.checkAndPrintGLError(gl);
  if (has2d()) {
    begin2DRendering(width,height);
synchronized (myInternalRenderList) {
      qid=myInternalRenderList.renderOpaque2d(this,qid,0);
    }
    if (elist != null) {
synchronized (elist) {
        qid=elist.renderOpaque2d(this,qid,0);
      }
    }
    if (hasTransparent2d()) {
      if (!isSelecting()) {
        enableTransparency(gl);
      }
synchronized (myInternalRenderList) {
        qid=myInternalRenderList.renderTransparent2d(this,qid,0);
      }
      if (elist != null) {
synchronized (elist) {
          qid=elist.renderTransparent2d(this,qid,0);
        }
      }
      if (!isSelecting()) {
        disableTransparency(gl);
      }
    }
    end2DRendering();
  }
  GLSupport.checkAndPrintGLError(gl);
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(gl);
    }
  }
 else {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  GLSupport.checkAndPrintGLError(gl);
  gl.glFlush();
  GLSupport.checkAndPrintGLError(gl);
}"
70761,"public void restoreDefaultState(boolean strictChecking){
  if (myMappingsSet) {
    if (myColorMapProps != null) {
      setColorMap(null);
    }
    if (myNormalMapProps != null) {
      setNormalMap(null);
    }
    if (myBumpMapProps != null) {
      setBumpMap(null);
    }
    myMappingsSet=false;
  }
  if (myNonDefaultColorSettings != 0) {
    if (myBackColor != null) {
      setBackColor(null);
    }
    if ((myNonDefaultColorSettings & EMISSION_BIT) != 0) {
      setEmission(DEFAULT_MATERIAL_EMISSION);
    }
    if ((myNonDefaultColorSettings & SPECULAR_BIT) != 0) {
      setSpecular(DEFAULT_MATERIAL_SPECULAR);
    }
    if ((myNonDefaultColorSettings & SHININESS_BIT) != 0) {
      setShininess(DEFAULT_MATERIAL_SHININESS);
    }
    if (getColorInterpolation() != DEFAULT_COLOR_INTERPOLATION) {
      setColorInterpolation(DEFAULT_COLOR_INTERPOLATION);
    }
    if (myHighlightColorActive) {
      setHighlighting(false);
    }
    myNonDefaultColorSettings=0;
  }
  if (myNonDefaultGeneralSettings != 0) {
    if (myViewerState.faceMode != DEFAULT_FACE_STYLE) {
      setFaceStyle(DEFAULT_FACE_STYLE);
    }
    if ((myNonDefaultGeneralSettings & LINE_WIDTH_BIT) != 0) {
      setLineWidth(DEFAULT_LINE_WIDTH);
    }
    if ((myNonDefaultGeneralSettings & POINT_SIZE_BIT) != 0) {
      setPointSize(DEFAULT_POINT_SIZE);
    }
    if (myViewerState.shading != DEFAULT_SHADING) {
      setShading(DEFAULT_SHADING);
    }
    if (mySurfaceResolution != DEFAULT_SURFACE_RESOLUTION) {
      setSurfaceResolution(DEFAULT_SURFACE_RESOLUTION);
    }
    if (myViewerState.colorMixing != DEFAULT_COLOR_MIXING) {
      setVertexColorMixing(DEFAULT_COLOR_MIXING);
    }
    myNonDefaultGeneralSettings=0;
  }
  if (myModelMatrixSet) {
    if (!modelMatrix.isIdentity()) {
      resetModelMatrix();
    }
    myModelMatrixSet=false;
  }
  if (myDrawMode != null) {
    if (strictChecking) {
      throw new IllegalStateException(""String_Node_Str"" + myDrawMode);
    }
 else {
      resetDraw();
    }
  }
}","public void restoreDefaultState(boolean strictChecking){
  if (myMappingsSet) {
    if (myColorMapProps != null) {
      setColorMap(null);
    }
    if (myNormalMapProps != null) {
      setNormalMap(null);
    }
    if (myBumpMapProps != null) {
      setBumpMap(null);
    }
    myMappingsSet=false;
  }
  if (myNonDefaultColorSettings != 0) {
    if (myBackColor != null) {
      setBackColor(null);
    }
    if ((myNonDefaultColorSettings & EMISSION_BIT) != 0) {
      setEmission(DEFAULT_MATERIAL_EMISSION);
    }
    if ((myNonDefaultColorSettings & SPECULAR_BIT) != 0) {
      setSpecular(DEFAULT_MATERIAL_SPECULAR);
    }
    if ((myNonDefaultColorSettings & SHININESS_BIT) != 0) {
      setShininess(DEFAULT_MATERIAL_SHININESS);
    }
    if (getColorInterpolation() != DEFAULT_COLOR_INTERPOLATION) {
      setColorInterpolation(DEFAULT_COLOR_INTERPOLATION);
    }
    if (myHighlightColorActive) {
      setHighlighting(false);
    }
    myNonDefaultColorSettings=0;
  }
  if (myNonDefaultGeneralSettings != 0) {
    if (myViewerState.faceMode != DEFAULT_FACE_STYLE) {
      setFaceStyle(DEFAULT_FACE_STYLE);
    }
    if ((myNonDefaultGeneralSettings & LINE_WIDTH_BIT) != 0) {
      setLineWidth(DEFAULT_LINE_WIDTH);
    }
    if ((myNonDefaultGeneralSettings & POINT_SIZE_BIT) != 0) {
      setPointSize(DEFAULT_POINT_SIZE);
    }
    if (myViewerState.shading != DEFAULT_SHADING) {
      setShading(DEFAULT_SHADING);
    }
    if (mySurfaceResolution != DEFAULT_SURFACE_RESOLUTION) {
      setSurfaceResolution(DEFAULT_SURFACE_RESOLUTION);
    }
    if (myViewerState.colorMixing != DEFAULT_COLOR_MIXING) {
      setVertexColorMixing(DEFAULT_COLOR_MIXING);
    }
    myNonDefaultGeneralSettings=0;
  }
  if (myModelMatrixSet) {
    int mmsize=modelMatrixStack.size();
    if (rendering2d) {
      mmsize-=1;
    }
    if (mmsize > 0) {
      if (strictChecking) {
        throw new IllegalStateException(""String_Node_Str"" + mmsize);
      }
 else {
        while (mmsize > 0) {
          modelMatrixStack.pop();
          mmsize--;
        }
      }
    }
    if (rendering2d) {
synchronized (modelMatrix) {
        if (!modelMatrix.equals(myDefaultModelMatrix2d)) {
          modelMatrix.set(myDefaultModelMatrix2d);
          invalidateModelMatrix();
        }
      }
    }
 else {
synchronized (modelMatrix) {
        if (!modelMatrix.isIdentity()) {
          modelMatrix=new RigidTransform3d();
          modelNormalMatrix=new Matrix3d();
          invalidateModelMatrix();
        }
      }
    }
    myModelMatrixSet=false;
  }
  if (myDrawMode != null) {
    if (strictChecking) {
      throw new IllegalStateException(""String_Node_Str"" + myDrawMode);
    }
 else {
      resetDraw();
    }
  }
}"
70762,"private int renderList(Renderer renderer,SortedRenderableList list,int qid,int flags){
  boolean selecting=renderer.isSelecting();
  for (int i=0; i < list.size(); i++) {
    try {
      IsRenderable r=list.get(i);
      if (selecting && r instanceof IsSelectable) {
        IsSelectable s=(IsSelectable)r;
        try {
          int numq=s.numSelectionQueriesNeeded();
          if (renderer.isSelectable(s)) {
            if (numq >= 0) {
              renderer.beginSubSelection(s,qid);
            }
 else {
              renderer.beginSelectionQuery(qid);
            }
            r.render(renderer,flags);
            if (numq >= 0) {
              renderer.endSubSelection();
            }
 else {
              renderer.endSelectionQuery();
            }
          }
          qid+=(numq >= 0 ? numq : 1);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
 else       if (selecting) {
      }
 else {
        r.render(renderer,flags);
      }
      renderer.restoreDefaultState(true);
    }
 catch (    Exception e) {
      renderer.restoreDefaultState(false);
      e.printStackTrace();
    }
  }
  return qid;
}","private int renderList(Renderer renderer,SortedRenderableList list,int qid,int flags){
  boolean selecting=renderer.isSelecting();
  for (int i=0; i < list.size(); i++) {
    try {
      IsRenderable r=list.get(i);
      if (selecting && r instanceof IsSelectable) {
        IsSelectable s=(IsSelectable)r;
        try {
          int numq=s.numSelectionQueriesNeeded();
          if (renderer.isSelectable(s)) {
            if (numq >= 0) {
              renderer.beginSubSelection(s,qid);
            }
 else {
              renderer.beginSelectionQuery(qid);
            }
            r.render(renderer,flags);
            if (numq >= 0) {
              renderer.endSubSelection();
            }
 else {
              renderer.endSelectionQuery();
            }
          }
          qid+=(numq >= 0 ? numq : 1);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
 else       if (selecting) {
      }
 else {
        r.render(renderer,flags);
      }
      renderer.restoreDefaultState(true);
    }
 catch (    Exception e) {
      renderer.restoreDefaultState(false);
      throw e;
    }
  }
  return qid;
}"
70763,"/** 
 * Creates an AffineTransform2d and initializes its components to the specified values.
 * @param A value for the A matrix
 * @param p value for the p vector
 */
public AffineTransform2d(Vector2d p,Matrix2d A){
  this.A=new Matrix2d(A);
  this.p=new Vector2d(p);
  M=A;
  b=p;
}","/** 
 * Creates an AffineTransform2d and initializes it to the provided
 * @param A value for the A matrix
 * @param p value for the p vector
 */
public AffineTransform2d(AffineTransform2dBase T){
  this.A=new Matrix2d(T.getMatrix());
  this.p=new Vector2d(T.getOffset());
  M=this.A;
  b=this.p;
}"
70764,"public Object clone(){
  try {
    return super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalErrorException(""String_Node_Str"" + getClass());
  }
}",public abstract Matrix2dBase clone();
70765,"protected void addTextureCoords(RenderObject r,MeshBase mesh){
  if (mesh.hasTextureCoords()) {
    ArrayList<Vector3d> coords=mesh.getTextureCoords();
    for (int i=0; i < coords.size(); i++) {
      Vector3d coord=coords.get(i);
      r.addTextureCoord((float)coord.x,(float)(1 - coord.y));
    }
  }
}","protected void addTextureCoords(RenderObject r,MeshBase mesh){
  if (mesh.hasTextureCoords()) {
    ArrayList<Vector3d> coords=mesh.getTextureCoords();
    for (int i=0; i < coords.size(); i++) {
      Vector3d coord=coords.get(i);
      r.addTextureCoord((float)coord.x,(float)coord.y);
    }
  }
}"
70766,"protected void drawDragBox(GL2 gl){
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  boolean savedLighting=isLightingOn();
  gl.glDisable(GL2.GL_LIGHTING);
  gl.glColor3f(0.5f,0.5f,0.5f);
  double x0=2 * myDragBox.x / (double)width - 1;
  double x1=x0 + 2 * myDragBox.width / (double)width;
  double y0=1 - 2 * myDragBox.y / (double)height;
  double y1=y0 - 2 * myDragBox.height / (double)height;
  gl.glBegin(GL2.GL_LINE_LOOP);
  gl.glVertex3d(x0,y0,0);
  gl.glVertex3d(x1,y0,0);
  gl.glVertex3d(x1,y1,0);
  gl.glVertex3d(x0,y1,0);
  gl.glEnd();
  if (savedLighting) {
    gl.glEnable(GL2.GL_LIGHTING);
  }
  gl.glPopMatrix();
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glPopMatrix();
  gl.glMatrixMode(GL2.GL_MODELVIEW);
}","protected void drawDragBox(GL2 gl){
  setColor(0.5f,0.5f,0.5f,1.0f);
  begin2DRendering(-1,1,-1,1);
  double x0=2 * myDragBox.x / (double)width - 1;
  double x1=x0 + 2 * myDragBox.width / (double)width;
  double y0=1 - 2 * myDragBox.y / (double)height;
  double y1=y0 - 2 * myDragBox.height / (double)height;
  maybeUpdateState(gl);
  gl.glBegin(GL2.GL_LINE_LOOP);
  gl.glVertex3d(x0,y0,0);
  gl.glVertex3d(x1,y0,0);
  gl.glVertex3d(x1,y1,0);
  gl.glVertex3d(x0,y1,0);
  gl.glEnd();
  end2DRendering();
}"
70767,"public boolean popViewMatrix(){
  if (viewMatrixStack.size() == 0) {
    return false;
  }
  viewMatrix=viewMatrixStack.pop();
  myViewState=viewStateStack.pop();
  if (Math.abs(viewMatrix.getOffset().norm()) < 1e-5) {
    System.err.println(""String_Node_Str"");
    Thread.dumpStack();
  }
  invalidateViewMatrix();
  return true;
}","public boolean popViewMatrix(){
  if (viewMatrixStack.size() == 0) {
    return false;
  }
  viewMatrix=viewMatrixStack.pop();
  myViewState=viewStateStack.pop();
  if (Math.abs(viewMatrix.getOffset().norm()) < 1e-5) {
  }
  invalidateViewMatrix();
  return true;
}"
70768,"public void setViewMatrix(RigidTransform3d v){
synchronized (viewMatrix) {
    viewMatrix.set(v);
  }
  if (Math.abs(viewMatrix.getOffset().norm()) < 1e-5) {
    System.err.println(""String_Node_Str"");
    Thread.dumpStack();
  }
  invalidateViewMatrix();
}","public void setViewMatrix(RigidTransform3d v){
synchronized (viewMatrix) {
    viewMatrix.set(v);
  }
  if (Math.abs(viewMatrix.getOffset().norm()) < 1e-5) {
  }
  invalidateViewMatrix();
}"
70769,"/** 
 * {@inheritDoc}
 */
public void setModelMatrix2d(double left,double right,double bottom,double top){
  AffineTransform3d XMW=new AffineTransform3d();
  double w=right - left;
  double h=top - bottom;
  XMW.A.m00=2 / w;
  XMW.A.m11=2 / h;
  XMW.p.set(-(left + right) / w,-(top - bottom) / h,0);
  setModelMatrix(XMW);
}","/** 
 * {@inheritDoc}
 */
public void setModelMatrix2d(double left,double right,double bottom,double top){
  AffineTransform3d XMW=new AffineTransform3d();
  double w=right - left;
  double h=top - bottom;
  XMW.A.m00=2 / w;
  XMW.A.m11=2 / h;
  XMW.p.set(-(left + right) / w,-(top + bottom) / h,0);
  setModelMatrix(XMW);
}"
70770,"/** 
 * Sets the eyeToWorld transform for this viewer, using the canonical parameters used by the GL <code>lookat</code> method.
 * @param eye position of the eye, in world coordinates
 * @param center point that the eye is looking at, in world coordinates
 * @param up up direction, in world coordinates
 */
public void setEyeToWorld(Point3d eye,Point3d center,Vector3d up){
  Vector3d zaxis=new Vector3d();
  Vector3d yaxis=new Vector3d();
  Vector3d xaxis=new Vector3d();
  zaxis.sub(eye,center);
  double n=zaxis.norm();
  if (n > 1e-12) {
    zaxis.scale(1.0 / n);
  }
 else {
    RotationMatrix3d R=new RotationMatrix3d();
    R.rotateZDirection(up);
    R.getColumn(0,zaxis);
    R.getColumn(1,xaxis);
    R.getColumn(2,yaxis);
  }
  xaxis.cross(up,zaxis);
  n=xaxis.norm();
  if (n > 1e-6) {
    xaxis.scale(1.0 / n);
    yaxis.cross(zaxis,xaxis);
    yaxis.normalize();
  }
 else {
    RotationMatrix3d R=new RotationMatrix3d();
    R.rotateZDirection(zaxis);
    R.getColumn(1,yaxis);
    R.getColumn(0,xaxis);
  }
synchronized (viewMatrix) {
    viewMatrix.set(new double[]{xaxis.x,xaxis.y,xaxis.z,-xaxis.dot(eye),yaxis.x,yaxis.y,yaxis.z,-yaxis.dot(eye),zaxis.x,zaxis.y,zaxis.z,-zaxis.dot(eye)});
  }
  if (Math.abs(viewMatrix.getOffset().norm()) < 1e-5) {
    System.err.println(""String_Node_Str"");
    Thread.dumpStack();
  }
  invalidateViewMatrix();
}","/** 
 * Sets the eyeToWorld transform for this viewer, using the canonical parameters used by the GL <code>lookat</code> method.
 * @param eye position of the eye, in world coordinates
 * @param center point that the eye is looking at, in world coordinates
 * @param up up direction, in world coordinates
 */
public void setEyeToWorld(Point3d eye,Point3d center,Vector3d up){
  Vector3d zaxis=new Vector3d();
  Vector3d yaxis=new Vector3d();
  Vector3d xaxis=new Vector3d();
  zaxis.sub(eye,center);
  double n=zaxis.norm();
  if (n > 1e-12) {
    zaxis.scale(1.0 / n);
  }
 else {
    RotationMatrix3d R=new RotationMatrix3d();
    R.rotateZDirection(up);
    R.getColumn(0,zaxis);
    R.getColumn(1,xaxis);
    R.getColumn(2,yaxis);
  }
  xaxis.cross(up,zaxis);
  n=xaxis.norm();
  if (n > 1e-6) {
    xaxis.scale(1.0 / n);
    yaxis.cross(zaxis,xaxis);
    yaxis.normalize();
  }
 else {
    RotationMatrix3d R=new RotationMatrix3d();
    R.rotateZDirection(zaxis);
    R.getColumn(1,yaxis);
    R.getColumn(0,xaxis);
  }
synchronized (viewMatrix) {
    viewMatrix.set(new double[]{xaxis.x,xaxis.y,xaxis.z,-xaxis.dot(eye),yaxis.x,yaxis.y,yaxis.z,-yaxis.dot(eye),zaxis.x,zaxis.y,zaxis.z,-zaxis.dot(eye)});
  }
  if (Math.abs(viewMatrix.getOffset().norm()) < 1e-5) {
  }
  invalidateViewMatrix();
}"
70771,"@Override protected void addContent(MultiViewer mv){
  final HashMap<String,Font> fontMap=new HashMap<>();
  for (  Font font : GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts()) {
    fontMap.put(font.getName(),font);
  }
  mv.addRenderable(new SimpleSelectable(){
    JFrame debugframe=null;
    @Override public void updateBounds(    Point3d pmin,    Point3d pmax){
      Point3d p1=new Point3d(-3,-3,-3);
      Point3d p2=new Point3d(3,3,3);
      p1.updateBounds(pmin,pmax);
      p2.updateBounds(pmin,pmax);
    }
    @Override public void render(    Renderer renderer,    int flags){
      if (debugframe == null) {
        TextImageStore store=((GLViewer)renderer).getTextRenderer().getImageStore();
        debugframe=TextImageStore.createDisplayFrame(store);
        debugframe.setVisible(true);
      }
      renderer.setShading(Shading.FLAT);
      renderer.setColor(Color.WHITE);
      renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
      renderer.drawSphere(Point3d.ZERO,0.01);
      Font font=new Font(Font.SANS_SERIF,0,54);
      renderer.drawText(font,""String_Node_Str"",new float[]{0.4f,0.3f,0.3f},0.25);
      renderer.setColor(Color.ORANGE);
      String text=""String_Node_Str"";
      renderer.drawText(font,text,new float[]{-2f,0f,0f},0.25);
      Font comic=fontMap.get(""String_Node_Str"");
      if (comic == null) {
        comic=new Font(Font.MONOSPACED,Font.BOLD,32);
      }
 else {
        comic=comic.deriveFont(Font.BOLD,32);
      }
      renderer.setColor(Color.CYAN);
      text=""String_Node_Str"";
      Rectangle2D rect=renderer.getTextBounds(comic,text,0.25);
      renderer.drawText(comic,text,new float[]{-(float)(rect.getWidth()),0.5f,0f},0.25);
      renderer.setColor(Color.MAGENTA);
      text=""String_Node_Str"";
      font=new Font(Font.SERIF,Font.PLAIN,64);
      rect=renderer.getTextBounds(font,text,0.3);
      renderer.pushModelMatrix();
      RigidTransform3d trans=new RigidTransform3d(new Vector3d(0,-0.4,0),new AxisAngle(0,1,0,Math.toRadians(30)));
      renderer.mulModelMatrix(trans);
      renderer.setFaceStyle(FaceStyle.FRONT);
      renderer.drawText(font,text,Point3d.ZERO,0.3);
      trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0,1,0,Math.PI));
      renderer.mulModelMatrix(trans);
      renderer.drawText(font,text,new Point3d(-rect.getWidth(),0,0),0.3);
      trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0.1,1,0,Math.PI * 1));
      renderer.mulModelMatrix(trans);
      renderer.setShading(Shading.NONE);
      renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
      renderer.setColor(Color.GREEN);
      text=""String_Node_Str"";
      drawMultiline(renderer,font,text,new float[]{-1.75f,-0.2f,-0.5f},0.1,2);
      renderer.popModelMatrix();
    }
    public void drawMultiline(    Renderer renderer,    Font font,    String text,    float[] loc,    double size,    double linelength){
      float left=loc[0];
      float[] nloc={loc[0],loc[1],loc[2]};
      Rectangle2D rect=renderer.getTextBounds(font,text,size);
      float lineheight=(float)(rect.getHeight());
      String[] words=text.split(""String_Node_Str"");
      int w=0;
      while (w < words.length) {
        String word=words[w];
        nloc[0]+=renderer.drawText(font,word,nloc,size);
        ++w;
        while (w < words.length && nloc[0] < left + linelength) {
          word=""String_Node_Str"" + words[w];
          rect=renderer.getTextBounds(font,word,size);
          double ll=nloc[0] + rect.getWidth();
          if (ll < left + linelength) {
            renderer.drawText(font,word,nloc,size);
            ++w;
          }
          nloc[0]=(float)ll;
        }
        nloc[0]=left;
        nloc[1]-=lineheight;
      }
    }
    @Override public void prerender(    RenderList list){
    }
    @Override public int getRenderHints(){
      return 0;
    }
    @Override public int numSelectionQueriesNeeded(){
      return 0;
    }
    @Override public boolean isSelectable(){
      return false;
    }
    @Override public void getSelection(    LinkedList<Object> list,    int qid){
    }
    @Override public void setSelected(    boolean set){
    }
    @Override public boolean isSelected(){
      return false;
    }
  }
);
  mv.setAxialView(AxisAlignedRotation.X_Y);
}","@Override protected void addContent(MultiViewer mv){
  final HashMap<String,Font> fontMap=new HashMap<>();
  for (  Font font : GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts()) {
    fontMap.put(font.getName(),font);
  }
  mv.addRenderable(new SimpleSelectable(){
    JFrame debugframe=null;
    @Override public void updateBounds(    Point3d pmin,    Point3d pmax){
      Point3d p1=new Point3d(-3,-3,-3);
      Point3d p2=new Point3d(3,3,3);
      p1.updateBounds(pmin,pmax);
      p2.updateBounds(pmin,pmax);
    }
    @Override public void render(    Renderer renderer,    int flags){
      if (debugframe == null) {
        TextImageStore store=((GLViewer)renderer).getTextRenderer().getImageStore();
        debugframe=TextImageStore.createDisplayFrame(store);
        debugframe.setVisible(true);
      }
      renderer.setShading(Shading.FLAT);
      renderer.setColor(Color.WHITE);
      renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
      Font font=new Font(Font.SANS_SERIF,0,54);
      renderer.drawText(font,""String_Node_Str"",new float[]{0.4f,0.3f,0.3f},0.25);
      renderer.setColor(Color.ORANGE);
      String text=""String_Node_Str"";
      renderer.drawText(font,text,new float[]{-2f,0f,0f},0.25);
      Font comic=fontMap.get(""String_Node_Str"");
      if (comic == null) {
        comic=new Font(Font.MONOSPACED,Font.BOLD,32);
      }
 else {
        comic=comic.deriveFont(Font.BOLD,32);
      }
      renderer.setColor(Color.CYAN);
      text=""String_Node_Str"";
      Rectangle2D rect=renderer.getTextBounds(comic,text,0.25);
      renderer.drawText(comic,text,new float[]{-(float)(rect.getWidth()),0.5f,0f},0.25);
      renderer.setColor(Color.MAGENTA);
      text=""String_Node_Str"";
      font=new Font(Font.SERIF,Font.PLAIN,64);
      rect=renderer.getTextBounds(font,text,0.3);
      renderer.pushModelMatrix();
      RigidTransform3d trans=new RigidTransform3d(new Vector3d(0,-0.4,0),new AxisAngle(0,1,0,Math.toRadians(30)));
      renderer.mulModelMatrix(trans);
      renderer.setFaceStyle(FaceStyle.FRONT);
      renderer.drawText(font,text,Point3d.ZERO,0.3);
      trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0,1,0,Math.PI));
      renderer.mulModelMatrix(trans);
      renderer.drawText(font,text,new Point3d(-rect.getWidth(),0,0),0.3);
      trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0.1,1,0,Math.PI * 1));
      renderer.mulModelMatrix(trans);
      renderer.setShading(Shading.NONE);
      renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
      renderer.setColor(Color.GREEN);
      text=""String_Node_Str"";
      drawMultiline(renderer,font,text,new float[]{-1.75f,-0.2f,-0.5f},0.1,2);
      renderer.popModelMatrix();
    }
    public void drawMultiline(    Renderer renderer,    Font font,    String text,    float[] loc,    double size,    double linelength){
      float left=loc[0];
      float[] nloc={loc[0],loc[1],loc[2]};
      Rectangle2D rect=renderer.getTextBounds(font,text,size);
      float lineheight=(float)(rect.getHeight());
      String[] words=text.split(""String_Node_Str"");
      int w=0;
      while (w < words.length) {
        String word=words[w];
        nloc[0]+=renderer.drawText(font,word,nloc,size);
        ++w;
        while (w < words.length && nloc[0] < left + linelength) {
          word=""String_Node_Str"" + words[w];
          rect=renderer.getTextBounds(font,word,size);
          double ll=nloc[0] + rect.getWidth();
          if (ll < left + linelength) {
            renderer.drawText(font,word,nloc,size);
            ++w;
          }
          nloc[0]=(float)ll;
        }
        nloc[0]=left;
        nloc[1]-=lineheight;
      }
    }
    @Override public void prerender(    RenderList list){
    }
    @Override public int getRenderHints(){
      return 0;
    }
    @Override public int numSelectionQueriesNeeded(){
      return 0;
    }
    @Override public boolean isSelectable(){
      return false;
    }
    @Override public void getSelection(    LinkedList<Object> list,    int qid){
    }
    @Override public void setSelected(    boolean set){
    }
    @Override public boolean isSelected(){
      return false;
    }
  }
);
  mv.setAxialView(AxisAlignedRotation.X_Y);
}"
70772,"@Override public void render(Renderer renderer,int flags){
  if (debugframe == null) {
    TextImageStore store=((GLViewer)renderer).getTextRenderer().getImageStore();
    debugframe=TextImageStore.createDisplayFrame(store);
    debugframe.setVisible(true);
  }
  renderer.setShading(Shading.FLAT);
  renderer.setColor(Color.WHITE);
  renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
  renderer.drawSphere(Point3d.ZERO,0.01);
  Font font=new Font(Font.SANS_SERIF,0,54);
  renderer.drawText(font,""String_Node_Str"",new float[]{0.4f,0.3f,0.3f},0.25);
  renderer.setColor(Color.ORANGE);
  String text=""String_Node_Str"";
  renderer.drawText(font,text,new float[]{-2f,0f,0f},0.25);
  Font comic=fontMap.get(""String_Node_Str"");
  if (comic == null) {
    comic=new Font(Font.MONOSPACED,Font.BOLD,32);
  }
 else {
    comic=comic.deriveFont(Font.BOLD,32);
  }
  renderer.setColor(Color.CYAN);
  text=""String_Node_Str"";
  Rectangle2D rect=renderer.getTextBounds(comic,text,0.25);
  renderer.drawText(comic,text,new float[]{-(float)(rect.getWidth()),0.5f,0f},0.25);
  renderer.setColor(Color.MAGENTA);
  text=""String_Node_Str"";
  font=new Font(Font.SERIF,Font.PLAIN,64);
  rect=renderer.getTextBounds(font,text,0.3);
  renderer.pushModelMatrix();
  RigidTransform3d trans=new RigidTransform3d(new Vector3d(0,-0.4,0),new AxisAngle(0,1,0,Math.toRadians(30)));
  renderer.mulModelMatrix(trans);
  renderer.setFaceStyle(FaceStyle.FRONT);
  renderer.drawText(font,text,Point3d.ZERO,0.3);
  trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0,1,0,Math.PI));
  renderer.mulModelMatrix(trans);
  renderer.drawText(font,text,new Point3d(-rect.getWidth(),0,0),0.3);
  trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0.1,1,0,Math.PI * 1));
  renderer.mulModelMatrix(trans);
  renderer.setShading(Shading.NONE);
  renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
  renderer.setColor(Color.GREEN);
  text=""String_Node_Str"";
  drawMultiline(renderer,font,text,new float[]{-1.75f,-0.2f,-0.5f},0.1,2);
  renderer.popModelMatrix();
}","@Override public void render(Renderer renderer,int flags){
  if (debugframe == null) {
    TextImageStore store=((GLViewer)renderer).getTextRenderer().getImageStore();
    debugframe=TextImageStore.createDisplayFrame(store);
    debugframe.setVisible(true);
  }
  renderer.setShading(Shading.FLAT);
  renderer.setColor(Color.WHITE);
  renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
  Font font=new Font(Font.SANS_SERIF,0,54);
  renderer.drawText(font,""String_Node_Str"",new float[]{0.4f,0.3f,0.3f},0.25);
  renderer.setColor(Color.ORANGE);
  String text=""String_Node_Str"";
  renderer.drawText(font,text,new float[]{-2f,0f,0f},0.25);
  Font comic=fontMap.get(""String_Node_Str"");
  if (comic == null) {
    comic=new Font(Font.MONOSPACED,Font.BOLD,32);
  }
 else {
    comic=comic.deriveFont(Font.BOLD,32);
  }
  renderer.setColor(Color.CYAN);
  text=""String_Node_Str"";
  Rectangle2D rect=renderer.getTextBounds(comic,text,0.25);
  renderer.drawText(comic,text,new float[]{-(float)(rect.getWidth()),0.5f,0f},0.25);
  renderer.setColor(Color.MAGENTA);
  text=""String_Node_Str"";
  font=new Font(Font.SERIF,Font.PLAIN,64);
  rect=renderer.getTextBounds(font,text,0.3);
  renderer.pushModelMatrix();
  RigidTransform3d trans=new RigidTransform3d(new Vector3d(0,-0.4,0),new AxisAngle(0,1,0,Math.toRadians(30)));
  renderer.mulModelMatrix(trans);
  renderer.setFaceStyle(FaceStyle.FRONT);
  renderer.drawText(font,text,Point3d.ZERO,0.3);
  trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0,1,0,Math.PI));
  renderer.mulModelMatrix(trans);
  renderer.drawText(font,text,new Point3d(-rect.getWidth(),0,0),0.3);
  trans=new RigidTransform3d(Vector3d.ZERO,new AxisAngle(0.1,1,0,Math.PI * 1));
  renderer.mulModelMatrix(trans);
  renderer.setShading(Shading.NONE);
  renderer.setFaceStyle(FaceStyle.FRONT_AND_BACK);
  renderer.setColor(Color.GREEN);
  text=""String_Node_Str"";
  drawMultiline(renderer,font,text,new float[]{-1.75f,-0.2f,-0.5f},0.1,2);
  renderer.popModelMatrix();
}"
70773,"public Object clone(){
  try {
    return super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalErrorException(""String_Node_Str"");
  }
}","public Matrix3dBase clone(){
  try {
    return (Matrix3dBase)super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalErrorException(""String_Node_Str"");
  }
}"
70774,"private void disableTransparency(GL2 gl){
  if (!alphaFaceCulling) {
    gl.glEnable(GL2.GL_CULL_FACE);
    gl.glDepthMask(true);
  }
  gl.glDisable(GL2.GL_BLEND);
}","private void disableTransparency(GL2 gl){
  if (!alphaFaceCulling) {
    setFaceStyle(FaceStyle.FRONT);
    gl.glDepthMask(true);
  }
  gl.glDisable(GL2.GL_BLEND);
}"
70775,"@Override public void init(GLAutoDrawable drawable){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + gl);
    System.out.println(""String_Node_Str"");
    GLContext context=drawable.getContext();
    String contextHC=Integer.toHexString(System.identityHashCode(context));
    System.out.println(""String_Node_Str"" + context.getClass().getName() + ""String_Node_Str""+ contextHC+ ""String_Node_Str""+ context.isShared()+ ""String_Node_Str"");
  }
  gl.setSwapInterval(1);
  if (gl.isExtensionAvailable(""String_Node_Str"")) {
    gl.glEnable(GL2.GL_MULTISAMPLE);
    myMultiSampleEnabled=true;
  }
  int[] buff=new int[1];
  gl.glGetIntegerv(GL2.GL_MAX_CLIP_PLANES,buff,0);
  maxClipPlanes=buff[0];
  gl.glEnable(GL2.GL_CULL_FACE);
  gl.glCullFace(GL2.GL_BACK);
  gl.glEnable(GL2.GL_DEPTH_TEST);
  gl.glClearDepth(1.0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_LOCAL_VIEWER,lmodel_local,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_TWO_SIDE,lmodel_twoside,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_AMBIENT,lmodel_ambient,0);
  gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1);
  gl.glEnable(GL2.GL_LIGHTING);
  gl.glEnable(GL2.GL_NORMALIZE);
  gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_FASTEST);
  gl.glDisable(GL2.GL_POINT_SMOOTH);
  setLightingEnabled(true);
  setDepthEnabled(true);
  setColorEnabled(true);
  setVertexColoringEnabled(true);
  setTextureMappingEnabled(true);
  setFaceStyle(FaceStyle.FRONT);
  setShading(Shading.PHONG);
  setGammaCorrectionEnabled(false);
  lightManager.setMaxLights(getMaxLights());
  setupLights(gl);
  gl.glShadeModel(GL2.GL_FLAT);
  if (!isSelecting()) {
    gl.glClearColor(bgColor[0],bgColor[1],bgColor[2],bgColor[3]);
  }
  resetViewVolume();
  invalidateModelMatrix();
  invalidateProjectionMatrix();
  invalidateViewMatrix();
  buildInternalRenderList();
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
  }
}","@Override public void init(GLAutoDrawable drawable){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + gl);
    System.out.println(""String_Node_Str"");
    GLContext context=drawable.getContext();
    String contextHC=Integer.toHexString(System.identityHashCode(context));
    System.out.println(""String_Node_Str"" + context.getClass().getName() + ""String_Node_Str""+ contextHC+ ""String_Node_Str""+ context.isShared()+ ""String_Node_Str"");
  }
  gl.setSwapInterval(1);
  if (gl.isExtensionAvailable(""String_Node_Str"")) {
    gl.glEnable(GL2.GL_MULTISAMPLE);
    myMultiSampleEnabled=true;
  }
  int[] buff=new int[1];
  gl.glGetIntegerv(GL2.GL_MAX_CLIP_PLANES,buff,0);
  maxClipPlanes=buff[0];
  setFaceStyle(FaceStyle.FRONT);
  gl.glEnable(GL2.GL_DEPTH_TEST);
  gl.glClearDepth(1.0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_LOCAL_VIEWER,lmodel_local,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_TWO_SIDE,lmodel_twoside,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_AMBIENT,lmodel_ambient,0);
  gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1);
  gl.glEnable(GL2.GL_LIGHTING);
  gl.glEnable(GL2.GL_NORMALIZE);
  gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_FASTEST);
  gl.glDisable(GL2.GL_POINT_SMOOTH);
  setLightingEnabled(true);
  setDepthEnabled(true);
  setColorEnabled(true);
  setVertexColoringEnabled(true);
  setTextureMappingEnabled(true);
  setFaceStyle(FaceStyle.FRONT);
  setShading(Shading.PHONG);
  setGammaCorrectionEnabled(false);
  lightManager.setMaxLights(getMaxLights());
  setupLights(gl);
  gl.glShadeModel(GL2.GL_FLAT);
  if (!isSelecting()) {
    gl.glClearColor(bgColor[0],bgColor[1],bgColor[2],bgColor[3]);
  }
  resetViewVolume();
  invalidateModelMatrix();
  invalidateProjectionMatrix();
  invalidateViewMatrix();
  buildInternalRenderList();
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
  }
}"
70776,"private void enableTransparency(GL2 gl){
  gl.glEnable(GL2.GL_BLEND);
  if (!alphaFaceCulling) {
    gl.glDepthMask(false);
    gl.glDisable(GL2.GL_CULL_FACE);
  }
  gl.glBlendFunc(sBlending.value(),dBlending.value());
}","private void enableTransparency(GL2 gl){
  gl.glEnable(GL2.GL_BLEND);
  if (!alphaFaceCulling) {
    gl.glDepthMask(false);
    setFaceStyle(FaceStyle.FRONT_AND_BACK);
  }
  gl.glBlendFunc(sBlending.value(),dBlending.value());
}"
70777,"public void display(GLAutoDrawable drawable,int flags){
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  maybeUpdateState(gl);
  gl.glPushMatrix();
  if (selectTrigger) {
    mySelector.setupSelection(drawable);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  doDisplay(drawable,flags);
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(drawable);
  }
 else {
    fireRerenderListeners();
  }
  gl.glPopMatrix();
  if (frameCapture != null) {
synchronized (frameCapture) {
      if (grab) {
        offscreenCapture(flags);
        grab=false;
      }
      if (grabWaitComplete) {
        frameCapture.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        frameCapture.waitForCompletion();
        frameCapture.dispose(gl);
        frameCapture=null;
      }
    }
  }
}","public void display(GLAutoDrawable drawable,int flags){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (!myInternalRenderListValid) {
    buildInternalRenderList();
  }
  maybeUpdateState(gl);
  gl.glPushMatrix();
  if (selectTrigger) {
    mySelector.setupSelection(drawable);
    selectEnabled=true;
    selectTrigger=false;
  }
  drawable.setAutoSwapBufferMode(selectEnabled ? false : true);
  doDisplay(drawable,flags);
  if (selectEnabled) {
    selectEnabled=false;
    mySelector.processSelection(drawable);
  }
 else {
    fireRerenderListeners();
  }
  gl.glPopMatrix();
  if (frameCapture != null) {
synchronized (frameCapture) {
      if (grab) {
        offscreenCapture(flags);
        grab=false;
      }
      if (grabWaitComplete) {
        frameCapture.waitForCompletion();
        grabWaitComplete=false;
      }
      if (grabClose) {
        frameCapture.waitForCompletion();
        frameCapture.dispose(gl);
        frameCapture=null;
      }
    }
  }
  this.drawable=null;
  this.gl=null;
}"
70778,"/** 
 * Draw triangular faces, using the current Shading, lighting and material, and computing a single ""face"" normal from the coordinates (so the current ""shading"" really matters only if it is Shading.NONE).
 */
public void drawTriangle(float[] pnt0,float[] pnt1,float[] pnt2){
  GL2 gl=getGL2();
  maybeUpdateState(gl);
  float[] normal=new float[3];
  computeNormal(pnt0,pnt1,pnt2,normal);
  gl.glBegin(GL2.GL_TRIANGLES);
  gl.glNormal3fv(normal,0);
  gl.glVertex3fv(pnt0,0);
  gl.glVertex3fv(pnt1,0);
  gl.glVertex3fv(pnt2,0);
  gl.glEnd();
}","/** 
 * Draw triangular faces, using the current Shading, lighting and material, and computing a single ""face"" normal from the coordinates (so the current ""shading"" really matters only if it is Shading.NONE).
 */
public void drawTriangle(float[] pnt0,float[] pnt1,float[] pnt2){
  GLSupport.checkAndPrintGLError(gl);
  GL2 gl=getGL2();
  maybeUpdateState(gl);
  float[] normal=new float[3];
  computeNormal(pnt0,pnt1,pnt2,normal);
  gl.glBegin(GL2.GL_TRIANGLES);
  gl.glNormal3fv(normal,0);
  gl.glVertex3fv(pnt0,0);
  gl.glVertex3fv(pnt1,0);
  gl.glVertex3fv(pnt2,0);
  gl.glEnd();
}"
70779,"@Override public void begin2DRendering(double left,double right,double bottom,double top){
  int attribBits=(GL2.GL_ENABLE_BIT | GL2.GL_TEXTURE_BIT | GL2.GL_COLOR_BUFFER_BIT| GL2.GL_DEPTH_BUFFER_BIT| GL2.GL_TRANSFORM_BIT);
  gl.glPushAttrib(attribBits);
  setLightingOn(false);
  gl.glDisable(GL2.GL_DEPTH_TEST);
  gl.glDisable(GL2.GL_CULL_FACE);
  gl.glMatrixMode(GL2.GL_TEXTURE);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  pushModelMatrix();
  pushViewMatrix();
  super.pushProjectionMatrix();
  setModelMatrix(RigidTransform3d.IDENTITY);
  setViewMatrix(RigidTransform3d.IDENTITY);
  setOrthogonal2d(left,right,bottom,top);
  rendering2d=true;
}","@Override public void begin2DRendering(double left,double right,double bottom,double top){
  int attribBits=(GL2.GL_ENABLE_BIT | GL2.GL_TEXTURE_BIT | GL2.GL_COLOR_BUFFER_BIT| GL2.GL_DEPTH_BUFFER_BIT| GL2.GL_TRANSFORM_BIT);
  gl.glPushAttrib(attribBits);
  setLightingOn(false);
  gl.glDisable(GL2.GL_DEPTH_TEST);
  setFaceStyle(FaceStyle.FRONT_AND_BACK);
  gl.glMatrixMode(GL2.GL_TEXTURE);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  pushModelMatrix();
  pushViewMatrix();
  super.pushProjectionMatrix();
  setModelMatrix(RigidTransform3d.IDENTITY);
  setViewMatrix(RigidTransform3d.IDENTITY);
  setOrthogonal2d(left,right,bottom,top);
  rendering2d=true;
}"
70780,"/** 
 * First orphans the original buffer, potentially causing a re-allocation, then returns a mapped buffer ready for writing.
 */
public ByteBuffer mapNewBuffer(GL3 gl){
  gl.glBindBuffer(target,boId);
  gl.glBufferData(target,size,null,usage);
  return gl.glMapBuffer(target,GL.GL_WRITE_ONLY);
}","/** 
 * First orphans the original buffer, potentially causing a re-allocation, then returns a mapped buffer ready for writing.
 */
public ByteBuffer mapNewBuffer(GL3 gl){
  bind(gl);
  gl.glBufferData(target,size,null,usage);
  return gl.glMapBuffer(target,GL.GL_WRITE_ONLY);
}"
70781,"public void update(GL3 gl,ByteBuffer buff,int start,int size){
  gl.glBindBuffer(target,boId);
  if (start == 0 && size >= this.size) {
    gl.glBufferData(target,size,null,usage);
  }
  gl.glBufferSubData(target,start * GLSupport.BYTE_SIZE,size * GLSupport.BYTE_SIZE,buff);
}","public void update(GL3 gl,ByteBuffer buff,int start,int size){
  bind(gl);
  if (start == 0 && size >= this.size) {
    gl.glBufferData(target,size,null,usage);
  }
  gl.glBufferSubData(target,start * GLSupport.BYTE_SIZE,size * GLSupport.BYTE_SIZE,buff);
}"
70782,"public void fill(GL3 gl,ByteBuffer buff,int size,int usage){
  setInfo(size * GLSupport.BYTE_SIZE,usage);
  gl.glBindBuffer(target,boId);
  gl.glBufferData(target,size * GLSupport.BYTE_SIZE,buff,usage);
}","public void fill(GL3 gl,ByteBuffer buff,int size,int usage){
  setInfo(size * GLSupport.BYTE_SIZE,usage);
  bind(gl);
  gl.glBufferData(target,size * GLSupport.BYTE_SIZE,buff,usage);
}"
70783,"/** 
 * Retrieve a mapped buffer to the underlying VBO data
 * @param gl
 * @param access either GL3.GL_WRITE_ONLY, GL3.GL_READ_ONLY, or GL3.GL_READ_WRITE;
 * @return the mapped buffer
 */
public ByteBuffer mapBuffer(GL3 gl,int access){
  gl.glBindBuffer(target,boId);
  return gl.glMapBuffer(target,access);
}","/** 
 * Retrieve a mapped buffer to the underlying VBO data
 * @param gl
 * @param access either GL3.GL_WRITE_ONLY, GL3.GL_READ_ONLY, or GL3.GL_READ_WRITE;
 * @return the mapped buffer
 */
public ByteBuffer mapBuffer(GL3 gl,int access){
  bind(gl);
  return gl.glMapBuffer(target,access);
}"
70784,"public void bind(GL3 gl){
  if (target == 0) {
    System.err.println(""String_Node_Str"");
  }
  gl.glBindBuffer(target,boId);
}","public void bind(GL3 gl){
  System.out.println(""String_Node_Str"" + boId + ""String_Node_Str""+ target+ ""String_Node_Str"");
  gl.glBindBuffer(target,boId);
}"
70785,"public void allocate(GL3 gl,int size,int usage){
  setInfo(size,usage);
  gl.glBindBuffer(target,boId);
  gl.glBufferData(target,size,null,usage);
}","public void allocate(GL3 gl,int size,int usage){
  setInfo(size,usage);
  bind(gl);
  gl.glBufferData(target,size,null,usage);
}"
70786,"/** 
 * Maps only a portion of the underlying buffer
 */
public ByteBuffer mapBufferRange(GL3 gl,int offset,int length,int access){
  gl.glBindBuffer(target,boId);
  return gl.glMapBufferRange(target,offset,length,access);
}","/** 
 * Maps only a portion of the underlying buffer
 */
public ByteBuffer mapBufferRange(GL3 gl,int offset,int length,int access){
  bind(gl);
  return gl.glMapBufferRange(target,offset,length,access);
}"
70787,"private void drawPoints(Renderer renderer,int gidx,RenderProps props,boolean selected){
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,selected);
switch (props.getPointStyle()) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        renderer.drawPoints(myRob,gidx,PointStyle.POINT,size);
      }
      break;
    }
case SPHERE:
{
    double rad=props.getPointRadius();
    if (rad > 0) {
      renderer.drawPoints(myRob,gidx,PointStyle.SPHERE,rad);
    }
    break;
  }
}
renderer.setShading(savedShading);
}","private void drawPoints(Renderer renderer,int gidx,RenderProps props,boolean selected){
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,selected);
  PointStyle style=props.getPointStyle();
switch (style) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        renderer.drawPoints(myRob,gidx,PointStyle.POINT,size);
      }
      break;
    }
case CUBE:
case SPHERE:
{
    double rad=props.getPointRadius();
    if (rad > 0) {
      renderer.drawPoints(myRob,gidx,style,rad);
    }
    break;
  }
}
renderer.setShading(savedShading);
}"
70788,"public void render(Renderer renderer,int flags){
  RenderProps props=myRenderProps;
  if (renderer.isSelecting()) {
    PointStyle style=props.getPointStyle();
    if (style == PointStyle.POINT) {
      int size=props.getPointSize();
      if (size > 0) {
        renderer.setPointSize(size);
      }
 else {
        return;
      }
    }
    for (int i=0; i < size(); i++) {
      Point pnt=get(i);
      if (pnt.getRenderProps() == null && renderer.isSelectable(pnt)) {
        float[] v0=pnt.myRenderCoords;
        renderer.beginSelectionQuery(i);
switch (style) {
case POINT:
{
            renderer.drawPoint(v0);
            break;
          }
case SPHERE:
{
          renderer.drawSphere(v0,props.getPointRadius());
          break;
        }
    }
    renderer.endSelectionQuery();
  }
}
if (style == PointStyle.POINT) {
  renderer.setPointSize(1);
}
}
 else if (myRob != null) {
int numReg=myRob.numPoints(REG_GRP);
int numSel=myRob.numPoints(SEL_GRP);
if (numSel > 0) {
  drawPoints(renderer,SEL_GRP,props,true);
}
if (numReg > 0) {
  drawPoints(renderer,REG_GRP,props,false);
}
}
}","public void render(Renderer renderer,int flags){
  RenderProps props=myRenderProps;
  if (renderer.isSelecting()) {
    PointStyle style=props.getPointStyle();
    if (style == PointStyle.POINT) {
      int size=props.getPointSize();
      if (size > 0) {
        renderer.setPointSize(size);
      }
 else {
        return;
      }
    }
    for (int i=0; i < size(); i++) {
      Point pnt=get(i);
      if (pnt.getRenderProps() == null && renderer.isSelectable(pnt)) {
        float[] v0=pnt.myRenderCoords;
        renderer.beginSelectionQuery(i);
switch (style) {
case POINT:
{
            renderer.drawPoint(v0);
            break;
          }
case CUBE:
{
          renderer.drawCube(v0,2 * props.getPointRadius());
        }
case SPHERE:
{
        renderer.drawSphere(v0,props.getPointRadius());
        break;
      }
  }
  renderer.endSelectionQuery();
}
}
if (style == PointStyle.POINT) {
renderer.setPointSize(1);
}
}
 else if (myRob != null) {
int numReg=myRob.numPoints(REG_GRP);
int numSel=myRob.numPoints(SEL_GRP);
if (numSel > 0) {
drawPoints(renderer,SEL_GRP,props,true);
}
if (numReg > 0) {
drawPoints(renderer,REG_GRP,props,false);
}
}
}"
70789,"@Override public void render(Renderer renderer,int flags){
  RenderProps props=getRenderProps();
  if (props == null) {
    return;
  }
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  Shading shading=props.getShading();
  if (shading != Shading.NONE) {
    renderer.setFaceColoring(props,isSelected());
  }
  if (props.getFaceStyle() != Renderer.FaceStyle.NONE) {
    Shading savedShadeModel=renderer.getShading();
    if (shading == Shading.NONE) {
      renderer.setColor(props.getFaceColorF(),isSelected());
    }
    renderer.setShading(shading);
    if (props.getDrawEdges()) {
      gl.glEnable(GL2.GL_POLYGON_OFFSET_FILL);
      gl.glPolygonOffset(1f,1f);
    }
    drawFaces(gl,renderer,props);
    if (props.getDrawEdges()) {
      gl.glDisable(GL2.GL_POLYGON_OFFSET_FILL);
    }
    renderer.setShading(savedShadeModel);
  }
  if (!renderer.isSelecting()) {
    if (props.getBackColorF() != null) {
      gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1f);
    }
  }
  if (props.getDrawEdges()) {
    float savedLineWidth=renderer.getLineWidth();
    Shading savedShadeModel=renderer.getShading();
    renderer.setLineWidth(props.getLineWidth());
    if (props.getLineColor() != null && !renderer.isSelecting()) {
      renderer.setShading(Shading.NONE);
      renderer.setLineColoring(props,isSelected());
    }
    if (useVertexColouring && !renderer.isSelecting()) {
      renderer.setShading(Shading.GOURAUD);
    }
 else {
      renderer.setShading(Shading.FLAT);
    }
    drawEdges(gl,props);
    renderer.setLineWidth(savedLineWidth);
    renderer.setShading(savedShadeModel);
  }
  gl.glPopMatrix();
}","@Override public void render(Renderer renderer,int flags){
  RenderProps props=getRenderProps();
  if (props == null) {
    return;
  }
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  Shading shading=props.getShading();
  if (shading != Shading.NONE) {
    renderer.setFaceColoring(props,isSelected());
  }
  if (props.getFaceStyle() != Renderer.FaceStyle.NONE) {
    Shading savedShadeModel=renderer.getShading();
    if (shading == Shading.NONE) {
      renderer.setColor(props.getFaceColorF(),isSelected());
    }
    renderer.setShading(shading);
    if (props.getDrawEdges()) {
      gl.glEnable(GL2.GL_POLYGON_OFFSET_FILL);
      gl.glPolygonOffset(1f,1f);
    }
    drawFaces(gl,renderer,props);
    if (props.getDrawEdges()) {
      gl.glDisable(GL2.GL_POLYGON_OFFSET_FILL);
    }
    renderer.setShading(savedShadeModel);
  }
  if (!renderer.isSelecting()) {
    if (props.getBackColorF() != null) {
      gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1f);
    }
  }
  if (props.getDrawEdges()) {
    float savedLineWidth=renderer.getLineWidth();
    Shading savedShadeModel=renderer.getShading();
    renderer.setLineWidth(props.getLineWidth());
    if (props.getLineColor() != null && !renderer.isSelecting()) {
      renderer.setShading(Shading.NONE);
      renderer.setLineColoring(props,isSelected());
    }
    if (useVertexColouring && !renderer.isSelecting()) {
      renderer.setShading(Shading.PHONG);
    }
 else {
      renderer.setShading(Shading.FLAT);
    }
    drawEdges(gl,props);
    renderer.setLineWidth(savedLineWidth);
    renderer.setShading(savedShadeModel);
  }
  gl.glPopMatrix();
}"
70790,"public void render(Renderer renderer,int flags){
  RenderProps props=getRenderProps();
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  Shading shading=props.getShading();
  if (shading != Shading.NONE) {
    renderer.setFaceColoring(props,isSelected());
  }
  if (props.getFaceStyle() != Renderer.FaceStyle.NONE) {
    Shading savedShadeModel=renderer.getShading();
    if (shading == Shading.NONE) {
      renderer.setColor(props.getFaceColorF(),isSelected());
    }
    renderer.setShading(shading);
    if (props.getDrawEdges()) {
      gl.glEnable(GL2.GL_POLYGON_OFFSET_FILL);
      gl.glPolygonOffset(1f,1f);
    }
    boolean useDisplayList=!renderer.isSelecting();
    GL2VersionedObject gvo=null;
    int facePrint=getFaceVersion();
    BooleanHolder compile=new BooleanHolder(true);
    if (useDisplayList) {
      gvo=viewer.getVersionedObject(gl,faceKey,facePrint,compile);
    }
    if (!useDisplayList || compile.value) {
      if (useDisplayList) {
        gvo.beginCompile(gl);
      }
      drawFaces(gl,renderer,props);
      if (useDisplayList) {
        gvo.endCompile(gl);
        gvo.draw(gl);
      }
    }
 else {
      gvo.draw(gl);
    }
    if (props.getDrawEdges()) {
      gl.glDisable(GL2.GL_POLYGON_OFFSET_FILL);
    }
    renderer.setShading(savedShadeModel);
  }
  if (!renderer.isSelecting()) {
    if (props.getBackColorF() != null) {
      gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1f);
    }
  }
  if (props.getDrawEdges()) {
    float savedLineWidth=renderer.getLineWidth();
    Shading savedShadeModel=renderer.getShading();
    renderer.setLineWidth(props.getLineWidth());
    if (props.getLineColor() != null && !renderer.isSelecting()) {
      renderer.setShading(Shading.NONE);
      renderer.setLineColoring(props,isSelected());
    }
    if (useVertexColouring && !renderer.isSelecting()) {
      renderer.setShading(Shading.GOURAUD);
    }
 else {
      renderer.setShading(Shading.FLAT);
    }
    boolean useDisplayList=!renderer.isSelecting();
    GL2VersionedObject gvo=null;
    int edgePrint=getEdgeVersion();
    BooleanHolder compile=new BooleanHolder(true);
    if (useDisplayList) {
      gvo=viewer.getVersionedObject(gl,edgeKey,edgePrint,compile);
    }
    if (!useDisplayList || compile.value) {
      if (useDisplayList) {
        gvo.beginCompile(gl);
      }
      drawEdges(gl,props);
      if (useDisplayList) {
        gvo.endCompile(gl);
        gvo.draw(gl);
      }
    }
 else {
      gvo.draw(gl);
    }
    renderer.setLineWidth(savedLineWidth);
    renderer.setShading(savedShadeModel);
  }
  gl.glPopMatrix();
}","public void render(Renderer renderer,int flags){
  RenderProps props=getRenderProps();
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  Shading shading=props.getShading();
  if (shading != Shading.NONE) {
    renderer.setFaceColoring(props,isSelected());
  }
  if (props.getFaceStyle() != Renderer.FaceStyle.NONE) {
    Shading savedShadeModel=renderer.getShading();
    if (shading == Shading.NONE) {
      renderer.setColor(props.getFaceColorF(),isSelected());
    }
    renderer.setShading(shading);
    if (props.getDrawEdges()) {
      gl.glEnable(GL2.GL_POLYGON_OFFSET_FILL);
      gl.glPolygonOffset(1f,1f);
    }
    boolean useDisplayList=!renderer.isSelecting();
    GL2VersionedObject gvo=null;
    int facePrint=getFaceVersion();
    BooleanHolder compile=new BooleanHolder(true);
    if (useDisplayList) {
      gvo=viewer.getVersionedObject(gl,faceKey,facePrint,compile);
    }
    if (!useDisplayList || compile.value) {
      if (useDisplayList) {
        gvo.beginCompile(gl);
      }
      drawFaces(gl,renderer,props);
      if (useDisplayList) {
        gvo.endCompile(gl);
        gvo.draw(gl);
      }
    }
 else {
      gvo.draw(gl);
    }
    if (props.getDrawEdges()) {
      gl.glDisable(GL2.GL_POLYGON_OFFSET_FILL);
    }
    renderer.setShading(savedShadeModel);
  }
  if (!renderer.isSelecting()) {
    if (props.getBackColorF() != null) {
      gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1f);
    }
  }
  if (props.getDrawEdges()) {
    float savedLineWidth=renderer.getLineWidth();
    Shading savedShadeModel=renderer.getShading();
    renderer.setLineWidth(props.getLineWidth());
    if (props.getLineColor() != null && !renderer.isSelecting()) {
      renderer.setShading(Shading.NONE);
      renderer.setLineColoring(props,isSelected());
    }
    if (useVertexColouring && !renderer.isSelecting()) {
      renderer.setShading(Shading.PHONG);
    }
 else {
      renderer.setShading(Shading.FLAT);
    }
    boolean useDisplayList=!renderer.isSelecting();
    GL2VersionedObject gvo=null;
    int edgePrint=getEdgeVersion();
    BooleanHolder compile=new BooleanHolder(true);
    if (useDisplayList) {
      gvo=viewer.getVersionedObject(gl,edgeKey,edgePrint,compile);
    }
    if (!useDisplayList || compile.value) {
      if (useDisplayList) {
        gvo.beginCompile(gl);
      }
      drawEdges(gl,props);
      if (useDisplayList) {
        gvo.endCompile(gl);
        gvo.draw(gl);
      }
    }
 else {
      gvo.draw(gl);
    }
    renderer.setLineWidth(savedLineWidth);
    renderer.setShading(savedShadeModel);
  }
  gl.glPopMatrix();
}"
70791,"public void drawPoints(Renderer renderer,RenderProps props,Iterator<? extends VertexComponent> iterator){
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,false);
switch (props.getPointStyle()) {
case POINT:
{
      renderer.setPointSize(props.getPointSize());
      if (renderer.isSelecting()) {
        int i=0;
        while (iterator.hasNext()) {
          VertexComponent pnt=iterator.next();
          if (pnt.getRenderProps() == null) {
            if (renderer.isSelectable(pnt)) {
              renderer.beginSelectionQuery(i);
              gl.glBegin(GL2.GL_POINTS);
              gl.glVertex3fv(pnt.getRenderCoords(),0);
              gl.glEnd();
              renderer.endSelectionQuery();
            }
          }
          i++;
        }
      }
 else {
        gl.glBegin(GL2.GL_POINTS);
        while (iterator.hasNext()) {
          VertexComponent pnt=iterator.next();
          if (pnt.getRenderProps() == null) {
            renderer.setPointColoring(props,pnt.isSelected());
            gl.glVertex3fv(pnt.getRenderCoords(),0);
          }
        }
        gl.glEnd();
      }
      renderer.setPointSize(1);
      break;
    }
case SPHERE:
{
    int i=0;
    while (iterator.hasNext()) {
      VertexComponent pnt=iterator.next();
      double rad=props.getPointRadius();
      if (pnt.getRenderProps() == null) {
        if (renderer.isSelecting()) {
          if (renderer.isSelectable(pnt)) {
            renderer.beginSelectionQuery(i);
            renderer.drawSphere(pnt.getRenderCoords(),rad);
            renderer.endSelectionQuery();
          }
        }
 else {
          renderer.setPointColoring(props,pnt.isSelected());
          renderer.drawSphere(pnt.getRenderCoords(),rad);
        }
      }
      i++;
    }
  }
}
renderer.setShading(savedShading);
gl.glPopMatrix();
}","public void drawPoints(Renderer renderer,RenderProps props,Iterator<? extends VertexComponent> iterator){
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,false);
switch (props.getPointStyle()) {
case POINT:
{
      renderer.setPointSize(props.getPointSize());
      if (renderer.isSelecting()) {
        int i=0;
        while (iterator.hasNext()) {
          VertexComponent pnt=iterator.next();
          if (pnt.getRenderProps() == null) {
            if (renderer.isSelectable(pnt)) {
              renderer.beginSelectionQuery(i);
              gl.glBegin(GL2.GL_POINTS);
              gl.glVertex3fv(pnt.getRenderCoords(),0);
              gl.glEnd();
              renderer.endSelectionQuery();
            }
          }
          i++;
        }
      }
 else {
        gl.glBegin(GL2.GL_POINTS);
        while (iterator.hasNext()) {
          VertexComponent pnt=iterator.next();
          if (pnt.getRenderProps() == null) {
            renderer.setPointColoring(props,pnt.isSelected());
            gl.glVertex3fv(pnt.getRenderCoords(),0);
          }
        }
        gl.glEnd();
      }
      renderer.setPointSize(1);
      break;
    }
case CUBE:
{
    int i=0;
    double width=2 * props.getPointRadius();
    while (iterator.hasNext()) {
      VertexComponent pnt=iterator.next();
      if (pnt.getRenderProps() == null) {
        if (renderer.isSelecting()) {
          if (renderer.isSelectable(pnt)) {
            renderer.beginSelectionQuery(i);
            renderer.drawCube(pnt.getRenderCoords(),width);
            renderer.endSelectionQuery();
          }
        }
 else {
          renderer.setPointColoring(props,pnt.isSelected());
          renderer.drawCube(pnt.getRenderCoords(),width);
        }
      }
      i++;
    }
    break;
  }
case SPHERE:
{
  int i=0;
  double rad=props.getPointRadius();
  while (iterator.hasNext()) {
    VertexComponent pnt=iterator.next();
    if (pnt.getRenderProps() == null) {
      if (renderer.isSelecting()) {
        if (renderer.isSelectable(pnt)) {
          renderer.beginSelectionQuery(i);
          renderer.drawSphere(pnt.getRenderCoords(),rad);
          renderer.endSelectionQuery();
        }
      }
 else {
        renderer.setPointColoring(props,pnt.isSelected());
        renderer.drawSphere(pnt.getRenderCoords(),rad);
      }
    }
    i++;
  }
  break;
}
}
renderer.setShading(savedShading);
gl.glPopMatrix();
}"
70792,"public void render(Renderer renderer,int flags){
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  RenderProps props=getRenderProps();
  boolean lastSelected=false;
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,isSelected());
switch (props.getPointStyle()) {
case POINT:
{
      renderer.setPointSize(props.getPointSize());
      if (renderer.isSelecting()) {
        int i=0;
        for (        VertexComponent vc : this) {
          if (vc.getRenderProps() == null) {
            renderer.beginSelectionQuery(i);
            gl.glBegin(GL2.GL_POINTS);
            gl.glVertex3fv(vc.getRenderCoords(),0);
            gl.glEnd();
            renderer.endSelectionQuery();
          }
          i++;
        }
      }
 else {
        VListPrint vPrint=getFingerPrint(PointStyle.POINT,0);
        BooleanHolder compile=new BooleanHolder(true);
        GL2VersionedObject gvo=viewer.getVersionedObject(gl,vKey,vPrint,compile);
        boolean useDisplayList=!renderer.isSelecting();
        if (compile.value || useDisplayList) {
          if (useDisplayList && compile.value) {
            gvo.beginCompile(gl);
          }
          gl.glBegin(GL2.GL_POINTS);
          for (          VertexComponent vc : this) {
            if (vc.getRenderProps() == null) {
              if (!isSelected()) {
                if (vc.isSelected() != lastSelected) {
                  renderer.setPointColoring(props,vc.isSelected());
                  lastSelected=vc.isSelected();
                }
              }
              gl.glVertex3fv(vc.getRenderCoords(),0);
            }
          }
          gl.glEnd();
          if (useDisplayList) {
            gvo.endCompile(gl);
            gvo.draw(gl);
          }
        }
 else {
          gvo.draw(gl);
        }
      }
      renderer.setPointSize(1);
      break;
    }
case SPHERE:
{
    BooleanHolder compile=new BooleanHolder(true);
    boolean useDisplayList=!renderer.isSelecting();
    GL2VersionedObject gvo=null;
    if (useDisplayList) {
      GL2Object sphere=viewer.getPrimitive(gl,PrimitiveType.SPHERE);
      VListPrint vPrint=getFingerPrint(PointStyle.POINT,sphere.hashCode());
      gvo=viewer.getVersionedObject(gl,vKey,vPrint,compile);
    }
    if (!useDisplayList || compile.value) {
      if (useDisplayList) {
        gvo.beginCompile(gl);
      }
      int i=0;
      for (      VertexComponent vc : this) {
        if (vc.getRenderProps() == null) {
          double rad=props.getPointRadius();
          if (renderer.isSelecting()) {
            renderer.beginSelectionQuery(i);
            renderer.drawSphere(vc.getRenderCoords(),rad);
            renderer.endSelectionQuery();
          }
 else {
            if (!isSelected()) {
              if (vc.isSelected() != lastSelected) {
                renderer.setPointColoring(props,vc.isSelected());
                lastSelected=vc.isSelected();
              }
            }
            renderer.drawSphere(vc.getRenderCoords(),rad);
          }
        }
        i++;
      }
      if (useDisplayList) {
        gvo.endCompile(gl);
        gvo.draw(gl);
      }
    }
 else {
      gvo.draw(gl);
      int err=gl.glGetError();
      if (err != GL.GL_NO_ERROR) {
        System.err.println(""String_Node_Str"" + err);
      }
    }
    break;
  }
}
renderer.setShading(savedShading);
gl.glPopMatrix();
}","public void render(Renderer renderer,int flags){
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  gl.glPushMatrix();
  RenderProps props=getRenderProps();
  boolean lastSelected=false;
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,isSelected());
switch (props.getPointStyle()) {
case POINT:
{
      renderer.setPointSize(props.getPointSize());
      if (renderer.isSelecting()) {
        int i=0;
        for (        VertexComponent vc : this) {
          if (vc.getRenderProps() == null) {
            renderer.beginSelectionQuery(i);
            gl.glBegin(GL2.GL_POINTS);
            gl.glVertex3fv(vc.getRenderCoords(),0);
            gl.glEnd();
            renderer.endSelectionQuery();
          }
          i++;
        }
      }
 else {
        VListPrint vPrint=getFingerPrint(PointStyle.POINT,0);
        BooleanHolder compile=new BooleanHolder(true);
        GL2VersionedObject gvo=viewer.getVersionedObject(gl,vKey,vPrint,compile);
        boolean useDisplayList=!renderer.isSelecting();
        if (compile.value || useDisplayList) {
          if (useDisplayList && compile.value) {
            gvo.beginCompile(gl);
          }
          gl.glBegin(GL2.GL_POINTS);
          for (          VertexComponent vc : this) {
            if (vc.getRenderProps() == null) {
              if (!isSelected()) {
                if (vc.isSelected() != lastSelected) {
                  renderer.setPointColoring(props,vc.isSelected());
                  lastSelected=vc.isSelected();
                }
              }
              gl.glVertex3fv(vc.getRenderCoords(),0);
            }
          }
          gl.glEnd();
          if (useDisplayList) {
            gvo.endCompile(gl);
            gvo.draw(gl);
          }
        }
 else {
          gvo.draw(gl);
        }
      }
      renderer.setPointSize(1);
      break;
    }
case CUBE:
{
    BooleanHolder compile=new BooleanHolder(true);
    boolean useDisplayList=!renderer.isSelecting();
    GL2VersionedObject gvo=null;
    if (useDisplayList) {
      GL2Object sphere=viewer.getPrimitive(gl,PrimitiveType.SPHERE);
      VListPrint vPrint=getFingerPrint(PointStyle.POINT,sphere.hashCode());
      gvo=viewer.getVersionedObject(gl,vKey,vPrint,compile);
    }
    if (!useDisplayList || compile.value) {
      if (useDisplayList) {
        gvo.beginCompile(gl);
      }
      int i=0;
      double width=2 * props.getPointRadius();
      for (      VertexComponent vc : this) {
        if (vc.getRenderProps() == null) {
          if (renderer.isSelecting()) {
            renderer.beginSelectionQuery(i);
            renderer.drawCube(vc.getRenderCoords(),width);
            renderer.endSelectionQuery();
          }
 else {
            if (!isSelected()) {
              if (vc.isSelected() != lastSelected) {
                renderer.setPointColoring(props,vc.isSelected());
                lastSelected=vc.isSelected();
              }
            }
            renderer.drawCube(vc.getRenderCoords(),width);
          }
        }
        i++;
      }
      if (useDisplayList) {
        gvo.endCompile(gl);
        gvo.draw(gl);
      }
    }
 else {
      gvo.draw(gl);
      int err=gl.glGetError();
      if (err != GL.GL_NO_ERROR) {
        System.err.println(""String_Node_Str"" + err);
      }
    }
    break;
  }
case SPHERE:
{
  BooleanHolder compile=new BooleanHolder(true);
  boolean useDisplayList=!renderer.isSelecting();
  GL2VersionedObject gvo=null;
  if (useDisplayList) {
    GL2Object sphere=viewer.getPrimitive(gl,PrimitiveType.SPHERE);
    VListPrint vPrint=getFingerPrint(PointStyle.POINT,sphere.hashCode());
    gvo=viewer.getVersionedObject(gl,vKey,vPrint,compile);
  }
  if (!useDisplayList || compile.value) {
    if (useDisplayList) {
      gvo.beginCompile(gl);
    }
    int i=0;
    double rad=props.getPointRadius();
    for (    VertexComponent vc : this) {
      if (vc.getRenderProps() == null) {
        if (renderer.isSelecting()) {
          renderer.beginSelectionQuery(i);
          renderer.drawSphere(vc.getRenderCoords(),rad);
          renderer.endSelectionQuery();
        }
 else {
          if (!isSelected()) {
            if (vc.isSelected() != lastSelected) {
              renderer.setPointColoring(props,vc.isSelected());
              lastSelected=vc.isSelected();
            }
          }
          renderer.drawSphere(vc.getRenderCoords(),rad);
        }
      }
      i++;
    }
    if (useDisplayList) {
      gvo.endCompile(gl);
      gvo.draw(gl);
    }
  }
 else {
    gvo.draw(gl);
    int err=gl.glGetError();
    if (err != GL.GL_NO_ERROR) {
      System.err.println(""String_Node_Str"" + err);
    }
  }
  break;
}
}
renderer.setShading(savedShading);
gl.glPopMatrix();
}"
70793,"public void render(Renderer renderer,PointMesh mesh,RenderProps props,boolean selected){
  if (mesh.numVertices() == 0) {
    return;
  }
  renderer.pushModelMatrix();
  if (mesh.isRenderBuffered()) {
    renderer.mulModelMatrix(mesh.getXMeshToWorldRender());
  }
 else {
    renderer.mulModelMatrix(mesh.XMeshToWorld);
  }
  float savedLineWidth=renderer.getLineWidth();
  Shading savedShadeModel=renderer.getShading();
  PointStyle pointStyle=props.getPointStyle();
  if (pointStyle == PointStyle.POINT && !mesh.hasNormals()) {
    renderer.setShading(Shading.NONE);
  }
 else {
    renderer.setShading(props.getShading());
  }
  ColorInterpolation savedColorInterp=null;
  if (usingHSV(mesh)) {
    savedColorInterp=renderer.setColorInterpolation(ColorInterpolation.HSV);
  }
  renderer.setPointColoring(props,selected);
switch (pointStyle) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        renderer.drawPoints(myRob,PointStyle.POINT,size);
      }
      break;
    }
case SPHERE:
{
    double rad=props.getPointRadius();
    if (rad > 0) {
      renderer.drawPoints(myRob,PointStyle.SPHERE,rad);
    }
    break;
  }
}
if (savedColorInterp != null) {
renderer.setColorInterpolation(savedColorInterp);
}
if (mesh.getNormalRenderLen() > 0) {
renderer.setLineWidth(props.getLineWidth());
renderer.setLineColoring(props,selected);
renderer.drawLines(myRob);
}
renderer.setLineWidth(savedLineWidth);
renderer.setShading(savedShadeModel);
renderer.popModelMatrix();
}","public void render(Renderer renderer,PointMesh mesh,RenderProps props,boolean selected){
  if (mesh.numVertices() == 0) {
    return;
  }
  renderer.pushModelMatrix();
  if (mesh.isRenderBuffered()) {
    renderer.mulModelMatrix(mesh.getXMeshToWorldRender());
  }
 else {
    renderer.mulModelMatrix(mesh.XMeshToWorld);
  }
  float savedLineWidth=renderer.getLineWidth();
  Shading savedShadeModel=renderer.getShading();
  PointStyle pointStyle=props.getPointStyle();
  if (pointStyle == PointStyle.POINT && !mesh.hasNormals()) {
    renderer.setShading(Shading.NONE);
  }
 else {
    renderer.setShading(props.getShading());
  }
  ColorInterpolation savedColorInterp=null;
  if (usingHSV(mesh)) {
    savedColorInterp=renderer.setColorInterpolation(ColorInterpolation.HSV);
  }
  renderer.setPointColoring(props,selected);
switch (pointStyle) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        renderer.drawPoints(myRob,PointStyle.POINT,size);
      }
      break;
    }
case CUBE:
case SPHERE:
{
    double rad=props.getPointRadius();
    if (rad > 0) {
      renderer.drawPoints(myRob,pointStyle,rad);
    }
    break;
  }
}
if (savedColorInterp != null) {
renderer.setColorInterpolation(savedColorInterp);
}
if (mesh.getNormalRenderLen() > 0) {
renderer.setLineWidth(props.getLineWidth());
renderer.setLineColoring(props,selected);
renderer.drawLines(myRob);
}
renderer.setLineWidth(savedLineWidth);
renderer.setShading(savedShadeModel);
renderer.popModelMatrix();
}"
70794,"@Override public void drawTriangles(RenderObject robj,int gidx){
  if (!robj.hasTriangles()) {
    return;
  }
  boolean enableLighting=false;
  if (isLightingEnabled() && !robj.hasNormals()) {
    enableLighting=true;
    setLightingEnabled(false);
  }
  maybeUpdateState(gl);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  GL2VersionedObject gvo=null;
  GLTexture tex=null;
  if (myColorMapProps != null && myColorMapProps.isEnabled() && robj.hasTextureCoords()) {
    tex=myGLResources.getOrLoadTexture(gl,myColorMapProps.getContent());
    if (tex != null) {
      gl.glEnable(GL.GL_TEXTURE_2D);
      gl.glActiveTexture(GL.GL_TEXTURE0);
      gl.glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,getTextureMode(myColorMapProps));
      tex.bind(gl);
    }
  }
  RenderObjectVersion fingerprint=robj.getVersionInfo();
  RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.TRIANGLES,gidx);
  boolean compile=true;
  if (useDisplayList) {
    gvo=myGLResources.getVersionedObject(key);
    if (gvo != null) {
      boolean iv=gvo.disposeInvalid(gl);
      if (iv == true) {
        System.out.println(""String_Node_Str"" + gvo);
      }
    }
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + gvo.getDisplayList().getListId());
    }
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    gl.glBegin(GL.GL_TRIANGLES);
    robj.readLock();
    int[] tris=robj.getTriangles(gidx);
    int triangleCount=robj.numTriangles(gidx);
    int triangleStride=robj.getTriangleStride();
    int idx=0;
    for (int i=0; i < triangleCount; ++i) {
      idx=i * triangleStride;
      for (int j=0; j < triangleStride; ++j) {
        int vidx=tris[idx + j];
        if (!selecting && useColors) {
          robj.getVertexColor(vidx);
          setVertexColor(gl,robj.getVertexColor(vidx),useHSV);
        }
        if (robj.hasNormals()) {
          gl.glNormal3fv(robj.getVertexNormal(vidx),0);
        }
        if (robj.hasTextureCoords()) {
          gl.glTexCoord2fv(robj.getVertexTextureCoord(vidx),0);
        }
        gl.glVertex3fv(robj.getVertexPosition(vidx),0);
      }
    }
    robj.readUnlock();
    gl.glEnd();
    if (gvo != null) {
      gvo.endCompile(gl);
      gvo.draw(gl);
    }
  }
 else {
    gvo.draw(gl);
  }
  if (tex != null) {
    tex.unbind(gl);
    gl.glDisable(GL.GL_TEXTURE_2D);
  }
  if (useColors) {
    gl.glDisable(GL2.GL_COLOR_MATERIAL);
    if (useHSV) {
      gl.glUseProgramObjectARB(0);
    }
  }
  if (enableLighting) {
    setLightingEnabled(true);
  }
}","@Override public void drawTriangles(RenderObject robj,int gidx){
  if (!robj.hasTriangles()) {
    return;
  }
  boolean enableLighting=false;
  if (isLightingEnabled() && !robj.hasNormals()) {
    enableLighting=true;
    setLightingEnabled(false);
  }
  maybeUpdateState(gl);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  GL2VersionedObject gvo=null;
  GLTexture tex=null;
  if (myColorMapProps != null && myColorMapProps.isEnabled() && robj.hasTextureCoords()) {
    tex=myGLResources.getOrLoadTexture(gl,myColorMapProps.getContent());
    if (tex != null) {
      gl.glEnable(GL.GL_TEXTURE_2D);
      gl.glActiveTexture(GL.GL_TEXTURE0);
      gl.glTexEnvi(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,getTextureMode(myColorMapProps));
      tex.bind(gl);
    }
  }
  RenderObjectVersion fingerprint=robj.getVersionInfo();
  RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.TRIANGLES,gidx);
  boolean compile=true;
  if (useDisplayList) {
    gvo=myGLResources.getVersionedObject(key);
    if (gvo != null) {
      boolean iv=gvo.disposeInvalid(gl);
      if (iv == true) {
        System.out.println(""String_Node_Str"" + gvo);
      }
    }
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (DEBUG) {
      System.out.println(""String_Node_Str"" + gvo.getDisplayList().getListId());
    }
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    gl.glBegin(GL.GL_TRIANGLES);
    robj.readLock();
    int[] tris=robj.getTriangles(gidx);
    int triangleCount=robj.numTriangles(gidx);
    int triangleStride=robj.getTriangleStride();
    int idx=0;
    for (int i=0; i < triangleCount; ++i) {
      idx=i * triangleStride;
      for (int j=0; j < triangleStride; ++j) {
        int vidx=tris[idx + j];
        if (!selecting && useColors) {
          robj.getVertexColor(vidx);
          setVertexColor(gl,robj.getVertexColor(vidx),useHSV);
        }
        if (robj.hasNormals()) {
          gl.glNormal3fv(robj.getVertexNormal(vidx),0);
        }
        if (robj.hasTextureCoords()) {
          gl.glTexCoord2fv(robj.getVertexTextureCoord(vidx),0);
        }
        gl.glVertex3fv(robj.getVertexPosition(vidx),0);
      }
    }
    robj.readUnlock();
    gl.glEnd();
    if (gvo != null) {
      gvo.endCompile(gl);
      gvo.draw(gl);
    }
  }
 else {
    gvo.draw(gl);
  }
  if (tex != null) {
    tex.unbind(gl);
    gl.glDisable(GL.GL_TEXTURE_2D);
  }
  if (useColors) {
    gl.glDisable(GL2.GL_COLOR_MATERIAL);
    if (useHSV) {
      gl.glUseProgramObjectARB(0);
    }
  }
  if (enableLighting) {
    setLightingEnabled(true);
  }
}"
70795,"private void drawSolidPoints(RenderObject robj,int gidx,PointStyle style,double rad){
  int pointCount=robj.numPoints(gidx);
  if (pointCount == 0) {
    return;
  }
  GL2 gl=getGL2();
  maybeUpdateState(gl);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  GL2Primitive point=null;
switch (style) {
case CUBE:
    point=getPrimitive(gl,PrimitiveType.CUBE);
  break;
case POINT:
case SPHERE:
point=getPrimitive(gl,PrimitiveType.SPHERE);
}
boolean useDisplayList=!selecting || !hasColors;
GL2VersionedObject gvo=null;
RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.POINTS,gidx);
PointFingerPrint fingerprint=new PointFingerPrint(robj.getVersionInfo(),style,point,(float)rad);
boolean compile=true;
if (useDisplayList) {
gvo=myGLResources.getVersionedObject(key);
if (gvo != null) {
boolean iv=gvo.disposeInvalid(gl);
if (iv == true) {
  System.out.println(""String_Node_Str"" + gvo);
}
}
if (gvo == null || gvo.disposeInvalid(gl)) {
gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
compile=true;
}
 else {
compile=!(gvo.compareExchangeFingerPrint(fingerprint));
}
}
if (compile) {
if (gvo != null) {
gvo.beginCompile(gl);
}
robj.readLock();
int[] points=robj.getPoints(gidx);
for (int i=0; i < pointCount; ++i) {
int vidx=points[i];
if (!selecting && useColors) {
  setVertexColor(gl,robj.getVertexColor(vidx),useHSV);
}
float[] p=robj.getPosition(vidx);
gl.glPushMatrix();
gl.glTranslatef(p[0],p[1],p[2]);
gl.glScaled(rad,rad,rad);
point.draw(gl);
gl.glPopMatrix();
}
robj.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
}","private void drawSolidPoints(RenderObject robj,int gidx,PointStyle style,double rad){
  int pointCount=robj.numPoints(gidx);
  if (pointCount == 0) {
    return;
  }
  GL2 gl=getGL2();
  maybeUpdateState(gl);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  GL2Primitive point=null;
switch (style) {
case CUBE:
    point=getPrimitive(gl,PrimitiveType.CUBE);
  break;
case POINT:
case SPHERE:
point=getPrimitive(gl,PrimitiveType.SPHERE);
}
boolean useDisplayList=!selecting || !hasColors;
GL2VersionedObject gvo=null;
RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.POINTS,gidx);
PointFingerPrint fingerprint=new PointFingerPrint(robj.getVersionInfo(),style,point,(float)rad);
boolean compile=true;
if (useDisplayList) {
gvo=myGLResources.getVersionedObject(key);
if (gvo != null) {
boolean iv=gvo.disposeInvalid(gl);
if (iv == true) {
  System.out.println(""String_Node_Str"" + gvo);
}
}
if (gvo == null || gvo.disposeInvalid(gl)) {
gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
compile=true;
}
 else {
compile=!(gvo.compareExchangeFingerPrint(fingerprint));
}
}
if (compile) {
if (gvo != null) {
gvo.beginCompile(gl);
}
robj.readLock();
int[] points=robj.getPoints(gidx);
for (int i=0; i < pointCount; ++i) {
int vidx=points[i];
if (!selecting && useColors) {
  setVertexColor(gl,robj.getVertexColor(vidx),useHSV);
}
float[] p=robj.getPosition(vidx);
gl.glPushMatrix();
gl.glTranslatef(p[0],p[1],p[2]);
gl.glScaled(rad,rad,rad);
point.draw(gl);
gl.glPopMatrix();
}
robj.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
}"
70796,"@Override public void drawVertices(RenderObject robj,DrawMode mode){
  boolean enableLighting=false;
  if (isLightingEnabled() && !robj.hasNormals()) {
    enableLighting=true;
    setLightingEnabled(false);
  }
  maybeUpdateState(gl);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  GL2VersionedObject gvo=null;
  RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.VERTICES,0);
  VertexFingerPrint fingerprint=new VertexFingerPrint(robj.getVersionInfo(),mode);
  boolean compile=true;
  if (useDisplayList) {
    gvo=myGLResources.getVersionedObject(key);
    if (gvo != null) {
      boolean iv=gvo.disposeInvalid(gl);
      if (iv == true) {
        System.out.println(""String_Node_Str"" + gvo);
      }
    }
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
switch (mode) {
case LINES:
      gl.glBegin(GL2.GL_LINES);
    break;
case LINE_LOOP:
  gl.glBegin(GL2.GL_LINE_LOOP);
break;
case LINE_STRIP:
gl.glBegin(GL2.GL_LINE_STRIP);
break;
case POINTS:
gl.glBegin(GL2.GL_POINTS);
break;
case TRIANGLES:
gl.glBegin(GL2.GL_TRIANGLES);
break;
case TRIANGLE_FAN:
gl.glBegin(GL2.GL_TRIANGLE_FAN);
break;
case TRIANGLE_STRIP:
gl.glBegin(GL2.GL_TRIANGLE_STRIP);
break;
default :
gl.glBegin(GL2.GL_POINTS);
break;
}
robj.readLock();
int vertexCount=robj.numVertices();
int positionOffset=robj.getVertexPositionOffset();
int normalOffset=robj.getVertexNormalOffset();
int colorOffset=robj.getVertexColorOffset();
int texcoordOffset=robj.getVertexTextureCoordOffset();
int vertexStride=robj.getVertexStride();
int[] verts=robj.getVertexBuffer();
int baseIdx=0;
for (int i=0; i < vertexCount; ++i) {
if (!selecting && useColors) {
setVertexColor(gl,robj.getColor(verts[baseIdx + colorOffset]),useHSV);
}
if (robj.hasNormals()) {
gl.glNormal3fv(robj.getNormal(verts[baseIdx + normalOffset]),0);
}
if (robj.hasTextureCoords()) {
gl.glTexCoord2fv(robj.getTextureCoord(verts[baseIdx + texcoordOffset]),0);
}
gl.glVertex3fv(robj.getPosition(verts[baseIdx + positionOffset]),0);
baseIdx+=vertexStride;
}
robj.readUnlock();
gl.glEnd();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
if (enableLighting) {
setLightingEnabled(true);
}
}","@Override public void drawVertices(RenderObject robj,DrawMode mode){
  boolean enableLighting=false;
  if (isLightingEnabled() && !robj.hasNormals()) {
    enableLighting=true;
    setLightingEnabled(false);
  }
  maybeUpdateState(gl);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  GL2VersionedObject gvo=null;
  RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.VERTICES,0);
  VertexFingerPrint fingerprint=new VertexFingerPrint(robj.getVersionInfo(),mode);
  boolean compile=true;
  if (useDisplayList) {
    gvo=myGLResources.getVersionedObject(key);
    if (gvo != null) {
      boolean iv=gvo.disposeInvalid(gl);
      if (iv == true) {
        System.out.println(""String_Node_Str"" + gvo);
      }
    }
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
switch (mode) {
case LINES:
      gl.glBegin(GL2.GL_LINES);
    break;
case LINE_LOOP:
  gl.glBegin(GL2.GL_LINE_LOOP);
break;
case LINE_STRIP:
gl.glBegin(GL2.GL_LINE_STRIP);
break;
case POINTS:
gl.glBegin(GL2.GL_POINTS);
break;
case TRIANGLES:
gl.glBegin(GL2.GL_TRIANGLES);
break;
case TRIANGLE_FAN:
gl.glBegin(GL2.GL_TRIANGLE_FAN);
break;
case TRIANGLE_STRIP:
gl.glBegin(GL2.GL_TRIANGLE_STRIP);
break;
default :
gl.glBegin(GL2.GL_POINTS);
break;
}
robj.readLock();
int vertexCount=robj.numVertices();
int positionOffset=robj.getVertexPositionOffset();
int normalOffset=robj.getVertexNormalOffset();
int colorOffset=robj.getVertexColorOffset();
int texcoordOffset=robj.getVertexTextureCoordOffset();
int vertexStride=robj.getVertexStride();
int[] verts=robj.getVertexBuffer();
int baseIdx=0;
for (int i=0; i < vertexCount; ++i) {
if (!selecting && useColors) {
setVertexColor(gl,robj.getColor(verts[baseIdx + colorOffset]),useHSV);
}
if (robj.hasNormals()) {
gl.glNormal3fv(robj.getNormal(verts[baseIdx + normalOffset]),0);
}
if (robj.hasTextureCoords()) {
gl.glTexCoord2fv(robj.getTextureCoord(verts[baseIdx + texcoordOffset]),0);
}
gl.glVertex3fv(robj.getPosition(verts[baseIdx + positionOffset]),0);
baseIdx+=vertexStride;
}
robj.readUnlock();
gl.glEnd();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
if (enableLighting) {
setLightingEnabled(true);
}
}"
70797,"private void maybeCommitViewerState(GL2 gl,ViewerState state){
  if (isSelecting()) {
    if (myCommittedViewerState.lightingEnabled == true) {
      gl.glDisable(GL2.GL_LIGHTING);
      myCommittedViewerState.lightingEnabled=false;
    }
    if (myCommittedViewerState.colorEnabled == false) {
      gl.glColorMask(true,true,true,true);
      myCommittedViewerState.colorEnabled=true;
    }
    if (myCommittedViewerState.transparencyEnabled == true) {
      gl.glDisable(GL.GL_BLEND);
      myCommittedViewerState.transparencyEnabled=false;
    }
  }
 else {
    if (myCommittedViewerState.lightingEnabled != state.lightingEnabled) {
      if (state.lightingEnabled) {
        gl.glEnable(GL2.GL_LIGHTING);
      }
 else {
        gl.glDisable(GL2.GL_LIGHTING);
      }
      myCommittedViewerState.lightingEnabled=state.lightingEnabled;
    }
    if (myCommittedViewerState.colorEnabled != state.colorEnabled) {
      if (state.colorEnabled) {
        gl.glColorMask(true,true,true,true);
      }
 else {
        gl.glColorMask(false,false,false,false);
      }
      myCommittedViewerState.colorEnabled=state.colorEnabled;
    }
    if (myCommittedViewerState.transparencyEnabled != state.transparencyEnabled) {
      if (state.transparencyEnabled) {
        gl.glEnable(GL.GL_BLEND);
      }
 else {
        gl.glDisable(GL.GL_BLEND);
      }
      myCommittedViewerState.transparencyEnabled=state.transparencyEnabled;
    }
  }
  if (myCommittedViewerState.depthEnabled != state.depthEnabled) {
    if (state.depthEnabled) {
      gl.glEnable(GL.GL_DEPTH_TEST);
    }
 else {
      gl.glDisable(GL.GL_DEPTH_TEST);
    }
    myCommittedViewerState.depthEnabled=state.depthEnabled;
  }
  if (myCommittedViewerState.faceMode != state.faceMode) {
switch (state.faceMode) {
case BACK:
      gl.glEnable(GL.GL_CULL_FACE);
    gl.glCullFace(GL.GL_FRONT);
  break;
case FRONT:
gl.glEnable(GL.GL_CULL_FACE);
gl.glCullFace(GL.GL_BACK);
break;
case FRONT_AND_BACK:
gl.glDisable(GL.GL_CULL_FACE);
break;
case NONE:
gl.glEnable(GL.GL_CULL_FACE);
gl.glCullFace(GL.GL_FRONT_AND_BACK);
break;
default :
break;
}
myCommittedViewerState.faceMode=state.faceMode;
}
if (myCommittedViewerState.shading != state.shading) {
switch (state.shading) {
case FLAT:
gl.glShadeModel(GL2.GL_FLAT);
break;
case GOURAUD:
case PHONG:
gl.glShadeModel(GL2.GL_SMOOTH);
break;
case NONE:
gl.glDisable(GL2.GL_LIGHTING);
myCommittedViewerState.lightingEnabled=false;
break;
default :
break;
}
myCommittedViewerState.shading=state.shading;
}
if (myCommittedViewerState.roundedPoints != state.roundedPoints) {
if (state.roundedPoints) {
gl.glEnable(GL2.GL_POINT_SMOOTH);
gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_NICEST);
}
 else {
gl.glDisable(GL2.GL_POINT_SMOOTH);
gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_FASTEST);
}
myCommittedViewerState.roundedPoints=state.roundedPoints;
}
}","private void maybeCommitViewerState(GL2 gl,ViewerState state){
  if (isSelecting()) {
    if (myCommittedViewerState.lightingEnabled == true) {
      gl.glDisable(GL2.GL_LIGHTING);
      myCommittedViewerState.lightingEnabled=false;
      myCommittedViewerState.shading=Shading.NONE;
    }
    if (myCommittedViewerState.colorEnabled == false) {
      gl.glColorMask(true,true,true,true);
      myCommittedViewerState.colorEnabled=true;
    }
    if (myCommittedViewerState.transparencyEnabled == true) {
      gl.glDisable(GL.GL_BLEND);
      myCommittedViewerState.transparencyEnabled=false;
    }
  }
 else {
    if (myCommittedViewerState.lightingEnabled != state.lightingEnabled) {
      if (state.lightingEnabled && state.shading != Shading.NONE) {
        gl.glEnable(GL2.GL_LIGHTING);
        myCommittedViewerState.lightingEnabled=true;
      }
 else {
        gl.glDisable(GL2.GL_LIGHTING);
        myCommittedViewerState.shading=Shading.NONE;
        myCommittedViewerState.lightingEnabled=false;
      }
    }
    if (myCommittedViewerState.colorEnabled != state.colorEnabled) {
      if (state.colorEnabled) {
        gl.glColorMask(true,true,true,true);
      }
 else {
        gl.glColorMask(false,false,false,false);
      }
      myCommittedViewerState.colorEnabled=state.colorEnabled;
    }
    if (myCommittedViewerState.transparencyEnabled != state.transparencyEnabled) {
      if (state.transparencyEnabled) {
        gl.glEnable(GL.GL_BLEND);
      }
 else {
        gl.glDisable(GL.GL_BLEND);
      }
      myCommittedViewerState.transparencyEnabled=state.transparencyEnabled;
    }
  }
  if (myCommittedViewerState.depthEnabled != state.depthEnabled) {
    if (state.depthEnabled) {
      gl.glEnable(GL.GL_DEPTH_TEST);
    }
 else {
      gl.glDisable(GL.GL_DEPTH_TEST);
    }
    myCommittedViewerState.depthEnabled=state.depthEnabled;
  }
  if (myCommittedViewerState.faceMode != state.faceMode) {
switch (state.faceMode) {
case BACK:
      gl.glEnable(GL.GL_CULL_FACE);
    gl.glCullFace(GL.GL_FRONT);
  break;
case FRONT:
gl.glEnable(GL.GL_CULL_FACE);
gl.glCullFace(GL.GL_BACK);
break;
case FRONT_AND_BACK:
gl.glDisable(GL.GL_CULL_FACE);
break;
case NONE:
gl.glEnable(GL.GL_CULL_FACE);
gl.glCullFace(GL.GL_FRONT_AND_BACK);
break;
default :
break;
}
myCommittedViewerState.faceMode=state.faceMode;
}
if (myCommittedViewerState.lightingEnabled && myCommittedViewerState.shading != state.shading) {
switch (state.shading) {
case FLAT:
gl.glShadeModel(GL2.GL_FLAT);
break;
case GOURAUD:
case PHONG:
gl.glShadeModel(GL2.GL_SMOOTH);
break;
case NONE:
gl.glDisable(GL2.GL_LIGHTING);
gl.glShadeModel(GL2.GL_SMOOTH);
myCommittedViewerState.lightingEnabled=false;
break;
default :
break;
}
myCommittedViewerState.shading=state.shading;
}
if (myCommittedViewerState.roundedPoints != state.roundedPoints) {
if (state.roundedPoints) {
gl.glEnable(GL2.GL_POINT_SMOOTH);
gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_NICEST);
}
 else {
gl.glDisable(GL2.GL_POINT_SMOOTH);
gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_FASTEST);
}
myCommittedViewerState.roundedPoints=state.roundedPoints;
}
}"
70798,"private void drawSolidLines(RenderObject robj,int gidx,LineStyle style,float rad){
  int lineCount=robj.numLines(gidx);
  if (lineCount == 0) {
    return;
  }
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  GL2VersionedObject gvo=null;
  RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.LINES,gidx);
  LineFingerPrint fingerprint=new LineFingerPrint(robj.getVersionInfo(),style,mySurfaceResolution,rad);
  boolean compile=true;
  if (useDisplayList) {
    gvo=myGLResources.getVersionedObject(key);
    if (gvo != null) {
      boolean iv=gvo.disposeInvalid(gl);
      if (iv == true) {
        System.out.println(""String_Node_Str"" + gvo);
      }
    }
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    int[] lines=robj.getLines(gidx);
    int lineStride=robj.getLineStride();
switch (style) {
case CYLINDER:
{
        if (!selecting && useColors) {
          for (int i=0; i < lineCount; ++i) {
            int baseIdx=lineStride * i;
            int vidx1=lines[baseIdx];
            int vidx2=lines[baseIdx + 1];
            float[] p0=robj.getVertexPosition(vidx1);
            byte[] c0=robj.getVertexColor(vidx1);
            float[] p1=robj.getVertexPosition(vidx2);
            byte[] c1=robj.getVertexColor(vidx2);
            drawColoredCylinder(gl,mySurfaceResolution,rad,rad,p0,c0,p1,c1,true,useHSV);
          }
        }
 else {
          for (int i=0; i < lineCount; ++i) {
            int baseIdx=lineStride * i;
            int vidx1=lines[baseIdx];
            int vidx2=lines[baseIdx + 1];
            float[] p0=robj.getVertexPosition(vidx1);
            float[] p1=robj.getVertexPosition(vidx2);
            drawCylinder(gl,mySurfaceResolution,rad,rad,p0,p1,true);
          }
        }
        break;
      }
case SPINDLE:
    if (!selecting && useColors) {
      for (int i=0; i < lineCount; ++i) {
        int baseIdx=lineStride * i;
        int vidx1=lines[baseIdx];
        int vidx2=lines[baseIdx + 1];
        float[] p0=robj.getVertexPosition(vidx1);
        byte[] c0=robj.getVertexColor(vidx1);
        float[] p1=robj.getVertexPosition(vidx2);
        byte[] c1=robj.getVertexColor(vidx2);
        drawColoredSpindle(gl,mySurfaceResolution,rad,p0,c0,p1,c1,isHSVColorInterpolationEnabled());
      }
    }
 else {
      for (int i=0; i < lineCount; ++i) {
        int baseIdx=lineStride * i;
        int vidx1=lines[baseIdx];
        int vidx2=lines[baseIdx + 1];
        float[] p0=robj.getVertexPosition(vidx1);
        float[] p1=robj.getVertexPosition(vidx2);
        drawSpindle(gl,mySurfaceResolution,rad,p0,p1);
      }
    }
  break;
case SOLID_ARROW:
{
  float arad=rad * 3;
  float aheight=arad * 2;
  if (!selecting && useColors) {
    for (int i=0; i < lineCount; ++i) {
      int baseIdx=lineStride * i;
      int vidx1=lines[baseIdx];
      int vidx2=lines[baseIdx + 1];
      float[] p0=robj.getVertexPosition(vidx1);
      byte[] c0=robj.getVertexColor(vidx1);
      float[] p1=robj.getVertexPosition(vidx2);
      byte[] c1=robj.getVertexColor(vidx2);
      drawColoredArrow(gl,mySurfaceResolution,rad,arad,aheight,p0,c0,p1,c1,isHSVColorInterpolationEnabled(),true);
    }
  }
 else {
    for (int i=0; i < lineCount; ++i) {
      int baseIdx=lineStride * i;
      int vidx1=lines[baseIdx];
      int vidx2=lines[baseIdx + 1];
      float[] p0=robj.getVertexPosition(vidx1);
      float[] p1=robj.getVertexPosition(vidx2);
      drawArrow(gl,mySurfaceResolution,rad,arad,aheight,p0,p1,true);
    }
  }
  break;
}
default :
}
robj.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
}","private void drawSolidLines(RenderObject robj,int gidx,LineStyle style,float rad){
  int lineCount=robj.numLines(gidx);
  if (lineCount == 0) {
    return;
  }
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && hasVertexColoring());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!myHighlightColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  GL2VersionedObject gvo=null;
  RenderObjectKey key=new RenderObjectKey(robj.getIdentifier(),DrawType.LINES,gidx);
  LineFingerPrint fingerprint=new LineFingerPrint(robj.getVersionInfo(),style,mySurfaceResolution,rad);
  boolean compile=true;
  if (useDisplayList) {
    gvo=myGLResources.getVersionedObject(key);
    if (gvo != null) {
      boolean iv=gvo.disposeInvalid(gl);
      if (iv == true) {
        System.out.println(""String_Node_Str"" + gvo);
      }
    }
    if (gvo == null || gvo.disposeInvalid(gl)) {
      gvo=myGLResources.allocateVersionedObject(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(gvo.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (gvo != null) {
      gvo.beginCompile(gl);
    }
    robj.readLock();
    int[] lines=robj.getLines(gidx);
    int lineStride=robj.getLineStride();
switch (style) {
case CYLINDER:
{
        if (!selecting && useColors) {
          for (int i=0; i < lineCount; ++i) {
            int baseIdx=lineStride * i;
            int vidx1=lines[baseIdx];
            int vidx2=lines[baseIdx + 1];
            float[] p0=robj.getVertexPosition(vidx1);
            byte[] c0=robj.getVertexColor(vidx1);
            float[] p1=robj.getVertexPosition(vidx2);
            byte[] c1=robj.getVertexColor(vidx2);
            drawColoredCylinder(gl,mySurfaceResolution,rad,rad,p0,c0,p1,c1,true,useHSV);
          }
        }
 else {
          for (int i=0; i < lineCount; ++i) {
            int baseIdx=lineStride * i;
            int vidx1=lines[baseIdx];
            int vidx2=lines[baseIdx + 1];
            float[] p0=robj.getVertexPosition(vidx1);
            float[] p1=robj.getVertexPosition(vidx2);
            drawCylinder(gl,mySurfaceResolution,rad,rad,p0,p1,true);
          }
        }
        break;
      }
case SPINDLE:
    if (!selecting && useColors) {
      for (int i=0; i < lineCount; ++i) {
        int baseIdx=lineStride * i;
        int vidx1=lines[baseIdx];
        int vidx2=lines[baseIdx + 1];
        float[] p0=robj.getVertexPosition(vidx1);
        byte[] c0=robj.getVertexColor(vidx1);
        float[] p1=robj.getVertexPosition(vidx2);
        byte[] c1=robj.getVertexColor(vidx2);
        drawColoredSpindle(gl,mySurfaceResolution,rad,p0,c0,p1,c1,isHSVColorInterpolationEnabled());
      }
    }
 else {
      for (int i=0; i < lineCount; ++i) {
        int baseIdx=lineStride * i;
        int vidx1=lines[baseIdx];
        int vidx2=lines[baseIdx + 1];
        float[] p0=robj.getVertexPosition(vidx1);
        float[] p1=robj.getVertexPosition(vidx2);
        drawSpindle(gl,mySurfaceResolution,rad,p0,p1);
      }
    }
  break;
case SOLID_ARROW:
{
  float arad=rad * 3;
  float aheight=arad * 2;
  if (!selecting && useColors) {
    for (int i=0; i < lineCount; ++i) {
      int baseIdx=lineStride * i;
      int vidx1=lines[baseIdx];
      int vidx2=lines[baseIdx + 1];
      float[] p0=robj.getVertexPosition(vidx1);
      byte[] c0=robj.getVertexColor(vidx1);
      float[] p1=robj.getVertexPosition(vidx2);
      byte[] c1=robj.getVertexColor(vidx2);
      drawColoredArrow(gl,mySurfaceResolution,rad,arad,aheight,p0,c0,p1,c1,isHSVColorInterpolationEnabled(),true);
    }
  }
 else {
    for (int i=0; i < lineCount; ++i) {
      int baseIdx=lineStride * i;
      int vidx1=lines[baseIdx];
      int vidx2=lines[baseIdx + 1];
      float[] p0=robj.getVertexPosition(vidx1);
      float[] p1=robj.getVertexPosition(vidx2);
      drawArrow(gl,mySurfaceResolution,rad,arad,aheight,p0,p1,true);
    }
  }
  break;
}
default :
}
robj.readUnlock();
if (gvo != null) {
gvo.endCompile(gl);
gvo.draw(gl);
}
}
 else {
gvo.draw(gl);
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
}"
70799,"private void refreshTextures(GL gl){
  if (textureLoader != null) {
    for (int i=0; i < 3; i++) {
      if (!textureLoader.isTextureValid(textureIds[i])) {
        int nx=myImage.getNumCols();
        int ny=myImage.getNumRows();
        int nz=myImage.getNumSlices();
switch (i) {
case 0:
{
switch (myImage.getPixelType()) {
case BYTE:
case SHORT:
{
                byte[] image=new byte[ny * nz];
                myImage.getPixelsByte(sliceCoordIdxs[0],0,0,1,1,1,1,ny,nz,timeIdx,image,converter);
                int src=GL2.GL_RED;
                int dst=GL2.GL_LUMINANCE;
                int max=0;
                for (int j=0; j < image.length; j++) {
                  int val=0xFF & image[j];
                  if (val > max) {
                    max=val;
                  }
                }
                textureLoader.getTexture(gl,textureIds[i],GL.GL_TEXTURE_2D,image,ny,nz,src,dst);
                break;
              }
case RGB:
{
              byte[] image=new byte[3 * ny * nz];
              myImage.getPixelsRGB(sliceCoordIdxs[0],0,0,1,1,1,1,ny,nz,timeIdx,image,converter);
              int src=GL2.GL_RGB;
              int dst=GL2.GL_RGB;
              textureLoader.getTexture(gl,textureIds[i],GL.GL_TEXTURE_2D,image,ny,nz,src,dst);
              break;
            }
        }
        break;
      }
case 1:
{
switch (myImage.getPixelType()) {
case BYTE:
case SHORT:
{
          byte[] image=new byte[nx * nz];
          myImage.getPixelsByte(0,sliceCoordIdxs[1],0,1,1,1,nx,1,nz,timeIdx,image,converter);
          int src=GL2.GL_RED;
          int dst=GL2.GL_LUMINANCE;
          int max=0;
          for (int j=0; j < image.length; j++) {
            int val=0xFF & image[j];
            if (val > max) {
              max=val;
            }
          }
          textureLoader.getTexture(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,nz,src,dst);
          break;
        }
case RGB:
{
        byte[] image=new byte[3 * nx * nz];
        myImage.getPixelsRGB(0,sliceCoordIdxs[1],0,1,1,1,nx,1,nz,timeIdx,image,converter);
        int src=GL2.GL_RGB;
        int dst=GL2.GL_RGB;
        textureLoader.getTexture(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,nz,src,dst);
        break;
      }
  }
  break;
}
case 2:
{
switch (myImage.getPixelType()) {
case BYTE:
case SHORT:
{
    byte[] image=new byte[nx * ny];
    myImage.getPixelsByte(0,0,sliceCoordIdxs[2],1,1,1,nx,ny,1,timeIdx,image,converter);
    int src=GL2.GL_RED;
    int dst=GL2.GL_LUMINANCE;
    int max=0;
    for (int j=0; j < image.length; j++) {
      int val=0xFF & image[j];
      if (val > max) {
        max=val;
      }
    }
    textureLoader.getTexture(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,ny,src,dst);
    break;
  }
case RGB:
{
  byte[] image=new byte[3 * nx * ny];
  myImage.getPixelsRGB(0,0,sliceCoordIdxs[2],1,1,1,nx,ny,1,timeIdx,image,converter);
  int src=GL2.GL_RGB;
  int dst=GL2.GL_RGB;
  textureLoader.getTexture(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,ny,src,dst);
  break;
}
}
break;
}
}
}
}
}
}","private void refreshTextures(GL gl){
  if (textureLoader != null) {
    for (int i=0; i < 3; i++) {
      if (!textureLoader.isTextureValid(textureIds[i])) {
        int nx=myImage.getNumCols();
        int ny=myImage.getNumRows();
        int nz=myImage.getNumSlices();
switch (i) {
case 0:
{
            if (yz != null) {
              yz.releaseDispose(gl);
            }
            yz=null;
switch (myImage.getPixelType()) {
case BYTE:
case SHORT:
{
                byte[] image=new byte[ny * nz];
                myImage.getPixelsByte(sliceCoordIdxs[0],0,0,1,1,1,1,ny,nz,timeIdx,image,converter);
                int src=GL2.GL_RED;
                int dst=GL2.GL_LUMINANCE;
                int max=0;
                for (int j=0; j < image.length; j++) {
                  int val=0xFF & image[j];
                  if (val > max) {
                    max=val;
                  }
                }
                yz=textureLoader.getTextureAcquired(gl,textureIds[i],GL.GL_TEXTURE_2D,image,ny,nz,src,dst);
                break;
              }
case RGB:
{
              byte[] image=new byte[3 * ny * nz];
              myImage.getPixelsRGB(sliceCoordIdxs[0],0,0,1,1,1,1,ny,nz,timeIdx,image,converter);
              int src=GL2.GL_RGB;
              int dst=GL2.GL_RGB;
              yz=textureLoader.getTextureAcquired(gl,textureIds[i],GL.GL_TEXTURE_2D,image,ny,nz,src,dst);
              break;
            }
        }
        break;
      }
case 1:
{
      if (xz != null) {
        xz.releaseDispose(gl);
      }
      xz=null;
switch (myImage.getPixelType()) {
case BYTE:
case SHORT:
{
          byte[] image=new byte[nx * nz];
          myImage.getPixelsByte(0,sliceCoordIdxs[1],0,1,1,1,nx,1,nz,timeIdx,image,converter);
          int src=GL2.GL_RED;
          int dst=GL2.GL_LUMINANCE;
          int max=0;
          for (int j=0; j < image.length; j++) {
            int val=0xFF & image[j];
            if (val > max) {
              max=val;
            }
          }
          xz=textureLoader.getTextureAcquired(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,nz,src,dst);
          break;
        }
case RGB:
{
        byte[] image=new byte[3 * nx * nz];
        myImage.getPixelsRGB(0,sliceCoordIdxs[1],0,1,1,1,nx,1,nz,timeIdx,image,converter);
        int src=GL2.GL_RGB;
        int dst=GL2.GL_RGB;
        xz=textureLoader.getTextureAcquired(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,nz,src,dst);
        break;
      }
  }
  break;
}
case 2:
{
if (xy != null) {
  xy.releaseDispose(gl);
}
xy=null;
switch (myImage.getPixelType()) {
case BYTE:
case SHORT:
{
    byte[] image=new byte[nx * ny];
    myImage.getPixelsByte(0,0,sliceCoordIdxs[2],1,1,1,nx,ny,1,timeIdx,image,converter);
    int src=GL2.GL_RED;
    int dst=GL2.GL_LUMINANCE;
    int max=0;
    for (int j=0; j < image.length; j++) {
      int val=0xFF & image[j];
      if (val > max) {
        max=val;
      }
    }
    xy=textureLoader.getTextureAcquired(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,ny,src,dst);
    break;
  }
case RGB:
{
  byte[] image=new byte[3 * nx * ny];
  myImage.getPixelsRGB(0,0,sliceCoordIdxs[2],1,1,1,nx,ny,1,timeIdx,image,converter);
  int src=GL2.GL_RGB;
  int dst=GL2.GL_RGB;
  xy=textureLoader.getTextureAcquired(gl,textureIds[i],GL.GL_TEXTURE_2D,image,nx,ny,src,dst);
  break;
}
}
break;
}
}
}
}
}
}"
70800,"@Override public synchronized void render(Renderer renderer,int flags){
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  if (textureLoader == null) {
    textureLoader=new GLTextureLoader();
  }
  refreshTextures(gl);
  RenderProps rprops=getRenderProps();
  if (drawBox) {
    float[] coords0=new float[3];
    float[] coords1=new float[3];
    final int[][] edges={{0,1},{1,2},{2,3},{3,0},{0,4},{1,5},{4,5},{5,6},{6,7},{7,4},{2,6},{3,7}};
    for (int i=0; i < edges.length; i++) {
      boxRenderCoords[edges[i][0]].get(coords0);
      boxRenderCoords[edges[i][1]].get(coords1);
      renderer.drawLine(rprops,coords0,coords1,isSelected());
    }
  }
  if (!renderer.isSelecting()) {
    gl.glDisable(GL2.GL_LIGHTING);
    gl.glEnable(GL2.GL_TEXTURE_2D);
    gl.glTexEnvf(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_MODULATE);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_S,GL.GL_CLAMP_TO_EDGE);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_T,GL2.GL_CLAMP_TO_EDGE);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);
    float alpha=(float)rprops.getAlpha();
    gl.glColor4f(1f,1f,1f,alpha);
  }
  byte[] savedCullFaceEnabled=new byte[1];
  gl.glGetBooleanv(GL2.GL_CULL_FACE,savedCullFaceEnabled,0);
  gl.glDisable(GL2.GL_CULL_FACE);
  for (int i=0; i < 3; i++) {
    if (drawSlice[i]) {
      if (!renderer.isSelecting()) {
        GLTexture tex=textureLoader.getTextureByName(textureIds[i]);
        tex.bind(gl);
      }
      gl.glBegin(GL2.GL_QUADS);
      gl.glTexCoord2d(0,0);
      gl.glVertex3d(sliceRenderCoords[i][0].x,sliceRenderCoords[i][0].y,sliceRenderCoords[i][0].z);
      gl.glTexCoord2d(1,0);
      gl.glVertex3d(sliceRenderCoords[i][1].x,sliceRenderCoords[i][1].y,sliceRenderCoords[i][1].z);
      gl.glTexCoord2d(1,1);
      gl.glVertex3d(sliceRenderCoords[i][2].x,sliceRenderCoords[i][2].y,sliceRenderCoords[i][2].z);
      gl.glTexCoord2d(0,1);
      gl.glVertex3d(sliceRenderCoords[i][3].x,sliceRenderCoords[i][3].y,sliceRenderCoords[i][3].z);
      gl.glEnd();
    }
  }
  if (savedCullFaceEnabled[0] != 0) {
    gl.glEnable(GL2.GL_CULL_FACE);
  }
  if (!renderer.isSelecting()) {
    gl.glDisable(GL2.GL_TEXTURE_2D);
    gl.glEnable(GL2.GL_LIGHTING);
  }
}","@Override public synchronized void render(Renderer renderer,int flags){
  if (!(renderer instanceof GL2Viewer)) {
    return;
  }
  GL2Viewer viewer=(GL2Viewer)renderer;
  GL2 gl=viewer.getGL2();
  if (textureLoader == null) {
    textureLoader=new GLTextureLoader();
  }
  refreshTextures(gl);
  RenderProps rprops=getRenderProps();
  if (drawBox) {
    float[] coords0=new float[3];
    float[] coords1=new float[3];
    final int[][] edges={{0,1},{1,2},{2,3},{3,0},{0,4},{1,5},{4,5},{5,6},{6,7},{7,4},{2,6},{3,7}};
    for (int i=0; i < edges.length; i++) {
      boxRenderCoords[edges[i][0]].get(coords0);
      boxRenderCoords[edges[i][1]].get(coords1);
      renderer.drawLine(rprops,coords0,coords1,isSelected());
    }
  }
  if (!renderer.isSelecting()) {
    gl.glDisable(GL2.GL_LIGHTING);
    gl.glEnable(GL2.GL_TEXTURE_2D);
    gl.glTexEnvf(GL2.GL_TEXTURE_ENV,GL2.GL_TEXTURE_ENV_MODE,GL2.GL_MODULATE);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_S,GL.GL_CLAMP_TO_EDGE);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_T,GL2.GL_CLAMP_TO_EDGE);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_LINEAR);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_LINEAR);
    float alpha=(float)rprops.getAlpha();
    gl.glColor4f(1f,1f,1f,alpha);
  }
  byte[] savedCullFaceEnabled=new byte[1];
  gl.glGetBooleanv(GL2.GL_CULL_FACE,savedCullFaceEnabled,0);
  gl.glDisable(GL2.GL_CULL_FACE);
  for (int i=0; i < 3; i++) {
    if (drawSlice[i]) {
      if (!renderer.isSelecting()) {
        GLTexture tex=textureLoader.getTextureByNameAcquired(textureIds[i]);
        tex.bind(gl);
      }
      gl.glBegin(GL2.GL_QUADS);
      gl.glTexCoord2d(0,0);
      gl.glVertex3d(sliceRenderCoords[i][0].x,sliceRenderCoords[i][0].y,sliceRenderCoords[i][0].z);
      gl.glTexCoord2d(1,0);
      gl.glVertex3d(sliceRenderCoords[i][1].x,sliceRenderCoords[i][1].y,sliceRenderCoords[i][1].z);
      gl.glTexCoord2d(1,1);
      gl.glVertex3d(sliceRenderCoords[i][2].x,sliceRenderCoords[i][2].y,sliceRenderCoords[i][2].z);
      gl.glTexCoord2d(0,1);
      gl.glVertex3d(sliceRenderCoords[i][3].x,sliceRenderCoords[i][3].y,sliceRenderCoords[i][3].z);
      gl.glEnd();
    }
  }
  if (savedCullFaceEnabled[0] != 0) {
    gl.glEnable(GL2.GL_CULL_FACE);
  }
  if (!renderer.isSelecting()) {
    gl.glDisable(GL2.GL_TEXTURE_2D);
    gl.glEnable(GL2.GL_LIGHTING);
  }
}"
70801,"@Override public GL2DisplayList acquire(){
  System.out.println(""String_Node_Str"" + listId + ""String_Node_Str""+ this+ ""String_Node_Str"");
  return (GL2DisplayList)super.acquire();
}","@Override public GL2DisplayList acquire(){
  return (GL2DisplayList)super.acquire();
}"
70802,"@Override public void dispose(){
  if (displayList != null) {
    System.out.println(""String_Node_Str"" + this + ""String_Node_Str"");
    displayList.release();
    displayList=null;
  }
}","@Override public void dispose(GL2 gl){
  if (displayList != null) {
    displayList.releaseDispose(gl);
    displayList=null;
  }
}"
70803,"public GL2Object(GL2DisplayList displayList){
  this.displayList=displayList.acquire();
  System.out.println(""String_Node_Str"" + this + ""String_Node_Str"");
}","public GL2Object(GL2DisplayList displayList){
  this.displayList=displayList.acquire();
}"
70804,"public PrimitiveKey(PrimitiveType type,int resolution,boolean capped){
  this.type=type;
  this.resolution=resolution;
switch (type) {
case CONE:
case CYLINDER:
    this.capped=capped;
  break;
case SPHERE:
case SPINDLE:
this.capped=false;
break;
}
}","public PrimitiveKey(PrimitiveType type,int resolution,boolean capped){
  this.type=type;
switch (type) {
case CONE:
case CYLINDER:
    this.resolution=resolution;
  this.capped=capped;
break;
case SPHERE:
case SPINDLE:
this.resolution=resolution;
this.capped=false;
break;
case CUBE:
this.capped=false;
this.resolution=0;
break;
}
}"
70805,"@Deprecated public int getNormalSetIdx(){
  return normalSetIdx;
}","@Deprecated public int getNormalSetIdx(){
  return 0;
}"
70806,"@Deprecated public int getPositionSetIdx(){
  return positionSetIdx;
}","@Deprecated public int getPositionSetIdx(){
  return 0;
}"
70807,"@Deprecated public int getTextureCoordSetIdx(){
  return textureSetIdx;
}","@Deprecated public int getTextureCoordSetIdx(){
  return 0;
}"
70808,"@Deprecated public int numNormalSets(){
  return numNormalSets;
}","@Deprecated public int numNormalSets(){
  if (hasNormals()) {
    return 1;
  }
  return 0;
}"
70809,"@Deprecated public int numTextureCoordSets(){
  return numTextureSets;
}","@Deprecated public int numTextureCoordSets(){
  if (hasTextureCoords()) {
    return 1;
  }
  return 0;
}"
70810,"@Deprecated public int numPositionSets(){
  return numPositionSets;
}","@Deprecated public int numPositionSets(){
  if (hasPositions()) {
    return 1;
  }
  return 0;
}"
70811,"@Deprecated public int getColorSetIdx(){
  return colorSetIdx;
}","@Deprecated public int getColorSetIdx(){
  return 0;
}"
70812,"/** 
 * Retrieves the normal at the supplied index.  If the returned normal is modified, then   {@link #notifyNormalsModified()} mustbe called.
 * @param nidx normal index
 * @return normal {x,y,z}
 */
public float[] getNormal(int nidx){
  if (nidx < 0) {
    return null;
  }
  return normals.get(nidx);
}","@Deprecated public float[] getNormal(int gidx,int idx){
  return getNormal(idx);
}"
70813,"@Deprecated public int numColorSets(){
  return numColorSets;
}","@Deprecated public int numColorSets(){
  if (hasColors()) {
    return 1;
  }
  return 0;
}"
70814,"/** 
 * Retrieves the texture coordinate at the supplied index.  If the returned texture coordinate is modified, then   {@link #notifyTextureCoordsModified()} must be manually called.
 * @param tidx position index
 * @return texture coordinate {x,y}
 */
public float[] getTextureCoord(int tidx){
  if (tidx < 0) {
    return null;
  }
  return texcoords.get(tidx);
}","@Deprecated public float[] getTextureCoord(int gidx,int idx){
  return getTextureCoord(idx);
}"
70815,"private void maybeGrowAdjustVertices(int cap){
  boolean vHasPositions=((vertexBufferMask & VERTEX_POSITIONS) != 0);
  boolean vHasNormals=((vertexBufferMask & VERTEX_POSITIONS) != 0);
  boolean vHasColors=((vertexBufferMask & VERTEX_POSITIONS) != 0);
  boolean vHasTexcoords=((vertexBufferMask & VERTEX_POSITIONS) != 0);
  boolean rHasPositions=hasPositions();
  boolean rHasNormals=hasNormals();
  boolean rHasColors=hasColors();
  boolean rHasTexcoords=hasTextureCoords();
  if (cap - vertexCapacity > 0) {
    cap=vertexCapacity + (vertexCapacity >> 1);
  }
  if (cap - vertexCapacity < 0) {
    cap=vertexCapacity;
  }
  int vcap=cap * vertexStride;
  if (vHasPositions != rHasPositions || vHasNormals != rHasNormals || vHasColors != rHasColors || vHasTexcoords != rHasTexcoords) {
    int newVertexStride=0;
    int newPositionOffset=-1;
    int newNormalOffset=-1;
    int newColorOffset=-1;
    int newTexcoordOffset=-1;
    byte newVertexBufferMask=0;
    if (rHasPositions) {
      newPositionOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_POSITIONS;
    }
    if (rHasNormals) {
      newNormalOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_NORMALS;
    }
    if (rHasColors) {
      newColorOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_COLORS;
    }
    if (rHasTexcoords) {
      newTexcoordOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_TEXCOORDS;
    }
    int[] newVerts=new int[cap * newVertexStride];
    Arrays.fill(newVerts,-1);
    if (vHasPositions) {
      int nidx=newPositionOffset;
      int oidx=vertexPositionOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    if (vHasNormals) {
      int nidx=newNormalOffset;
      int oidx=vertexNormalOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    if (vHasColors) {
      int nidx=newColorOffset;
      int oidx=vertexColorOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    if (vHasNormals) {
      int nidx=newTexcoordOffset;
      int oidx=vertexTexcoordOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    vertexStride=newVertexStride;
    vertexBufferMask=newVertexBufferMask;
    vertexPositionOffset=newPositionOffset;
    vertexNormalOffset=newNormalOffset;
    vertexColorOffset=newColorOffset;
    vertexTexcoordOffset=newTexcoordOffset;
    vertices=newVerts;
  }
 else   if (vcap > vertices.length) {
    vertices=Arrays.copyOf(vertices,vcap);
    int vstart=numVertices * vertexStride;
    for (int i=vstart; i < vcap; ++i) {
      vertices[i]=-1;
    }
  }
  vertexCapacity=cap;
}","private void maybeGrowAdjustVertices(int cap){
  boolean vHasPositions=((vertexBufferMask & VERTEX_POSITIONS) != 0);
  boolean vHasNormals=((vertexBufferMask & VERTEX_NORMALS) != 0);
  boolean vHasColors=((vertexBufferMask & VERTEX_COLORS) != 0);
  boolean vHasTexcoords=((vertexBufferMask & VERTEX_TEXCOORDS) != 0);
  boolean rHasPositions=hasPositions();
  boolean rHasNormals=hasNormals();
  boolean rHasColors=hasColors();
  boolean rHasTexcoords=hasTextureCoords();
  int ncap=vertexCapacity;
  if (ncap - cap < 0) {
    ncap=vertexCapacity + (vertexCapacity >> 1);
  }
  if (ncap - cap < 0) {
    ncap=cap;
  }
  int vcap=ncap * vertexStride;
  if (vHasPositions != rHasPositions || vHasNormals != rHasNormals || vHasColors != rHasColors || vHasTexcoords != rHasTexcoords) {
    int newVertexStride=0;
    int newPositionOffset=-1;
    int newNormalOffset=-1;
    int newColorOffset=-1;
    int newTexcoordOffset=-1;
    byte newVertexBufferMask=0;
    if (rHasPositions) {
      newPositionOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_POSITIONS;
    }
    if (rHasNormals) {
      newNormalOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_NORMALS;
    }
    if (rHasColors) {
      newColorOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_COLORS;
    }
    if (rHasTexcoords) {
      newTexcoordOffset=newVertexStride++;
      newVertexBufferMask|=VERTEX_TEXCOORDS;
    }
    int[] newVerts=new int[ncap * newVertexStride];
    Arrays.fill(newVerts,-1);
    if (vHasPositions) {
      int nidx=newPositionOffset;
      int oidx=vertexPositionOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    if (vHasNormals) {
      int nidx=newNormalOffset;
      int oidx=vertexNormalOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    if (vHasColors) {
      int nidx=newColorOffset;
      int oidx=vertexColorOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    if (vHasNormals) {
      int nidx=newTexcoordOffset;
      int oidx=vertexTexcoordOffset;
      for (int i=0; i < numVertices; ++i) {
        newVerts[nidx]=vertices[oidx];
        nidx+=newVertexStride;
        oidx+=vertexStride;
      }
    }
    vertexStride=newVertexStride;
    vertexBufferMask=newVertexBufferMask;
    vertexPositionOffset=newPositionOffset;
    vertexNormalOffset=newNormalOffset;
    vertexColorOffset=newColorOffset;
    vertexTexcoordOffset=newTexcoordOffset;
    vertices=newVerts;
  }
 else   if (vcap > vertices.length) {
    vertices=Arrays.copyOf(vertices,vcap);
    int vstart=numVertices * vertexStride;
    for (int i=vstart; i < vcap; ++i) {
      vertices[i]=-1;
    }
  }
  vertexCapacity=cap;
}"
70816,"/** 
 * Retrieves the color at the supplied index.  If the returned color is modified, then   {@link #notifyColorsModified()} must be manually called.
 * @param cidx color index
 * @return color {red, green, blue, alpha}
 */
public byte[] getColor(int cidx){
  if (cidx < 0) {
    return null;
  }
  return colors.get(cidx);
}","@Deprecated public byte[] getColor(int gidx,int idx){
  return getColor(idx);
}"
70817,"/** 
 * Retrieves the position at the supplied index.  If the returned position is modified, then   {@link #notifyPositionsModified()} must be manually called.
 * @param pidx position index
 * @return position {x,y,z}
 */
public float[] getPosition(int pidx){
  if (pidx < 0) {
    return null;
  }
  return positions.get(pidx);
}","@Deprecated public float[] getPosition(int gidx,int idx){
  return getPosition(idx);
}"
70818,"/** 
 * Creates a clone of this mesh.
 */
public MeshBase clone(){
  MeshBase mesh=null;
  try {
    mesh=(MeshBase)super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalErrorException(""String_Node_Str"" + e);
  }
  mesh.myVertices=new ArrayList<Vertex3d>();
  for (int i=0; i < myVertices.size(); i++) {
    mesh.addVertex(myVertices.get(i).pnt);
  }
  mesh.setMeshToWorld(XMeshToWorld);
  mesh.myIndexOffsets=null;
  if (myNormals != null) {
    mesh.myNormals=new ArrayList<Vector3d>();
    for (int i=0; i < myNormals.size(); i++) {
      mesh.myNormals.add(new Vector3d(myNormals.get(i)));
    }
  }
  if (myNormalIndices != null) {
    mesh.myNormalIndices=Arrays.copyOf(myNormalIndices,myNormalIndices.length);
  }
  mesh.myRenderNormalsValidP=false;
  if (myTextureCoords != null) {
    mesh.myTextureCoords=new ArrayList<Vector3d>();
    for (int i=0; i < myTextureCoords.size(); i++) {
      mesh.myTextureCoords.add(new Vector3d(myTextureCoords.get(i)));
    }
    mesh.myTextureIndices=Arrays.copyOf(myTextureIndices,myTextureIndices.length);
  }
  mesh.myVertexColoringP=myVertexColoringP;
  mesh.myFeatureColoringP=myFeatureColoringP;
  if (myColors != null) {
    mesh.myColors=new ArrayList<float[]>();
    for (int i=0; i < myColors.size(); i++) {
      mesh.myColors.add(copyColor(myColors.get(i)));
    }
    int[] colorIndices=getColorIndices();
    mesh.myColorIndices=Arrays.copyOf(colorIndices,colorIndices.length);
  }
  if (myRenderProps != null) {
    mesh.setRenderProps(myRenderProps);
  }
 else {
    mesh.myRenderProps=null;
  }
  mesh.setFixed(isFixed());
  mesh.myDisplayListValid=false;
  mesh.setRenderBuffered(isRenderBuffered());
  mesh.myLocalMinCoords=new Point3d();
  mesh.myLocalMaxCoords=new Point3d();
  mesh.myLocalBoundsValid=false;
  mesh.myWorldMinCoords=new Point3d();
  mesh.myWorldMaxCoords=new Point3d();
  mesh.myWorldBoundsValid=false;
  mesh.setName(getName());
  return mesh;
}","/** 
 * Creates a clone of this mesh.
 */
public MeshBase clone(){
  MeshBase mesh=null;
  try {
    mesh=(MeshBase)super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalErrorException(""String_Node_Str"" + e);
  }
  mesh.myVertices=new ArrayList<Vertex3d>();
  for (int i=0; i < myVertices.size(); i++) {
    mesh.addVertex(myVertices.get(i).pnt);
  }
  mesh.XMeshToWorld=new RigidTransform3d(XMeshToWorld);
  mesh.myIndexOffsets=null;
  if (myNormals != null) {
    mesh.myNormals=new ArrayList<Vector3d>();
    for (int i=0; i < myNormals.size(); i++) {
      mesh.myNormals.add(new Vector3d(myNormals.get(i)));
    }
  }
  if (myNormalIndices != null) {
    mesh.myNormalIndices=Arrays.copyOf(myNormalIndices,myNormalIndices.length);
  }
  mesh.myRenderNormalsValidP=false;
  if (myTextureCoords != null) {
    mesh.myTextureCoords=new ArrayList<Vector3d>();
    for (int i=0; i < myTextureCoords.size(); i++) {
      mesh.myTextureCoords.add(new Vector3d(myTextureCoords.get(i)));
    }
    mesh.myTextureIndices=Arrays.copyOf(myTextureIndices,myTextureIndices.length);
  }
  mesh.myVertexColoringP=myVertexColoringP;
  mesh.myFeatureColoringP=myFeatureColoringP;
  if (myColors != null) {
    mesh.myColors=new ArrayList<float[]>();
    for (int i=0; i < myColors.size(); i++) {
      mesh.myColors.add(copyColor(myColors.get(i)));
    }
    int[] colorIndices=getColorIndices();
    mesh.myColorIndices=Arrays.copyOf(colorIndices,colorIndices.length);
  }
  if (myRenderProps != null) {
    mesh.setRenderProps(myRenderProps);
  }
 else {
    mesh.myRenderProps=null;
  }
  mesh.setFixed(isFixed());
  mesh.myDisplayListValid=false;
  mesh.setRenderBuffered(isRenderBuffered());
  mesh.myLocalMinCoords=new Point3d();
  mesh.myLocalMaxCoords=new Point3d();
  mesh.myLocalBoundsValid=false;
  mesh.myWorldMinCoords=new Point3d();
  mesh.myWorldMaxCoords=new Point3d();
  mesh.myWorldBoundsValid=false;
  mesh.setName(getName());
  return mesh;
}"
70819,"private void drawPoints(Renderer renderer,RenderProps props,boolean selected){
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,selected);
switch (props.getPointStyle()) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        renderer.drawPoints(myRob,PointStyle.POINT,size);
      }
      break;
    }
case SPHERE:
{
    double rad=props.getPointRadius();
    if (rad > 0) {
      renderer.drawPoints(myRob,PointStyle.SPHERE,rad);
    }
    break;
  }
}
renderer.setShading(savedShading);
}","private void drawPoints(Renderer renderer,int gidx,RenderProps props,boolean selected){
  Shading savedShading=renderer.setPointShading(props);
  renderer.setPointColoring(props,selected);
switch (props.getPointStyle()) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        renderer.drawPoints(myRob,gidx,PointStyle.POINT,size);
      }
      break;
    }
case SPHERE:
{
    double rad=props.getPointRadius();
    if (rad > 0) {
      renderer.drawPoints(myRob,gidx,PointStyle.SPHERE,rad);
    }
    break;
  }
}
renderer.setShading(savedShading);
}"
70820,"public void render(Renderer renderer,int flags){
  RenderProps props=myRenderProps;
  if (renderer.isSelecting()) {
    PointStyle style=props.getPointStyle();
    if (style == PointStyle.POINT) {
      int size=props.getPointSize();
      if (size > 0) {
        renderer.setPointSize(size);
      }
 else {
        return;
      }
    }
    for (int i=0; i < size(); i++) {
      Point pnt=get(i);
      if (pnt.getRenderProps() == null && renderer.isSelectable(pnt)) {
        float[] v0=pnt.myRenderCoords;
        renderer.beginSelectionQuery(i);
switch (style) {
case POINT:
{
            renderer.drawPoint(v0);
            break;
          }
case SPHERE:
{
          renderer.drawSphere(v0,props.getPointRadius());
          break;
        }
    }
    renderer.endSelectionQuery();
  }
}
if (style == PointStyle.POINT) {
  renderer.setPointSize(1);
}
}
 else if (myRob != null) {
int numReg=myRob.numPoints(REG_GRP);
int numSel=myRob.numPoints(SEL_GRP);
if (numReg > 0) {
  myRob.pointGroup(REG_GRP);
  drawPoints(renderer,props,false);
}
if (numSel > 0) {
  myRob.pointGroup(SEL_GRP);
  drawPoints(renderer,props,true);
}
}
}","public void render(Renderer renderer,int flags){
  RenderProps props=myRenderProps;
  if (renderer.isSelecting()) {
    PointStyle style=props.getPointStyle();
    if (style == PointStyle.POINT) {
      int size=props.getPointSize();
      if (size > 0) {
        renderer.setPointSize(size);
      }
 else {
        return;
      }
    }
    for (int i=0; i < size(); i++) {
      Point pnt=get(i);
      if (pnt.getRenderProps() == null && renderer.isSelectable(pnt)) {
        float[] v0=pnt.myRenderCoords;
        renderer.beginSelectionQuery(i);
switch (style) {
case POINT:
{
            renderer.drawPoint(v0);
            break;
          }
case SPHERE:
{
          renderer.drawSphere(v0,props.getPointRadius());
          break;
        }
    }
    renderer.endSelectionQuery();
  }
}
if (style == PointStyle.POINT) {
  renderer.setPointSize(1);
}
}
 else if (myRob != null) {
int numReg=myRob.numPoints(REG_GRP);
int numSel=myRob.numPoints(SEL_GRP);
if (numReg > 0) {
  drawPoints(renderer,REG_GRP,props,false);
}
if (numSel > 0) {
  drawPoints(renderer,SEL_GRP,props,true);
}
}
}"
70821,"public void maybeUpdateMaterials(GL2 gl){
  if (myCurrentMaterialModified && !isSelecting()) {
    if (mySelectedColorActive) {
      mySelectedColor[3]=myCurrentMaterial.getAlpha();
      gl.glColor4fv(mySelectedColor,0);
      myCurrentMaterial.apply(gl);
      gl.glMaterialfv(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE,mySelectedColor,0);
    }
 else {
      gl.glColor4fv(myCurrentMaterial.getDiffuse(),0);
      myCurrentMaterial.apply(gl);
      if (myBackColor != null) {
        gl.glMaterialfv(GL2.GL_BACK,GL2.GL_AMBIENT_AND_DIFFUSE,myBackColor,0);
      }
    }
    myCurrentMaterialModified=false;
  }
}","public void maybeUpdateMaterials(GL2 gl){
  if (myCurrentMaterialModified) {
    if (isSelecting()) {
      gl.glColor4fv(mySelectingColor,0);
      myCurrentMaterial.apply(gl);
      gl.glMaterialfv(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE,mySelectingColor,0);
    }
 else {
      if (mySelectedColorActive) {
        mySelectedColor[3]=myCurrentMaterial.getAlpha();
        gl.glColor4fv(mySelectedColor,0);
        myCurrentMaterial.apply(gl);
        gl.glMaterialfv(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE,mySelectedColor,0);
      }
 else {
        gl.glColor4fv(myCurrentMaterial.getDiffuse(),0);
        myCurrentMaterial.apply(gl);
        if (myBackColor != null) {
          gl.glMaterialfv(GL2.GL_BACK,GL2.GL_AMBIENT_AND_DIFFUSE,myBackColor,0);
        }
      }
    }
    myCurrentMaterialModified=false;
  }
}"
70822,"public void bindInstancedVertices(GL3 gl,int gidx){
  int vstart=2 * pointGroupOffsets[gidx];
  int loc=pposAttr.getLocation();
  if (positionInfo != null) {
    GL3AttributeStorage storage=positionPutter.storage();
    vbos[positionInfo.vboIndex].bind(gl);
    gl.glEnableVertexAttribArray(loc);
    gl.glVertexAttribPointer(loc,storage.size(),storage.getGLType(),storage.isNormalized(),positionInfo.stride,positionInfo.offset + vstart * positionInfo.stride);
    gl.glVertexAttribDivisor(loc,1);
  }
  loc=pclrAttr.getLocation();
  if (colorInfo != null) {
    GL3AttributeStorage storage=colorPutter.storage();
    vbos[colorInfo.vboIndex].bind(gl);
    gl.glEnableVertexAttribArray(loc);
    gl.glVertexAttribPointer(loc,storage.size(),storage.getGLType(),storage.isNormalized(),colorInfo.stride,colorInfo.offset + vstart * colorInfo.stride);
    gl.glVertexAttribDivisor(loc,1);
  }
}","public void bindInstancedVertices(GL3 gl,int gidx){
  int vstart=pointGroupOffsets[gidx];
  int loc=pposAttr.getLocation();
  if (positionInfo != null) {
    GL3AttributeStorage storage=positionPutter.storage();
    vbos[positionInfo.vboIndex].bind(gl);
    gl.glEnableVertexAttribArray(loc);
    gl.glVertexAttribPointer(loc,storage.size(),storage.getGLType(),storage.isNormalized(),positionInfo.stride,positionInfo.offset + vstart * positionInfo.stride);
    gl.glVertexAttribDivisor(loc,1);
  }
  loc=pclrAttr.getLocation();
  if (colorInfo != null) {
    GL3AttributeStorage storage=colorPutter.storage();
    vbos[colorInfo.vboIndex].bind(gl);
    gl.glEnableVertexAttribArray(loc);
    gl.glVertexAttribPointer(loc,storage.size(),storage.getGLType(),storage.isNormalized(),colorInfo.stride,colorInfo.offset + vstart * colorInfo.stride);
    gl.glVertexAttribDivisor(loc,1);
  }
}"
70823,"protected GLShaderProgram getProgram(GL3 gl,RenderObjectState robj){
  if (isSelecting()) {
    return getProgram(gl);
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  Shading shading=isLightingEnabled() ? getShading() : Shading.NONE;
  builder.setLighting(shading);
  if (shading != Shading.NONE) {
    builder.setVertexNormals(true);
  }
  if (isTextureMappingEnabled()) {
    if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled() && !mySelectedColorActive) {
      builder.enableColorMap(true);
      builder.setVertexTextures(true);
      builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
      builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
      builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
      builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
    }
    if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
      builder.enableNormalMap(true);
      builder.setVertexTextures(true);
    }
    if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
      builder.enableBumpMap(true);
      builder.setVertexTextures(true);
    }
  }
  if (!robj.hasColors() || !isVertexColoringEnabled() || mySelectedColorActive) {
    builder.setColorInterpolation(ColorInterpolation.NONE);
    builder.setVertexColors(false);
  }
 else {
    if (isHSVColorInterpolationEnabled()) {
      builder.setColorInterpolation(ColorInterpolation.HSV);
    }
 else {
      builder.setColorInterpolation(ColorInterpolation.RGB);
    }
    builder.setVertexColorMixing(getVertexColorMixing());
    builder.setVertexColors(true);
  }
  return myProgManager.getProgram(gl,builder.build());
}","protected GLShaderProgram getProgram(GL3 gl,RenderObjectState robj){
  if (isSelecting()) {
    return myProgManager.getSelectionProgram(gl,RenderMode.TRIANGLES);
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  Shading shading=isLightingEnabled() ? getShading() : Shading.NONE;
  builder.setLighting(shading);
  if (shading != Shading.NONE) {
    builder.setVertexNormals(true);
  }
  if (isTextureMappingEnabled()) {
    if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled() && !mySelectedColorActive) {
      builder.enableColorMap(true);
      builder.setVertexTextures(true);
      builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
      builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
      builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
      builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
    }
    if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
      builder.enableNormalMap(true);
      builder.setVertexTextures(true);
    }
    if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
      builder.enableBumpMap(true);
      builder.setVertexTextures(true);
    }
  }
  if (!robj.hasColors() || !isVertexColoringEnabled() || mySelectedColorActive) {
    builder.setColorInterpolation(ColorInterpolation.NONE);
    builder.setVertexColors(false);
  }
 else {
    if (isHSVColorInterpolationEnabled()) {
      builder.setColorInterpolation(ColorInterpolation.HSV);
    }
 else {
      builder.setColorInterpolation(ColorInterpolation.RGB);
    }
    builder.setVertexColorMixing(getVertexColorMixing());
    builder.setVertexColors(true);
  }
  return myProgManager.getProgram(gl,builder.build());
}"
70824,"protected GLShaderProgram getColorProgram(GL3 gl,Shading shading,boolean hasNormals,ColorInterpolation cinterp){
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  if (!isSelecting()) {
    if (!isLightingEnabled()) {
      shading=Shading.NONE;
    }
    builder.setLighting(shading);
    if (shading != Shading.NONE) {
      builder.setVertexNormals(true);
    }
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
      if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
        builder.enableNormalMap(true);
        builder.setVertexTextures(true);
      }
      if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
        builder.enableBumpMap(true);
        builder.setVertexTextures(true);
      }
    }
    if (isVertexColoringEnabled()) {
      builder.setVertexColorMixing(getVertexColorMixing());
      builder.setColorInterpolation(cinterp);
      builder.setVertexColors(true);
      builder.mixVertexColorDiffuse(true);
      builder.mixVertexColorSpecular(true);
      builder.mixVertexColorEmission(true);
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}","protected GLShaderProgram getColorProgram(GL3 gl,Shading shading,boolean hasNormals,ColorInterpolation cinterp){
  if (isSelecting()) {
    return myProgManager.getSelectionProgram(gl,RenderMode.TRIANGLES);
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  if (!isSelecting()) {
    if (!isLightingEnabled()) {
      shading=Shading.NONE;
    }
    builder.setLighting(shading);
    if (shading != Shading.NONE) {
      builder.setVertexNormals(true);
    }
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
      if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
        builder.enableNormalMap(true);
        builder.setVertexTextures(true);
      }
      if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
        builder.enableBumpMap(true);
        builder.setVertexTextures(true);
      }
    }
    if (isVertexColoringEnabled()) {
      builder.setVertexColorMixing(getVertexColorMixing());
      builder.setColorInterpolation(cinterp);
      builder.setVertexColors(true);
      builder.mixVertexColorDiffuse(true);
      builder.mixVertexColorSpecular(true);
      builder.mixVertexColorEmission(true);
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}"
70825,"protected GLShaderProgram getBasicLineProgram(GL3 gl,boolean hasNormals,boolean hasColors,boolean hasTextures){
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  if (!isSelecting()) {
    Shading shading=Shading.NONE;
    builder.setLighting(shading);
    builder.setVertexNormals(hasNormals);
    if (hasColors) {
      builder.setVertexColors(hasColors);
      builder.setVertexColorMixing(getVertexColorMixing());
    }
    if (hasTextures && isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}","protected GLShaderProgram getBasicLineProgram(GL3 gl,boolean hasNormals,boolean hasColors,boolean hasTextures){
  if (isSelecting()) {
    return myProgManager.getSelectionProgram(gl,RenderMode.LINES);
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  if (!isSelecting()) {
    Shading shading=Shading.NONE;
    builder.setLighting(shading);
    builder.setVertexNormals(hasNormals);
    if (hasColors) {
      builder.setVertexColors(hasColors);
      builder.setVertexColorMixing(getVertexColorMixing());
    }
    if (hasTextures && isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}"
70826,"protected GLShaderProgram getBasicPointProgram(GL3 gl){
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  builder.setRoundPoints(true);
  if (!isSelecting()) {
    Shading shading=Shading.NONE;
    builder.setLighting(shading);
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}","protected GLShaderProgram getBasicPointProgram(GL3 gl){
  if (isSelecting()) {
    return myProgManager.getSelectionProgram(gl,RenderMode.POINTS);
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  builder.setRoundPoints(true);
  if (!isSelecting()) {
    Shading shading=Shading.NONE;
    builder.setLighting(shading);
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}"
70827,"protected GLShaderProgram getLinesProgram(GL3 gl,RenderObjectState robj,LineStyle style){
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  builder.setInstancedRendering(InstancedRendering.LINES);
  if (style == LineStyle.SOLID_ARROW) {
    builder.setLineScaleOffset(true);
  }
  if (!isSelecting()) {
    Shading shading=isLightingEnabled() ? getShading() : Shading.NONE;
    builder.setLighting(shading);
    if (shading != Shading.NONE) {
      builder.setVertexNormals(true);
    }
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled() && !mySelectedColorActive) {
        builder.enableColorMap(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.setVertexTextures(true);
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
      if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
        builder.enableNormalMap(true);
        builder.setVertexTextures(true);
      }
      if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
        builder.enableBumpMap(true);
        builder.setVertexTextures(true);
      }
    }
    if (!robj.hasColors() || !isVertexColoringEnabled() || mySelectedColorActive) {
      builder.setColorInterpolation(ColorInterpolation.NONE);
      builder.setVertexColors(false);
    }
 else {
      if (isHSVColorInterpolationEnabled()) {
        builder.setColorInterpolation(ColorInterpolation.HSV);
      }
 else {
        builder.setColorInterpolation(ColorInterpolation.RGB);
      }
      builder.setVertexColorMixing(getVertexColorMixing());
      builder.setVertexColors(true);
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}","protected GLShaderProgram getLinesProgram(GL3 gl,RenderObjectState robj,LineStyle style){
  if (isSelecting()) {
    if (style == LineStyle.LINE) {
      return myProgManager.getSelectionProgram(gl,RenderMode.LINES);
    }
 else {
      return myProgManager.getSelectionProgram(gl,RenderMode.INSTANCED_LINES);
    }
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  builder.setInstancedRendering(InstancedRendering.LINES);
  if (style == LineStyle.SOLID_ARROW) {
    builder.setLineScaleOffset(true);
  }
  if (!isSelecting()) {
    Shading shading=isLightingEnabled() ? getShading() : Shading.NONE;
    builder.setLighting(shading);
    if (shading != Shading.NONE) {
      builder.setVertexNormals(true);
    }
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled() && !mySelectedColorActive) {
        builder.enableColorMap(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.setVertexTextures(true);
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
      if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
        builder.enableNormalMap(true);
        builder.setVertexTextures(true);
      }
      if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
        builder.enableBumpMap(true);
        builder.setVertexTextures(true);
      }
    }
    if (!robj.hasColors() || !isVertexColoringEnabled() || mySelectedColorActive) {
      builder.setColorInterpolation(ColorInterpolation.NONE);
      builder.setVertexColors(false);
    }
 else {
      if (isHSVColorInterpolationEnabled()) {
        builder.setColorInterpolation(ColorInterpolation.HSV);
      }
 else {
        builder.setColorInterpolation(ColorInterpolation.RGB);
      }
      builder.setVertexColorMixing(getVertexColorMixing());
      builder.setVertexColors(true);
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}"
70828,"protected void maybeUpdateMaterials(GL3 gl){
  if (myCurrentMaterialModified && !selectEnabled) {
    if (mySelectedColorActive) {
      mySelectedColor[3]=myCurrentMaterial.getAlpha();
      myProgManager.setMaterials(gl,myCurrentMaterial,mySelectedColor,myCurrentMaterial,mySelectedColor);
    }
 else {
      myProgManager.setMaterials(gl,myCurrentMaterial,myCurrentMaterial.getDiffuse(),myCurrentMaterial,myBackColor);
    }
    myCurrentMaterialModified=false;
  }
}","protected void maybeUpdateMaterials(GL3 gl){
  if (myCurrentMaterialModified) {
    if (isSelecting()) {
      myProgManager.setMaterials(gl,myCurrentMaterial,mySelectingColor,myCurrentMaterial,mySelectingColor);
    }
 else {
      if (mySelectedColorActive) {
        mySelectedColor[3]=myCurrentMaterial.getAlpha();
        myProgManager.setMaterials(gl,myCurrentMaterial,mySelectedColor,myCurrentMaterial,mySelectedColor);
      }
 else {
        myProgManager.setMaterials(gl,myCurrentMaterial,myCurrentMaterial.getDiffuse(),myCurrentMaterial,myBackColor);
      }
    }
    myCurrentMaterialModified=false;
  }
}"
70829,"protected GLShaderProgram getBasicProgram(GL3 gl){
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  if (!isSelecting()) {
    Shading shading=Shading.NONE;
    builder.setLighting(shading);
    if (shading != Shading.NONE) {
      builder.setVertexNormals(true);
    }
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}","protected GLShaderProgram getBasicProgram(GL3 gl){
  if (isSelecting()) {
    return myProgManager.getSelectionProgram(gl,RenderMode.TRIANGLES);
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
  if (!isSelecting()) {
    Shading shading=Shading.NONE;
    builder.setLighting(shading);
    if (shading != Shading.NONE) {
      builder.setVertexNormals(true);
    }
    if (isTextureMappingEnabled()) {
      if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled()) {
        builder.enableColorMap(true);
        builder.setVertexTextures(true);
        builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
        builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
        builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
        builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
      }
    }
  }
  return myProgManager.getProgram(gl,builder.build());
}"
70830,"protected GLShaderProgram getPointsProgram(GL3 gl,PointStyle style,RenderObjectState robj){
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
switch (style) {
case SPHERE:
case CUBE:
    builder.setInstancedRendering(InstancedRendering.POINTS);
  builder.setVertexNormals(true);
break;
case POINT:
default :
builder.setInstancedRendering(InstancedRendering.NONE);
builder.setRoundPoints(true);
if (robj.hasNormals()) {
builder.setVertexNormals(true);
}
 else {
builder.setVertexNormals(false);
}
break;
}
if (!isSelecting()) {
Shading shading=isLightingEnabled() ? getShading() : Shading.NONE;
if (style == PointStyle.POINT) {
shading=Shading.NONE;
}
builder.setLighting(shading);
if (isTextureMappingEnabled()) {
if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled() && !mySelectedColorActive) {
builder.enableColorMap(true);
builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
builder.setVertexTextures(true);
builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
}
if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
builder.enableNormalMap(true);
builder.setVertexTextures(true);
}
if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
builder.enableBumpMap(true);
builder.setVertexTextures(true);
}
}
if (!robj.hasColors() || !isVertexColoringEnabled() || mySelectedColorActive) {
builder.setColorInterpolation(ColorInterpolation.NONE);
builder.setVertexColors(false);
}
 else {
if (isHSVColorInterpolationEnabled()) {
builder.setColorInterpolation(ColorInterpolation.HSV);
}
 else {
builder.setColorInterpolation(ColorInterpolation.RGB);
}
builder.setVertexColorMixing(getVertexColorMixing());
builder.setVertexColors(true);
}
}
return myProgManager.getProgram(gl,builder.build());
}","protected GLShaderProgram getPointsProgram(GL3 gl,PointStyle style,RenderObjectState robj){
  if (isSelecting()) {
    if (style == PointStyle.POINT) {
      return myProgManager.getSelectionProgram(gl,RenderMode.POINTS);
    }
 else {
      return myProgManager.getSelectionProgram(gl,RenderMode.INSTANCED_POINTS);
    }
  }
  GLSLInfoBuilder builder=new GLSLInfoBuilder();
  builder.setNumLights(myProgManager.numLights());
  builder.setNumClipPlanes(myProgManager.numClipPlanes());
switch (style) {
case SPHERE:
case CUBE:
    builder.setInstancedRendering(InstancedRendering.POINTS);
  builder.setVertexNormals(true);
break;
case POINT:
default :
builder.setInstancedRendering(InstancedRendering.NONE);
builder.setRoundPoints(true);
if (robj.hasNormals()) {
builder.setVertexNormals(true);
}
 else {
builder.setVertexNormals(false);
}
break;
}
if (!isSelecting()) {
Shading shading=isLightingEnabled() ? getShading() : Shading.NONE;
if (style == PointStyle.POINT) {
shading=Shading.NONE;
}
builder.setLighting(shading);
if (isTextureMappingEnabled()) {
if (myCurrentColorMapProps != null && myCurrentColorMapProps.isEnabled() && !mySelectedColorActive) {
builder.enableColorMap(true);
builder.setTextureColorMixing(myCurrentColorMapProps.getTextureColorMixing());
builder.setVertexTextures(true);
builder.mixTextureColorDiffuse(myCurrentColorMapProps.getDiffuseColoring());
builder.mixTextureColorSpecular(myCurrentColorMapProps.getSpecularColoring());
builder.mixTextureColorEmission(myCurrentColorMapProps.getDiffuseColoring());
}
if (myCurrentNormalMapProps != null && myCurrentNormalMapProps.isEnabled()) {
builder.enableNormalMap(true);
builder.setVertexTextures(true);
}
if (myCurrentBumpMapProps != null && myCurrentBumpMapProps.isEnabled()) {
builder.enableBumpMap(true);
builder.setVertexTextures(true);
}
}
if (!robj.hasColors() || !isVertexColoringEnabled() || mySelectedColorActive) {
builder.setColorInterpolation(ColorInterpolation.NONE);
builder.setVertexColors(false);
}
 else {
if (isHSVColorInterpolationEnabled()) {
builder.setColorInterpolation(ColorInterpolation.HSV);
}
 else {
builder.setColorInterpolation(ColorInterpolation.RGB);
}
builder.setVertexColorMixing(getVertexColorMixing());
builder.setVertexColors(true);
}
}
return myProgManager.getProgram(gl,builder.build());
}"
70831,"@Override public void drawSolidArrow(float[] pnt0,float[] pnt1,double rad,boolean capped){
  if (rad < Double.MIN_NORMAL) {
    return;
  }
  int nslices=getSurfaceResolution();
  double dx=pnt1[0] - pnt0[0];
  double dy=pnt1[1] - pnt0[1];
  double dz=pnt1[2] - pnt0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  double arrowRad=3 * rad;
  double arrowLen=Math.min(2 * arrowRad,len / 2);
  double lenFrac=1 - arrowLen / len;
  float[] coordsMid=new float[]{pnt0[0] + (float)(lenFrac * dx),pnt0[1] + (float)(lenFrac * dy),pnt0[2] + (float)(lenFrac * dz)};
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(pnt0,pnt1);
  mulModelMatrix(lineRot);
  scaleModelMatrix(rad,rad,len - arrowLen);
  maybeUpdateState(gl);
  GLShaderProgram prog=getProgram(gl);
  prog.use(gl);
  GL3Object cylinder=myPrimitiveManager.getCylinder(gl,nslices,capped);
  cylinder.draw(gl);
  popModelMatrix();
  pushModelMatrix();
  lineRot.setTranslation(coordsMid[0],coordsMid[1],coordsMid[2]);
  mulModelMatrix(lineRot);
  scaleModelMatrix(arrowRad,arrowRad,arrowLen);
  maybeUpdateState(gl);
  GL3Object cone=myPrimitiveManager.getCone(gl,nslices,capped);
  cone.draw(gl);
  gl.glUseProgram(0);
  popModelMatrix();
}","@Override public void drawSolidArrow(float[] pnt0,float[] pnt1,double rad,boolean capped){
  if (rad < Double.MIN_NORMAL) {
    return;
  }
  int nslices=getSurfaceResolution();
  double dx=pnt1[0] - pnt0[0];
  double dy=pnt1[1] - pnt0[1];
  double dz=pnt1[2] - pnt0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  double arrowRad=3 * rad;
  double arrowLen=Math.min(2 * arrowRad,len / 2);
  double lenFrac=1 - arrowLen / len;
  float[] coordsMid=new float[]{pnt0[0] + (float)(lenFrac * dx),pnt0[1] + (float)(lenFrac * dy),pnt0[2] + (float)(lenFrac * dz)};
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(pnt0,pnt1);
  mulModelMatrix(lineRot);
  scaleModelMatrix(rad,rad,len - arrowLen);
  maybeUpdateState(gl);
  GLShaderProgram prog=getProgram(gl);
  prog.use(gl);
  GL3Object cylinder=myPrimitiveManager.getCylinder(gl,nslices,capped);
  cylinder.draw(gl);
  popModelMatrix();
  pushModelMatrix();
  lineRot.setTranslation(coordsMid[0],coordsMid[1],coordsMid[2]);
  mulModelMatrix(lineRot);
  scaleModelMatrix(arrowRad,arrowRad,arrowLen);
  maybeUpdateState(gl);
  GL3Object cone=myPrimitiveManager.getCone(gl,nslices,capped);
  cone.draw(gl);
  popModelMatrix();
}"
70832,"@Override public void render(Renderer renderer,int flags){
  if (!isSelectable() && renderer.isSelecting()) {
    return;
  }
  FaceRenderProps rprops=(FaceRenderProps)getRenderProps();
  Rectangle2D box=myTextRenderer.getBounds(myText);
  float fTextSize=(float)(myTextSize / getFontSize());
  double t=0.75 * myTextSize;
  double vc=0.25 * myTextSize;
  double w=fTextSize * box.getWidth();
  int sw=renderer.getScreenWidth();
  int sh=renderer.getScreenHeight();
  renderPos.setZero();
switch (hAlignment) {
case CENTRE:
    renderPos.add(-w / 2,0);
  break;
case RIGHT:
renderPos.add(-w,0);
break;
default :
break;
}
switch (vAlignment) {
case CENTRE:
renderPos.add(0,-vc);
break;
case TOP:
renderPos.add(0,-t);
break;
case BOTTOM:
break;
}
double rad=Math.toRadians(myOrientation);
double ctheta=Math.cos(rad);
double stheta=Math.sin(rad);
renderPos.rotate(ctheta,stheta,renderPos);
if (myPos.x <= 0) {
renderPos.x+=myNormPos.x * sw;
}
 else {
renderPos.x+=myPos.x;
}
if (myPos.y <= 0) {
renderPos.y+=myNormPos.y * sh;
}
 else {
renderPos.y+=myPos.y;
}
myTransform.R.m00=ctheta;
myTransform.R.m10=stheta;
myTransform.R.m01=-stheta;
myTransform.R.m11=ctheta;
myTransform.p.set(renderPos.x,renderPos.y,0);
if (isSelected()) {
renderer.getSelectionColor(rgb);
}
 else {
rprops.getFaceColor(rgb);
}
boolean saved2d=renderer.is2DRendering();
if (!saved2d) {
renderer.begin2DRendering(sw,sh);
}
renderer.pushModelMatrix();
GLSupport.transformToGLMatrix(GLMatrix,myTransform);
renderer.mulModelMatrix(myTransform);
myTextRenderer.begin3DRendering();
myTextRenderer.setColor(rgb[0],rgb[1],rgb[2],(float)rprops.getAlpha());
myTextRenderer.draw3D(myText,0,0,0,fTextSize);
myTextRenderer.end3DRendering();
renderer.popModelMatrix();
if (!saved2d) {
renderer.end2DRendering();
}
}","@Override public void render(Renderer renderer,int flags){
  if (!isSelectable() && renderer.isSelecting()) {
    return;
  }
  FaceRenderProps rprops=(FaceRenderProps)getRenderProps();
  Rectangle2D box=myTextRenderer.getBounds(myText);
  float fTextSize=(float)(myTextSize / getFontSize());
  double t=0.75 * myTextSize;
  double vc=0.25 * myTextSize;
  double w=fTextSize * box.getWidth();
  int sw=renderer.getScreenWidth();
  int sh=renderer.getScreenHeight();
  renderPos.setZero();
switch (hAlignment) {
case CENTRE:
    renderPos.add(-w / 2,0);
  break;
case RIGHT:
renderPos.add(-w,0);
break;
default :
break;
}
switch (vAlignment) {
case CENTRE:
renderPos.add(0,-vc);
break;
case TOP:
renderPos.add(0,-t);
break;
case BOTTOM:
break;
}
double rad=Math.toRadians(myOrientation);
double ctheta=Math.cos(rad);
double stheta=Math.sin(rad);
renderPos.rotate(ctheta,stheta,renderPos);
if (myPos.x <= 0) {
renderPos.x+=myNormPos.x * sw;
}
 else {
renderPos.x+=myPos.x;
}
if (myPos.y <= 0) {
renderPos.y+=myNormPos.y * sh;
}
 else {
renderPos.y+=myPos.y;
}
myTransform.R.m00=ctheta;
myTransform.R.m10=stheta;
myTransform.R.m01=-stheta;
myTransform.R.m11=ctheta;
myTransform.p.set(renderPos.x,renderPos.y,0);
if (isSelected()) {
renderer.getHighlightColor(rgb);
}
 else {
rprops.getFaceColor(rgb);
}
boolean saved2d=renderer.is2DRendering();
if (!saved2d) {
renderer.begin2DRendering(sw,sh);
}
renderer.pushModelMatrix();
GLSupport.transformToGLMatrix(GLMatrix,myTransform);
renderer.mulModelMatrix(myTransform);
myTextRenderer.begin3DRendering();
myTextRenderer.setColor(rgb[0],rgb[1],rgb[2],(float)rprops.getAlpha());
myTextRenderer.draw3D(myText,0,0,0,fTextSize);
myTextRenderer.end3DRendering();
renderer.popModelMatrix();
if (!saved2d) {
renderer.end2DRendering();
}
}"
70833,"@Override public void render(Renderer renderer,int flags){
  if (!isSelectable() && renderer.isSelecting()) {
    return;
  }
  RenderProps rprops=getRenderProps();
  rprops.getFaceColor(rgb);
  if (isSelected()) {
    renderer.getSelectionColor(rgb);
  }
  float fTextSize=(float)(myTextSize / getFontSize());
  Rectangle2D box=myTextRenderer.getBounds(myText);
  double w=box.getWidth() * fTextSize;
  double t=myTextSize * 0.75;
  double vc=myTextSize * 0.25;
  rEye.invert(renderer.getViewMatrix().R);
  if (followEye) {
    rEye.getColumn(0,xdir);
  }
 else {
    xdir[0]=1;
    xdir[1]=0;
    xdir[2]=0;
  }
  renderPos.setZero();
switch (hAlignment) {
case CENTRE:
    renderPos.add(-xdir[0] * w / 2,-xdir[1] * w / 2,-xdir[2] * w / 2);
  break;
case RIGHT:
renderPos.add(-xdir[0] * w,-xdir[1] * w,-xdir[2] * w);
break;
default :
break;
}
if (followEye) {
rEye.getColumn(1,xdir);
}
 else {
xdir[0]=0;
xdir[1]=1;
xdir[2]=0;
}
switch (vAlignment) {
case CENTRE:
renderPos.add(-xdir[0] * vc,-xdir[1] * vc,-xdir[2] * vc);
break;
case TOP:
renderPos.add(-xdir[0] * t,-xdir[1] * t,-xdir[2] * t);
break;
default :
}
myTransform.setRotation(myOrientation);
if (followEye) {
myTransform.R.mul(rEye,myTransform.R);
renderPos.inverseTransform(rEye);
}
renderPos.transform(myTransform.R);
renderPos.add(myPos);
myTransform.p.set(renderPos);
renderer.pushModelMatrix();
renderer.mulModelMatrix(myTransform);
myTextRenderer.begin3DRendering();
myTextRenderer.setColor(rgb[0],rgb[1],rgb[2],(float)rprops.getAlpha());
myTextRenderer.draw3D(myText,0,0,0,fTextSize);
myTextRenderer.end3DRendering();
renderer.popModelMatrix();
}","@Override public void render(Renderer renderer,int flags){
  if (!isSelectable() && renderer.isSelecting()) {
    return;
  }
  RenderProps rprops=getRenderProps();
  rprops.getFaceColor(rgb);
  if (isSelected()) {
    renderer.getHighlightColor(rgb);
  }
  float fTextSize=(float)(myTextSize / getFontSize());
  Rectangle2D box=myTextRenderer.getBounds(myText);
  double w=box.getWidth() * fTextSize;
  double t=myTextSize * 0.75;
  double vc=myTextSize * 0.25;
  rEye.invert(renderer.getViewMatrix().R);
  if (followEye) {
    rEye.getColumn(0,xdir);
  }
 else {
    xdir[0]=1;
    xdir[1]=0;
    xdir[2]=0;
  }
  renderPos.setZero();
switch (hAlignment) {
case CENTRE:
    renderPos.add(-xdir[0] * w / 2,-xdir[1] * w / 2,-xdir[2] * w / 2);
  break;
case RIGHT:
renderPos.add(-xdir[0] * w,-xdir[1] * w,-xdir[2] * w);
break;
default :
break;
}
if (followEye) {
rEye.getColumn(1,xdir);
}
 else {
xdir[0]=0;
xdir[1]=1;
xdir[2]=0;
}
switch (vAlignment) {
case CENTRE:
renderPos.add(-xdir[0] * vc,-xdir[1] * vc,-xdir[2] * vc);
break;
case TOP:
renderPos.add(-xdir[0] * t,-xdir[1] * t,-xdir[2] * t);
break;
default :
}
myTransform.setRotation(myOrientation);
if (followEye) {
myTransform.R.mul(rEye,myTransform.R);
renderPos.inverseTransform(rEye);
}
renderPos.transform(myTransform.R);
renderPos.add(myPos);
myTransform.p.set(renderPos);
renderer.pushModelMatrix();
renderer.mulModelMatrix(myTransform);
myTextRenderer.begin3DRendering();
myTextRenderer.setColor(rgb[0],rgb[1],rgb[2],(float)rprops.getAlpha());
myTextRenderer.draw3D(myText,0,0,0,fTextSize);
myTextRenderer.end3DRendering();
renderer.popModelMatrix();
}"
70834,"protected void drawEdges(Renderer renderer,RenderObject r,RenderProps props,int group){
  if (r.numLines(group) > 0) {
    r.lineGroup(group);
    int width=props.getLineWidth();
    if (width > 0) {
      boolean selected=(group == SEL_GRP);
      Shading savedShading=renderer.setShading(Shading.NONE);
      renderer.setLineColoring(props,selected);
      renderer.drawLines(r,LineStyle.LINE,width);
      renderer.setShading(savedShading);
    }
  }
}","protected void drawEdges(Renderer renderer,RenderObject r,RenderProps props,int group){
  if (r.numLines(group) > 0) {
    int width=props.getLineWidth();
    if (width > 0) {
      boolean selected=(group == SEL_GRP);
      Shading savedShading=renderer.setShading(Shading.NONE);
      renderer.setLineColoring(props,selected);
      renderer.drawLines(r,group,LineStyle.LINE,width);
      renderer.setShading(savedShading);
    }
  }
}"
70835,"public void render(Renderer renderer,int flags){
  RenderProps props=myRenderProps;
  if (renderer.isSelecting()) {
    PointStyle style=props.getPointStyle();
    if (style == PointStyle.POINT) {
      int size=props.getPointSize();
      if (size > 0) {
        renderer.setPointSize(size);
      }
 else {
        return;
      }
    }
    for (int i=0; i < size(); i++) {
      Point pnt=get(i);
      if (pnt.getRenderProps() == null && renderer.isSelectable(pnt)) {
        float[] v0=pnt.myRenderCoords;
        renderer.beginSelectionQuery(i);
switch (style) {
case POINT:
{
            renderer.drawPoint(v0);
            break;
          }
case SPHERE:
{
          renderer.drawSphere(v0,props.getPointRadius());
          break;
        }
    }
    renderer.endSelectionQuery();
  }
}
if (style == PointStyle.POINT) {
  renderer.setPointSize(1);
}
}
 else if (myRob != null) {
int numReg=myRob.numPoints(REG_GRP);
int numSel=myRob.numPoints(SEL_GRP);
if (numReg > 0) {
  drawPoints(renderer,REG_GRP,props,false);
}
if (numSel > 0) {
  drawPoints(renderer,SEL_GRP,props,true);
}
}
}","public void render(Renderer renderer,int flags){
  RenderProps props=myRenderProps;
  if (renderer.isSelecting()) {
    PointStyle style=props.getPointStyle();
    if (style == PointStyle.POINT) {
      int size=props.getPointSize();
      if (size > 0) {
        renderer.setPointSize(size);
      }
 else {
        return;
      }
    }
    for (int i=0; i < size(); i++) {
      Point pnt=get(i);
      if (pnt.getRenderProps() == null && renderer.isSelectable(pnt)) {
        float[] v0=pnt.myRenderCoords;
        renderer.beginSelectionQuery(i);
switch (style) {
case POINT:
{
            renderer.drawPoint(v0);
            break;
          }
case SPHERE:
{
          renderer.drawSphere(v0,props.getPointRadius());
          break;
        }
    }
    renderer.endSelectionQuery();
  }
}
if (style == PointStyle.POINT) {
  renderer.setPointSize(1);
}
}
 else if (myRob != null) {
int numReg=myRob.numPoints(REG_GRP);
int numSel=myRob.numPoints(SEL_GRP);
if (numSel > 0) {
  drawPoints(renderer,SEL_GRP,props,true);
}
if (numReg > 0) {
  drawPoints(renderer,REG_GRP,props,false);
}
}
}"
70836,"public void doDisplay(GLAutoDrawable drawable,int flags){
  GL2 gl=drawable.getGL().getGL2();
  if (resetViewVolume && resizeEnabled) {
    resetViewVolume();
    resetViewVolume=false;
  }
  if (isSelecting()) {
    invalidateProjectionMatrix();
  }
  gl.glPushMatrix();
  if (isSelecting()) {
    gl.glClearColor(0f,0f,0f,0f);
  }
 else {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
  GLSupport.transformToGLMatrix(GLMatrix,viewMatrix);
  gl.glLoadMatrixd(GLMatrix,0);
  viewMatrixValidP=true;
  setupLights(gl);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  maybeUpdateState(gl);
  int nclips=0;
  int clipIdx=GL2.GL_CLIP_PLANE0;
  for (  GLClipPlane cp : myClipPlanes) {
    if (cp.isClippingEnabled()) {
      cp.getPlaneValues(myClipPlaneValues);
      myClipPlaneValues[3]+=cp.getOffset();
      gl.glClipPlane(clipIdx,myClipPlaneValues,0);
      gl.glEnable(clipIdx);
      clipIdx++;
      nclips++;
      if (nclips >= maxClipPlanes) {
        break;
      }
      if (cp.isSlicingEnabled()) {
        myClipPlaneValues[0]=-myClipPlaneValues[0];
        myClipPlaneValues[1]=-myClipPlaneValues[1];
        myClipPlaneValues[2]=-myClipPlaneValues[2];
        myClipPlaneValues[3]=-myClipPlaneValues[3] + 2 * cp.getOffset();
        gl.glClipPlane(clipIdx,myClipPlaneValues,0);
        gl.glEnable(clipIdx);
        clipIdx++;
        nclips++;
        if (nclips >= maxClipPlanes) {
          break;
        }
      }
    }
  }
  gl.glPushMatrix();
  int qid=0;
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
    if (myExternalRenderList != null) {
      qid=myExternalRenderList.renderOpaque(this,qid,flags);
    }
  }
  if (!isSelecting()) {
    enableTransparency(gl);
  }
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderTransparent(this,qid,flags);
  }
  if (myExternalRenderList != null) {
synchronized (myExternalRenderList) {
      qid=myExternalRenderList.renderTransparent(this,qid,flags);
    }
  }
  disableTransparency(gl);
  gl.glPopMatrix();
  for (int i=GL2.GL_CLIP_PLANE0; i < clipIdx; ++i) {
    gl.glDisable(i);
  }
  begin2DRendering(width,height);
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque2d(this,qid,0);
  }
  if (myExternalRenderList != null) {
synchronized (myExternalRenderList) {
      qid=myExternalRenderList.renderOpaque2d(this,qid,0);
    }
  }
  enableTransparency(gl);
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderTransparent2d(this,qid,0);
  }
  if (myExternalRenderList != null) {
synchronized (myExternalRenderList) {
      qid=myExternalRenderList.renderTransparent2d(this,qid,0);
    }
  }
  disableTransparency(gl);
  end2DRendering();
  gl.glPopMatrix();
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(gl);
    }
  }
  gl.glFlush();
}","public void doDisplay(GLAutoDrawable drawable,int flags){
  GL2 gl=drawable.getGL().getGL2();
  if (resetViewVolume && resizeEnabled) {
    resetViewVolume(gl);
    resetViewVolume=false;
  }
  if (isSelecting()) {
    invalidateProjectionMatrix();
  }
  gl.glPushMatrix();
  if (isSelecting()) {
    gl.glClearColor(0f,0f,0f,0f);
  }
 else {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  gl.glClear(GL2.GL_COLOR_BUFFER_BIT | GL2.GL_DEPTH_BUFFER_BIT);
  GLSupport.transformToGLMatrix(GLMatrix,viewMatrix);
  gl.glLoadMatrixd(GLMatrix,0);
  viewMatrixValidP=true;
  setupLights(gl);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  maybeUpdateState(gl);
  int nclips=0;
  int clipIdx=GL2.GL_CLIP_PLANE0;
  for (  GLClipPlane cp : myClipPlanes) {
    if (cp.isClippingEnabled()) {
      cp.getPlaneValues(myClipPlaneValues);
      myClipPlaneValues[3]+=cp.getOffset();
      gl.glClipPlane(clipIdx,myClipPlaneValues,0);
      gl.glEnable(clipIdx);
      clipIdx++;
      nclips++;
      if (nclips >= maxClipPlanes) {
        break;
      }
      if (cp.isSlicingEnabled()) {
        myClipPlaneValues[0]=-myClipPlaneValues[0];
        myClipPlaneValues[1]=-myClipPlaneValues[1];
        myClipPlaneValues[2]=-myClipPlaneValues[2];
        myClipPlaneValues[3]=-myClipPlaneValues[3] + 2 * cp.getOffset();
        gl.glClipPlane(clipIdx,myClipPlaneValues,0);
        gl.glEnable(clipIdx);
        clipIdx++;
        nclips++;
        if (nclips >= maxClipPlanes) {
          break;
        }
      }
    }
  }
  gl.glPushMatrix();
  int qid=0;
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
    if (myExternalRenderList != null) {
      qid=myExternalRenderList.renderOpaque(this,qid,flags);
    }
  }
  if (!isSelecting()) {
    enableTransparency(gl);
  }
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderTransparent(this,qid,flags);
  }
  if (myExternalRenderList != null) {
synchronized (myExternalRenderList) {
      qid=myExternalRenderList.renderTransparent(this,qid,flags);
    }
  }
  disableTransparency(gl);
  gl.glPopMatrix();
  for (int i=GL2.GL_CLIP_PLANE0; i < clipIdx; ++i) {
    gl.glDisable(i);
  }
  begin2DRendering(width,height);
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderOpaque2d(this,qid,0);
  }
  if (myExternalRenderList != null) {
synchronized (myExternalRenderList) {
      qid=myExternalRenderList.renderOpaque2d(this,qid,0);
    }
  }
  enableTransparency(gl);
synchronized (myInternalRenderList) {
    qid=myInternalRenderList.renderTransparent2d(this,qid,0);
  }
  if (myExternalRenderList != null) {
synchronized (myExternalRenderList) {
      qid=myExternalRenderList.renderTransparent2d(this,qid,0);
    }
  }
  disableTransparency(gl);
  end2DRendering();
  gl.glPopMatrix();
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(gl);
    }
  }
  gl.glFlush();
}"
70837,"@Override public void drawPoints(RenderObject robj,int gidx,PointStyle style,double rad){
switch (style) {
case POINT:
{
      float fold=getPointSize();
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setPointSize(frad);
        changed=true;
      }
      drawPoints(robj,gidx);
      if (changed) {
        setPointSize(fold);
      }
      break;
    }
case SPHERE:
  drawSpheres(robj,gidx,rad);
break;
}
}","@Override public void drawPoints(RenderObject robj,int gidx,PointStyle style,double rad){
switch (style) {
case POINT:
{
      float fold=getPointSize(gl);
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setPointSize(gl,frad);
        changed=true;
      }
      drawPoints(robj,gidx);
      if (changed) {
        setPointSize(gl,fold);
      }
      break;
    }
case SPHERE:
  drawSpheres(robj,gidx,rad);
break;
}
}"
70838,"@Override public void init(GLAutoDrawable drawable){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + gl);
    System.out.println(""String_Node_Str"");
    GLContext context=drawable.getContext();
    String contextHC=Integer.toHexString(System.identityHashCode(context));
    System.out.println(""String_Node_Str"" + context.getClass().getName() + ""String_Node_Str""+ contextHC+ ""String_Node_Str""+ context.isShared()+ ""String_Node_Str"");
  }
  gl.setSwapInterval(1);
  if (gl.isExtensionAvailable(""String_Node_Str"")) {
    gl.glEnable(GL2.GL_MULTISAMPLE);
    myMultiSampleEnabled=true;
  }
  int[] buff=new int[1];
  gl.glGetIntegerv(GL2.GL_MAX_CLIP_PLANES,buff,0);
  maxClipPlanes=buff[0];
  setFaceStyle(FaceStyle.FRONT);
  gl.glEnable(GL2.GL_DEPTH_TEST);
  gl.glClearDepth(1.0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_LOCAL_VIEWER,lmodel_local,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_TWO_SIDE,lmodel_twoside,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_AMBIENT,lmodel_ambient,0);
  gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1);
  gl.glEnable(GL2.GL_LIGHTING);
  gl.glEnable(GL2.GL_NORMALIZE);
  setLightingEnabled(true);
  setDepthEnabled(true);
  setColorEnabled(true);
  setVertexColoringEnabled(true);
  setTextureMappingEnabled(true);
  setFaceStyle(FaceStyle.FRONT);
  setShading(Shading.PHONG);
  setGammaCorrectionEnabled(false);
  lightManager.setMaxLights(getMaxLights(gl));
  setupLights(gl);
  if (!isSelecting()) {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  resetViewVolume();
  invalidateModelMatrix();
  invalidateProjectionMatrix();
  invalidateViewMatrix();
  buildInternalRenderList();
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
  }
}","@Override public void init(GLAutoDrawable drawable){
  this.drawable=drawable;
  this.gl=drawable.getGL().getGL2();
  if (DEBUG) {
    System.out.println(""String_Node_Str"" + gl);
    System.out.println(""String_Node_Str"");
    GLContext context=drawable.getContext();
    String contextHC=Integer.toHexString(System.identityHashCode(context));
    System.out.println(""String_Node_Str"" + context.getClass().getName() + ""String_Node_Str""+ contextHC+ ""String_Node_Str""+ context.isShared()+ ""String_Node_Str"");
  }
  gl.setSwapInterval(1);
  if (gl.isExtensionAvailable(""String_Node_Str"")) {
    gl.glEnable(GL2.GL_MULTISAMPLE);
    myMultiSampleEnabled=true;
  }
  int[] buff=new int[1];
  gl.glGetIntegerv(GL2.GL_MAX_CLIP_PLANES,buff,0);
  maxClipPlanes=buff[0];
  setFaceStyle(FaceStyle.FRONT);
  gl.glEnable(GL2.GL_DEPTH_TEST);
  gl.glClearDepth(1.0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_LOCAL_VIEWER,lmodel_local,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_TWO_SIDE,lmodel_twoside,0);
  gl.glLightModelfv(GL2.GL_LIGHT_MODEL_AMBIENT,lmodel_ambient,0);
  gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1);
  gl.glEnable(GL2.GL_LIGHTING);
  gl.glEnable(GL2.GL_NORMALIZE);
  setLightingEnabled(true);
  setDepthEnabled(true);
  setColorEnabled(true);
  setVertexColoringEnabled(true);
  setTextureMappingEnabled(true);
  setFaceStyle(FaceStyle.FRONT);
  setShading(Shading.PHONG);
  setGammaCorrectionEnabled(false);
  lightManager.setMaxLights(getMaxLights(gl));
  setupLights(gl);
  if (!isSelecting()) {
    gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  }
  resetViewVolume(gl);
  invalidateModelMatrix();
  invalidateProjectionMatrix();
  invalidateViewMatrix();
  buildInternalRenderList();
  if (DEBUG) {
    System.out.println(""String_Node_Str"");
  }
}"
70839,"@Override public void drawLines(RenderObject robj,int gidx,LineStyle style,double rad){
  maybeUpdateState(gl);
switch (style) {
case LINE:
{
      float fold=getLineWidth();
      float frad=(float)rad;
      boolean changeWidth=false;
      if (fold != frad) {
        setLineWidth(frad);
        changeWidth=true;
      }
      drawLines(robj,gidx);
      if (changeWidth) {
        setLineWidth(fold);
      }
      break;
    }
case CYLINDER:
case SPINDLE:
case SOLID_ARROW:
  drawSolidLines(robj,gidx,style,(float)rad);
break;
}
}","@Override public void drawLines(RenderObject robj,int gidx,LineStyle style,double rad){
  maybeUpdateState(gl);
switch (style) {
case LINE:
{
      float fold=getLineWidth(gl);
      float frad=(float)rad;
      boolean changeWidth=false;
      if (fold != frad) {
        setLineWidth(gl,frad);
        changeWidth=true;
      }
      drawLines(robj,gidx);
      if (changeWidth) {
        setLineWidth(gl,fold);
      }
      break;
    }
case CYLINDER:
case SPINDLE:
case SOLID_ARROW:
  drawSolidLines(robj,gidx,style,(float)rad);
break;
}
}"
70840,"public void drawLines(GL3 gl,int mode,int gidx){
  int vstart=lineGroupOffsets[gidx];
  int vcount=lineGroupOffsets[gidx + 1] - vstart;
  gl.glDrawArrays(mode,vstart,2 * vcount);
}","public void drawLines(GL3 gl,int mode,int gidx){
  int vstart=lineGroupOffsets[gidx];
  int vcount=lineGroupOffsets[gidx + 1] - vstart;
  gl.glDrawArrays(mode,2 * vstart,2 * vcount);
}"
70841,"@Override public void drawPoints(RenderObject robj,int gidx,PointStyle style,double rad){
  GL3RenderObjectPoints gro=myRenderObjectManager.getPoints(gl,robj);
  maybeUpdateState(gl);
switch (style) {
case POINT:
{
      float fold=getPointSize();
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setPointSize(frad);
        changed=true;
      }
      updateProgram(gl,RenderingMode.POINTS,robj.hasNormals(),robj.hasColors(),robj.hasTextureCoords());
      gro.drawPointGroup(gl,GL.GL_POINTS,gidx);
      if (changed) {
        setPointSize(fold);
      }
      break;
    }
case CUBE:
case SPHERE:
{
    GL3Object sphere=myPrimitiveManager.getSphere(gl,mySurfaceResolution,mySurfaceResolution / 2);
    gro.setRadius(gl,(float)rad);
    updateProgram(gl,RenderingMode.INSTANCED_POINTS,robj.hasNormals(),robj.hasColors(),robj.hasTextureCoords());
    gro.drawInstancedPointGroup(gl,sphere,gidx);
    break;
  }
}
}","@Override public void drawPoints(RenderObject robj,int gidx,PointStyle style,double rad){
  GL3RenderObjectPoints gro=myRenderObjectManager.getPoints(gl,robj);
  maybeUpdateState(gl);
switch (style) {
case POINT:
{
      float fold=getPointSize(gl);
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setPointSize(gl,frad);
        changed=true;
      }
      updateProgram(gl,RenderingMode.POINTS,robj.hasNormals(),robj.hasColors(),robj.hasTextureCoords());
      gro.drawPointGroup(gl,GL.GL_POINTS,gidx);
      if (changed) {
        setPointSize(gl,fold);
      }
      break;
    }
case SPHERE:
{
    GL3Object sphere=myPrimitiveManager.getSphere(gl,mySurfaceResolution,mySurfaceResolution / 2);
    gro.setRadius(gl,(float)rad);
    updateProgram(gl,RenderingMode.INSTANCED_POINTS,robj.hasNormals(),robj.hasColors(),robj.hasTextureCoords());
    gro.drawInstancedPointGroup(gl,sphere,gidx);
    break;
  }
}
}"
70842,"@Override public void init(GLAutoDrawable drawable){
  GLSupport.checkAndPrintGLError(drawable.getGL());
  this.drawable=drawable;
  gl=drawable.getGL().getGL3();
  String renderer=gl.glGetString(GL.GL_RENDERER);
  String version=gl.glGetString(GL.GL_VERSION);
  int[] buff=new int[2];
  gl.glGetIntegerv(GL3.GL_MAJOR_VERSION,buff,0);
  gl.glGetIntegerv(GL3.GL_MINOR_VERSION,buff,1);
  System.out.println(""String_Node_Str"" + renderer);
  System.out.println(""String_Node_Str"" + version + ""String_Node_Str""+ buff[0]+ ""String_Node_Str""+ buff[1]+ ""String_Node_Str"");
  gl.setSwapInterval(1);
  if (gl.isExtensionAvailable(""String_Node_Str"")) {
    gl.glEnable(GL3.GL_MULTISAMPLE);
  }
  gl.glGetIntegerv(GL3.GL_MAX_CLIP_DISTANCES,buff,0);
  maxClipPlanes=buff[0];
  selectEnabled=false;
  selectTrigger=false;
  setLightingEnabled(true);
  setDepthEnabled(true);
  setColorEnabled(true);
  setVertexColoringEnabled(true);
  setTextureMappingEnabled(true);
  setFaceStyle(FaceStyle.FRONT);
  setShading(Shading.PHONG);
  setGammaCorrectionEnabled(true);
  gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  resetViewVolume();
  invalidateModelMatrix();
  invalidateProjectionMatrix();
  invalidateViewMatrix();
  myProgManager.init(gl,lightManager.numLights(),0);
  myProgManager.setMatrices(gl,projectionMatrix,viewMatrix,modelMatrix,modelNormalMatrix);
  myProgManager.setLights(gl,lightManager.getLights(),1.0f / lightManager.getMaxIntensity(),viewMatrix);
  myProgManager.setMaterials(gl,myCurrentMaterial,myCurrentMaterial);
  myCurrentMaterialModified=true;
  gloFlex=GL3FlexObject.generate(gl,myGLResources.getVertexPositionAttribute(),myGLResources.getVertexNormalAttribute(),myGLResources.getVertexColorAttribute(),myGLResources.getVertexTexcoordAttribute());
  buildInternalRenderList();
  System.out.println(""String_Node_Str"");
  GLSupport.checkAndPrintGLError(drawable.getGL());
}","@Override public void init(GLAutoDrawable drawable){
  GLSupport.checkAndPrintGLError(drawable.getGL());
  this.drawable=drawable;
  gl=drawable.getGL().getGL3();
  String renderer=gl.glGetString(GL.GL_RENDERER);
  String version=gl.glGetString(GL.GL_VERSION);
  int[] buff=new int[2];
  gl.glGetIntegerv(GL3.GL_MAJOR_VERSION,buff,0);
  gl.glGetIntegerv(GL3.GL_MINOR_VERSION,buff,1);
  System.out.println(""String_Node_Str"" + renderer);
  System.out.println(""String_Node_Str"" + version + ""String_Node_Str""+ buff[0]+ ""String_Node_Str""+ buff[1]+ ""String_Node_Str"");
  gl.setSwapInterval(1);
  if (gl.isExtensionAvailable(""String_Node_Str"")) {
    gl.glEnable(GL3.GL_MULTISAMPLE);
  }
  gl.glGetIntegerv(GL3.GL_MAX_CLIP_DISTANCES,buff,0);
  maxClipPlanes=buff[0];
  selectEnabled=false;
  selectTrigger=false;
  setLightingEnabled(true);
  setDepthEnabled(true);
  setColorEnabled(true);
  setVertexColoringEnabled(true);
  setTextureMappingEnabled(true);
  setFaceStyle(FaceStyle.FRONT);
  setShading(Shading.PHONG);
  setGammaCorrectionEnabled(true);
  gl.glClearColor(backgroundColor[0],backgroundColor[1],backgroundColor[2],backgroundColor[3]);
  resetViewVolume(gl);
  invalidateModelMatrix();
  invalidateProjectionMatrix();
  invalidateViewMatrix();
  myProgManager.init(gl,lightManager.numLights(),0);
  myProgManager.setMatrices(gl,projectionMatrix,viewMatrix,modelMatrix,modelNormalMatrix);
  myProgManager.setLights(gl,lightManager.getLights(),1.0f / lightManager.getMaxIntensity(),viewMatrix);
  myProgManager.setMaterials(gl,myCurrentMaterial,myCurrentMaterial);
  myCurrentMaterialModified=true;
  gloFlex=GL3FlexObject.generate(gl,myGLResources.getVertexPositionAttribute(),myGLResources.getVertexNormalAttribute(),myGLResources.getVertexColorAttribute(),myGLResources.getVertexTexcoordAttribute());
  buildInternalRenderList();
  System.out.println(""String_Node_Str"");
  GLSupport.checkAndPrintGLError(drawable.getGL());
}"
70843,"@Override public void drawLines(RenderObject robj,int gidx,LineStyle style,double rad){
  GL3RenderObjectLines gro=myRenderObjectManager.getLines(gl,robj);
  maybeUpdateState(gl);
switch (style) {
case LINE:
{
      float fold=getLineWidth();
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setLineWidth(frad);
        changed=true;
      }
      updateProgram(gl,RenderingMode.DEFAULT,robj.hasNormals(),robj.hasColors(),robj.hasTextureCoords());
      gro.drawLineGroup(gl,GL.GL_LINES,gidx);
      if (changed) {
        setLineWidth(fold);
      }
      break;
    }
default :
{
    myProgramInfo.setLineScaleOffsetEnabled(true);
    updateProgram(gl,RenderingMode.INSTANCED_LINES,false,robj.hasColors(),false);
    myProgramInfo.setLineScaleOffsetEnabled(false);
switch (style) {
case CYLINDER:
{
        GL3Object primitive=myPrimitiveManager.getCylinder(gl,mySurfaceResolution,true);
        gro.setRadius(gl,(float)rad);
        gro.drawInstancedLineGroup(gl,primitive,gidx);
        break;
      }
case SOLID_ARROW:
{
      gro.setRadius(gl,(float)rad);
      GL3Object cylinder=myPrimitiveManager.getCylinder(gl,mySurfaceResolution,true);
      GL3Object cone=myPrimitiveManager.getCone(gl,mySurfaceResolution,true);
      float arrowRad=3 * (float)rad;
      float arrowLen=2 * arrowRad;
      float[] coneBoundary={1,0,-arrowLen,1};
      gro.setRadiusOffsets(gl,(float)rad,null,coneBoundary);
      gro.drawInstancedLineGroup(gl,cylinder,gidx);
      gro.setRadiusOffsets(gl,arrowRad,coneBoundary,null);
      gro.drawInstancedLineGroup(gl,cone,gidx);
      break;
    }
case SPINDLE:
{
    gro.setRadius(gl,(float)rad);
    GL3Object spindle=myPrimitiveManager.getSpindle(gl,mySurfaceResolution,mySurfaceResolution / 2);
    gro.drawInstancedLineGroup(gl,spindle,gidx);
    break;
  }
default :
break;
}
break;
}
}
}","@Override public void drawLines(RenderObject robj,int gidx,LineStyle style,double rad){
  GL3RenderObjectLines gro=myRenderObjectManager.getLines(gl,robj);
  maybeUpdateState(gl);
switch (style) {
case LINE:
{
      float fold=getLineWidth(gl);
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setLineWidth(gl,frad);
        changed=true;
      }
      updateProgram(gl,RenderingMode.DEFAULT,robj.hasNormals(),robj.hasColors(),robj.hasTextureCoords());
      gro.drawLineGroup(gl,GL.GL_LINES,gidx);
      if (changed) {
        setLineWidth(gl,fold);
      }
      break;
    }
default :
{
    myProgramInfo.setLineScaleOffsetEnabled(true);
    updateProgram(gl,RenderingMode.INSTANCED_LINES,false,robj.hasColors(),false);
    myProgramInfo.setLineScaleOffsetEnabled(false);
switch (style) {
case CYLINDER:
{
        GL3Object primitive=myPrimitiveManager.getCylinder(gl,mySurfaceResolution,true);
        gro.setRadius(gl,(float)rad);
        gro.drawInstancedLineGroup(gl,primitive,gidx);
        break;
      }
case SOLID_ARROW:
{
      gro.setRadius(gl,(float)rad);
      GL3Object cylinder=myPrimitiveManager.getCylinder(gl,mySurfaceResolution,true);
      GL3Object cone=myPrimitiveManager.getCone(gl,mySurfaceResolution,true);
      float arrowRad=3 * (float)rad;
      float arrowLen=2 * arrowRad;
      float[] coneBoundary={1,0,-arrowLen,1};
      gro.setRadiusOffsets(gl,(float)rad,null,coneBoundary);
      gro.drawInstancedLineGroup(gl,cylinder,gidx);
      gro.setRadiusOffsets(gl,arrowRad,coneBoundary,null);
      gro.drawInstancedLineGroup(gl,cone,gidx);
      break;
    }
case SPINDLE:
{
    gro.setRadius(gl,(float)rad);
    GL3Object spindle=myPrimitiveManager.getSpindle(gl,mySurfaceResolution,mySurfaceResolution / 2);
    gro.drawInstancedLineGroup(gl,spindle,gidx);
    break;
  }
default :
break;
}
break;
}
}
}"
70844,"public void processSelection(GLAutoDrawable drawable){
  GL2GL3 gl=myGl;
  GLSupport.checkAndPrintGLError(gl);
  int w=myViewW;
  int h=myViewH;
  fbo.deactivate(gl);
  ByteBuffer pixels=fbo.getPixels(gl,GL.GL_RGBA);
  fbo.dispose(gl);
  fbo=null;
  myViewer.setLightingEnabled(true);
  myViewer.setBackgroundColor(savedBackgroundColor[0],savedBackgroundColor[1],savedBackgroundColor[2],savedBackgroundColor[3]);
  if (savedBlend) {
    gl.glEnable(GL.GL_BLEND);
  }
  if (savedMulti) {
    gl.glEnable(GL.GL_MULTISAMPLE);
  }
  myViewer.setViewport(savedViewport[0],savedViewport[1],savedViewport[2],savedViewport[3]);
  myViewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  HitRecord[] hits=null;
  boolean badIdWarningIssued=false;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int lcolorId=a;
      lcolorId=0;
      lcolorId<<=8;
      lcolorId+=b;
      lcolorId<<=8;
      lcolorId+=g;
      lcolorId<<=8;
      lcolorId+=r;
      int colorId=(int)(lcolorId & (0xFFFFFFFF));
      if (colorId != 0) {
        int id=colorId / ID_STEP - 1 - ID_OFFSET;
        if (id < 0 || id >= myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          if (hits == null) {
            hits=new HitRecord[myTotalMaxQ];
          }
          HitRecord rec=hits[id];
          if (rec == null) {
            rec=new HitRecord(0);
            hits[id]=rec;
          }
          rec.size++;
        }
      }
    }
  }
  BufferUtilities.freeDirectBuffer(pixels);
  myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  if (hits == null) {
    myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    Iterator<GLRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      GLRenderable r=it.next();
      if (r instanceof GLSelectable) {
        GLSelectable s=(GLSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            HitRecord rec;
            if ((rec=hits[qid + i]) != null) {
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    LinkedList<Object>[] selObjs=new LinkedList[records.size()];
    for (int i=0; i < records.size(); i++) {
      selObjs[i]=records.get(i).objs;
    }
    myViewer.selectionEvent.mySelectedObjects=selObjs;
  }
  GLSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.selectionEvent);
  }
  myViewer.repaint();
}","public void processSelection(GLAutoDrawable drawable){
  GL2GL3 gl=myGl;
  GLSupport.checkAndPrintGLError(gl);
  int w=myViewW;
  int h=myViewH;
  fbo.deactivate(gl);
  ByteBuffer pixels=fbo.getPixels(gl,GL.GL_RGBA);
  fbo.dispose(gl);
  fbo=null;
  myViewer.setLightingEnabled(true);
  myViewer.setBackgroundColor(savedBackgroundColor[0],savedBackgroundColor[1],savedBackgroundColor[2],savedBackgroundColor[3]);
  if (savedBlend) {
    gl.glEnable(GL.GL_BLEND);
  }
  if (savedMulti) {
    gl.glEnable(GL.GL_MULTISAMPLE);
  }
  myViewer.setViewport(gl,savedViewport[0],savedViewport[1],savedViewport[2],savedViewport[3]);
  myViewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  HitRecord[] hits=null;
  boolean badIdWarningIssued=false;
  for (int i=0; i < w; i++) {
    for (int j=0; j < h; j++) {
      int r=0xff & pixels.get();
      int g=0xff & pixels.get();
      int b=0xff & pixels.get();
      int a=0xff & pixels.get();
      int lcolorId=a;
      lcolorId=0;
      lcolorId<<=8;
      lcolorId+=b;
      lcolorId<<=8;
      lcolorId+=g;
      lcolorId<<=8;
      lcolorId+=r;
      int colorId=(int)(lcolorId & (0xFFFFFFFF));
      if (colorId != 0) {
        int id=colorId / ID_STEP - 1 - ID_OFFSET;
        if (id < 0 || id >= myTotalMaxQ) {
          if (!badIdWarningIssued) {
            System.out.printf(""String_Node_Str"" + ""String_Node_Str"",id);
            badIdWarningIssued=true;
          }
        }
 else {
          if (hits == null) {
            hits=new HitRecord[myTotalMaxQ];
          }
          HitRecord rec=hits[id];
          if (rec == null) {
            rec=new HitRecord(0);
            hits[id]=rec;
          }
          rec.size++;
        }
      }
    }
  }
  BufferUtilities.freeDirectBuffer(pixels);
  myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  if (hits == null) {
    myViewer.selectionEvent.mySelectedObjects=new LinkedList[0];
  }
 else {
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    Iterator<GLRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      GLRenderable r=it.next();
      if (r instanceof GLSelectable) {
        GLSelectable s=(GLSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            HitRecord rec;
            if ((rec=hits[qid + i]) != null) {
              if (numq < 0) {
                rec.objs.add(s);
              }
 else {
                s.getSelection(rec.objs,i);
              }
              if (rec.objs.size() > 0) {
                records.add(rec);
              }
            }
          }
        }
        qid+=nums;
      }
    }
    Collections.sort(records);
    LinkedList<Object>[] selObjs=new LinkedList[records.size()];
    for (int i=0; i < records.size(); i++) {
      selObjs[i]=records.get(i).objs;
    }
    myViewer.selectionEvent.mySelectedObjects=selObjs;
  }
  GLSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.selectionEvent);
  }
  myViewer.repaint();
}"
70845,"public void setupSelection(GLAutoDrawable drawable){
  GL2GL3 gl=(GL2GL3)(myViewer.getGL());
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  savedViewport=myViewer.getViewport();
  myViewW=(int)Math.ceil(myRectW);
  myViewH=(int)Math.ceil(myRectH);
  myViewer.setPickMatrix((float)(myRectX),(float)(savedViewport[3] - myRectY),(float)myRectW,(float)myRectH,savedViewport);
  myViewer.setViewport(0,0,myViewW,myViewH);
  myViewer.setLightingEnabled(false);
  myViewer.getBackgroundColor(savedBackgroundColor);
  myViewer.setBackgroundColor(0,0,0,0);
  savedBlend=gl.glIsEnabled(GL.GL_BLEND);
  if (savedBlend) {
    gl.glDisable(GL.GL_BLEND);
  }
  savedMulti=gl.glIsEnabled(GL.GL_MULTISAMPLE);
  if (savedMulti) {
    gl.glDisable(GL.GL_MULTISAMPLE);
  }
  myViewer.setColor(0,0,0,0);
  fbo=new FrameBufferObject(myViewW,myViewH,1);
  fbo.activate(gl);
}","public void setupSelection(GLAutoDrawable drawable){
  GL2GL3 gl=(GL2GL3)(drawable.getGL());
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  savedViewport=myViewer.getViewport(gl);
  myViewW=(int)Math.ceil(myRectW);
  myViewH=(int)Math.ceil(myRectH);
  myViewer.setPickMatrix((float)(myRectX),(float)(savedViewport[3] - myRectY),(float)myRectW,(float)myRectH,savedViewport);
  myViewer.setViewport(gl,0,0,myViewW,myViewH);
  myViewer.setLightingEnabled(false);
  myViewer.getBackgroundColor(savedBackgroundColor);
  myViewer.setBackgroundColor(0,0,0,0);
  savedBlend=gl.glIsEnabled(GL.GL_BLEND);
  if (savedBlend) {
    gl.glDisable(GL.GL_BLEND);
  }
  savedMulti=gl.glIsEnabled(GL.GL_MULTISAMPLE);
  if (savedMulti) {
    gl.glDisable(GL.GL_MULTISAMPLE);
  }
  myViewer.setColor(0,0,0,0);
  fbo=new FrameBufferObject(myViewW,myViewH,1);
  fbo.activate(gl);
}"
70846,"public void processSelection(GLAutoDrawable drawable){
  if (!(myViewer instanceof GLViewer)) {
    return;
  }
  GLViewer viewer=(GLViewer)myViewer;
  GL2GL3 gl=(GL2GL3)(viewer.getGL());
  viewer.setColorEnabled(true);
  viewer.setDepthEnabled(true);
  viewer.setLightingEnabled(true);
  if (changeViewport) {
    gl.glViewport(mySavedViewport[0],mySavedViewport[1],mySavedViewport[2],mySavedViewport[3]);
  }
  viewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int lastQidx=-1;
  for (int i=myTotalMaxQ - 1; i >= 0; i--) {
    if (myQueryWasUsed[i]) {
      lastQidx=i;
      break;
    }
  }
  if (lastQidx == -1) {
    myViewer.setSelected(new LinkedList[0]);
  }
 else {
    int[] available=new int[1];
    do {
      gl.glGetQueryObjectiv(myQueries[lastQidx],GL2.GL_QUERY_RESULT_AVAILABLE,available,0);
      if (available[0] == 0) {
        waitMsec(1);
      }
    }
 while (available[0] == 0);
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    int[] result=new int[1];
    Iterator<GLRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      GLRenderable r=it.next();
      if (r instanceof GLSelectable) {
        GLSelectable s=(GLSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            if (myQueryWasUsed[qid + i]) {
              gl.glGetQueryObjectuiv(myQueries[qid + i],GL2.GL_QUERY_RESULT,result,0);
              if (result[0] > 0) {
                HitRecord rec=new HitRecord(result[0]);
                if (numq < 0) {
                  rec.objs.add(s);
                }
 else {
                  s.getSelection(rec.objs,i);
                }
                if (rec.objs.size() > 0) {
                  records.add(rec);
                }
              }
            }
          }
        }
        qid+=nums;
        if (qid > lastQidx) {
          break;
        }
      }
    }
    Collections.sort(records);
    LinkedList<Object>[] selObjs=new LinkedList[records.size()];
    for (int i=0; i < records.size(); i++) {
      selObjs[i]=records.get(i).objs;
    }
    myViewer.setSelected(selObjs);
  }
  gl.glDeleteQueries(myTotalMaxQ,myQueries,0);
  myQueries=null;
  myQueryWasUsed=null;
  GLSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.getSelectionEvent());
  }
  myViewer.getCanvas().repaint();
}","public void processSelection(GLAutoDrawable drawable){
  if (!(myViewer instanceof GLViewer)) {
    return;
  }
  GLViewer viewer=(GLViewer)myViewer;
  GL2GL3 gl=(GL2GL3)(drawable.getGL());
  viewer.setColorEnabled(true);
  viewer.setDepthEnabled(true);
  viewer.setLightingEnabled(true);
  if (changeViewport) {
    gl.glViewport(mySavedViewport[0],mySavedViewport[1],mySavedViewport[2],mySavedViewport[3]);
  }
  viewer.clearPickMatrix();
  if (!myMaxQStack.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int lastQidx=-1;
  for (int i=myTotalMaxQ - 1; i >= 0; i--) {
    if (myQueryWasUsed[i]) {
      lastQidx=i;
      break;
    }
  }
  if (lastQidx == -1) {
    myViewer.setSelected(new LinkedList[0]);
  }
 else {
    int[] available=new int[1];
    do {
      gl.glGetQueryObjectiv(myQueries[lastQidx],GL2.GL_QUERY_RESULT_AVAILABLE,available,0);
      if (available[0] == 0) {
        waitMsec(1);
      }
    }
 while (available[0] == 0);
    int qid=0;
    LinkedList<HitRecord> records=new LinkedList<HitRecord>();
    int[] result=new int[1];
    Iterator<GLRenderable> it=myViewer.renderIterator();
    while (it.hasNext()) {
      GLRenderable r=it.next();
      if (r instanceof GLSelectable) {
        GLSelectable s=(GLSelectable)r;
        int numq=s.numSelectionQueriesNeeded();
        int nums=(numq >= 0 ? numq : 1);
        if (s.isSelectable()) {
          for (int i=0; i < nums; i++) {
            if (myQueryWasUsed[qid + i]) {
              gl.glGetQueryObjectuiv(myQueries[qid + i],GL2.GL_QUERY_RESULT,result,0);
              if (result[0] > 0) {
                HitRecord rec=new HitRecord(result[0]);
                if (numq < 0) {
                  rec.objs.add(s);
                }
 else {
                  s.getSelection(rec.objs,i);
                }
                if (rec.objs.size() > 0) {
                  records.add(rec);
                }
              }
            }
          }
        }
        qid+=nums;
        if (qid > lastQidx) {
          break;
        }
      }
    }
    Collections.sort(records);
    LinkedList<Object>[] selObjs=new LinkedList[records.size()];
    for (int i=0; i < records.size(); i++) {
      selObjs[i]=records.get(i).objs;
    }
    myViewer.setSelected(selObjs);
  }
  gl.glDeleteQueries(myTotalMaxQ,myQueries,0);
  myQueries=null;
  myQueryWasUsed=null;
  GLSelectionListener[] listeners=myViewer.getSelectionListeners();
  for (int i=0; i < listeners.length; i++) {
    listeners[i].itemsSelected(myViewer.getSelectionEvent());
  }
  myViewer.getCanvas().repaint();
}"
70847,"public void setupSelection(GLAutoDrawable drawable){
  if (!(myViewer instanceof GLViewer)) {
    return;
  }
  GLViewer viewer=(GLViewer)myViewer;
  GL2GL3 gl=(GL2GL3)viewer.getGL();
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  if (myTotalMaxQ == 0) {
    return;
  }
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  myQueries=new int[myTotalMaxQ];
  myQueryWasUsed=new boolean[myTotalMaxQ];
  gl.glGenQueries(myTotalMaxQ,myQueries,0);
  mySavedViewport=viewer.getViewport();
  if (changeViewport) {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
    viewer.setViewport(0,0,(int)Math.ceil(myRectW),(int)Math.ceil(myRectH));
  }
 else {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
  }
  Vector2d zRange=new Vector2d();
  myViewer.getZRange(zRange);
  myViewer.setViewVolume(zRange.x,zRange.y);
  viewer.setLightingEnabled(false);
  viewer.setColorEnabled(false);
  viewer.setDepthEnabled(false);
}","public void setupSelection(GLAutoDrawable drawable){
  if (!(myViewer instanceof GLViewer)) {
    return;
  }
  GLViewer viewer=(GLViewer)myViewer;
  GL2GL3 gl=(GL2GL3)drawable.getGL();
  myGl=gl;
  myTotalMaxQ=myViewer.numSelectionQueriesNeeded();
  if (myTotalMaxQ == 0) {
    return;
  }
  myCurrentMaxQ=myTotalMaxQ;
  myCurrentIdx=-1;
  myIdxBase=0;
  myMaxQStack.clear();
  myIdxBaseStack.clear();
  myQueries=new int[myTotalMaxQ];
  myQueryWasUsed=new boolean[myTotalMaxQ];
  gl.glGenQueries(myTotalMaxQ,myQueries,0);
  mySavedViewport=viewer.getViewport(gl);
  if (changeViewport) {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
    viewer.setViewport(gl,0,0,(int)Math.ceil(myRectW),(int)Math.ceil(myRectH));
  }
 else {
    viewer.setPickMatrix((float)myRectX,(float)(mySavedViewport[3] - myRectY),(float)myRectW,(float)myRectH,mySavedViewport);
  }
  Vector2d zRange=new Vector2d();
  myViewer.getZRange(zRange);
  myViewer.setViewVolume(zRange.x,zRange.y);
  viewer.setLightingEnabled(false);
  viewer.setColorEnabled(false);
  viewer.setDepthEnabled(false);
}"
70848,"@Override public void drawAxes(RigidTransform3d X,double[] len,int lineWidth,boolean selected){
  GLSupport.checkAndPrintGLError(gl);
  double lx=len[0];
  double ly=len[1];
  double lz=len[2];
  boolean drawx=true;
  boolean drawy=true;
  boolean drawz=true;
  if (X == null) {
    X=RigidTransform3d.IDENTITY;
  }
  if (lx == 0) {
    lx=1;
    drawx=false;
  }
  if (ly == 0) {
    ly=1;
    drawy=false;
  }
  if (lz == 0) {
    lz=1;
    drawz=false;
  }
  pushModelMatrix();
  mulModelMatrix(X);
  scaleModelMatrix(lx,ly,lz);
  updateMatrices(gl);
  gl.glLineWidth(lineWidth);
  GL3Object axes=myGLResources.getAxes(gl,drawx,drawy,drawz);
  if (selectEnabled || selected) {
    axes.draw(gl,getBasicProgram(gl));
  }
 else {
    axes.draw(gl,getColorProgram(gl,Shading.NONE,ColorInterpolation.RGB));
  }
  gl.glLineWidth(1);
  popModelMatrix();
}","@Override public void drawAxes(RigidTransform3d X,double[] len,int lineWidth,boolean selected){
  GLSupport.checkAndPrintGLError(gl);
  double lx=len[0];
  double ly=len[1];
  double lz=len[2];
  boolean drawx=true;
  boolean drawy=true;
  boolean drawz=true;
  if (X == null) {
    X=RigidTransform3d.IDENTITY;
  }
  if (lx == 0) {
    lx=1;
    drawx=false;
  }
  if (ly == 0) {
    ly=1;
    drawy=false;
  }
  if (lz == 0) {
    lz=1;
    drawz=false;
  }
  pushModelMatrix();
  mulModelMatrix(X);
  scaleModelMatrix(lx,ly,lz);
  maybeUpdateState(gl);
  gl.glLineWidth(lineWidth);
  GL3Object axes=myGLResources.getAxes(gl,drawx,drawy,drawz);
  if (selectEnabled || selected) {
    axes.draw(gl,getBasicProgram(gl));
  }
 else {
    axes.draw(gl,getColorProgram(gl,Shading.NONE,ColorInterpolation.RGB));
  }
  gl.glLineWidth(1);
  popModelMatrix();
}"
70849,"public void drawCone(RenderProps props,float[] coords0,float[] coords1,double r,boolean capped){
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  mulModelMatrix(lineRot);
  scaleModelMatrix(r,r,len);
  updateMatrices(gl);
  int nslices=props.getPointSlices();
  GL3Object cone=myGLResources.getCone(gl,nslices,capped);
  cone.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}","public void drawCone(RenderProps props,float[] coords0,float[] coords1,double r,boolean capped){
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  mulModelMatrix(lineRot);
  scaleModelMatrix(r,r,len);
  maybeUpdateState(gl);
  int nslices=props.getPointSlices();
  GL3Object cone=myGLResources.getCone(gl,nslices,capped);
  cone.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}"
70850,"@Override public void drawTaperedEllipsoid(RenderProps props,float[] coords0,float[] coords1){
  double r=props.getLineRadius();
  if (r < Double.MIN_NORMAL) {
    return;
  }
  pushModelMatrix();
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  mulModelMatrix(lineRot);
  scaleModelMatrix(r,r,len);
  updateMatrices(gl);
  int nslices=props.getPointSlices();
  GL3Object ellipsoid=myGLResources.getTaperedEllipsoid(gl,nslices,(int)Math.ceil(nslices / 2));
  ellipsoid.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}","@Override public void drawTaperedEllipsoid(RenderProps props,float[] coords0,float[] coords1){
  double r=props.getLineRadius();
  if (r < Double.MIN_NORMAL) {
    return;
  }
  pushModelMatrix();
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  mulModelMatrix(lineRot);
  scaleModelMatrix(r,r,len);
  maybeUpdateState(gl);
  int nslices=props.getPointSlices();
  GL3Object ellipsoid=myGLResources.getTaperedEllipsoid(gl,nslices,(int)Math.ceil(nslices / 2));
  ellipsoid.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}"
70851,"@Override public void drawSphere(RenderProps props,float[] coords,double r){
  if (r < Double.MIN_NORMAL) {
    return;
  }
  pushModelMatrix();
  translateModelMatrix(coords[0],coords[1],coords[2]);
  scaleModelMatrix(r);
  updateMatrices(gl);
  int nslices=props.getPointSlices();
  GL3Object sphere=myGLResources.getSphere(gl,nslices,(int)Math.ceil(nslices / 2));
  sphere.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}","@Override public void drawSphere(RenderProps props,float[] coords,double r){
  if (r < Double.MIN_NORMAL) {
    return;
  }
  pushModelMatrix();
  translateModelMatrix(coords[0],coords[1],coords[2]);
  scaleModelMatrix(r);
  maybeUpdateState(gl);
  int nslices=props.getPointSlices();
  GL3Object sphere=myGLResources.getSphere(gl,nslices,(int)Math.ceil(nslices / 2));
  sphere.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}"
70852,"@Override public void drawCylinder(RenderProps props,float[] coords0,float[] coords1,double r,boolean capped){
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  mulModelMatrix(lineRot);
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  scaleModelMatrix(r,r,len);
  updateMatrices(gl);
  int nslices=props.getPointSlices();
  GL3Object cylinder=myGLResources.getCylinder(gl,nslices,capped);
  cylinder.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}","@Override public void drawCylinder(RenderProps props,float[] coords0,float[] coords1,double r,boolean capped){
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  mulModelMatrix(lineRot);
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  scaleModelMatrix(r,r,len);
  maybeUpdateState(gl);
  int nslices=props.getPointSlices();
  GL3Object cylinder=myGLResources.getCylinder(gl,nslices,capped);
  cylinder.draw(gl,getRegularProgram(gl));
  popModelMatrix();
}"
70853,"@Override public void drawSolidArrow(RenderProps props,float[] coords0,float[] coords1,boolean capped){
  double r=props.getLineRadius();
  if (r < Double.MIN_NORMAL) {
    return;
  }
  int nslices=props.getPointSlices();
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  double arrowRad=3 * props.getLineRadius();
  double arrowLen=Math.min(2 * arrowRad,len / 2);
  double lenFrac=1 - arrowLen / len;
  float[] coordsMid=new float[]{coords0[0] + (float)(lenFrac * dx),coords0[1] + (float)(lenFrac * dy),coords0[2] + (float)(lenFrac * dz)};
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  mulModelMatrix(lineRot);
  scaleModelMatrix(r,r,len - arrowLen);
  updateMatrices(gl);
  GL3Object cylinder=myGLResources.getCylinder(gl,nslices,capped);
  cylinder.draw(gl,getRegularProgram(gl));
  popModelMatrix();
  pushModelMatrix();
  lineRot.setTranslation(coordsMid[0],coordsMid[1],coordsMid[2]);
  mulModelMatrix(lineRot);
  scaleModelMatrix(arrowRad,arrowRad,arrowLen);
  updateMatrices(gl);
  GL3Object cone=myGLResources.getCone(gl,nslices,capped);
  cone.draw(gl,getRegularProgram(gl));
  gl.glUseProgram(0);
  popModelMatrix();
}","@Override public void drawSolidArrow(RenderProps props,float[] coords0,float[] coords1,boolean capped){
  double r=props.getLineRadius();
  if (r < Double.MIN_NORMAL) {
    return;
  }
  int nslices=props.getPointSlices();
  double dx=coords1[0] - coords0[0];
  double dy=coords1[1] - coords0[1];
  double dz=coords1[2] - coords0[2];
  double len=Math.sqrt(dx * dx + dy * dy + dz * dz);
  double arrowRad=3 * props.getLineRadius();
  double arrowLen=Math.min(2 * arrowRad,len / 2);
  double lenFrac=1 - arrowLen / len;
  float[] coordsMid=new float[]{coords0[0] + (float)(lenFrac * dx),coords0[1] + (float)(lenFrac * dy),coords0[2] + (float)(lenFrac * dz)};
  pushModelMatrix();
  RigidTransform3d lineRot=getLineTransform(coords0,coords1);
  mulModelMatrix(lineRot);
  scaleModelMatrix(r,r,len - arrowLen);
  maybeUpdateState(gl);
  GL3Object cylinder=myGLResources.getCylinder(gl,nslices,capped);
  cylinder.draw(gl,getRegularProgram(gl));
  popModelMatrix();
  pushModelMatrix();
  lineRot.setTranslation(coordsMid[0],coordsMid[1],coordsMid[2]);
  mulModelMatrix(lineRot);
  scaleModelMatrix(arrowRad,arrowRad,arrowLen);
  maybeUpdateState(gl);
  GL3Object cone=myGLResources.getCone(gl,nslices,capped);
  cone.draw(gl,getRegularProgram(gl));
  gl.glUseProgram(0);
  popModelMatrix();
}"
70854,"private GL3Object buildGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,int type){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),pinfo.offset,pinfo.stride,pinfo.count);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),ninfo.offset,ninfo.stride,ninfo.count);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),cinfo.offset,cinfo.stride,cinfo.count);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),tinfo.offset,tinfo.stride,tinfo.count);
    aidx++;
  }
  int mode;
  GL3ElementAttributeArray elems=null;
switch (type) {
case POINTS:
{
      AttributeInfo oinfo=pointsInfo[oidx];
      BufferStorage bs=indexPutter.storage();
      BufferObject ibo=vbos[oinfo.vboIndex];
      mode=GL.GL_POINTS;
      elems=new GL3ElementAttributeArray(ibo,GL3Util.getGLType(bs.type()),oinfo.offset,oinfo.stride,oinfo.count);
      break;
    }
case LINES:
{
    AttributeInfo oinfo=linesInfo[oidx];
    BufferStorage bs=indexPutter.storage();
    BufferObject ibo=vbos[oinfo.vboIndex];
    mode=GL.GL_LINES;
    elems=new GL3ElementAttributeArray(ibo,GL3Util.getGLType(bs.type()),oinfo.offset,oinfo.stride,oinfo.count);
    break;
  }
case TRIANGLES:
{
  AttributeInfo oinfo=trianglesInfo[oidx];
  BufferStorage bs=indexPutter.storage();
  BufferObject ibo=vbos[oinfo.vboIndex];
  mode=GL.GL_TRIANGLES;
  elems=new GL3ElementAttributeArray(ibo,GL3Util.getGLType(bs.type()),oinfo.offset,oinfo.stride,oinfo.count);
  break;
}
case VERTICES:
default :
mode=GL.GL_POINTS;
}
GL3Object glo=new GL3Object(attribs,elems,mode);
return glo;
}","private GL3Object buildGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,int type){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    nattribs++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),pinfo.offset,pinfo.stride,pinfo.count);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),ninfo.offset,ninfo.stride,ninfo.count);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),cinfo.offset,cinfo.stride,cinfo.count);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),tinfo.offset,tinfo.stride,tinfo.count);
    aidx++;
  }
  int mode;
  GL3ElementAttributeArray elems=null;
switch (type) {
case POINTS:
{
      AttributeInfo oinfo=pointsInfo[oidx];
      BufferStorage bs=indexPutter.storage();
      BufferObject ibo=vbos[oinfo.vboIndex];
      mode=GL.GL_POINTS;
      elems=new GL3ElementAttributeArray(ibo,GL3Util.getGLType(bs.type()),oinfo.offset,oinfo.stride,oinfo.count);
      break;
    }
case LINES:
{
    AttributeInfo oinfo=linesInfo[oidx];
    BufferStorage bs=indexPutter.storage();
    BufferObject ibo=vbos[oinfo.vboIndex];
    mode=GL.GL_LINES;
    elems=new GL3ElementAttributeArray(ibo,GL3Util.getGLType(bs.type()),oinfo.offset,oinfo.stride,oinfo.count);
    break;
  }
case TRIANGLES:
{
  AttributeInfo oinfo=trianglesInfo[oidx];
  BufferStorage bs=indexPutter.storage();
  BufferObject ibo=vbos[oinfo.vboIndex];
  mode=GL.GL_TRIANGLES;
  elems=new GL3ElementAttributeArray(ibo,GL3Util.getGLType(bs.type()),oinfo.offset,oinfo.stride,oinfo.count);
  break;
}
case VERTICES:
default :
mode=GL.GL_POINTS;
}
GL3Object glo=new GL3Object(attribs,elems,mode);
return glo;
}"
70855,"private void doDisplay(GLAutoDrawable drawable,int flags){
  GLSupport.checkAndPrintGLError(drawable.getGL());
  int mclips=Math.min(2 * myClipPlanes.size(),maxClipPlanes);
  progManager.reconfigure(gl,lightManager.numLights(),mclips);
  progManager.setLights(gl,lightManager.getLights(),1.0f / lightManager.getMaxIntensity(),viewMatrix);
  maybeUpdateState(gl);
  GL3 gl3=drawable.getGL().getGL3();
  if (!isSelecting()) {
    gl3.glClearColor(bgColor[0],bgColor[1],bgColor[2],bgColor[3]);
  }
  gl3.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  int nclips=0;
  if (myClipPlanes.size() > 0) {
    nclips=progManager.setClipPlanes(gl3,myClipPlanes);
    for (int i=0; i < nclips; ++i) {
      gl.glEnable(GL3.GL_CLIP_DISTANCE0 + i);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  int qid=0;
synchronized (renderablesLock) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
    if (myExternalRenderList != null) {
      qid=myExternalRenderList.renderOpaque(this,qid,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  if (hasTransparent3d()) {
    if (!isSelecting()) {
      enableTransparency(gl);
    }
synchronized (renderablesLock) {
      qid=myInternalRenderList.renderTransparent(this,qid,flags);
      if (myExternalRenderList != null) {
        qid=myExternalRenderList.renderTransparent(this,qid,flags);
      }
    }
    disableTransparency(gl);
  }
  GLSupport.checkAndPrintGLError(gl);
  for (int i=0; i < nclips; ++i) {
    gl.glDisable(GL3.GL_CLIP_DISTANCE0 + i);
  }
  GLSupport.checkAndPrintGLError(gl);
  if (has2d()) {
    begin2DRendering(width,height);
synchronized (renderablesLock) {
      qid=myInternalRenderList.renderOpaque2d(this,qid,0);
      if (myExternalRenderList != null) {
        qid=myExternalRenderList.renderOpaque2d(this,qid,0);
      }
    }
    if (hasTransparent2d()) {
      enableTransparency(gl);
synchronized (renderablesLock) {
        qid=myInternalRenderList.renderTransparent2d(this,qid,0);
        if (myExternalRenderList != null) {
          qid=myExternalRenderList.renderTransparent2d(this,qid,0);
        }
      }
      disableTransparency(gl);
    }
    end2DRendering();
  }
  GLSupport.checkAndPrintGLError(gl);
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(drawable);
    }
  }
 else {
    gl.glClearColor(bgColor[0],bgColor[1],bgColor[2],bgColor[3]);
  }
  GLSupport.checkAndPrintGLError(gl);
  gl3.glFlush();
  GLSupport.checkAndPrintGLError(gl);
}","private void doDisplay(GLAutoDrawable drawable,int flags){
  GLSupport.checkAndPrintGLError(drawable.getGL());
  int mclips=Math.min(2 * myClipPlanes.size(),maxClipPlanes);
  progManager.reconfigure(gl,lightManager.numLights(),mclips);
  progManager.setLights(gl,lightManager.getLights(),1.0f / lightManager.getMaxIntensity(),viewMatrix);
  maybeUpdateState(gl);
  GL3 gl3=drawable.getGL().getGL3();
  if (!isSelecting()) {
    gl3.glClearColor(bgColor[0],bgColor[1],bgColor[2],bgColor[3]);
  }
  gl3.glClear(GL.GL_COLOR_BUFFER_BIT | GL.GL_DEPTH_BUFFER_BIT);
  if (!isSelecting()) {
    if (gridVisible) {
      myGrid.render(this,flags);
    }
    if (axisLength > 0) {
      drawAxes(gl,axisLength);
    }
    for (    Dragger3d dragger : myDraggers) {
      dragger.render(this,0);
    }
    if (myDrawTool != null) {
      myDrawTool.render(this,0);
    }
    for (    GLClipPlane cp : myClipPlanes) {
      cp.render(this,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  int nclips=0;
  if (myClipPlanes.size() > 0) {
    nclips=progManager.setClipPlanes(gl3,myClipPlanes);
    for (int i=0; i < nclips; ++i) {
      gl.glEnable(GL3.GL_CLIP_DISTANCE0 + i);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  int qid=0;
synchronized (renderablesLock) {
    qid=myInternalRenderList.renderOpaque(this,qid,flags);
    if (myExternalRenderList != null) {
      qid=myExternalRenderList.renderOpaque(this,qid,flags);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  if (hasTransparent3d()) {
    if (!isSelecting()) {
      enableTransparency(gl);
    }
synchronized (renderablesLock) {
      qid=myInternalRenderList.renderTransparent(this,qid,flags);
      if (myExternalRenderList != null) {
        qid=myExternalRenderList.renderTransparent(this,qid,flags);
      }
    }
    if (!isSelecting()) {
      disableTransparency(gl);
    }
  }
  GLSupport.checkAndPrintGLError(gl);
  for (int i=0; i < nclips; ++i) {
    gl.glDisable(GL3.GL_CLIP_DISTANCE0 + i);
  }
  GLSupport.checkAndPrintGLError(gl);
  if (has2d()) {
    begin2DRendering(width,height);
synchronized (renderablesLock) {
      qid=myInternalRenderList.renderOpaque2d(this,qid,0);
      if (myExternalRenderList != null) {
        qid=myExternalRenderList.renderOpaque2d(this,qid,0);
      }
    }
    if (hasTransparent2d()) {
      enableTransparency(gl);
synchronized (renderablesLock) {
        qid=myInternalRenderList.renderTransparent2d(this,qid,0);
        if (myExternalRenderList != null) {
          qid=myExternalRenderList.renderTransparent2d(this,qid,0);
        }
      }
      disableTransparency(gl);
    }
    end2DRendering();
  }
  GLSupport.checkAndPrintGLError(gl);
  if (!isSelecting()) {
    if (myDragBox != null) {
      drawDragBox(drawable);
    }
  }
 else {
    gl.glClearColor(bgColor[0],bgColor[1],bgColor[2],bgColor[3]);
  }
  GLSupport.checkAndPrintGLError(gl);
  gl3.glFlush();
  GLSupport.checkAndPrintGLError(gl);
}"
70856,"/** 
 * Takes a FemModel3d containing linear elements, and creates a quadratic model whose elements are the corresponding quadratic elements, with new nodes inserted along the edges as required. The new quadratic model will have straight edges in the rest position.
 * @param linMod A FemModel3d previously inialized with only linear elements.
 */
public static FemModel3d createQuadraticModel(FemModel3d quadMod,FemModel3d linMod){
  ComponentListView<FemNode3d> quadNodes=quadMod.getNodes();
  if (quadMod == linMod) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<FemNode3d,FemNode3d> nodeMap=new HashMap<FemNode3d,FemNode3d>();
  for (  FemNode3d n : linMod.getNodes()) {
    FemNode3d newn=new FemNode3d(n.getPosition());
    nodeMap.put(n,newn);
    quadMod.addNode(newn);
  }
  for (  FemElement3d e : linMod.getElements()) {
    ArrayList<FemNode3d> allNodes=new ArrayList<FemNode3d>();
    FemNode3d qnodes[];
    for (    FemNode3d n : e.getNodes()) {
      allNodes.add(nodeMap.get(n));
    }
    if (e instanceof TetElement) {
      qnodes=QuadtetElement.getQuadraticNodes((TetElement)e);
    }
 else     if (e instanceof HexElement) {
      qnodes=QuadhexElement.getQuadraticNodes((HexElement)e);
    }
 else     if (e instanceof WedgeElement) {
      qnodes=QuadwedgeElement.getQuadraticNodes((WedgeElement)e);
    }
 else     if (e instanceof PyramidElement) {
      qnodes=QuadpyramidElement.getQuadraticNodes((PyramidElement)e);
    }
 else {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    for (int i=0; i < qnodes.length; i++) {
      boolean nodeExists=false;
      for (      FemNode3d n : quadNodes) {
        if (qnodes[i].getPosition().equals(n.getPosition())) {
          qnodes[i]=n;
          nodeExists=true;
          break;
        }
      }
      if (!nodeExists) {
        quadMod.addNode(qnodes[i]);
      }
    }
    for (    FemNode3d n : qnodes) {
      allNodes.add(n);
    }
    FemNode3d[] nodes=allNodes.toArray(new FemNode3d[0]);
    FemElement3d qe=null;
    if (e instanceof TetElement) {
      qe=new QuadtetElement(nodes);
    }
 else     if (e instanceof HexElement) {
      qe=new QuadhexElement(nodes);
    }
 else     if (e instanceof WedgeElement) {
      qe=new QuadwedgeElement(nodes);
    }
 else     if (e instanceof PyramidElement) {
      qe=new QuadpyramidElement(nodes);
    }
    quadMod.addElement(qe);
  }
  quadMod.setMaterial(linMod.getMaterial());
  for (  FemNode3d n : quadNodes) {
    n.setMass(0);
  }
  double density=linMod.getDensity();
  for (  FemElement3d e : quadMod.getElements()) {
    double mass=e.getRestVolume() * density;
    e.setMass(mass);
    e.updateNodeMasses(mass);
  }
  return quadMod;
}","/** 
 * Takes a FemModel3d containing linear elements, and creates a quadratic model whose elements are the corresponding quadratic elements, with new nodes inserted along the edges as required. The new quadratic model will have straight edges in the rest position.
 * @param linMod A FemModel3d previously inialized with only linear elements.
 */
public static FemModel3d createQuadraticModel(FemModel3d quadMod,FemModel3d linMod){
  ComponentListView<FemNode3d> quadNodes=quadMod.getNodes();
  if (quadMod == linMod) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  HashMap<FemNode3d,FemNode3d> nodeMap=new HashMap<FemNode3d,FemNode3d>();
  for (  FemNode3d n : linMod.getNodes()) {
    FemNode3d newn=new FemNode3d(n.getPosition());
    nodeMap.put(n,newn);
    quadMod.addNode(newn);
  }
  for (  FemElement3d e : linMod.getElements()) {
    ArrayList<FemNode3d> allNodes=new ArrayList<FemNode3d>();
    FemNode3d qnodes[];
    for (    FemNode3d n : e.getNodes()) {
      allNodes.add(nodeMap.get(n));
    }
    if (e instanceof TetElement) {
      qnodes=QuadtetElement.getQuadraticNodes((TetElement)e);
    }
 else     if (e instanceof HexElement) {
      qnodes=QuadhexElement.getQuadraticNodes((HexElement)e);
    }
 else     if (e instanceof WedgeElement) {
      qnodes=QuadwedgeElement.getQuadraticNodes((WedgeElement)e);
    }
 else     if (e instanceof PyramidElement) {
      qnodes=QuadpyramidElement.getQuadraticNodes((PyramidElement)e);
    }
 else {
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    for (int i=0; i < qnodes.length; i++) {
      boolean nodeExists=false;
      for (      FemNode3d n : quadNodes) {
        if (qnodes[i].getPosition().equals(n.getPosition())) {
          qnodes[i]=n;
          nodeExists=true;
          break;
        }
      }
      if (!nodeExists) {
        quadMod.addNode(qnodes[i]);
      }
    }
    for (    FemNode3d n : qnodes) {
      allNodes.add(n);
    }
    FemNode3d[] nodes=allNodes.toArray(new FemNode3d[0]);
    FemElement3d qe=null;
    if (e instanceof TetElement) {
      qe=new QuadtetElement(nodes);
    }
 else     if (e instanceof HexElement) {
      qe=new QuadhexElement(nodes);
    }
 else     if (e instanceof WedgeElement) {
      qe=new QuadwedgeElement(nodes);
    }
 else     if (e instanceof PyramidElement) {
      qe=new QuadpyramidElement(nodes);
    }
    quadMod.addElement(qe);
  }
  quadMod.setMaterial(linMod.getMaterial());
  for (  FemNode3d n : quadNodes) {
    n.clearMass();
  }
  double density=linMod.getDensity();
  for (  FemElement3d e : quadMod.getElements()) {
    double mass=e.getRestVolume() * density;
    e.setMass(mass);
    e.updateNodeMasses(mass);
  }
  return quadMod;
}"
70857,"public void clearElements(){
  myElements.removeAll();
  for (int i=0; i < myNodes.size(); i++) {
    myNodes.get(i).setMass(0);
  }
  if (myAutoGenerateSurface) {
    mySurfaceMeshValid=false;
    myInternalSurfaceMeshComp=null;
  }
}","public void clearElements(){
  myElements.removeAll();
  for (int i=0; i < myNodes.size(); i++) {
    myNodes.get(i).clearMass();
  }
  if (myAutoGenerateSurface) {
    mySurfaceMeshValid=false;
    myInternalSurfaceMeshComp=null;
  }
}"
70858,"public void clearContactActivity(){
  for (  ContactConstraint c : myBilaterals0.values()) {
    c.setActive(false);
  }
  for (  ContactConstraint c : myBilaterals1.values()) {
    c.setActive(false);
  }
}","public void clearContactActivity(){
  for (  ContactConstraint c : myBilaterals0.values()) {
    c.setActive(false);
    c.setDistance(0);
  }
  for (  ContactConstraint c : myBilaterals1.values()) {
    c.setActive(false);
    c.setDistance(0);
  }
}"
70859,"boolean hashContactUsingFace(CollidableBody collidable0,CollidableBody collidable1){
  PolygonalMesh mesh0=collidable0.getCollisionMesh();
  PolygonalMesh mesh1=collidable1.getCollisionMesh();
  return (hasLowDOF(collidable0) && mesh0.numVertices() > mesh1.numVertices());
}","boolean hashContactUsingFace(CollidableBody collidable0,CollidableBody collidable1){
  PolygonalMesh mesh0=collidable0.getCollisionMesh();
  PolygonalMesh mesh1=collidable1.getCollisionMesh();
  return (!isCompliant() && hasLowDOF(collidable0) && mesh0.numVertices() > mesh1.numVertices());
}"
70860,"protected void computeStiffnessPosCorrection(VectorNd vel,int velSize){
  boolean analyze=false;
  updateSolveMatrixStructure();
  if (myKKTSolveMatrixVersion != mySolveMatrixVersion) {
    myKKTSolveMatrixVersion=mySolveMatrixVersion;
    analyze=true;
  }
  SparseNumberedBlockMatrix S=mySolveMatrix;
  S.setZero();
  mySys.addVelJacobian(S,null,-1);
  mySys.addPosJacobian(S,null,-1);
  addActiveMassMatrix(mySys,S);
  if (myKKTSolver == null) {
    myKKTSolver=new KKTSolver();
    analyze=true;
  }
  if (myKKTGTVersion != myGTVersion) {
    analyze=true;
    myKKTGTVersion=myGTVersion;
  }
  if (analyze) {
    myKKTSolver.analyze(S,velSize,myGT,mySys.getSolveMatrixType());
  }
  if (myHybridSolveP && !analyze && myNT.colSize() == 0) {
    myKKTSolver.factorAndSolve(S,velSize,myGT,myRg,vel,myLam,myBf,myBg,myHybridSolveTol);
  }
 else {
    myKKTSolver.factor(S,velSize,myGT,myRg,myNT,myRn);
    myKKTSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  }
  if (computeKKTResidual) {
    double res=myKKTSolver.residual(S,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
}","protected void computeStiffnessPosCorrection(VectorNd vel,int velSize){
  boolean analyze=false;
  updateSolveMatrixStructure();
  if (myKKTSolveMatrixVersion != mySolveMatrixVersion) {
    myKKTSolveMatrixVersion=mySolveMatrixVersion;
    analyze=true;
  }
  SparseNumberedBlockMatrix S=mySolveMatrix;
  S.setZero();
  mySys.addVelJacobian(S,null,-1);
  mySys.addPosJacobian(S,null,-1);
  addActiveMassMatrix(mySys,S);
  if (myKKTSolver == null) {
    myKKTSolver=new KKTSolver();
    analyze=true;
  }
  if (myKKTGTVersion != myGTVersion) {
    analyze=true;
    myKKTGTVersion=myGTVersion;
  }
  if (analyze) {
    myKKTSolver.analyze(S,velSize,myGT,myRg,mySys.getSolveMatrixType());
  }
  if (myHybridSolveP && !analyze && myNT.colSize() == 0) {
    myKKTSolver.factorAndSolve(S,velSize,myGT,myRg,vel,myLam,myBf,myBg,myHybridSolveTol);
  }
 else {
    myKKTSolver.factor(S,velSize,myGT,myRg,myNT,myRn);
    myKKTSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  }
  if (computeKKTResidual) {
    double res=myKKTSolver.residual(S,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
}"
70861,"/** 
 * Solves a KKT system in which the Jacobian augmented M matrix and and force vectors are given by <pre> M' = M + a0 df/dv + a1 df/dx  bf' = bf + (a2 df/dv + a3 df/dx) vel0 </pre> It is assumed that a0 and a1 are both non-zero. It is also assumed that the a0 = -alpha h, where h is the step size and alpha indicates the propertion of implicitness for the solve; i.e., for regular backward euler, alpha=1, while for trapezoidal solves, alpha = 0.5; When used to solve for velocities in an implicit integrator, then on input, bf is assumed to be given by <pre> bf = M vel0 + h f </pre> where h is the time step and f is the generalized forces, while on output bf is modified to include the Jacobian terms described above.
 * @param vel returns the computed velocity
 * @param fpar if useFictitousJacobianForces is true, returns fictitious Jacobian forces for parametric components
 * @param bf right side offset
 * @param btmp temporary vector
 * @param vel0 right side velocity
 * @param h interval time step - used to scale constraint offsets and impulses
 * @param a0 left side df/dv coefficient
 * @param a1 left side df/dx coefficient
 * @param a2 right side df/dv coefficient
 * @param a3 right side df/dx coefficient
 */
public void KKTFactorAndSolve(VectorNd vel,VectorNd fpar,VectorNd bf,VectorNd btmp,VectorNd vel0,double h,double a0,double a1,double a2,double a3){
  updateStateSizes();
  int velSize=myActiveVelSize;
  boolean analyze=false;
  updateSolveMatrixStructure();
  if (myKKTSolveMatrixVersion != mySolveMatrixVersion) {
    myKKTSolveMatrixVersion=mySolveMatrixVersion;
    analyze=true;
  }
  SparseNumberedBlockMatrix S=mySolveMatrix;
  S.setZero();
  myC.setSize(S.rowSize());
  myC.setZero();
  mySys.addVelJacobian(S,myC,a0);
  if (useFictitousJacobianForces) {
    bf.scaledAdd(-a0,myC);
    if (fpar != null && myParametricVelSize > 0) {
      setSubVector(fpar,myC,velSize,myParametricVelSize);
    }
  }
  if (vel0 != null) {
    double alpha=a2 / a0 - a3 / a1;
    S.mul(btmp,vel0,velSize,velSize);
    bf.scaledAdd(alpha,btmp);
  }
  myC.setZero();
  mySys.addPosJacobian(S,myC,a1);
  if (useFictitousJacobianForces) {
    bf.scaledAdd(-a0,myC);
    if (fpar != null && myParametricVelSize > 0) {
      addSubVector(fpar,myC,velSize,myParametricVelSize);
    }
  }
  if (vel0 != null && a3 != 0) {
    double beta=a3 / a1;
    S.mul(btmp,vel0,velSize,velSize);
    bf.scaledAdd(beta,btmp);
  }
  addActiveMassMatrix(mySys,S);
  if (velSize > 0 && myParametricVelSize > 0) {
    S.mulTranspose(btmp,myUpar,0,velSize,velSize,myParametricVelSize);
    bf.sub(btmp);
  }
  if (myKKTSolver == null) {
    myKKTSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  if (myKKTGTVersion != myGTVersion) {
    analyze=true;
    myKKTGTVersion=myGTVersion;
  }
  if (myGsize > 0 && myParametricVelSize > 0) {
    myGT.mulTranspose(myBg,myUpar,0,myGsize,velSize,myParametricVelSize);
    myBg.negate();
  }
 else {
    myBg.setZero();
  }
  setBilateralOffsets(h,-a0);
  updateUnilateralConstraints();
  if (myNsize > 0 && myParametricVelSize > 0) {
    myNT.mulTranspose(myBn,myUpar,0,myNsize,velSize,myParametricVelSize);
    myBn.negate();
  }
 else {
    myBn.setZero();
  }
  setUnilateralOffsets(h,-a0);
  mySys.getBilateralImpulses(myLam);
  mySys.getUnilateralImpulses(myThe);
  if (!solveModePrinted) {
    String msg=(myHybridSolveP ? ""String_Node_Str"" : ""String_Node_Str"");
    if (mySys.getSolveMatrixType() == Matrix.INDEFINITE) {
      msg+=""String_Node_Str"";
    }
 else {
      msg+=""String_Node_Str"";
    }
    System.out.println(msg);
    solveModePrinted=true;
  }
  if (crsWriter == null && crsFileName != null) {
    try {
      crsWriter=ArtisynthIO.newIndentingPrintWriter(crsFileName);
    }
 catch (    Exception e) {
      crsFileName=null;
    }
  }
  if (velSize != 0) {
    if (vel0 != null) {
      vel.set(vel0);
    }
    if (analyze) {
      myKKTSolver.analyze(S,velSize,myGT,mySys.getSolveMatrixType());
    }
    if (myHybridSolveP && !analyze && myNT.colSize() == 0) {
      if (profileKKTSolveTime) {
        timerStart();
      }
      myKKTSolver.factorAndSolve(S,velSize,myGT,myRg,vel,myLam,bf,myBg,myHybridSolveTol);
      if (profileKKTSolveTime) {
        timerStop(""String_Node_Str"");
      }
    }
 else {
      if (profileKKTSolveTime) {
        timerStart();
      }
      myKKTSolver.factor(S,velSize,myGT,myRg,myNT,myRn);
      myKKTSolver.solve(vel,myLam,myThe,bf,myBg,myBn);
      if (profileKKTSolveTime) {
        timerStop(""String_Node_Str"");
      }
    }
    if (computeKKTResidual) {
      double res=myKKTSolver.residual(S,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,bf,myBg,myBn);
      System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
    }
    if (crsWriter != null) {
      String msg=""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ (analyze ? ""String_Node_Str"" : ""String_Node_Str"");
      System.out.println(msg);
      try {
        crsWriter.println(msg);
        myKKTSolver.printLinearProblem(crsWriter,bf,myBg,""String_Node_Str"",crsOmitDiag);
      }
 catch (      Exception e) {
        e.printStackTrace();
        crsWriter=null;
        crsFileName=null;
      }
    }
  }
  mySys.setBilateralImpulses(myLam,h);
  mySys.setUnilateralImpulses(myThe,h);
  if (myUpdateForcesAtStepEnd) {
    if (myGsize > 0) {
      myGT.mulAdd(myFcon,myLam,velSize,myGsize);
    }
    if (myNsize > 0) {
      myNT.mulAdd(myFcon,myThe,velSize,myNsize);
    }
  }
  if (myLogWriter != null) {
    try {
      NumberFormat fmt=new NumberFormat(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ velSize+ ""String_Node_Str"");
      S.write(myLogWriter,fmt,Matrix.WriteFormat.SYMMETRIC_CRS,velSize,velSize);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str"");
      myGT.write(myLogWriter,fmt,Matrix.WriteFormat.CRS,velSize,myGT.colSize());
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str"");
      myNT.write(myLogWriter,fmt,Matrix.WriteFormat.CRS,velSize,myNT.colSize());
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      bf.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myBg.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myBn.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      vel.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myLam.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myThe.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.flush();
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      e.printStackTrace();
      myLogWriter=null;
    }
  }
}","/** 
 * Solves a KKT system in which the Jacobian augmented M matrix and and force vectors are given by <pre> M' = M + a0 df/dv + a1 df/dx  bf' = bf + (a2 df/dv + a3 df/dx) vel0 </pre> It is assumed that a0 and a1 are both non-zero. It is also assumed that the a0 = -alpha h, where h is the step size and alpha indicates the propertion of implicitness for the solve; i.e., for regular backward euler, alpha=1, while for trapezoidal solves, alpha = 0.5; When used to solve for velocities in an implicit integrator, then on input, bf is assumed to be given by <pre> bf = M vel0 + h f </pre> where h is the time step and f is the generalized forces, while on output bf is modified to include the Jacobian terms described above.
 * @param vel returns the computed velocity
 * @param fpar if useFictitousJacobianForces is true, returns fictitious Jacobian forces for parametric components
 * @param bf right side offset
 * @param btmp temporary vector
 * @param vel0 right side velocity
 * @param h interval time step - used to scale constraint offsets and impulses
 * @param a0 left side df/dv coefficient
 * @param a1 left side df/dx coefficient
 * @param a2 right side df/dv coefficient
 * @param a3 right side df/dx coefficient
 */
public void KKTFactorAndSolve(VectorNd vel,VectorNd fpar,VectorNd bf,VectorNd btmp,VectorNd vel0,double h,double a0,double a1,double a2,double a3){
  updateStateSizes();
  int velSize=myActiveVelSize;
  boolean analyze=false;
  updateSolveMatrixStructure();
  if (myKKTSolveMatrixVersion != mySolveMatrixVersion) {
    myKKTSolveMatrixVersion=mySolveMatrixVersion;
    analyze=true;
  }
  SparseNumberedBlockMatrix S=mySolveMatrix;
  S.setZero();
  myC.setSize(S.rowSize());
  myC.setZero();
  mySys.addVelJacobian(S,myC,a0);
  if (useFictitousJacobianForces) {
    bf.scaledAdd(-a0,myC);
    if (fpar != null && myParametricVelSize > 0) {
      setSubVector(fpar,myC,velSize,myParametricVelSize);
    }
  }
  if (vel0 != null) {
    double alpha=a2 / a0 - a3 / a1;
    S.mul(btmp,vel0,velSize,velSize);
    bf.scaledAdd(alpha,btmp);
  }
  myC.setZero();
  mySys.addPosJacobian(S,myC,a1);
  if (useFictitousJacobianForces) {
    bf.scaledAdd(-a0,myC);
    if (fpar != null && myParametricVelSize > 0) {
      addSubVector(fpar,myC,velSize,myParametricVelSize);
    }
  }
  if (vel0 != null && a3 != 0) {
    double beta=a3 / a1;
    S.mul(btmp,vel0,velSize,velSize);
    bf.scaledAdd(beta,btmp);
  }
  addActiveMassMatrix(mySys,S);
  if (velSize > 0 && myParametricVelSize > 0) {
    S.mulTranspose(btmp,myUpar,0,velSize,velSize,myParametricVelSize);
    bf.sub(btmp);
  }
  if (myKKTSolver == null) {
    myKKTSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  if (myKKTGTVersion != myGTVersion) {
    analyze=true;
    myKKTGTVersion=myGTVersion;
  }
  if (myGsize > 0 && myParametricVelSize > 0) {
    myGT.mulTranspose(myBg,myUpar,0,myGsize,velSize,myParametricVelSize);
    myBg.negate();
  }
 else {
    myBg.setZero();
  }
  setBilateralOffsets(h,-a0);
  updateUnilateralConstraints();
  if (myNsize > 0 && myParametricVelSize > 0) {
    myNT.mulTranspose(myBn,myUpar,0,myNsize,velSize,myParametricVelSize);
    myBn.negate();
  }
 else {
    myBn.setZero();
  }
  setUnilateralOffsets(h,-a0);
  mySys.getBilateralImpulses(myLam);
  mySys.getUnilateralImpulses(myThe);
  if (!solveModePrinted) {
    String msg=(myHybridSolveP ? ""String_Node_Str"" : ""String_Node_Str"");
    if (mySys.getSolveMatrixType() == Matrix.INDEFINITE) {
      msg+=""String_Node_Str"";
    }
 else {
      msg+=""String_Node_Str"";
    }
    System.out.println(msg);
    solveModePrinted=true;
  }
  if (crsWriter == null && crsFileName != null) {
    try {
      crsWriter=ArtisynthIO.newIndentingPrintWriter(crsFileName);
    }
 catch (    Exception e) {
      crsFileName=null;
    }
  }
  if (velSize != 0) {
    if (vel0 != null) {
      vel.set(vel0);
    }
    if (analyze) {
      myKKTSolver.analyze(S,velSize,myGT,myRg,mySys.getSolveMatrixType());
    }
    if (myHybridSolveP && !analyze && myNT.colSize() == 0) {
      if (profileKKTSolveTime) {
        timerStart();
      }
      myKKTSolver.factorAndSolve(S,velSize,myGT,myRg,vel,myLam,bf,myBg,myHybridSolveTol);
      if (profileKKTSolveTime) {
        timerStop(""String_Node_Str"");
      }
    }
 else {
      if (profileKKTSolveTime) {
        timerStart();
      }
      myKKTSolver.factor(S,velSize,myGT,myRg,myNT,myRn);
      myKKTSolver.solve(vel,myLam,myThe,bf,myBg,myBn);
      if (profileKKTSolveTime) {
        timerStop(""String_Node_Str"");
      }
    }
    if (computeKKTResidual) {
      double res=myKKTSolver.residual(S,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,bf,myBg,myBn);
      System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
    }
    if (crsWriter != null) {
      String msg=""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ (analyze ? ""String_Node_Str"" : ""String_Node_Str"");
      System.out.println(msg);
      try {
        crsWriter.println(msg);
        myKKTSolver.printLinearProblem(crsWriter,bf,myBg,""String_Node_Str"",crsOmitDiag);
      }
 catch (      Exception e) {
        e.printStackTrace();
        crsWriter=null;
        crsFileName=null;
      }
    }
  }
  mySys.setBilateralImpulses(myLam,h);
  mySys.setUnilateralImpulses(myThe,h);
  if (myUpdateForcesAtStepEnd) {
    if (myGsize > 0) {
      myGT.mulAdd(myFcon,myLam,velSize,myGsize);
    }
    if (myNsize > 0) {
      myNT.mulAdd(myFcon,myThe,velSize,myNsize);
    }
  }
  if (myLogWriter != null) {
    try {
      NumberFormat fmt=new NumberFormat(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ velSize+ ""String_Node_Str"");
      S.write(myLogWriter,fmt,Matrix.WriteFormat.SYMMETRIC_CRS,velSize,velSize);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str"");
      myGT.write(myLogWriter,fmt,Matrix.WriteFormat.CRS,velSize,myGT.colSize());
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str"");
      myNT.write(myLogWriter,fmt,Matrix.WriteFormat.CRS,velSize,myNT.colSize());
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      bf.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myBg.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myBn.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      vel.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myLam.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myThe.write(myLogWriter,fmt);
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.println(""String_Node_Str"");
      myLogWriter.flush();
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      e.printStackTrace();
      myLogWriter=null;
    }
  }
}"
70862,"protected void computeVelCorrections(VectorNd vel,double t0,double t1){
  double h=t1 - t0;
  int velSize=myActiveVelSize;
  if (velSize == 0) {
    return;
  }
  if (myConSolver == null) {
    myConSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  updateUnilateralConstraints();
  if (myGsize == 0 && myNsize == 0) {
    return;
  }
  if (myGsize > 0 && myParametricVelSize > 0) {
    myGT.mulTranspose(myBg,myUpar,0,myGsize,velSize,myParametricVelSize);
    myBg.negate();
  }
 else {
    myBg.setZero();
  }
  setBilateralOffsets(h,0);
  if (myNsize > 0 && myParametricVelSize > 0) {
    myNT.mulTranspose(myBn,myUpar,0,myNsize,velSize,myParametricVelSize);
    myBn.negate();
  }
 else {
    myBn.setZero();
  }
  setUnilateralOffsets(h,0);
  myBf.setSize(velSize);
  myMass.mul(myBf,vel,velSize,velSize);
  if (myConMassVersion != myMassVersion || myConGTVersion != myGTVersion) {
    myConSolver.analyze(myMass,velSize,myGT,Matrix.SPD);
    myConMassVersion=myMassVersion;
    myConGTVersion=myGTVersion;
  }
  mySys.getBilateralImpulses(myLam);
  mySys.getUnilateralImpulses(myThe);
  myConSolver.factor(myMass,velSize,myGT,myRg,myNT,myRn);
  myConSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  if (computeKKTResidual) {
    double res=myConSolver.residual(myMass,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
  mySys.setBilateralImpulses(myLam,h);
  mySys.setUnilateralImpulses(myThe,h);
  if (myUpdateForcesAtStepEnd) {
    if (myGsize > 0) {
      myGT.mulAdd(myFcon,myLam,velSize,myGsize);
    }
    if (myNsize > 0) {
      myNT.mulAdd(myFcon,myThe,velSize,myNsize);
    }
  }
}","protected void computeVelCorrections(VectorNd vel,double t0,double t1){
  double h=t1 - t0;
  int velSize=myActiveVelSize;
  if (velSize == 0) {
    return;
  }
  if (myConSolver == null) {
    myConSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  updateUnilateralConstraints();
  if (myGsize == 0 && myNsize == 0) {
    return;
  }
  if (myGsize > 0 && myParametricVelSize > 0) {
    myGT.mulTranspose(myBg,myUpar,0,myGsize,velSize,myParametricVelSize);
    myBg.negate();
  }
 else {
    myBg.setZero();
  }
  setBilateralOffsets(h,0);
  if (myNsize > 0 && myParametricVelSize > 0) {
    myNT.mulTranspose(myBn,myUpar,0,myNsize,velSize,myParametricVelSize);
    myBn.negate();
  }
 else {
    myBn.setZero();
  }
  setUnilateralOffsets(h,0);
  myBf.setSize(velSize);
  myMass.mul(myBf,vel,velSize,velSize);
  if (myConMassVersion != myMassVersion || myConGTVersion != myGTVersion) {
    myConSolver.analyze(myMass,velSize,myGT,myRg,Matrix.SPD);
    myConMassVersion=myMassVersion;
    myConGTVersion=myGTVersion;
  }
  mySys.getBilateralImpulses(myLam);
  mySys.getUnilateralImpulses(myThe);
  myConSolver.factor(myMass,velSize,myGT,myRg,myNT,myRn);
  myConSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  if (computeKKTResidual) {
    double res=myConSolver.residual(myMass,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
  mySys.setBilateralImpulses(myLam,h);
  mySys.setUnilateralImpulses(myThe,h);
  if (myUpdateForcesAtStepEnd) {
    if (myGsize > 0) {
      myGT.mulAdd(myFcon,myLam,velSize,myGsize);
    }
    if (myNsize > 0) {
      myNT.mulAdd(myFcon,myThe,velSize,myNsize);
    }
  }
}"
70863,"protected void computeMassPosCorrection(VectorNd vel,int velSize){
  if (myConMassVersion != myMassVersion || myConGTVersion != myGTVersion) {
    myConSolver.analyze(myMass,velSize,myGT,Matrix.SPD);
    myConMassVersion=myMassVersion;
    myConGTVersion=myGTVersion;
  }
  myConSolver.factor(myMass,velSize,myGT,myRg,myNT,myRn);
  myConSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  if (computeKKTResidual) {
    double res=myConSolver.residual(myMass,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
}","protected void computeMassPosCorrection(VectorNd vel,int velSize){
  if (myConMassVersion != myMassVersion || myConGTVersion != myGTVersion) {
    myConSolver.analyze(myMass,velSize,myGT,myRg,Matrix.SPD);
    myConMassVersion=myMassVersion;
    myConGTVersion=myGTVersion;
  }
  myConSolver.factor(myMass,velSize,myGT,myRg,myNT,myRn);
  myConSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  if (computeKKTResidual) {
    double res=myConSolver.residual(myMass,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
}"
70864,"protected void constrainedVelSolve(VectorNd vel,VectorNd f,double t0,double t1){
  double h=t1 - t0;
  int velSize=myActiveVelSize;
  if (velSize == 0) {
    return;
  }
  if (myConSolver == null) {
    myConSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  updateUnilateralConstraints();
  if (myGsize > 0 && myParametricVelSize > 0) {
    myGT.mulTranspose(myBg,myUpar,0,myGsize,velSize,myParametricVelSize);
    myBg.negate();
  }
 else {
    myBg.setZero();
  }
  setBilateralOffsets(h,0);
  if (myNsize > 0 && myParametricVelSize > 0) {
    myNT.mulTranspose(myBn,myUpar,0,myNsize,velSize,myParametricVelSize);
    myBn.negate();
  }
 else {
    myBn.setZero();
  }
  setUnilateralOffsets(h,0);
  myBf.setSize(velSize);
  if (myParametricVelSize > 0) {
    myMass.mul(myBf,myUpar,0,velSize,velSize,myParametricVelSize);
    myBf.negate();
  }
 else {
    myBf.setZero();
  }
  myBf.scaledAdd(h,myMassForces);
  myBf.scaledAdd(h,f);
  myMass.mulAdd(myBf,vel,velSize,velSize);
  if (myConMassVersion != myMassVersion || myConGTVersion != myGTVersion) {
    myConSolver.analyze(myMass,velSize,myGT,Matrix.SPD);
    myConMassVersion=myMassVersion;
    myConGTVersion=myGTVersion;
  }
  mySys.getBilateralImpulses(myLam);
  mySys.getUnilateralImpulses(myThe);
  myConSolver.factor(myMass,velSize,myGT,myRg,myNT,myRn);
  myConSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  if (computeKKTResidual) {
    double res=myConSolver.residual(myMass,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
  mySys.setBilateralImpulses(myLam,h);
  mySys.setUnilateralImpulses(myThe,h);
  if (myUpdateForcesAtStepEnd) {
    if (myGsize > 0) {
      myGT.mulAdd(myFcon,myLam,velSize,myGsize);
    }
    if (myNsize > 0) {
      myNT.mulAdd(myFcon,myThe,velSize,myNsize);
    }
  }
}","protected void constrainedVelSolve(VectorNd vel,VectorNd f,double t0,double t1){
  double h=t1 - t0;
  int velSize=myActiveVelSize;
  if (velSize == 0) {
    return;
  }
  if (myConSolver == null) {
    myConSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  updateUnilateralConstraints();
  if (myGsize > 0 && myParametricVelSize > 0) {
    myGT.mulTranspose(myBg,myUpar,0,myGsize,velSize,myParametricVelSize);
    myBg.negate();
  }
 else {
    myBg.setZero();
  }
  setBilateralOffsets(h,0);
  if (myNsize > 0 && myParametricVelSize > 0) {
    myNT.mulTranspose(myBn,myUpar,0,myNsize,velSize,myParametricVelSize);
    myBn.negate();
  }
 else {
    myBn.setZero();
  }
  setUnilateralOffsets(h,0);
  myBf.setSize(velSize);
  if (myParametricVelSize > 0) {
    myMass.mul(myBf,myUpar,0,velSize,velSize,myParametricVelSize);
    myBf.negate();
  }
 else {
    myBf.setZero();
  }
  myBf.scaledAdd(h,myMassForces);
  myBf.scaledAdd(h,f);
  myMass.mulAdd(myBf,vel,velSize,velSize);
  if (myConMassVersion != myMassVersion || myConGTVersion != myGTVersion) {
    myConSolver.analyze(myMass,velSize,myGT,myRg,Matrix.SPD);
    myConMassVersion=myMassVersion;
    myConGTVersion=myGTVersion;
  }
  mySys.getBilateralImpulses(myLam);
  mySys.getUnilateralImpulses(myThe);
  myConSolver.factor(myMass,velSize,myGT,myRg,myNT,myRn);
  myConSolver.solve(vel,myLam,myThe,myBf,myBg,myBn);
  if (computeKKTResidual) {
    double res=myConSolver.residual(myMass,velSize,myGT,myRg,myNT,myRn,vel,myLam,myThe,myBf,myBg,myBn);
    System.out.println(""String_Node_Str"" + velSize + ""String_Node_Str""+ myGT.colSize()+ ""String_Node_Str""+ myNT.colSize()+ ""String_Node_Str""+ res);
  }
  mySys.setBilateralImpulses(myLam,h);
  mySys.setUnilateralImpulses(myThe,h);
  if (myUpdateForcesAtStepEnd) {
    if (myGsize > 0) {
      myGT.mulAdd(myFcon,myLam,velSize,myGsize);
    }
    if (myNsize > 0) {
      myNT.mulAdd(myFcon,myThe,velSize,myNsize);
    }
  }
}"
70865,"private void doUpdateStructure(SparseBlockMatrix M,SparseBlockMatrix GT){
  int nactive=mySys.numActiveComponents();
  myNumActiveBodies=0;
  for (int ci=0; ci < nactive; ci++) {
    if (componentIsRigidBody(ci,M)) {
      myNumActiveBodies++;
    }
  }
  if (myNumActiveBodies > 0) {
    myBodyCompMap=new int[myNumActiveBodies];
    myCompBodyMap=new int[nactive];
    int bi=0;
    for (int ci=0; ci < nactive; ci++) {
      if (componentIsRigidBody(ci,M)) {
        myCompBodyMap[ci]=bi;
        myBodyCompMap[bi]=ci;
        bi++;
      }
 else {
        myCompBodyMap[ci]=-1;
      }
    }
    myMassSizes=new int[myNumActiveBodies];
    mySizeM=0;
    for (bi=0; bi < myNumActiveBodies; bi++) {
      int size=M.getBlockRowSize(myBodyCompMap[bi]);
      myMassSizes[bi]=size;
      mySizeM+=size;
    }
    myVelIdxs=new int[mySizeM];
    myMass=new SparseBlockMatrix(myMassSizes);
    int boff=0;
    for (bi=0; bi < myNumActiveBodies; bi++) {
      int ci=myBodyCompMap[bi];
      myMass.addBlock(bi,bi,M.getBlock(ci,ci).clone());
      int vidx=M.getBlockRowOffset(ci);
      int size=myMassSizes[bi];
      for (int k=0; k < size; k++) {
        myVelIdxs[boff + k]=vidx++;
      }
      boff+=size;
    }
    myVel=new VectorNd(mySizeM);
    myBf=new VectorNd(mySizeM);
    myGT=new SparseBlockMatrix(myMassSizes,new int[0]);
    myGTMap=createConstraintMatrix(myGT,GT,G_MATRIX);
    mySizeG=myGT.colSize();
    myLamIdxs=createConstraintIdxs(GT,myGTMap,mySizeG);
    myLam.setSize(mySizeG);
    myBg.setSize(mySizeG);
    myRg.setSize(mySizeG);
    mySolver.analyze(myMass,mySizeM,myGT,Matrix.SPD);
  }
}","private void doUpdateStructure(SparseBlockMatrix M,SparseBlockMatrix GT){
  int nactive=mySys.numActiveComponents();
  myNumActiveBodies=0;
  for (int ci=0; ci < nactive; ci++) {
    if (componentIsRigidBody(ci,M)) {
      myNumActiveBodies++;
    }
  }
  if (myNumActiveBodies > 0) {
    myBodyCompMap=new int[myNumActiveBodies];
    myCompBodyMap=new int[nactive];
    int bi=0;
    for (int ci=0; ci < nactive; ci++) {
      if (componentIsRigidBody(ci,M)) {
        myCompBodyMap[ci]=bi;
        myBodyCompMap[bi]=ci;
        bi++;
      }
 else {
        myCompBodyMap[ci]=-1;
      }
    }
    myMassSizes=new int[myNumActiveBodies];
    mySizeM=0;
    for (bi=0; bi < myNumActiveBodies; bi++) {
      int size=M.getBlockRowSize(myBodyCompMap[bi]);
      myMassSizes[bi]=size;
      mySizeM+=size;
    }
    myVelIdxs=new int[mySizeM];
    myMass=new SparseBlockMatrix(myMassSizes);
    int boff=0;
    for (bi=0; bi < myNumActiveBodies; bi++) {
      int ci=myBodyCompMap[bi];
      myMass.addBlock(bi,bi,M.getBlock(ci,ci).clone());
      int vidx=M.getBlockRowOffset(ci);
      int size=myMassSizes[bi];
      for (int k=0; k < size; k++) {
        myVelIdxs[boff + k]=vidx++;
      }
      boff+=size;
    }
    myVel=new VectorNd(mySizeM);
    myBf=new VectorNd(mySizeM);
    myGT=new SparseBlockMatrix(myMassSizes,new int[0]);
    myGTMap=createConstraintMatrix(myGT,GT,G_MATRIX);
    mySizeG=myGT.colSize();
    myLamIdxs=createConstraintIdxs(GT,myGTMap,mySizeG);
    myLam.setSize(mySizeG);
    myBg.setSize(mySizeG);
    myRg.setSize(mySizeG);
    mySolver.analyze(myMass,mySizeM,myGT,myRg,Matrix.SPD);
  }
}"
70866,"public void build(String[] args){
  MechModel mech=new MechModel(""String_Node_Str"");
  addModel(mech);
  RigidBody ball=RigidBody.createIcosahedralSphere(""String_Node_Str"",0.8,0.1,1);
  ball.setPose(new RigidTransform3d(0,0,0,0.4,0.1,0.1));
  ball.setDynamic(false);
  mech.addRigidBody(ball);
  RigidBody plate=RigidBody.createBox(""String_Node_Str"",5,5,5,1);
  plate.setPose(new RigidTransform3d(0,0,2.94,1,0,0,0));
  plate.setDynamic(false);
  mech.addRigidBody(plate);
  mech.setDefaultCollisionBehavior(true,0.20);
  RenderProps.setFaceStyle(ball,RenderProps.Faces.NONE);
  RenderProps.setDrawEdges(ball,true);
  RenderProps.setEdgeColor(ball,Color.WHITE);
  RenderProps.setVisible(plate,false);
  RenderProps.setAlpha(plate,0.5);
  CollisionManager cm=mech.getCollisionManager();
  RenderProps.setVisible(cm,true);
  RenderProps.setLineWidth(cm,3);
  RenderProps.setLineColor(cm,Color.RED);
  RenderProps.setEdgeWidth(cm,3);
  RenderProps.setEdgeColor(cm,Color.BLUE);
  cm.setContactNormalLen(0.5);
  cm.setDrawIntersectionContours(true);
  cm.setDrawIntersectionFaces(true);
  addMonitor(new PenetrationRenderer(cm.collisionHandlers().get(0)));
}","public void build(String[] args){
  MechModel mech=new MechModel(""String_Node_Str"");
  addModel(mech);
  RigidBody ball=RigidBody.createIcosahedralSphere(""String_Node_Str"",0.8,0.1,1);
  ball.setPose(new RigidTransform3d(0,0,0,0.4,0.1,0.1));
  ball.setDynamic(false);
  mech.addRigidBody(ball);
  RigidBody plate=RigidBody.createBox(""String_Node_Str"",5,5,5,1);
  plate.setPose(new RigidTransform3d(0,0,2.94,1,0,0,0));
  plate.setDynamic(false);
  mech.addRigidBody(plate);
  mech.setDefaultCollisionBehavior(true,0.20);
  RenderProps.setFaceStyle(ball,RenderProps.Faces.NONE);
  RenderProps.setDrawEdges(ball,true);
  RenderProps.setEdgeColor(ball,Color.WHITE);
  RenderProps.setVisible(plate,false);
  RenderProps.setAlpha(plate,0.5);
  CollisionManager cm=mech.getCollisionManager();
  RenderProps.setVisible(cm,true);
  RenderProps.setLineWidth(cm,3);
  RenderProps.setLineColor(cm,Color.RED);
  RenderProps.setEdgeWidth(cm,3);
  RenderProps.setEdgeColor(cm,Color.BLUE);
  cm.setContactNormalLen(0.5);
  cm.setDrawIntersectionContours(true);
  cm.setDrawIntersectionFaces(true);
  cm.setDrawIntersectionPoints(true);
  addMonitor(new PenetrationRenderer(cm.collisionHandlers().get(0)));
}"
70867,"public void printLinearProblem(PrintWriter pw,VectorNd bf,VectorNd bg,String fmtStr,boolean omitLowerRightDiagonal) throws IOException {
  NumberFormat fmt=new NumberFormat(fmtStr);
  int size=mySizeM + myNumG;
  int nnz=myNumVals;
  if (omitLowerRightDiagonal) {
    nnz-=myNumG;
  }
  pw.println(size);
  for (int i=0; i < size + 1; i++) {
    pw.print(Math.min(nnz + 1,myRowOffs[i]));
    if (i < size) {
      pw.print(""String_Node_Str"");
    }
  }
  pw.println(""String_Node_Str"");
  for (int i=0; i < nnz; i++) {
    pw.print(myColIdxs[i]);
    if (i < nnz - 1) {
      pw.print(""String_Node_Str"");
    }
  }
  pw.println(""String_Node_Str"");
  for (int i=0; i < nnz; i++) {
    pw.print(fmt.format(myVals[i]));
    if (i < nnz - 1) {
      pw.print(""String_Node_Str"");
    }
  }
  pw.println(""String_Node_Str"");
  bf.write(pw,fmt);
  pw.print(""String_Node_Str"");
  bg.write(pw,fmt);
  pw.println(""String_Node_Str"");
  pw.flush();
}","public void printLinearProblem(PrintWriter pw,VectorNd bf,VectorNd bg,String fmtStr,boolean omitLowerRightDiagonal) throws IOException {
  NumberFormat fmt=new NumberFormat(fmtStr);
  int size=mySizeM + myNumG;
  int nnz=myNumVals;
  if (omitLowerRightDiagonal) {
    nnz-=myNumG;
  }
  if (myPartitionM == Matrix.Partition.UpperTriangular) {
    pw.print(""String_Node_Str"");
  }
  pw.println(size);
  for (int i=0; i < size + 1; i++) {
    pw.print(Math.min(nnz + 1,myRowOffs[i]));
    if (i < size) {
      pw.print(""String_Node_Str"");
    }
  }
  pw.println(""String_Node_Str"");
  for (int i=0; i < nnz; i++) {
    pw.print(myColIdxs[i]);
    if (i < nnz - 1) {
      pw.print(""String_Node_Str"");
    }
  }
  pw.println(""String_Node_Str"");
  for (int i=0; i < nnz; i++) {
    pw.print(fmt.format(myVals[i]));
    if (i < nnz - 1) {
      pw.print(""String_Node_Str"");
    }
  }
  pw.println(""String_Node_Str"");
  bf.write(pw,fmt);
  pw.print(""String_Node_Str"");
  bg.write(pw,fmt);
  pw.println(""String_Node_Str"");
  pw.flush();
}"
70868,"/** 
 * Performs symbolic analysis on the equality portion of the KKT system defined by matrices M and GT. This step must be called before any calls are made to factor().
 * @param M Sparse matrix defining M
 * @param sizeM size of M 
 * @param GT Sparse matrix defining the transpose of G
 * @param typeM describes the type of M, to be used in determining how the resulting KKT system should be factored. Should be either  {@link Matrix#INDEFINITE},   {@link Matrix#SYMMETRIC}, or  {@link Matrix#SPD}. 
 */
public void analyze(SparseBlockMatrix M,int sizeM,SparseBlockMatrix GT,int typeM){
  analyzeMG(M,sizeM,GT,null,typeM);
}","/** 
 * Performs symbolic analysis on the equality portion of the KKT system defined by matrices M and GT. This step must be called before any calls are made to factor().
 * @param M Sparse matrix defining M
 * @param sizeM size of M 
 * @param GT Sparse matrix defining the transpose of G
 * @param Rg if non-null, supplies the diagonal regularization matrix R
 * @param typeM describes the type of M, to be used in determining how the resulting KKT system should be factored. Should be either  {@link Matrix#INDEFINITE},   {@link Matrix#SYMMETRIC}, or  {@link Matrix#SPD}. 
 */
public void analyze(SparseBlockMatrix M,int sizeM,SparseBlockMatrix GT,VectorNd Rg,int typeM){
  analyzeMG(M,sizeM,GT,Rg,typeM);
}"
70869,"private void solveAndCheck(Object M,int sizeM,SparseBlockMatrix GT,SparseBlockMatrix NT,VectorNd Rg,VectorNd Rn,VectorNd bm,VectorNd bg,VectorNd bn,VectorNd vel,VectorNd lam,VectorNd the,int typeM){
  SparseBlockMatrix DT=null;
  VectorNd mu=null;
  VectorNd bet=null;
  int[] Dref=null;
  int numG=GT.colSize();
  int numN=0;
  if (NT != null && NT.colSize() > 0) {
    numN=NT.colSize();
  }
  KKTSolver solver=new KKTSolver();
  if (M instanceof SparseBlockMatrix) {
    solver.analyze((SparseBlockMatrix)M,sizeM,GT,typeM);
  }
 else {
    solver.analyze((VectorNd)M,sizeM,GT);
  }
  Status status;
  if (numN == 0) {
    if (M instanceof SparseBlockMatrix) {
      solver.factor((SparseBlockMatrix)M,sizeM,GT,Rg);
    }
 else {
      solver.factor((VectorNd)M,sizeM,GT,Rg);
    }
    status=solver.solve(vel,lam,bm,bg);
  }
 else {
    if (M instanceof SparseBlockMatrix) {
      solver.factor((SparseBlockMatrix)M,sizeM,GT,Rg,NT,Rn);
    }
 else {
      solver.factor((VectorNd)M,sizeM,GT,Rg,NT,Rn);
    }
    status=solver.solve(vel,lam,the,bm,bg,bn);
  }
  if (status != Status.SOLVED) {
    throw new TestException(""String_Node_Str"" + status);
  }
  VectorNd bmCheck=new VectorNd(sizeM);
  VectorNd bgCheck=new VectorNd(numG);
  if (checkSolve(M,sizeM,GT,NT,vel,lam,the,bm,bmCheck) > 1e-8) {
    throw new TestException(""String_Node_Str"" + bm.toString(""String_Node_Str"") + ""String_Node_Str""+ bmCheck.toString(""String_Node_Str""));
  }
  checkComplementarity(GT,NT,null,Rg,Rn,bg,bn,null,null,vel,lam,the,null);
}","private void solveAndCheck(Object M,int sizeM,SparseBlockMatrix GT,SparseBlockMatrix NT,VectorNd Rg,VectorNd Rn,VectorNd bm,VectorNd bg,VectorNd bn,VectorNd vel,VectorNd lam,VectorNd the,int typeM){
  SparseBlockMatrix DT=null;
  VectorNd mu=null;
  VectorNd bet=null;
  int[] Dref=null;
  int numG=GT.colSize();
  int numN=0;
  if (NT != null && NT.colSize() > 0) {
    numN=NT.colSize();
  }
  KKTSolver solver=new KKTSolver();
  if (M instanceof SparseBlockMatrix) {
    solver.analyze((SparseBlockMatrix)M,sizeM,GT,Rg,typeM);
  }
 else {
    solver.analyze((VectorNd)M,sizeM,GT,Rg);
  }
  Status status;
  if (numN == 0) {
    if (M instanceof SparseBlockMatrix) {
      solver.factor((SparseBlockMatrix)M,sizeM,GT,Rg);
    }
 else {
      solver.factor((VectorNd)M,sizeM,GT,Rg);
    }
    status=solver.solve(vel,lam,bm,bg);
  }
 else {
    if (M instanceof SparseBlockMatrix) {
      solver.factor((SparseBlockMatrix)M,sizeM,GT,Rg,NT,Rn);
    }
 else {
      solver.factor((VectorNd)M,sizeM,GT,Rg,NT,Rn);
    }
    status=solver.solve(vel,lam,the,bm,bg,bn);
  }
  if (status != Status.SOLVED) {
    throw new TestException(""String_Node_Str"" + status);
  }
  VectorNd bmCheck=new VectorNd(sizeM);
  VectorNd bgCheck=new VectorNd(numG);
  if (checkSolve(M,sizeM,GT,NT,vel,lam,the,bm,bmCheck) > 1e-8) {
    throw new TestException(""String_Node_Str"" + bm.toString(""String_Node_Str"") + ""String_Node_Str""+ bmCheck.toString(""String_Node_Str""));
  }
  checkComplementarity(GT,NT,null,Rg,Rn,bg,bn,null,null,vel,lam,the,null);
}"
70870,"void testMLCP(MLCP mlcp){
  KKTSolver solver=new KKTSolver();
  if (mlcp.M == null) {
    throw new TestException(""String_Node_Str"");
  }
  int Mtype=Matrix.INDEFINITE;
  if (mlcp.M.isSymmetric(0)) {
    Mtype=Matrix.SYMMETRIC;
  }
  int sizeM=mlcp.M.rowSize();
  VectorNd vel=new VectorNd(sizeM);
  int sizeG=mlcp.GT != null ? mlcp.GT.colSize() : 0;
  VectorNd Rg=mlcp.Rg != null ? mlcp.Rg : new VectorNd(sizeG);
  VectorNd bg=mlcp.bg != null ? mlcp.bg : new VectorNd(sizeG);
  VectorNd lam=new VectorNd(sizeG);
  int sizeN=mlcp.NT != null ? mlcp.NT.colSize() : 0;
  VectorNd Rn=mlcp.Rn != null ? mlcp.Rn : new VectorNd(sizeN);
  VectorNd bn=mlcp.bn != null ? mlcp.bn : new VectorNd(sizeN);
  VectorNd the=new VectorNd(sizeN);
  int sizeD=mlcp.DT != null ? mlcp.DT.colSize() : 0;
  VectorNd bd=mlcp.bd != null ? mlcp.bd : new VectorNd(sizeD);
  VectorNd phi=new VectorNd(sizeD);
  Status status;
  solver.analyze(mlcp.M,sizeM,mlcp.GT,Mtype);
  if (sizeN == 0) {
    solver.factor(mlcp.M,sizeM,mlcp.GT,Rg);
    status=solver.solve(vel,lam,mlcp.bf,bg);
  }
 else   if (sizeD == 0) {
    solver.factor(mlcp.M,sizeM,mlcp.GT,Rg,mlcp.NT,Rn);
    status=solver.solve(vel,lam,the,mlcp.bf,bg,bn);
  }
 else {
    solver.factor(mlcp.M,sizeM,mlcp.GT,Rg,mlcp.NT,Rn,mlcp.DT);
    status=solver.solve(vel,lam,the,phi,mlcp.bf,bg,bn,bd,mlcp.flim);
  }
  if (status != Status.SOLVED) {
    throw new TestException(""String_Node_Str"" + status);
  }
  if (mlcp.vel != null) {
    checkResult(""String_Node_Str"",vel,mlcp.vel);
  }
  if (sizeG != 0 && mlcp.lam != null) {
    checkResult(""String_Node_Str"",lam,mlcp.lam);
  }
  if (sizeN != 0 && mlcp.the != null) {
    checkResult(""String_Node_Str"",the,mlcp.the);
  }
  if (sizeD != 0 && mlcp.phi != null) {
    checkResult(""String_Node_Str"",phi,mlcp.phi);
  }
  checkComplementarity(mlcp.GT,mlcp.NT,mlcp.DT,Rg,Rn,bg,bn,bd,mlcp.flim,vel,lam,the,phi);
  if (verbose && mlcp.name != null && mlcp.name.length() > 0) {
    System.out.println(mlcp.name + ""String_Node_Str"");
  }
}","void testMLCP(MLCP mlcp){
  KKTSolver solver=new KKTSolver();
  if (mlcp.M == null) {
    throw new TestException(""String_Node_Str"");
  }
  int Mtype=Matrix.INDEFINITE;
  if (mlcp.M.isSymmetric(0)) {
    Mtype=Matrix.SYMMETRIC;
  }
  int sizeM=mlcp.M.rowSize();
  VectorNd vel=new VectorNd(sizeM);
  int sizeG=mlcp.GT != null ? mlcp.GT.colSize() : 0;
  VectorNd Rg=mlcp.Rg != null ? mlcp.Rg : new VectorNd(sizeG);
  VectorNd bg=mlcp.bg != null ? mlcp.bg : new VectorNd(sizeG);
  VectorNd lam=new VectorNd(sizeG);
  int sizeN=mlcp.NT != null ? mlcp.NT.colSize() : 0;
  VectorNd Rn=mlcp.Rn != null ? mlcp.Rn : new VectorNd(sizeN);
  VectorNd bn=mlcp.bn != null ? mlcp.bn : new VectorNd(sizeN);
  VectorNd the=new VectorNd(sizeN);
  int sizeD=mlcp.DT != null ? mlcp.DT.colSize() : 0;
  VectorNd bd=mlcp.bd != null ? mlcp.bd : new VectorNd(sizeD);
  VectorNd phi=new VectorNd(sizeD);
  Status status;
  solver.analyze(mlcp.M,sizeM,mlcp.GT,Rg,Mtype);
  if (sizeN == 0) {
    solver.factor(mlcp.M,sizeM,mlcp.GT,Rg);
    status=solver.solve(vel,lam,mlcp.bf,bg);
  }
 else   if (sizeD == 0) {
    solver.factor(mlcp.M,sizeM,mlcp.GT,Rg,mlcp.NT,Rn);
    status=solver.solve(vel,lam,the,mlcp.bf,bg,bn);
  }
 else {
    solver.factor(mlcp.M,sizeM,mlcp.GT,Rg,mlcp.NT,Rn,mlcp.DT);
    status=solver.solve(vel,lam,the,phi,mlcp.bf,bg,bn,bd,mlcp.flim);
  }
  if (status != Status.SOLVED) {
    throw new TestException(""String_Node_Str"" + status);
  }
  if (mlcp.vel != null) {
    checkResult(""String_Node_Str"",vel,mlcp.vel);
  }
  if (sizeG != 0 && mlcp.lam != null) {
    checkResult(""String_Node_Str"",lam,mlcp.lam);
  }
  if (sizeN != 0 && mlcp.the != null) {
    checkResult(""String_Node_Str"",the,mlcp.the);
  }
  if (sizeD != 0 && mlcp.phi != null) {
    checkResult(""String_Node_Str"",phi,mlcp.phi);
  }
  checkComplementarity(mlcp.GT,mlcp.NT,mlcp.DT,Rg,Rn,bg,bn,bd,mlcp.flim,vel,lam,the,phi);
  if (verbose && mlcp.name != null && mlcp.name.length() > 0) {
    System.out.println(mlcp.name + ""String_Node_Str"");
  }
}"
70871,"@Override public void drawPoints(RenderObject robj,PointStyle style,double rad){
  maybeUpdateState(gl);
switch (style) {
case POINT:
{
      float fold=getPointSize();
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setPointSize(frad);
        changed=true;
      }
      drawPoints(robj);
      if (changed) {
        setPointSize(fold);
      }
      break;
    }
case SPHERE:
  drawSpheres(robj,rad);
break;
}
}","@Override public void drawPoints(RenderObject robj,PointStyle style,double rad){
switch (style) {
case POINT:
{
      float fold=getPointSize();
      float frad=(float)rad;
      boolean changed=false;
      if (fold != frad) {
        setPointSize(frad);
        changed=true;
      }
      drawPoints(robj);
      if (changed) {
        setPointSize(fold);
      }
      break;
    }
case SPHERE:
  drawSpheres(robj,rad);
break;
}
}"
70872,"@Override public void drawVertices(RenderObject robj,VertexDrawMode mode){
  maybeUpdateState(gl);
  boolean enableLighting=false;
  if (isLightingEnabled() && !robj.hasNormals()) {
    enableLighting=true;
    setLightingEnabled(false);
  }
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && isVertexColoringEnabled());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    gl.glEnable(GL2.GL_COLOR_MATERIAL);
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  DisplayListPassport dlpp=null;
  RenderObjectKey key=new RenderObjectKey(robj,DrawType.VERTICES);
  VertexFingerPrint fingerprint=new VertexFingerPrint(robj.getVersionInfo(),mode);
  boolean compile=true;
  if (useDisplayList) {
    dlpp=myGLResources.getDisplayListPassport(gl,key);
    if (dlpp == null) {
      dlpp=myGLResources.allocateDisplayListPassport(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(dlpp.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (dlpp != null) {
      gl.glNewList(dlpp.getList(),GL2.GL_COMPILE);
    }
switch (mode) {
case LINES:
      gl.glBegin(GL2.GL_LINES);
    break;
case LINE_LOOP:
  gl.glBegin(GL2.GL_LINE_LOOP);
break;
case LINE_STRIP:
gl.glBegin(GL2.GL_LINE_STRIP);
break;
case POINTS:
gl.glBegin(GL2.GL_POINTS);
break;
case TRIANGLES:
gl.glBegin(GL2.GL_TRIANGLES);
break;
case TRIANGLE_FAN:
gl.glBegin(GL2.GL_TRIANGLE_FAN);
break;
case TRIANGLE_STRIP:
gl.glBegin(GL2.GL_TRIANGLE_STRIP);
break;
default :
gl.glBegin(GL2.GL_POINTS);
break;
}
for (VertexIndexSet v : robj.getVertices()) {
if (!selecting && useColors) {
setVertexColor(gl,robj.getColor(v.getColorIndex()),useHSV);
}
if (robj.hasNormals()) {
gl.glNormal3fv(robj.getNormal(v.getNormalIndex()),0);
}
gl.glVertex3fv(robj.getPosition(v.getPositionIndex()),0);
}
gl.glEnd();
if (dlpp != null) {
gl.glEndList();
gl.glCallList(dlpp.getList());
}
}
 else {
gl.glCallList(dlpp.getList());
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
if (enableLighting) {
setLightingEnabled(true);
}
}","@Override public void drawVertices(RenderObject robj,VertexDrawMode mode){
  maybeUpdateState(gl);
  boolean enableLighting=false;
  if (isLightingEnabled() && !robj.hasNormals()) {
    enableLighting=true;
    setLightingEnabled(false);
  }
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && isVertexColoringEnabled());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!mySelectedColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  DisplayListPassport dlpp=null;
  RenderObjectKey key=new RenderObjectKey(robj,DrawType.VERTICES);
  VertexFingerPrint fingerprint=new VertexFingerPrint(robj.getVersionInfo(),mode);
  boolean compile=true;
  if (useDisplayList) {
    dlpp=myGLResources.getDisplayListPassport(gl,key);
    if (dlpp == null) {
      dlpp=myGLResources.allocateDisplayListPassport(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(dlpp.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (dlpp != null) {
      gl.glNewList(dlpp.getList(),GL2.GL_COMPILE);
    }
switch (mode) {
case LINES:
      gl.glBegin(GL2.GL_LINES);
    break;
case LINE_LOOP:
  gl.glBegin(GL2.GL_LINE_LOOP);
break;
case LINE_STRIP:
gl.glBegin(GL2.GL_LINE_STRIP);
break;
case POINTS:
gl.glBegin(GL2.GL_POINTS);
break;
case TRIANGLES:
gl.glBegin(GL2.GL_TRIANGLES);
break;
case TRIANGLE_FAN:
gl.glBegin(GL2.GL_TRIANGLE_FAN);
break;
case TRIANGLE_STRIP:
gl.glBegin(GL2.GL_TRIANGLE_STRIP);
break;
default :
gl.glBegin(GL2.GL_POINTS);
break;
}
for (VertexIndexSet v : robj.getVertices()) {
if (!selecting && useColors) {
setVertexColor(gl,robj.getColor(v.getColorIndex()),useHSV);
}
if (robj.hasNormals()) {
gl.glNormal3fv(robj.getNormal(v.getNormalIndex()),0);
}
gl.glVertex3fv(robj.getPosition(v.getPositionIndex()),0);
}
gl.glEnd();
if (dlpp != null) {
gl.glEndList();
gl.glCallList(dlpp.getList());
}
}
 else {
gl.glCallList(dlpp.getList());
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
if (enableLighting) {
setLightingEnabled(true);
}
}"
70873,"private void drawColoredArrow(GL2 gl,int nslices,double rad,float arrowRad,float arrowHeight,float[] coords0,byte[] color0,float[] coords1,byte[] color1,boolean hsv,boolean capped){
  utmp.set(coords1[0] - coords0[0],coords1[1] - coords0[1],coords1[2] - coords0[2]);
  Xtmp.p.set(coords0[0],coords0[1],coords0[2]);
  Xtmp.R.setZDirection(utmp);
  gl.glPushMatrix();
  GL2Viewer.mulTransform(gl,Xtmp);
  byte[] colorM=new byte[4];
  double h2=utmp.norm();
  double h=h2 - arrowHeight;
  double t=(float)(h / h2);
  interpColor4ub(color0,t,color1,colorM,hsv);
  if (nslices + 1 != cosBuff.length) {
    cosBuff=new double[nslices + 1];
    sinBuff=new double[nslices + 1];
    cosBuff[0]=1;
    sinBuff[0]=0;
    cosBuff[nslices]=1;
    sinBuff[nslices]=0;
    for (int i=1; i < nslices; i++) {
      double ang=i / (double)nslices * 2 * Math.PI;
      cosBuff[i]=Math.cos(ang);
      sinBuff[i]=Math.sin(ang);
    }
  }
  gl.glBegin(GL2.GL_QUAD_STRIP);
  double c1, s1;
  for (int i=0; i <= nslices; i++) {
    c1=cosBuff[i];
    s1=sinBuff[i];
    gl.glNormal3d(c1,s1,0);
    gl.glColor4ubv(colorM,0);
    gl.glVertex3d(rad * c1,rad * s1,h);
    gl.glColor4ubv(color0,0);
    gl.glVertex3d(rad * c1,rad * s1,0);
  }
  gl.glEnd();
  gl.glBegin(GL2.GL_QUAD_STRIP);
  for (int i=0; i <= nslices; i++) {
    c1=cosBuff[i];
    s1=sinBuff[i];
    gl.glNormal3d(c1,s1,1);
    gl.glColor4ubv(color1,0);
    gl.glVertex3d(0,0,h2);
    gl.glColor4ubv(colorM,0);
    gl.glVertex3d(rad * c1,rad * s1,h);
  }
  gl.glEnd();
  if (capped) {
    gl.glColor4ubv(color0,0);
    gl.glBegin(GL2.GL_POLYGON);
    gl.glNormal3d(0,0,-1);
    for (int i=0; i < nslices; i++) {
      gl.glVertex3d(rad * cosBuff[i],rad * sinBuff[i],0);
    }
    gl.glEnd();
    gl.glColor4ubv(colorM,0);
    gl.glBegin(GL2.GL_QUAD_STRIP);
    gl.glNormal3d(0,0,-1);
    for (int i=0; i < nslices; i++) {
      gl.glVertex3d(rad * cosBuff[i],rad * sinBuff[i],h);
      gl.glVertex3d(arrowRad * cosBuff[i],arrowRad * sinBuff[i],h);
    }
    gl.glEnd();
  }
  gl.glPopMatrix();
}","private void drawColoredArrow(GL2 gl,int nslices,double rad,float arrowRad,float arrowHeight,float[] coords0,byte[] color0,float[] coords1,byte[] color1,boolean hsv,boolean capped){
  utmp.set(coords1[0] - coords0[0],coords1[1] - coords0[1],coords1[2] - coords0[2]);
  Xtmp.p.set(coords0[0],coords0[1],coords0[2]);
  Xtmp.R.setZDirection(utmp);
  gl.glPushMatrix();
  GL2Viewer.mulTransform(gl,Xtmp);
  byte[] colorM=new byte[4];
  double h2=utmp.norm();
  double h=h2 - arrowHeight;
  double t=(float)(h / h2);
  interpColor4ub(color0,t,color1,colorM,hsv);
  if (nslices + 1 != cosBuff.length) {
    cosBuff=new double[nslices + 1];
    sinBuff=new double[nslices + 1];
    cosBuff[0]=1;
    sinBuff[0]=0;
    cosBuff[nslices]=1;
    sinBuff[nslices]=0;
    for (int i=1; i < nslices; i++) {
      double ang=i / (double)nslices * 2 * Math.PI;
      cosBuff[i]=Math.cos(ang);
      sinBuff[i]=Math.sin(ang);
    }
  }
  gl.glBegin(GL2.GL_QUAD_STRIP);
  double c1, s1;
  for (int i=0; i <= nslices; i++) {
    c1=cosBuff[i];
    s1=sinBuff[i];
    gl.glNormal3d(c1,s1,0);
    setVertexColor(gl,colorM,hsv);
    gl.glVertex3d(rad * c1,rad * s1,h);
    setVertexColor(gl,color0,hsv);
    gl.glVertex3d(rad * c1,rad * s1,0);
  }
  gl.glEnd();
  gl.glBegin(GL2.GL_QUAD_STRIP);
  for (int i=0; i <= nslices; i++) {
    c1=cosBuff[i];
    s1=sinBuff[i];
    gl.glNormal3d(c1,s1,1);
    setVertexColor(gl,color1,hsv);
    gl.glVertex3d(0,0,h2);
    setVertexColor(gl,colorM,hsv);
    gl.glVertex3d(arrowRad * c1,arrowRad * s1,h);
  }
  gl.glEnd();
  if (capped) {
    setVertexColor(gl,color0,hsv);
    gl.glBegin(GL2.GL_POLYGON);
    gl.glNormal3d(0,0,-1);
    for (int i=0; i < nslices; i++) {
      gl.glVertex3d(-rad * cosBuff[i],rad * sinBuff[i],0);
    }
    gl.glEnd();
    setVertexColor(gl,colorM,hsv);
    gl.glBegin(GL2.GL_QUAD_STRIP);
    gl.glNormal3d(0,0,-1);
    for (int i=0; i <= nslices; i++) {
      gl.glVertex3d(arrowRad * cosBuff[i],arrowRad * sinBuff[i],h);
      gl.glVertex3d(rad * cosBuff[i],rad * sinBuff[i],h);
    }
    gl.glEnd();
  }
  gl.glPopMatrix();
}"
70874,"private void drawSpheres(RenderObject robj,double rad){
  GL2 gl=getGL2();
  maybeUpdateState(gl);
  List<int[]> pnts=robj.getPoints();
  int displayList=myGLResources.getSphereDisplayList(gl,myPointSlices);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && isVertexColoringEnabled());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    gl.glEnable(GL2.GL_COLOR_MATERIAL);
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  DisplayListPassport dlpp=null;
  RenderObjectKey key=new RenderObjectKey(robj,DrawType.POINTS);
  PointFingerPrint fingerprint=new PointFingerPrint(robj.getVersionInfo(),PointStyle.SPHERE,displayList,(float)rad);
  boolean compile=true;
  if (useDisplayList) {
    dlpp=myGLResources.getDisplayListPassport(gl,key);
    if (dlpp == null) {
      dlpp=myGLResources.allocateDisplayListPassport(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(dlpp.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (dlpp != null) {
      gl.glNewList(dlpp.getList(),GL2.GL_COMPILE);
    }
    for (    int[] pnt : pnts) {
      VertexIndexSet v=robj.getVertex(pnt[0]);
      if (!selecting && useColors) {
        setVertexColor(gl,robj.getColor(v.getColorIndex()),useHSV);
      }
      float[] p=robj.getPosition(v.getPositionIndex());
      gl.glPushMatrix();
      gl.glTranslatef(p[0],p[1],p[2]);
      gl.glScaled(rad,rad,rad);
      gl.glCallList(displayList);
      gl.glPopMatrix();
    }
    if (dlpp != null) {
      gl.glEndList();
      gl.glCallList(dlpp.getList());
    }
  }
 else {
    gl.glCallList(dlpp.getList());
  }
  if (useColors) {
    gl.glDisable(GL2.GL_COLOR_MATERIAL);
    if (useHSV) {
      gl.glUseProgramObjectARB(0);
    }
  }
}","private void drawSpheres(RenderObject robj,double rad){
  GL2 gl=getGL2();
  maybeUpdateState(gl);
  List<int[]> pnts=robj.getPoints();
  int displayList=myGLResources.getSphereDisplayList(gl,myPointSlices);
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && isVertexColoringEnabled());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!mySelectedColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  DisplayListPassport dlpp=null;
  RenderObjectKey key=new RenderObjectKey(robj,DrawType.POINTS);
  PointFingerPrint fingerprint=new PointFingerPrint(robj.getVersionInfo(),PointStyle.SPHERE,displayList,(float)rad);
  boolean compile=true;
  if (useDisplayList) {
    dlpp=myGLResources.getDisplayListPassport(gl,key);
    if (dlpp == null) {
      dlpp=myGLResources.allocateDisplayListPassport(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(dlpp.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (dlpp != null) {
      gl.glNewList(dlpp.getList(),GL2.GL_COMPILE);
    }
    for (    int[] pnt : pnts) {
      VertexIndexSet v=robj.getVertex(pnt[0]);
      if (!selecting && useColors) {
        setVertexColor(gl,robj.getColor(v.getColorIndex()),useHSV);
      }
      float[] p=robj.getPosition(v.getPositionIndex());
      gl.glPushMatrix();
      gl.glTranslatef(p[0],p[1],p[2]);
      gl.glScaled(rad,rad,rad);
      gl.glCallList(displayList);
      gl.glPopMatrix();
    }
    if (dlpp != null) {
      gl.glEndList();
      gl.glCallList(dlpp.getList());
    }
  }
 else {
    gl.glCallList(dlpp.getList());
  }
  if (useColors) {
    gl.glDisable(GL2.GL_COLOR_MATERIAL);
    if (useHSV) {
      gl.glUseProgramObjectARB(0);
    }
  }
}"
70875,"private void drawColoredEllipsoid(GL2 gl,int slices,float rad,float[] p0,byte[] c0,float[] p1,byte[] c1,boolean hsv){
  utmp.set(p1[0] - p0[0],p1[1] - p0[1],p1[2] - p0[2]);
  Xtmp.p.set(p0[0],p0[1],p0[2]);
  Xtmp.R.setZDirection(utmp);
  gl.glPushMatrix();
  GL2Viewer.mulTransform(gl,Xtmp);
  int levels=slices / 2;
  levels=Math.max(levels,2);
  double sin0=0;
  double cos0=1;
  double len=utmp.norm();
  byte[] cm=new byte[4];
  for (int slice=0; slice < slices; slice++) {
    double ang=(slice + 1) * 2 * Math.PI / slices;
    double cos1=Math.cos(ang);
    double sin1=Math.sin(ang);
    gl.glBegin(GL2.GL_TRIANGLE_STRIP);
    for (int j=0; j <= levels; j++) {
      double h=j * 1.0 / levels;
      double r=1 * Math.sin(h * Math.PI / 1.0);
      double drdh=Math.PI / 1.0 * 1.0 * Math.cos(h * Math.PI / 1.0);
      interpColor4ub(c0,h,c1,cm,hsv);
      gl.glColor4ubv(cm,0);
      gl.glNormal3d(cos0,sin0,-drdh * rad / len);
      gl.glVertex3d(cos0 * r * rad,sin0 * r * rad,h * len);
      gl.glNormal3d(cos1,sin1,-drdh * rad / len);
      gl.glVertex3d(cos1 * r * rad,sin1 * r * rad,h * len);
    }
    gl.glEnd();
    sin0=sin1;
    cos0=cos1;
  }
  gl.glPopMatrix();
}","private void drawColoredEllipsoid(GL2 gl,int slices,float rad,float[] p0,byte[] c0,float[] p1,byte[] c1,boolean hsv){
  utmp.set(p1[0] - p0[0],p1[1] - p0[1],p1[2] - p0[2]);
  Xtmp.p.set(p0[0],p0[1],p0[2]);
  Xtmp.R.setZDirection(utmp);
  gl.glPushMatrix();
  GL2Viewer.mulTransform(gl,Xtmp);
  int levels=slices / 2;
  levels=Math.max(levels,2);
  double sin0=0;
  double cos0=1;
  double len=utmp.norm();
  byte[] cm=new byte[4];
  for (int slice=0; slice < slices; slice++) {
    double ang=(slice + 1) * 2 * Math.PI / slices;
    double cos1=Math.cos(ang);
    double sin1=Math.sin(ang);
    gl.glBegin(GL2.GL_TRIANGLE_STRIP);
    for (int j=0; j <= levels; j++) {
      double h=j * 1.0 / levels;
      double r=1 * Math.sin(h * Math.PI);
      double drdh=Math.PI * Math.cos(h * Math.PI);
      interpColor4ub(c0,h,c1,cm,hsv);
      setVertexColor(gl,cm,hsv);
      gl.glNormal3d(cos0,sin0,-drdh * rad / len);
      gl.glVertex3d(cos0 * r * rad,sin0 * r * rad,h * len);
      gl.glNormal3d(cos1,sin1,-drdh * rad / len);
      gl.glVertex3d(cos1 * r * rad,sin1 * r * rad,h * len);
    }
    gl.glEnd();
    sin0=sin1;
    cos0=cos1;
  }
  gl.glPopMatrix();
}"
70876,"private void drawColoredCylinder(GL2 gl,int nslices,double base,double top,float[] coords0,byte[] color0,float[] coords1,byte[] color1,boolean capped,boolean useHSV){
  utmp.set(coords1[0] - coords0[0],coords1[1] - coords0[1],coords1[2] - coords0[2]);
  Xtmp.p.set(coords0[0],coords0[1],coords0[2]);
  Xtmp.R.setZDirection(utmp);
  gl.glPushMatrix();
  GL2Viewer.mulTransform(gl,Xtmp);
  double h=utmp.norm();
  if (nslices + 1 != cosBuff.length) {
    cosBuff=new double[nslices + 1];
    sinBuff=new double[nslices + 1];
    cosBuff[0]=1;
    sinBuff[0]=0;
    cosBuff[nslices]=1;
    sinBuff[nslices]=0;
    for (int i=1; i < nslices; i++) {
      double ang=i / (double)nslices * 2 * Math.PI;
      cosBuff[i]=Math.cos(ang);
      sinBuff[i]=Math.sin(ang);
    }
  }
  gl.glBegin(GL2.GL_QUAD_STRIP);
  double c1, s1;
  for (int i=0; i <= nslices; i++) {
    c1=cosBuff[i];
    s1=sinBuff[i];
    gl.glNormal3d(c1,s1,(base - top) / h);
    setVertexColor(gl,color0,useHSV);
    gl.glColor4ubv(color0,0);
    gl.glVertex3d(base * c1,base * s1,0);
    setVertexColor(gl,color1,useHSV);
    gl.glVertex3d(top * c1,top * s1,h);
  }
  gl.glEnd();
  if (capped) {
    gl.glColor4ubv(color1,0);
    if (top > 0) {
      gl.glBegin(GL2.GL_POLYGON);
      gl.glNormal3d(0,0,1);
      for (int i=0; i < nslices; i++) {
        gl.glVertex3d(top * cosBuff[i],top * sinBuff[i],h);
      }
      gl.glEnd();
    }
    gl.glColor4ubv(color0,0);
    if (base > 0) {
      gl.glBegin(GL2.GL_POLYGON);
      gl.glNormal3d(0,0,-1);
      for (int i=0; i < nslices; i++) {
        gl.glVertex3d(base * cosBuff[i],base * sinBuff[i],0);
      }
      gl.glEnd();
    }
  }
  gl.glPopMatrix();
}","private void drawColoredCylinder(GL2 gl,int nslices,double base,double top,float[] coords0,byte[] color0,float[] coords1,byte[] color1,boolean capped,boolean useHSV){
  utmp.set(coords1[0] - coords0[0],coords1[1] - coords0[1],coords1[2] - coords0[2]);
  Xtmp.p.set(coords0[0],coords0[1],coords0[2]);
  Xtmp.R.setZDirection(utmp);
  gl.glPushMatrix();
  GL2Viewer.mulTransform(gl,Xtmp);
  double h=utmp.norm();
  if (nslices + 1 != cosBuff.length) {
    cosBuff=new double[nslices + 1];
    sinBuff=new double[nslices + 1];
    cosBuff[0]=1;
    sinBuff[0]=0;
    cosBuff[nslices]=1;
    sinBuff[nslices]=0;
    for (int i=1; i < nslices; i++) {
      double ang=i / (double)nslices * 2 * Math.PI;
      cosBuff[i]=Math.cos(ang);
      sinBuff[i]=Math.sin(ang);
    }
  }
  double nz=(base - top) / h;
  double nscale=1.0 / Math.sqrt(1 + nz * nz);
  gl.glBegin(GL2.GL_QUAD_STRIP);
  double c1, s1;
  for (int i=0; i <= nslices; i++) {
    c1=cosBuff[i];
    s1=sinBuff[i];
    gl.glNormal3d(nscale * c1,nscale * s1,nscale * nz);
    setVertexColor(gl,color1,useHSV);
    gl.glVertex3d(top * c1,top * s1,h);
    setVertexColor(gl,color0,useHSV);
    gl.glVertex3d(base * c1,base * s1,0);
  }
  gl.glEnd();
  if (capped) {
    if (top > 0) {
      setVertexColor(gl,color1,useHSV);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glNormal3d(0,0,1);
      for (int i=0; i < nslices; i++) {
        gl.glVertex3d(top * cosBuff[i],top * sinBuff[i],h);
      }
      gl.glEnd();
    }
    if (base > 0) {
      setVertexColor(gl,color0,useHSV);
      gl.glBegin(GL2.GL_POLYGON);
      gl.glNormal3d(0,0,-1);
      for (int i=nslices - 1; i >= 0; i--) {
        gl.glVertex3d(base * cosBuff[i],base * sinBuff[i],0);
      }
      gl.glEnd();
    }
  }
  gl.glPopMatrix();
}"
70877,"private void interpColor4ub(byte[] c0,double t,byte[] c1,byte[] out,boolean hsv){
  if (hsv) {
    byte[] tmp=new byte[4];
    RGBtoHSV(c0,tmp);
    tmp[3]=c0[3];
    RGBtoHSV(c1,out);
    out[3]=c1[3];
    for (int i=0; i < 4; ++i) {
      out[i]=(byte)((1 - t) * tmp[i] + t * out[i]);
    }
    HSVtoRGB(out,out);
  }
 else {
    for (int i=0; i < 4; ++i) {
      out[i]=(byte)((1 - t) * c0[i] + t * c1[i]);
    }
  }
}","private void interpColor4ub(byte[] c0,double t,byte[] c1,byte[] out,boolean hsv){
  if (hsv) {
    byte[] tmp=new byte[4];
    RGBtoHSV(c0,tmp);
    tmp[3]=c0[3];
    RGBtoHSV(c1,out);
    out[3]=c1[3];
    for (int i=0; i < 4; ++i) {
      out[i]=(byte)((1 - t) * (tmp[i] & 0xFF) + t * (out[i] & 0xFF));
    }
    HSVtoRGB(out,out);
  }
 else {
    for (int i=0; i < 4; ++i) {
      out[i]=(byte)((1 - t) * (c0[i] & 0xFF) + t * (c1[i] & 0xFF));
    }
  }
}"
70878,"protected void maybeUpdateShading(GL2 gl){
  if (myShadingModified && !isSelecting()) {
    Shading shading=getShadeModel();
    if (shading == Shading.NONE) {
      setLightingEnabled(false);
    }
 else {
      setLightingEnabled(true);
      gl.glShadeModel(getGLShadingModel(shading));
    }
    myShadingModified=false;
  }
}","protected void maybeUpdateShading(GL2 gl){
  if (myShadingModified && !isSelecting()) {
    Shading shading=getShadeModel();
    if (shading == Shading.NONE) {
      setLightingEnabled(false);
    }
 else {
      setLightingEnabled(true);
      int glShading=getGLShadingModel(shading);
      gl.glShadeModel(glShading);
    }
    myShadingModified=false;
  }
}"
70879,"private void drawSolidLines(RenderObject robj,LineStyle style,float rad){
  List<int[]> lines=robj.getLines();
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && isVertexColoringEnabled());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    gl.glEnable(GL2.GL_COLOR_MATERIAL);
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  DisplayListPassport dlpp=null;
  RenderObjectKey key=new RenderObjectKey(robj,DrawType.LINES);
  LineFingerPrint fingerprint=new LineFingerPrint(robj.getVersionInfo(),style,myLineSlices,rad);
  boolean compile=true;
  if (useDisplayList) {
    dlpp=myGLResources.getDisplayListPassport(gl,key);
    if (dlpp == null) {
      dlpp=myGLResources.allocateDisplayListPassport(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(dlpp.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (dlpp != null) {
      gl.glNewList(dlpp.getList(),GL2.GL_COMPILE);
    }
switch (style) {
case CYLINDER:
{
        if (!selecting && useColors) {
          for (          int[] line : lines) {
            VertexIndexSet v0=robj.getVertex(line[0]);
            VertexIndexSet v1=robj.getVertex(line[1]);
            float[] p0=robj.getPosition(v0.getPositionIndex());
            byte[] c0=robj.getColor(v0.getColorIndex());
            float[] p1=robj.getPosition(v1.getPositionIndex());
            byte[] c1=robj.getColor(v1.getColorIndex());
            drawColoredCylinder(gl,myLineSlices,rad,rad,p0,c0,p1,c1,true,useHSV);
          }
        }
 else {
          for (          int[] line : lines) {
            VertexIndexSet v0=robj.getVertex(line[0]);
            VertexIndexSet v1=robj.getVertex(line[1]);
            float[] p0=robj.getPosition(v0.getPositionIndex());
            float[] p1=robj.getPosition(v1.getPositionIndex());
            drawCylinder(gl,myLineSlices,rad,rad,p0,p1,true);
          }
        }
        break;
      }
case ELLIPSOID:
    if (!selecting && useColors) {
      for (      int[] line : lines) {
        VertexIndexSet v0=robj.getVertex(line[0]);
        VertexIndexSet v1=robj.getVertex(line[1]);
        float[] p0=robj.getPosition(v0.getPositionIndex());
        byte[] c0=robj.getColor(v0.getColorIndex());
        float[] p1=robj.getPosition(v1.getPositionIndex());
        byte[] c1=robj.getColor(v1.getColorIndex());
        drawColoredEllipsoid(gl,myLineSlices,rad,p0,c0,p1,c1,isHSVColorInterpolationEnabled());
      }
    }
 else {
      for (      int[] line : lines) {
        VertexIndexSet v0=robj.getVertex(line[0]);
        VertexIndexSet v1=robj.getVertex(line[1]);
        float[] p0=robj.getPosition(v0.getPositionIndex());
        float[] p1=robj.getPosition(v1.getPositionIndex());
        drawEllipsoid(gl,myLineSlices,rad,p0,p1);
      }
    }
  break;
case SOLID_ARROW:
{
  float arad=rad * 3;
  float aheight=arad * 2;
  if (!selecting && useColors) {
    for (    int[] line : lines) {
      VertexIndexSet v0=robj.getVertex(line[0]);
      VertexIndexSet v1=robj.getVertex(line[1]);
      float[] p0=robj.getPosition(v0.getPositionIndex());
      byte[] c0=robj.getColor(v0.getColorIndex());
      float[] p1=robj.getPosition(v1.getPositionIndex());
      byte[] c1=robj.getColor(v1.getColorIndex());
      drawColoredArrow(gl,myLineSlices,rad,arad,aheight,p0,c0,p1,c1,isHSVColorInterpolationEnabled(),true);
    }
  }
 else {
    for (    int[] line : lines) {
      VertexIndexSet v0=robj.getVertex(line[0]);
      VertexIndexSet v1=robj.getVertex(line[1]);
      float[] p0=robj.getPosition(v0.getPositionIndex());
      float[] p1=robj.getPosition(v1.getPositionIndex());
      drawArrow(gl,myLineSlices,rad,arad,aheight,p0,p1,true);
    }
  }
  break;
}
default :
}
if (dlpp != null) {
gl.glEndList();
gl.glCallList(dlpp.getList());
}
}
 else {
gl.glCallList(dlpp.getList());
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
}","private void drawSolidLines(RenderObject robj,LineStyle style,float rad){
  List<int[]> lines=robj.getLines();
  boolean selecting=isSelecting();
  boolean hasColors=(robj.hasColors() && isVertexColoringEnabled());
  boolean useColors=hasColors && !selecting;
  boolean useHSV=isHSVColorInterpolationEnabled() && !isLightingEnabled();
  if (useColors) {
    gl.glColorMaterial(GL2.GL_FRONT_AND_BACK,GL2.GL_AMBIENT_AND_DIFFUSE);
    if (!mySelectedColorActive) {
      gl.glEnable(GL2.GL_COLOR_MATERIAL);
    }
    if (useHSV) {
      useHSV=setupHSVInterpolation(gl);
    }
  }
  boolean useDisplayList=!selecting || !hasColors;
  DisplayListPassport dlpp=null;
  RenderObjectKey key=new RenderObjectKey(robj,DrawType.LINES);
  LineFingerPrint fingerprint=new LineFingerPrint(robj.getVersionInfo(),style,myLineSlices,rad);
  boolean compile=true;
  if (useDisplayList) {
    dlpp=myGLResources.getDisplayListPassport(gl,key);
    if (dlpp == null) {
      dlpp=myGLResources.allocateDisplayListPassport(gl,key,fingerprint);
      compile=true;
    }
 else {
      compile=!(dlpp.compareExchangeFingerPrint(fingerprint));
    }
  }
  if (compile) {
    if (dlpp != null) {
      gl.glNewList(dlpp.getList(),GL2.GL_COMPILE);
    }
switch (style) {
case CYLINDER:
{
        if (!selecting && useColors) {
          for (          int[] line : lines) {
            VertexIndexSet v0=robj.getVertex(line[0]);
            VertexIndexSet v1=robj.getVertex(line[1]);
            float[] p0=robj.getPosition(v0.getPositionIndex());
            byte[] c0=robj.getColor(v0.getColorIndex());
            float[] p1=robj.getPosition(v1.getPositionIndex());
            byte[] c1=robj.getColor(v1.getColorIndex());
            drawColoredCylinder(gl,myLineSlices,rad,rad,p0,c0,p1,c1,true,useHSV);
          }
        }
 else {
          for (          int[] line : lines) {
            VertexIndexSet v0=robj.getVertex(line[0]);
            VertexIndexSet v1=robj.getVertex(line[1]);
            float[] p0=robj.getPosition(v0.getPositionIndex());
            float[] p1=robj.getPosition(v1.getPositionIndex());
            drawCylinder(gl,myLineSlices,rad,rad,p0,p1,true);
          }
        }
        break;
      }
case ELLIPSOID:
    if (!selecting && useColors) {
      for (      int[] line : lines) {
        VertexIndexSet v0=robj.getVertex(line[0]);
        VertexIndexSet v1=robj.getVertex(line[1]);
        float[] p0=robj.getPosition(v0.getPositionIndex());
        byte[] c0=robj.getColor(v0.getColorIndex());
        float[] p1=robj.getPosition(v1.getPositionIndex());
        byte[] c1=robj.getColor(v1.getColorIndex());
        drawColoredEllipsoid(gl,myLineSlices,rad,p0,c0,p1,c1,isHSVColorInterpolationEnabled());
      }
    }
 else {
      for (      int[] line : lines) {
        VertexIndexSet v0=robj.getVertex(line[0]);
        VertexIndexSet v1=robj.getVertex(line[1]);
        float[] p0=robj.getPosition(v0.getPositionIndex());
        float[] p1=robj.getPosition(v1.getPositionIndex());
        drawEllipsoid(gl,myLineSlices,rad,p0,p1);
      }
    }
  break;
case SOLID_ARROW:
{
  float arad=rad * 3;
  float aheight=arad * 2;
  if (!selecting && useColors) {
    for (    int[] line : lines) {
      VertexIndexSet v0=robj.getVertex(line[0]);
      VertexIndexSet v1=robj.getVertex(line[1]);
      float[] p0=robj.getPosition(v0.getPositionIndex());
      byte[] c0=robj.getColor(v0.getColorIndex());
      float[] p1=robj.getPosition(v1.getPositionIndex());
      byte[] c1=robj.getColor(v1.getColorIndex());
      drawColoredArrow(gl,myLineSlices,rad,arad,aheight,p0,c0,p1,c1,isHSVColorInterpolationEnabled(),true);
    }
  }
 else {
    for (    int[] line : lines) {
      VertexIndexSet v0=robj.getVertex(line[0]);
      VertexIndexSet v1=robj.getVertex(line[1]);
      float[] p0=robj.getPosition(v0.getPositionIndex());
      float[] p1=robj.getPosition(v1.getPositionIndex());
      drawArrow(gl,myLineSlices,rad,arad,aheight,p0,p1,true);
    }
  }
  break;
}
default :
}
if (dlpp != null) {
gl.glEndList();
gl.glCallList(dlpp.getList());
}
}
 else {
gl.glCallList(dlpp.getList());
}
if (useColors) {
gl.glDisable(GL2.GL_COLOR_MATERIAL);
if (useHSV) {
gl.glUseProgramObjectARB(0);
}
}
}"
70880,"private int createProgram(GL3 gl,GLSLInfo key){
  String[] shaders=GLSLGenerator.getShaderScripts(key);
  int vs=gl.glCreateShader(GL3.GL_VERTEX_SHADER);
  gl.glShaderSource(vs,1,new String[]{shaders[0]},null,0);
  gl.glCompileShader(vs);
  boolean success=glCheckShaderCompilation(gl,vs);
  if (!success) {
    throw new RuntimeException(""String_Node_Str"" + shaders[0]);
  }
  int fs=gl.glCreateShader(GL3.GL_FRAGMENT_SHADER);
  gl.glShaderSource(fs,1,new String[]{shaders[1]},null,0);
  gl.glCompileShader(fs);
  success=glCheckShaderCompilation(gl,fs);
  if (!success) {
    throw new RuntimeException(""String_Node_Str"" + shaders[1]);
  }
  int prog=gl.glCreateProgram();
  gl.glAttachShader(prog,vs);
  gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_POSITION.index(),GL3VertexAttribute.VERTEX_POSITION.name());
  if (key.hasVertexNormals() && key.getShading() != Shading.NONE) {
    gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_NORMAL.index(),GL3VertexAttribute.VERTEX_NORMAL.name());
  }
  if (key.hasVertexColors() && key.getColorInterpolation() != ColorInterpolation.NONE) {
    gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_COLOR.index(),GL3VertexAttribute.VERTEX_COLOR.name());
  }
  if (key.hasVertexTextures()) {
    gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_TEXTURE.index(),GL3VertexAttribute.VERTEX_TEXTURE.name());
  }
switch (key.getInstancedRendering()) {
case POINTS:
    gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_SCALE.index(),GL3VertexAttribute.INSTANCE_SCALE.name());
  gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_POSITION.index(),GL3VertexAttribute.INSTANCE_POSITION.name());
break;
case FRAMES:
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_SCALE.index(),GL3VertexAttribute.INSTANCE_SCALE.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_POSITION.index(),GL3VertexAttribute.INSTANCE_POSITION.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_ORIENTATION.index(),GL3VertexAttribute.INSTANCE_ORIENTATION.name());
break;
case AFFINES:
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_AFFINE_MATRIX.index(),GL3VertexAttribute.INSTANCE_AFFINE_MATRIX.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_NORMAL_MATRIX.index(),GL3VertexAttribute.INSTANCE_NORMAL_MATRIX.name());
break;
case LINES:
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_RADIUS.index(),GL3VertexAttribute.LINE_RADIUS.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_BOTTOM_POSITION.index(),GL3VertexAttribute.LINE_BOTTOM_POSITION.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_TOP_POSITION.index(),GL3VertexAttribute.LINE_TOP_POSITION.name());
break;
case NONE:
break;
}
switch (key.getInstancedRendering()) {
case POINTS:
case FRAMES:
case AFFINES:
if (key.getColorInterpolation() != ColorInterpolation.NONE && key.hasInstanceColors()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_COLOR.index(),GL3VertexAttribute.INSTANCE_COLOR.name());
}
if (key.hasInstanceTextures()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_TEXTURE.index(),GL3VertexAttribute.INSTANCE_TEXTURE.name());
}
break;
case LINES:
if (key.hasLineLengthOffset()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_LENGTH_OFFSET.index(),GL3VertexAttribute.LINE_LENGTH_OFFSET.name());
}
if (key.getColorInterpolation() != ColorInterpolation.NONE && key.hasLineColors()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_BOTTOM_COLOR.index(),GL3VertexAttribute.LINE_BOTTOM_COLOR.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_TOP_COLOR.index(),GL3VertexAttribute.LINE_TOP_COLOR.name());
}
if (key.hasLineTextures()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_BOTTOM_TEXTURE.index(),GL3VertexAttribute.LINE_BOTTOM_TEXTURE.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_TOP_TEXTURE.index(),GL3VertexAttribute.LINE_TOP_TEXTURE.name());
}
break;
case NONE:
break;
}
gl.glAttachShader(prog,fs);
gl.glLinkProgram(prog);
gl.glDetachShader(prog,vs);
gl.glDeleteShader(vs);
gl.glDetachShader(prog,fs);
gl.glDeleteShader(fs);
return prog;
}","private int createProgram(GL3 gl,GLSLInfo key){
  String[] shaders=GLSLGenerator.getShaderScripts(key);
  int vs=gl.glCreateShader(GL3.GL_VERTEX_SHADER);
  gl.glShaderSource(vs,1,new String[]{shaders[0]},null,0);
  gl.glCompileShader(vs);
  boolean success=glCheckShaderCompilation(gl,vs);
  if (!success) {
    throw new RuntimeException(""String_Node_Str"" + shaders[0]);
  }
  int fs=gl.glCreateShader(GL3.GL_FRAGMENT_SHADER);
  gl.glShaderSource(fs,1,new String[]{shaders[1]},null,0);
  gl.glCompileShader(fs);
  success=glCheckShaderCompilation(gl,fs);
  if (!success) {
    System.out.println(""String_Node_Str"" + shaders[0]);
    System.out.println(""String_Node_Str"" + shaders[1]);
    shaders=GLSLGenerator.getShaderScripts(key);
    throw new RuntimeException(""String_Node_Str"" + shaders[1]);
  }
  int prog=gl.glCreateProgram();
  gl.glAttachShader(prog,vs);
  gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_POSITION.index(),GL3VertexAttribute.VERTEX_POSITION.name());
  if (key.hasVertexNormals() && key.getShading() != Shading.NONE) {
    gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_NORMAL.index(),GL3VertexAttribute.VERTEX_NORMAL.name());
  }
  if (key.hasVertexColors() && key.getColorInterpolation() != ColorInterpolation.NONE) {
    gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_COLOR.index(),GL3VertexAttribute.VERTEX_COLOR.name());
  }
  if (key.hasVertexTextures()) {
    gl.glBindAttribLocation(prog,GL3VertexAttribute.VERTEX_TEXTURE.index(),GL3VertexAttribute.VERTEX_TEXTURE.name());
  }
switch (key.getInstancedRendering()) {
case POINTS:
    gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_SCALE.index(),GL3VertexAttribute.INSTANCE_SCALE.name());
  gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_POSITION.index(),GL3VertexAttribute.INSTANCE_POSITION.name());
break;
case FRAMES:
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_SCALE.index(),GL3VertexAttribute.INSTANCE_SCALE.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_POSITION.index(),GL3VertexAttribute.INSTANCE_POSITION.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_ORIENTATION.index(),GL3VertexAttribute.INSTANCE_ORIENTATION.name());
break;
case AFFINES:
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_AFFINE_MATRIX.index(),GL3VertexAttribute.INSTANCE_AFFINE_MATRIX.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_NORMAL_MATRIX.index(),GL3VertexAttribute.INSTANCE_NORMAL_MATRIX.name());
break;
case LINES:
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_RADIUS.index(),GL3VertexAttribute.LINE_RADIUS.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_BOTTOM_POSITION.index(),GL3VertexAttribute.LINE_BOTTOM_POSITION.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_TOP_POSITION.index(),GL3VertexAttribute.LINE_TOP_POSITION.name());
break;
case NONE:
break;
}
switch (key.getInstancedRendering()) {
case POINTS:
case FRAMES:
case AFFINES:
if (key.getColorInterpolation() != ColorInterpolation.NONE && key.hasInstanceColors()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_COLOR.index(),GL3VertexAttribute.INSTANCE_COLOR.name());
}
if (key.hasInstanceTextures()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.INSTANCE_TEXTURE.index(),GL3VertexAttribute.INSTANCE_TEXTURE.name());
}
break;
case LINES:
if (key.hasLineLengthOffset()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_LENGTH_OFFSET.index(),GL3VertexAttribute.LINE_LENGTH_OFFSET.name());
}
if (key.getColorInterpolation() != ColorInterpolation.NONE && key.hasLineColors()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_BOTTOM_COLOR.index(),GL3VertexAttribute.LINE_BOTTOM_COLOR.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_TOP_COLOR.index(),GL3VertexAttribute.LINE_TOP_COLOR.name());
}
if (key.hasLineTextures()) {
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_BOTTOM_TEXTURE.index(),GL3VertexAttribute.LINE_BOTTOM_TEXTURE.name());
gl.glBindAttribLocation(prog,GL3VertexAttribute.LINE_TOP_TEXTURE.index(),GL3VertexAttribute.LINE_TOP_TEXTURE.name());
}
break;
case NONE:
break;
}
gl.glAttachShader(prog,fs);
gl.glLinkProgram(prog);
gl.glDetachShader(prog,vs);
gl.glDeleteShader(vs);
gl.glDetachShader(prog,fs);
gl.glDeleteShader(fs);
return prog;
}"
70881,"private static void addVertexInputs(StringBuilder hb,GLSLInfo info){
  appendln(hb,""String_Node_Str"");
  appendln(hb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(hb,""String_Node_Str"");
  }
  if (info.hasVertexColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
    appendln(hb,""String_Node_Str"");
  }
  if (info.hasVertexTextures()) {
    appendln(hb,""String_Node_Str"");
  }
switch (info.getInstancedRendering()) {
case POINTS:
    appendln(hb);
  appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
}
break;
case FRAMES:
appendln(hb);
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
}
break;
case AFFINES:
appendln(hb);
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
}
break;
case LINES:
appendln(hb);
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
}
break;
case NONE:
break;
}
appendln(hb);
}","private static void addVertexInputs(StringBuilder hb,GLSLInfo info){
  appendln(hb,""String_Node_Str"");
  appendln(hb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(hb,""String_Node_Str"");
  }
  if (info.hasVertexColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
    appendln(hb,""String_Node_Str"");
  }
  if (info.hasVertexTextures()) {
    appendln(hb,""String_Node_Str"");
  }
switch (info.getInstancedRendering()) {
case POINTS:
    appendln(hb);
  appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
}
break;
case FRAMES:
appendln(hb);
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
}
break;
case AFFINES:
appendln(hb);
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
}
break;
case LINES:
appendln(hb);
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(hb,""String_Node_Str"");
}
if (info.hasLineColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceColors() && info.getColorInterpolation() != ColorInterpolation.NONE) {
appendln(hb,""String_Node_Str"");
}
if (info.hasLineTextures()) {
appendln(hb,""String_Node_Str"");
appendln(hb,""String_Node_Str"");
}
if (info.hasInstanceTextures()) {
appendln(hb,""String_Node_Str"");
}
break;
case NONE:
break;
}
appendln(hb);
}"
70882,"private static void buildFragmentShaderMain(StringBuilder mb,GLSLInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  boolean lights=false;
  if (info.getShading() != Shading.NONE && info.numLights() > 0) {
    lights=true;
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
switch (info.getShading()) {
case FLAT:
case GOURAUD:
      appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
case PHONG:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
break;
case NONE:
break;
}
}
 else {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
InstancedRendering instanced=info.getInstancedRendering();
ColorInterpolation cinterp=info.getColorInterpolation();
boolean hasColors=(cinterp != ColorInterpolation.NONE) && (info.hasVertexColors() || ((instanced == InstancedRendering.POINTS || instanced == InstancedRendering.FRAMES || instanced == InstancedRendering.AFFINES) && info.hasInstanceColors()) || (instanced == InstancedRendering.LINES && info.hasLineColors()));
boolean hasTextures=info.hasVertexTextures() || ((instanced == InstancedRendering.POINTS || instanced == InstancedRendering.FRAMES || instanced == InstancedRendering.AFFINES) && info.hasInstanceTextures()) || (instanced == InstancedRendering.LINES && info.hasLineTextures());
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (hasColors) {
appendln(mb,""String_Node_Str"");
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getColorMixing();
switch (cmix) {
case DECAL:
appendln(mb,""String_Node_Str"");
break;
case MODULATE:
appendln(mb,""String_Node_Str"");
break;
case REPLACE:
appendln(mb,""String_Node_Str"");
break;
case NONE:
appendln(mb,""String_Node_Str"");
default :
}
}
if (hasTextures) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getColorMixing();
switch (cmix) {
case DECAL:
appendln(mb,""String_Node_Str"");
break;
case MODULATE:
appendln(mb,""String_Node_Str"");
break;
case REPLACE:
appendln(mb,""String_Node_Str"");
case NONE:
appendln(mb,""String_Node_Str"");
default :
}
}
if (lights) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}","private static void buildFragmentShaderMain(StringBuilder mb,GLSLInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  boolean lights=false;
  if (info.getShading() != Shading.NONE && info.numLights() > 0) {
    lights=true;
    appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
switch (info.getShading()) {
case FLAT:
case GOURAUD:
      appendln(mb,""String_Node_Str"");
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
break;
case PHONG:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
break;
case NONE:
break;
}
}
 else {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
InstancedRendering instanced=info.getInstancedRendering();
ColorInterpolation cinterp=info.getColorInterpolation();
boolean hasColors=(cinterp != ColorInterpolation.NONE) && (info.hasVertexColors() || ((instanced == InstancedRendering.POINTS || instanced == InstancedRendering.FRAMES || instanced == InstancedRendering.AFFINES) && info.hasInstanceColors()) || (instanced == InstancedRendering.LINES && info.hasLineColors()));
boolean hasTextures=info.hasVertexTextures() || ((instanced == InstancedRendering.POINTS || instanced == InstancedRendering.FRAMES || instanced == InstancedRendering.AFFINES) && info.hasInstanceTextures()) || (instanced == InstancedRendering.LINES && info.hasLineTextures());
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (hasColors) {
appendln(mb,""String_Node_Str"");
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getColorMixing();
switch (cmix) {
case DECAL:
appendln(mb,""String_Node_Str"");
break;
case MODULATE:
appendln(mb,""String_Node_Str"");
break;
case REPLACE:
appendln(mb,""String_Node_Str"");
break;
case NONE:
appendln(mb,""String_Node_Str"");
default :
}
}
if (hasTextures) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
ColorMixing cmix=info.getColorMixing();
switch (cmix) {
case DECAL:
appendln(mb,""String_Node_Str"");
break;
case MODULATE:
appendln(mb,""String_Node_Str"");
break;
case REPLACE:
appendln(mb,""String_Node_Str"");
case NONE:
appendln(mb,""String_Node_Str"");
default :
}
}
if (lights) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}"
70883,"private static void buildVertexShaderMain(StringBuilder mb,GLSLInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb);
  appendln(mb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(mb,""String_Node_Str"");
  }
  appendln(mb);
  InstancedRendering instanced=info.getInstancedRendering();
switch (instanced) {
case AFFINES:
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
  appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case FRAMES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case LINES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
}
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case POINTS:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
ColorInterpolation cinterp=info.getColorInterpolation();
if (cinterp != ColorInterpolation.NONE) {
switch (instanced) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case LINES:
if (info.hasLineColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case NONE:
if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
}
}
switch (info.getShading()) {
case FLAT:
case GOURAUD:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case PHONG:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
break;
}
switch (info.getInstancedRendering()) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case LINES:
if (info.hasLineTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case NONE:
if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
}
if (info.numClipPlanes() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numClipPlanes() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
appendln(mb,""String_Node_Str"");
}","private static void buildVertexShaderMain(StringBuilder mb,GLSLInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb);
  appendln(mb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(mb,""String_Node_Str"");
  }
  appendln(mb);
  InstancedRendering instanced=info.getInstancedRendering();
switch (instanced) {
case AFFINES:
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
  appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case FRAMES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case LINES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
}
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case POINTS:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
ColorInterpolation cinterp=info.getColorInterpolation();
if (cinterp != ColorInterpolation.NONE) {
switch (instanced) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case LINES:
if (info.hasLineColors()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
}
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasInstanceColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case NONE:
if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
}
}
switch (info.getShading()) {
case FLAT:
case GOURAUD:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case PHONG:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
break;
}
switch (info.getInstancedRendering()) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case LINES:
if (info.hasLineTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasInstanceTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case NONE:
if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
}
if (info.numClipPlanes() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numClipPlanes() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
appendln(mb,""String_Node_Str"");
}"
70884,"/** 
 * Creates a combined hex/wedge fem model by extruding triangles into wedges and quads into hexes. If the mesh is the surface mesh of an underlying FemModel, then each triangle is examined to see if it is associated with an underlying hex element, and if it is, then a hex element is extruded from both the surface triangles connected to that element.
 * @param model Empty FEM model to which elements are added. If <code>null</code>,then a new FEM model will be created and returned. Note that <code>model</code> must be different from <code>surfaceFem</code>
 * @param n number of layers 
 * @param d layer thickness
 * @param surface surface mesh to extrude
 * @param surfaceFem FEM associated with the surface mesh, or <code>null</code> if there is associated FEM.
 * @return extruded FEM model, which will be <code>model</code> ifthat argument is not <code>null</code>.
 */
public static FemModel3d createHexWedgeExtrusion(FemModel3d model,int n,double d,PolygonalMesh surface,FemModel3d surfaceFem){
  if (model == null) {
    model=new FemModel3d();
  }
 else   if (model == surfaceFem) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    model.clear();
  }
  for (  Vertex3d v : surface.getVertices()) {
    FemNode3d node=new FemNode3d(v.pnt);
    model.addNode(node);
  }
  boolean[] marked=new boolean[surface.numFaces()];
  Point3d newpnt=new Point3d();
  Vector3d nrm=new Vector3d();
  for (int l=0; l < n; l++) {
    for (    Vertex3d v : surface.getVertices()) {
      v.computeAngleWeightedNormal(nrm);
      newpnt.scaledAdd((l + 1) * d,nrm,v.pnt);
      model.addNode(new FemNode3d(newpnt));
    }
    int numSurfVtxs=surface.numVertices();
    for (int i=0; i < surface.numFaces(); i++) {
      if (!marked[i]) {
        Face f=surface.getFaces().get(i);
        int numv=f.numVertices();
        if (numv != 3 && numv != 4) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        int[] vertexIndices=null;
        FemNode3d quadNode=null;
        if (surfaceFem != null) {
          FemElement3d elem=surfaceFem.getSurfaceElement(f);
          if (elem != null && numv == 3) {
            quadNode=getQuadFaceNode(f,elem,surfaceFem);
          }
        }
        if (quadNode != null) {
          vertexIndices=new int[4];
          HalfEdge he=f.firstHalfEdge();
          int k=0;
          for (int j=0; j < 3; j++) {
            vertexIndices[k++]=he.tail.getIndex();
            Vertex3d vop=he.opposite.getNext().head;
            if (surfaceFem.getSurfaceNode(vop) == quadNode) {
              vertexIndices[k++]=vop.getIndex();
              marked[he.opposite.getFace().getIndex()]=true;
            }
            he=he.getNext();
          }
        }
 else {
          vertexIndices=f.getVertexIndices();
        }
        FemElement3d e;
        if (vertexIndices.length == 3) {
          FemNode3d[] nodes=new FemNode3d[6];
          for (int j=0; j < 3; j++) {
            int idx=vertexIndices[j];
            nodes[j]=model.getNode(idx + l * numSurfVtxs);
            nodes[j + 3]=model.getNode(idx + (l + 1) * numSurfVtxs);
          }
          e=new WedgeElement(nodes);
        }
 else {
          FemNode3d[] nodes=new FemNode3d[8];
          for (int j=0; j < 4; j++) {
            int idx=vertexIndices[j];
            nodes[j]=model.getNode(idx + (l + 1) * numSurfVtxs);
            nodes[j + 4]=model.getNode(idx + l * numSurfVtxs);
          }
          e=new HexElement(nodes);
        }
        model.addElement(e);
        marked[f.getIndex()]=true;
      }
    }
  }
  return model;
}","/** 
 * Creates a combined hex/wedge fem model by extruding triangles into wedges and quads into hexes. If the mesh is the surface mesh of an underlying FemModel, then each triangle is examined to see if it is associated with an underlying hex element, and if it is, then a hex element is extruded from both the surface triangles connected to that element.
 * @param model Empty FEM model to which elements are added. If <code>null</code>,then a new FEM model will be created and returned. Note that <code>model</code> must be different from <code>surfaceFem</code>
 * @param n number of layers 
 * @param d layer thickness
 * @param surface surface mesh to extrude
 * @param surfaceFem FEM associated with the surface mesh, or <code>null</code> if there is associated FEM.
 * @return extruded FEM model, which will be <code>model</code> ifthat argument is not <code>null</code>.
 */
public static FemModel3d createHexWedgeExtrusion(FemModel3d model,int n,double d,PolygonalMesh surface,FemModel3d surfaceFem){
  if (model == null) {
    model=new FemModel3d();
  }
 else   if (model == surfaceFem) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    model.clear();
  }
  for (  Vertex3d v : surface.getVertices()) {
    FemNode3d node=new FemNode3d(v.pnt);
    model.addNode(node);
  }
  Point3d newpnt=new Point3d();
  Vector3d nrm=new Vector3d();
  for (int l=0; l < n; l++) {
    boolean[] marked=new boolean[surface.numFaces()];
    for (    Vertex3d v : surface.getVertices()) {
      v.computeAngleWeightedNormal(nrm);
      newpnt.scaledAdd((l + 1) * d,nrm,v.pnt);
      model.addNode(new FemNode3d(newpnt));
    }
    int numSurfVtxs=surface.numVertices();
    for (int i=0; i < surface.numFaces(); i++) {
      if (!marked[i]) {
        Face f=surface.getFaces().get(i);
        int numv=f.numVertices();
        if (numv != 3 && numv != 4) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        int[] vertexIndices=null;
        FemNode3d quadNode=null;
        if (surfaceFem != null) {
          FemElement3d elem=surfaceFem.getSurfaceElement(f);
          if (elem != null && numv == 3) {
            quadNode=getQuadFaceNode(f,elem,surfaceFem);
          }
        }
        if (quadNode != null) {
          vertexIndices=new int[4];
          HalfEdge he=f.firstHalfEdge();
          int k=0;
          for (int j=0; j < 3; j++) {
            vertexIndices[k++]=he.tail.getIndex();
            Vertex3d vop=he.opposite.getNext().head;
            if (surfaceFem.getSurfaceNode(vop) == quadNode) {
              vertexIndices[k++]=vop.getIndex();
              marked[he.opposite.getFace().getIndex()]=true;
            }
            he=he.getNext();
          }
        }
 else {
          vertexIndices=f.getVertexIndices();
        }
        FemElement3d e;
        if (vertexIndices.length == 3) {
          FemNode3d[] nodes=new FemNode3d[6];
          for (int j=0; j < 3; j++) {
            int idx=vertexIndices[j];
            nodes[j]=model.getNode(idx + l * numSurfVtxs);
            nodes[j + 3]=model.getNode(idx + (l + 1) * numSurfVtxs);
          }
          e=new WedgeElement(nodes);
        }
 else {
          FemNode3d[] nodes=new FemNode3d[8];
          for (int j=0; j < 4; j++) {
            int idx=vertexIndices[j];
            nodes[j]=model.getNode(idx + (l + 1) * numSurfVtxs);
            nodes[j + 4]=model.getNode(idx + l * numSurfVtxs);
          }
          e=new HexElement(nodes);
        }
        model.addElement(e);
        marked[f.getIndex()]=true;
      }
    }
  }
  return model;
}"
70885,"void drawFacesRaw(GLRenderer renderer,GL2 gl,RenderProps props,Material faceMaterial){
  boolean useVertexColors=useVertexColouring;
  if (renderer.isSelecting()) {
    useVertexColors=false;
  }
  int type=-1;
  int lastType=-1;
  boolean lastSelected=false;
  int i=0;
  for (  FaceComponent fc : this) {
    if (fc.getRenderProps() == null) {
      Face face=fc.getFace();
      if (face.isTriangle()) {
        type=0;
      }
 else       if (face.numEdges() == 4) {
        type=1;
      }
 else {
        type=2;
      }
      if (renderer.isSelecting()) {
        renderer.beginSelectionQuery(i);
      }
 else {
        if (fc.isSelected() && !lastSelected) {
          renderer.updateMaterial(props,renderer.getSelectionMaterial(),true);
          lastSelected=true;
        }
 else         if (!fc.isSelected() && lastSelected) {
          renderer.updateMaterial(props,faceMaterial,false);
          lastSelected=false;
        }
      }
      if (lastType == -1) {
switch (type) {
case 0:
          gl.glBegin(GL2.GL_TRIANGLES);
        break;
case 1:
      gl.glBegin(GL2.GL_QUADS);
    break;
default :
  gl.glBegin(GL2.GL_POLYGON);
}
}
 else if (type == 0 && lastType != 0) {
gl.glEnd();
gl.glBegin(GL2.GL_TRIANGLES);
}
 else if (type == 1 && lastType != 1) {
gl.glEnd();
gl.glBegin(GL2.GL_QUADS);
}
 else if (type == 2 && lastType != 2) {
gl.glEnd();
gl.glBegin(GL2.GL_POLYGON);
}
Vector3d faceNrm=face.getNormal();
gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
HalfEdge he=face.firstHalfEdge();
do {
Vertex3d vtx=he.head;
Point3d pnt=vtx.myRenderPnt;
if (useVertexColors) {
float[] color=he.head.getColorArray();
gl.glColor4f(color[0],color[1],color[2],color[3]);
}
gl.glVertex3d(pnt.x,pnt.y,pnt.z);
he=he.getNext();
}
 while (he != face.firstHalfEdge());
if (renderer.isSelecting()) {
gl.glEnd();
renderer.endSelectionQuery();
lastType=-1;
}
 else {
lastType=type;
}
}
i++;
}
if (lastType != -1) {
gl.glEnd();
}
}","void drawFacesRaw(GLRenderer renderer,GL2 gl,RenderProps props,Material faceMaterial){
  boolean useVertexColors=useVertexColouring;
  if (renderer.isSelecting()) {
    useVertexColors=false;
  }
  int type=-1;
  int lastType=-1;
  boolean lastSelected=false;
  int i=0;
  for (  FaceComponent fc : this) {
    if (fc.getRenderProps() == null) {
      Face face=fc.getFace();
      if (face.isTriangle()) {
        type=0;
      }
 else       if (face.numEdges() == 4) {
        type=1;
      }
 else {
        type=2;
      }
      if (renderer.isSelecting()) {
        renderer.beginSelectionQuery(i);
      }
 else {
        if (fc.isSelected() && !lastSelected) {
          renderer.updateMaterial(props,renderer.getSelectionMaterial(),true);
          lastSelected=true;
        }
 else         if (!fc.isSelected() && lastSelected) {
          renderer.updateMaterial(props,faceMaterial,false);
          lastSelected=false;
        }
      }
      if (lastType == -1) {
switch (type) {
case 0:
          gl.glBegin(GL2.GL_TRIANGLES);
        break;
case 1:
      gl.glBegin(GL2.GL_QUADS);
    break;
default :
  gl.glBegin(GL2.GL_POLYGON);
}
}
 else if (type == 0 && lastType != 0) {
gl.glEnd();
gl.glBegin(GL2.GL_TRIANGLES);
}
 else if (type == 1 && lastType != 1) {
gl.glEnd();
gl.glBegin(GL2.GL_QUADS);
}
 else if (type == 2 && lastType != 2) {
gl.glEnd();
gl.glBegin(GL2.GL_POLYGON);
}
Vector3d faceNrm=face.getNormal();
gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
HalfEdge he=face.firstHalfEdge();
do {
Vertex3d vtx=he.head;
Point3d pnt=vtx.myRenderPnt;
if (useVertexColors) {
float[] color=he.head.getColorArray();
gl.glColor4f(color[0],color[1],color[2],color[3]);
}
gl.glVertex3d(pnt.x,pnt.y,pnt.z);
he=he.getNext();
}
 while (he != face.firstHalfEdge());
if (renderer.isSelecting()) {
gl.glEnd();
renderer.endSelectionQuery();
lastType=-1;
}
 else {
lastType=type;
}
}
++i;
}
if (lastType != -1) {
gl.glEnd();
}
}"
70886,"public void render(GLRenderer renderer,int flags){
  renderer.checkAndPrintGLError();
  GL2 gl=renderer.getGL2();
  gl.glPushMatrix();
  RenderProps props=getRenderProps();
  float[] color=props.getPointColorArray();
  float[] selColor=renderer.getSelectionColor().getColorComponents(new float[4]);
  Material pointMaterial=props.getPointMaterial();
  if (isSelected()) {
    color=selColor;
    pointMaterial=renderer.getSelectionMaterial();
  }
  if (useDisplayLists && displayList == 0) {
    displayList=DisplayListManager.allocList(gl);
    displayListValid=false;
  }
  boolean lastSelected=false;
switch (props.getPointStyle()) {
case POINT:
{
      renderer.setLightingEnabled(false);
      renderer.setPointSize(props.getPointSize());
      if (renderer.isSelecting()) {
        int i=0;
        for (        VertexComponent vc : this) {
          if (vc.getRenderProps() == null) {
            renderer.beginSelectionQuery(i);
            gl.glBegin(GL2.GL_POINTS);
            gl.glVertex3fv(vc.getRenderCoords(),0);
            gl.glEnd();
            renderer.endSelectionQuery();
          }
          i++;
        }
      }
 else {
        renderer.setColor(color,false);
        if (useDisplayLists && !displayListValid) {
          gl.glNewList(displayList,GL2.GL_COMPILE_AND_EXECUTE);
        }
        if (!displayListValid || renderer.isSelecting()) {
          for (          VertexComponent vc : this) {
            if (vc.getRenderProps() == null) {
              if (vc.isSelected() && !lastSelected) {
                renderer.setColor(selColor);
                lastSelected=true;
              }
 else               if (!vc.isSelected() && lastSelected) {
                renderer.setColor(color);
              }
              gl.glBegin(GL2.GL_POINTS);
              gl.glVertex3fv(vc.getRenderCoords(),0);
              gl.glEnd();
            }
          }
          if (useDisplayLists) {
            gl.glEndList();
            displayListValid=true;
          }
        }
 else         if (displayListValid) {
          gl.glCallList(displayList);
        }
      }
      renderer.setPointSize(1);
      renderer.setLightingEnabled(true);
    }
case SPHERE:
{
    renderer.setMaterialAndShading(props,pointMaterial,false);
    if (useDisplayLists && !displayListValid) {
      renderer.validateInternalDisplayLists(props);
      gl.glNewList(displayList,GL2.GL_COMPILE_AND_EXECUTE);
    }
    if (!displayListValid || renderer.isSelecting()) {
      int i=0;
      for (      VertexComponent vc : this) {
        if (vc.getRenderProps() == null) {
          if (renderer.isSelecting()) {
            renderer.beginSelectionQuery(i);
            renderer.drawSphere(props,vc.getRenderCoords());
            renderer.endSelectionQuery();
          }
 else {
            if (vc.isSelected() && !lastSelected) {
              renderer.updateMaterial(props,renderer.getSelectionMaterial(),false);
              lastSelected=true;
            }
 else             if (!vc.isSelected() && lastSelected) {
              renderer.updateMaterial(props,pointMaterial,false);
              lastSelected=false;
            }
            renderer.drawSphere(props,vc.getRenderCoords());
          }
        }
        i++;
      }
      if (useDisplayLists) {
        gl.glEndList();
        displayListValid=true;
      }
    }
 else {
      gl.glCallList(displayList);
      int err=gl.glGetError();
      if (err != GL.GL_NO_ERROR) {
        System.err.println(""String_Node_Str"" + err);
      }
    }
    renderer.restoreShading(props);
  }
}
gl.glPopMatrix();
renderer.checkAndPrintGLError();
}","public void render(GLRenderer renderer,int flags){
  renderer.checkAndPrintGLError();
  GL2 gl=renderer.getGL2();
  gl.glPushMatrix();
  RenderProps props=getRenderProps();
  float[] color=props.getPointColorArray();
  float[] selColor=renderer.getSelectionColor().getColorComponents(new float[4]);
  Material pointMaterial=props.getPointMaterial();
  if (isSelected()) {
    color=selColor;
    pointMaterial=renderer.getSelectionMaterial();
  }
  if (useDisplayLists && displayList == 0) {
    displayList=DisplayListManager.allocList(gl);
    displayListValid=false;
  }
  boolean lastSelected=false;
switch (props.getPointStyle()) {
case POINT:
{
      renderer.setLightingEnabled(false);
      renderer.setPointSize(props.getPointSize());
      if (renderer.isSelecting()) {
        int i=0;
        for (        VertexComponent vc : this) {
          if (vc.getRenderProps() == null) {
            renderer.beginSelectionQuery(i);
            gl.glBegin(GL2.GL_POINTS);
            gl.glVertex3fv(vc.getRenderCoords(),0);
            gl.glEnd();
            renderer.endSelectionQuery();
          }
          i++;
        }
      }
 else {
        renderer.setColor(color,false);
        if (useDisplayLists && !displayListValid) {
          gl.glNewList(displayList,GL2.GL_COMPILE_AND_EXECUTE);
        }
        if (!displayListValid || renderer.isSelecting()) {
          for (          VertexComponent vc : this) {
            if (vc.getRenderProps() == null) {
              if (vc.isSelected() && !lastSelected) {
                renderer.setColor(selColor);
                lastSelected=true;
              }
 else               if (!vc.isSelected() && lastSelected) {
                renderer.setColor(color);
              }
              gl.glBegin(GL2.GL_POINTS);
              gl.glVertex3fv(vc.getRenderCoords(),0);
              gl.glEnd();
            }
          }
          if (useDisplayLists) {
            gl.glEndList();
            displayListValid=true;
          }
        }
 else         if (displayListValid) {
          gl.glCallList(displayList);
        }
      }
      renderer.setPointSize(1);
      renderer.setLightingEnabled(true);
      break;
    }
case SPHERE:
{
    renderer.setMaterialAndShading(props,pointMaterial,false);
    if (useDisplayLists && !displayListValid) {
      renderer.validateInternalDisplayLists(props);
      gl.glNewList(displayList,GL2.GL_COMPILE_AND_EXECUTE);
    }
    if (!displayListValid || renderer.isSelecting()) {
      int i=0;
      for (      VertexComponent vc : this) {
        if (vc.getRenderProps() == null) {
          if (renderer.isSelecting()) {
            renderer.beginSelectionQuery(i);
            renderer.drawSphere(props,vc.getRenderCoords());
            renderer.endSelectionQuery();
          }
 else {
            if (vc.isSelected() && !lastSelected) {
              renderer.updateMaterial(props,renderer.getSelectionMaterial(),false);
              lastSelected=true;
            }
 else             if (!vc.isSelected() && lastSelected) {
              renderer.updateMaterial(props,pointMaterial,false);
              lastSelected=false;
            }
            renderer.drawSphere(props,vc.getRenderCoords());
          }
        }
        i++;
      }
      if (useDisplayLists) {
        gl.glEndList();
        displayListValid=true;
      }
    }
 else {
      gl.glCallList(displayList);
      int err=gl.glGetError();
      if (err != GL.GL_NO_ERROR) {
        System.err.println(""String_Node_Str"" + err);
      }
    }
    renderer.restoreShading(props);
    break;
  }
}
gl.glPopMatrix();
renderer.checkAndPrintGLError();
}"
70887,"private void drawEdgesRaw(GLRenderer renderer,PolygonalMesh mesh,int flags){
  GL2 gl=renderer.getGL2();
  RenderProps.Shading savedShadeModel=renderer.getShadeModel();
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  boolean mergeQuadTriangles=false;
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  int[] indexOffs=mesh.getFeatureIndexOffsets();
  ArrayList<Face> faceList=mesh.getFaces();
  for (int faceIdx=0; faceIdx < faceList.size(); faceIdx++) {
    faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
    int faceOff=indexOffs[faceIdx];
    gl.glBegin(GL2.GL_LINE_LOOP);
    for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
      HalfEdge he=myEdges[edgeIdx];
      int vi=(edgeIdx <= 2 ? edgeIdx : 2);
      Vertex3d vtx=he.head;
      Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
      if (useVertexColors) {
        float[] color=null;
        int ci=mesh.myColorIndices[faceOff + vi];
        if (ci == -1) {
          color=null;
        }
 else {
          color=mesh.myColors.get(ci);
        }
        setVertexColor(gl,color,useHSVInterpolation);
      }
      gl.glVertex3d(pnt.x,pnt.y,pnt.z);
    }
    gl.glEnd();
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}","private void drawEdgesRaw(GLRenderer renderer,PolygonalMesh mesh,int flags){
  GL2 gl=renderer.getGL2();
  RenderProps.Shading savedShadeModel=renderer.getShadeModel();
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  boolean mergeQuadTriangles=false;
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  int[] indexOffs=mesh.getFeatureIndexOffsets();
  int[] cidxs=useVertexColors ? mesh.getColorIndices() : null;
  ArrayList<float[]> colors=useVertexColors ? mesh.getColors() : null;
  ArrayList<Face> faceList=mesh.getFaces();
  for (int faceIdx=0; faceIdx < faceList.size(); faceIdx++) {
    faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
    int faceOff=indexOffs[faceIdx];
    gl.glBegin(GL2.GL_LINE_LOOP);
    for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
      HalfEdge he=myEdges[edgeIdx];
      int vi=(edgeIdx <= 2 ? edgeIdx : 2);
      Vertex3d vtx=he.head;
      Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
      if (useVertexColors) {
        float[] color=null;
        int ci=cidxs[faceOff + vi];
        if (ci == -1) {
          color=null;
        }
 else {
          color=colors.get(ci);
        }
        setVertexColor(gl,color,useHSVInterpolation);
      }
      gl.glVertex3d(pnt.x,pnt.y,pnt.z);
    }
    gl.glEnd();
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}"
70888,"private void drawFacesRaw(GLRenderer renderer,PolygonalMesh mesh,TextureProps textureProps,int flags){
  Vector3d nrm;
  Vector3d[] nrms=null;
  Vector3d vtxNrm=new Vector3d();
  RenderProps.Shading savedShadeModel=renderer.getShadeModel();
  GL2 gl=renderer.getGL2();
  boolean computeVertexNormals=(flags & COMPUTE_VERTEX_NORMALS) != 0;
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  boolean useTextureCoords=(textureProps != null && textureProps.isEnabled() && !textureProps.isAutomatic() && mesh.myTextureIndices != null);
  boolean mergeQuadTriangles=(savedShadeModel != Shading.FLAT);
  if ((flags & IS_SELECTING) != 0) {
    useVertexColors=false;
  }
  if (!useNewRenderNormals && computeVertexNormals) {
    nrms=new Vector3d[mesh.numVertices()];
    for (int v=0; v < mesh.numVertices(); v++) {
      nrms[v]=new Vector3d();
      if (useRenderNormals) {
        mesh.getVertices().get(v).computeRenderNormal(nrms[v]);
      }
 else {
        mesh.getVertices().get(v).computeNormal(nrms[v]);
      }
    }
  }
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  myLastEdgeCnt=0;
  ArrayList<Face> faceList=mesh.getFaces();
  int[] faceOrder=mesh.getFaceOrder();
  int faceIdx;
synchronized (mesh) {
    int[] indexOffs=mesh.getFeatureIndexOffsets();
    int[] normalIndices=mesh.getNormalIndices();
    for (int i=0; i < faceList.size(); i++) {
      if (faceOrder == null) {
        faceIdx=i;
      }
 else {
        faceIdx=faceOrder[i];
      }
      faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
      Face face=faceList.get(faceIdx);
      if (myEdgeCnt > 4) {
        gl.glBegin(GL2.GL_POLYGON);
      }
 else       if (myLastEdgeCnt != myEdgeCnt) {
        if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
          gl.glEnd();
        }
        if (myEdgeCnt == 3) {
          gl.glBegin(GL2.GL_TRIANGLES);
        }
 else {
          gl.glBegin(GL2.GL_QUADS);
        }
      }
      if (!computeVertexNormals) {
        Vector3d faceNrm;
        if (useRenderNormals) {
          faceNrm=face.getRenderNormal();
        }
 else {
          faceNrm=face.getNormal();
        }
        gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
      }
      for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
        HalfEdge he=myEdges[edgeIdx];
        int vi=(edgeIdx <= 2 ? edgeIdx : 2);
        int faceOff=indexOffs[he.face.idx];
        Vertex3d vtx=he.head;
        Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
        if (computeVertexNormals) {
          if (useNewRenderNormals) {
            int nidx=normalIndices[faceOff + vi];
            if (nidx != -1) {
              float[] vec=mesh.myRenderNormals[nidx];
              gl.glNormal3f(vec[0],vec[1],vec[2]);
            }
          }
 else {
            HalfEdge lastHard=he.lastHardEdge();
            if (lastHard != null) {
              lastHard.computeVertexNormal(vtxNrm,useRenderNormals);
              gl.glNormal3d(vtxNrm.x,vtxNrm.y,vtxNrm.z);
            }
 else {
              nrm=nrms[he.head.idx];
              gl.glNormal3d(nrm.x,nrm.y,nrm.z);
            }
          }
        }
        if (useTextureCoords) {
          int iv=mesh.myTextureIndices[faceOff + vi];
          Vector3d vtext=mesh.myTextureCoords.get(iv);
          double sss=vtext.x;
          double ttt=vtext.y;
          gl.glTexCoord2f((float)sss,(float)(1 - ttt));
        }
        if (useVertexColors) {
          float[] color=null;
          int ci=mesh.myColorIndices[faceOff + vi];
          if (ci == -1) {
            color=null;
          }
 else {
            color=mesh.myColors.get(ci);
          }
          setVertexColor(gl,color,useHSVInterpolation);
        }
        gl.glVertex3d(pnt.x,pnt.y,pnt.z);
      }
      if (myEdgeCnt > 4) {
        gl.glEnd();
      }
      myLastEdgeCnt=myEdgeCnt;
    }
    if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
      gl.glEnd();
    }
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}","private void drawFacesRaw(GLRenderer renderer,PolygonalMesh mesh,TextureProps textureProps,int flags){
  Vector3d[] nrms=null;
  Vector3d vtxNrm=new Vector3d();
  RenderProps.Shading savedShadeModel=renderer.getShadeModel();
  GL2 gl=renderer.getGL2();
  boolean computeVertexNormals=(flags & COMPUTE_VERTEX_NORMALS) != 0;
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  boolean useTextureCoords=(textureProps != null && textureProps.isEnabled() && !textureProps.isAutomatic() && mesh.myTextureIndices != null);
  boolean mergeQuadTriangles=(savedShadeModel != Shading.FLAT);
  if ((flags & IS_SELECTING) != 0) {
    useVertexColors=false;
  }
  if (!useNewRenderNormals && computeVertexNormals) {
    nrms=new Vector3d[mesh.numVertices()];
    for (int v=0; v < mesh.numVertices(); v++) {
      nrms[v]=new Vector3d();
      if (useRenderNormals) {
        mesh.getVertices().get(v).computeRenderNormal(nrms[v]);
      }
 else {
        mesh.getVertices().get(v).computeNormal(nrms[v]);
      }
    }
  }
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  myLastEdgeCnt=0;
  ArrayList<Face> faceList=mesh.getFaces();
  int[] faceOrder=mesh.getFaceOrder();
  int faceIdx;
synchronized (mesh) {
    int[] indexOffs=mesh.getFeatureIndexOffsets();
    int[] normalIndices=mesh.getNormalIndices();
    int[] cidxs=useVertexColors ? mesh.getColorIndices() : null;
    ArrayList<float[]> colors=useVertexColors ? mesh.getColors() : null;
    for (int i=0; i < faceList.size(); i++) {
      if (faceOrder == null) {
        faceIdx=i;
      }
 else {
        faceIdx=faceOrder[i];
      }
      faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
      Face face=faceList.get(faceIdx);
      if (myEdgeCnt > 4) {
        gl.glBegin(GL2.GL_POLYGON);
      }
 else       if (myLastEdgeCnt != myEdgeCnt) {
        if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
          gl.glEnd();
        }
        if (myEdgeCnt == 3) {
          gl.glBegin(GL2.GL_TRIANGLES);
        }
 else {
          gl.glBegin(GL2.GL_QUADS);
        }
      }
      if (!computeVertexNormals) {
        Vector3d faceNrm;
        if (useRenderNormals) {
          faceNrm=face.getRenderNormal();
        }
 else {
          faceNrm=face.getNormal();
        }
        gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
      }
      for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
        HalfEdge he=myEdges[edgeIdx];
        int vi=(edgeIdx <= 2 ? edgeIdx : 2);
        int faceOff=indexOffs[he.face.idx];
        Vertex3d vtx=he.head;
        Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
        if (computeVertexNormals) {
          if (useNewRenderNormals) {
            int nidx=normalIndices[faceOff + vi];
            if (nidx != -1) {
              float[] nrm=mesh.myRenderNormals[nidx];
              gl.glNormal3f(nrm[0],nrm[1],nrm[2]);
            }
          }
 else {
            HalfEdge lastHard=he.lastHardEdge();
            if (lastHard != null) {
              lastHard.computeVertexNormal(vtxNrm,useRenderNormals);
              gl.glNormal3d(vtxNrm.x,vtxNrm.y,vtxNrm.z);
            }
 else {
              Vector3d nrm=nrms[he.head.idx];
              gl.glNormal3d(nrm.x,nrm.y,nrm.z);
            }
          }
        }
        if (useTextureCoords) {
          int iv=mesh.myTextureIndices[faceOff + vi];
          Vector3d vtext=mesh.myTextureCoords.get(iv);
          double sss=vtext.x;
          double ttt=vtext.y;
          gl.glTexCoord2f((float)sss,(float)(1 - ttt));
        }
        if (useVertexColors) {
          float[] color=null;
          int ci=cidxs[faceOff + vi];
          if (ci == -1) {
            color=null;
          }
 else {
            color=colors.get(ci);
          }
          setVertexColor(gl,color,useHSVInterpolation);
        }
        gl.glVertex3d(pnt.x,pnt.y,pnt.z);
      }
      if (myEdgeCnt > 4) {
        gl.glEnd();
      }
      myLastEdgeCnt=myEdgeCnt;
    }
    if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
      gl.glEnd();
    }
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}"
70889,"private GL3Object buildObjectGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,AttributeInfo[] radiusLengthInfo,GL3Object object,boolean hasLengthOffset){
  GL3VertexAttributeArray[] pattribs=object.getGL3VertexAttributes();
  int nattribs=pattribs.length;
  nattribs++;
  if (hasLengthOffset) {
    nattribs++;
  }
  if (pidx >= 0) {
    nattribs+=2;
  }
  if (cidx >= 0) {
    nattribs+=2;
  }
  if (tidx >= 0) {
    tidx+=2;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  for (int i=0; i < pattribs.length; ++i) {
    attribs[i]=pattribs[i];
  }
  int aidx=pattribs.length;
  attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[0].vboIndex],GL3VertexAttribute.LINE_RADIUS,GL.GL_FLOAT,1,false,radiusLengthInfo[0].offset,radiusLengthInfo[0].stride,radiusLengthInfo[0].count,robj.numLines(oidx));
  if (hasLengthOffset) {
    attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[1].vboIndex],GL3VertexAttribute.LINE_LENGTH_OFFSET,GL.GL_FLOAT,4,false,radiusLengthInfo[1].offset,radiusLengthInfo[1].stride,radiusLengthInfo[1].count,robj.numLines(oidx));
  }
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + lineGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * pinfo.stride,pinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + pinfo.stride,2 * pinfo.stride,pinfo.count / 2,1);
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + lineGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * cinfo.stride,cinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + cinfo.stride,2 * cinfo.stride,cinfo.count / 2,1);
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + lineGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * tinfo.stride,tinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + tinfo.stride,2 * tinfo.stride,tinfo.count / 2,1);
  }
  GL3Object glo=new GL3Object(gl,attribs,object.getGL3ElementAttribute());
  glo.setDrawInfo(object.getStart(),object.getCount(),object.getMode(),robj.numLines(oidx));
  return glo;
}","private GL3Object buildObjectGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,AttributeInfo[] radiusLengthInfo,GL3Object object,boolean hasLengthOffset){
  GL3VertexAttributeArray[] pattribs=object.getGL3VertexAttributes();
  int nattribs=pattribs.length;
  nattribs++;
  if (hasLengthOffset) {
    nattribs++;
  }
  if (pidx >= 0) {
    nattribs+=2;
  }
  if (cidx >= 0) {
    nattribs+=2;
  }
  if (tidx >= 0) {
    tidx+=2;
  }
  int lineCount=lineGroupOffsets[oidx + 1] - lineGroupOffsets[oidx];
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  for (int i=0; i < pattribs.length; ++i) {
    attribs[i]=pattribs[i];
  }
  int aidx=pattribs.length;
  attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[0].vboIndex],GL3VertexAttribute.LINE_RADIUS,GL.GL_FLOAT,1,false,radiusLengthInfo[0].offset,radiusLengthInfo[0].stride,radiusLengthInfo[0].count,lineCount);
  if (hasLengthOffset) {
    attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[1].vboIndex],GL3VertexAttribute.LINE_LENGTH_OFFSET,GL.GL_FLOAT,4,false,radiusLengthInfo[1].offset,radiusLengthInfo[1].stride,radiusLengthInfo[1].count,lineCount);
  }
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + 2 * lineGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * pinfo.stride,lineCount,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + pinfo.stride,2 * pinfo.stride,lineCount,1);
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + 2 * lineGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * cinfo.stride,lineCount,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + cinfo.stride,2 * cinfo.stride,lineCount,1);
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + 2 * lineGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * tinfo.stride,lineCount,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + tinfo.stride,2 * tinfo.stride,lineCount,1);
  }
  GL3Object glo=new GL3Object(gl,attribs,object.getGL3ElementAttribute());
  glo.setDrawInfo(object.getStart(),object.getCount(),object.getMode(),lineCount);
  return glo;
}"
70890,"private void createVBOs(GL3 gl,RenderObject robj,GL3Object lineObject,float lineRadius,GL3Object headObject,float headRadius,float headLength){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  lineGroupOffsets=new int[robj.numLineGroups()];
  lineInfo=createAttributeInfoArrays(2);
  headInfo=createAttributeInfoArrays(2);
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numLinesTotal=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    lineGroupOffsets[lg]=numLinesTotal;
    numLinesTotal+=robj.numLines(lg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * 2* numLinesTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * 2* numLinesTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * 2* numLinesTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * 2* numLinesTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=2 * numLinesTotal;
    }
  }
  int staticVBOIdx=0;
  int dynamicVBOIdx=0;
  if (staticVertexSize > 0 && dynamicVertexSize > 0) {
    dynamicVBOIdx=1;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=staticVBOIdx;
    }
  }
  int vboIdx=dynamicVBOIdx + 1;
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  lineInfo[0].offset=0;
  lineInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[0].count=1;
  lineInfo[0].vboIndex=vboIdx;
  lineInfo[1].offset=1 * GLSupport.FLOAT_SIZE;
  lineInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[1].count=1;
  lineInfo[1].vboIndex=vboIdx;
  headInfo[0].offset=5 * GLSupport.FLOAT_SIZE;
  headInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[0].count=1;
  headInfo[0].vboIndex=vboIdx;
  headInfo[1].offset=6 * GLSupport.FLOAT_SIZE;
  headInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[1].count=1;
  headInfo[1].vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numPositionSets() - 1)* POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numNormalSets() - 1)* NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numColorSets() - 1)* COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numTextureCoordSets() - 1)* TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    List<int[]> lines=robj.getLines(lg);
    for (    int[] line : lines) {
      for (int j=0; j < 2; ++j) {
        VertexIndexSet v=robj.getVertex(line[j]);
        for (int i=0; i < positionInfo.length; ++i) {
          AttributeInfo ai=positionInfo[i];
          float[] pos=robj.getPosition(i,v.getPositionIndex());
          positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        for (int i=0; i < normalInfo.length; ++i) {
          AttributeInfo ai=normalInfo[i];
          float[] nrm=robj.getNormal(i,v.getNormalIndex());
          normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
        }
        for (int i=0; i < colorInfo.length; ++i) {
          AttributeInfo ai=colorInfo[i];
          byte[] color=robj.getColor(i,v.getColorIndex());
          colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
        }
        for (int i=0; i < textureInfo.length; ++i) {
          AttributeInfo ai=textureInfo[i];
          float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
          texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        vidx++;
      }
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(10 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(lineRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}","private void createVBOs(GL3 gl,RenderObject robj,GL3Object lineObject,float lineRadius,GL3Object headObject,float headRadius,float headLength){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  lineGroupOffsets=new int[robj.numLineGroups() + 1];
  lineInfo=createAttributeInfoArrays(2);
  headInfo=createAttributeInfoArrays(2);
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numLinesTotal=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    lineGroupOffsets[lg]=numLinesTotal;
    numLinesTotal+=robj.numLines(lg);
  }
  lineGroupOffsets[robj.numLineGroups()]=numLinesTotal;
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * 2* numLinesTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * 2* numLinesTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * 2* numLinesTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * 2* numLinesTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=2 * numLinesTotal;
    }
  }
  int staticVBOIdx=0;
  int dynamicVBOIdx=0;
  if (staticVertexSize > 0 && dynamicVertexSize > 0) {
    dynamicVBOIdx=1;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=staticVBOIdx;
    }
  }
  int vboIdx=dynamicVBOIdx + 1;
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  lineInfo[0].offset=0;
  lineInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[0].count=1;
  lineInfo[0].vboIndex=vboIdx;
  lineInfo[1].offset=1 * GLSupport.FLOAT_SIZE;
  lineInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[1].count=1;
  lineInfo[1].vboIndex=vboIdx;
  headInfo[0].offset=5 * GLSupport.FLOAT_SIZE;
  headInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[0].count=1;
  headInfo[0].vboIndex=vboIdx;
  headInfo[1].offset=6 * GLSupport.FLOAT_SIZE;
  headInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[1].count=1;
  headInfo[1].vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numPositionSets() - 1)* POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numNormalSets() - 1)* NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numColorSets() - 1)* COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numTextureCoordSets() - 1)* TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    List<int[]> lines=robj.getLines(lg);
    for (    int[] line : lines) {
      for (int j=0; j < 2; ++j) {
        VertexIndexSet v=robj.getVertex(line[j]);
        for (int i=0; i < positionInfo.length; ++i) {
          AttributeInfo ai=positionInfo[i];
          float[] pos=robj.getPosition(i,v.getPositionIndex());
          positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        for (int i=0; i < normalInfo.length; ++i) {
          AttributeInfo ai=normalInfo[i];
          float[] nrm=robj.getNormal(i,v.getNormalIndex());
          normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
        }
        for (int i=0; i < colorInfo.length; ++i) {
          AttributeInfo ai=colorInfo[i];
          byte[] color=robj.getColor(i,v.getColorIndex());
          colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
        }
        for (int i=0; i < textureInfo.length; ++i) {
          AttributeInfo ai=textureInfo[i];
          float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
          texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        vidx++;
      }
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(10 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(lineRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}"
70891,"private GL3Object buildLineGLO(GL3 gl,int pidx,int nidx,int cidx,int tidx,int oidx){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + lineGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,pinfo.stride,pinfo.count);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    int offset=ninfo.offset + lineGroupOffsets[oidx] * ninfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,ninfo.stride,ninfo.count);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + lineGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,cinfo.stride,cinfo.count);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + lineGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,tinfo.stride,tinfo.count);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,null,GL.GL_LINES);
  return glo;
}","private GL3Object buildLineGLO(GL3 gl,int pidx,int nidx,int cidx,int tidx,int oidx){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int lineCount2=2 * (lineGroupOffsets[oidx + 1] - lineGroupOffsets[oidx]);
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + 2 * lineGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,pinfo.stride,lineCount2);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    int offset=ninfo.offset + 2 * lineGroupOffsets[oidx] * ninfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,ninfo.stride,lineCount2);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + 2 * lineGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,cinfo.stride,lineCount2);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + 2 * lineGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,tinfo.stride,lineCount2);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,null,GL.GL_LINES);
  return glo;
}"
70892,"private GL3Object buildObjectGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,GL3Object pointObject,float pointRadius){
  GL3VertexAttributeArray[] pattribs=pointObject.getGL3VertexAttributes();
  int nattribs=pattribs.length;
  nattribs++;
  if (pidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  for (int i=0; i < pattribs.length; ++i) {
    attribs[i]=pattribs[i];
  }
  int aidx=pattribs.length;
  attribs[aidx++]=new GL3VertexAttributeArray(vbos[pointInfo.vboIndex],GL3VertexAttribute.INSTANCE_SCALE,GL.GL_FLOAT,1,false,pointInfo.offset,pointInfo.stride,pointInfo.count,robj.numPoints(oidx));
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + pointGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.INSTANCE_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,pinfo.stride,pinfo.count,1);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + pointGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.INSTANCE_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,cinfo.stride,cinfo.count,1);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + pointGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.INSTANCE_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,tinfo.stride,tinfo.count,1);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,pointObject.getGL3ElementAttribute());
  glo.setDrawInfo(pointObject.getStart(),pointObject.getCount(),pointObject.getMode(),robj.numPoints(oidx));
  return glo;
}","private GL3Object buildObjectGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,GL3Object pointObject,float pointRadius){
  GL3VertexAttributeArray[] pattribs=pointObject.getGL3VertexAttributes();
  int nattribs=pattribs.length;
  nattribs++;
  if (pidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  for (int i=0; i < pattribs.length; ++i) {
    attribs[i]=pattribs[i];
  }
  int aidx=pattribs.length;
  attribs[aidx++]=new GL3VertexAttributeArray(vbos[pointInfo.vboIndex],GL3VertexAttribute.INSTANCE_SCALE,GL.GL_FLOAT,1,false,pointInfo.offset,pointInfo.stride,pointInfo.count,robj.numPoints(oidx));
  int pointCount=pointGroupOffsets[oidx + 1] - pointGroupOffsets[oidx];
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + pointGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.INSTANCE_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,pinfo.stride,pointCount,1);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + pointGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.INSTANCE_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,cinfo.stride,pointCount,1);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + pointGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.INSTANCE_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,tinfo.stride,pointCount,1);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,pointObject.getGL3ElementAttribute());
  glo.setDrawInfo(pointObject.getStart(),pointObject.getCount(),pointObject.getMode(),robj.numPoints(oidx));
  return glo;
}"
70893,"private void createVBOs(GL3 gl,RenderObject robj,float pointRadius){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  pointGroupOffsets=new int[robj.numPointGroups()];
  pointInfo=new AttributeInfo();
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numPointsTotal=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    pointGroupOffsets[pg]=numPointsTotal;
    numPointsTotal+=robj.numPoints(pg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=numPointsTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * numPointsTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=numPointsTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * numPointsTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=numPointsTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * numPointsTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=numPointsTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * numPointsTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=numPointsTotal;
    }
  }
  int staticVBOIdx=0;
  int dynamicVBOIdx=0;
  if (staticVertexSize > 0 && dynamicVertexSize > 0) {
    dynamicVBOIdx=1;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=staticVBOIdx;
    }
  }
  int vboIdx=dynamicVBOIdx + 1;
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  pointInfo.offset=0;
  pointInfo.stride=1 * GLSupport.FLOAT_SIZE;
  pointInfo.count=1;
  pointInfo.vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numPositionSets() - 1) * POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numNormalSets() - 1) * NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numColorSets() - 1) * COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numTextureCoordSets() - 1) * TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    List<int[]> pnts=robj.getPoints(pg);
    for (    int[] pnt : pnts) {
      VertexIndexSet v=robj.getVertex(pnt[0]);
      for (int i=0; i < positionInfo.length; ++i) {
        AttributeInfo ai=positionInfo[i];
        float[] pos=robj.getPosition(i,v.getPositionIndex());
        positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      for (int i=0; i < normalInfo.length; ++i) {
        AttributeInfo ai=normalInfo[i];
        float[] nrm=robj.getNormal(i,v.getNormalIndex());
        normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
      }
      for (int i=0; i < colorInfo.length; ++i) {
        AttributeInfo ai=colorInfo[i];
        byte[] color=robj.getColor(i,v.getColorIndex());
        colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
      }
      for (int i=0; i < textureInfo.length; ++i) {
        AttributeInfo ai=textureInfo[i];
        float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
        texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      vidx++;
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(1 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(pointRadius);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}","private void createVBOs(GL3 gl,RenderObject robj,float pointRadius){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  pointGroupOffsets=new int[robj.numPointGroups() + 1];
  pointInfo=new AttributeInfo();
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numPointsTotal=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    pointGroupOffsets[pg]=numPointsTotal;
    numPointsTotal+=robj.numPoints(pg);
  }
  pointGroupOffsets[robj.numPointGroups()]=numPointsTotal;
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=numPointsTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * numPointsTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=numPointsTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * numPointsTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=numPointsTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * numPointsTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=numPointsTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * numPointsTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=numPointsTotal;
    }
  }
  int staticVBOIdx=0;
  int dynamicVBOIdx=0;
  if (staticVertexSize > 0 && dynamicVertexSize > 0) {
    dynamicVBOIdx=1;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=staticVBOIdx;
    }
  }
  int vboIdx=dynamicVBOIdx + 1;
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  pointInfo.offset=0;
  pointInfo.stride=1 * GLSupport.FLOAT_SIZE;
  pointInfo.count=1;
  pointInfo.vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numPositionSets() - 1) * POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numNormalSets() - 1) * NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numColorSets() - 1) * COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numTextureCoordSets() - 1) * TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    List<int[]> pnts=robj.getPoints(pg);
    for (    int[] pnt : pnts) {
      VertexIndexSet v=robj.getVertex(pnt[0]);
      for (int i=0; i < positionInfo.length; ++i) {
        AttributeInfo ai=positionInfo[i];
        float[] pos=robj.getPosition(i,v.getPositionIndex());
        positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      for (int i=0; i < normalInfo.length; ++i) {
        AttributeInfo ai=normalInfo[i];
        float[] nrm=robj.getNormal(i,v.getNormalIndex());
        normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
      }
      for (int i=0; i < colorInfo.length; ++i) {
        AttributeInfo ai=colorInfo[i];
        byte[] color=robj.getColor(i,v.getColorIndex());
        colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
      }
      for (int i=0; i < textureInfo.length; ++i) {
        AttributeInfo ai=textureInfo[i];
        float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
        texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      vidx++;
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(1 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(pointRadius);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}"
70894,"private GL3Object buildPointGLO(GL3 gl,int pidx,int nidx,int cidx,int tidx,int oidx){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + pointGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,pinfo.stride,pinfo.count);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    int offset=ninfo.offset + pointGroupOffsets[oidx] * ninfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,ninfo.stride,ninfo.count);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + pointGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,cinfo.stride,cinfo.count);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + pointGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,tinfo.stride,tinfo.count);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,null,GL.GL_POINTS);
  return glo;
}","private GL3Object buildPointGLO(GL3 gl,int pidx,int nidx,int cidx,int tidx,int oidx){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int pointCount=pointGroupOffsets[oidx + 1] - pointGroupOffsets[oidx];
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + pointGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,pinfo.stride,pointCount);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    int offset=ninfo.offset + pointGroupOffsets[oidx] * ninfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,ninfo.stride,pointCount);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + pointGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,cinfo.stride,pointCount);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + pointGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,tinfo.stride,pointCount);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,null,GL.GL_POINTS);
  return glo;
}"
70895,"private void setProbeUpdateInterval(double h){
  refTargetForceInProbe.setUpdateInterval(h);
  refTargetMotionInProbe.setUpdateInterval(h);
  excitationInput.setUpdateInterval(h);
  excitationOutProbe.setUpdateInterval(h);
  modelTargetMotionOutProbe.setUpdateInterval(h);
  refTargetMotionOutProbe.setUpdateInterval(h);
}","private void setProbeUpdateInterval(double h){
  if (refTargetForceInProbe != null) {
    refTargetForceInProbe.setUpdateInterval(h);
  }
  if (refTargetMotionInProbe != null) {
    refTargetMotionInProbe.setUpdateInterval(h);
    modelTargetMotionOutProbe.setUpdateInterval(h);
    refTargetMotionOutProbe.setUpdateInterval(h);
  }
  excitationInput.setUpdateInterval(h);
  excitationOutProbe.setUpdateInterval(h);
}"
70896,"private void configureTargetForceProbe(NumericProbeBase probe,ArrayList<ForceTarget> targets,String filename){
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ForceTarget target : targets) {
    props.add(target.getProperty(""String_Node_Str""));
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}","private void configureTargetForceProbe(NumericProbeBase probe,ArrayList<ForceTarget> targets,String filename){
  System.out.println(""String_Node_Str"");
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ForceTarget target : targets) {
    props.add(target.getProperty(""String_Node_Str""));
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}"
70897,"private void findOrCreateProbes(RootModel root,TrackingController controller){
  refTargetForceInProbe=findOrCreateInputProbe(root,""String_Node_Str"");
  refTargetMotionInProbe=findOrCreateInputProbe(root,""String_Node_Str"");
  refTargetMotionOutProbe=findOrCreateOutputProbe(root,""String_Node_Str"");
  modelTargetMotionOutProbe=findOrCreateOutputProbe(root,""String_Node_Str"");
  excitationOutProbe=findOrCreateOutputProbe(root,""String_Node_Str"");
  excitationInput=findOrCreateInputProbe(root,""String_Node_Str"");
  setLoneBreakpoint(root,controller.getProbeDuration());
  setProbeDuration(controller.getProbeDuration());
  setProbeUpdateInterval(controller.getProbeUpdateInterval());
  if (myMain.getTimeline() != null && myMain.getRootModel() != null) {
    myMain.getTimeline().requestResetAll();
  }
}","private void findOrCreateProbes(RootModel root,TrackingController controller){
  if (findForceTargetTerm(controller) != null) {
    refTargetForceInProbe=findOrCreateInputProbe(root,""String_Node_Str"");
  }
  if (findMotionTargetTerm(controller) != null) {
    refTargetMotionInProbe=findOrCreateInputProbe(root,""String_Node_Str"");
    refTargetMotionOutProbe=findOrCreateOutputProbe(root,""String_Node_Str"");
    modelTargetMotionOutProbe=findOrCreateOutputProbe(root,""String_Node_Str"");
  }
  excitationOutProbe=findOrCreateOutputProbe(root,""String_Node_Str"");
  excitationInput=findOrCreateInputProbe(root,""String_Node_Str"");
  setLoneBreakpoint(root,controller.getProbeDuration());
  setProbeDuration(controller.getProbeDuration());
  setProbeUpdateInterval(controller.getProbeUpdateInterval());
  if (myMain.getTimeline() != null && myMain.getRootModel() != null) {
    myMain.getTimeline().requestResetAll();
  }
}"
70898,"private void setProbeDuration(double t){
  refTargetForceInProbe.setStopTime(t);
  refTargetMotionInProbe.setStopTime(t);
  excitationInput.setStopTime(t);
  excitationOutProbe.setStopTime(t);
  modelTargetMotionOutProbe.setStopTime(t);
  refTargetMotionOutProbe.setStopTime(t);
}","private void setProbeDuration(double t){
  if (refTargetForceInProbe != null) {
    refTargetForceInProbe.setStopTime(t);
  }
  if (refTargetMotionInProbe != null) {
    refTargetMotionInProbe.setStopTime(t);
    modelTargetMotionOutProbe.setStopTime(t);
    refTargetMotionOutProbe.setStopTime(t);
  }
  excitationInput.setStopTime(t);
  excitationOutProbe.setStopTime(t);
}"
70899,"private void configureTargetMotionProbe(NumericProbeBase probe,ArrayList<MotionTargetComponent> targets,String filename){
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ModelComponent target : targets) {
    if (target instanceof Point) {
      props.add(target.getProperty(""String_Node_Str""));
    }
 else     if (target instanceof Frame) {
      props.add(target.getProperty(""String_Node_Str""));
      props.add(target.getProperty(""String_Node_Str""));
    }
 else {
      System.err.println(""String_Node_Str"" + target.getClass().toString());
    }
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}","private void configureTargetMotionProbe(NumericProbeBase probe,ArrayList<MotionTargetComponent> targets,String filename){
  System.out.println(""String_Node_Str"");
  ArrayList<Property> props=new ArrayList<Property>();
  for (  ModelComponent target : targets) {
    if (target instanceof Point) {
      props.add(target.getProperty(""String_Node_Str""));
    }
 else     if (target instanceof Frame) {
      props.add(target.getProperty(""String_Node_Str""));
      props.add(target.getProperty(""String_Node_Str""));
    }
 else {
      System.err.println(""String_Node_Str"" + target.getClass().toString());
    }
  }
  probe.setAttachedFileName(filename);
  if (probe instanceof NumericInputProbe) {
    ((NumericInputProbe)probe).setInputProperties(props.toArray(new Property[props.size()]));
  }
 else   if (probe instanceof NumericOutputProbe) {
    ((NumericOutputProbe)probe).setOutputProperties(props.toArray(new Property[props.size()]));
  }
  if (probe instanceof NumericInputProbe) {
    File file=probe.getAttachedFile();
    if (file == null || !file.exists()) {
      ((NumericInputProbe)probe).loadEmpty();
      probe.setActive(false);
    }
 else {
      try {
        probe.load();
        probe.setActive(true);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
}"
70900,"protected void addSpringMesh(MechModel mech){
  Particle p0=new Particle(0.5,-0.10,0,0.20);
  p0.setDynamic(false);
  Particle p1=new Particle(0.5,0,0,0.25);
  Particle p2=new Particle(0.5,0,0,0.15);
  Particle p3=new Particle(0.5,0.10,0,0.20);
  AxialSpring[] springs=new AxialSpring[10];
  for (int i=0; i < springs.length; i++) {
    springs[i]=new AxialSpring(0.50,0.20,0.10);
  }
  mech.particles().addNumbered(p1,4);
  mech.particles().addNumbered(p2,0);
  mech.attachAxialSpring(p1,p2,springs[2]);
}","protected void addSpringMesh(MechModel mech){
  Particle p0=new Particle(0.5,-0.10,0,0.20);
  p0.setDynamic(false);
  Particle p1=new Particle(0.5,0,0,0.25);
  Particle p2=new Particle(0.5,0,0,0.15);
  Particle p3=new Particle(0.5,0.10,0,0.20);
  AxialSpring[] springs=new AxialSpring[10];
  for (int i=0; i < springs.length; i++) {
    springs[i]=new AxialSpring(0.50,0.20,0.10);
  }
  mech.particles().addNumbered(p1,4);
  mech.particles().addNumbered(p2,0);
  mech.attachAxialSpring(p2,p1,springs[2]);
}"
70901,"@Override public void build(String[] args) throws IOException {
  super.build(args);
  MechModel mech=new MechModel(""String_Node_Str"");
  addModel(mech);
  addSpringMesh(mech);
  for (  AxialSpring s : mech.axialSprings()) {
    s.setRenderProps(null);
  }
  RenderProps.setLineStyle(mech,LineStyle.CYLINDER);
  RenderProps.setLineRadius(mech,0.02);
}","@Override public void build(String[] args) throws IOException {
  super.build(args);
  MechModel mech=new MechModel(""String_Node_Str"");
  addModel(mech);
  addVerticalSprings(mech);
  for (  AxialSpring s : mech.axialSprings()) {
    s.setRenderProps(null);
  }
  RenderProps.setLineStyle(mech,LineStyle.CYLINDER);
  RenderProps.setLineRadius(mech,0.02);
}"
70902,"private static void addRodriguesLineRotation(StringBuilder fb){
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb);
}","private static void addRodriguesLineRotation(StringBuilder fb){
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb,""String_Node_Str"");
  appendln(fb);
}"
70903,"void drawFacesRaw(GLRenderer renderer,GL2 gl,RenderProps props,Material faceMaterial){
  boolean useVertexColors=useVertexColouring;
  if (renderer.isSelecting()) {
    useVertexColors=false;
  }
  int type=-1;
  int lastType=-1;
  boolean lastSelected=false;
  ArrayList<float[]> colors=null;
  int[] colorIndices=null;
  int[] indexOffs=null;
  if (useVertexColors && size() > 0) {
    MeshBase mesh=get(0).myMesh;
    colors=mesh.getColors();
    colorIndices=mesh.getColorIndices();
    indexOffs=mesh.getFeatureIndexOffsets();
  }
  int i=0;
  for (  FaceComponent fc : this) {
    if (fc.getRenderProps() == null) {
      Face face=fc.getFace();
      if (face.isTriangle()) {
        type=0;
      }
 else       if (face.numEdges() == 4) {
        type=1;
      }
 else {
        type=2;
      }
      if (renderer.isSelecting()) {
        renderer.beginSelectionQuery(i);
      }
 else {
        if (fc.isSelected() && !lastSelected) {
          renderer.updateMaterial(props,renderer.getSelectionMaterial(),true);
          lastSelected=true;
        }
 else         if (!fc.isSelected() && lastSelected) {
          renderer.updateMaterial(props,faceMaterial,false);
          lastSelected=false;
        }
      }
      if (lastType == -1) {
switch (type) {
case 0:
          gl.glBegin(GL2.GL_TRIANGLES);
        break;
case 1:
      gl.glBegin(GL2.GL_QUADS);
    break;
default :
  gl.glBegin(GL2.GL_POLYGON);
}
}
 else if (type == 0 && lastType != 0) {
gl.glEnd();
gl.glBegin(GL2.GL_TRIANGLES);
}
 else if (type == 1 && lastType != 1) {
gl.glEnd();
gl.glBegin(GL2.GL_QUADS);
}
 else if (type == 2 && lastType != 2) {
gl.glEnd();
gl.glBegin(GL2.GL_POLYGON);
}
Vector3d faceNrm=face.getNormal();
gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
int k=0;
HalfEdge he=face.firstHalfEdge();
int faceOff=indexOffs[i];
do {
Vertex3d vtx=he.head;
Point3d pnt=vtx.myRenderPnt;
if (useVertexColors) {
int cidx=colorIndices[faceOff + k];
if (cidx != -1) {
  float[] color=colors.get(cidx);
  gl.glColor4f(color[0],color[1],color[2],color[3]);
}
}
gl.glVertex3d(pnt.x,pnt.y,pnt.z);
he=he.getNext();
k++;
}
 while (he != face.firstHalfEdge());
if (renderer.isSelecting()) {
gl.glEnd();
renderer.endSelectionQuery();
lastType=-1;
}
 else {
lastType=type;
}
}
++i;
}
if (lastType != -1) {
gl.glEnd();
}
}","void drawFacesRaw(GLRenderer renderer,GL2 gl,RenderProps props,Material faceMaterial){
  boolean useVertexColors=useVertexColouring;
  if (renderer.isSelecting()) {
    useVertexColors=false;
  }
  int type=-1;
  int lastType=-1;
  boolean lastSelected=false;
  ArrayList<float[]> colors=null;
  int[] colorIndices=null;
  int[] indexOffs=null;
  if (useVertexColors && size() > 0) {
    MeshBase mesh=get(0).myMesh;
    colors=mesh.getColors();
    colorIndices=mesh.getColorIndices();
    indexOffs=mesh.getFeatureIndexOffsets();
  }
  int i=0;
  for (  FaceComponent fc : this) {
    if (fc.getRenderProps() == null) {
      Face face=fc.getFace();
      if (face.isTriangle()) {
        type=0;
      }
 else       if (face.numEdges() == 4) {
        type=1;
      }
 else {
        type=2;
      }
      if (renderer.isSelecting()) {
        renderer.beginSelectionQuery(i);
      }
 else {
        if (fc.isSelected() && !lastSelected) {
          renderer.updateMaterial(props,renderer.getSelectionMaterial(),true);
          lastSelected=true;
        }
 else         if (!fc.isSelected() && lastSelected) {
          renderer.updateMaterial(props,faceMaterial,false);
          lastSelected=false;
        }
      }
      if (lastType == -1) {
switch (type) {
case 0:
          gl.glBegin(GL2.GL_TRIANGLES);
        break;
case 1:
      gl.glBegin(GL2.GL_QUADS);
    break;
default :
  gl.glBegin(GL2.GL_POLYGON);
}
}
 else if (type == 0 && lastType != 0) {
gl.glEnd();
gl.glBegin(GL2.GL_TRIANGLES);
}
 else if (type == 1 && lastType != 1) {
gl.glEnd();
gl.glBegin(GL2.GL_QUADS);
}
 else if (type == 2 && lastType != 2) {
gl.glEnd();
gl.glBegin(GL2.GL_POLYGON);
}
Vector3d faceNrm=face.getNormal();
gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
int k=0;
HalfEdge he=face.firstHalfEdge();
do {
Vertex3d vtx=he.head;
Point3d pnt=vtx.myRenderPnt;
if (useVertexColors) {
int faceOff=indexOffs[i];
int cidx=colorIndices[faceOff + k];
if (cidx != -1) {
  float[] color=colors.get(cidx);
  gl.glColor4f(color[0],color[1],color[2],color[3]);
}
}
gl.glVertex3d(pnt.x,pnt.y,pnt.z);
he=he.getNext();
k++;
}
 while (he != face.firstHalfEdge());
if (renderer.isSelecting()) {
gl.glEnd();
renderer.endSelectionQuery();
lastType=-1;
}
 else {
lastType=type;
}
}
++i;
}
if (lastType != -1) {
gl.glEnd();
}
}"
70904,"private void drawEdges(GL2 gl,RenderProps props){
  ArrayList<float[]> colors=null;
  int[] colorIndices=null;
  int[] indexOffs=null;
  if (useVertexColouring && size() > 0) {
    MeshBase mesh=get(0).myMesh;
    colors=mesh.getColors();
    colorIndices=mesh.getColorIndices();
    indexOffs=mesh.getFeatureIndexOffsets();
  }
  gl.glBegin(GL2.GL_LINES);
  for (  FaceComponent fc : this) {
    if (fc.getRenderProps() == null) {
      Face face=fc.getFace();
      HalfEdge he=face.firstHalfEdge();
      int k=0;
      int faceOff=indexOffs[face.getIndex()];
      do {
        if (useVertexColouring) {
          int cidx=colorIndices[faceOff + k];
          if (cidx != -1) {
            float[] color=colors.get(cidx);
            gl.glColor4f(color[0],color[1],color[2],color[3]);
          }
        }
        Point3d pnt=he.head.myRenderPnt;
        gl.glVertex3d(pnt.x,pnt.y,pnt.z);
        pnt=he.tail.myRenderPnt;
        gl.glVertex3d(pnt.x,pnt.y,pnt.z);
        he=he.getNext();
        k++;
      }
 while (he != face.firstHalfEdge());
    }
  }
  gl.glEnd();
}","private void drawEdges(GL2 gl,RenderProps props){
  ArrayList<float[]> colors=null;
  int[] colorIndices=null;
  int[] indexOffs=null;
  if (useVertexColouring && size() > 0) {
    MeshBase mesh=get(0).myMesh;
    colors=mesh.getColors();
    colorIndices=mesh.getColorIndices();
    indexOffs=mesh.getFeatureIndexOffsets();
  }
  gl.glBegin(GL2.GL_LINES);
  for (  FaceComponent fc : this) {
    if (fc.getRenderProps() == null) {
      Face face=fc.getFace();
      HalfEdge he=face.firstHalfEdge();
      int k=0;
      do {
        if (useVertexColouring) {
          int faceOff=indexOffs[face.getIndex()];
          int cidx=colorIndices[faceOff + k];
          if (cidx != -1) {
            float[] color=colors.get(cidx);
            gl.glColor4f(color[0],color[1],color[2],color[3]);
          }
        }
        Point3d pnt=he.head.myRenderPnt;
        gl.glVertex3d(pnt.x,pnt.y,pnt.z);
        pnt=he.tail.myRenderPnt;
        gl.glVertex3d(pnt.x,pnt.y,pnt.z);
        he=he.getNext();
        k++;
      }
 while (he != face.firstHalfEdge());
    }
  }
  gl.glEnd();
}"
70905,"/** 
 * Explicitly sets the colors and associated indices for this mesh. The information supplied by <code>colors</code> and <code>indices</code> is copied to internal structures that are subsequently returned by   {@link #getColors} and {@link #getColorIndices}, respectively.   The argument <code>indices</code> specifies an index values into <code>colors</code> for each vertex of each feature, as described for  {@link #getNormalIndices()}. If a feature vertex has no color value, the index should be specified as <code>-1</code>. If <code>indices</code> is <code>null</code>, then <code>colors</code> should contain one color per vertex and a default index set will be created, appropriate to the mesh subclass. <p>If <code>colors</code> is <code>null</code>, then colors are explicitly removed and subsequent calls to   {@link #getColors} will return <code>null</code>.<p>Each entry in <code>colors</code> should be a <code>float[]</code> of length three (or four) giving the RGB (or RGBA) values for the color in the range 0 to 1.
 * @param colors colors to be set for this mesh
 * @param indices color indices, or <code>null</code> if the indices are tobe automatically generated.
 */
public void setColors(List<float[]> colors,int[] indices){
  if (colors == null) {
    myColors=null;
    myColorIndices=null;
  }
 else {
    ArrayList<float[]> newColors=new ArrayList<float[]>(colors.size());
    for (int i=0; i < colors.size(); i++) {
      float[] c=colors.get(i);
      if (c == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + i);
      }
      if (c.length != 3 && c.length != 4) {
        throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str""+ c.length+ ""String_Node_Str"");
      }
      newColors.add(copyColor(c));
    }
    if (indices == null && colors.size() != numVertices()) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    int[] newIndices=createIndices(indices);
    myColors=newColors;
    myColorIndices=newIndices;
  }
  myVertexColoringP=false;
  myFeatureColoringP=false;
}","/** 
 * Explicitly sets the colors and associated indices for this mesh. The information supplied by <code>colors</code> and <code>indices</code> is copied to internal structures that are subsequently returned by   {@link #getColors} and {@link #getColorIndices}, respectively.   <p> Colors should be specified as <code>float[]</code> objects with a length >= 3, indicating RGG values (or RGBA values for length >= 4) in the range [0,1]. <p>The argument <code>indices</code> specifies an index values into <code>colors</code> for each vertex of each feature, as described for  {@link #getNormalIndices()}. If a feature vertex has no color value, the index should be specified as <code>-1</code>.  If <code>indices</code> is <code>null</code>, then <code>colors</code> should contain one color per vertex and a default index set will be created, appropriate to the mesh subclass. <p>If <code>colors</code> is <code>null</code>, then colors are explicitly removed and subsequent calls to   {@link #getColors} will return <code>null</code>.<p>Each entry in <code>colors</code> should be a <code>float[]</code> of length three (or four) giving the RGB (or RGBA) values for the color in the range 0 to 1.
 * @param colors colors to be set for this mesh
 * @param indices color indices, or <code>null</code> if the indices are tobe automatically generated.
 */
public void setColors(List<float[]> colors,int[] indices){
  if (colors == null) {
    myColors=null;
    myColorIndices=null;
  }
 else {
    ArrayList<float[]> newColors=new ArrayList<float[]>(colors.size());
    for (int i=0; i < colors.size(); i++) {
      float[] c=colors.get(i);
      if (c == null) {
        throw new IllegalArgumentException(""String_Node_Str"" + i);
      }
      if (c.length < 3) {
        throw new IllegalArgumentException(""String_Node_Str"" + i + ""String_Node_Str"");
      }
      newColors.add(copyColor(c));
    }
    if (indices == null && colors.size() != numVertices()) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"");
    }
    int[] newIndices=createIndices(indices);
    myColors=newColors;
    myColorIndices=newIndices;
  }
  myVertexColoringP=false;
  myFeatureColoringP=false;
}"
70906,"public void setColorsTest() throws IOException {
  PolygonalMesh mesh=createMesh(cubeObj,true);
  mesh.setVertexColoringEnabled();
  check(""String_Node_Str"",mesh.numColors() == 8);
  check(""String_Node_Str"",mesh.getVertexColoringEnabled());
  checkIndices(mesh.getColorIndices(),mesh.createVertexIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 28);
  for (int i=0; i < mesh.numColors(); i++) {
    mesh.setColor(i,cubeColors[i]);
  }
  Face f0=mesh.getFace(0);
  Face f3=mesh.getFace(3);
  Face f6=mesh.getFace(6);
  Face f4=mesh.getFace(4);
  mesh.removeFace(f0);
  mesh.removeFace(f3);
  check(""String_Node_Str"",mesh.numColors() == 8);
  checkIndices(mesh.getColorIndices(),mesh.createVertexIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 22);
  mesh.removeFace(f6);
  mesh.removeFace(f4);
  mesh.removeVertex(mesh.getVertex(5));
  check(""String_Node_Str"",mesh.numColors() == 7);
  checkColors(mesh.getColors(),createColors(new float[][]{red,green,blue,cyan,yellow,pink,grey}));
  mesh.addVertex(4,4,4);
  checkColors(mesh.getColors(),createColors(new float[][]{red,green,blue,cyan,yellow,pink,grey,grey}));
  checkIndices(mesh.getColorIndices(),mesh.createVertexIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 14);
  mesh.clearColors();
  checkColors(mesh.getColors(),null);
  mesh=createMesh(cubeObj,true);
  mesh.setFeatureColoringEnabled();
  check(""String_Node_Str"",mesh.getFeatureColoringEnabled());
  check(""String_Node_Str"",!mesh.getVertexColoringEnabled());
  check(""String_Node_Str"",mesh.numColors() == 8);
  checkIndices(mesh.getColorIndices(),mesh.createFeatureIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 28);
  for (int i=0; i < mesh.numColors(); i++) {
    mesh.setColor(i,cubeColors[i]);
  }
  f0=mesh.getFace(0);
  f3=mesh.getFace(3);
  f6=mesh.getFace(6);
  f4=mesh.getFace(4);
  mesh.removeFace(f0);
  mesh.removeFace(f3);
  check(""String_Node_Str"",mesh.numColors() == 6);
  checkIndices(mesh.getColorIndices(),mesh.createFeatureIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 22);
  mesh.removeFace(f6);
  mesh.removeFace(f4);
  mesh.removeVertex(mesh.getVertex(5));
  check(""String_Node_Str"",mesh.numColors() == 4);
  checkColors(mesh.getColors(),createColors(new float[][]{green,blue,magenta,grey}));
  mesh.addFace(new int[]{3,4,1});
  checkColors(mesh.getColors(),createColors(new float[][]{green,blue,magenta,grey,grey}));
  checkIndices(mesh.getColorIndices(),mesh.createFeatureIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 17);
}","public void setColorsTest() throws IOException {
  PolygonalMesh mesh=createMesh(cubeObj,true);
  mesh.setVertexColoringEnabled();
  check(""String_Node_Str"",mesh.numColors() == 8);
  check(""String_Node_Str"",mesh.getVertexColoringEnabled());
  checkIndices(mesh.getColorIndices(),mesh.createVertexIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 28);
  for (int i=0; i < mesh.numColors(); i++) {
    mesh.setColor(i,cubeColors[i]);
  }
  Face f0=mesh.getFace(0);
  Face f3=mesh.getFace(3);
  Face f6=mesh.getFace(6);
  Face f4=mesh.getFace(4);
  mesh.removeFace(f0);
  mesh.removeFace(f3);
  check(""String_Node_Str"",mesh.numColors() == 8);
  checkIndices(mesh.getColorIndices(),mesh.createVertexIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 22);
  mesh.removeFace(f6);
  mesh.removeFace(f4);
  mesh.removeVertex(mesh.getVertex(5));
  check(""String_Node_Str"",mesh.numColors() == 7);
  checkColors(mesh.getColors(),createColors(new float[][]{red,green,blue,cyan,yellow,pink,grey}));
  mesh.addVertex(4,4,4);
  checkColors(mesh.getColors(),createColors(new float[][]{red,green,blue,cyan,yellow,pink,grey,grey}));
  checkIndices(mesh.getColorIndices(),mesh.createVertexIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 14);
  mesh.clearColors();
  checkColors(mesh.getColors(),null);
  mesh=createMesh(cubeObj,true);
  mesh.setFeatureColoringEnabled();
  check(""String_Node_Str"",mesh.getFeatureColoringEnabled());
  check(""String_Node_Str"",!mesh.getVertexColoringEnabled());
  check(""String_Node_Str"",mesh.numColors() == 8);
  checkIndices(mesh.getColorIndices(),mesh.createFeatureIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 28);
  for (int i=0; i < mesh.numColors(); i++) {
    mesh.setColor(i,cubeColors[i]);
  }
  f0=mesh.getFace(0);
  f3=mesh.getFace(3);
  f6=mesh.getFace(6);
  f4=mesh.getFace(4);
  mesh.removeFace(f0);
  mesh.removeFace(f3);
  check(""String_Node_Str"",mesh.numColors() == 6);
  checkIndices(mesh.getColorIndices(),mesh.createFeatureIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 22);
  mesh.removeFace(f6);
  mesh.removeFace(f4);
  mesh.removeVertex(mesh.getVertex(5));
  check(""String_Node_Str"",mesh.numColors() == 4);
  checkColors(mesh.getColors(),createColors(new float[][]{green,blue,magenta,grey}));
  mesh.addFace(new int[]{3,4,1});
  checkColors(mesh.getColors(),createColors(new float[][]{green,blue,magenta,grey,grey}));
  checkIndices(mesh.getColorIndices(),mesh.createFeatureIndices());
  check(""String_Node_Str"",mesh.getColorIndices().length == 17);
  mesh.setColor(2,new float[]{1f,0f,0f,0.5f});
  checkColor(mesh.getColor(2),new float[]{1f,0f,0f,0.5f});
  mesh.setColor(2,new float[]{1f,0f,0f});
  checkColor(mesh.getColor(2),new float[]{1f,0f,0f,1f});
}"
70907,"public static void computeTriangleNormals(RenderObject r,int tgrp){
  int numt=r.numTriangles(tgrp);
  for (int i=0; i < numt; i++) {
    int[] idxs=r.getTriangle(tgrp,i);
    float[] p0=r.getVertexPosition(idxs[0]);
    float[] p1=r.getVertexPosition(idxs[1]);
    float[] p2=r.getVertexPosition(idxs[2]);
    float[] nrm=r.getVertexNormal(idxs[0]);
    float ax=p1[0] - p0[0];
    float ay=p1[1] - p0[1];
    float az=p1[2] - p0[2];
    float bx=p2[0] - p0[0];
    float by=p2[1] - p0[1];
    float bz=p2[2] - p0[2];
    float nx=ay * bz - az * by;
    float ny=az * bx - ax * bz;
    float nz=ax * by - ay * bx;
    float mag=(float)Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (mag > 0) {
      nx/=mag;
      ny/=mag;
      nz/=mag;
    }
    nrm[0]=nx;
    nrm[1]=ny;
    nrm[2]=nz;
  }
}","public static void computeTriangleNormals(RenderObject r,int tgrp){
  int numt=r.numTriangles(tgrp);
  for (int i=0; i < numt; i++) {
    int[] idxs=r.getTriangle(tgrp,i);
    float[] p0=r.getVertexPosition(idxs[0]);
    float[] p1=r.getVertexPosition(idxs[1]);
    float[] p2=r.getVertexPosition(idxs[2]);
    float[] nrm=r.getVertexNormal(idxs[0]);
    float ax=p1[0] - p0[0];
    float ay=p1[1] - p0[1];
    float az=p1[2] - p0[2];
    float bx=p2[0] - p0[0];
    float by=p2[1] - p0[1];
    float bz=p2[2] - p0[2];
    float nx=ay * bz - az * by;
    float ny=az * bx - ax * bz;
    float nz=ax * by - ay * bx;
    float mag=(float)Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (mag > 0) {
      nx/=mag;
      ny/=mag;
      nz/=mag;
    }
    nrm[0]=nx;
    nrm[1]=ny;
    nrm[2]=nz;
  }
  r.notifyNormalsModified();
}"
70908,"void render(Renderer renderer,FemElement3d elem,RenderProps props){
  RenderObject r=myRob;
  updatePositions(r,elem);
  renderer.setLightingEnabled(false);
  renderer.setLineWidth(props.getLineWidth());
  renderer.setColor(props.getLineColorArray(),elem.isSelected());
  renderer.drawLines(r);
  renderer.setLineWidth(1);
  renderer.setLightingEnabled(true);
  double s=elem.getElementWidgetSize();
  if (s > 0) {
    updateNormals(r,elem);
    if (!renderer.isSelecting()) {
      Material mat=props.getFaceMaterial();
      if (elem.isInverted()) {
        mat=FemModel3d.myInvertedMaterial;
      }
      renderer.setMaterial(mat,elem.isSelected());
    }
    if (s != 1.0) {
      float cx=0;
      float cy=0;
      float cz=0;
      FemNode[] nodes=elem.getNodes();
      int nnodes=nodes.length;
      for (int i=0; i < nnodes; i++) {
        FemNode n=nodes[i];
        cx+=n.myRenderCoords[0];
        cy+=n.myRenderCoords[1];
        cz+=n.myRenderCoords[2];
      }
      cx/=nnodes;
      cy/=nnodes;
      cz/=nnodes;
      renderer.pushModelMatrix();
      renderer.translateModelMatrix(cx * (1 - s),cy * (1 - s),cz * (1 - s));
      renderer.scaleModelMatrix(s);
      renderer.drawTriangles(r);
      renderer.popModelMatrix();
    }
 else {
      renderer.drawTriangles(r);
    }
  }
}","void render(Renderer renderer,FemElement3d elem,RenderProps props){
  RenderObject r=myRob;
  updatePositions(r,elem);
  renderer.setLightingEnabled(false);
  renderer.setLineWidth(props.getLineWidth());
  renderer.setColor(props.getLineColorArray(),elem.isSelected());
  renderer.drawLines(r);
  renderer.setLineWidth(1);
  renderer.setLightingEnabled(true);
  Shading shading=props.getShading();
  boolean restoreLighting=false;
  if (shading == Shading.NONE) {
    renderer.setLightingEnabled(false);
    restoreLighting=true;
  }
  double s=elem.getElementWidgetSize();
  if (s > 0) {
    updateNormals(r,elem);
    if (!renderer.isSelecting()) {
      Material mat=props.getFaceMaterial();
      if (elem.isInverted()) {
        mat=FemModel3d.myInvertedMaterial;
      }
      renderer.setMaterial(mat,elem.isSelected());
    }
    if (s != 1.0) {
      float cx=0;
      float cy=0;
      float cz=0;
      FemNode[] nodes=elem.getNodes();
      int nnodes=nodes.length;
      for (int i=0; i < nnodes; i++) {
        FemNode n=nodes[i];
        cx+=n.myRenderCoords[0];
        cy+=n.myRenderCoords[1];
        cz+=n.myRenderCoords[2];
      }
      cx/=nnodes;
      cy/=nnodes;
      cz/=nnodes;
      renderer.pushModelMatrix();
      renderer.translateModelMatrix(cx * (1 - s),cy * (1 - s),cz * (1 - s));
      renderer.scaleModelMatrix(s);
      renderer.drawTriangles(r);
      renderer.popModelMatrix();
    }
 else {
      renderer.drawTriangles(r);
    }
  }
  if (restoreLighting) {
    renderer.setLightingEnabled(true);
  }
}"
70909,"private static void buildVertexShaderMain(StringBuilder mb,GLSLInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb);
  appendln(mb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(mb,""String_Node_Str"");
  }
  appendln(mb);
  InstancedRendering instanced=info.getInstancedRendering();
switch (instanced) {
case AFFINES:
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
  appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case FRAMES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case LINES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
}
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case POINTS:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
ColorInterpolation cinterp=info.getColorInterpolation();
if (cinterp != ColorInterpolation.NONE) {
switch (instanced) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
}
break;
case LINES:
if (info.hasLineColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
}
break;
case NONE:
if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
}
break;
}
}
switch (info.getShading()) {
case FLAT:
case GOURAUD:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case PHONG:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
break;
}
switch (info.getInstancedRendering()) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case LINES:
if (info.hasLineTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case NONE:
if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
}
if (info.numClipPlanes() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numClipPlanes() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
appendln(mb,""String_Node_Str"");
}","private static void buildVertexShaderMain(StringBuilder mb,GLSLInfo info){
  appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
  appendln(mb);
  appendln(mb,""String_Node_Str"");
  if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
    appendln(mb,""String_Node_Str"");
  }
  appendln(mb);
  InstancedRendering instanced=info.getInstancedRendering();
switch (instanced) {
case AFFINES:
    appendln(mb,""String_Node_Str"");
  appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
  appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case FRAMES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case LINES:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasLineLengthOffset()) {
appendln(mb,""String_Node_Str"");
}
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
appendln(mb);
break;
case POINTS:
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals() && info.getShading() != Shading.NONE) {
appendln(mb,""String_Node_Str"");
}
break;
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
ColorInterpolation cinterp=info.getColorInterpolation();
if (cinterp != ColorInterpolation.NONE) {
switch (instanced) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case LINES:
if (info.hasLineColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
 else if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
case NONE:
if (info.hasVertexColors()) {
if (cinterp == ColorInterpolation.HSV) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb);
}
break;
}
}
switch (info.getShading()) {
case FLAT:
case GOURAUD:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numLights() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case PHONG:
if (info.numLights() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
if (info.hasVertexNormals()) {
appendln(mb,""String_Node_Str"");
}
 else {
appendln(mb,""String_Node_Str"");
}
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
}
break;
case NONE:
break;
}
switch (info.getInstancedRendering()) {
case POINTS:
case FRAMES:
case AFFINES:
if (info.hasInstanceTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case LINES:
if (info.hasLineTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
 else if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
case NONE:
if (info.hasVertexTextures()) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
break;
}
if (info.numClipPlanes() > 0) {
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"" + info.numClipPlanes() + ""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb,""String_Node_Str"");
appendln(mb);
}
appendln(mb,""String_Node_Str"");
}"
70910,"public static void main(String[] args){
  MultiViewer rot=new MultiViewer();
  rot.addGL2Viewer(""String_Node_Str"",30,30,640,480);
  rot.addGL3Viewer(""String_Node_Str"",670,30,640,480);
  rot.syncViews();
  addRenderObjects(rot);
  rot.setWindowSizes(640,480);
  rot.autoFitViewers();
}","public static void main(String[] args){
  GL2vsGL3Tester tester=new GL2vsGL3Tester();
  tester.run();
}"
70911,"public Object validateValue(ValueChangeEvent e,StringHolder errMsg){
  if (!attachedInputFileValid((String)e.getValue())) {
    if (errMsg != null) {
      errMsg.value=""String_Node_Str"";
    }
    return Property.IllegalValue;
  }
  if (errMsg != null) {
    errMsg.value=null;
  }
  return e.getValue();
}","public Object validateValue(ValueChangeEvent e,StringHolder errMsg){
  if (!attachedInputFileValid((String)e.getValue(),errMsg)) {
    return Property.IllegalValue;
  }
  if (errMsg != null) {
    errMsg.value=null;
  }
  return e.getValue();
}"
70912,"private boolean attachedInputFileValid(String path){
  if (path != null && !path.equals(""String_Node_Str"")) {
    if (!filePathExists(getFullPath(path))) {
      return false;
    }
  }
  return true;
}","private boolean attachedInputFileValid(String path,StringHolder errMsg){
  if (path != null && !path.equals(""String_Node_Str"")) {
    String fullPath=getFullPath(path);
    if (!filePathExists(fullPath)) {
      if (errMsg != null) {
        errMsg.value=""String_Node_Str"";
      }
      return false;
    }
 else {
      File file=new File(fullPath);
      if (file.isDirectory()) {
        if (errMsg != null) {
          errMsg.value=""String_Node_Str"";
        }
        return false;
      }
    }
  }
  return true;
}"
70913,"private void setInputProbe(){
  ArrayList<String> variableNames=new ArrayList<String>();
  ArrayList<Integer> variableDims=new ArrayList<Integer>();
  for (  Map.Entry<String,NumericProbeVariable> entry : myVariables.entrySet()) {
    variableNames.add(entry.getKey());
    variableDims.add(entry.getValue().getDimension());
    System.out.println(entry.getKey() + ""String_Node_Str"" + entry.getValue());
  }
  int[] varDimsInt=new int[variableDims.size()];
  for (int i=0; i < variableDims.size(); i++) {
    varDimsInt[i]=variableDims.get(i);
  }
  NumericInputProbe probeToSet;
  if (oldProbe == null) {
    ModelComponent refComp=ComponentUtils.getPropertyComponent(myProperties.get(0));
    probeToSet=new NumericInputProbe(refComp);
  }
 else {
    probeToSet=oldProbe;
  }
  probeToSet.set(myProperties.toArray(new Property[0]),getDriverExpressions(),variableNames.toArray(new String[0]),varDimsInt);
  probeToSet.setStartTime(startTimeField.getDoubleValue());
  probeToSet.setStopTime(endTimeField.getDoubleValue());
  probeToSet.setScale(scaleField.getDoubleValue());
  probeToSet.setName(probeNameField.getStringValue());
  String attachedFilePath=attachedFileField.getStringValue();
  if (attachedFilePath != null) {
    if (attachedFilePath.equals(""String_Node_Str"") || !attachedInputFileValid(attachedFilePath)) {
      attachedFilePath=null;
    }
  }
  if (attachedFilePath != null) {
    probeToSet.setAttachedFileName(attachedFilePath);
    try {
      probeToSet.load();
      ((Displayable)probeToSet).updateDisplays();
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      probeToSet.setAttachedFileName(null);
    }
  }
 else {
    probeToSet.setAttachedFileName(null);
    if (probeToSet.getNumericList().isEmpty()) {
      if (probeToSet.isSettable()) {
        probeToSet.setData(probeToSet.getStartTime());
        probeToSet.setData(probeToSet.getStopTime());
      }
 else {
        probeToSet.loadEmpty();
      }
    }
  }
  if (oldProbe == null) {
    AddComponentsCommand cmd=new AddComponentsCommand(""String_Node_Str"",probeToSet,myMain.getRootModel().getInputProbes());
    myMain.getUndoManager().saveStateAndExecute(cmd);
  }
}","private void setInputProbe(){
  ArrayList<String> variableNames=new ArrayList<String>();
  ArrayList<Integer> variableDims=new ArrayList<Integer>();
  for (  Map.Entry<String,NumericProbeVariable> entry : myVariables.entrySet()) {
    variableNames.add(entry.getKey());
    variableDims.add(entry.getValue().getDimension());
    System.out.println(entry.getKey() + ""String_Node_Str"" + entry.getValue());
  }
  int[] varDimsInt=new int[variableDims.size()];
  for (int i=0; i < variableDims.size(); i++) {
    varDimsInt[i]=variableDims.get(i);
  }
  NumericInputProbe probeToSet;
  if (oldProbe == null) {
    ModelComponent refComp=ComponentUtils.getPropertyComponent(myProperties.get(0));
    probeToSet=new NumericInputProbe(refComp);
  }
 else {
    probeToSet=oldProbe;
  }
  probeToSet.set(myProperties.toArray(new Property[0]),getDriverExpressions(),variableNames.toArray(new String[0]),varDimsInt);
  probeToSet.setStartTime(startTimeField.getDoubleValue());
  probeToSet.setStopTime(endTimeField.getDoubleValue());
  probeToSet.setScale(scaleField.getDoubleValue());
  probeToSet.setName(probeNameField.getStringValue());
  String attachedFilePath=attachedFileField.getStringValue();
  if (attachedFilePath != null) {
    if (attachedFilePath.equals(""String_Node_Str"") || !attachedInputFileValid(attachedFilePath,null)) {
      attachedFilePath=null;
    }
  }
  if (attachedFilePath != null) {
    probeToSet.setAttachedFileName(attachedFilePath);
    try {
      probeToSet.load();
      ((Displayable)probeToSet).updateDisplays();
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      probeToSet.setAttachedFileName(null);
    }
  }
 else {
    probeToSet.setAttachedFileName(null);
    if (probeToSet.getNumericList().isEmpty()) {
      if (probeToSet.isSettable()) {
        probeToSet.setData(probeToSet.getStartTime());
        probeToSet.setData(probeToSet.getStopTime());
      }
 else {
        probeToSet.loadEmpty();
      }
    }
  }
  if (oldProbe == null) {
    AddComponentsCommand cmd=new AddComponentsCommand(""String_Node_Str"",probeToSet,myMain.getRootModel().getInputProbes());
    myMain.getUndoManager().saveStateAndExecute(cmd);
  }
}"
70914,"/** 
 * returns the full path according to a relative path and the working directory
 * @param relativePath relative path
 * @return full path
 */
protected String getFullPath(String relativePath){
  return ArtisynthPath.getWorkingDirPath() + File.separator + relativePath;
}","/** 
 * returns the full path according to a relative path and the working directory
 * @param relativePath relative path
 * @return full path
 */
protected String getFullPath(String relativePath){
  File f=new File(relativePath);
  if (f.isAbsolute()) {
    return f.getAbsolutePath();
  }
  return ArtisynthPath.getWorkingDirPath() + File.separator + relativePath;
}"
70915,"private boolean attachedOutputFileValid(String path){
  if (path != null && !path.equals(""String_Node_Str"")) {
    if (!filePathExists(getFullPath(path))) {
      File file=new File(getFullPath(path));
      File dir=file.getParentFile();
      if (dir == null || !dir.isDirectory()) {
        return false;
      }
    }
  }
  return true;
}","private boolean attachedOutputFileValid(String path,StringHolder errMsg){
  if (path != null && !path.equals(""String_Node_Str"")) {
    String fullPath=getFullPath(path);
    if (!filePathExists(fullPath)) {
      File file=new File(fullPath);
      if (file.isDirectory()) {
        if (errMsg != null) {
          errMsg.value=""String_Node_Str"";
        }
        return false;
      }
      File dir=file.getParentFile();
      if (dir == null || !dir.isDirectory()) {
        if (errMsg != null) {
          errMsg.value=""String_Node_Str"";
        }
        return false;
      }
    }
  }
  return true;
}"
70916,"public Object validateValue(ValueChangeEvent e,StringHolder errMsg){
  if (!attachedOutputFileValid((String)e.getValue())) {
    if (errMsg != null) {
      errMsg.value=""String_Node_Str"";
    }
    return Property.IllegalValue;
  }
  if (errMsg != null) {
    errMsg.value=null;
  }
  return e.getValue();
}","public Object validateValue(ValueChangeEvent e,StringHolder errMsg){
  if (!attachedOutputFileValid((String)e.getValue(),errMsg)) {
    return Property.IllegalValue;
  }
  if (errMsg != null) {
    errMsg.value=null;
  }
  return e.getValue();
}"
70917,"public void valueChange(ValueChangeEvent v){
  if (v.getSource() == attachedFileField) {
    String newPath=attachedFileField.getStringValue();
    if (newPath == originalFilePath) {
      return;
    }
    originalFilePath=newPath;
    String fullPath=ArtisynthPath.getWorkingDirPath() + File.separator + newPath;
    File tmpFile=new File(fullPath);
    if (tmpFile.exists()) {
    }
 else {
      if (tmpFile.getParentFile().exists()) {
        try {
          boolean ok=tmpFile.createNewFile();
        }
 catch (        Exception e) {
          System.out.println(e.getMessage());
        }
      }
 else {
        if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
          System.out.println(""String_Node_Str"");
          tmpFile.getParentFile().mkdirs();
          try {
            tmpFile.createNewFile();
          }
 catch (          Exception e) {
            System.out.println(e.getMessage());
          }
        }
      }
    }
  }
}","public void valueChange(ValueChangeEvent v){
  if (v.getSource() == attachedFileField) {
    String newPath=attachedFileField.getStringValue();
    if (newPath == originalFilePath) {
      return;
    }
    File newFile=new File(newPath);
    originalFilePath=newPath;
    String fullPath=newPath;
    if (!newFile.isAbsolute()) {
      fullPath=ArtisynthPath.getWorkingDirPath() + File.separator + newPath;
    }
    File tmpFile=new File(fullPath);
    if (tmpFile.exists()) {
      if (tmpFile.isDirectory()) {
      }
    }
 else {
      if (tmpFile.getParentFile().exists()) {
        try {
          boolean ok=tmpFile.createNewFile();
        }
 catch (        Exception e) {
          System.out.println(e.getMessage());
        }
      }
 else {
        if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.OK_CANCEL_OPTION) == JOptionPane.OK_OPTION) {
          System.out.println(""String_Node_Str"");
          tmpFile.getParentFile().mkdirs();
          try {
            tmpFile.createNewFile();
          }
 catch (          Exception e) {
            System.out.println(e.getMessage());
          }
        }
      }
    }
  }
}"
70918,"/** 
 * Override to account for property selector
 */
protected void updateDisplay(boolean forceUpdate){
  String[] newText=null;
  Object value=getInternalValue();
  BooleanHolder corrected=new BooleanHolder();
  if (value == Property.VoidValue) {
    newText=new String[]{""String_Node_Str"",""String_Node_Str""};
  }
 else {
    Object textValue=textToValue(getText(),corrected,null);
    if (forceUpdate || textValue == Property.IllegalValue || corrected.value || !valuesEqual(textValue,value)) {
      newText=valueToTextArray(value);
    }
  }
  if (newText != null) {
    myLastText=newText[0];
    myTextField.setText(newText[0]);
    if (myPropertySelector != null) {
      myLastPropName=newText[1];
      if (""String_Node_Str"".equals(newText[1])) {
        myPropertySelector.setValue(nullString);
      }
 else {
        myPropertySelector.setValue(newText[1]);
      }
    }
 else {
      if (newText[1] != null && !""String_Node_Str"".equals(newText[1])) {
        myLastText=newText[0] + ""String_Node_Str"" + newText[1];
        myTextField.setText(myLastText);
      }
    }
  }
 else {
    myLastText=myTextField.getText();
    if (myPropertySelector != null) {
      String propValue=(String)(myPropertySelector.getValue());
      myLastPropName=propValue;
    }
  }
  setReverseTextBackground(false);
}","/** 
 * Override to account for property selector
 */
protected void updateDisplay(boolean forceUpdate){
  String[] newText=null;
  Object value=getInternalValue();
  BooleanHolder corrected=new BooleanHolder();
  if (value == Property.VoidValue) {
    newText=new String[]{""String_Node_Str"",""String_Node_Str""};
  }
 else {
    Object textValue=textToValue(getText(),corrected,null);
    if (forceUpdate || textValue == Property.IllegalValue || corrected.value || !valuesEqual(textValue,value)) {
      newText=valueToTextArray(value);
    }
  }
  if (newText != null) {
    myLastText=newText[0];
    myTextField.setText(newText[0]);
    if (myPropertiesAllowed) {
      myPropertyMask=true;
      myLastPropName=newText[1];
      if (""String_Node_Str"".equals(newText[1])) {
        myPropertySelector.setValue(nullString);
      }
 else {
        myPropertySelector.setValue(newText[1]);
      }
      myPropertyMask=false;
    }
 else {
      if (newText[1] != null && !""String_Node_Str"".equals(newText[1])) {
        myLastText=newText[0] + ""String_Node_Str"" + newText[1];
        myTextField.setText(myLastText);
      }
    }
  }
 else {
    myLastText=myTextField.getText();
    if (myPropertySelector != null) {
      String propValue=(String)(myPropertySelector.getValue());
      myLastPropName=propValue;
    }
  }
  setReverseTextBackground(false);
}"
70919,"private void setValueFromPropertySelector(){
  String propName=(String)myPropertySelector.getValue();
  HasProperties host=getHost();
  if (propName.equals(nullString)) {
    Object value=getValueForHost();
    System.out.println(""String_Node_Str"");
    updateValueAndDisplay(value);
    return;
  }
  if (host == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
  Property prop=host.getProperty(propName);
  if (prop == null) {
    throw new InternalErrorException(""String_Node_Str"" + propName);
  }
  updateValueAndDisplay(prop);
}","private void setValueFromPropertySelector(){
  if (!myPropertyMask) {
    String propName=(String)myPropertySelector.getValue();
    HasProperties host=getHost();
    if (propName.equals(nullString)) {
      Object value=getValueForHost();
      System.out.println(""String_Node_Str"");
      updateValueAndDisplay(value);
      return;
    }
    if (host == null) {
      throw new InternalErrorException(""String_Node_Str"");
    }
    Property prop=host.getProperty(propName);
    if (prop == null) {
      throw new InternalErrorException(""String_Node_Str"" + propName);
    }
    updateValueAndDisplay(prop);
  }
}"
70920,"protected String valueToText(Object value){
  ModelComponent comp=getComponent(value);
  RootModel root=myMain.getRootModel();
  if (root == null || comp == null) {
    return ""String_Node_Str"";
  }
  if (value instanceof ModelComponent) {
    return ComponentUtils.getPathName(root,comp);
  }
 else   if (value instanceof Property) {
    Property prop=(Property)value;
    boolean excludeLeaf=(myPropertySelector != null && !(prop.get() instanceof CompositeProperty));
    String path=ComponentUtils.getPropertyPathName(prop,root,excludeLeaf);
    if (!path.contains(""String_Node_Str"")) {
      path=""String_Node_Str"" + path;
    }
    return path;
  }
 else {
    throw new InternalErrorException(""String_Node_Str"" + value.getClass());
  }
}","protected String valueToText(Object value){
  ModelComponent comp=getComponent(value);
  RootModel root=myMain.getRootModel();
  if (root == null || comp == null) {
    return ""String_Node_Str"";
  }
  if (value instanceof ModelComponent) {
    return ComponentUtils.getPathName(root,comp);
  }
 else   if (value instanceof Property) {
    Property prop=(Property)value;
    boolean excludeLeaf=(myPropertySelector != null && !(prop.get() instanceof CompositeProperty));
    String path=ComponentUtils.getPropertyPathName(prop,root,false);
    if (!path.contains(""String_Node_Str"")) {
      path=""String_Node_Str"" + path;
    }
    return path;
  }
 else {
    throw new InternalErrorException(""String_Node_Str"" + value.getClass());
  }
}"
70921,"protected String[] valueToTextArray(Object value){
  ModelComponent comp=getComponent(value);
  RootModel root=myMain.getRootModel();
  String compStr=""String_Node_Str"";
  String propStr=""String_Node_Str"";
  if (root == null || comp == null) {
    return new String[]{""String_Node_Str"",""String_Node_Str""};
  }
  if (value instanceof ModelComponent) {
    compStr=ComponentUtils.getPathName(root,comp);
  }
 else   if (value instanceof Property) {
    Property prop=(Property)value;
    boolean excludeLeaf=(myPropertySelector != null && !(prop.get() instanceof CompositeProperty));
    String path=ComponentUtils.getPropertyPathName(prop,root,excludeLeaf);
    int idx=path.indexOf(':');
    propStr=path;
    if (idx >= 0) {
      compStr=path.substring(0,idx);
      if (idx < path.length() - 1) {
        propStr=path.substring(idx + 1);
      }
    }
  }
 else {
    throw new InternalErrorException(""String_Node_Str"" + value.getClass());
  }
  return new String[]{compStr,propStr};
}","protected String[] valueToTextArray(Object value){
  ModelComponent comp=getComponent(value);
  RootModel root=myMain.getRootModel();
  String compStr=""String_Node_Str"";
  String propStr=""String_Node_Str"";
  if (root == null || comp == null) {
    return new String[]{""String_Node_Str"",""String_Node_Str""};
  }
  if (value instanceof ModelComponent) {
    compStr=ComponentUtils.getPathName(root,comp);
  }
 else   if (value instanceof Property) {
    Property prop=(Property)value;
    boolean excludeLeaf=(myPropertySelector != null && !(prop.get() instanceof CompositeProperty));
    String path=ComponentUtils.getPropertyPathName(prop,root,false);
    int idx=path.indexOf(':');
    propStr=path;
    if (idx >= 0) {
      compStr=path.substring(0,idx);
      if (idx < path.length() - 1) {
        propStr=path.substring(idx + 1);
      }
    }
  }
 else {
    throw new InternalErrorException(""String_Node_Str"" + value.getClass());
  }
  return new String[]{compStr,propStr};
}"
70922,"private void setValueFromDisplay(){
  if (myAlwaysParseText || !myLastText.equals(myTextField.getText())) {
    StringHolder errMsg=new StringHolder();
    BooleanHolder corrected=new BooleanHolder();
    Object value=textToValue(myTextField.getText(),corrected,errMsg);
    if (value != Property.IllegalValue) {
      value=validateValue(value,errMsg);
    }
    if (value == Property.IllegalValue) {
      focusListenerMasked=true;
      JOptionPane.showMessageDialog(LabeledTextField.this,errMsg.value,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      focusListenerMasked=false;
      myTextField.setText(myLastText);
      updateDisplay();
      myLastEntryAccepted=false;
      return;
    }
    updateValue(value);
    updateDisplay();
  }
 else {
    setReverseTextBackground(false);
  }
  myLastEntryAccepted=true;
}","protected void setValueFromDisplay(){
  if (myAlwaysParseText || !myLastText.equals(myTextField.getText())) {
    StringHolder errMsg=new StringHolder();
    BooleanHolder corrected=new BooleanHolder();
    Object value=textToValue(myTextField.getText(),corrected,errMsg);
    if (value != Property.IllegalValue) {
      value=validateValue(value,errMsg);
    }
    if (value == Property.IllegalValue) {
      focusListenerMasked=true;
      JOptionPane.showMessageDialog(LabeledTextField.this,errMsg.value,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      focusListenerMasked=false;
      myTextField.setText(myLastText);
      updateDisplay();
      myLastEntryAccepted=false;
      return;
    }
    updateValue(value);
    updateDisplay();
  }
 else {
    setReverseTextBackground(false);
  }
  myLastEntryAccepted=true;
}"
70923,"@Override public int hashCode(){
  return mesh.hashCode() + version + style.hashCode() * 17 + sphereDL * 7 + Double.hashCode(r) * 83 + shading.hashCode() * 41 + (useVertexColors ? 11 : 17) + (useTextures ? 19 : 23);
}","@Override public int hashCode(){
  return mesh.hashCode() + version + style.hashCode() * 17 + sphereDL * 7 + GLSupport.hashCode(r) * 83 + shading.hashCode() * 41 + (useVertexColors ? 11 : 17) + (useTextures ? 19 : 23);
}"
70924,"@Override public int hashCode(){
  return mesh.hashCode() + version + style.hashCode() * 17 + +slices * 3 + Double.hashCode(r) * 83 + shading.hashCode() * 41 + (useVertexColors ? 11 : 17) + (useTextures ? 19 : 23);
}","@Override public int hashCode(){
  return mesh.hashCode() + version + style.hashCode() * 17 + +slices * 3 + GLSupport.hashCode(r) * 83 + shading.hashCode() * 41 + (useVertexColors ? 11 : 17) + (useTextures ? 19 : 23);
}"
70925,"public void getCurrentVel(Vector3d vel,Vector3d dvel){
  if (myNodes != null) {
    double[] coords=myCoords.getBuffer();
    vel.setZero();
    for (int i=0; i < myNodes.length; i++) {
      vel.scaledAdd(coords[i],myNodes[i].getPosition(),vel);
    }
    if (dvel != null) {
      computeVelDerivative(dvel);
    }
  }
 else {
    vel.setZero();
    if (dvel != null) {
      dvel.setZero();
    }
  }
}","public void getCurrentVel(Vector3d vel,Vector3d dvel){
  if (myNodes != null) {
    double[] coords=myCoords.getBuffer();
    vel.setZero();
    for (int i=0; i < myNodes.length; i++) {
      vel.scaledAdd(coords[i],myNodes[i].getVelocity(),vel);
    }
    if (dvel != null) {
      computeVelDerivative(dvel);
    }
  }
 else {
    vel.setZero();
    if (dvel != null) {
      dvel.setZero();
    }
  }
}"
70926,"private void clearAll(GL3 gl){
  dynamicMask=0;
  dynamicVertexSize=0;
  staticMask=0;
  staticVertexSize=0;
  nVertices=0;
  positionInfo=null;
  normalInfo=null;
  colorInfo=null;
  textureInfo=null;
  lineInfo=null;
  headInfo=null;
  if (lglos != null) {
    for (    GL3Object glo : lglos) {
      glo.release(gl);
    }
  }
  lglos=null;
  if (hglos != null) {
    for (    GL3Object glo : hglos) {
      glo.release(gl);
    }
  }
  hglos=null;
  gloInfo=null;
  if (vbos != null) {
    for (    BufferObject vbo : vbos) {
      vbo.release(gl);
    }
  }
  vbos=null;
  positionPutter=null;
  normalPutter=null;
  colorPutter=null;
  texturePutter=null;
  lastVersionInfo=null;
  lastLineObject=null;
  lastLineRadius=-1;
  lastHeadObject=null;
  lastHeadRadius=-1;
  lastHeadLength=-1;
}","private void clearAll(GL3 gl){
  dynamicMask=0;
  dynamicVertexSize=0;
  staticMask=0;
  staticVertexSize=0;
  nVertices=0;
  positionInfo=null;
  normalInfo=null;
  colorInfo=null;
  textureInfo=null;
  lineInfo=null;
  headInfo=null;
  lineGroupOffsets=null;
  if (lglos != null) {
    for (    GL3Object glo : lglos) {
      glo.release(gl);
    }
  }
  lglos=null;
  if (hglos != null) {
    for (    GL3Object glo : hglos) {
      glo.release(gl);
    }
  }
  hglos=null;
  gloInfo=null;
  if (vbos != null) {
    for (    BufferObject vbo : vbos) {
      vbo.release(gl);
    }
  }
  vbos=null;
  positionPutter=null;
  normalPutter=null;
  colorPutter=null;
  texturePutter=null;
  lastVersionInfo=null;
  lastLineObject=null;
  lastLineRadius=-1;
  lastHeadObject=null;
  lastHeadRadius=-1;
  lastHeadLength=-1;
}"
70927,"public GL3RenderObjectLines(RenderObject r){
  this.roId=r.getIdentifier();
  this.roState=r.getStateInfo();
  vbos=null;
  lglos=null;
  hglos=null;
  gloInfo=null;
  positionInfo=null;
  normalInfo=null;
  colorInfo=null;
  textureInfo=null;
  lastVersionInfo=null;
  lastLineObject=null;
  lastLineRadius=-1;
  lastHeadObject=null;
  lastHeadRadius=-1;
  lastHeadLength=-1;
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  nVertices=0;
}","public GL3RenderObjectLines(RenderObject r){
  this.roId=r.getIdentifier();
  this.roState=r.getStateInfo();
  vbos=null;
  lglos=null;
  hglos=null;
  gloInfo=null;
  positionInfo=null;
  normalInfo=null;
  colorInfo=null;
  textureInfo=null;
  lineGroupOffsets=null;
  lastVersionInfo=null;
  lastLineObject=null;
  lastLineRadius=-1;
  lastHeadObject=null;
  lastHeadRadius=-1;
  lastHeadLength=-1;
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  nVertices=0;
}"
70928,"private GL3Object buildObjectGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,AttributeInfo[] radiusLengthInfo,GL3Object object,boolean hasLengthOffset){
  GL3VertexAttributeArray[] pattribs=object.getGL3VertexAttributes();
  int nattribs=pattribs.length;
  nattribs++;
  if (hasLengthOffset) {
    nattribs++;
  }
  if (pidx >= 0) {
    nattribs+=2;
  }
  if (cidx >= 0) {
    nattribs+=2;
  }
  if (tidx >= 0) {
    tidx+=2;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  for (int i=0; i < pattribs.length; ++i) {
    attribs[i]=pattribs[i];
  }
  int aidx=pattribs.length;
  attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[0].vboIndex],GL3VertexAttribute.LINE_RADIUS,GL.GL_FLOAT,1,false,radiusLengthInfo[0].offset,radiusLengthInfo[0].stride,radiusLengthInfo[0].count,robj.numLines(oidx));
  if (hasLengthOffset) {
    attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[1].vboIndex],GL3VertexAttribute.LINE_LENGTH_OFFSET,GL.GL_FLOAT,4,false,radiusLengthInfo[1].offset,radiusLengthInfo[1].stride,radiusLengthInfo[1].count,robj.numLines(oidx));
  }
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),pinfo.offset,2 * pinfo.stride,pinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),pinfo.offset + pinfo.stride,2 * pinfo.stride,pinfo.count / 2,1);
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),cinfo.offset,2 * cinfo.stride,cinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),cinfo.offset + cinfo.stride,2 * cinfo.stride,cinfo.count / 2,1);
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),tinfo.offset,2 * tinfo.stride,tinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),tinfo.offset + tinfo.stride,2 * tinfo.stride,tinfo.count / 2,1);
  }
  GL3Object glo=new GL3Object(gl,attribs,object.getGL3ElementAttribute());
  glo.setDrawInfo(object.getStart(),object.getCount(),object.getMode(),robj.numLines(oidx));
  return glo;
}","private GL3Object buildObjectGLO(GL3 gl,RenderObject robj,int pidx,int nidx,int cidx,int tidx,int oidx,AttributeInfo[] radiusLengthInfo,GL3Object object,boolean hasLengthOffset){
  GL3VertexAttributeArray[] pattribs=object.getGL3VertexAttributes();
  int nattribs=pattribs.length;
  nattribs++;
  if (hasLengthOffset) {
    nattribs++;
  }
  if (pidx >= 0) {
    nattribs+=2;
  }
  if (cidx >= 0) {
    nattribs+=2;
  }
  if (tidx >= 0) {
    tidx+=2;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  for (int i=0; i < pattribs.length; ++i) {
    attribs[i]=pattribs[i];
  }
  int aidx=pattribs.length;
  attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[0].vboIndex],GL3VertexAttribute.LINE_RADIUS,GL.GL_FLOAT,1,false,radiusLengthInfo[0].offset,radiusLengthInfo[0].stride,radiusLengthInfo[0].count,robj.numLines(oidx));
  if (hasLengthOffset) {
    attribs[aidx++]=new GL3VertexAttributeArray(vbos[radiusLengthInfo[1].vboIndex],GL3VertexAttribute.LINE_LENGTH_OFFSET,GL.GL_FLOAT,4,false,radiusLengthInfo[1].offset,radiusLengthInfo[1].stride,radiusLengthInfo[1].count,robj.numLines(oidx));
  }
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + lineGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * pinfo.stride,pinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + pinfo.stride,2 * pinfo.stride,pinfo.count / 2,1);
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + lineGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * cinfo.stride,cinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + cinfo.stride,2 * cinfo.stride,cinfo.count / 2,1);
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + lineGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_BOTTOM_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,2 * tinfo.stride,tinfo.count / 2,1);
    attribs[aidx++]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.LINE_TOP_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset + tinfo.stride,2 * tinfo.stride,tinfo.count / 2,1);
  }
  GL3Object glo=new GL3Object(gl,attribs,object.getGL3ElementAttribute());
  glo.setDrawInfo(object.getStart(),object.getCount(),object.getMode(),robj.numLines(oidx));
  return glo;
}"
70929,"private void createVBOs(GL3 gl,RenderObject robj,GL3Object lineObject,float lineRadius,GL3Object headObject,float headRadius,float headLength){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  lineInfo=createAttributeInfoArrays(2);
  headInfo=createAttributeInfoArrays(2);
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numLinesTotal=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    numLinesTotal+=robj.numLines(lg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * 2* numLinesTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * 2* numLinesTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * 2* numLinesTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * 2* numLinesTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=2 * numLinesTotal;
    }
  }
  int vboIdx=0;
  if (staticVertexSize > 0) {
    vboIdx++;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=vboIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=0;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=vboIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=0;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=vboIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=0;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=vboIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=0;
    }
  }
  if (!streaming && robj.isDynamic()) {
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  lineInfo[0].offset=0;
  lineInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[0].count=1;
  lineInfo[0].vboIndex=vboIdx;
  lineInfo[1].offset=1 * GLSupport.FLOAT_SIZE;
  lineInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[1].count=1;
  lineInfo[1].vboIndex=vboIdx;
  headInfo[0].offset=5 * GLSupport.FLOAT_SIZE;
  headInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[0].count=1;
  headInfo[0].vboIndex=vboIdx;
  headInfo[1].offset=6 * GLSupport.FLOAT_SIZE;
  headInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[1].count=1;
  headInfo[1].vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numPositionSets() - 1)* POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numNormalSets() - 1)* NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numColorSets() - 1)* COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numTextureCoordSets() - 1)* TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    List<int[]> lines=robj.getLines(lg);
    for (    int[] line : lines) {
      for (int j=0; j < 2; ++j) {
        VertexIndexSet v=robj.getVertex(line[j]);
        for (int i=0; i < positionInfo.length; ++i) {
          AttributeInfo ai=positionInfo[i];
          float[] pos=robj.getPosition(i,v.getPositionIndex());
          positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        for (int i=0; i < normalInfo.length; ++i) {
          AttributeInfo ai=normalInfo[i];
          float[] nrm=robj.getNormal(i,v.getNormalIndex());
          normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
        }
        for (int i=0; i < colorInfo.length; ++i) {
          AttributeInfo ai=colorInfo[i];
          byte[] color=robj.getColor(i,v.getColorIndex());
          colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
        }
        for (int i=0; i < textureInfo.length; ++i) {
          AttributeInfo ai=textureInfo[i];
          float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
          texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        vidx++;
      }
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(10 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(lineRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}","private void createVBOs(GL3 gl,RenderObject robj,GL3Object lineObject,float lineRadius,GL3Object headObject,float headRadius,float headLength){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  lineGroupOffsets=new int[robj.numLineGroups()];
  lineInfo=createAttributeInfoArrays(2);
  headInfo=createAttributeInfoArrays(2);
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numLinesTotal=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    lineGroupOffsets[lg]=numLinesTotal;
    numLinesTotal+=robj.numLines(lg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * 2* numLinesTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * 2* numLinesTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * 2* numLinesTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * 2* numLinesTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=2 * numLinesTotal;
    }
  }
  int staticVBOIdx=0;
  int dynamicVBOIdx=0;
  if (staticVertexSize > 0 && dynamicVertexSize > 0) {
    dynamicVBOIdx=1;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=staticVBOIdx;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=dynamicVBOIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=staticVBOIdx;
    }
  }
  int vboIdx=dynamicVBOIdx + 1;
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  lineInfo[0].offset=0;
  lineInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[0].count=1;
  lineInfo[0].vboIndex=vboIdx;
  lineInfo[1].offset=1 * GLSupport.FLOAT_SIZE;
  lineInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[1].count=1;
  lineInfo[1].vboIndex=vboIdx;
  headInfo[0].offset=5 * GLSupport.FLOAT_SIZE;
  headInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[0].count=1;
  headInfo[0].vboIndex=vboIdx;
  headInfo[1].offset=6 * GLSupport.FLOAT_SIZE;
  headInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[1].count=1;
  headInfo[1].vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numPositionSets() - 1)* POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numNormalSets() - 1)* NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numColorSets() - 1)* COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numTextureCoordSets() - 1)* TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    List<int[]> lines=robj.getLines(lg);
    for (    int[] line : lines) {
      for (int j=0; j < 2; ++j) {
        VertexIndexSet v=robj.getVertex(line[j]);
        for (int i=0; i < positionInfo.length; ++i) {
          AttributeInfo ai=positionInfo[i];
          float[] pos=robj.getPosition(i,v.getPositionIndex());
          positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        for (int i=0; i < normalInfo.length; ++i) {
          AttributeInfo ai=normalInfo[i];
          float[] nrm=robj.getNormal(i,v.getNormalIndex());
          normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
        }
        for (int i=0; i < colorInfo.length; ++i) {
          AttributeInfo ai=colorInfo[i];
          byte[] color=robj.getColor(i,v.getColorIndex());
          colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
        }
        for (int i=0; i < textureInfo.length; ++i) {
          AttributeInfo ai=textureInfo[i];
          float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
          texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        vidx++;
      }
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(10 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(lineRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}"
70930,"private GL3Object buildLineGLO(GL3 gl,int pidx,int nidx,int cidx,int tidx,int oidx){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),pinfo.offset,pinfo.stride,pinfo.count);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),ninfo.offset,ninfo.stride,ninfo.count);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),cinfo.offset,cinfo.stride,cinfo.count);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),tinfo.offset,tinfo.stride,tinfo.count);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,null,GL.GL_LINES);
  return glo;
}","private GL3Object buildLineGLO(GL3 gl,int pidx,int nidx,int cidx,int tidx,int oidx){
  int nattribs=0;
  if (pidx >= 0) {
    nattribs++;
  }
  if (nidx >= 0) {
    nattribs++;
  }
  if (cidx >= 0) {
    nattribs++;
  }
  if (tidx >= 0) {
    tidx++;
  }
  GL3VertexAttributeArray[] attribs=new GL3VertexAttributeArray[nattribs];
  int aidx=0;
  if (pidx >= 0) {
    AttributeInfo pinfo=positionInfo[pidx];
    BufferObject vbo=vbos[pinfo.vboIndex];
    BufferStorage bs=positionPutter.storage();
    int offset=pinfo.offset + lineGroupOffsets[oidx] * pinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_POSITION,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,pinfo.stride,pinfo.count);
    aidx++;
  }
  if (nidx >= 0) {
    AttributeInfo ninfo=normalInfo[nidx];
    BufferObject vbo=vbos[ninfo.vboIndex];
    BufferStorage bs=normalPutter.storage();
    int offset=ninfo.offset + lineGroupOffsets[oidx] * ninfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_NORMAL,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,ninfo.stride,ninfo.count);
    aidx++;
  }
  if (cidx >= 0) {
    AttributeInfo cinfo=colorInfo[cidx];
    BufferObject vbo=vbos[cinfo.vboIndex];
    BufferStorage bs=colorPutter.storage();
    int offset=cinfo.offset + lineGroupOffsets[oidx] * cinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_COLOR,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,cinfo.stride,cinfo.count);
    aidx++;
  }
  if (tidx >= 0) {
    AttributeInfo tinfo=textureInfo[tidx];
    BufferObject vbo=vbos[tinfo.vboIndex];
    BufferStorage bs=texturePutter.storage();
    int offset=tinfo.offset + lineGroupOffsets[oidx] * tinfo.stride;
    attribs[aidx]=new GL3VertexAttributeArray(vbo,GL3VertexAttribute.VERTEX_TEXTURE,GL3Util.getGLType(bs.type()),bs.size(),bs.isNormalized(),offset,tinfo.stride,tinfo.count);
    aidx++;
  }
  GL3Object glo=new GL3Object(gl,attribs,null,GL.GL_LINES);
  return glo;
}"
70931,"public int add1DFrictionConstraints(SparseBlockMatrix DT,FrictionInfo[] finfo,double mu,int numf){
  Vector3d dir=new Vector3d();
  if (myMasters.size() > 0 && computeFrictionDir(dir) > 0) {
    finfo[numf].mu=mu;
    finfo[numf].contactIdx0=mySolveIndex;
    finfo[numf].contactIdx1=-1;
    finfo[numf].flags=FrictionInfo.BILATERAL;
    for (int i=0; i < myMasters.size(); i++) {
      ContactMaster cm=myMasters.get(i);
      int bi=cm.getSolveIndex();
      if (bi != -1) {
        MatrixBlock blk=cm.get1DFrictionBlock(dir);
        Vector3d tmp=new Vector3d();
        tmp.x=blk.get(0,0);
        tmp.y=blk.get(1,0);
        tmp.z=blk.get(2,0);
        DT.addBlock(bi,numf,blk);
      }
    }
    numf++;
  }
  return numf;
}","public int add1DFrictionConstraints(SparseBlockMatrix DT,FrictionInfo[] finfo,double mu,int numf){
  Vector3d dir=new Vector3d();
  if (myMasters.size() > 0 && computeFrictionDir(dir) > 0 && mu > 0) {
    finfo[numf].mu=mu;
    finfo[numf].contactIdx0=mySolveIndex;
    finfo[numf].contactIdx1=-1;
    finfo[numf].flags=FrictionInfo.BILATERAL;
    for (int i=0; i < myMasters.size(); i++) {
      ContactMaster cm=myMasters.get(i);
      int bi=cm.getSolveIndex();
      if (bi != -1) {
        MatrixBlock blk=cm.get1DFrictionBlock(dir);
        Vector3d tmp=new Vector3d();
        tmp.x=blk.get(0,0);
        tmp.y=blk.get(1,0);
        tmp.z=blk.get(2,0);
        DT.addBlock(bi,numf,blk);
      }
    }
    numf++;
  }
  return numf;
}"
70932,"protected void projectFrictionConstraints(VectorNd vel,double t0){
  updateFrictionConstraints();
  myRBSolver.updateStructure(myMass,myGT);
  myRBSolver.projectFriction(myMass,myGT,myNT,myDT,myRg,myBg,myRn,myBn,myBd,myFrictionInfo,vel,myLam,myThe,myPhi);
  int[] RBDTmap=myRBSolver.getDTMap();
  if (RBDTmap != null) {
    int[] DTmap=new int[myDT.numBlockCols() - RBDTmap.length];
    int i=0;
    int k=0;
    for (int bj=0; bj < myDT.numBlockCols(); bj++) {
      if (k < RBDTmap.length && RBDTmap[k] == bj) {
        k++;
      }
 else {
        DTmap[i++]=bj;
      }
    }
    if (i != DTmap.length) {
      throw new InternalErrorException(""String_Node_Str"");
    }
    updateInverseMassMatrix(t0);
    for (i=0; i < DTmap.length; i++) {
      FrictionInfo info=myFrictionInfo[DTmap[i]];
      double phiMax;
      if ((info.flags & FrictionInfo.BILATERAL) != 0) {
        phiMax=info.getMaxFriction(myLam);
      }
 else {
        phiMax=info.getMaxFriction(myThe);
      }
      int bj=DTmap[i];
      int j=myDT.getBlockColOffset(bj);
      double doff=myBd.get(j);
      double phi=projectSingleFrictionConstraint(vel,myDT,bj,phiMax,doff,true);
      myPhi.set(j,phi);
    }
  }
  if (myUpdateForcesAtStepEnd) {
    int velSize=myActiveVelSize;
    if (myDsize > 0) {
      myDT.mulAdd(myFcon,myPhi,velSize,myDsize);
    }
  }
}","protected void projectFrictionConstraints(VectorNd vel,double t0){
  updateFrictionConstraints();
  myRBSolver.updateStructure(myMass,myGT,myGTVersion);
  myRBSolver.projectFriction(myMass,myGT,myNT,myDT,myRg,myBg,myRn,myBn,myBd,myFrictionInfo,vel,myLam,myThe,myPhi);
  int[] RBDTmap=myRBSolver.getDTMap();
  if (RBDTmap != null) {
    int[] DTmap=new int[myDT.numBlockCols() - RBDTmap.length];
    int i=0;
    int k=0;
    for (int bj=0; bj < myDT.numBlockCols(); bj++) {
      if (k < RBDTmap.length && RBDTmap[k] == bj) {
        k++;
      }
 else {
        DTmap[i++]=bj;
      }
    }
    if (i != DTmap.length) {
      throw new InternalErrorException(""String_Node_Str"");
    }
    updateInverseMassMatrix(t0);
    for (i=0; i < DTmap.length; i++) {
      FrictionInfo info=myFrictionInfo[DTmap[i]];
      double phiMax;
      if ((info.flags & FrictionInfo.BILATERAL) != 0) {
        phiMax=info.getMaxFriction(myLam);
      }
 else {
        phiMax=info.getMaxFriction(myThe);
      }
      int bj=DTmap[i];
      int j=myDT.getBlockColOffset(bj);
      double doff=myBd.get(j);
      double phi=projectSingleFrictionConstraint(vel,myDT,bj,phiMax,doff,true);
      myPhi.set(j,phi);
    }
  }
  if (myUpdateForcesAtStepEnd) {
    int velSize=myActiveVelSize;
    if (myDsize > 0) {
      myDT.mulAdd(myFcon,myPhi,velSize,myDsize);
    }
  }
}"
70933,"protected boolean computeRigidBodyPosCorrections(VectorNd pos,double t){
  int velSize=myActiveVelSize;
  if (velSize == 0) {
    return false;
  }
  if (myConSolver == null) {
    myConSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  updateUnilateralConstraints();
  myVel.setSize(velSize);
  if (myGsize > 0 || myNsize > 0) {
    mySys.getBilateralInfo(myGInfo);
    double[] gbuf=myBg.getBuffer();
    for (int i=0; i < myGsize; i++) {
      gbuf[i]=-myGInfo[i].dist;
    }
    myRg.setZero();
    mySys.getUnilateralInfo(myNInfo);
    double[] nbuf=myBn.getBuffer();
    for (int i=0; i < myNsize; i++) {
      nbuf[i]=-myNInfo[i].dist;
    }
    myRn.setZero();
    myVel.setZero();
    myLam.setZero();
    myThe.setZero();
    myRBSolver.updateStructure(myMass,myGT);
    if (myRBSolver.projectPosition(myMass,myGT,myNT,myBg,myBn,myVel,myLam,myThe)) {
      mySys.addActivePosImpulse(pos,1,myVel);
      return true;
    }
  }
  return false;
}","protected boolean computeRigidBodyPosCorrections(VectorNd pos,double t){
  int velSize=myActiveVelSize;
  if (velSize == 0) {
    return false;
  }
  if (myConSolver == null) {
    myConSolver=new KKTSolver();
  }
  updateBilateralConstraints();
  updateUnilateralConstraints();
  myVel.setSize(velSize);
  if (myGsize > 0 || myNsize > 0) {
    mySys.getBilateralInfo(myGInfo);
    double[] gbuf=myBg.getBuffer();
    for (int i=0; i < myGsize; i++) {
      gbuf[i]=-myGInfo[i].dist;
    }
    myRg.setZero();
    mySys.getUnilateralInfo(myNInfo);
    double[] nbuf=myBn.getBuffer();
    for (int i=0; i < myNsize; i++) {
      nbuf[i]=-myNInfo[i].dist;
    }
    myRn.setZero();
    myVel.setZero();
    myLam.setZero();
    myThe.setZero();
    myRBSolver.updateStructure(myMass,myGT,myGTVersion);
    if (myRBSolver.projectPosition(myMass,myGT,myNT,myBg,myBn,myVel,myLam,myThe)) {
      mySys.addActivePosImpulse(pos,1,myVel);
      return true;
    }
  }
  return false;
}"
70934,"public void updateStructure(SparseBlockMatrix M,SparseBlockMatrix GT){
  if (mySolver == null) {
    mySolver=new KKTSolver();
  }
  if (myStructureVersion != mySys.getStructureVersion()) {
    doUpdateStructure(M,GT);
    myStructureVersion=mySys.getStructureVersion();
  }
}","public void updateStructure(SparseBlockMatrix M,SparseBlockMatrix GT,int GTversion){
  if (mySolver == null) {
    mySolver=new KKTSolver();
  }
  if (myStructureVersion != mySys.getStructureVersion() || myBilateralVersion != GTversion) {
    doUpdateStructure(M,GT);
    myStructureVersion=mySys.getStructureVersion();
    myBilateralVersion=GTversion;
  }
}"
70935,"public void update(GL3 gl,ByteBuffer buff,int start){
  gl.glBindBuffer(target,boId);
  if (start == 0 && buff.limit() == size) {
    gl.glBufferData(target,size,null,usage);
  }
  gl.glBufferSubData(target,start * Byte.BYTES,buff.limit() * Byte.BYTES,buff);
}","public void update(GL3 gl,ByteBuffer buff,int start){
  gl.glBindBuffer(target,boId);
  if (start == 0 && buff.limit() == size) {
    gl.glBufferData(target,size,null,usage);
  }
  gl.glBufferSubData(target,start * GLSupport.BYTE_SIZE,buff.limit() * GLSupport.BYTE_SIZE,buff);
}"
70936,"public void fill(GL3 gl,ByteBuffer buff,int target,int usage){
  setInfo(target,buff.limit() * Byte.BYTES,usage);
  gl.glBindBuffer(target,boId);
  gl.glBufferData(target,buff.limit() * Byte.BYTES,buff,usage);
}","public void fill(GL3 gl,ByteBuffer buff,int target,int usage){
  setInfo(target,buff.limit() * GLSupport.BYTE_SIZE,usage);
  gl.glBindBuffer(target,boId);
  gl.glBufferData(target,buff.limit() * GLSupport.BYTE_SIZE,buff,usage);
}"
70937,"/** 
 * Returns the number of enabled clip distances
 * @param gl
 * @param clips
 * @return
 */
public int updateClipPlanes(GL3 gl,List<GLClipPlane> clips){
  float[] clipbuff=new float[getSize() / Float.BYTES];
  int nclips=0;
  for (  GLClipPlane cp : clips) {
    if (cp.isClippingEnabled()) {
      int idx=getOffset(nclips) / Float.BYTES;
      cp.getClipPlaneValues(clipbuff,idx,false);
      nclips++;
      if (nclips >= numClipPlanes) {
        break;
      }
      if (cp.isSlicingEnabled()) {
        idx=getOffset(nclips) / Float.BYTES;
        cp.getClipPlaneValues(clipbuff,idx,true);
        nclips++;
        if (nclips >= numClipPlanes) {
          break;
        }
      }
    }
  }
  FloatBuffer data=FloatBuffer.wrap(clipbuff);
  update(gl,data);
  return nclips;
}","/** 
 * Returns the number of enabled clip distances
 * @param gl
 * @param clips
 * @return
 */
public int updateClipPlanes(GL3 gl,List<GLClipPlane> clips){
  float[] clipbuff=new float[getSize() / GLSupport.FLOAT_SIZE];
  int nclips=0;
  for (  GLClipPlane cp : clips) {
    if (cp.isClippingEnabled()) {
      int idx=getOffset(nclips) / GLSupport.FLOAT_SIZE;
      cp.getClipPlaneValues(clipbuff,idx,false);
      nclips++;
      if (nclips >= numClipPlanes) {
        break;
      }
      if (cp.isSlicingEnabled()) {
        idx=getOffset(nclips) / GLSupport.FLOAT_SIZE;
        cp.getClipPlaneValues(clipbuff,idx,true);
        nclips++;
        if (nclips >= numClipPlanes) {
          break;
        }
      }
    }
  }
  FloatBuffer data=FloatBuffer.wrap(clipbuff);
  update(gl,data);
  return nclips;
}"
70938,"@Override public int bytesPerColor(){
  return 4 * Byte.BYTES;
}","@Override public int bytesPerColor(){
  return 4 * GLSupport.BYTE_SIZE;
}"
70939,"private void createVBOs(GL3 gl,RenderObject robj,GL3Object lineObject,float lineRadius,GL3Object headObject,float headRadius,float headLength){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  lineInfo=createAttributeInfoArrays(2);
  headInfo=createAttributeInfoArrays(2);
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numLinesTotal=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    numLinesTotal+=robj.numLines(lg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * 2* numLinesTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * 2* numLinesTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * 2* numLinesTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * 2* numLinesTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=2 * numLinesTotal;
    }
  }
  int vboIdx=0;
  if (staticVertexSize > 0) {
    vboIdx++;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=vboIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=0;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=vboIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=0;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=vboIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=0;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=vboIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=0;
    }
  }
  if (!streaming && robj.isDynamic()) {
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  lineInfo[0].offset=0;
  lineInfo[0].stride=10 * Float.BYTES;
  lineInfo[0].count=1;
  lineInfo[0].vboIndex=vboIdx;
  lineInfo[1].offset=1 * Float.BYTES;
  lineInfo[1].stride=10 * Float.BYTES;
  lineInfo[1].count=1;
  lineInfo[1].vboIndex=vboIdx;
  headInfo[0].offset=5 * Float.BYTES;
  headInfo[0].stride=10 * Float.BYTES;
  headInfo[0].count=1;
  headInfo[0].vboIndex=vboIdx;
  headInfo[1].offset=6 * Float.BYTES;
  headInfo[1].stride=10 * Float.BYTES;
  headInfo[1].count=1;
  headInfo[1].vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numPositionSets() - 1)* POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numNormalSets() - 1)* NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numColorSets() - 1)* COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numTextureCoordSets() - 1)* TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    List<int[]> lines=robj.getLines(lg);
    for (    int[] line : lines) {
      for (int j=0; j < 2; ++j) {
        VertexIndexSet v=robj.getVertex(line[j]);
        for (int i=0; i < positionInfo.length; ++i) {
          AttributeInfo ai=positionInfo[i];
          float[] pos=robj.getPosition(i,v.getPositionIndex());
          positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        for (int i=0; i < normalInfo.length; ++i) {
          AttributeInfo ai=normalInfo[i];
          float[] nrm=robj.getNormal(i,v.getNormalIndex());
          normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
        }
        for (int i=0; i < colorInfo.length; ++i) {
          AttributeInfo ai=colorInfo[i];
          byte[] color=robj.getColor(i,v.getColorIndex());
          colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
        }
        for (int i=0; i < textureInfo.length; ++i) {
          AttributeInfo ai=textureInfo[i];
          float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
          texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        vidx++;
      }
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(10 * Float.BYTES);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(lineRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}","private void createVBOs(GL3 gl,RenderObject robj,GL3Object lineObject,float lineRadius,GL3Object headObject,float headRadius,float headLength){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  lineInfo=createAttributeInfoArrays(2);
  headInfo=createAttributeInfoArrays(2);
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numLinesTotal=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    numLinesTotal+=robj.numLines(lg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * 2* numLinesTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * 2* numLinesTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * 2* numLinesTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=2 * numLinesTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=2 * numLinesTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * 2* numLinesTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=2 * numLinesTotal;
    }
  }
  int vboIdx=0;
  if (staticVertexSize > 0) {
    vboIdx++;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=vboIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=0;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=vboIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=0;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=vboIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=0;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=vboIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=0;
    }
  }
  if (!streaming && robj.isDynamic()) {
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  lineInfo[0].offset=0;
  lineInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[0].count=1;
  lineInfo[0].vboIndex=vboIdx;
  lineInfo[1].offset=1 * GLSupport.FLOAT_SIZE;
  lineInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  lineInfo[1].count=1;
  lineInfo[1].vboIndex=vboIdx;
  headInfo[0].offset=5 * GLSupport.FLOAT_SIZE;
  headInfo[0].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[0].count=1;
  headInfo[0].vboIndex=vboIdx;
  headInfo[1].offset=6 * GLSupport.FLOAT_SIZE;
  headInfo[1].stride=10 * GLSupport.FLOAT_SIZE;
  headInfo[1].count=1;
  headInfo[1].vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numPositionSets() - 1)* POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numNormalSets() - 1)* NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numColorSets() - 1)* COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(2 * numLinesTotal * (robj.numTextureCoordSets() - 1)* TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int lg=0; lg < robj.numLineGroups(); ++lg) {
    List<int[]> lines=robj.getLines(lg);
    for (    int[] line : lines) {
      for (int j=0; j < 2; ++j) {
        VertexIndexSet v=robj.getVertex(line[j]);
        for (int i=0; i < positionInfo.length; ++i) {
          AttributeInfo ai=positionInfo[i];
          float[] pos=robj.getPosition(i,v.getPositionIndex());
          positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        for (int i=0; i < normalInfo.length; ++i) {
          AttributeInfo ai=normalInfo[i];
          float[] nrm=robj.getNormal(i,v.getNormalIndex());
          normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
        }
        for (int i=0; i < colorInfo.length; ++i) {
          AttributeInfo ai=colorInfo[i];
          byte[] color=robj.getColor(i,v.getColorIndex());
          colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
        }
        for (int i=0; i < textureInfo.length; ++i) {
          AttributeInfo ai=textureInfo[i];
          float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
          texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
        }
        vidx++;
      }
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(10 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(lineRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headRadius);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(0.0f);
  buffs[vboIdx].putFloat(headLength);
  buffs[vboIdx].putFloat(1.0f);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}"
70940,"private void createVBOs(GL3 gl,RenderObject robj,float pointRadius){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  pointInfo=new AttributeInfo();
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numPointsTotal=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    numPointsTotal+=robj.numPoints(pg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=numPointsTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * numPointsTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=numPointsTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * numPointsTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=numPointsTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * numPointsTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=numPointsTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * numPointsTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=numPointsTotal;
    }
  }
  int vboIdx=0;
  if (staticVertexSize > 0) {
    vboIdx++;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=vboIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=0;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=vboIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=0;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=vboIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=0;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=vboIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=0;
    }
  }
  if (!streaming && robj.isDynamic()) {
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  pointInfo.offset=0;
  pointInfo.stride=1 * Float.BYTES;
  pointInfo.count=1;
  pointInfo.vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numPositionSets() - 1) * POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numNormalSets() - 1) * NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numColorSets() - 1) * COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numTextureCoordSets() - 1) * TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    List<int[]> pnts=robj.getPoints(pg);
    for (    int[] pnt : pnts) {
      VertexIndexSet v=robj.getVertex(pnt[0]);
      for (int i=0; i < positionInfo.length; ++i) {
        AttributeInfo ai=positionInfo[i];
        float[] pos=robj.getPosition(i,v.getPositionIndex());
        positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      for (int i=0; i < normalInfo.length; ++i) {
        AttributeInfo ai=normalInfo[i];
        float[] nrm=robj.getNormal(i,v.getNormalIndex());
        normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
      }
      for (int i=0; i < colorInfo.length; ++i) {
        AttributeInfo ai=colorInfo[i];
        byte[] color=robj.getColor(i,v.getColorIndex());
        colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
      }
      for (int i=0; i < textureInfo.length; ++i) {
        AttributeInfo ai=textureInfo[i];
        float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
        texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      vidx++;
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(1 * Float.BYTES);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(pointRadius);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}","private void createVBOs(GL3 gl,RenderObject robj,float pointRadius){
  positionPutter=PositionBufferPutter.createDefault();
  normalPutter=NormalBufferPutter.createDefault();
  colorPutter=ColorBufferPutter.createDefault();
  texturePutter=TextureCoordBufferPutter.createDefault();
  final int POSITION_BYTES=positionPutter.bytesPerPosition();
  final int NORMAL_BYTES=normalPutter.bytesPerNormal();
  final int COLOR_BYTES=colorPutter.bytesPerColor();
  final int TEXTURE_BYTES=texturePutter.bytesPerTextureCoord();
  positionInfo=createAttributeInfoArrays(robj.numPositionSets());
  normalInfo=createAttributeInfoArrays(robj.numNormalSets());
  colorInfo=createAttributeInfoArrays(robj.numColorSets());
  textureInfo=createAttributeInfoArrays(robj.numTextureCoordSets());
  pointInfo=new AttributeInfo();
  staticVertexSize=0;
  staticMask=0;
  dynamicVertexSize=0;
  dynamicMask=0;
  boolean streaming=robj.isStreaming();
  nVertices=robj.numVertices();
  int numPointsTotal=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    numPointsTotal+=robj.numPoints(pg);
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=POSITION_BYTES;
      dynamicMask|=POSITION_FLAG;
    }
 else {
      positionInfo[0].offset=staticVertexSize;
      staticVertexSize+=POSITION_BYTES;
      staticMask|=POSITION_FLAG;
    }
    positionInfo[0].count=numPointsTotal;
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].offset=(i - 1) * POSITION_BYTES * numPointsTotal;
      positionInfo[i].stride=POSITION_BYTES;
      positionInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=NORMAL_BYTES;
      dynamicMask|=NORMAL_FLAG;
    }
 else {
      normalInfo[0].offset=staticVertexSize;
      staticVertexSize+=NORMAL_BYTES;
      staticMask|=NORMAL_FLAG;
    }
    normalInfo[0].count=numPointsTotal;
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].offset=(i - 1) * NORMAL_BYTES * numPointsTotal;
      normalInfo[i].stride=NORMAL_BYTES;
      normalInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=COLOR_BYTES;
      dynamicMask|=COLOR_FLAG;
    }
 else {
      colorInfo[0].offset=staticVertexSize;
      staticVertexSize+=COLOR_BYTES;
      staticMask|=COLOR_FLAG;
    }
    colorInfo[0].count=numPointsTotal;
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].offset=(i - 1) * COLOR_BYTES * numPointsTotal;
      colorInfo[i].stride=COLOR_BYTES;
      colorInfo[i].count=numPointsTotal;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].offset=dynamicVertexSize;
      dynamicVertexSize+=TEXTURE_BYTES;
      dynamicMask|=TEXTURE_FLAG;
    }
 else {
      textureInfo[0].offset=staticVertexSize;
      staticVertexSize+=TEXTURE_BYTES;
      staticMask|=TEXTURE_FLAG;
    }
    textureInfo[0].count=numPointsTotal;
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].offset=(i - 1) * TEXTURE_BYTES * numPointsTotal;
      textureInfo[i].stride=TEXTURE_BYTES;
      textureInfo[i].count=numPointsTotal;
    }
  }
  int vboIdx=0;
  if (staticVertexSize > 0) {
    vboIdx++;
  }
  if (robj.hasPositions()) {
    if (!streaming && robj.isPositionsDynamic()) {
      positionInfo[0].stride=dynamicVertexSize;
      positionInfo[0].vboIndex=vboIdx;
    }
 else {
      positionInfo[0].stride=staticVertexSize;
      positionInfo[0].vboIndex=0;
    }
  }
  if (robj.hasNormals()) {
    if (!streaming && robj.isNormalsDynamic()) {
      normalInfo[0].stride=dynamicVertexSize;
      normalInfo[0].vboIndex=vboIdx;
    }
 else {
      normalInfo[0].stride=staticVertexSize;
      normalInfo[0].vboIndex=0;
    }
  }
  if (robj.hasColors()) {
    if (!streaming && robj.isColorsDynamic()) {
      colorInfo[0].stride=dynamicVertexSize;
      colorInfo[0].vboIndex=vboIdx;
    }
 else {
      colorInfo[0].stride=staticVertexSize;
      colorInfo[0].vboIndex=0;
    }
  }
  if (robj.hasTextureCoords()) {
    if (!streaming && robj.isTextureCoordsDynamic()) {
      textureInfo[0].stride=dynamicVertexSize;
      textureInfo[0].vboIndex=vboIdx;
    }
 else {
      textureInfo[0].stride=staticVertexSize;
      textureInfo[0].vboIndex=0;
    }
  }
  if (!streaming && robj.isDynamic()) {
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    for (int i=1; i < positionInfo.length; ++i) {
      positionInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    for (int i=1; i < normalInfo.length; ++i) {
      normalInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    for (int i=1; i < colorInfo.length; ++i) {
      colorInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    for (int i=1; i < textureInfo.length; ++i) {
      textureInfo[i].vboIndex=vboIdx;
    }
    vboIdx++;
  }
  pointInfo.offset=0;
  pointInfo.stride=1 * GLSupport.FLOAT_SIZE;
  pointInfo.count=1;
  pointInfo.vboIndex=vboIdx;
  vboIdx++;
  int nVBOs=vboIdx;
  ByteBuffer[] buffs=new ByteBuffer[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * staticVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * dynamicVertexSize);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numPositionSets() - 1) * POSITION_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numNormalSets() - 1) * NORMAL_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numColorSets() - 1) * COLOR_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    buffs[vboIdx]=ByteBuffer.allocateDirect(numPointsTotal * (robj.numTextureCoordSets() - 1) * TEXTURE_BYTES);
    buffs[vboIdx].order(ByteOrder.nativeOrder());
    vboIdx++;
  }
  int vidx=0;
  for (int pg=0; pg < robj.numPointGroups(); ++pg) {
    List<int[]> pnts=robj.getPoints(pg);
    for (    int[] pnt : pnts) {
      VertexIndexSet v=robj.getVertex(pnt[0]);
      for (int i=0; i < positionInfo.length; ++i) {
        AttributeInfo ai=positionInfo[i];
        float[] pos=robj.getPosition(i,v.getPositionIndex());
        positionPutter.putPosition(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      for (int i=0; i < normalInfo.length; ++i) {
        AttributeInfo ai=normalInfo[i];
        float[] nrm=robj.getNormal(i,v.getNormalIndex());
        normalPutter.putNormal(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,nrm);
      }
      for (int i=0; i < colorInfo.length; ++i) {
        AttributeInfo ai=colorInfo[i];
        byte[] color=robj.getColor(i,v.getColorIndex());
        colorPutter.putColor(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,color);
      }
      for (int i=0; i < textureInfo.length; ++i) {
        AttributeInfo ai=textureInfo[i];
        float[] pos=robj.getTextureCoord(i,v.getTextureCoordIndex());
        texturePutter.putTextureCoord(buffs[ai.vboIndex],ai.offset + vidx * ai.stride,pos);
      }
      vidx++;
    }
  }
  buffs[vboIdx]=ByteBuffer.allocateDirect(1 * GLSupport.FLOAT_SIZE);
  buffs[vboIdx].order(ByteOrder.nativeOrder());
  buffs[vboIdx].putFloat(pointRadius);
  vbos=new BufferObject[nVBOs];
  vboIdx=0;
  if (staticVertexSize > 0) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(false,streaming));
    vboIdx++;
  }
  if (!streaming && robj.isDynamic()) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(true,streaming));
    vboIdx++;
  }
  if (robj.numPositionSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isPositionsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numNormalSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isNormalsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numColorSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isColorsDynamic(),streaming));
    vboIdx++;
  }
  if (robj.numTextureCoordSets() > 1) {
    vbos[vboIdx]=new BufferObject(gl);
    buffs[vboIdx].rewind();
    vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,getBufferUsage(robj.isTextureCoordsDynamic(),streaming));
    vboIdx++;
  }
  vbos[vboIdx]=new BufferObject(gl);
  buffs[vboIdx].rewind();
  vbos[vboIdx].fill(gl,buffs[vboIdx],GL.GL_ARRAY_BUFFER,GL.GL_DYNAMIC_DRAW);
  vboIdx++;
}"
70941,"@Override public void getHardReferences(List<ModelComponent> refs){
  super.getHardReferences(refs);
  if (myFrame != null) {
    refs.add(myFrame);
  }
  if (myElement != null) {
    refs.add(myElement);
  }
 else   if (myNodes != null) {
    for (    FemNode n : myNodes) {
      refs.add(n);
    }
  }
}","@Override public void getHardReferences(List<ModelComponent> refs){
  super.getHardReferences(refs);
  if (myElement != null) {
    refs.add(myElement);
  }
}"
70942,"@Override public void getHardReferences(List<ModelComponent> refs){
  super.getHardReferences(refs);
  refs.add(getPoint());
  if (myNodes != null) {
    for (    FemNode node : myNodes) {
      refs.add(node);
    }
  }
}","@Override public void getHardReferences(List<ModelComponent> refs){
  super.getHardReferences(refs);
  if (myElement != null) {
    refs.add(myElement);
  }
}"
70943,"@Override public void getHardReferences(List<ModelComponent> refs){
  super.getHardReferences(refs);
  DynamicAttachment ax=getAttachment();
  if (ax != null) {
    ax.getHardReferences(refs);
  }
}","@Override public void getHardReferences(List<ModelComponent> refs){
  super.getHardReferences(refs);
  DynamicAttachment ax=getAttachment();
  if (ax != null) {
    ArrayList<ModelComponent> allrefs=new ArrayList<ModelComponent>();
    ax.getHardReferences(allrefs);
    allrefs.remove(this);
    refs.addAll(allrefs);
  }
}"
70944,"public static LinkedList<ModelComponent> findDependentComponents(List<ModelComponent> update,List<? extends ModelComponent> comps){
  ModelComponent acomp=findCommonAncestor(comps);
  if (acomp == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  CompositeComponent ancestor=nearestEncapsulatingAncestor(acomp);
  HashMap<ModelComponent,Dependencies> depMap=buildDependencyMap(ancestor);
  HashSet<ModelComponent> updateSet=new LinkedHashSet<ModelComponent>();
  LinkedList<ModelComponent> delete=new LinkedList<ModelComponent>();
  for (  ModelComponent c : comps) {
    recursivelyAddDependenices(delete,updateSet,c,depMap);
  }
  for (  ModelComponent c : delete) {
    c.setMarked(false);
  }
  update.addAll(updateSet);
  LinkedHashMap<ModelComponent,LinkedList<ModelComponent>> parentMap=new LinkedHashMap<ModelComponent,LinkedList<ModelComponent>>();
  ModelComponent currentParent=null;
  LinkedList<ModelComponent> listForParent=null;
  ModelComponent root=null;
  for (  ModelComponent c : delete) {
    ModelComponent parent=c.getParent();
    if (parent == null) {
      if (root == null) {
        root=c;
      }
 else       if (c != root) {
        throw new InternalErrorException(""String_Node_Str"" + getPathName(c) + ""String_Node_Str""+ getPathName(root));
      }
    }
 else {
      if (parent != currentParent) {
        listForParent=parentMap.get(parent);
        if (listForParent == null) {
          listForParent=new LinkedList<ModelComponent>();
          parentMap.put(parent,listForParent);
        }
        currentParent=parent;
      }
      listForParent.add(c);
    }
  }
  delete.clear();
  if (root != null) {
    delete.add(root);
  }
  for (  LinkedList<ModelComponent> l : parentMap.values()) {
    delete.addAll(l);
  }
  return delete;
}","public static LinkedList<ModelComponent> findDependentComponents(List<ModelComponent> update,List<? extends ModelComponent> comps){
  ModelComponent acomp=findCommonAncestor(comps);
  if (acomp == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  CompositeComponent ancestor=farthestEncapsulatingAncestor(acomp);
  HashMap<ModelComponent,Dependencies> depMap=buildDependencyMap(ancestor);
  HashSet<ModelComponent> updateSet=new LinkedHashSet<ModelComponent>();
  LinkedList<ModelComponent> delete=new LinkedList<ModelComponent>();
  for (  ModelComponent c : comps) {
    recursivelyAddDependenices(delete,updateSet,c,depMap);
  }
  for (  ModelComponent c : delete) {
    c.setMarked(false);
  }
  update.addAll(updateSet);
  LinkedHashMap<ModelComponent,LinkedList<ModelComponent>> parentMap=new LinkedHashMap<ModelComponent,LinkedList<ModelComponent>>();
  ModelComponent currentParent=null;
  LinkedList<ModelComponent> listForParent=null;
  ModelComponent root=null;
  for (  ModelComponent c : delete) {
    ModelComponent parent=c.getParent();
    if (parent == null) {
      if (root == null) {
        root=c;
      }
 else       if (c != root) {
        throw new InternalErrorException(""String_Node_Str"" + getPathName(c) + ""String_Node_Str""+ getPathName(root));
      }
    }
 else {
      if (parent != currentParent) {
        listForParent=parentMap.get(parent);
        if (listForParent == null) {
          listForParent=new LinkedList<ModelComponent>();
          parentMap.put(parent,listForParent);
        }
        currentParent=parent;
      }
      listForParent.add(c);
    }
  }
  delete.clear();
  if (root != null) {
    delete.add(root);
  }
  for (  LinkedList<ModelComponent> l : parentMap.values()) {
    delete.addAll(l);
  }
  return delete;
}"
70945,"/** 
 * Returns the closest ancestor of a component (or the component itself) for which   {@link CompositeComponent#hierarchyContainsReferences() hierarchyContainsDependencies()} returns <code>true</code>.That means all inter-component references are contained within the ancestor's hierarchy. If no such ancestor is found,  <code>null</code> is returned.
 * @return closest encapsulated ancestor
 */
public static CompositeComponent nearestEncapsulatingAncestor(ModelComponent c){
  CompositeComponent ancestor;
  if (c instanceof CompositeComponent) {
    ancestor=(CompositeComponent)c;
  }
 else {
    ancestor=c.getParent();
  }
  while (ancestor != null) {
    if (ancestor.hierarchyContainsReferences()) {
      return ancestor;
    }
    ancestor=ancestor.getParent();
  }
  return null;
}","/** 
 * Returns the closest ancestor of a component (or the component itself) for which   {@link CompositeComponent#hierarchyContainsReferences() hierarchyContainsDependencies()} returns <code>true</code>.That means all inter-component references are contained within the ancestor's hierarchy. If no such ancestor is found,  <code>null</code> is returned.
 * @return closest encapsulating ancestor
 */
public static CompositeComponent nearestEncapsulatingAncestor(ModelComponent c){
  CompositeComponent ancestor;
  if (c instanceof CompositeComponent) {
    ancestor=(CompositeComponent)c;
  }
 else {
    ancestor=c.getParent();
  }
  while (ancestor != null) {
    if (ancestor.hierarchyContainsReferences()) {
      return ancestor;
    }
    ancestor=ancestor.getParent();
  }
  return null;
}"
70946,"public static <C extends ModelComponent>void updateReferences(ModelComponent c,List<C> refs,boolean undo,Deque<Object> undoInfo){
  if (undo) {
    Object obj=undoInfo.getFirst();
    if (obj != ModelComponentBase.NULL_OBJ) {
      ((ListRemove<C>)obj).undo();
    }
  }
 else {
    ListRemove<C> remove=null;
    if (refs != null) {
      for (int i=0; i < refs.size(); i++) {
        if (!ComponentUtils.isConnected(c,refs.get(i))) {
          if (remove == null) {
            remove=new ListRemove<C>(refs);
          }
          remove.requestRemove(i);
        }
      }
    }
    if (remove != null) {
      remove.remove();
      undoInfo.addLast(remove);
    }
 else {
      undoInfo.addLast(ModelComponentBase.NULL_OBJ);
    }
  }
}","public static <C extends ModelComponent>void updateReferences(ModelComponent c,List<C> refs,boolean undo,Deque<Object> undoInfo){
  if (undo) {
    Object obj=undoInfo.removeFirst();
    if (obj != ModelComponentBase.NULL_OBJ) {
      ((ListRemove<C>)obj).undo();
    }
  }
 else {
    ListRemove<C> remove=null;
    if (refs != null) {
      for (int i=0; i < refs.size(); i++) {
        if (!ComponentUtils.isConnected(c,refs.get(i))) {
          if (remove == null) {
            remove=new ListRemove<C>(refs);
          }
          remove.requestRemove(i);
        }
      }
    }
    if (remove != null) {
      remove.remove();
      undoInfo.addLast(remove);
    }
 else {
      undoInfo.addLast(ModelComponentBase.NULL_OBJ);
    }
  }
}"
70947,"public void addSkinMesh() throws IOException {
  String dataDir=ArtisynthPath.getSrcRelativePath(Tentacle.class,""String_Node_Str"");
  String meshFilename=dataDir + ""String_Node_Str"";
  PolygonalMesh tentacle=new PolygonalMesh(new File(meshFilename));
  TextureProps tp=new TextureProps();
  tp.setFileName(dataDir + ""String_Node_Str"");
  tp.setMode(Mode.DECAL);
  tp.setEnabled(true);
  RenderProps rp=new RenderProps(myMechMod.getRenderProps());
  rp.setFaceStyle(Faces.FRONT);
  rp.setFaceColor(new Color(255,187,187));
  rp.setDrawEdges(false);
  rp.setLineColor(Color.BLACK);
  rp.setTextureProps(tp);
  tentacle.setRenderProps(rp);
  Point3d min=new Point3d(inf,inf,inf);
  Point3d max=new Point3d(-inf,-inf,-inf);
  tentacle.updateBounds(min,max);
  Vector3d tentacleBounds=new Vector3d();
  tentacleBounds.sub(max,min);
  min=new Point3d(inf,inf,inf);
  max=new Point3d(-inf,-inf,-inf);
  for (  RigidBody body : myMechMod.rigidBodies()) {
    if (body.isDynamic()) {
      body.updateBounds(min,max);
    }
  }
  Vector3d skeletonBounds=new Vector3d();
  skeletonBounds.sub(max,min);
  tentacle.scale(0.011);
  RigidTransform3d X=new RigidTransform3d();
  X.p.x=-skeletonBounds.x / 2;
  tentacle.transform(X);
  SkinMesh skinMesh=new SkinMesh(tentacle);
  ArrayList<RigidBody> skinnedBodies=new ArrayList<RigidBody>();
  for (  RigidBody body : myMechMod.rigidBodies()) {
    skinnedBodies.add(body);
    skinMesh.addFrame(body);
  }
  skinMesh.computeWeights();
  skinMesh.setRenderProps(rp);
  myMechMod.addMeshBody(skinMesh);
}","public void addSkinMesh() throws IOException {
  String dataDir=ArtisynthPath.getSrcRelativePath(RigidTentacle.class,""String_Node_Str"");
  String meshFilename=dataDir + ""String_Node_Str"";
  PolygonalMesh tentacle=new PolygonalMesh(new File(meshFilename));
  TextureProps tp=new TextureProps();
  tp.setFileName(dataDir + ""String_Node_Str"");
  tp.setMode(Mode.DECAL);
  tp.setEnabled(true);
  RenderProps rp=new RenderProps(myMechMod.getRenderProps());
  rp.setFaceStyle(Faces.FRONT);
  rp.setFaceColor(new Color(255,187,187));
  rp.setDrawEdges(false);
  rp.setLineColor(Color.BLACK);
  rp.setTextureProps(tp);
  tentacle.setRenderProps(rp);
  Point3d min=new Point3d(inf,inf,inf);
  Point3d max=new Point3d(-inf,-inf,-inf);
  tentacle.updateBounds(min,max);
  Vector3d tentacleBounds=new Vector3d();
  tentacleBounds.sub(max,min);
  min=new Point3d(inf,inf,inf);
  max=new Point3d(-inf,-inf,-inf);
  for (  RigidBody body : myMechMod.rigidBodies()) {
    if (body.isDynamic()) {
      body.updateBounds(min,max);
    }
  }
  Vector3d skeletonBounds=new Vector3d();
  skeletonBounds.sub(max,min);
  tentacle.scale(0.011);
  RigidTransform3d X=new RigidTransform3d();
  X.p.x=-skeletonBounds.x / 2;
  tentacle.transform(X);
  SkinMesh skinMesh=new SkinMesh(tentacle);
  ArrayList<RigidBody> skinnedBodies=new ArrayList<RigidBody>();
  for (  RigidBody body : myMechMod.rigidBodies()) {
    skinnedBodies.add(body);
    skinMesh.addFrame(body);
  }
  skinMesh.computeWeights();
  skinMesh.setRenderProps(rp);
  myMechMod.addMeshBody(skinMesh);
}"
70948,"/** 
 * Currently only detects type by file extension.  For Abaqus use .inp,  Ansys .elem, and Tetgen .ele.  If a .node is supplied, the method will try to find a corresponding .ele or .elem file.
 * @param fileName
 * @return type of the file
 * @throws IOException
 */
public static FemFileType detectType(String fileName){
  String ext=getFileExtension(fileName);
  ext=ext.toLowerCase();
  if (""String_Node_Str"".equals(ext)) {
    return FemFileType.ABAQUS;
  }
 else   if (""String_Node_Str"".equals(ext)) {
    return FemFileType.ANSYS;
  }
 else   if (""String_Node_Str"".equals(ext)) {
    return FemFileType.TETGEN;
  }
 else   if (""String_Node_Str"".equals(ext)) {
    String baseName=removeExtension(fileName);
    String elemName=baseName + ""String_Node_Str"";
    File elemFile=new File(elemName);
    if (elemFile.exists()) {
      return FemFileType.TETGEN;
    }
    elemName=baseName + ""String_Node_Str"";
    elemFile=new File(elemName);
    if (elemFile.exists()) {
      return FemFileType.ANSYS;
    }
  }
  return null;
}","/** 
 * Currently only detects type by file extension.  For Abaqus use .inp,  Ansys .elem, and Tetgen .ele.  If a .node is supplied, the method will try to find a corresponding .ele or .elem file.
 * @param fileName
 * @return type of the file
 */
public static FemFileType detectType(String fileName){
  String ext=getFileExtension(fileName);
  ext=ext.toLowerCase();
  if (""String_Node_Str"".equals(ext)) {
    return FemFileType.ABAQUS;
  }
 else   if (""String_Node_Str"".equals(ext)) {
    return FemFileType.ANSYS;
  }
 else   if (""String_Node_Str"".equals(ext)) {
    return FemFileType.TETGEN;
  }
 else   if (""String_Node_Str"".equals(ext)) {
    String baseName=removeExtension(fileName);
    String elemName=baseName + ""String_Node_Str"";
    File elemFile=new File(elemName);
    if (elemFile.exists()) {
      return FemFileType.TETGEN;
    }
    elemName=baseName + ""String_Node_Str"";
    elemFile=new File(elemName);
    if (elemFile.exists()) {
      return FemFileType.ANSYS;
    }
  }
  return null;
}"
70949,"/** 
 * Adds a copy of the nodes, elements, markers and attachments from <code>fem1</code> to <code>fem0</code>.
 * @param fem0 FEM model to which components should be added
 * @param fem1 FEM model providing components
 * @param nodeMergeDist If >= 0, causes nearby nodes of <code>fem1</code> and <code>fem0</code> to be merged: any node of <code>fem1</code> that is within <code>nodeMergeDist</code> of a node in <code>fem0</code> is replaced by the nearest node in <code>fem0</code>.
 */
public static void addFem(FemModel3d fem0,FemModel3d fem1,double nodeMergeDist){
  int flags=CopyableComponent.COPY_REFERENCES;
  HashMap<ModelComponent,ModelComponent> copyMap=new HashMap<ModelComponent,ModelComponent>();
  ArrayList<FemNode3d> newNodes=new ArrayList<FemNode3d>();
  for (  FemNode3d n : fem1.myNodes) {
    FemNode3d newn;
    if (nodeMergeDist < 0 || (newn=fem0.findNearestNode(n.getPosition(),nodeMergeDist)) == null) {
      newn=n.copy(flags,copyMap);
      newn.setName(n.getName());
      newNodes.add(newn);
    }
    copyMap.put(n,newn);
  }
  for (  FemNode3d n : newNodes) {
    fem0.myNodes.add(n);
  }
  for (  FemElement3d e : fem1.myElements) {
    FemElement3d newe=e.copy(flags,copyMap);
    newe.setName(e.getName());
    copyMap.put(e,newe);
    fem0.myElements.add(newe);
  }
  for (  FemMarker m : fem1.myMarkers) {
    FemMarker newm=m.copy(flags,copyMap);
    newm.setName(m.getName());
    fem0.myMarkers.add(newm);
  }
  for (  DynamicAttachment a : fem1.myAttachments) {
    DynamicAttachment newa=a.copy(flags,copyMap);
    newa.setName(a.getName());
    fem0.myAttachments.add(newa);
  }
}","/** 
 * Adds a copy of the nodes, elements, markers and attachments from <code>fem1</code> to <code>fem0</code>.
 * @param fem0 FEM model to which components should be added
 * @param fem1 FEM model providing components
 * @param nodeMergeDist If &gt;= 0, causes nearby nodes of <code>fem1</code> and <code>fem0</code> to be merged: any node of <code>fem1</code> that is within <code>nodeMergeDist</code> of a node in <code>fem0</code> is replaced by the nearest node in <code>fem0</code>.
 */
public static void addFem(FemModel3d fem0,FemModel3d fem1,double nodeMergeDist){
  int flags=CopyableComponent.COPY_REFERENCES;
  HashMap<ModelComponent,ModelComponent> copyMap=new HashMap<ModelComponent,ModelComponent>();
  ArrayList<FemNode3d> newNodes=new ArrayList<FemNode3d>();
  for (  FemNode3d n : fem1.myNodes) {
    FemNode3d newn;
    if (nodeMergeDist < 0 || (newn=fem0.findNearestNode(n.getPosition(),nodeMergeDist)) == null) {
      newn=n.copy(flags,copyMap);
      newn.setName(n.getName());
      newNodes.add(newn);
    }
    copyMap.put(n,newn);
  }
  for (  FemNode3d n : newNodes) {
    fem0.myNodes.add(n);
  }
  for (  FemElement3d e : fem1.myElements) {
    FemElement3d newe=e.copy(flags,copyMap);
    newe.setName(e.getName());
    copyMap.put(e,newe);
    fem0.myElements.add(newe);
  }
  for (  FemMarker m : fem1.myMarkers) {
    FemMarker newm=m.copy(flags,copyMap);
    newm.setName(m.getName());
    fem0.myMarkers.add(newm);
  }
  for (  DynamicAttachment a : fem1.myAttachments) {
    DynamicAttachment newa=a.copy(flags,copyMap);
    newa.setName(a.getName());
    fem0.myAttachments.add(newa);
  }
}"
70950,"/** 
 * Creates a tetrahedral FEM model from a triangular surface mesh. The tetrahedra will be added to either an existing model (supplied through the argument <code>model</code>), or a newly created <code>FemModel3d</code> (if <code>model</code> is <code>null</code>). <p> The tessellation is done using tetgen, which is called through a JNI interface. The tessellation quality is controlled using the <code>quality</code> variable, described below.
 * @param model model to which the tetrahedra should be added, or <code>null</code> if the model is to be created from scratch.
 * @param surface triangular surface mesh used to define the tessellation.
 * @param quality If 0, then only the mesh nodes will be used to form the tessellation. However, this may result in highly degenerate tetrahedra. Otherwise, if > 0, tetgen will add additional nodes to ensure that the minimum edge-radius ratio does not exceed <code>quality</code>. A good default value for <code>quality</code> is 2. If set too small (such as less then 1), then tetgen may not terminate.
 * @return the FEM model
 */
public static FemModel3d createFromMesh(FemModel3d model,PolygonalMesh surface,double quality){
  TetgenTessellator tetgen=new TetgenTessellator();
  tetgen.buildFromMesh(surface,quality);
  if (model == null) {
    model=new FemModel3d();
  }
 else {
    model.clear();
  }
  Point3d[] points=tetgen.getPoints();
  for (int i=0; i < points.length; i++) {
    model.addNode(new FemNode3d(points[i]));
  }
  ComponentList<FemNode3d> nodes=model.getNodes();
  int[] tets=tetgen.getTets();
  for (int i=0; i < tets.length / 4; i++) {
    FemNode3d n0=nodes.get(tets[i * 4 + 0]);
    FemNode3d n1=nodes.get(tets[i * 4 + 1]);
    FemNode3d n2=nodes.get(tets[i * 4 + 2]);
    FemNode3d n3=nodes.get(tets[i * 4 + 3]);
    TetElement elem=new TetElement(n1,n3,n2,n0);
    model.addElement(elem);
  }
  return model;
}","/** 
 * Creates a tetrahedral FEM model from a triangular surface mesh. The tetrahedra will be added to either an existing model (supplied through the argument <code>model</code>), or a newly created <code>FemModel3d</code> (if <code>model</code> is <code>null</code>). <p> The tessellation is done using tetgen, which is called through a JNI interface. The tessellation quality is controlled using the <code>quality</code> variable, described below.
 * @param model model to which the tetrahedra should be added, or <code>null</code> if the model is to be created from scratch.
 * @param surface triangular surface mesh used to define the tessellation.
 * @param quality If 0, then only the mesh nodes will be used to form the tessellation. However, this may result in highly degenerate tetrahedra. Otherwise, if &gt; 0, tetgen will add additional nodes to ensure that the minimum edge-radius ratio does not exceed <code>quality</code>. A good default value for <code>quality</code> is 2. If set too small (such as less then 1), then tetgen may not terminate.
 * @return the FEM model
 */
public static FemModel3d createFromMesh(FemModel3d model,PolygonalMesh surface,double quality){
  TetgenTessellator tetgen=new TetgenTessellator();
  tetgen.buildFromMesh(surface,quality);
  if (model == null) {
    model=new FemModel3d();
  }
 else {
    model.clear();
  }
  Point3d[] points=tetgen.getPoints();
  for (int i=0; i < points.length; i++) {
    model.addNode(new FemNode3d(points[i]));
  }
  ComponentList<FemNode3d> nodes=model.getNodes();
  int[] tets=tetgen.getTets();
  for (int i=0; i < tets.length / 4; i++) {
    FemNode3d n0=nodes.get(tets[i * 4 + 0]);
    FemNode3d n1=nodes.get(tets[i * 4 + 1]);
    FemNode3d n2=nodes.get(tets[i * 4 + 2]);
    FemNode3d n3=nodes.get(tets[i * 4 + 3]);
    TetElement elem=new TetElement(n1,n3,n2,n0);
    model.addElement(elem);
  }
  return model;
}"
70951,"/** 
 * Finds the nearest node to a specified point that is within a specified maximum distance. If no node is within the specified maximum distance, <code>null</code> is returned.
 * @param pnt Point for which the nearest node should be located
 * @param maxDist Maximum distance that the node must be from thepoint. If <code>maxDist</code> < 0, then <code>null</code> will be returned.
 * @return Nearest point within the prescribed distance, or <code>null</code>if there is no such point
 */
public FemNode3d findNearestNode(Point3d pnt,double maxDist){
  if (maxDist < 0) {
    return null;
  }
  BVTree bvtree=getBVTree();
  ArrayList<BVNode> nodes=new ArrayList<BVNode>();
  bvtree.intersectSphere(nodes,pnt,maxDist);
  FemNode3d nearest=null;
  double dist=1 + 2 * maxDist;
  for (  BVNode n : nodes) {
    Boundable[] elements=n.getElements();
    for (int i=0; i < elements.length; i++) {
      FemElement3d e=(FemElement3d)elements[i];
      for (int k=0; k < e.numNodes(); k++) {
        double d=e.myNodes[k].getPosition().distance(pnt);
        if (d < dist && d <= maxDist) {
          dist=d;
          nearest=e.myNodes[k];
        }
      }
    }
  }
  return nearest;
}","/** 
 * Finds the nearest node to a specified point that is within a specified maximum distance. If no node is within the specified maximum distance, <code>null</code> is returned.
 * @param pnt Point for which the nearest node should be located
 * @param maxDist Maximum distance that the node must be from thepoint. If <code>maxDist</code> &lt; 0, then <code>null</code> will be returned.
 * @return Nearest point within the prescribed distance, or <code>null</code>if there is no such point
 */
public FemNode3d findNearestNode(Point3d pnt,double maxDist){
  if (maxDist < 0) {
    return null;
  }
  BVTree bvtree=getBVTree();
  ArrayList<BVNode> nodes=new ArrayList<BVNode>();
  bvtree.intersectSphere(nodes,pnt,maxDist);
  FemNode3d nearest=null;
  double dist=1 + 2 * maxDist;
  for (  BVNode n : nodes) {
    Boundable[] elements=n.getElements();
    for (int i=0; i < elements.length; i++) {
      FemElement3d e=(FemElement3d)elements[i];
      for (int k=0; k < e.numNodes(); k++) {
        double d=e.myNodes[k].getPosition().distance(pnt);
        if (d < dist && d <= maxDist) {
          dist=d;
          nearest=e.myNodes[k];
        }
      }
    }
  }
  return nearest;
}"
70952,"/** 
 * Adds pressure stiffness to the matrix Kij via the formula <pre> Kij = Bi^T D Bj </pre> where gi and gj are the gradients for shape functions i and j, Bi and Bj are the B matrices formed from gi and gj, and D is created from the pressure p according to D_ii = -p and D_ij = p for i != j and i, j < 3.
 */
public static void addPressureStiffness(Matrix3d K,Vector3d gi,double p,Vector3d gj,double dv){
  double gjx=p * gj.x * dv;
  double gjy=p * gj.y * dv;
  double gjz=p * gj.z * dv;
  double gix=gi.x;
  double giy=gi.y;
  double giz=gi.z;
  double diag=-gix * gjx - giy * gjy - giz * gjz;
synchronized (K) {
    K.m00+=diag;
    K.m01+=gix * gjy - giy * gjx;
    K.m02+=gix * gjz - giz * gjx;
    K.m10+=giy * gjx - gix * gjy;
    K.m11+=diag;
    K.m12+=giy * gjz - giz * gjy;
    K.m20+=giz * gjx - gix * gjz;
    K.m21+=giz * gjy - giy * gjz;
    K.m22+=diag;
  }
}","/** 
 * Adds pressure stiffness to the matrix Kij via the formula <pre> Kij = Bi^T D Bj </pre> where gi and gj are the gradients for shape functions i and j, Bi and Bj are the B matrices formed from gi and gj, and D is created from the pressure p according to D_ii = -p and D_ij = p for i != j and i, j &lt; 3.
 */
public static void addPressureStiffness(Matrix3d K,Vector3d gi,double p,Vector3d gj,double dv){
  double gjx=p * gj.x * dv;
  double gjy=p * gj.y * dv;
  double gjz=p * gj.z * dv;
  double gix=gi.x;
  double giy=gi.y;
  double giz=gi.z;
  double diag=-gix * gjx - giy * gjy - giz * gjz;
synchronized (K) {
    K.m00+=diag;
    K.m01+=gix * gjy - giy * gjx;
    K.m02+=gix * gjz - giz * gjx;
    K.m10+=giy * gjx - gix * gjy;
    K.m11+=diag;
    K.m12+=giy * gjz - giz * gjy;
    K.m20+=giz * gjx - gix * gjz;
    K.m21+=giz * gjy - giy * gjz;
    K.m22+=diag;
  }
}"
70953,"/** 
 * Returns true if the selection list contains a set of components & for which collisions can be set.
 */
public boolean containsCollidableSelection(LinkedList<ModelComponent> selection){
  int numRigidBodies=0;
  for (  ModelComponent c : selection) {
    if (!(c instanceof Collidable)) {
      return false;
    }
 else     if (c instanceof RigidBody) {
      numRigidBodies++;
    }
  }
  System.out.println(""String_Node_Str"" + numRigidBodies);
  if (numRigidBodies == selection.size()) {
    return numRigidBodies >= 2;
  }
 else {
    return true;
  }
}","/** 
 * Returns true if the selection list contains a set of components &amp; for which collisions can be set.
 */
public boolean containsCollidableSelection(LinkedList<ModelComponent> selection){
  int numRigidBodies=0;
  for (  ModelComponent c : selection) {
    if (!(c instanceof Collidable)) {
      return false;
    }
 else     if (c instanceof RigidBody) {
      numRigidBodies++;
    }
  }
  System.out.println(""String_Node_Str"" + numRigidBodies);
  if (numRigidBodies == selection.size()) {
    return numRigidBodies >= 2;
  }
 else {
    return true;
  }
}"
70954,"/** 
 * Create inequality constraints A >= b from bounds lb and ub
 */
public void createBoundConstraints(MatrixNd A,VectorNd b,VectorNd lb,VectorNd ub){
  A.setIdentity();
  int idx=0;
  if (lb != null) {
    for (int i=0; i < lb.size(); i++) {
      A.set(idx,i,1.0);
      b.set(idx++,lb.get(i));
    }
  }
  if (ub != null) {
    for (int i=0; i < ub.size(); i++) {
      A.set(idx,i,-1.0);
      b.set(idx++,-ub.get(i));
    }
  }
}","/** 
 * Create inequality constraints A &gt;= b from bounds lb and ub
 */
public void createBoundConstraints(MatrixNd A,VectorNd b,VectorNd lb,VectorNd ub){
  A.setIdentity();
  int idx=0;
  if (lb != null) {
    for (int i=0; i < lb.size(); i++) {
      A.set(idx,i,1.0);
      b.set(idx++,lb.get(i));
    }
  }
  if (ub != null) {
    for (int i=0; i < ub.size(); i++) {
      A.set(idx,i,-1.0);
      b.set(idx++,-ub.get(i));
    }
  }
}"
70955,"/** 
 * Solves the Quadratic Program of the form: min { x^T*Q*x + x^T*L }, subject to A*x <= b, Aeq*x = beq
 * @return x
 */
public VectorNd solve(double t0,double t1){
  Q.setZero();
  P.setZero();
  for (  QPTerm term : myCostTerms) {
    term.getQP(Q,P,t0,t1);
  }
  int rowoff=0;
  for (  LeastSquaresTerm term : myInequalityTerms) {
    term.getTerm(A,b,rowoff,t0,t1);
  }
  rowoff=0;
  for (  LeastSquaresTerm term : myEqualityTerms) {
    term.getTerm(Aeq,beq,rowoff,t0,t1);
  }
  try {
    if (Aeq.rowSize() == 0 || beq.size() == 0) {
      mySolver.solve(x,Q,P,A,b);
    }
 else {
      Status qpStatus=mySolver.solve(x,Q,P,A,b,Aeq,beq);
      if (qpStatus != Status.SOLVED) {
        System.err.println(""String_Node_Str"" + qpStatus.toString());
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return x;
}","/** 
 * Solves the Quadratic Program of the form: min { x^T*Q*x + x^T*L }, subject to A*x &lt;= b, Aeq*x = beq
 * @return x
 */
public VectorNd solve(double t0,double t1){
  Q.setZero();
  P.setZero();
  for (  QPTerm term : myCostTerms) {
    term.getQP(Q,P,t0,t1);
  }
  int rowoff=0;
  for (  LeastSquaresTerm term : myInequalityTerms) {
    term.getTerm(A,b,rowoff,t0,t1);
  }
  rowoff=0;
  for (  LeastSquaresTerm term : myEqualityTerms) {
    term.getTerm(Aeq,beq,rowoff,t0,t1);
  }
  try {
    if (Aeq.rowSize() == 0 || beq.size() == 0) {
      mySolver.solve(x,Q,P,A,b);
    }
 else {
      Status qpStatus=mySolver.solve(x,Q,P,A,b,Aeq,beq);
      if (qpStatus != Status.SOLVED) {
        System.err.println(""String_Node_Str"" + qpStatus.toString());
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return x;
}"
70956,"/** 
 * Computes <pre> T y -= G  x </pre> where y and x are vectors associated with master and slave components, respectively, and G is the constraint matrix for the attachment.
 * @param ybuf buffer into which to store result
 * @param yoff offset into ybuf
 * @param xbuf buffer containing right hand side vector
 * @param xoff offset into xbuf
 * @param B matrix associated with a slave component
 * @param idx master component index
 */
protected abstract void mulSubGT(double[] ybuf,int yoff,double[] xbuf,int xoff,int idx);","/** 
 * Computes <pre> T y -= G  x </pre> where y and x are vectors associated with master and slave components, respectively, and G is the constraint matrix for the attachment.
 * @param ybuf buffer into which to store result
 * @param yoff offset into ybuf
 * @param xbuf buffer containing right hand side vector
 * @param xoff offset into xbuf
 * @param idx master component index
 */
protected abstract void mulSubGT(double[] ybuf,int yoff,double[] xbuf,int xoff,int idx);"
70957,"/** 
 * Returns the current velocity of the attached frame, in frame coordinates. Also optionally returns the velocity derivative term, defined by <pre> \dot J velm <pre> where <code>J</code> is the matrix that maps master velocities to the attached frame velocity (in frame coordinates), and <code>velm</code> are the master velocities.
 * @param vel used to return current frame velocity
 * @param dvel if not <code>null</code>, returns the velocity derivative term
 */
public abstract void getCurrentVel(Twist vel,Twist dvel);","/** 
 * Returns the current velocity of the attached frame, in frame coordinates. Also optionally returns the velocity derivative term, defined by <pre> \dot J velm </pre> where <code>J</code> is the matrix that maps master velocities to the attached frame velocity (in frame coordinates), and <code>velm</code> are the master velocities.
 * @param vel used to return current frame velocity
 * @param dvel if not <code>null</code>, returns the velocity derivative term
 */
public abstract void getCurrentVel(Twist vel,Twist dvel);"
70958,"/** 
 * Returns the collision behavior for a specified pair of collidables <code>a</code> and <code>b</code>. Generic designations (such as   {@link Collidable#RigidBody}) are not allowed. The returned behavior is the current effective behavior resulting from the application of all default and explicit collision behavior settings. <p> If <code>a</code> or <i><code>b</code> contain sub-collidables, then if a consistent collision behavior is found amount all pairs of sub-collidables, that behavior is returned; otherwise, <code>null</code> is returned. If <code>a</code> equals <i><code>b</code>, then this method searches for a consistent collision behavior among all sub-collidables of <code>a</code> whose   {@link Collidable#getCollidable getCollidable()}method returns <code>Colidability.ALL</code> or <code>Colidability.INTERNAL</code>.
 * @param a first collidable
 * @param b second collidable
 * @return behavior for this pair of collidables.
 */
public CollisionBehavior getCollisionBehavior(Collidable a,Collidable b){
  return myCollisionManager.getBehavior(a,b);
}","/** 
 * Returns the collision behavior for a specified pair of collidables <code>a</code> and <code>b</code>. Generic designations (such as   {@link Collidable#RigidBody}) are not allowed. The returned behavior is the current effective behavior resulting from the application of all default and explicit collision behavior settings. <p> If <code>a</code> or <code>b</code> contain sub-collidables, then if a consistent collision behavior is found amount all pairs of sub-collidables, that behavior is returned; otherwise, <code>null</code> is returned. If <code>a</code> equals <code>b</code>, then this method searches for a consistent collision behavior among all sub-collidables of <code>a</code> whose   {@link Collidable#getCollidable getCollidable()}method returns <code>Colidability.ALL</code> or <code>Colidability.INTERNAL</code>.
 * @param a first collidable
 * @param b second collidable
 * @return behavior for this pair of collidables.
 */
public CollisionBehavior getCollisionBehavior(Collidable a,Collidable b){
  return myCollisionManager.getBehavior(a,b);
}"
70959,"/** 
 * Removes all dependencies with have very low weights ( |w| <= tol )
 * @return true if modified
 */
public boolean reduceDependencies(double tol);","/** 
 * Removes all dependencies with have very low weights ( |w| &lt;= tol )
 * @return true if modified
 */
public boolean reduceDependencies(double tol);"
70960,"/** 
 * Attempts to scan and store a specific set of property values for a specified host. Checks if the current token is a word  matching one of the specified property names.  If so, scan either '=' or ':' and the following property value, store the property name and value in the token  queue using a <code>StrinToken</code> and an <code>ObjectToken</code>,  and return <code>true</code>. Otherwise, return <code>false</code>. <p> This method is intended for handling property values which must be set in the <i>post-scan</i> stage after references have been set. 
 * @param rtok input token stream
 * @param host host containing the properties
 * @param propNames names of properties to match
 * @param tokens token queue for postscan
 * @return <core>true</code> if a property value was scannedand stored.
 * @throws IOException
 */
public static boolean scanAndStorePropertyValues(ReaderTokenizer rtok,HasProperties host,String[] propNames,Deque<ScanToken> tokens) throws IOException {
  if (rtok.ttype == TT_WORD) {
    for (int i=0; i < propNames.length; i++) {
      if (rtok.sval.equals(propNames[i])) {
        tokens.offer(new StringToken(rtok.sval,rtok.lineno()));
        Object val=scanPropertyValue(rtok,host,propNames[i]);
        tokens.offer(new ObjectToken(val));
        return true;
      }
    }
  }
  return false;
}","/** 
 * Attempts to scan and store a specific set of property values for a specified host. Checks if the current token is a word  matching one of the specified property names.  If so, scan either '=' or ':' and the following property value, store the property name and value in the token  queue using a <code>StrinToken</code> and an <code>ObjectToken</code>,  and return <code>true</code>. Otherwise, return <code>false</code>. <p> This method is intended for handling property values which must be set in the <i>post-scan</i> stage after references have been set. 
 * @param rtok input token stream
 * @param host host containing the properties
 * @param propNames names of properties to match
 * @param tokens token queue for postscan
 * @return <code>true</code> if a property value was scannedand stored.
 * @throws IOException
 */
public static boolean scanAndStorePropertyValues(ReaderTokenizer rtok,HasProperties host,String[] propNames,Deque<ScanToken> tokens) throws IOException {
  if (rtok.ttype == TT_WORD) {
    for (int i=0; i < propNames.length; i++) {
      if (rtok.sval.equals(propNames[i])) {
        tokens.offer(new StringToken(rtok.sval,rtok.lineno()));
        Object val=scanPropertyValue(rtok,host,propNames[i]);
        tokens.offer(new ObjectToken(val));
        return true;
      }
    }
  }
  return false;
}"
70961,"/** 
 * Main function Usage: java artisynth.core.moviemaker.AnimatedGifWriter [options] <list of input files> <output file>
 */
public static void main(String[] args) throws Exception {
  DoubleHolder delayHolder=new DoubleHolder(0);
  IntHolder loopHolder=new IntHolder(1);
  String[] left=parseArgs(args,delayHolder,loopHolder);
  if (left == null || left.length < 2) {
    return;
  }
  ArrayList<BufferedImage> imageList=new ArrayList<BufferedImage>(left.length);
  for (int i=0; i < left.length - 1; i++) {
    try {
      BufferedImage image=ImageIO.read(new File(left[i]));
      imageList.add(image);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + left[i] + ""String_Node_Str"");
    }
  }
  String outputFile=left[left.length - 1];
  if (imageList.size() > 0) {
    write(new File(outputFile),imageList,delayHolder.value,loopHolder.value);
  }
}","/** 
 * Main function Usage: java artisynth.core.moviemaker.AnimatedGifWriter [options] &lt;list of input files&gt; &lt;output file&gt;
 */
public static void main(String[] args) throws Exception {
  DoubleHolder delayHolder=new DoubleHolder(0);
  IntHolder loopHolder=new IntHolder(1);
  String[] left=parseArgs(args,delayHolder,loopHolder);
  if (left == null || left.length < 2) {
    return;
  }
  ArrayList<BufferedImage> imageList=new ArrayList<BufferedImage>(left.length);
  for (int i=0; i < left.length - 1; i++) {
    try {
      BufferedImage image=ImageIO.read(new File(left[i]));
      imageList.add(image);
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + left[i] + ""String_Node_Str"");
    }
  }
  String outputFile=left[left.length - 1];
  if (imageList.size() > 0) {
    write(new File(outputFile),imageList,delayHolder.value,loopHolder.value);
  }
}"
70962,"/** 
 * Sets the Timeline track number associated with this probe. The Timeline should use this method to keep the track information current.
 * @param num new track< number
 */
public void setTrack(int num){
  myTrackNum=num;
}","/** 
 * Sets the Timeline track number associated with this probe. The Timeline should use this method to keep the track information current.
 * @param num new track number
 */
public void setTrack(int num){
  myTrackNum=num;
}"
70963,"/** 
 * Set number of lines to scroll up 0 <= offset <= # buffered lines - lines on screen
 */
public void setScrollOffset(int offset){
  myScrollOffset=offset;
  myScrollOffset=Math.max(myScrollOffset,0);
  myScrollOffset=Math.min(myScrollOffset,myNumLines);
}","/** 
 * Set number of lines to scroll up 0 &lt;= offset &lt;= # buffered lines - lines on screen
 */
public void setScrollOffset(int offset){
  myScrollOffset=offset;
  myScrollOffset=Math.max(myScrollOffset,0);
  myScrollOffset=Math.min(myScrollOffset,myNumLines);
}"
70964,"/** 
 * Creates a decoder provided the supplied conversion command
 * @see #setConvertCommand(String)
 */
public DicomImageDecoderImageMagick(String identifyCmd,String convertCmd){
  setCommands(identifyCmd,convertCmd);
}","/** 
 * Creates a decoder provided the supplied conversion command
 */
public DicomImageDecoderImageMagick(String identifyCmd,String convertCmd){
  setCommands(identifyCmd,convertCmd);
}"
70965,"/** 
 * Determines if two bounding boxes with half widths <code>hw1</code> and <code>hw2</code> are disjoint. The first box is assumed to be axis-aligned and centered at the origin, while the coordinate frame of the second box has position and orientation given by <code>p21</code> and <code>R21</code>, respectively. <p> For details on this algorithm, see pg 338 of Game Physics by David Eberly, or ""OBBTree: A Hierarchichal Structure for Rapid Interference Detection"", Gottschalk Lin & Manocha
 */
public static final boolean isDisjoint(Vector3d hw1,Vector3d hw2,RotationMatrix3d R21,Vector3d p21){
  double t;
  double p_x=p21.x;
  if ((t=p_x) < 0)   t=-t;
  double m00=R21.m00;
  double m01=R21.m01;
  double m02=R21.m02;
  double abs00=(m00 >= 0 ? m00 : -m00);
  double abs01=(m01 >= 0 ? m01 : -m01);
  double abs02=(m02 >= 0 ? m02 : -m02);
  if (t > (hw1.x + hw2.x * abs00 + hw2.y * abs01 + hw2.z * abs02))   return true;
  double m10=R21.m10;
  double m20=R21.m20;
  double p_y=p21.y;
  double p_z=p21.z;
  if ((t=p_x * m00 + p_y * m10 + p_z * m20) < 0)   t=-t;
  double abs10=(m10 >= 0 ? m10 : -m10);
  double abs20=(m20 >= 0 ? m20 : -m20);
  if (t > (hw2.x + hw1.x * abs00 + hw1.y * abs10 + hw1.z * abs20))   return true;
  if ((t=p_y) < 0)   t=-t;
  double m11=R21.m11;
  double m12=R21.m12;
  double abs11=(m11 >= 0 ? m11 : -m11);
  double abs12=(m12 >= 0 ? m12 : -m12);
  if (t > (hw1.y + hw2.x * abs10 + hw2.y * abs11 + hw2.z * abs12))   return true;
  if ((t=p_z) < 0)   t=-t;
  double m21=R21.m21;
  double m22=R21.m22;
  double abs21=(m21 >= 0 ? m21 : -m21);
  double abs22=(m22 >= 0 ? m22 : -m22);
  if (t > (hw1.z + hw2.x * abs20 + hw2.y * abs21 + hw2.z * abs22))   return true;
  if ((t=p_x * m01 + p_y * m11 + p_z * m21) < 0)   t=-t;
  if (t > (hw2.y + hw1.x * abs01 + hw1.y * abs11 + hw1.z * abs21))   return true;
  if ((t=p_x * m02 + p_y * m12 + p_z * m22) < 0)   t=-t;
  if (t > (hw2.z + hw1.x * abs02 + hw1.y * abs12 + hw1.z * abs22))   return true;
  if ((t=p_z * m10 - p_y * m20) < 0)   t=-t;
  if (t > (hw1.y * abs20 + hw1.z * abs10 + hw2.y * abs02 + hw2.z * abs01))   return true;
  if ((t=p_z * m11 - p_y * m21) < 0)   t=-t;
  if (t > (hw1.y * abs21 + hw1.z * abs11 + hw2.x * abs02 + hw2.z * abs00))   return true;
  if ((t=p_z * m12 - p_y * m22) < 0)   t=-t;
  if (t > (hw1.y * abs22 + hw1.z * abs12 + hw2.x * abs01 + hw2.y * abs00))   return true;
  if ((t=p_x * m20 - p_z * m00) < 0)   t=-t;
  if (t > (hw1.x * abs20 + hw1.z * abs00 + hw2.y * abs12 + hw2.z * abs11))   return true;
  if ((t=p_x * m21 - p_z * m01) < 0)   t=-t;
  if (t > (hw1.x * abs21 + hw1.z * abs01 + hw2.x * abs12 + hw2.z * abs10))   return true;
  if ((t=p_x * m22 - p_z * m02) < 0)   t=-t;
  if (t > (hw1.x * abs22 + hw1.z * abs02 + hw2.x * abs11 + hw2.y * abs10))   return true;
  if ((t=p_y * m00 - p_x * m10) < 0)   t=-t;
  if (t > (hw1.x * abs10 + hw1.y * abs00 + hw2.y * abs22 + hw2.z * abs21))   return true;
  if ((t=p_y * m01 - p_x * m11) < 0)   t=-t;
  if (t > (hw1.x * abs11 + hw1.y * abs01 + hw2.x * abs22 + hw2.z * abs20))   return true;
  if ((t=p_y * m02 - p_x * m12) < 0)   t=-t;
  if (t > (hw1.x * abs12 + hw1.y * abs02 + hw2.x * abs21 + hw2.y * abs20))   return true;
  return false;
}","/** 
 * Determines if two bounding boxes with half widths <code>hw1</code> and <code>hw2</code> are disjoint. The first box is assumed to be axis-aligned and centered at the origin, while the coordinate frame of the second box has position and orientation given by <code>p21</code> and <code>R21</code>, respectively. <p> For details on this algorithm, see pg 338 of Game Physics by David Eberly, or ""OBBTree: A Hierarchichal Structure for Rapid Interference Detection"", Gottschalk Lin &amp; Manocha
 */
public static final boolean isDisjoint(Vector3d hw1,Vector3d hw2,RotationMatrix3d R21,Vector3d p21){
  double t;
  double p_x=p21.x;
  if ((t=p_x) < 0)   t=-t;
  double m00=R21.m00;
  double m01=R21.m01;
  double m02=R21.m02;
  double abs00=(m00 >= 0 ? m00 : -m00);
  double abs01=(m01 >= 0 ? m01 : -m01);
  double abs02=(m02 >= 0 ? m02 : -m02);
  if (t > (hw1.x + hw2.x * abs00 + hw2.y * abs01 + hw2.z * abs02))   return true;
  double m10=R21.m10;
  double m20=R21.m20;
  double p_y=p21.y;
  double p_z=p21.z;
  if ((t=p_x * m00 + p_y * m10 + p_z * m20) < 0)   t=-t;
  double abs10=(m10 >= 0 ? m10 : -m10);
  double abs20=(m20 >= 0 ? m20 : -m20);
  if (t > (hw2.x + hw1.x * abs00 + hw1.y * abs10 + hw1.z * abs20))   return true;
  if ((t=p_y) < 0)   t=-t;
  double m11=R21.m11;
  double m12=R21.m12;
  double abs11=(m11 >= 0 ? m11 : -m11);
  double abs12=(m12 >= 0 ? m12 : -m12);
  if (t > (hw1.y + hw2.x * abs10 + hw2.y * abs11 + hw2.z * abs12))   return true;
  if ((t=p_z) < 0)   t=-t;
  double m21=R21.m21;
  double m22=R21.m22;
  double abs21=(m21 >= 0 ? m21 : -m21);
  double abs22=(m22 >= 0 ? m22 : -m22);
  if (t > (hw1.z + hw2.x * abs20 + hw2.y * abs21 + hw2.z * abs22))   return true;
  if ((t=p_x * m01 + p_y * m11 + p_z * m21) < 0)   t=-t;
  if (t > (hw2.y + hw1.x * abs01 + hw1.y * abs11 + hw1.z * abs21))   return true;
  if ((t=p_x * m02 + p_y * m12 + p_z * m22) < 0)   t=-t;
  if (t > (hw2.z + hw1.x * abs02 + hw1.y * abs12 + hw1.z * abs22))   return true;
  if ((t=p_z * m10 - p_y * m20) < 0)   t=-t;
  if (t > (hw1.y * abs20 + hw1.z * abs10 + hw2.y * abs02 + hw2.z * abs01))   return true;
  if ((t=p_z * m11 - p_y * m21) < 0)   t=-t;
  if (t > (hw1.y * abs21 + hw1.z * abs11 + hw2.x * abs02 + hw2.z * abs00))   return true;
  if ((t=p_z * m12 - p_y * m22) < 0)   t=-t;
  if (t > (hw1.y * abs22 + hw1.z * abs12 + hw2.x * abs01 + hw2.y * abs00))   return true;
  if ((t=p_x * m20 - p_z * m00) < 0)   t=-t;
  if (t > (hw1.x * abs20 + hw1.z * abs00 + hw2.y * abs12 + hw2.z * abs11))   return true;
  if ((t=p_x * m21 - p_z * m01) < 0)   t=-t;
  if (t > (hw1.x * abs21 + hw1.z * abs01 + hw2.x * abs12 + hw2.z * abs10))   return true;
  if ((t=p_x * m22 - p_z * m02) < 0)   t=-t;
  if (t > (hw1.x * abs22 + hw1.z * abs02 + hw2.x * abs11 + hw2.y * abs10))   return true;
  if ((t=p_y * m00 - p_x * m10) < 0)   t=-t;
  if (t > (hw1.x * abs10 + hw1.y * abs00 + hw2.y * abs22 + hw2.z * abs21))   return true;
  if ((t=p_y * m01 - p_x * m11) < 0)   t=-t;
  if (t > (hw1.x * abs11 + hw1.y * abs01 + hw2.x * abs22 + hw2.z * abs20))   return true;
  if ((t=p_y * m02 - p_x * m12) < 0)   t=-t;
  if (t > (hw1.x * abs12 + hw1.y * abs02 + hw2.x * abs21 + hw2.y * abs20))   return true;
  return false;
}"
70966,"public static ExcitationSourceList updateReferences(ModelComponent host,ExcitationSourceList sources,boolean undo,Deque<Object> undoInfo){
  if (undo) {
    Object obj=undoInfo.removeFirst();
    if (obj != ModelComponentBase.NULL_OBJ) {
      ListRemove<ExcitationSource> remove=(ListRemove<ExcitationSource>)obj;
      if (sources == null) {
        sources=(ExcitationSourceList)remove.getList();
      }
      remove.undo();
    }
  }
 else   if (sources != null) {
    ListRemove<ExcitationSource> remove=null;
    for (int i=0; i < sources.size(); i++) {
      if (!ComponentUtils.isConnected(host,sources.get(i).myComp)) {
        if (remove == null) {
          remove=new ListRemove<ExcitationSource>(sources);
        }
        remove.requestRemove(i);
      }
    }
    if (remove != null) {
      remove.remove();
      if (sources.size() == 0) {
        sources=null;
      }
      undoInfo.addLast(remove);
    }
 else {
      undoInfo.addLast(ModelComponentBase.NULL_OBJ);
    }
  }
  return sources;
}","public static ExcitationSourceList updateReferences(ModelComponent host,ExcitationSourceList sources,boolean undo,Deque<Object> undoInfo){
  if (undo) {
    Object obj=undoInfo.removeFirst();
    if (obj != ModelComponentBase.NULL_OBJ) {
      ListRemove<ExcitationSource> remove=(ListRemove<ExcitationSource>)obj;
      if (sources == null) {
        sources=(ExcitationSourceList)remove.getList();
      }
      remove.undo();
    }
  }
 else {
    ListRemove<ExcitationSource> remove=null;
    if (sources != null) {
      for (int i=0; i < sources.size(); i++) {
        if (!ComponentUtils.isConnected(host,sources.get(i).myComp)) {
          if (remove == null) {
            remove=new ListRemove<ExcitationSource>(sources);
          }
          remove.requestRemove(i);
        }
      }
    }
    if (remove != null) {
      remove.remove();
      if (sources.size() == 0) {
        sources=null;
      }
      undoInfo.addLast(remove);
    }
 else {
      undoInfo.addLast(ModelComponentBase.NULL_OBJ);
    }
  }
  return sources;
}"
70967,"public Texture getTexture(String name,byte[] bytes,int width,int height,int srcPixelFormat,int target,int dstPixelFormat,int minFilter,int magFilter){
  int textureID=createTextureID();
  Texture texture=new Texture(target,textureID);
  gl.glBindTexture(target,textureID);
  texture.setWidth(width);
  texture.setHeight(height);
  if (target == GL2.GL_TEXTURE_2D) {
    gl.glTexParameteri(target,GL2.GL_TEXTURE_MIN_FILTER,minFilter);
    gl.glTexParameteri(target,GL2.GL_TEXTURE_MAG_FILTER,magFilter);
  }
  ByteBuffer buffer=ByteBuffer.allocate(bytes.length);
  buffer.put(bytes);
  buffer.position(0);
  gl.glTexImage2D(target,0,dstPixelFormat,width,height,0,srcPixelFormat,GL2.GL_UNSIGNED_BYTE,buffer);
  return texture;
}","public Texture getTexture(String name,byte[] bytes,int width,int height,int srcPixelFormat,int target,int dstPixelFormat,int minFilter,int magFilter){
  int textureID=createTextureID();
  Texture texture=new Texture(target,textureID);
  gl.glBindTexture(target,textureID);
  texture.setWidth(width);
  texture.setHeight(height);
  if (target == GL2.GL_TEXTURE_2D) {
    gl.glTexParameteri(target,GL2.GL_TEXTURE_MIN_FILTER,minFilter);
    gl.glTexParameteri(target,GL2.GL_TEXTURE_MAG_FILTER,magFilter);
  }
  ByteBuffer buffer=ByteBuffer.allocateDirect(bytes.length);
  buffer.put(bytes);
  buffer.rewind();
  if (width % 4 != 0) {
    gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT,1);
  }
  gl.glTexImage2D(target,0,dstPixelFormat,width,height,0,srcPixelFormat,GL2.GL_UNSIGNED_BYTE,buffer);
  if (width % 4 != 0) {
    gl.glPixelStorei(GL.GL_UNPACK_ALIGNMENT,4);
  }
  return texture;
}"
70968,"public Map<Vertex3d,Vector3d> getContactImpulses(){
  LinkedHashMap<Vertex3d,Vector3d> map=new LinkedHashMap<Vertex3d,Vector3d>();
  for (  ContactConstraint c : myBilaterals0.values()) {
    accumulateImpulses(map,c.myCpnt0,c.getNormal(),c.getImpulse());
  }
  for (  ContactConstraint c : myBilaterals1.values()) {
    accumulateImpulses(map,c.myCpnt1,c.getNormal(),-c.getImpulse());
  }
  return map;
}","public Map<Vertex3d,Vector3d> getContactImpulses(CollidableBody colA){
  LinkedHashMap<Vertex3d,Vector3d> map=new LinkedHashMap<Vertex3d,Vector3d>();
  for (  ContactConstraint c : myBilaterals0.values()) {
    if (colA == myCollidable0) {
      accumulateImpulses(map,c.myCpnt0,c.getNormal(),c.getImpulse());
    }
 else {
      accumulateImpulses(map,c.myCpnt1,c.getNormal(),-c.getImpulse());
    }
  }
  for (  ContactConstraint c : myBilaterals1.values()) {
    if (colA == myCollidable0) {
      accumulateImpulses(map,c.myCpnt1,c.getNormal(),-c.getImpulse());
    }
 else {
      accumulateImpulses(map,c.myCpnt0,c.getNormal(),c.getImpulse());
    }
  }
  return map;
}"
70969,"/** 
 * Returns a map specifying the contact impulses acting on the CollidableBody <code>colA</code> in response to contact with another CollidableBody <code>colB</code>. This method currently requires that <code>colA</code> is a deformable body. If it is not, or if no collisions are enabled between <code>colA</code> and <code>colB</code>, then <code>null</code> is returned. <p>The map gives the most recently computed impulses acting on each vertex of the collision mesh of <code>colA</code> (this is the same mesh returned by   {@link CollidableBody#getCollisionMesh}). Vertices for which no impulses were computed do not appear in the map. To turn the impulses into forces, one must divide by the current step size. <p>Contact impulses give the forces that arise in order to prevent further interpenetration between <code>colA</code> and <code>colB</code>. They do <i>not</i> include impulses that are computed to separate <code>colA</code> and <code>colB</code> when they initially come into contact.
 * @param colA first collidable
 * @param colB second collidable
 * @return if appropriate, map giving the contact impulses acting on<code>colA</code> in response to <code>colB</code>.
 */
public Map<Vertex3d,Vector3d> getContactImpulses(CollidableBody colA,CollidableBody colB){
  if (!colA.isDeformable()) {
    return null;
  }
  updateHandlers();
  CollisionHandler handler=null;
  for (  CollisionHandler h : myCollisionHandlers) {
    if ((h.myCollidable0 == colA && h.myCollidable1 == colB) || (h.myCollidable0 == colB && h.myCollidable1 == colA)) {
      handler=h;
    }
  }
  if (handler == null) {
    return null;
  }
 else {
    return handler.getContactImpulses();
  }
}","/** 
 * Returns a map specifying the contact impulses acting on the CollidableBody <code>colA</code> in response to contact with another CollidableBody <code>colB</code>. This method currently requires that <code>colA</code> is a deformable body. If it is not, or if no collisions are enabled between <code>colA</code> and <code>colB</code>, then <code>null</code> is returned. <p>The map gives the most recently computed impulses acting on each vertex of the collision mesh of <code>colA</code> (this is the same mesh returned by   {@link CollidableBody#getCollisionMesh}). Vertices for which no impulses were computed do not appear in the map. To turn the impulses into forces, one must divide by the current step size. <p>Contact impulses give the forces that arise in order to prevent further interpenetration between <code>colA</code> and <code>colB</code>. They do <i>not</i> include impulses that are computed to separate <code>colA</code> and <code>colB</code> when they initially come into contact.
 * @param colA first collidable
 * @param colB second collidable
 * @return if appropriate, map giving the contact impulses acting on<code>colA</code> in response to <code>colB</code>.
 */
public Map<Vertex3d,Vector3d> getContactImpulses(CollidableBody colA,CollidableBody colB){
  if (!colA.isDeformable()) {
    return null;
  }
  updateHandlers();
  CollisionHandler handler=null;
  for (  CollisionHandler h : myCollisionHandlers) {
    if ((h.myCollidable0 == colA && h.myCollidable1 == colB) || (h.myCollidable0 == colB && h.myCollidable1 == colA)) {
      handler=h;
    }
  }
  if (handler == null) {
    return null;
  }
 else {
    return handler.getContactImpulses(colA);
  }
}"
70970,"public File cache(URIx uri,File cacheFile,FileTransferMonitor monitor) throws FileSystemException {
  File tmpCacheFile=new File(cacheFile.getAbsolutePath() + TMP_EXTENSION);
  FileObject localTempFile=manager.resolveFile(tmpCacheFile.getAbsolutePath());
  FileObject localCacheFile=manager.resolveFile(cacheFile.getAbsolutePath());
  FileObject remoteFile=null;
  setAuthenticator(fsOpts,null);
  setIdentityFactory(fsOpts,null);
  boolean cancel=false;
  while (remoteFile == null && cancel == false) {
    remoteFile=resolveRemote(uri);
  }
  if (remoteFile == null || !remoteFile.exists()) {
    throw new FileSystemException(""String_Node_Str"" + uri.toString() + ""String_Node_Str"",new FileNotFoundException(""String_Node_Str"" + uri.toString() + ""String_Node_Str""));
  }
  if (monitor != null) {
    monitor.monitor(localTempFile,remoteFile,-1,cacheFile.getName());
    monitor.start();
    monitor.fireStartEvent(localTempFile);
  }
  try {
    if (remoteFile.isFile()) {
      localTempFile.copyFrom(remoteFile,Selectors.SELECT_SELF);
    }
 else     if (remoteFile.isFolder()) {
      localTempFile.copyFrom(remoteFile,Selectors.SELECT_SELF_AND_CHILDREN);
    }
    if (monitor != null) {
      monitor.fireCompleteEvent(localTempFile);
    }
  }
 catch (  Exception e) {
    localTempFile.delete();
    throw new RuntimeException(""String_Node_Str"" + remoteFile.getURL() + ""String_Node_Str""+ localTempFile.getURL(),e);
  }
 finally {
    localTempFile.close();
    remoteFile.close();
    if (monitor != null) {
      monitor.release(localTempFile);
      monitor.stop();
    }
  }
  try {
    if (tmpCacheFile.isDirectory()) {
      SafeFileUtils.moveDirectory(tmpCacheFile,cacheFile);
    }
 else {
      SafeFileUtils.moveFile(tmpCacheFile,cacheFile);
    }
  }
 catch (  Exception e) {
    localCacheFile.delete();
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + localCacheFile.getURL(),e);
  }
  return cacheFile;
}","public File cache(URIx uri,File cacheFile,FileTransferMonitor monitor) throws FileSystemException {
  File tmpCacheFile=new File(cacheFile.getAbsolutePath() + TMP_EXTENSION);
  URIx cacheURI=new URIx(cacheFile.getAbsoluteFile());
  URIx tmpCacheURI=new URIx(tmpCacheFile.getAbsoluteFile());
  FileObject localTempFile=manager.resolveFile(tmpCacheURI.toString(true));
  FileObject localCacheFile=manager.resolveFile(cacheURI.toString(true));
  FileObject remoteFile=null;
  setAuthenticator(fsOpts,null);
  setIdentityFactory(fsOpts,null);
  boolean cancel=false;
  while (remoteFile == null && cancel == false) {
    remoteFile=resolveRemote(uri);
  }
  if (remoteFile == null || !remoteFile.exists()) {
    throw new FileSystemException(""String_Node_Str"" + uri.toString() + ""String_Node_Str"",new FileNotFoundException(""String_Node_Str"" + uri.toString() + ""String_Node_Str""));
  }
  if (monitor != null) {
    monitor.monitor(localTempFile,remoteFile,-1,cacheFile.getName());
    monitor.start();
    monitor.fireStartEvent(localTempFile);
  }
  try {
    if (remoteFile.isFile()) {
      localTempFile.copyFrom(remoteFile,Selectors.SELECT_SELF);
    }
 else     if (remoteFile.isFolder()) {
      localTempFile.copyFrom(remoteFile,Selectors.SELECT_SELF_AND_CHILDREN);
    }
    if (monitor != null) {
      monitor.fireCompleteEvent(localTempFile);
    }
  }
 catch (  Exception e) {
    localTempFile.delete();
    throw new RuntimeException(""String_Node_Str"" + remoteFile.getURL() + ""String_Node_Str""+ localTempFile.getURL(),e);
  }
 finally {
    localTempFile.close();
    remoteFile.close();
    if (monitor != null) {
      monitor.release(localTempFile);
      monitor.stop();
    }
  }
  try {
    if (tmpCacheFile.isDirectory()) {
      SafeFileUtils.moveDirectory(tmpCacheFile,cacheFile);
    }
 else {
      SafeFileUtils.moveFile(tmpCacheFile,cacheFile);
    }
  }
 catch (  Exception e) {
    localCacheFile.delete();
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + localCacheFile.getURL(),e);
  }
  return cacheFile;
}"
70971,"private static URIx mergeExtension(URIx base,String extension){
  URIx merged=new URIx(base);
  if (merged.isZip()) {
    String fn=base.getFragment() + extension;
    merged.setFragment(fn);
  }
 else {
    String fn=base.getPath() + extension;
    merged.setPath(fn);
  }
  return merged;
}","private static URIx mergeExtension(URIx base,String extension){
  URIx merged=new URIx(base);
  if (merged.isZip()) {
    String fn=base.getFragment() + extension;
    merged.setFragment(fn);
  }
 else {
    String fn=base.getPath(false) + extension;
    merged.setPath(fn);
  }
  return merged;
}"
70972,"public String getPath(boolean encoded){
  if (encoded) {
    return percentEncode(path,PATH_RESERVED);
  }
  return percentDecode(path);
}","public String getPath(boolean encoded){
  if (encoded) {
    return percentEncode(path,PATH_RESERVED);
  }
  return path;
}"
70973,"public String getUserName(boolean encoded){
  if (encoded) {
    return percentEncode(userName,STANDARD_RESERVED);
  }
  return percentDecode(userName);
}","public String getUserName(boolean encoded){
  if (encoded) {
    return percentEncode(userName,STANDARD_RESERVED);
  }
  return userName;
}"
70974,"public String getHost(boolean encoded){
  if (encoded) {
    return percentEncode(host,STANDARD_RESERVED);
  }
  return percentDecode(host);
}","public String getHost(boolean encoded){
  if (encoded) {
    return percentEncode(host,STANDARD_RESERVED);
  }
  return host;
}"
70975,"public String getQuery(boolean encoded){
  if (encoded) {
    return percentEncode(query,QUERY_RESERVED);
  }
  return percentDecode(query);
}","public String getQuery(boolean encoded){
  if (encoded) {
    return percentEncode(query,QUERY_RESERVED);
  }
  return query;
}"
70976,"public String getFragment(boolean encoded){
  if (encoded) {
    if (isZip()) {
      return fragment;
    }
    return percentEncode(fragment,FRAGMENT_RESERVED);
  }
  return percentDecode(fragment);
}","public String getFragment(boolean encoded){
  if (encoded) {
    if (isZip()) {
      return fragment;
    }
    return percentEncode(fragment,FRAGMENT_RESERVED);
  }
  return fragment;
}"
70977,"public String getPassword(boolean encoded){
  if (encoded) {
    return percentEncode(password,PASSWORD_RESERVED);
  }
  return percentDecode(password);
}","public String getPassword(boolean encoded){
  if (encoded) {
    return percentEncode(password,PASSWORD_RESERVED);
  }
  return password;
}"
70978,"protected void recomputeWorldBounds(){
  Point3d pnt=new Point3d();
  Point3d pmin=myWorldMinCoords;
  Point3d pmax=myWorldMaxCoords;
  if (myVertices.size() == 0) {
    pmin.set(0,0,0);
    pmax.set(0,0,0);
  }
 else {
    double inf=Double.POSITIVE_INFINITY;
    pmin.set(inf,inf,inf);
    pmax.set(-inf,-inf,-inf);
  }
  for (  Vertex3d vertex : myVertices) {
    if (!myXMeshToWorldIsIdentity) {
      pnt.transform(XMeshToWorld,vertex.pnt);
    }
 else {
      pnt.set(vertex.pnt);
    }
    if (pnt.x > pmax.x) {
      pmax.x=pnt.x;
    }
 else     if (pnt.x < pmin.x) {
      pmin.x=pnt.x;
    }
    if (pnt.y > pmax.y) {
      pmax.y=pnt.y;
    }
 else     if (pnt.y < pmin.y) {
      pmin.y=pnt.y;
    }
    if (pnt.z > pmax.z) {
      pmax.z=pnt.z;
    }
 else     if (pnt.z < pmin.z) {
      pmin.z=pnt.z;
    }
  }
  myWorldBoundsValid=true;
}","protected void recomputeWorldBounds(){
  Point3d pnt=new Point3d();
  Point3d pmin=myWorldMinCoords;
  Point3d pmax=myWorldMaxCoords;
  if (myVertices.size() == 0) {
    pmin.set(0,0,0);
    pmax.set(0,0,0);
  }
 else {
    pmin.set(inf,inf,inf);
    pmax.set(-inf,-inf,-inf);
  }
  for (  Vertex3d vertex : myVertices) {
    if (!myXMeshToWorldIsIdentity) {
      pnt.transform(XMeshToWorld,vertex.pnt);
    }
 else {
      pnt.set(vertex.pnt);
    }
    if (pnt.x > pmax.x) {
      pmax.x=pnt.x;
    }
    if (pnt.x < pmin.x) {
      pmin.x=pnt.x;
    }
    if (pnt.y > pmax.y) {
      pmax.y=pnt.y;
    }
    if (pnt.y < pmin.y) {
      pmin.y=pnt.y;
    }
    if (pnt.z > pmax.z) {
      pmax.z=pnt.z;
    }
    if (pnt.z < pmin.z) {
      pmin.z=pnt.z;
    }
  }
  myWorldBoundsValid=true;
}"
70979,"protected void recomputeLocalBounds(){
  Point3d pmin=myLocalMinCoords;
  Point3d pmax=myLocalMaxCoords;
  if (myVertices.size() == 0) {
    pmin.set(0,0,0);
    pmax.set(0,0,0);
  }
 else {
    double inf=Double.POSITIVE_INFINITY;
    pmin.set(inf,inf,inf);
    pmax.set(-inf,-inf,-inf);
  }
  for (  Vertex3d vertex : myVertices) {
    Point3d pnt=vertex.pnt;
    if (pnt.x > pmax.x) {
      pmax.x=pnt.x;
    }
 else     if (pnt.x < pmin.x) {
      pmin.x=pnt.x;
    }
    if (pnt.y > pmax.y) {
      pmax.y=pnt.y;
    }
 else     if (pnt.y < pmin.y) {
      pmin.y=pnt.y;
    }
    if (pnt.z > pmax.z) {
      pmax.z=pnt.z;
    }
 else     if (pnt.z < pmin.z) {
      pmin.z=pnt.z;
    }
  }
  myLocalBoundsValid=true;
}","protected void recomputeLocalBounds(){
  Point3d pmin=myLocalMinCoords;
  Point3d pmax=myLocalMaxCoords;
  if (myVertices.size() == 0) {
    pmin.set(0,0,0);
    pmax.set(0,0,0);
  }
 else {
    double inf=Double.POSITIVE_INFINITY;
    pmin.set(inf,inf,inf);
    pmax.set(-inf,-inf,-inf);
  }
  for (  Vertex3d vertex : myVertices) {
    Point3d pnt=vertex.pnt;
    if (pnt.x > pmax.x) {
      pmax.x=pnt.x;
    }
    if (pnt.x < pmin.x) {
      pmin.x=pnt.x;
    }
    if (pnt.y > pmax.y) {
      pmax.y=pnt.y;
    }
    if (pnt.y < pmin.y) {
      pmin.y=pnt.y;
    }
    if (pnt.z > pmax.z) {
      pmax.z=pnt.z;
    }
    if (pnt.z < pmin.z) {
      pmin.z=pnt.z;
    }
  }
  myLocalBoundsValid=true;
}"
70980,"/** 
 * Write all waypoint state to the attached file if it exists.
 */
public void save(){
  File file=getAttachedFile();
  if (file != null) {
    try {
      if (isAttachedFileRelative()) {
        file.getParentFile().mkdirs();
      }
      System.out.println(""String_Node_Str"" + file.getName());
      DataOutputStream dos=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));
      dos.writeInt(numValid());
      for (      WayPoint way : myWayPoints) {
        if (way.getState() != null) {
          System.out.println(""String_Node_Str"" + way.getTime());
          dos.writeDouble(way.getTime());
          way.getState().writeBinary(dos);
        }
      }
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + file.getName());
      e.printStackTrace();
    }
  }
}","/** 
 * Write all waypoint state to the attached file if it exists.
 */
public void save(){
  File file=getAttachedFile();
  if (file != null) {
    try {
      if (isAttachedFileRelative()) {
        file.getParentFile().mkdirs();
      }
      System.out.println(""String_Node_Str"" + file.getName());
      DataOutputStream dos=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));
      dos.writeInt(numValid());
      for (      WayPoint way : myWayPoints) {
        if (way.getState() != null) {
          System.out.println(""String_Node_Str"" + way.getTime());
          dos.writeDouble(way.getTime());
          way.getState().writeBinary(dos);
        }
      }
      dos.close();
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + file.getName());
      e.printStackTrace();
    }
  }
}"
70981,"/** 
 * Load waypoint state data from the attached file.
 */
public void load(){
  invalidateAll();
  File file=getAttachedFile();
  if (file != null) {
    if (!file.exists()) {
      System.out.println(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    }
 else {
      try {
        DataInputStream dis=new DataInputStream(new BufferedInputStream(new FileInputStream(file)));
        ListIterator<WayPoint> li=myWayPoints.listIterator();
        int numvalid=dis.readInt();
        for (int i=0; i < numvalid; i++) {
          double time=dis.readDouble();
          WayPoint way=null;
          if (li.hasNext()) {
            while (li.hasNext()) {
              way=li.next();
              if (way.getTime() >= time) {
                break;
              }
            }
            if (TimeBase.equals(way.getTime(),time)) {
            }
 else             if (way.getTime() > time) {
              li.previous();
              way=new WayPoint(time);
              li.add(way);
            }
 else {
              way=new WayPoint(time);
              li.add(way);
            }
          }
 else {
            way=new WayPoint(time);
            li.add(way);
          }
          CompositeState cs=(CompositeState)myRootModel.createState(null);
          cs.readBinary(dis);
          way.setState(cs);
        }
      }
 catch (      IOException e) {
        System.err.println(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}","/** 
 * Load waypoint state data from the attached file.
 */
public void load(){
  invalidateAll();
  File file=getAttachedFile();
  if (file != null) {
    if (!file.exists()) {
      System.out.println(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
    }
 else {
      try {
        DataInputStream dis=new DataInputStream(new BufferedInputStream(new FileInputStream(file)));
        ListIterator<WayPoint> li=myWayPoints.listIterator();
        int numvalid=dis.readInt();
        for (int i=0; i < numvalid; i++) {
          double time=dis.readDouble();
          WayPoint way=null;
          if (li.hasNext()) {
            while (li.hasNext()) {
              way=li.next();
              if (way.getTime() >= time) {
                break;
              }
            }
            if (TimeBase.equals(way.getTime(),time)) {
            }
 else             if (way.getTime() > time) {
              li.previous();
              way=new WayPoint(time);
              li.add(way);
            }
 else {
              way=new WayPoint(time);
              li.add(way);
            }
          }
 else {
            way=new WayPoint(time);
            li.add(way);
          }
          CompositeState cs=(CompositeState)myRootModel.createState(null);
          cs.readBinary(dis);
          way.setState(cs);
        }
        dis.close();
      }
 catch (      IOException e) {
        System.err.println(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}"
70982,"/** 
 * Return an iterator which iterates through 27 cells. Iterates through the 27 cells which include and are adjacent to the cell containing pos.
 * @param pos A position in the centre bin.
 * @return Iterator for 27 bins.
 */
public Iterator<List<T>> getCellsNear(Point3d pos){
  if (!myIndexListInitialized)   setupListsToNeighbours();
  int xIdx=(int)Math.round(pos.x / myGridSpacing);
  int yIdx=(int)Math.round(pos.y / myGridSpacing);
  int zIdx=(int)Math.round(pos.z / myGridSpacing);
  Iterator<List<T>> it=myIndexList.get(new Index(xIdx,yIdx,zIdx)).listIterator();
  return it;
}","/** 
 * Return an iterator which iterates through 27 cells. Iterates through the 27 cells which include and are adjacent to the cell containing pos.
 * @param pos A position in the centre bin.
 * @return Iterator for 27 bins.
 */
public Iterator<List<T>> getCellsNear(Point3d pos){
  if (!myIndexListInitialized)   setupListsToNeighbours();
  int xIdx=(int)Math.round(pos.x / myGridSpacing);
  int yIdx=(int)Math.round(pos.y / myGridSpacing);
  int zIdx=(int)Math.round(pos.z / myGridSpacing);
  List<List<T>> list=myIndexList.get(new Index(xIdx,yIdx,zIdx));
  if (list == null) {
    return getCellsNearOld(pos);
  }
  Iterator<List<T>> it=list.listIterator();
  return it;
}"
70983,"public void componentChanged(ComponentChangeEvent e){
  if (e.getCode() == ComponentChangeEvent.Code.STRUCTURE_CHANGED || e.getCode() == ComponentChangeEvent.Code.DYNAMIC_ACTIVITY_CHANGED) {
    boolean invalidateWaypoints=false;
    RootModel root=getRootModel();
    if (root != null) {
      invalidateWaypoints=changeAffectsWaypoints(root,e);
      if (invalidateWaypoints) {
        root.getWayPoints().invalidateAfterTime(0);
      }
    }
    ModelComponent c=e.getComponent();
    if (myTimeline != null) {
      if (root != null && c == root.getWayPoints()) {
        myTimeline.requestUpdateWidgets();
      }
 else {
        myTimeline.requestUpdateDisplay();
      }
    }
    if (e.getCode() == ComponentChangeEvent.Code.STRUCTURE_CHANGED) {
      if (c != null && c instanceof CompositeComponent && myFrame != null) {
        myFrame.getNavPanel().updateStructure(c);
        if (root != null && (c == root.getInputProbes() || c == root.getOutputProbes())) {
          myTimeline.updateProbes();
        }
      }
    }
    if (invalidateWaypoints && !myScheduler.isPlaying()) {
      myScheduler.invalidateInitialState();
    }
  }
 else   if (e.getCode() == ComponentChangeEvent.Code.NAME_CHANGED) {
    ModelComponent c=e.getComponent();
    if (c.getParent() != null && myFrame != null) {
      myFrame.getNavPanel().updateStructure(c.getParent());
    }
 else {
      myFrame.getNavPanel().updateStructure(c);
    }
  }
 else   if (e.getCode() == ComponentChangeEvent.Code.PROPERTY_CHANGED) {
    PropertyChangeEvent pe=(PropertyChangeEvent)e;
    ModelComponent c=e.getComponent();
    if (c == getRootModel()) {
      if (pe.getPropertyName().equals(""String_Node_Str"")) {
        doSetMaxStep(getRootModel().getMaxStepSize());
      }
 else       if (pe.getPropertyName().equals(""String_Node_Str"")) {
        if (myViewerManager != null) {
          myViewerManager.resetViewers(getRootModel().getDefaultViewOrientation());
        }
      }
    }
 else     if (pe.getPropertyName().startsWith(""String_Node_Str"")) {
      if (myFrame != null) {
        myFrame.getNavPanel().updateStructure(e.getComponent());
      }
    }
  }
 else   if (e.getCode() == ComponentChangeEvent.Code.GEOMETRY_CHANGED) {
    if (!getScheduler().isPlaying()) {
      rerender();
    }
  }
}","public void componentChanged(ComponentChangeEvent e){
  if (e.getCode() == ComponentChangeEvent.Code.STRUCTURE_CHANGED || e.getCode() == ComponentChangeEvent.Code.DYNAMIC_ACTIVITY_CHANGED) {
    boolean invalidateWaypoints=false;
    RootModel root=getRootModel();
    if (root != null) {
      invalidateWaypoints=changeAffectsWaypoints(root,e);
      if (invalidateWaypoints) {
        root.getWayPoints().invalidateAfterTime(0);
      }
    }
    ModelComponent c=e.getComponent();
    if (myTimeline != null) {
      if (root != null && c == root.getWayPoints()) {
        myTimeline.requestUpdateWidgets();
      }
 else {
        myTimeline.requestUpdateDisplay();
      }
    }
    if (e.getCode() == ComponentChangeEvent.Code.STRUCTURE_CHANGED) {
      if (c != null && c instanceof CompositeComponent && myFrame != null) {
        myFrame.getNavPanel().updateStructure(c);
        if (root != null && (c == root.getInputProbes() || c == root.getOutputProbes())) {
          myTimeline.updateProbes();
        }
      }
    }
    if (invalidateWaypoints && !myScheduler.isPlaying()) {
      myScheduler.invalidateInitialState();
    }
  }
 else   if (e.getCode() == ComponentChangeEvent.Code.NAME_CHANGED) {
    ModelComponent c=e.getComponent();
    if (myFrame != null) {
      if (c.getParent() != null) {
        myFrame.getNavPanel().updateStructure(c.getParent());
      }
 else {
        myFrame.getNavPanel().updateStructure(c);
      }
    }
  }
 else   if (e.getCode() == ComponentChangeEvent.Code.PROPERTY_CHANGED) {
    PropertyChangeEvent pe=(PropertyChangeEvent)e;
    ModelComponent c=e.getComponent();
    if (c == getRootModel()) {
      if (pe.getPropertyName().equals(""String_Node_Str"")) {
        doSetMaxStep(getRootModel().getMaxStepSize());
      }
 else       if (pe.getPropertyName().equals(""String_Node_Str"")) {
        if (myViewerManager != null) {
          myViewerManager.resetViewers(getRootModel().getDefaultViewOrientation());
        }
      }
    }
 else     if (pe.getPropertyName().startsWith(""String_Node_Str"")) {
      if (myFrame != null) {
        myFrame.getNavPanel().updateStructure(e.getComponent());
      }
    }
  }
 else   if (e.getCode() == ComponentChangeEvent.Code.GEOMETRY_CHANGED) {
    if (!getScheduler().isPlaying()) {
      rerender();
    }
  }
}"
70984,"public static LinkedHashMap<Integer,ArrayList<Integer>> readElemFile(Reader elemReader,boolean useAnsysNum) throws IOException {
  LinkedHashMap<Integer,ArrayList<Integer>> elemPositions=new LinkedHashMap<Integer,ArrayList<Integer>>();
  int offset=useAnsysNum ? 0 : -1;
  int elemId=0;
  String line;
  int lineno=0;
  BufferedReader reader=new BufferedReader(elemReader);
  line=reader.readLine();
  ArrayList<Integer> widths=new ArrayList<Integer>(14);
  computeWidths(widths,line);
  while (line != null) {
    ArrayList<Integer> numbers=new ArrayList<Integer>();
    ArrayList<Integer> elemNumList;
    lineno++;
    int off=0;
    int nidx=0;
    while ((off=parseNumber(numbers,line,off,widths.get(nidx),lineno)) != -1) {
      nidx++;
    }
    if (numbers.size() == 14) {
      elemNumList=new ArrayList<Integer>();
      for (int i=0; i < 8; i++) {
        elemNumList.add(numbers.get(i) + offset);
      }
      for (int i=8; i < 13; i++) {
        elemNumList.add(0,numbers.get(i));
      }
      elemId=numbers.get(13);
    }
 else {
      elemNumList=elemPositions.get(elemId + offset);
      for (int i=0; i < numbers.size(); i++) {
        elemNumList.add(numbers.get(i) + offset);
      }
    }
    elemPositions.put(elemId + offset,elemNumList);
    line=reader.readLine();
  }
  return elemPositions;
}","public static LinkedHashMap<Integer,ArrayList<Integer>> readElemFile(Reader elemReader,boolean useAnsysNum) throws IOException {
  LinkedHashMap<Integer,ArrayList<Integer>> elemPositions=new LinkedHashMap<Integer,ArrayList<Integer>>();
  int offset=useAnsysNum ? 0 : -1;
  int elemId=0;
  String line;
  int lineno=0;
  BufferedReader reader=new BufferedReader(elemReader);
  line=reader.readLine();
  ArrayList<Integer> widths=new ArrayList<Integer>(14);
  computeWidths(widths,line);
  widths.add(0);
  while (line != null) {
    ArrayList<Integer> numbers=new ArrayList<Integer>();
    ArrayList<Integer> elemNumList;
    lineno++;
    int off=0;
    int nidx=0;
    while ((off=parseNumber(numbers,line,off,widths.get(nidx),lineno)) != -1) {
      nidx++;
      if (off >= line.length()) {
        break;
      }
    }
    if (numbers.size() == 14) {
      elemNumList=new ArrayList<Integer>();
      for (int i=0; i < 8; i++) {
        elemNumList.add(numbers.get(i) + offset);
      }
      for (int i=8; i < 13; i++) {
        elemNumList.add(0,numbers.get(i));
      }
      elemId=numbers.get(13);
    }
 else {
      elemNumList=elemPositions.get(elemId + offset);
      for (int i=0; i < numbers.size(); i++) {
        elemNumList.add(numbers.get(i) + offset);
      }
    }
    elemPositions.put(elemId + offset,elemNumList);
    line=reader.readLine();
  }
  return elemPositions;
}"
70985,"public void test(){
  testFit();
  testIntersectPlane();
}","public void test(){
  testFit();
  testIntersectPlane();
  testSet();
}"
70986,"public static void main(String[] args){
  PlaneTest tester=new PlaneTest();
  try {
    tester.test();
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
  System.out.println(""String_Node_Str"");
}","public static void main(String[] args){
  RandomGenerator.setSeed(0x1234);
  PlaneTest tester=new PlaneTest();
  try {
    tester.test();
  }
 catch (  Exception e) {
    e.printStackTrace();
    System.exit(1);
  }
  System.out.println(""String_Node_Str"");
}"
70987,"/** 
 * Sets this plane to pass through three non-colinear points arranged counter-clockwise around the normal.
 * @param p1 first point
 * @param p2 second point
 * @param p3 third point
 * @throws IllegalArgumentException if the points are colinear
 */
public void set(Point3d p1,Point3d p2,Point3d p3) throws IllegalArgumentException {
  double d1x=p2.x - p1.x;
  double d1y=p2.y - p1.y;
  double d1z=p2.z - p1.z;
  double d2x=p3.x - p1.x;
  double d2y=p3.y - p1.y;
  double d2z=p3.z - p1.z;
  normal.x=d1y * d2z - d1z * d2y;
  normal.y=d1z * d2x - d1x * d2z;
  normal.z=d1x * d2y - d1y * d2x;
  double mag=normal.norm();
  if (mag == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  normal.scale(1 / mag);
}","/** 
 * Sets this plane to pass through three non-colinear points arranged counter-clockwise around the normal.
 * @param p1 first point
 * @param p2 second point
 * @param p3 third point
 * @throws IllegalArgumentException if the points are colinear
 */
public void set(Point3d p1,Point3d p2,Point3d p3) throws IllegalArgumentException {
  double d1x=p2.x - p1.x;
  double d1y=p2.y - p1.y;
  double d1z=p2.z - p1.z;
  double d2x=p3.x - p1.x;
  double d2y=p3.y - p1.y;
  double d2z=p3.z - p1.z;
  normal.x=d1y * d2z - d1z * d2y;
  normal.y=d1z * d2x - d1x * d2z;
  normal.z=d1x * d2y - d1y * d2x;
  double mag=normal.norm();
  if (mag == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  normal.scale(1 / mag);
  offset=normal.dot(p1);
  offset+=normal.dot(p2);
  offset+=normal.dot(p3);
  offset/=3;
}"
70988,"/** 
 * Returns true if the specified character is a quote character.
 * @param ch character to be queried
 * @return true if <code>ch</code>ch is a quote character
 * @see #quoteChar
 */
public final boolean isQuoteChar(int ch){
  if (ch >= ctype.length) {
    return false;
  }
 else {
    return (ctype[ch] & C_QUOTE) != 0;
  }
}","/** 
 * Returns true if the specified character is a quote character.
 * @param ch character to be queried
 * @return true if <code>ch</code>ch is a quote character
 * @see #quoteChar
 */
public final boolean isQuoteChar(int ch){
  if (ch >= ctype.length) {
    return false;
  }
 else   if (ch < 0) {
    return false;
  }
 else {
    return (ctype[ch] & C_QUOTE) != 0;
  }
}"
70989,"/** 
 * Returns a List of cells (List<T>'s) that might intersect a bv tree.
 * @param bvtree
 */
public Map<List<T>,ArrayList<BVNode>> getCellsIntersecting(BVTree bvtree){
  Map<List<T>,ArrayList<BVNode>> potentials=new HashMap<>();
  Point3d cellCentre=new Point3d();
  double searchRad=myGridSpacing * Math.sqrt(0.5);
  searchRad=Math.sqrt(searchRad * searchRad + myGridSpacing * myGridSpacing / 4);
  searchRad+=myGridSpacing;
  double sphereRadius=Math.sqrt(2 * searchRad * searchRad);
  for (  Index index : myGrid.keySet()) {
    ArrayList<BVNode> nodes=new ArrayList<>();
    cellCentre.x=index.vals[0] * myGridSpacing;
    cellCentre.y=index.vals[1] * myGridSpacing;
    cellCentre.z=index.vals[2] * myGridSpacing;
    bvtree.intersectSphere(nodes,cellCentre,sphereRadius);
    if (nodes.size() > 0) {
      potentials.put(myGrid.get(index),nodes);
    }
  }
  return potentials;
}","/** 
 * Returns a List of cells (List<T>'s) that might intersect a bv tree.
 * @param bvtree
 */
public Map<List<T>,ArrayList<BVNode>> getCellsIntersecting(BVTree bvtree){
  Map<List<T>,ArrayList<BVNode>> potentials=new HashMap<List<T>,ArrayList<BVNode>>();
  Point3d cellCentre=new Point3d();
  double searchRad=myGridSpacing * Math.sqrt(0.5);
  searchRad=Math.sqrt(searchRad * searchRad + myGridSpacing * myGridSpacing / 4);
  searchRad+=myGridSpacing;
  double sphereRadius=Math.sqrt(2 * searchRad * searchRad);
  for (  Index index : myGrid.keySet()) {
    ArrayList<BVNode> nodes=new ArrayList<BVNode>();
    cellCentre.x=index.vals[0] * myGridSpacing;
    cellCentre.y=index.vals[1] * myGridSpacing;
    cellCentre.z=index.vals[2] * myGridSpacing;
    bvtree.intersectSphere(nodes,cellCentre,sphereRadius);
    if (nodes.size() > 0) {
      potentials.put(myGrid.get(index),nodes);
    }
  }
  return potentials;
}"
70990,"protected synchronized void setupListsToNeighbours(){
  if (myIndexListInitialized) {
    return;
  }
  myIndexList.clear();
  for (  Index index : myGrid.keySet()) {
    List<List<T>> list=new LinkedList<>();
    NearCellIter it=new NearCellIter(index.vals[0],index.vals[1],index.vals[2]);
    while (it.hasNext()) {
      List<T> cells=it.next();
      if (cells == null) {
        continue;
      }
      list.add(cells);
    }
    myIndexList.put(index,list);
  }
  myIndexListInitialized=true;
}","protected synchronized void setupListsToNeighbours(){
  if (myIndexListInitialized) {
    return;
  }
  myIndexList.clear();
  for (  Index index : myGrid.keySet()) {
    List<List<T>> list=new LinkedList<List<T>>();
    NearCellIter it=new NearCellIter(index.vals[0],index.vals[1],index.vals[2]);
    while (it.hasNext()) {
      List<T> cells=it.next();
      if (cells == null) {
        continue;
      }
      list.add(cells);
    }
    myIndexList.put(index,list);
  }
  myIndexListInitialized=true;
}"
70991,"public static PolygonalMesh readBinary(PolygonalMesh mesh,InputStream is,double tol) throws IOException {
  boolean _printDebug=false;
  is.skip(80);
  byte[] bbuf=new byte[4];
  is.read(bbuf,0,4);
  long numFacets=0;
  numFacets|=bbuf[3] & 0xFF;
  numFacets<<=8;
  numFacets|=bbuf[2] & 0xFF;
  numFacets<<=8;
  numFacets|=bbuf[1] & 0xFF;
  numFacets<<=8;
  numFacets|=bbuf[0] & 0xFF;
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + numFacets);
  }
  ArrayList<Point3d> nodeList=new ArrayList<Point3d>();
  ArrayList<ArrayList<Integer>> faceList=new ArrayList<ArrayList<Integer>>();
  if (_printDebug) {
    System.out.print(""String_Node_Str"");
  }
  long start=System.nanoTime();
  int facetSize=50;
  bbuf=new byte[facetSize];
  List<Point3d> allPoints=new ArrayList<>(3 * (int)numFacets);
  List<Point3d[]> allFaces=new ArrayList<>((int)numFacets);
  for (long i=0; i < numFacets; i++) {
    int nBytesRead=is.read(bbuf,0,facetSize);
    if (nBytesRead < facetSize) {
      throw new IOException(""String_Node_Str"");
    }
    ByteBuffer bb=ByteBuffer.wrap(bbuf);
    bb.order(ByteOrder.LITTLE_ENDIAN);
    bb.getFloat();
    bb.getFloat();
    bb.getFloat();
    Point3d[] face=new Point3d[3];
    double[] vals=new double[3];
    for (int j=0; j < 3; j++) {
      vals[0]=bb.getFloat();
      vals[1]=bb.getFloat();
      vals[2]=bb.getFloat();
      Point3d pnt;
      pnt=new Point3d(vals);
      allPoints.add(pnt);
      face[j]=pnt;
    }
    allFaces.add(face);
    bb.getShort();
  }
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  SpatialHashTable<Point3d> table=new SpatialHashTable<>(tol);
  table.setup(allPoints,allPoints);
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  HashMap<Point3d,Integer> allToUniqueMap=new HashMap<>(allPoints.size());
  double tolSq=tol * tol;
  for (  Point3d pnt : allPoints) {
    if (allToUniqueMap.containsKey(pnt)) {
      continue;
    }
    List<Point3d> results=new ArrayList<>();
    Iterator<List<Point3d>> it=table.getCellsNearOld(pnt);
    while (it.hasNext()) {
      List<Point3d> cell=it.next();
      if (cell == null)       continue;
      for (      Point3d neighbour : cell) {
        if (neighbour.distanceSquared(pnt) < tolSq) {
          results.add(neighbour);
        }
      }
    }
    int idx=nodeList.size();
    nodeList.add(pnt);
    for (    Point3d neighbour : results) {
      allToUniqueMap.put(neighbour,idx);
    }
  }
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  for (  Point3d[] face : allFaces) {
    ArrayList<Integer> faceNodes=new ArrayList<Integer>(3);
    for (int i=0; i < 3; i++) {
      int idx=allToUniqueMap.get(face[i]);
      faceNodes.add(idx);
    }
    faceList.add(faceNodes);
  }
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  mesh=buildMesh(mesh,nodeList,faceList);
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + nodeList.size());
    System.out.println(""String_Node_Str"" + allFaces.size());
  }
  return mesh;
}","public static PolygonalMesh readBinary(PolygonalMesh mesh,InputStream is,double tol) throws IOException {
  boolean _printDebug=false;
  is.skip(80);
  byte[] bbuf=new byte[4];
  is.read(bbuf,0,4);
  long numFacets=0;
  numFacets|=bbuf[3] & 0xFF;
  numFacets<<=8;
  numFacets|=bbuf[2] & 0xFF;
  numFacets<<=8;
  numFacets|=bbuf[1] & 0xFF;
  numFacets<<=8;
  numFacets|=bbuf[0] & 0xFF;
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + numFacets);
  }
  ArrayList<Point3d> nodeList=new ArrayList<Point3d>();
  ArrayList<ArrayList<Integer>> faceList=new ArrayList<ArrayList<Integer>>();
  if (_printDebug) {
    System.out.print(""String_Node_Str"");
  }
  long start=System.nanoTime();
  int facetSize=50;
  bbuf=new byte[facetSize];
  List<Point3d> allPoints=new ArrayList<Point3d>(3 * (int)numFacets);
  List<Point3d[]> allFaces=new ArrayList<Point3d[]>((int)numFacets);
  for (long i=0; i < numFacets; i++) {
    int nBytesRead=is.read(bbuf,0,facetSize);
    if (nBytesRead < facetSize) {
      throw new IOException(""String_Node_Str"");
    }
    ByteBuffer bb=ByteBuffer.wrap(bbuf);
    bb.order(ByteOrder.LITTLE_ENDIAN);
    bb.getFloat();
    bb.getFloat();
    bb.getFloat();
    Point3d[] face=new Point3d[3];
    double[] vals=new double[3];
    for (int j=0; j < 3; j++) {
      vals[0]=bb.getFloat();
      vals[1]=bb.getFloat();
      vals[2]=bb.getFloat();
      Point3d pnt;
      pnt=new Point3d(vals);
      allPoints.add(pnt);
      face[j]=pnt;
    }
    allFaces.add(face);
    bb.getShort();
  }
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  SpatialHashTable<Point3d> table=new SpatialHashTable<Point3d>(tol);
  table.setup(allPoints,allPoints);
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  HashMap<Point3d,Integer> allToUniqueMap=new HashMap<Point3d,Integer>(allPoints.size());
  double tolSq=tol * tol;
  for (  Point3d pnt : allPoints) {
    if (allToUniqueMap.containsKey(pnt)) {
      continue;
    }
    List<Point3d> results=new ArrayList<Point3d>();
    Iterator<List<Point3d>> it=table.getCellsNearOld(pnt);
    while (it.hasNext()) {
      List<Point3d> cell=it.next();
      if (cell == null)       continue;
      for (      Point3d neighbour : cell) {
        if (neighbour.distanceSquared(pnt) < tolSq) {
          results.add(neighbour);
        }
      }
    }
    int idx=nodeList.size();
    nodeList.add(pnt);
    for (    Point3d neighbour : results) {
      allToUniqueMap.put(neighbour,idx);
    }
  }
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  for (  Point3d[] face : allFaces) {
    ArrayList<Integer> faceNodes=new ArrayList<Integer>(3);
    for (int i=0; i < 3; i++) {
      int idx=allToUniqueMap.get(face[i]);
      faceNodes.add(idx);
    }
    faceList.add(faceNodes);
  }
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    start=System.nanoTime();
  }
  mesh=buildMesh(mesh,nodeList,faceList);
  if (_printDebug) {
    System.out.println(""String_Node_Str"" + 1.e-9 * (System.nanoTime() - start) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + nodeList.size());
    System.out.println(""String_Node_Str"" + allFaces.size());
  }
  return mesh;
}"
70992,"private void drawEdgesRaw(GL2 gl,PolygonalMesh mesh,int flags){
  int[] shadingModel=new int[1];
  gl.glGetIntegerv(GL2.GL_SHADE_MODEL,shadingModel,0);
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  useHSVInterpolation=false;
  boolean mergeQuadTriangles=false;
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  ArrayList<Face> faceList=mesh.getFaces();
  for (int faceIdx=0; faceIdx < faceList.size(); faceIdx++) {
    faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
    gl.glBegin(GL2.GL_LINE_LOOP);
    for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
      HalfEdge he=myEdges[edgeIdx];
      Vertex3d vtx=he.head;
      Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
      if (useVertexColors) {
        setVertexColor(gl,vtx,useHSVInterpolation);
      }
      gl.glVertex3d(pnt.x,pnt.y,pnt.z);
    }
    gl.glEnd();
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}","private void drawEdgesRaw(GL2 gl,PolygonalMesh mesh,int flags){
  int[] shadingModel=new int[1];
  gl.glGetIntegerv(GL2.GL_SHADE_MODEL,shadingModel,0);
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  boolean mergeQuadTriangles=false;
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  ArrayList<Face> faceList=mesh.getFaces();
  for (int faceIdx=0; faceIdx < faceList.size(); faceIdx++) {
    faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
    gl.glBegin(GL2.GL_LINE_LOOP);
    for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
      HalfEdge he=myEdges[edgeIdx];
      Vertex3d vtx=he.head;
      Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
      if (useVertexColors) {
        setVertexColor(gl,vtx,useHSVInterpolation);
      }
      gl.glVertex3d(pnt.x,pnt.y,pnt.z);
    }
    gl.glEnd();
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}"
70993,"private void drawFacesRaw(GL2 gl,PolygonalMesh mesh,TextureProps textureProps,int flags){
  Vector3d nrm;
  Vector3d[] nrms=null;
  Vector3d vtxNrm=new Vector3d();
  int[] shadingModel=new int[1];
  gl.glGetIntegerv(GL2.GL_SHADE_MODEL,shadingModel,0);
  boolean computeVertexNormals=(flags & COMPUTE_VERTEX_NORMALS) != 0;
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  useHSVInterpolation=false;
  boolean useTextureCoords=(textureProps != null && textureProps.isEnabled() && !textureProps.isAutomatic() && mesh.myTextureIndices != null);
  boolean mergeQuadTriangles=(shadingModel[0] == GL2.GL_SMOOTH);
  if ((flags & IS_SELECTING) != 0) {
    useVertexColors=false;
  }
  if (computeVertexNormals) {
    nrms=new Vector3d[mesh.getNumVertices()];
    for (int v=0; v < mesh.getNumVertices(); v++) {
      nrms[v]=new Vector3d();
      if (useRenderNormals) {
        mesh.getVertices().get(v).computeRenderNormal(nrms[v]);
      }
 else {
        mesh.getVertices().get(v).computeNormal(nrms[v]);
      }
    }
  }
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  myLastEdgeCnt=0;
  ArrayList<Face> faceList=mesh.getFaces();
  int[] faceOrder=mesh.getFaceOrder();
  int faceIdx;
  for (int i=0; i < faceList.size(); i++) {
    if (faceOrder == null) {
      faceIdx=i;
    }
 else {
      faceIdx=faceOrder[i];
    }
    faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
    Face face=faceList.get(faceIdx);
    if (myEdgeCnt > 4) {
      gl.glBegin(GL2.GL_POLYGON);
    }
 else     if (myLastEdgeCnt != myEdgeCnt) {
      if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
        gl.glEnd();
      }
      if (myEdgeCnt == 3) {
        gl.glBegin(GL2.GL_TRIANGLES);
      }
 else {
        gl.glBegin(GL2.GL_QUADS);
      }
    }
    if (!computeVertexNormals) {
      Vector3d faceNrm;
      if (useRenderNormals) {
        faceNrm=face.getRenderNormal();
      }
 else {
        faceNrm=face.getNormal();
      }
      gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
    }
    for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
      HalfEdge he=myEdges[edgeIdx];
      Vertex3d vtx=he.head;
      Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
      if (computeVertexNormals) {
        HalfEdge lastHard=he.lastHardEdge();
        if (lastHard != null) {
          lastHard.computeVertexNormal(vtxNrm,useRenderNormals);
          gl.glNormal3d(vtxNrm.x,vtxNrm.y,vtxNrm.z);
        }
 else {
          nrm=nrms[he.head.idx];
          gl.glNormal3d(nrm.x,nrm.y,nrm.z);
        }
      }
      if (useTextureCoords) {
        int iv=mesh.myTextureIndices.get(faceIdx)[edgeIdx];
        Vector3d vtext=(Vector3d)mesh.myTextureVertexList.get(iv);
        double sss=vtext.x;
        double ttt=vtext.y;
        gl.glTexCoord2f((float)sss,(float)(1 - ttt));
      }
      if (useVertexColors) {
        setVertexColor(gl,vtx,useHSVInterpolation);
      }
      gl.glVertex3d(pnt.x,pnt.y,pnt.z);
    }
    if (myEdgeCnt > 4) {
      gl.glEnd();
    }
    myLastEdgeCnt=myEdgeCnt;
  }
  if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
    gl.glEnd();
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}","private void drawFacesRaw(GL2 gl,PolygonalMesh mesh,TextureProps textureProps,int flags){
  Vector3d nrm;
  Vector3d[] nrms=null;
  Vector3d vtxNrm=new Vector3d();
  int[] shadingModel=new int[1];
  gl.glGetIntegerv(GL2.GL_SHADE_MODEL,shadingModel,0);
  boolean computeVertexNormals=(flags & COMPUTE_VERTEX_NORMALS) != 0;
  boolean useRenderNormals=mesh.isRenderBuffered() && !mesh.isFixed();
  boolean useVertexColors=(flags & GLRenderer.VERTEX_COLORING) != 0;
  boolean useHSVInterpolation=(flags & GLRenderer.HSV_COLOR_INTERPOLATION) != 0;
  System.out.println(useHSVInterpolation);
  boolean useTextureCoords=(textureProps != null && textureProps.isEnabled() && !textureProps.isAutomatic() && mesh.myTextureIndices != null);
  boolean mergeQuadTriangles=(shadingModel[0] == GL2.GL_SMOOTH);
  if ((flags & IS_SELECTING) != 0) {
    useVertexColors=false;
  }
  if (computeVertexNormals) {
    nrms=new Vector3d[mesh.getNumVertices()];
    for (int v=0; v < mesh.getNumVertices(); v++) {
      nrms[v]=new Vector3d();
      if (useRenderNormals) {
        mesh.getVertices().get(v).computeRenderNormal(nrms[v]);
      }
 else {
        mesh.getVertices().get(v).computeNormal(nrms[v]);
      }
    }
  }
  if (useVertexColors && useHSVInterpolation) {
    useHSVInterpolation=setupHSVInterpolation(gl);
  }
  myLastEdgeCnt=0;
  ArrayList<Face> faceList=mesh.getFaces();
  int[] faceOrder=mesh.getFaceOrder();
  int faceIdx;
  for (int i=0; i < faceList.size(); i++) {
    if (faceOrder == null) {
      faceIdx=i;
    }
 else {
      faceIdx=faceOrder[i];
    }
    faceIdx=unpackEdges(faceList,faceIdx,mergeQuadTriangles);
    Face face=faceList.get(faceIdx);
    if (myEdgeCnt > 4) {
      gl.glBegin(GL2.GL_POLYGON);
    }
 else     if (myLastEdgeCnt != myEdgeCnt) {
      if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
        gl.glEnd();
      }
      if (myEdgeCnt == 3) {
        gl.glBegin(GL2.GL_TRIANGLES);
      }
 else {
        gl.glBegin(GL2.GL_QUADS);
      }
    }
    if (!computeVertexNormals) {
      Vector3d faceNrm;
      if (useRenderNormals) {
        faceNrm=face.getRenderNormal();
      }
 else {
        faceNrm=face.getNormal();
      }
      gl.glNormal3d(faceNrm.x,faceNrm.y,faceNrm.z);
    }
    for (int edgeIdx=0; edgeIdx < myEdgeCnt; edgeIdx++) {
      HalfEdge he=myEdges[edgeIdx];
      Vertex3d vtx=he.head;
      Point3d pnt=useRenderNormals ? vtx.myRenderPnt : vtx.pnt;
      if (computeVertexNormals) {
        HalfEdge lastHard=he.lastHardEdge();
        if (lastHard != null) {
          lastHard.computeVertexNormal(vtxNrm,useRenderNormals);
          gl.glNormal3d(vtxNrm.x,vtxNrm.y,vtxNrm.z);
        }
 else {
          nrm=nrms[he.head.idx];
          gl.glNormal3d(nrm.x,nrm.y,nrm.z);
        }
      }
      if (useTextureCoords) {
        int iv=mesh.myTextureIndices.get(faceIdx)[edgeIdx];
        Vector3d vtext=(Vector3d)mesh.myTextureVertexList.get(iv);
        double sss=vtext.x;
        double ttt=vtext.y;
        gl.glTexCoord2f((float)sss,(float)(1 - ttt));
      }
      if (useVertexColors) {
        setVertexColor(gl,vtx,useHSVInterpolation);
      }
      gl.glVertex3d(pnt.x,pnt.y,pnt.z);
    }
    if (myEdgeCnt > 4) {
      gl.glEnd();
    }
    myLastEdgeCnt=myEdgeCnt;
  }
  if (myLastEdgeCnt == 3 || myLastEdgeCnt == 4) {
    gl.glEnd();
  }
  if (useVertexColors && useHSVInterpolation) {
    gl.glUseProgramObjectARB(0);
  }
}"
70994,"private void setVertexColor(GL2 gl,Vertex3d vtx,boolean useHSV){
  float[] color=vtx.getColorArray();
  if (color != null) {
    if (useHSV) {
      GLSupport.RGBtoHSV(myColorBuf,color);
      gl.glColor4f(myColorBuf[0],myColorBuf[1],myColorBuf[2],myColorBuf[3]);
    }
 else {
      gl.glColor4f(color[0],color[1],color[2],color[3]);
    }
  }
}","private void setVertexColor(GL2 gl,Vertex3d vtx,boolean useHSV){
  float[] color=vtx.getColorArray();
  if (color != null) {
    if (useHSV) {
      GLSupport.RGBtoHSV(myColorBuf,color);
      gl.glColor4f(myColorBuf[0],myColorBuf[1],myColorBuf[2],color[3]);
    }
 else {
      gl.glColor4f(color[0],color[1],color[2],color[3]);
    }
  }
}"
70995,"/** 
 * Returns true is a specified Frame is currently registered with this SkinMesh.
 * @param frame Frame to be queried
 */
public boolean hasFrame(Frame frame){
  return myFrameInfo.contains(frame);
}","/** 
 * Returns true is a specified Frame is currently registered with this SkinMesh.
 * @param frame Frame to be queried
 */
public boolean hasFrame(Frame frame){
  for (  FrameInfo fi : myFrameInfo) {
    if (fi.getFrame() == frame) {
      return true;
    }
  }
  return false;
}"
70996,"public synchronized void applyOutputProbes(List<Probe> list,double t1,ModelInfo info){
  double maxStep=info.model.getMaxStepSize();
  boolean coincidesWithStep=(maxStep != -1 && TimeBase.modulo(t1,maxStep) == 0);
  for (  Probe p : list) {
    if (p.isActive() && (p.isEventTime(t1) || (coincidesWithStep && p.getUpdateInterval() < 0))) {
      p.apply(t1);
    }
  }
}","public synchronized void applyOutputProbes(List<Probe> list,double t1,ModelInfo info){
  double maxStep=info.model.getMaxStepSize();
  boolean coincidesWithStep=(maxStep != -1 && TimeBase.modulo(t1,maxStep) == 0);
  for (  Probe p : list) {
    if (!p.isActive() || TimeBase.compare(t1,p.getStartTime()) < 0 || TimeBase.compare(t1,p.getStopTime()) > 0) {
      continue;
    }
    if (p.isEventTime(t1) || (coincidesWithStep && p.getUpdateInterval() < 0)) {
      p.apply(t1);
    }
  }
}"
70997,"public void drawPoints(RenderProps props,Iterator<? extends RenderablePoint> iterator){
switch (props.getPointStyle()) {
case POINT:
{
      setLightingEnabled(false);
      gl.glPointSize(props.getPointSize());
      if (isSelecting()) {
        int i=0;
        while (iterator.hasNext()) {
          RenderablePoint pnt=iterator.next();
          if (pnt.getRenderProps() == null) {
            if (isSelectable(pnt)) {
              beginSelectionQuery(i);
              gl.glBegin(GL2.GL_POINTS);
              gl.glVertex3fv(pnt.getRenderCoords(),0);
              gl.glEnd();
              endSelectionQuery();
            }
          }
          i++;
        }
      }
 else {
        gl.glBegin(GL2.GL_POINTS);
        setColor(props.getPointColorArray(),false);
        while (iterator.hasNext()) {
          RenderablePoint pnt=iterator.next();
          if (pnt.getRenderProps() == null) {
            updateColor(props.getPointColorArray(),pnt.isSelected());
            gl.glVertex3fv(pnt.getRenderCoords(),0);
          }
        }
        gl.glEnd();
      }
      gl.glPointSize(1);
      setLightingEnabled(true);
      break;
    }
case SPHERE:
{
    setMaterialAndShading(props,props.getPointMaterial(),false);
    int i=0;
    while (iterator.hasNext()) {
      RenderablePoint pnt=iterator.next();
      if (pnt.getRenderProps() == null) {
        if (isSelecting()) {
          if (isSelectable(pnt)) {
            beginSelectionQuery(i);
            drawSphere(props,pnt.getRenderCoords());
            endSelectionQuery();
          }
        }
 else {
          updateMaterial(props,props.getPointMaterial(),pnt.isSelected());
          drawSphere(props,pnt.getRenderCoords());
        }
      }
      i++;
    }
    restoreShading(props);
  }
}
}","public void drawPoints(RenderProps props,Iterator<? extends RenderablePoint> iterator){
switch (props.getPointStyle()) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        setLightingEnabled(false);
        gl.glPointSize(size);
        if (isSelecting()) {
          int i=0;
          while (iterator.hasNext()) {
            RenderablePoint pnt=iterator.next();
            if (pnt.getRenderProps() == null) {
              if (isSelectable(pnt)) {
                beginSelectionQuery(i);
                gl.glBegin(GL2.GL_POINTS);
                gl.glVertex3fv(pnt.getRenderCoords(),0);
                gl.glEnd();
                endSelectionQuery();
              }
            }
            i++;
          }
        }
 else {
          gl.glBegin(GL2.GL_POINTS);
          setColor(props.getPointColorArray(),false);
          while (iterator.hasNext()) {
            RenderablePoint pnt=iterator.next();
            if (pnt.getRenderProps() == null) {
              updateColor(props.getPointColorArray(),pnt.isSelected());
              gl.glVertex3fv(pnt.getRenderCoords(),0);
            }
          }
          gl.glEnd();
        }
        gl.glPointSize(1);
        setLightingEnabled(true);
      }
      break;
    }
case SPHERE:
{
    setMaterialAndShading(props,props.getPointMaterial(),false);
    int i=0;
    while (iterator.hasNext()) {
      RenderablePoint pnt=iterator.next();
      if (pnt.getRenderProps() == null) {
        if (isSelecting()) {
          if (isSelectable(pnt)) {
            beginSelectionQuery(i);
            drawSphere(props,pnt.getRenderCoords());
            endSelectionQuery();
          }
        }
 else {
          updateMaterial(props,props.getPointMaterial(),pnt.isSelected());
          drawSphere(props,pnt.getRenderCoords());
        }
      }
      i++;
    }
    restoreShading(props);
  }
}
}"
70998,"public void drawPoint(RenderProps props,float[] coords,boolean selected){
switch (props.getPointStyle()) {
case POINT:
{
      setLightingEnabled(false);
      gl.glPointSize(props.getPointSize());
      setColor(props.getPointColorArray(),selected);
      gl.glBegin(GL2.GL_POINTS);
      gl.glVertex3fv(coords,0);
      gl.glEnd();
      gl.glPointSize(1);
      setLightingEnabled(true);
      break;
    }
case SPHERE:
{
    setMaterialAndShading(props,props.getPointMaterial(),selected);
    drawSphere(props,coords);
    restoreShading(props);
    break;
  }
}
}","public void drawPoint(RenderProps props,float[] coords,boolean selected){
switch (props.getPointStyle()) {
case POINT:
{
      int size=props.getPointSize();
      if (size > 0) {
        setLightingEnabled(false);
        gl.glPointSize(size);
        setColor(props.getPointColorArray(),selected);
        gl.glBegin(GL2.GL_POINTS);
        gl.glVertex3fv(coords,0);
        gl.glEnd();
        gl.glPointSize(1);
        setLightingEnabled(true);
      }
      break;
    }
case SPHERE:
{
    setMaterialAndShading(props,props.getPointMaterial(),selected);
    drawSphere(props,coords);
    restoreShading(props);
    break;
  }
}
}"
70999,"public void render(GLRenderer renderer,RenderProps props,int flags){
  GL2 gl=renderer.getGL2();
  offsetMag=1.0 * renderer.centerDistancePerPixel();
  renderer.getZDirection();
  Vector3d offDir=new Vector3d(renderer.getZDirection());
  double scale=offsetMag / offDir.norm();
  offDir.scale(scale);
  if (myRenderSegments != null) {
    for (    LineSeg seg : myRenderSegments) {
      renderer.drawLine(props,seg.coords0,seg.coords1,false);
    }
  }
  if (drawIntersectionContour && props.getEdgeWidth() > 0 && myRenderContactInfo != null) {
    gl.glLineWidth(props.getEdgeWidth());
    float[] rgb=props.getEdgeColorArray();
    if (rgb == null) {
      rgb=props.getLineColorArray();
    }
    renderer.setColor(rgb,false);
    renderer.setLightingEnabled(false);
    if (myRenderContactInfo.contours != null) {
      for (      MeshIntersectionContour contour : myRenderContactInfo.contours) {
        gl.glBegin(GL2.GL_LINE_LOOP);
        for (        MeshIntersectionPoint p : contour) {
          gl.glVertex3d(p.x + offDir.x,p.y + offDir.y,p.z + offDir.z);
        }
        gl.glEnd();
      }
    }
 else     if (myRenderContactInfo.intersections != null) {
      gl.glBegin(GL2.GL_LINES);
      for (      TriTriIntersection tsect : myRenderContactInfo.intersections) {
        gl.glVertex3d(tsect.points[0].x + offDir.x,tsect.points[0].y + offDir.y,tsect.points[0].z + offDir.z);
        gl.glVertex3d(tsect.points[1].x + offDir.x,tsect.points[1].y + offDir.y,tsect.points[1].z + offDir.z);
      }
      gl.glEnd();
    }
    renderer.setLightingEnabled(true);
    gl.glLineWidth(1);
  }
  float[] coords=new float[3];
  if (drawIntersectionPoints && myRenderContactInfo != null) {
    if (myRenderContactInfo.intersections != null) {
      for (      TriTriIntersection tsect : myRenderContactInfo.intersections) {
        for (        Point3d pnt : tsect.points) {
          pnt.get(coords);
          renderer.drawPoint(props,coords,false);
        }
      }
    }
    if (myRenderContactInfo.points0 != null) {
      for (      ContactPenetratingPoint cpp : myRenderContactInfo.points0) {
        if (cpp.distance > 0) {
          cpp.vertex.getWorldPoint().get(coords);
          renderer.drawPoint(props,coords,false);
        }
      }
    }
    if (myRenderContactInfo.points1 != null) {
      for (      ContactPenetratingPoint cpp : myRenderContactInfo.points1) {
        if (cpp.distance > 0) {
          cpp.vertex.getWorldPoint().get(coords);
          renderer.drawPoint(props,coords,false);
        }
      }
    }
    if (myRenderContactInfo.edgeEdgeContacts != null) {
      for (      EdgeEdgeContact eec : myRenderContactInfo.edgeEdgeContacts) {
        eec.point0.get(coords);
        renderer.drawPoint(props,coords,false);
        eec.point1.get(coords);
        renderer.drawPoint(props,coords,false);
      }
    }
  }
  if (drawIntersectionFaces && myRenderFaces != null) {
    gl.glPushMatrix();
    Material faceMat=props.getFaceMaterial();
    Shading shading=props.getShading();
    if (shading != Shading.NONE) {
      faceMat.apply(gl,GL2.GL_FRONT_AND_BACK);
      gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1);
    }
    if (props.getFaceStyle() != RenderProps.Faces.NONE) {
      int[] savedShadeModel=new int[1];
      gl.glGetIntegerv(GL2.GL_SHADE_MODEL,savedShadeModel,0);
      if (shading == Shading.NONE) {
        renderer.setLightingEnabled(false);
        renderer.setColor(props.getFaceColorArray(),false);
      }
 else       if (shading != Shading.FLAT && !renderer.isSelecting()) {
        gl.glShadeModel(GL2.GL_SMOOTH);
      }
 else {
        gl.glShadeModel(GL2.GL_FLAT);
      }
      byte[] savedCullFaceEnabled=new byte[1];
      int[] savedCullFaceMode=new int[1];
      gl.glGetBooleanv(GL2.GL_CULL_FACE,savedCullFaceEnabled,0);
      gl.glGetIntegerv(GL2.GL_CULL_FACE_MODE,savedCullFaceMode,0);
      RenderProps.Faces faces=props.getFaceStyle();
switch (faces) {
case FRONT_AND_BACK:
{
          gl.glDisable(GL2.GL_CULL_FACE);
          break;
        }
case FRONT:
{
        gl.glCullFace(GL2.GL_BACK);
        break;
      }
case BACK:
{
      gl.glCullFace(GL2.GL_FRONT);
      break;
    }
default :
  break;
}
offDir.scale(0.5);
gl.glBegin(GL2.GL_TRIANGLES);
for (FaceSeg seg : myRenderFaces) {
gl.glNormal3d(seg.nrm.x,seg.nrm.y,seg.nrm.z);
gl.glVertex3d(seg.p0.x + offDir.x,seg.p0.y + offDir.y,seg.p0.z + offDir.z);
gl.glVertex3d(seg.p1.x + offDir.x,seg.p1.y + offDir.y,seg.p1.z + offDir.z);
gl.glVertex3d(seg.p2.x + offDir.x,seg.p2.y + offDir.y,seg.p2.z + offDir.z);
}
gl.glEnd();
if (savedCullFaceEnabled[0] != 0) {
gl.glEnable(GL2.GL_CULL_FACE);
}
 else {
gl.glDisable(GL2.GL_CULL_FACE);
}
gl.glCullFace(savedCullFaceMode[0]);
if (shading == Shading.NONE) {
renderer.setLightingEnabled(true);
}
gl.glShadeModel(savedShadeModel[0]);
}
gl.glPopMatrix();
}
}","public void render(GLRenderer renderer,RenderProps props,int flags){
  GL2 gl=renderer.getGL2();
  double offsetMag=1.0 * renderer.centerDistancePerPixel();
  renderer.getZDirection();
  Vector3d offDir=new Vector3d(renderer.getZDirection());
  double scale=offsetMag / offDir.norm();
  offDir.scale(scale);
  if (myRenderSegments != null) {
    for (    LineSeg seg : myRenderSegments) {
      renderer.drawLine(props,seg.coords0,seg.coords1,false);
    }
  }
  if (drawIntersectionContour && props.getEdgeWidth() > 0 && myRenderContactInfo != null) {
    gl.glLineWidth(props.getEdgeWidth());
    float[] rgb=props.getEdgeColorArray();
    if (rgb == null) {
      rgb=props.getLineColorArray();
    }
    renderer.setColor(rgb,false);
    renderer.setLightingEnabled(false);
    if (myRenderContactInfo.contours != null) {
      for (      MeshIntersectionContour contour : myRenderContactInfo.contours) {
        gl.glBegin(GL2.GL_LINE_LOOP);
        for (        MeshIntersectionPoint p : contour) {
          gl.glVertex3d(p.x + offDir.x,p.y + offDir.y,p.z + offDir.z);
        }
        gl.glEnd();
      }
    }
 else     if (myRenderContactInfo.intersections != null) {
      gl.glBegin(GL2.GL_LINES);
      for (      TriTriIntersection tsect : myRenderContactInfo.intersections) {
        gl.glVertex3d(tsect.points[0].x + offDir.x,tsect.points[0].y + offDir.y,tsect.points[0].z + offDir.z);
        gl.glVertex3d(tsect.points[1].x + offDir.x,tsect.points[1].y + offDir.y,tsect.points[1].z + offDir.z);
      }
      gl.glEnd();
    }
    renderer.setLightingEnabled(true);
    gl.glLineWidth(1);
  }
  float[] coords=new float[3];
  if (drawIntersectionPoints && myRenderContactInfo != null) {
    if (myRenderContactInfo.intersections != null) {
      for (      TriTriIntersection tsect : myRenderContactInfo.intersections) {
        for (        Point3d pnt : tsect.points) {
          pnt.get(coords);
          renderer.drawPoint(props,coords,false);
        }
      }
    }
    if (myRenderContactInfo.points0 != null) {
      for (      ContactPenetratingPoint cpp : myRenderContactInfo.points0) {
        if (cpp.distance > 0) {
          cpp.vertex.getWorldPoint().get(coords);
          renderer.drawPoint(props,coords,false);
        }
      }
    }
    if (myRenderContactInfo.points1 != null) {
      for (      ContactPenetratingPoint cpp : myRenderContactInfo.points1) {
        if (cpp.distance > 0) {
          cpp.vertex.getWorldPoint().get(coords);
          renderer.drawPoint(props,coords,false);
        }
      }
    }
    if (myRenderContactInfo.edgeEdgeContacts != null) {
      for (      EdgeEdgeContact eec : myRenderContactInfo.edgeEdgeContacts) {
        eec.point0.get(coords);
        renderer.drawPoint(props,coords,false);
        eec.point1.get(coords);
        renderer.drawPoint(props,coords,false);
      }
    }
  }
  if (drawIntersectionFaces && myRenderFaces != null) {
    gl.glPushMatrix();
    Material faceMat=props.getFaceMaterial();
    Shading shading=props.getShading();
    if (shading != Shading.NONE) {
      faceMat.apply(gl,GL2.GL_FRONT_AND_BACK);
      gl.glLightModelf(GL2.GL_LIGHT_MODEL_TWO_SIDE,1);
    }
    if (props.getFaceStyle() != RenderProps.Faces.NONE) {
      int[] savedShadeModel=new int[1];
      gl.glGetIntegerv(GL2.GL_SHADE_MODEL,savedShadeModel,0);
      if (shading == Shading.NONE) {
        renderer.setLightingEnabled(false);
        renderer.setColor(props.getFaceColorArray(),false);
      }
 else       if (shading != Shading.FLAT && !renderer.isSelecting()) {
        gl.glShadeModel(GL2.GL_SMOOTH);
      }
 else {
        gl.glShadeModel(GL2.GL_FLAT);
      }
      byte[] savedCullFaceEnabled=new byte[1];
      int[] savedCullFaceMode=new int[1];
      gl.glGetBooleanv(GL2.GL_CULL_FACE,savedCullFaceEnabled,0);
      gl.glGetIntegerv(GL2.GL_CULL_FACE_MODE,savedCullFaceMode,0);
      RenderProps.Faces faces=props.getFaceStyle();
switch (faces) {
case FRONT_AND_BACK:
{
          gl.glDisable(GL2.GL_CULL_FACE);
          break;
        }
case FRONT:
{
        gl.glCullFace(GL2.GL_BACK);
        break;
      }
case BACK:
{
      gl.glCullFace(GL2.GL_FRONT);
      break;
    }
default :
  break;
}
offDir.scale(0.5);
gl.glBegin(GL2.GL_TRIANGLES);
for (FaceSeg seg : myRenderFaces) {
gl.glNormal3d(seg.nrm.x,seg.nrm.y,seg.nrm.z);
gl.glVertex3d(seg.p0.x + offDir.x,seg.p0.y + offDir.y,seg.p0.z + offDir.z);
gl.glVertex3d(seg.p1.x + offDir.x,seg.p1.y + offDir.y,seg.p1.z + offDir.z);
gl.glVertex3d(seg.p2.x + offDir.x,seg.p2.y + offDir.y,seg.p2.z + offDir.z);
}
gl.glEnd();
if (savedCullFaceEnabled[0] != 0) {
gl.glEnable(GL2.GL_CULL_FACE);
}
 else {
gl.glDisable(GL2.GL_CULL_FACE);
}
gl.glCullFace(savedCullFaceMode[0]);
if (shading == Shading.NONE) {
renderer.setLightingEnabled(true);
}
gl.glShadeModel(savedShadeModel[0]);
}
gl.glPopMatrix();
}
}"
71000,"/** 
 * Creates an FemModel with uniform density based on ANSYS data contained in a specified file. The node coordinate data can be scaled non-uniformly using an optional parameter giving scale values about the x, y, and z axes.
 * @param model FEM model to be populated by ANSYS data
 * @param nodeReader reader supplying node data in the ANSYS format
 * @param elemReader reader supplying element data in the ANSYS format
 * @param density density of the model
 * @param scale if non-null, gives scaling about the x, y, and z axes
 * @param options option flags. Should be an or-ed combination of {@link #TETRAHEDRALIZE_HEXES} and {@link #ONE_BASED_NUMBERING}.
 * @throws IOException if this is a problem reading the file
 */
public static FemModel3d read(FemModel3d model,Reader nodeReader,Reader elemReader,double density,Vector3d scale,int options) throws IOException {
  boolean tetrahedralize=(options & TETRAHEDRALIZE_HEXES) != 0;
  boolean useAnsysNum=(options & ONE_BASED_NUMBERING) != 0;
  if (model == null) {
    model=new FemModel3d();
  }
 else {
    model.clear();
  }
  if (density >= 0) {
    model.setDensity(density);
  }
  if (useAnsysNum) {
    model.useAnsysNumbering();
  }
  LinkedHashMap<Integer,Point3d> nodeMap=readNodeFile(nodeReader,useAnsysNum);
  LinkedHashMap<Integer,Integer> nodeIdMap=new LinkedHashMap<Integer,Integer>();
  for (  int nodeId : nodeMap.keySet()) {
    Point3d pos=nodeMap.get(nodeId);
    if (scale != null) {
      pos.x*=scale.x;
      pos.y*=scale.y;
      pos.z*=scale.z;
    }
    FemNode3d node=new FemNode3d(pos);
    model.addNumberedNode(node,nodeId);
    nodeIdMap.put(nodeId,node.getNumber());
  }
  LinkedHashMap<Integer,ArrayList<Integer>> elemMap=readElemFile(elemReader,useAnsysNum);
  ArrayList<HexElement> hexElems=new ArrayList<HexElement>();
  boolean flip=false;
  if (scale != null) {
    double scaleProduct=scale.x * scale.y * scale.z;
    flip=(scaleProduct < 0);
  }
  for (  int elemId : elemMap.keySet()) {
    ArrayList<Integer> elemNumList=elemMap.get(elemId);
    int[] attrList=new int[5];
    for (int i=attrList.length - 1; i >= 0; i--) {
      attrList[i]=elemNumList.remove(0);
    }
    ArrayList<Integer> nodeList=getValidElemNodes(elemNumList,nodeIdMap,flip);
switch (nodeList.size()) {
case 4:
      createTet(model,nodeList,elemId,attrList);
    break;
case 5:
  createPyramid(model,nodeList,elemId,attrList);
break;
case 6:
createWedge(model,nodeList,elemId,attrList);
break;
case 8:
hexElems.add(createHex(model,nodeList,elemId,attrList));
break;
case 10:
createQuadTet(model,nodeList,elemId,attrList);
break;
case 20:
createQuadHex(model,nodeList,elemId,attrList);
break;
default :
System.out.println(""String_Node_Str"" + nodeList.size() + ""String_Node_Str"");
}
}
HexElement.setParities(hexElems);
if (tetrahedralize) {
for (HexElement hex : hexElems) {
FemNode3d[] n=hex.getNodes();
TetElement[] tets=TetElement.createCubeTesselation(n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],hex.getParity() == 1);
model.removeElement(hex);
for (TetElement tet : tets) {
model.addElement(tet);
}
}
}
return model;
}","/** 
 * Creates an FemModel with uniform density based on ANSYS data contained in a specified file. The node coordinate data can be scaled non-uniformly using an optional parameter giving scale values about the x, y, and z axes.
 * @param model FEM model to be populated by ANSYS data
 * @param nodeReader reader supplying node data in the ANSYS format
 * @param elemReader reader supplying element data in the ANSYS format
 * @param density density of the model
 * @param scale if non-null, gives scaling about the x, y, and z axes
 * @param options option flags. Should be an or-ed combination of {@link #TETRAHEDRALIZE_HEXES} and {@link #ONE_BASED_NUMBERING}.
 * @throws IOException if this is a problem reading the file
 */
public static FemModel3d read(FemModel3d model,Reader nodeReader,Reader elemReader,double density,Vector3d scale,int options) throws IOException {
  boolean tetrahedralize=(options & TETRAHEDRALIZE_HEXES) != 0;
  boolean useAnsysNum=(options & ONE_BASED_NUMBERING) != 0;
  if (model == null) {
    model=new FemModel3d();
  }
 else {
    model.clear();
  }
  if (density >= 0) {
    model.setDensity(density);
  }
  if (useAnsysNum) {
    model.useAnsysNumbering();
  }
  LinkedHashMap<Integer,Point3d> nodeMap=readNodeFile(nodeReader,useAnsysNum);
  LinkedHashMap<Integer,Integer> nodeIdMap=new LinkedHashMap<Integer,Integer>();
  for (  int nodeId : nodeMap.keySet()) {
    Point3d pos=nodeMap.get(nodeId);
    if (scale != null) {
      pos.x*=scale.x;
      pos.y*=scale.y;
      pos.z*=scale.z;
    }
    FemNode3d node=new FemNode3d(pos);
    model.addNumberedNode(node,nodeId);
    nodeIdMap.put(nodeId,node.getNumber());
  }
  LinkedHashMap<Integer,ArrayList<Integer>> elemMap=readElemFile(elemReader,useAnsysNum);
  ArrayList<HexElement> hexElems=new ArrayList<HexElement>();
  boolean flip=false;
  if (scale != null) {
    double scaleProduct=scale.x * scale.y * scale.z;
    flip=(scaleProduct < 0);
  }
  for (  int elemId : elemMap.keySet()) {
    ArrayList<Integer> elemNumList=elemMap.get(elemId);
    int[] attrList=new int[5];
    for (int i=attrList.length - 1; i >= 0; i--) {
      attrList[i]=elemNumList.remove(0);
    }
    ArrayList<Integer> nodeList=getValidElemNodes(elemNumList,nodeIdMap,flip);
switch (nodeList.size()) {
case 4:
      createTet(model,nodeList,elemId,attrList);
    break;
case 5:
  createPyramid(model,nodeList,elemId,attrList);
break;
case 6:
createWedge(model,nodeList,elemId,attrList);
break;
case 8:
hexElems.add(createHex(model,nodeList,elemId,attrList));
break;
case 10:
createQuadTet(model,nodeList,elemId,attrList);
break;
case 20:
createQuadHex(model,nodeList,elemId,attrList);
break;
default :
System.out.println(""String_Node_Str"" + elemId + ""String_Node_Str""+ nodeList.size()+ ""String_Node_Str"");
}
}
HexElement.setParities(hexElems);
if (tetrahedralize) {
for (HexElement hex : hexElems) {
FemNode3d[] n=hex.getNodes();
TetElement[] tets=TetElement.createCubeTesselation(n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],hex.getParity() == 1);
model.removeElement(hex);
for (TetElement tet : tets) {
model.addElement(tet);
}
}
}
return model;
}"
