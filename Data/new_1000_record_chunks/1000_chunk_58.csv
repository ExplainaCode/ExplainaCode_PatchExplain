record_number,buggy_code,fixed_code
57001,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57002,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57003,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57004,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57005,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57006,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57007,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57008,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57009,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57010,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57011,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57012,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57013,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57014,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57015,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57016,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57017,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57018,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57019,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57020,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57021,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57022,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57023,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57024,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57025,"@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  CommandButton commandButton=(CommandButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String CID=component.getClientId(context);
  String type=commandButton.getType();
  if (null == type)   type=""String_Node_Str"";
  String style=commandButton.getStyle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  if (null != commandButton.getDir()) {
    rw.writeAttribute(""String_Node_Str"",commandButton.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,commandButton,rw);
  writeAttribute(rw,""String_Node_Str"",style,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(commandButton),""String_Node_Str"");
  String title=commandButton.getTitle();
  if (title != null && title.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",title,""String_Node_Str"");
  }
  if (commandButton.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!type.equals(""String_Node_Str"") && !type.equals(""String_Node_Str"")) {
    String formId=R.findComponentFormId(context,component);
    if (formId == null) {
      throw new FacesException(""String_Node_Str"" + CID + ""String_Node_Str"");
    }
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,commandButton,rw);
  R.encodeHTML4DHTMLAttrs(rw,commandButton.getAttributes(),H.ALLBUTTON);
}","@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  CommandButton commandButton=(CommandButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String CID=component.getClientId(context);
  String type=commandButton.getType();
  if (null == type)   type=""String_Node_Str"";
  String style=commandButton.getStyle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  if (null != commandButton.getDir()) {
    rw.writeAttribute(""String_Node_Str"",commandButton.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,commandButton,rw);
  writeAttribute(rw,""String_Node_Str"",style,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(commandButton),""String_Node_Str"");
  if (commandButton.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!type.equals(""String_Node_Str"") && !type.equals(""String_Node_Str"")) {
    String formId=R.findComponentFormId(context,component);
    if (formId == null) {
      throw new FacesException(""String_Node_Str"" + CID + ""String_Node_Str"");
    }
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,commandButton,rw);
  R.encodeHTML4DHTMLAttrs(rw,commandButton.getAttributes(),H.ALLBUTTON);
}"
57026,"/** 
 * Encode the HTML code of the button.
 * @param context the current FacesContext
 * @param attrs the attribute list
 * @throws IOException thrown if something's wrong with the ResponseWriter
 */
public void encodeHTML(FacesContext context,Map<String,Object> attrs) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  Object value=attrs.get(""String_Node_Str"");
  String style=asString(attrs.get(STYLE));
  rw.startElement(""String_Node_Str"",this);
  rw.writeAttribute(""String_Node_Str"",getClientId(context),""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",getClientId(context),""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  if (style != null) {
    rw.writeAttribute(STYLE,style,STYLE);
  }
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(attrs),""String_Node_Str"");
  Tooltip.generateTooltip(context,attrs,rw);
  final String clickHandler=encodeClick(context,attrs);
  if (null != clickHandler && clickHandler.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",clickHandler,null);
  }
  String d=asString(attrs.get(DISMISS));
  if (d != null) {
    rw.writeAttribute(DATA_DISMISS,d,null);
  }
  boolean disabled=(toBool(attrs.get(DISABLED)));
  if (disabled) {
    rw.writeAttribute(DISABLED,DISABLED,null);
  }
  renderPassThruAttributes(context,this,ALLBUTTON_ATTRS);
  String icon=asString(attrs.get(ICON));
  String faicon=asString(attrs.get(ICONAWESOME));
  boolean fa=false;
  if (faicon != null) {
    icon=faicon;
    fa=true;
  }
  if (icon != null) {
    Object ialign=attrs.get(ICON_ALIGN);
    if (ialign != null && ialign.equals(RIGHT)) {
      rw.writeText(value + ""String_Node_Str"",null);
      IconRenderer.encodeIcon(rw,this,icon,fa);
    }
 else {
      IconRenderer.encodeIcon(rw,this,icon,fa);
      rw.writeText(""String_Node_Str"" + value,null);
    }
  }
 else {
    rw.writeText(value,null);
  }
  Tooltip.activateTooltips(context,getAttributes(),this);
  rw.endElement(""String_Node_Str"");
}","/** 
 * Encode the HTML code of the button.
 * @param context the current FacesContext
 * @param attrs the attribute list
 * @throws IOException thrown if something's wrong with the ResponseWriter
 */
public void encodeHTML(FacesContext context,Map<String,Object> attrs) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  Object value=attrs.get(""String_Node_Str"");
  String style=asString(attrs.get(STYLE));
  rw.startElement(""String_Node_Str"",this);
  rw.writeAttribute(""String_Node_Str"",getClientId(context),""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",getClientId(context),""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  if (null != attrs.get(""String_Node_Str"")) {
    rw.writeAttribute(""String_Node_Str"",attrs.get(""String_Node_Str""),""String_Node_Str"");
  }
  if (style != null) {
    rw.writeAttribute(STYLE,style,STYLE);
  }
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(attrs),""String_Node_Str"");
  Tooltip.generateTooltip(context,attrs,rw);
  final String clickHandler=encodeClick(context,attrs);
  if (null != clickHandler && clickHandler.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",clickHandler,null);
  }
  String d=asString(attrs.get(DISMISS));
  if (d != null) {
    rw.writeAttribute(DATA_DISMISS,d,null);
  }
  boolean disabled=(toBool(attrs.get(DISABLED)));
  if (disabled) {
    rw.writeAttribute(DISABLED,DISABLED,null);
  }
  renderPassThruAttributes(context,this,ALLBUTTON_ATTRS);
  String icon=asString(attrs.get(ICON));
  String faicon=asString(attrs.get(ICONAWESOME));
  boolean fa=false;
  if (faicon != null) {
    icon=faicon;
    fa=true;
  }
  if (icon != null) {
    Object ialign=attrs.get(ICON_ALIGN);
    if (ialign != null && ialign.equals(RIGHT)) {
      rw.writeText(value + ""String_Node_Str"",null);
      IconRenderer.encodeIcon(rw,this,icon,fa);
    }
 else {
      IconRenderer.encodeIcon(rw,this,icon,fa);
      rw.writeText(""String_Node_Str"" + value,null);
    }
  }
 else {
    rw.writeText(value,null);
  }
  Tooltip.activateTooltips(context,getAttributes(),this);
  rw.endElement(""String_Node_Str"");
}"
57027,"@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  CommandButton commandButton=(CommandButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String CID=component.getClientId(context);
  String type=commandButton.getType();
  if (null == type)   type=""String_Node_Str"";
  String style=commandButton.getStyle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  Tooltip.generateTooltip(context,commandButton,rw);
  writeAttribute(rw,H.STYLE,style,H.STYLE);
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(commandButton),""String_Node_Str"");
  String title=commandButton.getTitle();
  if (title != null && title.length() > 0) {
    rw.writeAttribute(H.TITLE,title,H.TITLE);
  }
  if (commandButton.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!type.equals(""String_Node_Str"") && !type.equals(""String_Node_Str"")) {
    String formId=R.findComponentFormId(context,component);
    if (formId == null) {
      throw new FacesException(""String_Node_Str"" + CID + ""String_Node_Str"");
    }
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScriptForCommandButtons(context,commandButton,rw);
  R.encodeHTML4DHTMLAttrs(rw,commandButton.getAttributes(),A.ALLBUTTON_ATTRS);
}","@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  CommandButton commandButton=(CommandButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String CID=component.getClientId(context);
  String type=commandButton.getType();
  if (null == type)   type=""String_Node_Str"";
  String style=commandButton.getStyle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  if (null != commandButton.getDir()) {
    rw.writeAttribute(""String_Node_Str"",commandButton.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,commandButton,rw);
  writeAttribute(rw,H.STYLE,style,H.STYLE);
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(commandButton),""String_Node_Str"");
  String title=commandButton.getTitle();
  if (title != null && title.length() > 0) {
    rw.writeAttribute(H.TITLE,title,H.TITLE);
  }
  if (commandButton.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!type.equals(""String_Node_Str"") && !type.equals(""String_Node_Str"")) {
    String formId=R.findComponentFormId(context,component);
    if (formId == null) {
      throw new FacesException(""String_Node_Str"" + CID + ""String_Node_Str"");
    }
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScriptForCommandButtons(context,commandButton,rw);
  R.encodeHTML4DHTMLAttrs(rw,commandButton.getAttributes(),A.ALLBUTTON_ATTRS);
}"
57028,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputText inputText=(InputText)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  UIComponent prep=inputText.getFacet(C.PREPEND);
  UIComponent app=inputText.getFacet(C.APPEND);
  boolean prepend=(prep != null);
  boolean append=(app != null);
  if (prepend) {
    R.addClass2FacetComponent(prep,""String_Node_Str"",InputText.ADDON);
    if (prep instanceof Icon)     ((Icon)prep).setAddon(true);
  }
  if (append) {
    R.addClass2FacetComponent(app,""String_Node_Str"",InputText.ADDON);
    if (app instanceof Icon)     ((Icon)app).setAddon(true);
  }
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=H.PASSWORD;
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      prep.encodeAll(context);
    }
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,A.INPUT_TEXT_ATTRS);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      app.encodeAll(context);
    }
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputText inputText=(InputText)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  UIComponent prep=inputText.getFacet(C.PREPEND);
  UIComponent app=inputText.getFacet(C.APPEND);
  boolean prepend=(prep != null);
  boolean append=(app != null);
  if (prepend) {
    R.addClass2FacetComponent(prep,""String_Node_Str"",InputText.ADDON);
    if (prep instanceof Icon)     ((Icon)prep).setAddon(true);
  }
  if (append) {
    R.addClass2FacetComponent(app,""String_Node_Str"",InputText.ADDON);
    if (app instanceof Icon)     ((Icon)app).setAddon(true);
  }
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=H.PASSWORD;
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      prep.encodeAll(context);
    }
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,A.INPUT_TEXT_ATTRS);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      app.encodeAll(context);
    }
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}"
57029,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputTextarea inputText=(InputTextarea)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  UIComponent prep=inputText.getFacet(C.PREPEND);
  UIComponent app=inputText.getFacet(C.APPEND);
  boolean prepend=(prep != null);
  boolean append=(app != null);
  if (prepend) {
    R.addClass2FacetComponent(prep,""String_Node_Str"",InputTextarea.ADDON);
    if (prep instanceof Icon)     ((Icon)prep).setAddon(true);
  }
  if (append) {
    R.addClass2FacetComponent(app,""String_Node_Str"",InputTextarea.ADDON);
    if (app instanceof Icon)     ((Icon)app).setAddon(true);
  }
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=H.PASSWORD;
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      prep.encodeAll(context);
    }
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  rw.writeAttribute(""String_Node_Str"",inputText.getRows(),""String_Node_Str"");
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,A.INPUT_TEXT_ATTRS);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  String v=getValue2Render(context,component);
  if (null == v)   v=""String_Node_Str"";
  rw.writeText(v,null);
  rw.endElement(""String_Node_Str"");
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      app.encodeAll(context);
    }
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputTextarea inputText=(InputTextarea)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  UIComponent prep=inputText.getFacet(C.PREPEND);
  UIComponent app=inputText.getFacet(C.APPEND);
  boolean prepend=(prep != null);
  boolean append=(app != null);
  if (prepend) {
    R.addClass2FacetComponent(prep,""String_Node_Str"",InputTextarea.ADDON);
    if (prep instanceof Icon)     ((Icon)prep).setAddon(true);
  }
  if (append) {
    R.addClass2FacetComponent(app,""String_Node_Str"",InputTextarea.ADDON);
    if (app instanceof Icon)     ((Icon)app).setAddon(true);
  }
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=H.PASSWORD;
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      prep.encodeAll(context);
    }
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  rw.writeAttribute(""String_Node_Str"",inputText.getRows(),""String_Node_Str"");
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,A.INPUT_TEXT_ATTRS);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  String v=getValue2Render(context,component);
  if (null == v)   v=""String_Node_Str"";
  rw.writeText(v,null);
  rw.endElement(""String_Node_Str"");
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      app.encodeAll(context);
    }
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}"
57030,"/** 
 * This methods generates the HTML code of the current b:message.
 * @param context the FacesContext.
 * @param component the current b:message.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Message message=(Message)component;
  String forValue=message.getFor();
  if (null == forValue || forValue.length() == 0)   forValue=""String_Node_Str"";
  forValue=ExpressionResolver.getComponentIDs(context,message,forValue);
  List<FacesMessage> messageList=new ArrayList<FacesMessage>();
  Iterator<FacesMessage> messageIterator=FacesContext.getCurrentInstance().getMessages(forValue);
  while (messageIterator.hasNext()) {
    FacesMessage fm=messageIterator.next();
    messageList.add(fm);
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=message.getClientId();
  if (null != messageList && (!messageList.isEmpty())) {
    rw.startElement(""String_Node_Str"",message);
    writeAttribute(rw,""String_Node_Str"",clientId);
    String styleClass=message.getStyleClass();
    if (null != styleClass && styleClass.length() > 0)     styleClass=styleClass + ""String_Node_Str"";
 else     styleClass=""String_Node_Str"";
    String severityClass=findHighestSeverityClass(messageList,message);
    styleClass+=""String_Node_Str"" + severityClass + ""String_Node_Str"";
    writeAttribute(rw,""String_Node_Str"",styleClass);
    writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
    for (    FacesMessage msg : messageList) {
      if (message.isShowIcon()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowSummary()) {
        if (msg.getSummary() != null && (!msg.getSummary().equals(msg.getDetail()))) {
          rw.startElement(""String_Node_Str"",component);
          writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
          rw.writeText(msg.getSummary(),null);
          rw.endElement(""String_Node_Str"");
        }
      }
      if (message.isShowDetail()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.writeText(msg.getDetail(),null);
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
}","/** 
 * This methods generates the HTML code of the current b:message.
 * @param context the FacesContext.
 * @param component the current b:message.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Message message=(Message)component;
  String forValue=message.getFor();
  if (null == forValue || forValue.length() == 0)   forValue=""String_Node_Str"";
  forValue=ExpressionResolver.getComponentIDs(context,message,forValue);
  List<FacesMessage> messageList=new ArrayList<FacesMessage>();
  Iterator<FacesMessage> messageIterator=FacesContext.getCurrentInstance().getMessages(forValue);
  while (messageIterator.hasNext()) {
    FacesMessage fm=messageIterator.next();
    messageList.add(fm);
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=message.getClientId();
  if (null != messageList && (!messageList.isEmpty())) {
    rw.startElement(""String_Node_Str"",message);
    writeAttribute(rw,""String_Node_Str"",clientId);
    if (null != message.getDir()) {
      rw.writeAttribute(""String_Node_Str"",message.getDir(),""String_Node_Str"");
    }
    String styleClass=message.getStyleClass();
    if (null != styleClass && styleClass.length() > 0)     styleClass=styleClass + ""String_Node_Str"";
 else     styleClass=""String_Node_Str"";
    String severityClass=findHighestSeverityClass(messageList,message);
    styleClass+=""String_Node_Str"" + severityClass + ""String_Node_Str"";
    writeAttribute(rw,""String_Node_Str"",styleClass);
    writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
    for (    FacesMessage msg : messageList) {
      if (message.isShowIcon()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowSummary()) {
        if (msg.getSummary() != null && (!msg.getSummary().equals(msg.getDetail()))) {
          rw.startElement(""String_Node_Str"",component);
          writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
          rw.writeText(msg.getSummary(),null);
          rw.endElement(""String_Node_Str"");
        }
      }
      if (message.isShowDetail()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.writeText(msg.getDetail(),null);
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
}"
57031,"@Override public void encodeEnd(FacesContext facesContext,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  UIMessages uiMessages=(UIMessages)component;
  ResponseWriter writer=facesContext.getResponseWriter();
  String clientId=uiMessages.getClientId(facesContext);
  Iterator<FacesMessage> allMessages=uiMessages.isGlobalOnly() ? facesContext.getMessages(null) : facesContext.getMessages();
  Map<String,List<FacesMessage>> messages=new HashMap<String,List<FacesMessage>>();
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  while (allMessages.hasNext()) {
    FacesMessage message=allMessages.next();
    Severity severity=message.getSeverity();
    if (message.isRendered() && !uiMessages.isRedisplay()) {
      continue;
    }
    if (severity.equals(FacesMessage.SEVERITY_INFO))     messages.get(""String_Node_Str"").add(message);
 else     if (severity.equals(FacesMessage.SEVERITY_WARN))     messages.get(""String_Node_Str"").add(message);
 else     if (severity.equals(FacesMessage.SEVERITY_ERROR))     messages.get(""String_Node_Str"").add(message);
 else     if (severity.equals(FacesMessage.SEVERITY_FATAL))     messages.get(""String_Node_Str"").add(message);
  }
  writer.startElement(""String_Node_Str"",uiMessages);
  writer.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  for (  String severity : messages.keySet()) {
    List<FacesMessage> severityMessages=messages.get(severity);
    if (severityMessages.size() > 0) {
      encodeSeverityMessages(facesContext,uiMessages,severity,severityMessages);
    }
  }
  writer.endElement(""String_Node_Str"");
}","@Override public void encodeEnd(FacesContext facesContext,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Messages uiMessages=(Messages)component;
  ResponseWriter writer=facesContext.getResponseWriter();
  String clientId=uiMessages.getClientId(facesContext);
  Iterator<FacesMessage> allMessages=uiMessages.isGlobalOnly() ? facesContext.getMessages(null) : facesContext.getMessages();
  Map<String,List<FacesMessage>> messages=new HashMap<String,List<FacesMessage>>();
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  messages.put(""String_Node_Str"",new ArrayList<FacesMessage>());
  while (allMessages.hasNext()) {
    FacesMessage message=allMessages.next();
    Severity severity=message.getSeverity();
    if (message.isRendered() && !uiMessages.isRedisplay()) {
      continue;
    }
    if (severity.equals(FacesMessage.SEVERITY_INFO))     messages.get(""String_Node_Str"").add(message);
 else     if (severity.equals(FacesMessage.SEVERITY_WARN))     messages.get(""String_Node_Str"").add(message);
 else     if (severity.equals(FacesMessage.SEVERITY_ERROR))     messages.get(""String_Node_Str"").add(message);
 else     if (severity.equals(FacesMessage.SEVERITY_FATAL))     messages.get(""String_Node_Str"").add(message);
  }
  writer.startElement(""String_Node_Str"",uiMessages);
  if (null != uiMessages.getDir()) {
    writer.writeAttribute(""String_Node_Str"",uiMessages.getDir(),""String_Node_Str"");
  }
  writer.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  for (  String severity : messages.keySet()) {
    List<FacesMessage> severityMessages=messages.get(severity);
    if (severityMessages.size() > 0) {
      encodeSeverityMessages(facesContext,uiMessages,severity,severityMessages);
    }
  }
  writer.endElement(""String_Node_Str"");
}"
57032,"/** 
 * Start the column span div (if there's one). This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected int startColSpanDiv(ResponseWriter rw,SelectBooleanCheckbox selectBooleanCheckbox) throws IOException {
  int span=selectBooleanCheckbox.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  return span;
}","/** 
 * Start the column span div (if there's one). This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected int startColSpanDiv(ResponseWriter rw,SelectBooleanCheckbox selectBooleanCheckbox) throws IOException {
  int span=selectBooleanCheckbox.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
    if (null != selectBooleanCheckbox.getDir()) {
      rw.writeAttribute(""String_Node_Str"",selectBooleanCheckbox.getDir(),""String_Node_Str"");
    }
  }
  return span;
}"
57033,"/** 
 * This methods generates the HTML code of the current b:selectBooleanCheckbox.
 * @param context the FacesContext.
 * @param component the current b:selectBooleanCheckbox.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  SelectBooleanCheckbox selectBooleanCheckbox=(SelectBooleanCheckbox)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=selectBooleanCheckbox.getClientId();
  addLabel(rw,clientId,selectBooleanCheckbox);
  UIComponent prependingAddOnFacet=selectBooleanCheckbox.getFacet(C.PREPEND);
  if ((prependingAddOnFacet != null)) {
    R.addClass2FacetComponent(prependingAddOnFacet,""String_Node_Str"",ADDON);
  }
  UIComponent appendingAddOnFacet=selectBooleanCheckbox.getFacet(C.APPEND);
  if ((appendingAddOnFacet != null)) {
    R.addClass2FacetComponent(appendingAddOnFacet,""String_Node_Str"",ADDON);
  }
  final boolean hasAddon=startInputGroupForAddOn(rw,(prependingAddOnFacet != null),(appendingAddOnFacet != null),selectBooleanCheckbox);
  int span=startColSpanDiv(rw,selectBooleanCheckbox);
  addPrependingAddOnToInputGroup(context,rw,prependingAddOnFacet,(prependingAddOnFacet != null),selectBooleanCheckbox);
  renderInputTag(context,rw,clientId,selectBooleanCheckbox);
  addAppendingAddOnToInputGroup(context,rw,appendingAddOnFacet,(appendingAddOnFacet != null),selectBooleanCheckbox);
  closeInputGroupForAddOn(rw,hasAddon);
  closeColSpanDiv(rw,span);
  Tooltip.activateTooltips(context,selectBooleanCheckbox);
}","/** 
 * This methods generates the HTML code of the current b:selectBooleanCheckbox.
 * @param context the FacesContext.
 * @param component the current b:selectBooleanCheckbox.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  SelectBooleanCheckbox selectBooleanCheckbox=(SelectBooleanCheckbox)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=selectBooleanCheckbox.getClientId();
  int span=startColSpanDiv(rw,selectBooleanCheckbox);
  addLabel(rw,clientId,selectBooleanCheckbox);
  UIComponent prependingAddOnFacet=selectBooleanCheckbox.getFacet(C.PREPEND);
  if ((prependingAddOnFacet != null)) {
    R.addClass2FacetComponent(prependingAddOnFacet,""String_Node_Str"",ADDON);
  }
  UIComponent appendingAddOnFacet=selectBooleanCheckbox.getFacet(C.APPEND);
  if ((appendingAddOnFacet != null)) {
    R.addClass2FacetComponent(appendingAddOnFacet,""String_Node_Str"",ADDON);
  }
  final boolean hasAddon=startInputGroupForAddOn(rw,(prependingAddOnFacet != null),(appendingAddOnFacet != null),selectBooleanCheckbox);
  addPrependingAddOnToInputGroup(context,rw,prependingAddOnFacet,(prependingAddOnFacet != null),selectBooleanCheckbox);
  renderInputTag(context,rw,clientId,selectBooleanCheckbox);
  addAppendingAddOnToInputGroup(context,rw,appendingAddOnFacet,(appendingAddOnFacet != null),selectBooleanCheckbox);
  closeInputGroupForAddOn(rw,hasAddon);
  closeColSpanDiv(rw,span);
  Tooltip.activateTooltips(context,selectBooleanCheckbox);
}"
57034,"/** 
 * Renders the optional label. This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param clientId the id used by the label to reference the input field
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected void addLabel(ResponseWriter rw,String clientId,SelectBooleanCheckbox selectBooleanCheckbox) throws IOException {
  if (selectBooleanCheckbox.isRenderLabel()) {
    String label=selectBooleanCheckbox.getLabel();
    if (label != null) {
      rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
      rw.writeText(label,null);
      rw.endElement(""String_Node_Str"");
    }
  }
}","/** 
 * Renders the optional label. This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param clientId the id used by the label to reference the input field
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected void addLabel(ResponseWriter rw,String clientId,SelectBooleanCheckbox selectBooleanCheckbox) throws IOException {
  if (selectBooleanCheckbox.isRenderLabel()) {
    String label=selectBooleanCheckbox.getLabel();
    if (label != null) {
      rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
      if (null != selectBooleanCheckbox.getDir()) {
        rw.writeAttribute(""String_Node_Str"",selectBooleanCheckbox.getDir(),""String_Node_Str"");
      }
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
      rw.writeText(label,null);
      rw.endElement(""String_Node_Str"");
    }
  }
}"
57035,"/** 
 * Starts the input field group (if needed to display a component seamlessly in front of or behind the input field). This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param hasPrependingAddOn
 * @param hasAppendingAddOn
 * @param selectBooleanCheckbox the component to render
 * @return true if there is an add-on in front of or behind the input field
 * @throws IOException may be thrown by the response writer
 */
protected boolean startInputGroupForAddOn(ResponseWriter rw,boolean hasPrependingAddOn,boolean hasAppendingAddOn,SelectBooleanCheckbox selectBooleanCheckbox) throws IOException {
  final boolean hasAddon=hasAppendingAddOn || hasPrependingAddOn;
  if (hasAddon) {
    rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  return hasAddon;
}","/** 
 * Starts the input field group (if needed to display a component seamlessly in front of or behind the input field). This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param hasPrependingAddOn
 * @param hasAppendingAddOn
 * @param selectBooleanCheckbox the component to render
 * @return true if there is an add-on in front of or behind the input field
 * @throws IOException may be thrown by the response writer
 */
protected boolean startInputGroupForAddOn(ResponseWriter rw,boolean hasPrependingAddOn,boolean hasAppendingAddOn,SelectBooleanCheckbox selectBooleanCheckbox) throws IOException {
  final boolean hasAddon=hasAppendingAddOn || hasPrependingAddOn;
  if (hasAddon) {
    rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (null != selectBooleanCheckbox.getDir()) {
      rw.writeAttribute(""String_Node_Str"",selectBooleanCheckbox.getDir(),""String_Node_Str"");
    }
  }
  return hasAddon;
}"
57036,"/** 
 * Renders the start of the input tag. This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected void renderInputTag(ResponseWriter rw,FacesContext context,SelectBooleanCheckbox selectBooleanCheckbox,String clientId) throws IOException {
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  Tooltip.generateTooltip(context,selectBooleanCheckbox,rw);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
}","/** 
 * Renders the start of the input tag. This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected void renderInputTag(ResponseWriter rw,FacesContext context,SelectBooleanCheckbox selectBooleanCheckbox,String clientId) throws IOException {
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  if (null != selectBooleanCheckbox.getDir()) {
    rw.writeAttribute(""String_Node_Str"",selectBooleanCheckbox.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,selectBooleanCheckbox,rw);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
}"
57037,"/** 
 * Generates the HTML code for this component. 
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  SelectMultiMenu menu=(SelectMultiMenu)component;
  if (!menu.isRendered()) {
    return;
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=menu.getClientId(context).replace(""String_Node_Str"",""String_Node_Str"");
  ;
  rw.startElement(""String_Node_Str"",menu);
  Tooltip.generateTooltip(context,menu,rw);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addLabel(rw,clientId,menu);
  UIComponent prependingAddOnFacet=menu.getFacet(C.PREPEND);
  if ((prependingAddOnFacet != null)) {
    R.addClass2FacetComponent(prependingAddOnFacet,""String_Node_Str"",ADDON);
  }
  UIComponent appendingAddOnFacet=menu.getFacet(C.APPEND);
  if ((appendingAddOnFacet != null)) {
    R.addClass2FacetComponent(appendingAddOnFacet,""String_Node_Str"",ADDON);
  }
  final boolean hasAddon=startInputGroupForAddOn(rw,(prependingAddOnFacet != null),(appendingAddOnFacet != null),menu);
  int span=startColSpanDiv(rw,menu);
  addPrependingAddOnToInputGroup(context,rw,prependingAddOnFacet,(prependingAddOnFacet != null),menu);
  renderSelectTag(context,rw,clientId,menu);
  addAppendingAddOnToInputGroup(context,rw,appendingAddOnFacet,(appendingAddOnFacet != null),menu);
  closeInputGroupForAddOn(rw,hasAddon);
  closeColSpanDiv(rw,span);
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,menu);
  String options=""String_Node_Str"";
  int maxHeight=menu.getMaxHeight();
  if (maxHeight > 0) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + String.valueOf(maxHeight);
  }
  String nonSelectedText=menu.getNonSelectedText();
  if (nonSelectedText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + nonSelectedText + ""String_Node_Str"";
  }
  String nSelectedText=menu.getNSelectedText();
  nSelectedText=(String)menu.getAttributes().get(""String_Node_Str"");
  if (nSelectedText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + nSelectedText + ""String_Node_Str"";
  }
  String allSelectedText=menu.getAllSelectedText();
  if (allSelectedText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + allSelectedText + ""String_Node_Str"";
  }
  int numberDisplayed=menu.getNumberDisplayed();
  if (numberDisplayed > 0) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + String.valueOf(numberDisplayed);
  }
  if (menu.isIncludeSelectAllOption()) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  String selectAllText=menu.getSelectAllText();
  if (selectAllText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + selectAllText + ""String_Node_Str"";
  }
  if (menu.isEnableFiltering()) {
    options+=""String_Node_Str"" + ""String_Node_Str"";
  }
  String filterPlaceholder=menu.getFilterPlaceholder();
  if (filterPlaceholder != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + filterPlaceholder + ""String_Node_Str"";
  }
  boolean enableCaseInsensitiveFiltering=menu.isEnableCaseInsensitiveFiltering();
  if (enableCaseInsensitiveFiltering) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  boolean disableIfEmpty=menu.isDisableIfEmpty();
  if (disableIfEmpty) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  boolean dropRight=menu.isDropRight();
  if (dropRight) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  String onChange=menu.getOnchange();
  if (onChange != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + onChange;
  }
  String onDropdownShow=menu.getOndropdownshow();
  if (onDropdownShow != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + onDropdownShow;
  }
  String onDropdownHide=menu.getOndropdownhide();
  if (onDropdownHide != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + onDropdownHide;
  }
  String buttonClass=menu.getButtonClass();
  if (buttonClass != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + buttonClass + ""String_Node_Str"";
  }
  String styleClass=menu.getStyleClass();
  if (styleClass != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + styleClass + ""String_Node_Str"";
  }
  int buttonWidth=menu.getButtonWidth();
  if (buttonWidth > 0) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + buttonWidth + ""String_Node_Str"";
  }
  if (options.length() > 0) {
    options=""String_Node_Str"" + options.substring(1,options.length()) + ""String_Node_Str"";
  }
  String js=""String_Node_Str"" + clientId + ""String_Node_Str""+ options+ ""String_Node_Str"";
  context.getResponseWriter().write(""String_Node_Str"" + js + ""String_Node_Str"");
}","/** 
 * Generates the HTML code for this component. 
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  SelectMultiMenu menu=(SelectMultiMenu)component;
  if (!menu.isRendered()) {
    return;
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=menu.getClientId(context).replace(""String_Node_Str"",""String_Node_Str"");
  ;
  rw.startElement(""String_Node_Str"",menu);
  writeAttribute(rw,""String_Node_Str"",menu.getDir(),""String_Node_Str"");
  Tooltip.generateTooltip(context,menu,rw);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addLabel(rw,clientId,menu);
  UIComponent prependingAddOnFacet=menu.getFacet(C.PREPEND);
  if ((prependingAddOnFacet != null)) {
    R.addClass2FacetComponent(prependingAddOnFacet,""String_Node_Str"",ADDON);
  }
  UIComponent appendingAddOnFacet=menu.getFacet(C.APPEND);
  if ((appendingAddOnFacet != null)) {
    R.addClass2FacetComponent(appendingAddOnFacet,""String_Node_Str"",ADDON);
  }
  final boolean hasAddon=startInputGroupForAddOn(rw,(prependingAddOnFacet != null),(appendingAddOnFacet != null),menu);
  int span=startColSpanDiv(rw,menu);
  addPrependingAddOnToInputGroup(context,rw,prependingAddOnFacet,(prependingAddOnFacet != null),menu);
  renderSelectTag(context,rw,clientId,menu);
  addAppendingAddOnToInputGroup(context,rw,appendingAddOnFacet,(appendingAddOnFacet != null),menu);
  closeInputGroupForAddOn(rw,hasAddon);
  closeColSpanDiv(rw,span);
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,menu);
  String options=""String_Node_Str"";
  int maxHeight=menu.getMaxHeight();
  if (maxHeight > 0) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + String.valueOf(maxHeight);
  }
  String nonSelectedText=menu.getNonSelectedText();
  if (nonSelectedText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + nonSelectedText + ""String_Node_Str"";
  }
  String nSelectedText=menu.getNSelectedText();
  nSelectedText=(String)menu.getAttributes().get(""String_Node_Str"");
  if (nSelectedText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + nSelectedText + ""String_Node_Str"";
  }
  String allSelectedText=menu.getAllSelectedText();
  if (allSelectedText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + allSelectedText + ""String_Node_Str"";
  }
  int numberDisplayed=menu.getNumberDisplayed();
  if (numberDisplayed > 0) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + String.valueOf(numberDisplayed);
  }
  if (menu.isIncludeSelectAllOption()) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  String selectAllText=menu.getSelectAllText();
  if (selectAllText != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + selectAllText + ""String_Node_Str"";
  }
  if (menu.isEnableFiltering()) {
    options+=""String_Node_Str"" + ""String_Node_Str"";
  }
  String filterPlaceholder=menu.getFilterPlaceholder();
  if (filterPlaceholder != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + filterPlaceholder + ""String_Node_Str"";
  }
  boolean enableCaseInsensitiveFiltering=menu.isEnableCaseInsensitiveFiltering();
  if (enableCaseInsensitiveFiltering) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  boolean disableIfEmpty=menu.isDisableIfEmpty();
  if (disableIfEmpty) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  boolean dropRight=menu.isDropRight();
  if (dropRight) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"";
  }
  String onChange=menu.getOnchange();
  if (onChange != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + onChange;
  }
  String onDropdownShow=menu.getOndropdownshow();
  if (onDropdownShow != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + onDropdownShow;
  }
  String onDropdownHide=menu.getOndropdownhide();
  if (onDropdownHide != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + onDropdownHide;
  }
  String buttonClass=menu.getButtonClass();
  if (buttonClass != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + buttonClass + ""String_Node_Str"";
  }
  String styleClass=menu.getStyleClass();
  if (styleClass != null) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + styleClass + ""String_Node_Str"";
  }
  int buttonWidth=menu.getButtonWidth();
  if (buttonWidth > 0) {
    options+=""String_Node_Str"" + ""String_Node_Str"" + buttonWidth + ""String_Node_Str"";
  }
  if (options.length() > 0) {
    options=""String_Node_Str"" + options.substring(1,options.length()) + ""String_Node_Str"";
  }
  String js=""String_Node_Str"" + clientId + ""String_Node_Str""+ options+ ""String_Node_Str"";
  context.getResponseWriter().write(""String_Node_Str"" + js + ""String_Node_Str"");
}"
57038,"/** 
 * Generates the HTML code for this component. 
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  SelectOneMenu menu=(SelectOneMenu)component;
  if (!menu.isRendered()) {
    return;
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=menu.getClientId(context);
  rw.startElement(""String_Node_Str"",menu);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  addLabel(rw,clientId,menu);
  UIComponent prependingAddOnFacet=menu.getFacet(C.PREPEND);
  if ((prependingAddOnFacet != null)) {
    R.addClass2FacetComponent(prependingAddOnFacet,""String_Node_Str"",ADDON);
  }
  UIComponent appendingAddOnFacet=menu.getFacet(C.APPEND);
  if ((appendingAddOnFacet != null)) {
    R.addClass2FacetComponent(appendingAddOnFacet,""String_Node_Str"",ADDON);
  }
  final boolean hasAddon=startInputGroupForAddOn(rw,(prependingAddOnFacet != null),(appendingAddOnFacet != null),menu);
  int span=startColSpanDiv(rw,menu);
  addPrependingAddOnToInputGroup(context,rw,prependingAddOnFacet,(prependingAddOnFacet != null),menu);
  renderSelectTag(context,rw,clientId,menu);
  addAppendingAddOnToInputGroup(context,rw,appendingAddOnFacet,(appendingAddOnFacet != null),menu);
  closeInputGroupForAddOn(rw,hasAddon);
  closeColSpanDiv(rw,span);
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,menu);
}","/** 
 * Generates the HTML code for this component. 
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  SelectOneMenu menu=(SelectOneMenu)component;
  if (!menu.isRendered()) {
    return;
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=menu.getClientId(context);
  rw.startElement(""String_Node_Str"",menu);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",menu.getDir(),""String_Node_Str"");
  addLabel(rw,clientId,menu);
  UIComponent prependingAddOnFacet=menu.getFacet(C.PREPEND);
  if ((prependingAddOnFacet != null)) {
    R.addClass2FacetComponent(prependingAddOnFacet,""String_Node_Str"",ADDON);
  }
  UIComponent appendingAddOnFacet=menu.getFacet(C.APPEND);
  if ((appendingAddOnFacet != null)) {
    R.addClass2FacetComponent(appendingAddOnFacet,""String_Node_Str"",ADDON);
  }
  final boolean hasAddon=startInputGroupForAddOn(rw,(prependingAddOnFacet != null),(appendingAddOnFacet != null),menu);
  int span=startColSpanDiv(rw,menu);
  addPrependingAddOnToInputGroup(context,rw,prependingAddOnFacet,(prependingAddOnFacet != null),menu);
  renderSelectTag(context,rw,clientId,menu);
  addAppendingAddOnToInputGroup(context,rw,appendingAddOnFacet,(appendingAddOnFacet != null),menu);
  closeInputGroupForAddOn(rw,hasAddon);
  closeColSpanDiv(rw,span);
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,menu);
}"
57039,"@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String clientId=component.getClientId();
  Switch _switch=(Switch)component;
  rw.startElement(""String_Node_Str"",_switch);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  renderInputTagAttributes(rw,clientId,_switch);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),_switch,rw);
  renderInputTagValue(context,rw,_switch);
  rw.endElement(""String_Node_Str"");
  clientId=clientId.replace(""String_Node_Str"",""String_Node_Str"");
  rw.append(""String_Node_Str"");
  rw.append(""String_Node_Str"" + clientId + ""String_Node_Str"");
  rw.append(""String_Node_Str"");
}","@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String clientId=component.getClientId();
  super.encodeBegin(context,component);
  clientId=clientId.replace(""String_Node_Str"",""String_Node_Str"");
  rw.append(""String_Node_Str"");
  rw.append(""String_Node_Str"" + clientId + ""String_Node_Str"");
  rw.append(""String_Node_Str"");
}"
57040,"/** 
 * This methods generates the HTML code of the current b:panel. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:panel.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Panel panel=(Panel)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=panel.getClientId();
  String jQueryClientID=clientId.replace(""String_Node_Str"",""String_Node_Str"");
  boolean isCollapsible=panel.isCollapsible();
  if (isCollapsible) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String _look=panel.getLook();
  String _title=panel.getTitle();
  String _titleClass=panel.getTitleClass();
  String _styleClass=panel.getStyleClass();
  if (null == _styleClass) {
    _styleClass=""String_Node_Str"";
  }
 else {
    _styleClass+=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,panel,rw);
  Tooltip.generateTooltip(context,panel,rw);
  String _style=panel.getStyle();
  if (null != _style && _style.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_style,""String_Node_Str"");
  }
  if (_look != null) {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"" + _look,""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"",""String_Node_Str"");
  }
  UIComponent head=panel.getFacet(""String_Node_Str"");
  if (head != null || _title != null) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    String _titleStyle=panel.getTitleStyle();
    if (null != _titleStyle) {
      rw.writeAttribute(""String_Node_Str"",_titleStyle,""String_Node_Str"");
    }
    if (_title != null) {
      rw.startElement(""String_Node_Str"",panel);
      if (_titleClass != null) {
        rw.writeAttribute(""String_Node_Str"",_titleClass,""String_Node_Str"");
      }
 else {
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      if (isCollapsible) {
        rw.startElement(""String_Node_Str"",panel);
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + jQueryClientID + ""String_Node_Str"",""String_Node_Str"");
        if (panel.isCollapsed()) {
          rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
        }
      }
      rw.writeText(_title,null);
      rw.endElement(""String_Node_Str"");
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (isCollapsible) {
        rw.startElement(""String_Node_Str"",panel);
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + jQueryClientID + ""String_Node_Str"",""String_Node_Str"");
        if (panel.isCollapsed()) {
          rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
        }
      }
      head.encodeAll(context);
      if (isCollapsible) {
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",jQueryClientID + ""String_Node_Str"",null);
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  String _contentClass=panel.getContentClass();
  if (null == _contentClass)   _contentClass=""String_Node_Str"";
  if (isCollapsible) {
    _contentClass+=""String_Node_Str"";
    if (!panel.isCollapsed())     _contentClass+=""String_Node_Str"";
  }
  _contentClass=""String_Node_Str"" + ""String_Node_Str"" + _contentClass;
  _contentClass=_contentClass.trim();
  if (_contentClass.length() > 0)   rw.writeAttribute(""String_Node_Str"",_contentClass,""String_Node_Str"");
  String _contentStyle=panel.getContentStyle();
  if (null != _contentStyle && _contentStyle.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_contentStyle,""String_Node_Str"");
  }
}","/** 
 * This methods generates the HTML code of the current b:panel. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:panel.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Panel panel=(Panel)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=panel.getClientId();
  String jQueryClientID=clientId.replace(""String_Node_Str"",""String_Node_Str"");
  boolean isCollapsible=panel.isCollapsible();
  if (isCollapsible) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String _look=panel.getLook();
  String _title=panel.getTitle();
  String _titleClass=panel.getTitleClass();
  String _styleClass=panel.getStyleClass();
  if (null == _styleClass) {
    _styleClass=""String_Node_Str"";
  }
 else {
    _styleClass+=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,panel,rw);
  Tooltip.generateTooltip(context,panel,rw);
  String _style=panel.getStyle();
  if (null != _style && _style.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_style,""String_Node_Str"");
  }
  if (_look != null) {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"" + _look,""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"",""String_Node_Str"");
  }
  UIComponent head=panel.getFacet(""String_Node_Str"");
  if (head != null || _title != null) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    String _titleStyle=panel.getTitleStyle();
    if (null != _titleStyle) {
      rw.writeAttribute(""String_Node_Str"",_titleStyle,""String_Node_Str"");
    }
    if (_title != null) {
      rw.startElement(""String_Node_Str"",panel);
      if (_titleClass != null) {
        rw.writeAttribute(""String_Node_Str"",_titleClass,""String_Node_Str"");
      }
 else {
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      if (isCollapsible) {
        rw.startElement(""String_Node_Str"",panel);
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + jQueryClientID + ""String_Node_Str"",""String_Node_Str"");
        if (panel.isCollapsed()) {
          rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
        }
      }
      rw.writeText(_title,null);
      if (isCollapsible) {
        rw.endElement(""String_Node_Str"");
      }
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (isCollapsible) {
        rw.startElement(""String_Node_Str"",panel);
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + jQueryClientID + ""String_Node_Str"",""String_Node_Str"");
        if (panel.isCollapsed()) {
          rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
        }
      }
      head.encodeAll(context);
      if (isCollapsible) {
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",jQueryClientID + ""String_Node_Str"",null);
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  String _contentClass=panel.getContentClass();
  if (null == _contentClass)   _contentClass=""String_Node_Str"";
  if (isCollapsible) {
    _contentClass+=""String_Node_Str"";
    if (!panel.isCollapsed())     _contentClass+=""String_Node_Str"";
  }
  _contentClass=""String_Node_Str"" + ""String_Node_Str"" + _contentClass;
  _contentClass=_contentClass.trim();
  if (_contentClass.length() > 0)   rw.writeAttribute(""String_Node_Str"",_contentClass,""String_Node_Str"");
  String _contentStyle=panel.getContentStyle();
  if (null != _contentStyle && _contentStyle.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_contentStyle,""String_Node_Str"");
  }
}"
57041,"/** 
 * HTML snippet of the container holding both the button as well as the dropdown. Default: <div class='btn-group' style='display:block' />. Note that the original definition of the widget doesn't use the style definition. We've added it to fix a rendering bug. <P> Usually this method is called internally by the JSF engine.
 */
public void setButtonContainer(String _buttonContainer){
  getStateHelper().put(PropertyKeys.buttonContainer,_buttonContainer);
}","/** 
 * HTML snippet of the container holding both the button as well as the dropdown. Default: <div class='btn-group' style='display:block'></div>. Note that the original definition of the widget doesn't use the style definition. We've added it to fix a rendering bug. <P> Usually this method is called internally by the JSF engine.
 */
public void setButtonContainer(String _buttonContainer){
  getStateHelper().put(PropertyKeys.buttonContainer,_buttonContainer);
}"
57042,"/** 
 * HTML snippet of the container holding both the button as well as the dropdown. Default: <div class='btn-group' style='display:block' />. Note that the original definition of the widget doesn't use the style definition. We've added it to fix a rendering bug. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getButtonContainer(){
  String value=(String)getStateHelper().eval(PropertyKeys.buttonContainer);
  return value;
}","/** 
 * HTML snippet of the container holding both the button as well as the dropdown. Default: <div class='btn-group' style='display:block'></div>. Note that the original definition of the widget doesn't use the style definition. We've added it to fix a rendering bug. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getButtonContainer(){
  String value=(String)getStateHelper().eval(PropertyKeys.buttonContainer);
  return value;
}"
57043,"private static StringBuilder generateAJAXCallForClientBehavior(FacesContext context,IAJAXComponent component,ClientBehavior ajaxBehavior){
  StringBuilder cJS=new StringBuilder(150);
  String update=component.getUpdate();
  String oncomplete=component.getOncomplete();
  String process=component.getProcess();
  String onevent=""String_Node_Str"";
  if (ajaxBehavior != null) {
    if (ajaxBehavior instanceof AjaxBehavior) {
      boolean disabled=((AjaxBehavior)ajaxBehavior).isDisabled();
      if (!disabled) {
        String onerror=((AjaxBehavior)ajaxBehavior).getOnerror();
        onevent=((AjaxBehavior)ajaxBehavior).getOnevent();
        if (onevent == null)         onevent=""String_Node_Str"";
        Collection<String> execute=((AjaxBehavior)ajaxBehavior).getExecute();
        if (null != execute && (!execute.isEmpty())) {
          for (          String u : execute) {
            if (null == process)             process=u;
 else             process+=""String_Node_Str"" + u;
          }
        }
        Collection<String> render=((AjaxBehavior)ajaxBehavior).getRender();
        if (null != render && (!render.isEmpty())) {
          update=""String_Node_Str"";
          for (          String u : render) {
            update+=u + ""String_Node_Str"";
          }
        }
        oncomplete=component.getOncomplete();
      }
    }
  }
  process=ExpressionResolver.getComponentIDs(context,(UIComponent)component,process);
  update=ExpressionResolver.getComponentIDs(context,(UIComponent)component,update);
  cJS.append(encodeClick(component)).append(""String_Node_Str"").append(update == null ? ""String_Node_Str"" : (""String_Node_Str"" + update + ""String_Node_Str"")).append(process == null ? ""String_Node_Str"" : (""String_Node_Str"" + process.trim() + ""String_Node_Str""));
  if (oncomplete != null) {
    cJS.append(""String_Node_Str"" + oncomplete + ""String_Node_Str"");
  }
 else   cJS.append(""String_Node_Str"");
  if (onevent != null) {
    cJS.append(""String_Node_Str"" + onevent + ""String_Node_Str"");
  }
  cJS.append(""String_Node_Str"");
  return cJS;
}","private static StringBuilder generateAJAXCallForClientBehavior(FacesContext context,IAJAXComponent component,ClientBehavior ajaxBehavior){
  StringBuilder cJS=new StringBuilder(150);
  String update=component.getUpdate();
  String oncomplete=component.getOncomplete();
  String process=component.getProcess();
  String onevent=""String_Node_Str"";
  if (ajaxBehavior != null) {
    if (ajaxBehavior instanceof AjaxBehavior) {
      boolean disabled=((AjaxBehavior)ajaxBehavior).isDisabled();
      if (!disabled) {
        String onerror=((AjaxBehavior)ajaxBehavior).getOnerror();
        onevent=((AjaxBehavior)ajaxBehavior).getOnevent();
        if (onevent == null)         onevent=""String_Node_Str"";
        Collection<String> execute=((AjaxBehavior)ajaxBehavior).getExecute();
        if (null != execute && (!execute.isEmpty())) {
          for (          String u : execute) {
            if (null == process)             process=u;
 else             process+=""String_Node_Str"" + u;
          }
        }
        Collection<String> render=((AjaxBehavior)ajaxBehavior).getRender();
        if (null != render && (!render.isEmpty())) {
          update=""String_Node_Str"";
          for (          String u : render) {
            update+=u + ""String_Node_Str"";
          }
        }
        oncomplete=component.getOncomplete();
      }
    }
  }
  process=ExpressionResolver.getComponentIDs(context,(UIComponent)component,process);
  update=ExpressionResolver.getComponentIDs(context,(UIComponent)component,update);
  cJS.append(encodeClick(component)).append(""String_Node_Str"").append(update == null ? ""String_Node_Str"" : (""String_Node_Str"" + update + ""String_Node_Str"")).append(process == null ? ""String_Node_Str"" : (""String_Node_Str"" + process.trim() + ""String_Node_Str""));
  if (oncomplete != null) {
    cJS.append(""String_Node_Str"" + oncomplete + ""String_Node_Str"");
  }
 else   cJS.append(""String_Node_Str"");
  if ((onevent != null) && (onevent.length() > 0)) {
    cJS.append(""String_Node_Str"" + onevent + ""String_Node_Str"");
  }
  cJS.append(""String_Node_Str"");
  return cJS;
}"
57044,"/** 
 * Renders the start of the input tag. This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected void renderInputTagHelper(ResponseWriter rw,FacesContext context,SelectBooleanCheckbox selectBooleanCheckbox,String clientId) throws IOException {
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
  rw.writeAttribute(""String_Node_Str"",clientId + ""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.endElement(""String_Node_Str"");
}","/** 
 * Renders the start of the input tag. This method is protected in order to allow third-party frameworks to derive from it.
 * @param rw the response writer
 * @param selectBooleanCheckbox the component to render
 * @throws IOException may be thrown by the response writer
 */
protected void renderInputTagHelper(ResponseWriter rw,FacesContext context,SelectBooleanCheckbox selectBooleanCheckbox,String clientId) throws IOException {
  rw.startElement(""String_Node_Str"",selectBooleanCheckbox);
  rw.writeAttribute(""String_Node_Str"",clientId + ""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.endElement(""String_Node_Str"");
}"
57045,"private static StringBuilder generateAJAXCall(FacesContext context,IAJAXComponent component,String event){
  String complete=component.getOncomplete();
  StringBuilder cJS=new StringBuilder(150);
  String update=component.getUpdate();
  if (null == update) {
    update=""String_Node_Str"";
  }
  update=ExpressionResolver.getComponentIDs(context,(UIComponent)component,update);
  String process=component.getProcess();
  if (null == process) {
    if (component.getClass().getName().contains(""String_Node_Str"")) {
      process=""String_Node_Str"";
    }
 else {
      process=""String_Node_Str"";
    }
  }
  process=ExpressionResolver.getComponentIDs(context,(UIComponent)component,process);
  cJS.append(""String_Node_Str"").append(""String_Node_Str"" + update + ""String_Node_Str"").append(""String_Node_Str"").append(process).append(""String_Node_Str"");
  if (complete != null) {
    cJS.append(""String_Node_Str"" + complete + ""String_Node_Str"");
  }
 else   cJS.append(""String_Node_Str"");
  if (event != null) {
    cJS.append(""String_Node_Str"" + event + ""String_Node_Str"");
  }
  cJS.append(""String_Node_Str"");
  return cJS;
}","private static StringBuilder generateAJAXCall(FacesContext context,IAJAXComponent component,String event){
  String complete=component.getOncomplete();
  StringBuilder cJS=new StringBuilder(150);
  String update=component.getUpdate();
  if (null == update) {
    update=""String_Node_Str"";
  }
  update=ExpressionResolver.getComponentIDs(context,(UIComponent)component,update);
  String process=component.getProcess();
  if (null == process) {
    if (component.getClass().getName().contains(""String_Node_Str"")) {
      process=""String_Node_Str"";
    }
 else {
      process=""String_Node_Str"";
    }
  }
  process=ExpressionResolver.getComponentIDs(context,(UIComponent)component,process);
  cJS.append(""String_Node_Str"").append(""String_Node_Str"" + update + ""String_Node_Str"").append(""String_Node_Str"").append(process).append(""String_Node_Str"");
  if (complete != null) {
    cJS.append(""String_Node_Str"" + complete + ""String_Node_Str"");
  }
 else   cJS.append(""String_Node_Str"");
  if ((event != null) && (event.length() > 0)) {
    cJS.append(""String_Node_Str"" + event + ""String_Node_Str"");
  }
  cJS.append(""String_Node_Str"");
  return cJS;
}"
57046,"private static StringBuilder generateAJAXCallForClientBehavior(FacesContext context,IAJAXComponent component,ClientBehavior ajaxBehavior){
  StringBuilder cJS=new StringBuilder(150);
  String update=component.getUpdate();
  String oncomplete=component.getOncomplete();
  String process=component.getProcess();
  String onevent=""String_Node_Str"";
  if (ajaxBehavior != null) {
    if (ajaxBehavior instanceof AjaxBehavior) {
      boolean disabled=((AjaxBehavior)ajaxBehavior).isDisabled();
      if (!disabled) {
        String onerror=((AjaxBehavior)ajaxBehavior).getOnerror();
        onevent=((AjaxBehavior)ajaxBehavior).getOnevent();
        if (onevent == null)         onevent=""String_Node_Str"";
 else         if (onevent.length() > 0)         onevent=onevent + ""String_Node_Str"";
        Collection<String> execute=((AjaxBehavior)ajaxBehavior).getExecute();
        if (null != execute && (!execute.isEmpty())) {
          for (          String u : execute) {
            process+=""String_Node_Str"" + u;
          }
        }
        Collection<String> render=((AjaxBehavior)ajaxBehavior).getRender();
        if (null != render && (!render.isEmpty())) {
          update=""String_Node_Str"";
          for (          String u : render) {
            update+=u + ""String_Node_Str"";
          }
        }
        oncomplete=component.getOncomplete();
      }
    }
  }
  process=ExpressionResolver.getComponentIDs(context,(UIComponent)component,process);
  update=ExpressionResolver.getComponentIDs(context,(UIComponent)component,update);
  cJS.append(encodeClick(component)).append(onevent).append(""String_Node_Str"").append(update == null ? ""String_Node_Str"" : (""String_Node_Str"" + update + ""String_Node_Str"")).append(process == null ? ""String_Node_Str"" : (""String_Node_Str"" + process.trim() + ""String_Node_Str""));
  if (oncomplete != null) {
    cJS.append(""String_Node_Str"" + oncomplete + ""String_Node_Str"");
  }
  cJS.append(""String_Node_Str"");
  return cJS;
}","private static StringBuilder generateAJAXCallForClientBehavior(FacesContext context,IAJAXComponent component,ClientBehavior ajaxBehavior){
  StringBuilder cJS=new StringBuilder(150);
  String update=component.getUpdate();
  String oncomplete=component.getOncomplete();
  String process=component.getProcess();
  String onevent=""String_Node_Str"";
  if (ajaxBehavior != null) {
    if (ajaxBehavior instanceof AjaxBehavior) {
      boolean disabled=((AjaxBehavior)ajaxBehavior).isDisabled();
      if (!disabled) {
        String onerror=((AjaxBehavior)ajaxBehavior).getOnerror();
        onevent=((AjaxBehavior)ajaxBehavior).getOnevent();
        if (onevent == null)         onevent=""String_Node_Str"";
 else         if (onevent.length() > 0)         onevent=onevent + ""String_Node_Str"";
        Collection<String> execute=((AjaxBehavior)ajaxBehavior).getExecute();
        if (null != execute && (!execute.isEmpty())) {
          for (          String u : execute) {
            if (null == process)             process=u;
 else             process+=""String_Node_Str"" + u;
          }
        }
        Collection<String> render=((AjaxBehavior)ajaxBehavior).getRender();
        if (null != render && (!render.isEmpty())) {
          update=""String_Node_Str"";
          for (          String u : render) {
            update+=u + ""String_Node_Str"";
          }
        }
        oncomplete=component.getOncomplete();
      }
    }
  }
  process=ExpressionResolver.getComponentIDs(context,(UIComponent)component,process);
  update=ExpressionResolver.getComponentIDs(context,(UIComponent)component,update);
  cJS.append(encodeClick(component)).append(onevent).append(""String_Node_Str"").append(update == null ? ""String_Node_Str"" : (""String_Node_Str"" + update + ""String_Node_Str"")).append(process == null ? ""String_Node_Str"" : (""String_Node_Str"" + process.trim() + ""String_Node_Str""));
  if (oncomplete != null) {
    cJS.append(""String_Node_Str"" + oncomplete + ""String_Node_Str"");
  }
  cJS.append(""String_Node_Str"");
  return cJS;
}"
57047,"public static void generateBootsFacesAJAXAndJavaScript(FacesContext context,ClientBehaviorHolder component,ResponseWriter rw,String specialEvent,String specialEventHandler) throws IOException {
  Map<String,List<ClientBehavior>> clientBehaviors=component.getClientBehaviors();
  Collection<String> eventNames=component.getEventNames();
  for (  String keyClientBehavior : eventNames) {
    String jsCallback=""String_Node_Str"";
    String nameOfGetter=""String_Node_Str"" + keyClientBehavior;
    try {
      Method[] methods=component.getClass().getMethods();
      for (      Method m : methods) {
        if (m.getParameterTypes().length == 0) {
          if (m.getReturnType() == String.class) {
            if (m.getName().equalsIgnoreCase(nameOfGetter)) {
              jsCallback=(String)m.invoke(component);
              if (keyClientBehavior.equals(specialEvent)) {
                if (null == jsCallback || jsCallback.length() == 0)                 jsCallback=specialEventHandler;
 else                 jsCallback=jsCallback + ""String_Node_Str"" + specialEventHandler;
              }
              jsCallback=convertAJAXToJavascript(context,jsCallback,component);
              break;
            }
          }
        }
      }
    }
 catch (    ReflectiveOperationException ex) {
      System.err.println(""String_Node_Str"" + nameOfGetter);
    }
    String script=""String_Node_Str"";
    List<ClientBehavior> behaviors=clientBehaviors.get(keyClientBehavior);
    if (null != behaviors) {
      for (      ClientBehavior cb : behaviors) {
        ClientBehaviorContext behaviorContext=ClientBehaviorContext.createClientBehaviorContext(context,(UIComponent)component,keyClientBehavior,null,null);
        String s=buildAjaxCommand(behaviorContext,(AjaxBehavior)cb,false);
        script+=cb.getScript(behaviorContext) + ""String_Node_Str"";
      }
    }
    if (jsCallback.length() > 0 || script.length() > 0) {
      if (jsCallback.length() > 0 && ""String_Node_Str"".equals(keyClientBehavior))       script+=""String_Node_Str"";
      rw.writeAttribute(""String_Node_Str"" + keyClientBehavior,jsCallback + script,null);
    }
  }
}","public static void generateBootsFacesAJAXAndJavaScript(FacesContext context,ClientBehaviorHolder component,ResponseWriter rw,String specialEvent,String specialEventHandler) throws IOException {
  Map<String,List<ClientBehavior>> clientBehaviors=component.getClientBehaviors();
  Collection<String> eventNames=component.getEventNames();
  for (  String keyClientBehavior : eventNames) {
    String jsCallback=""String_Node_Str"";
    String nameOfGetter=""String_Node_Str"" + keyClientBehavior;
    try {
      Method[] methods=component.getClass().getMethods();
      for (      Method m : methods) {
        if (m.getParameterTypes().length == 0) {
          if (m.getReturnType() == String.class) {
            if (m.getName().equalsIgnoreCase(nameOfGetter)) {
              jsCallback=(String)m.invoke(component);
              if (keyClientBehavior.equals(specialEvent)) {
                if (null == jsCallback || jsCallback.length() == 0)                 jsCallback=specialEventHandler;
 else                 jsCallback=jsCallback + ""String_Node_Str"" + specialEventHandler;
              }
              jsCallback=convertAJAXToJavascript(context,jsCallback,component);
              break;
            }
          }
        }
      }
    }
 catch (    ReflectiveOperationException ex) {
      System.err.println(""String_Node_Str"" + nameOfGetter);
    }
    String script=""String_Node_Str"";
    List<ClientBehavior> behaviors=clientBehaviors.get(keyClientBehavior);
    if (null != behaviors) {
      for (      ClientBehavior cb : behaviors) {
        ClientBehaviorContext behaviorContext=ClientBehaviorContext.createClientBehaviorContext(context,(UIComponent)component,keyClientBehavior,null,null);
        String s=buildAjaxCommand(behaviorContext,(AjaxBehavior)cb,false);
        script+=cb.getScript(behaviorContext) + ""String_Node_Str"";
      }
    }
    if (jsCallback.length() > 0 || script.length() > 0) {
      if (component instanceof CommandButton)       if (jsCallback.length() > 0 && ""String_Node_Str"".equals(keyClientBehavior))       script+=""String_Node_Str"";
      rw.writeAttribute(""String_Node_Str"" + keyClientBehavior,jsCallback + script,null);
    }
  }
}"
57048,"/** 
 * This methods receives and processes input made by the user. More specifically, it ckecks whether the user has interacted with the current b:selectBooleanCheckbox. The default implementation simply stores the input value in the list of submitted values. If the validation checks are passed, the values in the <code>submittedValues</code> list are store in the backend bean.
 * @param context the FacesContext.
 * @param component the current b:selectBooleanCheckbox.
 */
@Override public void decode(FacesContext context,UIComponent component){
  SelectBooleanCheckbox selectBooleanCheckbox=(SelectBooleanCheckbox)component;
  if (selectBooleanCheckbox.isDisabled() || selectBooleanCheckbox.isReadonly()) {
    return;
  }
  decodeBehaviors(context,selectBooleanCheckbox);
  String clientId=selectBooleanCheckbox.getClientId(context);
  String submittedValue=(String)context.getExternalContext().getRequestParameterMap().get(clientId);
  if (submittedValue != null) {
    selectBooleanCheckbox.setSubmittedValue(""String_Node_Str"".equals(submittedValue));
  }
  new AJAXRenderer().decode(context,component);
}","/** 
 * This methods receives and processes input made by the user. More specifically, it ckecks whether the user has interacted with the current b:selectBooleanCheckbox. The default implementation simply stores the input value in the list of submitted values. If the validation checks are passed, the values in the <code>submittedValues</code> list are store in the backend bean.
 * @param context the FacesContext.
 * @param component the current b:selectBooleanCheckbox.
 */
@Override public void decode(FacesContext context,UIComponent component){
  SelectBooleanCheckbox selectBooleanCheckbox=(SelectBooleanCheckbox)component;
  if (selectBooleanCheckbox.isDisabled() || selectBooleanCheckbox.isReadonly()) {
    return;
  }
  decodeBehaviors(context,selectBooleanCheckbox);
  String clientId=selectBooleanCheckbox.getClientId(context);
  String submittedValue=(String)context.getExternalContext().getRequestParameterMap().get(clientId);
  String event=(String)context.getExternalContext().getRequestParameterMap().get(""String_Node_Str"");
  if (submittedValue != null) {
    selectBooleanCheckbox.setSubmittedValue(""String_Node_Str"".equals(submittedValue));
    if (clientId.contains(""String_Node_Str""))     System.out.println(event + ""String_Node_Str"" + ""String_Node_Str"".equals(submittedValue));
  }
 else   if (context.getExternalContext().getRequestParameterMap().containsKey(clientId + ""String_Node_Str"")) {
    selectBooleanCheckbox.setSubmittedValue(false);
    if (clientId.contains(""String_Node_Str""))     System.out.println(event + ""String_Node_Str"" + ""String_Node_Str"");
  }
  new AJAXRenderer().decode(context,component);
}"
57049,"public static String determineQualifiedId(UIComponent component){
  String qualifiedId=""String_Node_Str"";
  if (component instanceof NamingContainer)   qualifiedId=component.getId();
  while (component != null && (!(component instanceof UIViewRoot)) && (!(component instanceof UIForm))) {
    component=component.getParent();
    if (component instanceof NamingContainer)     qualifiedId=component.getId() + ""String_Node_Str"" + qualifiedId;
  }
  return ""String_Node_Str"" + qualifiedId;
}","public static String determineQualifiedId(UIComponent component){
  String qualifiedId=""String_Node_Str"";
  if (component instanceof NamingContainer)   return ""String_Node_Str"";
  while (component != null && (!(component instanceof UIViewRoot)) && (!(component instanceof NamingContainer))) {
    component=component.getParent();
    if (component instanceof NamingContainer)     qualifiedId=component.getId() + ""String_Node_Str"" + qualifiedId;
  }
  return ""String_Node_Str"" + qualifiedId;
}"
57050,"public List<UIComponent> resolve(UIComponent component,List<UIComponent> parentComponents,String currentId,String originalExpression,String[] parameters){
  List<UIComponent> result=new ArrayList<UIComponent>();
  for (  UIComponent parent : parentComponents) {
    while ((!(parent instanceof UIViewRoot)) && (!(parent instanceof NamingContainer))) {
      parent=parent.getParent();
    }
    String parentId=ExpressionResolverUtilities.determineQualifiedId(parent);
    String childId;
    if (parentId.endsWith(""String_Node_Str""))     childId=parentId + currentId;
 else     childId=parentId + ""String_Node_Str"" + currentId;
    UIComponent c=component.findComponent(childId);
    if (null != c) {
      result.add(c);
    }
  }
  if (result.size() > 0) {
    return result;
  }
  throw new FacesException(""String_Node_Str"" + currentId + ""String_Node_Str""+ originalExpression);
}","public List<UIComponent> resolve(UIComponent component,List<UIComponent> parentComponents,String currentId,String originalExpression,String[] parameters){
  List<UIComponent> result=new ArrayList<UIComponent>();
  for (  UIComponent parent : parentComponents) {
    while ((!(parent instanceof UIViewRoot)) && (!(parent instanceof NamingContainer))) {
      parent=parent.getParent();
    }
    String parentId=ExpressionResolverUtilities.determineQualifiedId(parent);
    String childId;
    if (parentId.length() == 0)     childId=currentId;
 else     if (parentId.endsWith(""String_Node_Str""))     childId=parentId + currentId;
 else     childId=parentId + ""String_Node_Str"" + currentId;
    UIComponent c=component.findComponent(childId);
    if (null == c) {
      c=component.findComponent(""String_Node_Str"" + childId);
    }
    if (null != c) {
      result.add(c);
    }
  }
  if (result.size() > 0) {
    return result;
  }
  throw new FacesException(""String_Node_Str"" + currentId + ""String_Node_Str""+ originalExpression);
}"
57051,"/** 
 * Encodes the HTML for this context
 * @param fc
 * @throws IOException
 */
private void encodeHTML(FacesContext fc) throws IOException {
  Map<String,Object> attrs=getAttributes();
  String clientId=getClientId(fc);
  ResponseWriter rw=fc.getResponseWriter();
  sloc=selectLocale(fc.getViewRoot().getLocale(),A.asString(attrs.get(A.LOCALE)));
  sdf=selectDateFormat(sloc,A.asString(attrs.get(A.DTFORMAT)));
  String dpId;
  Object v=getSubmittedValue();
  if (v == null) {
    v=this.getValue();
  }
  mode=A.asString(attrs.get(""String_Node_Str""),A.TOGGLEICON);
  boolean inline=mode.equals(A.INLINE);
  if (inline) {
    dpId=clientId + ""String_Node_Str"" + ""String_Node_Str"";
    rw.startElement(""String_Node_Str"",this);
    rw.writeAttribute(""String_Node_Str"",dpId,null);
    rw.endElement(""String_Node_Str"");
  }
 else {
    dpId=clientId;
    if (!mode.equals(A.POPUP)) {
      rw.startElement(""String_Node_Str"",this);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      if (mode.equals(A.ICONPOP) || mode.equals(A.ICONTOGGLE)) {
        R.addonIcon(rw,this,CALENDAR,false);
      }
    }
  }
  String type=inline ? ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  Tooltip.generateTooltip(fc,attrs,rw);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (v != null) {
    rw.writeAttribute(""String_Node_Str"",getDateAsString(v,sdf,sloc),null);
  }
  String ph=A.asString(attrs.get(A.PHOLDER));
  if (ph != null) {
    rw.writeAttribute(H.PHOLDER,ph,null);
  }
  if (A.toBool(attrs.get(A.DISABLED))) {
    rw.writeAttribute(A.DISABLED,A.DISABLED,null);
  }
  if (A.toBool(attrs.get(A.READONLY))) {
    rw.writeAttribute(A.READONLY,A.READONLY,null);
  }
  rw.endElement(""String_Node_Str"");
  encodeJS(fc,rw,clientId,dpId);
  if (mode.equals(A.POPICON) || mode.equals(A.TOGGLEICON)) {
    R.addonIcon(rw,this,CALENDAR,false);
  }
  if (!inline && !mode.equals(A.POPUP)) {
    rw.endElement(""String_Node_Str"");
    JQ.datePickerToggler(rw,clientId,clientId + ""String_Node_Str"" + ADDON);
  }
}","/** 
 * Encodes the HTML for this context
 * @param fc
 * @throws IOException
 */
private void encodeHTML(FacesContext fc) throws IOException {
  Map<String,Object> attrs=getAttributes();
  String clientId=getClientId(fc);
  ResponseWriter rw=fc.getResponseWriter();
  sloc=selectLocale(fc.getViewRoot().getLocale(),A.asString(attrs.get(A.LOCALE)));
  sdf=selectDateFormat(sloc,A.asString(attrs.get(A.DTFORMAT)));
  String dpId;
  Object v=getSubmittedValue();
  if (v == null) {
    v=this.getValue();
  }
  mode=A.asString(attrs.get(""String_Node_Str""),A.TOGGLEICON);
  boolean inline=mode.equals(A.INLINE);
  if (inline) {
    dpId=clientId + ""String_Node_Str"" + ""String_Node_Str"";
    rw.startElement(""String_Node_Str"",this);
    rw.writeAttribute(""String_Node_Str"",dpId,null);
    rw.endElement(""String_Node_Str"");
  }
 else {
    dpId=clientId;
    if (!mode.equals(A.POPUP)) {
      rw.startElement(""String_Node_Str"",this);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      if (mode.equals(A.ICONPOP) || mode.equals(A.ICONTOGGLE)) {
        R.addonIcon(rw,this,CALENDAR,false);
      }
    }
  }
  String type=inline ? ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  Tooltip.generateTooltip(fc,attrs,rw);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (v != null) {
    rw.writeAttribute(""String_Node_Str"",getDateAsString(v,sdf,sloc),null);
  }
  String ph=A.asString(attrs.get(A.PHOLDER));
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (A.toBool(attrs.get(A.DISABLED))) {
    rw.writeAttribute(A.DISABLED,A.DISABLED,null);
  }
  if (A.toBool(attrs.get(A.READONLY))) {
    rw.writeAttribute(A.READONLY,A.READONLY,null);
  }
  rw.endElement(""String_Node_Str"");
  encodeJS(fc,rw,clientId,dpId);
  if (mode.equals(A.POPICON) || mode.equals(A.TOGGLEICON)) {
    R.addonIcon(rw,this,CALENDAR,false);
  }
  if (!inline && !mode.equals(A.POPUP)) {
    rw.endElement(""String_Node_Str"");
    JQ.datePickerToggler(rw,clientId,clientId + ""String_Node_Str"" + ADDON);
  }
}"
57052,"@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  CommandButton commandButton=(CommandButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String CID=component.getClientId(context);
  String type=commandButton.getType();
  if (null == type)   type=""String_Node_Str"";
  String style=commandButton.getStyle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  Tooltip.generateTooltip(context,commandButton,rw);
  writeAttribute(rw,H.STYLE,style,H.STYLE);
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(commandButton),""String_Node_Str"");
  String title=commandButton.getTitle();
  if (title != null && title.length() > 0) {
    rw.writeAttribute(H.TITLE,title,H.TITLE);
  }
  if (commandButton.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!type.equals(""String_Node_Str"") && !type.equals(""String_Node_Str"")) {
    String formId=R.findComponentFormId(context,component);
    if (formId == null) {
      throw new FacesException(""String_Node_Str"" + CID + ""String_Node_Str"");
    }
  }
  AJAXRenderer.generateJavaScriptHandlers(context,commandButton,rw,CID,type);
  R.encodeHTML4DHTMLAttrs(rw,commandButton.getAttributes(),A.ALLBUTTON_ATTRS);
}","@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  CommandButton commandButton=(CommandButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String CID=component.getClientId(context);
  String type=commandButton.getType();
  if (null == type)   type=""String_Node_Str"";
  String style=commandButton.getStyle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",type,null);
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",CID,""String_Node_Str"");
  Tooltip.generateTooltip(context,commandButton,rw);
  writeAttribute(rw,H.STYLE,style,H.STYLE);
  rw.writeAttribute(""String_Node_Str"",getStyleClasses(commandButton),""String_Node_Str"");
  String title=commandButton.getTitle();
  if (title != null && title.length() > 0) {
    rw.writeAttribute(H.TITLE,title,H.TITLE);
  }
  if (commandButton.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (!type.equals(""String_Node_Str"") && !type.equals(""String_Node_Str"")) {
    String formId=R.findComponentFormId(context,component);
    if (formId == null) {
      throw new FacesException(""String_Node_Str"" + CID + ""String_Node_Str"");
    }
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScriptForCommandButtons(context,commandButton,rw);
  R.encodeHTML4DHTMLAttrs(rw,commandButton.getAttributes(),A.ALLBUTTON_ATTRS);
}"
57053,"/** 
 * This methods generates the HTML code of the current b:panel. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:panel.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Panel panel=(Panel)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=panel.getClientId();
  rw.endElement(H.DIV);
  UIComponent foot=panel.getFacet(""String_Node_Str"");
  if (foot != null) {
    rw.startElement(H.DIV,panel);
    rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
    foot.encodeAll(context);
    rw.endElement(H.DIV);
  }
  rw.endElement(H.DIV);
  boolean isCollapsible=panel.isCollapsible();
  if (isCollapsible) {
    String jQueryClientID=clientId.replace(""String_Node_Str"",""String_Node_Str"");
    rw.endElement(H.DIV);
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    String hiddenInputFieldID=jQueryClientID + ""String_Node_Str"";
    rw.writeAttribute(""String_Node_Str"",hiddenInputFieldID,""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",hiddenInputFieldID,""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",panel.isCollapsed(),""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",panel);
    rw.writeText(""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + jQueryClientID + ""String_Node_Str""+ ""String_Node_Str""+ hiddenInputFieldID+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + jQueryClientID + ""String_Node_Str""+ ""String_Node_Str""+ hiddenInputFieldID+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"",null);
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,panel.getAttributes(),panel);
}","/** 
 * This methods generates the HTML code of the current b:panel. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:panel.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Panel panel=(Panel)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=panel.getClientId();
  rw.endElement(H.DIV);
  UIComponent foot=panel.getFacet(""String_Node_Str"");
  if (foot != null) {
    rw.startElement(H.DIV,panel);
    rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
    foot.encodeAll(context);
    rw.endElement(H.DIV);
  }
  rw.endElement(H.DIV);
  boolean isCollapsible=panel.isCollapsible();
  if (isCollapsible) {
    String jQueryClientID=clientId.replace(""String_Node_Str"",""String_Node_Str"");
    rw.endElement(H.DIV);
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    String hiddenInputFieldID=jQueryClientID + ""String_Node_Str"";
    rw.writeAttribute(""String_Node_Str"",hiddenInputFieldID,""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",hiddenInputFieldID,""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",String.valueOf(panel.isCollapsed()),""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",panel);
    rw.writeText(""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + jQueryClientID + ""String_Node_Str""+ ""String_Node_Str""+ hiddenInputFieldID+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + jQueryClientID + ""String_Node_Str""+ ""String_Node_Str""+ hiddenInputFieldID+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"",null);
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,panel.getAttributes(),panel);
}"
57054,"/** 
 * This methods receives and processes input made by the user. More specifically, it ckecks whether the user has interacted with the current b:panel. The default implementation simply stores the input value in the list of submitted values. If the validation checks are passed, the values in the <code>submittedValues</code> list are store in the backend bean.
 * @param context the FacesContext.
 * @param component the current b:panel.
 */
@Override public void decode(FacesContext context,UIComponent component){
  Panel panel=(Panel)component;
  decodeBehaviors(context,panel);
  String clientId=panel.getClientId(context);
  String collapseStateId=clientId.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
  String submittedValue=(String)context.getExternalContext().getRequestParameterMap().get(collapseStateId);
  if (submittedValue != null) {
    panel.setCollapsed(Boolean.valueOf(submittedValue));
  }
}","/** 
 * This methods receives and processes input made by the user. More specifically, it ckecks whether the user has interacted with the current b:panel. The default implementation simply stores the input value in the list of submitted values. If the validation checks are passed, the values in the <code>submittedValues</code> list are store in the backend bean.
 * @param context the FacesContext.
 * @param component the current b:panel.
 */
@Override public void decode(FacesContext context,UIComponent component){
  Panel panel=(Panel)component;
  decodeBehaviors(context,panel);
  String clientId=panel.getClientId(context);
  String collapseStateId=clientId.replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
  String submittedValue=(String)context.getExternalContext().getRequestParameterMap().get(collapseStateId);
  if (submittedValue != null) {
    if (Boolean.valueOf(submittedValue) != panel.isCollapsed())     panel.setCollapsed(Boolean.valueOf(submittedValue));
  }
}"
57055,"/** 
 * Make sure jQuery is loaded before jQueryUI, and that every other Javascript is loaded later. Also make sure that the BootsFaces resource files are loaded prior to other resource files, giving the developer the opportunity to overwrite a CSS or JS file.
 * @param root The current UIViewRoot
 * @param context The current FacesContext
 */
private void enforceCorrectLoadOrder(UIViewRoot root,FacesContext context){
  List<UIComponent> resources=new ArrayList<UIComponent>(root.getComponentResources(context,""String_Node_Str""));
  for (  UIComponent c : resources) {
    root.removeComponentResource(context,c);
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"") && (!name.contains(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str"")) {
        String name=(String)c.getAttributes().get(""String_Node_Str"");
        if (name != null) {
          name=name.toLowerCase();
          if ((name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
            continue;
          }
        }
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       continue;
    }
    if (name != null) {
      name=name.toLowerCase();
      if (!(name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
 else     root.addComponentResource(context,c,""String_Node_Str"");
  }
}","/** 
 * Make sure jQuery is loaded before jQueryUI, and that every other Javascript is loaded later. Also make sure that the BootsFaces resource files are loaded prior to other resource files, giving the developer the opportunity to overwrite a CSS or JS file.
 * @param root The current UIViewRoot
 * @param context The current FacesContext
 */
private void enforceCorrectLoadOrder(UIViewRoot root,FacesContext context){
  List<UIComponent> resources=new ArrayList<UIComponent>(root.getComponentResources(context,""String_Node_Str""));
  for (  UIComponent c : resources) {
    root.removeComponentResource(context,c);
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"") && (!name.contains(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       root.addComponentResource(context,c,""String_Node_Str"");
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       continue;
    }
    if (name != null) {
      name=name.toLowerCase();
      if (!(name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
 else     root.addComponentResource(context,c,""String_Node_Str"");
  }
}"
57056,"private void addResourceIfNecessary(UIViewRoot root,FacesContext context,UIOutput output){
  for (  UIComponent c : root.getComponentResources(context,""String_Node_Str"")) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null && library.equals(output.getAttributes().get(""String_Node_Str""))) {
      if (name != null && name.equals(output.getAttributes().get(""String_Node_Str""))) {
        return;
      }
    }
  }
  root.addComponentResource(context,output,""String_Node_Str"");
}","private void addResourceIfNecessary(UIViewRoot root,FacesContext context,UIOutput output){
  for (  UIComponent c : root.getComponentResources(context,""String_Node_Str"")) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null && library.equals(output.getAttributes().get(""String_Node_Str""))) {
      if (name != null && library.equals(output.getAttributes().get(""String_Node_Str""))) {
        return;
      }
    }
  }
  root.addComponentResource(context,output,""String_Node_Str"");
}"
57057,"private void addResourceIfNecessary(UIViewRoot root,FacesContext context,UIOutput output){
  for (  UIComponent c : root.getComponentResources(context,""String_Node_Str"")) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null && library.equals(output.getAttributes().get(""String_Node_Str""))) {
      if (name != null && library.equals(output.getAttributes().get(""String_Node_Str""))) {
        return;
      }
    }
  }
  root.addComponentResource(context,output,""String_Node_Str"");
}","private void addResourceIfNecessary(UIViewRoot root,FacesContext context,UIOutput output){
  for (  UIComponent c : root.getComponentResources(context,""String_Node_Str"")) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null && library.equals(output.getAttributes().get(""String_Node_Str""))) {
      if (name != null && name.equals(output.getAttributes().get(""String_Node_Str""))) {
        return;
      }
    }
  }
  root.addComponentResource(context,output,""String_Node_Str"");
}"
57058,"/** 
 * Make sure jQuery is loaded before jQueryUI, and that every other Javascript is loaded later. Also make sure that the BootsFaces resource files are loaded prior to other resource files, giving the developer the opportunity to overwrite a CSS or JS file.
 * @param root The current UIViewRoot
 * @param context The current FacesContext
 */
private void enforceCorrectLoadOrder(UIViewRoot root,FacesContext context){
  List<UIComponent> resources=new ArrayList<UIComponent>(root.getComponentResources(context,""String_Node_Str""));
  for (  UIComponent c : resources) {
    root.removeComponentResource(context,c);
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"") && (!name.contains(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       root.addComponentResource(context,c,""String_Node_Str"");
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       continue;
    }
    if (name != null) {
      name=name.toLowerCase();
      if (!(name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
 else     root.addComponentResource(context,c,""String_Node_Str"");
  }
}","/** 
 * Make sure jQuery is loaded before jQueryUI, and that every other Javascript is loaded later. Also make sure that the BootsFaces resource files are loaded prior to other resource files, giving the developer the opportunity to overwrite a CSS or JS file.
 * @param root The current UIViewRoot
 * @param context The current FacesContext
 */
private void enforceCorrectLoadOrder(UIViewRoot root,FacesContext context){
  List<UIComponent> resources=new ArrayList<UIComponent>(root.getComponentResources(context,""String_Node_Str""));
  for (  UIComponent c : resources) {
    root.removeComponentResource(context,c);
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"") && (!name.contains(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str"")) {
        String name=(String)c.getAttributes().get(""String_Node_Str"");
        if (name != null) {
          name=name.toLowerCase();
          if ((name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
            continue;
          }
        }
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       continue;
    }
    if (name != null) {
      name=name.toLowerCase();
      if (!(name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
 else     root.addComponentResource(context,c,""String_Node_Str"");
  }
}"
57059,"/** 
 * Make sure jQuery is loaded before jQueryUI, and that every other Javascript is loaded later.
 * @param root The current UIViewRoot
 * @param context The current FacesContext
 */
private void enforceCorrectLoadOrder(UIViewRoot root,FacesContext context){
  List<UIComponent> resources=new ArrayList<UIComponent>(root.getComponentResources(context,""String_Node_Str""));
  for (  UIComponent c : resources) {
    root.removeComponentResource(context,c);
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"") && (!name.contains(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (!(name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
 else     root.addComponentResource(context,c,""String_Node_Str"");
  }
}","/** 
 * Make sure jQuery is loaded before jQueryUI, and that every other Javascript is loaded later. Also make sure that the BootsFaces resource files are loaded prior to other resource files, giving the developer the opportunity to overwrite a CSS or JS file.
 * @param root The current UIViewRoot
 * @param context The current FacesContext
 */
private void enforceCorrectLoadOrder(UIViewRoot root,FacesContext context){
  List<UIComponent> resources=new ArrayList<UIComponent>(root.getComponentResources(context,""String_Node_Str""));
  for (  UIComponent c : resources) {
    root.removeComponentResource(context,c);
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"") && (!name.contains(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    if (name != null) {
      name=name.toLowerCase();
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
  }
  for (  UIComponent c : resources) {
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       root.addComponentResource(context,c,""String_Node_Str"");
    }
  }
  for (  UIComponent c : resources) {
    String name=(String)c.getAttributes().get(""String_Node_Str"");
    String library=(String)c.getAttributes().get(""String_Node_Str"");
    if (library != null) {
      if (library.equals(""String_Node_Str""))       continue;
    }
    if (name != null) {
      name=name.toLowerCase();
      if (!(name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str""))) {
        root.addComponentResource(context,c,""String_Node_Str"");
      }
    }
 else     root.addComponentResource(context,c,""String_Node_Str"");
  }
}"
57060,"/** 
 * Add the required Javascript files and the FontAwesome CDN link.
 * @param root The UIViewRoot of the JSF tree.
 * @param context The current FacesContext
 * @param isProduction This flag can be used to deliver different version of the JS library, optimized for debugging or production.
 */
private void addJavascript(UIViewRoot root,FacesContext context,boolean isProduction){
  Application app=context.getApplication();
  ResourceHandler rh=app.getResourceHandler();
  String theme=null;
  theme=context.getExternalContext().getInitParameter(C.P_USETHEME);
  if (isFontAwesomeComponentUsedAndRemoveIt() || (theme != null && theme.equals(C.TRUE))) {
    Resource themeResource=rh.createResource(C.BSF_CSS_TBSTHEME,C.BSF_LIBRARY);
    if (themeResource == null) {
      throw new FacesException(""String_Node_Str"" + C.BSF_CSS_TBSTHEME + ""String_Node_Str""+ C.BSF_LIBRARY+ ""String_Node_Str"");
    }
 else {
      UIOutput output=new UIOutput();
      output.setRendererType(""String_Node_Str"");
      output.getAttributes().put(""String_Node_Str"",C.BSF_CSS_TBSTHEME);
      output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
      output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
      root.addComponentResource(context,output,""String_Node_Str"");
    }
  }
  UIComponent header=findHeader(root);
  boolean useCDNImportForFontAwesome=(null == header) || (null == header.getFacet(""String_Node_Str""));
  if (useCDNImportForFontAwesome) {
    String useCDN=FacesContext.getCurrentInstance().getExternalContext().getInitParameter(""String_Node_Str"");
    if (null != useCDN)     if (useCDN.equalsIgnoreCase(""String_Node_Str"") || useCDN.equals(""String_Node_Str""))     useCDNImportForFontAwesome=false;
  }
  boolean loadJQuery=true;
  List<UIComponent> availableResources=root.getComponentResources(context,""String_Node_Str"");
  for (  UIComponent ava : availableResources) {
    String name=(String)ava.getAttributes().get(""String_Node_Str"");
    if (null != name) {
      name=name.toLowerCase();
      if ((name.contains(""String_Node_Str"") || name.contains(""String_Node_Str"")) && name.endsWith(""String_Node_Str""))       useCDNImportForFontAwesome=false;
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
      }
 else       if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        loadJQuery=false;
      }
    }
  }
  if (useCDNImportForFontAwesome) {
    InternalFALink output=new InternalFALink();
    output.getAttributes().put(""String_Node_Str"",C.FONTAWESOME_CDN_URL);
    root.addComponentResource(context,output,""String_Node_Str"");
  }
  Map<String,Object> viewMap=root.getViewMap();
  @SuppressWarnings(""String_Node_Str"") Map<String,String> resourceMap=(Map<String,String>)viewMap.get(RESOURCE_KEY);
  if (null != resourceMap) {
    if (loadJQuery) {
      boolean needsJQuery=false;
      for (      Entry<String,String> entry : resourceMap.entrySet()) {
        String file=entry.getValue();
        if (""String_Node_Str"".equals(file)) {
          needsJQuery=true;
        }
      }
      if (needsJQuery) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        root.addComponentResource(context,output,""String_Node_Str"");
      }
    }
    for (    Entry<String,String> entry : resourceMap.entrySet()) {
      String file=entry.getValue();
      String library=entry.getKey().substring(0,entry.getKey().length() - file.length() - 1);
      if (!""String_Node_Str"".equals(file)) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",file);
        output.getAttributes().put(""String_Node_Str"",library);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        root.addComponentResource(context,output,""String_Node_Str"");
      }
    }
  }
  enforceCorrectLoadOrder(root,context);
{
    InternalIE8CompatiblityLinks output=new InternalIE8CompatiblityLinks();
    root.addComponentResource(context,output,""String_Node_Str"");
  }
}","/** 
 * Add the required Javascript files and the FontAwesome CDN link.
 * @param root The UIViewRoot of the JSF tree.
 * @param context The current FacesContext
 * @param isProduction This flag can be used to deliver different version of the JS library, optimized for debugging or production.
 */
private void addJavascript(UIViewRoot root,FacesContext context,boolean isProduction){
  Application app=context.getApplication();
  ResourceHandler rh=app.getResourceHandler();
  String theme=null;
  theme=context.getExternalContext().getInitParameter(C.P_USETHEME);
  if (isFontAwesomeComponentUsedAndRemoveIt() || (theme != null && theme.equals(C.TRUE))) {
    Resource themeResource=rh.createResource(C.BSF_CSS_TBSTHEME,C.BSF_LIBRARY);
    if (themeResource == null) {
      throw new FacesException(""String_Node_Str"" + C.BSF_CSS_TBSTHEME + ""String_Node_Str""+ C.BSF_LIBRARY+ ""String_Node_Str"");
    }
 else {
      UIOutput output=new UIOutput();
      output.setRendererType(""String_Node_Str"");
      output.getAttributes().put(""String_Node_Str"",C.BSF_CSS_TBSTHEME);
      output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
      output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
      addResourceIfNecessary(root,context,output);
    }
  }
  UIComponent header=findHeader(root);
  boolean useCDNImportForFontAwesome=(null == header) || (null == header.getFacet(""String_Node_Str""));
  if (useCDNImportForFontAwesome) {
    String useCDN=FacesContext.getCurrentInstance().getExternalContext().getInitParameter(""String_Node_Str"");
    if (null != useCDN)     if (useCDN.equalsIgnoreCase(""String_Node_Str"") || useCDN.equals(""String_Node_Str""))     useCDNImportForFontAwesome=false;
  }
  boolean loadJQuery=true;
  List<UIComponent> availableResources=root.getComponentResources(context,""String_Node_Str"");
  for (  UIComponent ava : availableResources) {
    String name=(String)ava.getAttributes().get(""String_Node_Str"");
    if (null != name) {
      name=name.toLowerCase();
      if ((name.contains(""String_Node_Str"") || name.contains(""String_Node_Str"")) && name.endsWith(""String_Node_Str""))       useCDNImportForFontAwesome=false;
      if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
      }
 else       if (name.contains(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        loadJQuery=false;
      }
    }
  }
  if (useCDNImportForFontAwesome) {
    InternalFALink output=new InternalFALink();
    output.getAttributes().put(""String_Node_Str"",C.FONTAWESOME_CDN_URL);
    addResourceIfNecessary(root,context,output);
  }
  Map<String,Object> viewMap=root.getViewMap();
  @SuppressWarnings(""String_Node_Str"") Map<String,String> resourceMap=(Map<String,String>)viewMap.get(RESOURCE_KEY);
  if (null != resourceMap) {
    if (loadJQuery) {
      boolean needsJQuery=false;
      for (      Entry<String,String> entry : resourceMap.entrySet()) {
        String file=entry.getValue();
        if (""String_Node_Str"".equals(file)) {
          needsJQuery=true;
        }
      }
      if (needsJQuery) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        addResourceIfNecessary(root,context,output);
      }
    }
    for (    Entry<String,String> entry : resourceMap.entrySet()) {
      String file=entry.getValue();
      String library=entry.getKey().substring(0,entry.getKey().length() - file.length() - 1);
      if (!""String_Node_Str"".equals(file)) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",file);
        output.getAttributes().put(""String_Node_Str"",library);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        addResourceIfNecessary(root,context,output);
      }
    }
  }
  enforceCorrectLoadOrder(root,context);
{
    InternalIE8CompatiblityLinks output=new InternalIE8CompatiblityLinks();
    addResourceIfNecessary(root,context,output);
  }
}"
57061,"/** 
 * Add the required Javascript files and the FontAwesome CDN link. 
 * @param root The UIViewRoot of the JSF tree.
 * @param context The current FacesContext
 * @param isProduction This flag can be used to deliver different version of the JS library, optimized for debugging or production.
 */
private void addJavascript(UIViewRoot root,FacesContext context,boolean isProduction){
  Application app=context.getApplication();
  ResourceHandler rh=app.getResourceHandler();
  String theme=null;
  theme=context.getExternalContext().getInitParameter(C.P_USETHEME);
  if (theme != null && theme.equals(C.TRUE)) {
    Resource themeResource=rh.createResource(C.BSF_CSS_TBSTHEME,C.BSF_LIBRARY);
    if (themeResource == null) {
      throw new FacesException(""String_Node_Str"" + C.BSF_CSS_TBSTHEME + ""String_Node_Str""+ C.BSF_LIBRARY+ ""String_Node_Str"");
    }
 else {
      UIOutput output=new UIOutput();
      output.setRendererType(""String_Node_Str"");
      output.getAttributes().put(""String_Node_Str"",C.BSF_CSS_TBSTHEME);
      output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
      output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
      root.addComponentResource(context,output,""String_Node_Str"");
    }
  }
  UIComponent header=findHeader(root);
  boolean usefa=(null == header) || (null == header.getFacet(""String_Node_Str""));
  if (usefa) {
    InternalFALink output=new InternalFALink();
    output.getAttributes().put(""String_Node_Str"",C.FONTAWESOME_CDN_URL);
    root.addComponentResource(context,output,""String_Node_Str"");
  }
  boolean loadJQuery=true;
  List<UIComponent> availableResources=root.getComponentResources(context,""String_Node_Str"");
  for (  UIComponent ava : availableResources) {
    String name=(String)ava.getAttributes().get(""String_Node_Str"");
    if (null != name)     if (name.toLowerCase().contains(""String_Node_Str"") && name.toLowerCase().endsWith(""String_Node_Str"")) {
    }
 else     if (name.toLowerCase().contains(""String_Node_Str"") && name.toLowerCase().endsWith(""String_Node_Str"")) {
      loadJQuery=false;
    }
  }
  Map<String,Object> viewMap=root.getViewMap();
  @SuppressWarnings(""String_Node_Str"") Map<String,String> resourceMap=(Map<String,String>)viewMap.get(RESOURCE_KEY);
  if (null != resourceMap) {
    if (loadJQuery) {
      boolean needsJQuery=false;
      for (      Entry<String,String> entry : resourceMap.entrySet()) {
        String file=entry.getValue();
        if (""String_Node_Str"".equals(file)) {
          needsJQuery=true;
        }
      }
      if (needsJQuery) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        root.addComponentResource(context,output,""String_Node_Str"");
      }
    }
    for (    Entry<String,String> entry : resourceMap.entrySet()) {
      String file=entry.getValue();
      String library=entry.getKey().substring(0,entry.getKey().length() - file.length() - 1);
      if (!""String_Node_Str"".equals(file)) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",file);
        output.getAttributes().put(""String_Node_Str"",library);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        root.addComponentResource(context,output,""String_Node_Str"");
      }
    }
  }
{
    InternalIE8CompatiblityLinks output=new InternalIE8CompatiblityLinks();
    root.addComponentResource(context,output,""String_Node_Str"");
  }
}","/** 
 * Add the required Javascript files and the FontAwesome CDN link.
 * @param root The UIViewRoot of the JSF tree.
 * @param context The current FacesContext
 * @param isProduction This flag can be used to deliver different version of the JS library, optimized for debugging or production.
 */
private void addJavascript(UIViewRoot root,FacesContext context,boolean isProduction){
  Application app=context.getApplication();
  ResourceHandler rh=app.getResourceHandler();
  String theme=null;
  theme=context.getExternalContext().getInitParameter(C.P_USETHEME);
  if (isFontAwesomeComponentUsedAndRemoveIt() || (theme != null && theme.equals(C.TRUE))) {
    Resource themeResource=rh.createResource(C.BSF_CSS_TBSTHEME,C.BSF_LIBRARY);
    if (themeResource == null) {
      throw new FacesException(""String_Node_Str"" + C.BSF_CSS_TBSTHEME + ""String_Node_Str""+ C.BSF_LIBRARY+ ""String_Node_Str"");
    }
 else {
      UIOutput output=new UIOutput();
      output.setRendererType(""String_Node_Str"");
      output.getAttributes().put(""String_Node_Str"",C.BSF_CSS_TBSTHEME);
      output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
      output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
      root.addComponentResource(context,output,""String_Node_Str"");
    }
  }
  UIComponent header=findHeader(root);
  boolean usefa=(null == header) || (null == header.getFacet(""String_Node_Str""));
  if (usefa) {
    InternalFALink output=new InternalFALink();
    output.getAttributes().put(""String_Node_Str"",C.FONTAWESOME_CDN_URL);
    root.addComponentResource(context,output,""String_Node_Str"");
  }
  boolean loadJQuery=true;
  List<UIComponent> availableResources=root.getComponentResources(context,""String_Node_Str"");
  for (  UIComponent ava : availableResources) {
    String name=(String)ava.getAttributes().get(""String_Node_Str"");
    if (null != name)     if (name.toLowerCase().contains(""String_Node_Str"") && name.toLowerCase().endsWith(""String_Node_Str"")) {
    }
 else     if (name.toLowerCase().contains(""String_Node_Str"") && name.toLowerCase().endsWith(""String_Node_Str"")) {
      loadJQuery=false;
    }
  }
  Map<String,Object> viewMap=root.getViewMap();
  @SuppressWarnings(""String_Node_Str"") Map<String,String> resourceMap=(Map<String,String>)viewMap.get(RESOURCE_KEY);
  if (null != resourceMap) {
    if (loadJQuery) {
      boolean needsJQuery=false;
      for (      Entry<String,String> entry : resourceMap.entrySet()) {
        String file=entry.getValue();
        if (""String_Node_Str"".equals(file)) {
          needsJQuery=true;
        }
      }
      if (needsJQuery) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",C.BSF_LIBRARY);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        root.addComponentResource(context,output,""String_Node_Str"");
      }
    }
    for (    Entry<String,String> entry : resourceMap.entrySet()) {
      String file=entry.getValue();
      String library=entry.getKey().substring(0,entry.getKey().length() - file.length() - 1);
      if (!""String_Node_Str"".equals(file)) {
        UIOutput output=new UIOutput();
        output.setRendererType(""String_Node_Str"");
        output.getAttributes().put(""String_Node_Str"",file);
        output.getAttributes().put(""String_Node_Str"",library);
        output.getAttributes().put(""String_Node_Str"",""String_Node_Str"");
        root.addComponentResource(context,output,""String_Node_Str"");
      }
    }
  }
{
    InternalIE8CompatiblityLinks output=new InternalIE8CompatiblityLinks();
    root.addComponentResource(context,output,""String_Node_Str"");
  }
}"
57062,"/** 
 * Renders the button. <br> General layout of the generated HTML code:<br> &lt;button class=""btn btn-large"" href=""#"">&lt;i class=""icon-star"">&lt;/i> Star&lt;/button>
 * @param context the current FacesContext
 * @throws IOException thrown if something's wrong with the ResponseWriter
 */
@Override public void encodeEnd(FacesContext context) throws IOException {
  encodeHTML(context,getAttributes());
}","/** 
 * Renders the button. <br> General layout of the generated HTML code:<br> &lt;button class=""btn btn-large"" href=""#""%gt;&lt;i class=""icon-star""&gt;&lt;/i&gt; Star&lt;/button&gt;
 * @param context the current FacesContext
 * @throws IOException thrown if something's wrong with the ResponseWriter
 */
@Override public void encodeEnd(FacesContext context) throws IOException {
  encodeHTML(context,getAttributes());
}"
57063,"/** 
 * <p>Returns the <code>label</code> property from the specified component.</p> Simplified and adapted version of the implementation of Mojarra 2.2.8-b02 (see MessageFactory).
 * @param context   - the <code>FacesContext</code> for the current request
 * @param component - the component of interest
 * @return the label, if any, of the component
 */
public String getLabel(FacesContext context){
  Object o=getAttributes().get(""String_Node_Str"");
  if (o == null || (o instanceof String && ((String)o).length() == 0)) {
    ValueExpression vex=getValueExpression(""String_Node_Str"");
    if (null != vex)     return (String)vex.getValue(context.getELContext());
  }
  return (String)getClientId(context);
}","/** 
 * <p>Returns the <code>label</code> property from the specified component.</p> Simplified and adapted version of the implementation of Mojarra 2.2.8-b02 (see MessageFactory).
 * @param context   - the <code>FacesContext</code> for the current request
 * @return the label, if any, of the component
 */
public String getLabel(FacesContext context){
  Object o=getAttributes().get(""String_Node_Str"");
  if (o == null || (o instanceof String && ((String)o).length() == 0)) {
    ValueExpression vex=getValueExpression(""String_Node_Str"");
    if (null != vex)     return (String)vex.getValue(context.getELContext());
  }
  return (String)getClientId(context);
}"
57064,"/** 
 * <p> Creates and returns a FacesMessage for the specified Locale. </p> Simplified and streamlined version of the implementation of Mojarra 2.2.8-b02 (see MessageFactory).
 * @param locale - the target <code>Locale</code>
 * @param messageId - the key of the message in the resource bundle
 * @param params - substittion parameters
 * @return a localized <code>FacesMessage</code> with the severity of FacesMessage.SEVERITY_ERROR
 */
public static FacesMessage getMessage(String messageId,String... params){
  String summary=null;
  String detail=null;
  ResourceBundle bundle;
  String bundleName;
  FacesContext context=FacesContext.getCurrentInstance();
  Locale locale=context.getViewRoot().getLocale();
  Application app=(FacesContext.getCurrentInstance().getApplication());
  if (null != (bundleName=app.getMessageBundle())) {
    if (null != (bundle=ResourceBundle.getBundle(bundleName,locale,Thread.currentThread().getContextClassLoader()))) {
      try {
        summary=bundle.getString(messageId);
        detail=bundle.getString(messageId + ""String_Node_Str"");
      }
 catch (      MissingResourceException e) {
      }
    }
  }
  if (null == summary) {
    bundle=ResourceBundle.getBundle(FacesMessage.FACES_MESSAGES,locale,Thread.currentThread().getContextClassLoader());
    if (null == bundle) {
      throw new NullPointerException();
    }
    try {
      summary=bundle.getString(messageId);
      detail=bundle.getString(messageId + ""String_Node_Str"");
    }
 catch (    MissingResourceException e) {
    }
  }
  for (int i=0; i < params.length; i++) {
    summary=summary.replace(""String_Node_Str"" + i + ""String_Node_Str"",params[i]);
    detail=detail.replace(""String_Node_Str"" + i + ""String_Node_Str"",params[i]);
  }
  FacesMessage ret=new FacesMessage(FacesMessage.SEVERITY_ERROR,summary,detail);
  ret.setSeverity(FacesMessage.SEVERITY_ERROR);
  return ret;
}","/** 
 * <p> Creates and returns a FacesMessage for the specified Locale. </p> Simplified and streamlined version of the implementation of Mojarra 2.2.8-b02 (see MessageFactory).
 * @param messageId - the key of the message in the resource bundle
 * @param params - substitution parameters
 * @return a localized <code>FacesMessage</code> with the severity of FacesMessage.SEVERITY_ERROR
 */
public static FacesMessage getMessage(String messageId,String... params){
  String summary=null;
  String detail=null;
  ResourceBundle bundle;
  String bundleName;
  FacesContext context=FacesContext.getCurrentInstance();
  Locale locale=context.getViewRoot().getLocale();
  Application app=(FacesContext.getCurrentInstance().getApplication());
  if (null != (bundleName=app.getMessageBundle())) {
    if (null != (bundle=ResourceBundle.getBundle(bundleName,locale,Thread.currentThread().getContextClassLoader()))) {
      try {
        summary=bundle.getString(messageId);
        detail=bundle.getString(messageId + ""String_Node_Str"");
      }
 catch (      MissingResourceException e) {
      }
    }
  }
  if (null == summary) {
    bundle=ResourceBundle.getBundle(FacesMessage.FACES_MESSAGES,locale,Thread.currentThread().getContextClassLoader());
    if (null == bundle) {
      throw new NullPointerException();
    }
    try {
      summary=bundle.getString(messageId);
      detail=bundle.getString(messageId + ""String_Node_Str"");
    }
 catch (    MissingResourceException e) {
    }
  }
  for (int i=0; i < params.length; i++) {
    summary=summary.replace(""String_Node_Str"" + i + ""String_Node_Str"",params[i]);
    detail=detail.replace(""String_Node_Str"" + i + ""String_Node_Str"",params[i]);
  }
  FacesMessage ret=new FacesMessage(FacesMessage.SEVERITY_ERROR,summary,detail);
  ret.setSeverity(FacesMessage.SEVERITY_ERROR);
  return ret;
}"
57065,"/** 
 * Generates the HTML of the tabs.
 * @param context the current FacesContext
 * @param writer the response writer
 * @param children the tabs
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTabs(FacesContext context,ResponseWriter writer,List<UIComponent> children,Map<String,Object> attributes,int currentlyActiveIndex) throws IOException {
  if (null != children) {
    int activeIndex=determineActiveIndex(attributes,currentlyActiveIndex);
    for (int index=0; index < children.size(); index++) {
      encodeTab(context,writer,children.get(index),index == activeIndex);
    }
  }
}","/** 
 * Generates the HTML of the tabs.
 * @param context the current FacesContext
 * @param writer the response writer
 * @param children the tabs
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTabs(FacesContext context,ResponseWriter writer,List<UIComponent> children,Map<String,Object> attributes,int currentlyActiveIndex,String hiddenInputFieldID) throws IOException {
  if (null != children) {
    int activeIndex=determineActiveIndex(attributes,currentlyActiveIndex);
    for (int index=0; index < children.size(); index++) {
      encodeTab(context,writer,children.get(index),index == activeIndex,hiddenInputFieldID,index);
    }
  }
}"
57066,"/** 
 * Generate the clickable entity of the tab.
 * @param writer the response writer
 * @param tab the tab to be rendered.
 * @param tabAttributes the attribute list of the tab.
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTabAnchorTag(ResponseWriter writer,UIComponent tab,Map<String,Object> tabAttributes) throws IOException {
  writer.startElement(A,tab);
  writer.writeAttribute(ROLE,""String_Node_Str"",ROLE);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  writer.writeAttribute(HREF,""String_Node_Str"" + tab.getClientId().replace(""String_Node_Str"",""String_Node_Str""),HREF);
  R.encodeHTML4DHTMLAttrs(writer,tabAttributes,TAB_ATTRS);
  writer.writeText(tabAttributes.get(""String_Node_Str""),null);
  writer.endElement(A);
}","/** 
 * Generate the clickable entity of the tab.
 * @param writer the response writer
 * @param tab the tab to be rendered.
 * @param tabAttributes the attribute list of the tab.
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTabAnchorTag(ResponseWriter writer,UIComponent tab,Map<String,Object> tabAttributes,String hiddenInputFieldID,int tabindex) throws IOException {
  writer.startElement(A,tab);
  writer.writeAttribute(ROLE,""String_Node_Str"",ROLE);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  writer.writeAttribute(HREF,""String_Node_Str"" + tab.getClientId().replace(""String_Node_Str"",""String_Node_Str""),HREF);
  String onclick=""String_Node_Str"" + hiddenInputFieldID + ""String_Node_Str""+ String.valueOf(tabindex)+ ""String_Node_Str"";
  String userClick=(String)tabAttributes.get(""String_Node_Str"");
  if (null != userClick && userClick.trim().length() > 0) {
    onclick+=userClick;
  }
  writer.writeAttribute(""String_Node_Str"",onclick,""String_Node_Str"");
  R.encodeHTML4DHTMLAttrs(writer,tabAttributes,TAB_ATTRS);
  writer.writeText(tabAttributes.get(""String_Node_Str""),null);
  writer.endElement(A);
}"
57067,"/** 
 * Generate an individual tab. Basically, that's &lt;li role=""presentation"" class=""active""&gt&lt;a href=""#{clientID}"" role=""tab"" data-toggle=""tab""&lt; {{title}} &gt;/a&gt;
 * @param context the current FacesContext
 * @param writer the response writer
 * @param tab the tab to be rendered.
 * @param isActive is the current tab active?
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTab(FacesContext context,ResponseWriter writer,UIComponent tab,boolean isActive) throws IOException {
  writer.startElement(LI,tab);
  writer.writeAttribute(ROLE,""String_Node_Str"",ROLE);
  Map<String,Object> tabAttributes=tab.getAttributes();
  String classes=isActive ? ACTIVE : ""String_Node_Str"";
  if (tabAttributes.containsKey(STYLECLASS)) {
    classes+=""String_Node_Str"";
    classes+=tabAttributes.get(STYLECLASS);
  }
  if (classes.length() > 0)   writer.writeAttribute(CLASS,classes,CLASS);
  encodeTabAnchorTag(writer,tab,tabAttributes);
  writer.endElement(LI);
}","/** 
 * Generate an individual tab. Basically, that's &lt;li role=""presentation"" class=""active""&gt&lt;a href=""#{clientID}"" role=""tab"" data-toggle=""tab""&lt; {{title}} &gt;/a&gt;
 * @param context the current FacesContext
 * @param writer the response writer
 * @param tab the tab to be rendered.
 * @param isActive is the current tab active?
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTab(FacesContext context,ResponseWriter writer,UIComponent tab,boolean isActive,String hiddenInputFieldID,int tabIndex) throws IOException {
  writer.startElement(LI,tab);
  writer.writeAttribute(ROLE,""String_Node_Str"",ROLE);
  Map<String,Object> tabAttributes=tab.getAttributes();
  String classes=isActive ? ACTIVE : ""String_Node_Str"";
  if (tabAttributes.containsKey(STYLECLASS)) {
    classes+=""String_Node_Str"";
    classes+=tabAttributes.get(STYLECLASS);
  }
  if (classes.length() > 0)   writer.writeAttribute(CLASS,classes,CLASS);
  encodeTabAnchorTag(writer,tab,tabAttributes,hiddenInputFieldID,tabIndex);
  writer.endElement(LI);
}"
57068,"/** 
 * Generates the HTML code for the entire TabStrip.
 * @param context the current FacesContext
 * @throws IOException only thrown if something's wrong with the response writer
 */
@Override public void encodeBegin(FacesContext context) throws IOException {
  ResponseWriter writer=context.getResponseWriter();
  Map<String,Object> attributes=getAttributes();
  String clientId=getClientId(context);
  writer.startElement(""String_Node_Str"",this);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",clientId + ""String_Node_Str"",""String_Node_Str"");
  writer.writeAttribute(""String_Node_Str"",determineActiveIndex(attributes,currentlyActiveIndex),""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
  writer.startElement(UL,this);
  writer.writeAttribute(ID,clientId,ID);
  String classes=""String_Node_Str"";
  if (attributes.containsKey(STYLECLASS)) {
    classes+=""String_Node_Str"";
    classes+=attributes.get(STYLECLASS);
  }
  writer.writeAttribute(CLASS,classes,CLASS);
  String role=""String_Node_Str"";
  R.encodeHTML4DHTMLAttrs(writer,attributes,TAB_VIEW_ATTRS);
  if (attributes.containsKey(ROLE)) {
    role=(String)attributes.get(ROLE);
  }
  writer.writeAttribute(ROLE,role,ROLE);
  encodeTabs(context,writer,getChildren(),attributes,currentlyActiveIndex);
  writer.endElement(""String_Node_Str"");
  encodeTabContentPanes(context,writer,this,attributes,currentlyActiveIndex);
}","/** 
 * Generates the HTML code for the entire TabStrip.
 * @param context the current FacesContext
 * @throws IOException only thrown if something's wrong with the response writer
 */
@Override public void encodeBegin(FacesContext context) throws IOException {
  ResponseWriter writer=context.getResponseWriter();
  Map<String,Object> attributes=getAttributes();
  String clientId=getClientId(context);
  writer.startElement(""String_Node_Str"",this);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  final String hiddenInputFieldID=clientId + ""String_Node_Str"";
  writer.writeAttribute(""String_Node_Str"",hiddenInputFieldID,""String_Node_Str"");
  writer.writeAttribute(""String_Node_Str"",hiddenInputFieldID,""String_Node_Str"");
  writer.writeAttribute(""String_Node_Str"",determineActiveIndex(attributes,currentlyActiveIndex),""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
  writer.startElement(UL,this);
  writer.writeAttribute(ID,clientId,ID);
  String classes=""String_Node_Str"";
  if (attributes.containsKey(STYLECLASS)) {
    classes+=""String_Node_Str"";
    classes+=attributes.get(STYLECLASS);
  }
  writer.writeAttribute(CLASS,classes,CLASS);
  String role=""String_Node_Str"";
  R.encodeHTML4DHTMLAttrs(writer,attributes,TAB_VIEW_ATTRS);
  if (attributes.containsKey(ROLE)) {
    role=(String)attributes.get(ROLE);
  }
  writer.writeAttribute(ROLE,role,ROLE);
  encodeTabs(context,writer,getChildren(),attributes,currentlyActiveIndex,hiddenInputFieldID);
  writer.endElement(""String_Node_Str"");
  encodeTabContentPanes(context,writer,this,attributes,currentlyActiveIndex);
}"
57069,"/** 
 * Generate an individual tab. Basically, that's &lt;li role=""presentation"" class=""active""&gt&lt;a href=""#{clientID}"" role=""tab"" data-toggle=""tab""&lt; {{title}} &gt;/a&gt;
 * @param context the current FacesContext
 * @param writer the response writer
 * @param tab the tab to be rendered.
 * @param isActive is the current tab active?
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTab(FacesContext context,ResponseWriter writer,UIComponent tab,boolean isActive) throws IOException {
  writer.startElement(LI,tab);
  writer.writeAttribute(ROLE,""String_Node_Str"",ROLE);
  Map<String,Object> tabAttributes=tab.getAttributes();
  String classes=isActive ? ACTIVE : ""String_Node_Str"";
  if (tabAttributes.containsKey(STYLECLASS)) {
    classes+=""String_Node_Str"";
    classes+=tabAttributes.get(STYLECLASS);
  }
  writer.writeAttribute(CLASS,classes,CLASS);
  encodeTabAnchorTag(writer,tab,tabAttributes);
  writer.endElement(LI);
}","/** 
 * Generate an individual tab. Basically, that's &lt;li role=""presentation"" class=""active""&gt&lt;a href=""#{clientID}"" role=""tab"" data-toggle=""tab""&lt; {{title}} &gt;/a&gt;
 * @param context the current FacesContext
 * @param writer the response writer
 * @param tab the tab to be rendered.
 * @param isActive is the current tab active?
 * @throws IOException only thrown if something's wrong with the response writer
 */
private static void encodeTab(FacesContext context,ResponseWriter writer,UIComponent tab,boolean isActive) throws IOException {
  writer.startElement(LI,tab);
  writer.writeAttribute(ROLE,""String_Node_Str"",ROLE);
  Map<String,Object> tabAttributes=tab.getAttributes();
  String classes=isActive ? ACTIVE : ""String_Node_Str"";
  if (tabAttributes.containsKey(STYLECLASS)) {
    classes+=""String_Node_Str"";
    classes+=tabAttributes.get(STYLECLASS);
  }
  if (classes.length() > 0)   writer.writeAttribute(CLASS,classes,CLASS);
  encodeTabAnchorTag(writer,tab,tabAttributes);
  writer.endElement(LI);
}"
57070,"/** 
 * Merge the column span information and the optional columnClasses attribute.
 * @param colSpans the integer array returned by getColSpans().
 * @return null or an array of String consisting of the CSS classes.
 */
protected String[] getColumnClasses(int[] colSpans){
  String columnsCSV=getColumnClasses();
  String[] columnClasses;
  if (null == columnsCSV)   columnClasses=null;
 else {
    columnClasses=columnsCSV.split(""String_Node_Str"");
    if (columnClasses.length > colSpans.length) {
      throw new FacesException(""String_Node_Str"");
    }
  }
  String[] result=new String[colSpans.length];
  for (int i=0; i < colSpans.length; i++) {
    if (columnClasses == null) {
      result[i]=""String_Node_Str"" + colSpans[i];
    }
 else {
      String current=columnClasses[i % columnClasses.length];
      if (current.contains(""String_Node_Str"")) {
        result[i]=current;
      }
 else {
        result[i]=""String_Node_Str"" + colSpans[i] + ""String_Node_Str""+ current;
      }
    }
  }
  return result;
}","/** 
 * Merge the column span information and the optional columnClasses attribute.
 * @param colSpans the integer array returned by getColSpans().
 * @return null or an array of String consisting of the CSS classes.
 */
protected String[] getColumnClasses(int[] colSpans){
  String columnsCSV=getColumnClasses();
  String[] columnClasses;
  if (null == columnsCSV)   columnClasses=null;
 else {
    columnClasses=columnsCSV.split(""String_Node_Str"");
    if (columnClasses.length > colSpans.length) {
      throw new FacesException(""String_Node_Str"");
    }
  }
  String size=getSize();
  if (null == size || size.equals(""String_Node_Str""))   size=""String_Node_Str"";
  String[] result=new String[colSpans.length];
  for (int i=0; i < colSpans.length; i++) {
    if (columnClasses == null) {
      result[i]=""String_Node_Str"" + size + ""String_Node_Str""+ colSpans[i];
    }
 else {
      String current=columnClasses[i % columnClasses.length];
      if (current.contains(""String_Node_Str"")) {
        result[i]=current;
      }
 else {
        result[i]=""String_Node_Str"" + size + ""String_Node_Str""+ colSpans[i]+ ""String_Node_Str""+ current;
      }
    }
  }
  return result;
}"
57071,"@Override public void decode(FacesContext context){
  String subVal=(String)context.getExternalContext().getRequestParameterMap().get(getClientId(context));
  if (subVal != null) {
    this.setSubmittedValue(subVal);
    this.setValid(true);
  }
}","@Override public void decode(FacesContext context){
  InputText inputText=(InputText)this;
  if (inputText.isDisabled() || inputText.isReadonly()) {
    return;
  }
  decodeBehaviors(context,inputText);
  String clientId=inputText.getClientId(context);
  String submittedValue=(String)context.getExternalContext().getRequestParameterMap().get(clientId);
  if (submittedValue != null) {
    inputText.setSubmittedValue(submittedValue);
  }
}"
57072,"@Override public void encodeBegin(FacesContext context) throws IOException {
  Map<String,Object> attrs=getAttributes();
  ResponseWriter rw=context.getResponseWriter();
  String clientId=getClientId(context);
  UIComponent prep=getFacet(C.PREPEND);
  UIComponent app=getFacet(C.APPEND);
  boolean prepend=(prep != null);
  boolean append=(app != null);
  if (prepend) {
    R.addClass2FacetComponent(prep,""String_Node_Str"",ADDON);
  }
  if (append) {
    R.addClass2FacetComponent(app,""String_Node_Str"",ADDON);
  }
  String l=A.asString(attrs.get(A.LABEL));
  String t=A.asString(attrs.get(A.TYPE));
  if (t == null)   t=H.TEXT;
  rw.startElement(H.DIV,this);
  rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
  if (l != null) {
    rw.startElement(H.LABEL,this);
    rw.writeAttribute(A.FOR,clientId,A.FOR);
    rw.writeText(l,null);
    rw.endElement(H.LABEL);
  }
  if (append || prepend) {
    rw.startElement(H.DIV,this);
    rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
  }
  int span=A.toInt(attrs.get(A.SPAN));
  if (span > 0) {
    rw.startElement(H.DIV,this);
    rw.writeAttribute(H.CLASS,""String_Node_Str"" + span,H.CLASS);
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(H.DIV,this);
      rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
      prep.encodeAll(context);
      rw.endElement(H.DIV);
    }
 else {
      prep.encodeAll(context);
    }
  }
  rw.startElement(H.INPUT,this);
  rw.writeAttribute(H.ID,clientId,null);
  rw.writeAttribute(H.NAME,clientId,null);
  rw.writeAttribute(H.TYPE,t,null);
  StringBuilder sb;
  String s;
  sb=new StringBuilder(20);
  sb.append(""String_Node_Str"");
  String fsize=A.asString(attrs.get(A.FIELDSIZE));
  if (fsize != null) {
    sb.append(""String_Node_Str"").append(fsize);
  }
  String sclass=A.asString(attrs.get(H.STYLECLASS));
  if (sclass != null) {
    sb.append(""String_Node_Str"").append(sclass);
  }
  s=sb.toString().trim();
  if (s != null && s.length() > 0) {
    rw.writeAttribute(H.CLASS,s,H.CLASS);
  }
  String ph=A.asString(attrs.get(A.PHOLDER));
  if (ph != null) {
    rw.writeAttribute(H.PHOLDER,ph,null);
  }
  if (A.toBool(attrs.get(A.DISABLED))) {
    rw.writeAttribute(A.DISABLED,A.DISABLED,null);
  }
  if (A.toBool(attrs.get(A.READONLY))) {
    rw.writeAttribute(A.READONLY,A.READONLY,null);
  }
  R.encodeHTML4DHTMLAttrs(rw,attrs,A.INPUT_TEXT_ATTRS);
  if ((A.asString(attrs.get(""String_Node_Str"")) != null) && (A.asString(attrs.get(""String_Node_Str"")).equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=R.getValue2Render(context,this);
  rw.writeAttribute(H.VALUE,v,null);
  rw.endElement(H.INPUT);
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(H.DIV,this);
      rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
      app.encodeAll(context);
      rw.endElement(H.DIV);
    }
 else {
      app.encodeAll(context);
    }
  }
  if (append || prepend) {
    rw.endElement(H.DIV);
  }
  rw.endElement(H.DIV);
  if (span > 0) {
    rw.endElement(H.DIV);
  }
}","@Override public void encodeBegin(FacesContext context) throws IOException {
  Map<String,Object> attrs=getAttributes();
  ResponseWriter rw=context.getResponseWriter();
  String clientId=getClientId(context);
  UIComponent prep=getFacet(C.PREPEND);
  UIComponent app=getFacet(C.APPEND);
  boolean prepend=(prep != null);
  boolean append=(app != null);
  if (prepend) {
    R.addClass2FacetComponent(prep,""String_Node_Str"",ADDON);
  }
  if (append) {
    R.addClass2FacetComponent(app,""String_Node_Str"",ADDON);
  }
  String l=A.asString(attrs.get(A.LABEL));
  String t=A.asString(attrs.get(A.TYPE));
  if (t == null)   t=H.TEXT;
  rw.startElement(H.DIV,this);
  rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
  if (l != null) {
    rw.startElement(H.LABEL,this);
    rw.writeAttribute(A.FOR,clientId,A.FOR);
    rw.writeText(l,null);
    rw.endElement(H.LABEL);
  }
  if (append || prepend) {
    rw.startElement(H.DIV,this);
    rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
  }
  int span=A.toInt(attrs.get(A.SPAN));
  if (span > 0) {
    rw.startElement(H.DIV,this);
    rw.writeAttribute(H.CLASS,""String_Node_Str"" + span,H.CLASS);
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(H.DIV,this);
      rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
      prep.encodeAll(context);
      rw.endElement(H.DIV);
    }
 else {
      prep.encodeAll(context);
    }
  }
  rw.startElement(H.INPUT,this);
  rw.writeAttribute(H.ID,clientId,null);
  rw.writeAttribute(H.NAME,clientId,null);
  rw.writeAttribute(H.TYPE,t,null);
  StringBuilder sb;
  String s;
  sb=new StringBuilder(20);
  sb.append(""String_Node_Str"");
  String fsize=A.asString(attrs.get(A.FIELDSIZE));
  if (fsize != null) {
    sb.append(""String_Node_Str"").append(fsize);
  }
  String sclass=A.asString(attrs.get(H.STYLECLASS));
  if (sclass != null) {
    sb.append(""String_Node_Str"").append(sclass);
  }
  s=sb.toString().trim();
  if (s != null && s.length() > 0) {
    rw.writeAttribute(H.CLASS,s,H.CLASS);
  }
  String ph=A.asString(attrs.get(A.PHOLDER));
  if (ph != null) {
    rw.writeAttribute(H.PHOLDER,ph,null);
  }
  if (A.toBool(attrs.get(A.DISABLED))) {
    rw.writeAttribute(A.DISABLED,A.DISABLED,null);
  }
  if (A.toBool(attrs.get(A.READONLY))) {
    rw.writeAttribute(A.READONLY,A.READONLY,null);
  }
  R.encodeHTML4DHTMLAttrs(rw,attrs,A.INPUT_TEXT_ATTRS);
  if ((A.asString(attrs.get(""String_Node_Str"")) != null) && (A.asString(attrs.get(""String_Node_Str"")).equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=R.getValue2Render(context,this);
  rw.writeAttribute(H.VALUE,v,null);
  Map<String,List<ClientBehavior>> clientBehaviors=this.getClientBehaviors();
  Set<String> keysClientBehavior=clientBehaviors.keySet();
  for (  String keyClientBehavior : keysClientBehavior) {
    List<ClientBehavior> behaviors=clientBehaviors.get(keyClientBehavior);
    for (    ClientBehavior cb : behaviors) {
      ClientBehaviorContext behaviorContext=ClientBehaviorContext.createClientBehaviorContext(context,this,keyClientBehavior,null,null);
      rw.writeAttribute(""String_Node_Str"" + keyClientBehavior,cb.getScript(behaviorContext),null);
    }
  }
  rw.endElement(H.INPUT);
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(H.DIV,this);
      rw.writeAttribute(H.CLASS,""String_Node_Str"",H.CLASS);
      app.encodeAll(context);
      rw.endElement(H.DIV);
    }
 else {
      app.encodeAll(context);
    }
  }
  if (append || prepend) {
    rw.endElement(H.DIV);
  }
  rw.endElement(H.DIV);
  if (span > 0) {
    rw.endElement(H.DIV);
  }
}"
57073,"/** 
 * Encodes component attributes (HTML 4 + DHTML)
 * @param rw ResponseWriter instance
 * @param attrs
 * @param alist
 * @throws IOException 
 */
public static void encodeHTML4DHTMLAttrs(ResponseWriter rw,Map<String,Object> attrs,String[] alist) throws IOException {
  for (  String a : alist) {
    if (attrs.get(a) != null) {
      String val=A.asString(attrs.get(a));
      if (val != null && val.length() > 0) {
        rw.writeAttribute(a,val,a);
      }
    }
  }
}","/** 
 * Encodes component attributes (HTML 4 + DHTML)
 * @param rw ResponseWriter instance
 * @param attrs
 * @param alist
 * @throws IOException 
 */
public static void encodeHTML4DHTMLAttrs(ResponseWriter rw,Map<String,Object> attrs,String[] alist) throws IOException {
  for (  String a : alist) {
    if (attrs.containsKey(a)) {
      if (attrs.get(a) != null) {
        String val=A.asString(attrs.get(a));
        if (val != null && val.length() > 0) {
          rw.writeAttribute(a,val,a);
        }
      }
    }
  }
}"
57074,"/** 
 * Returns the value of log B(p, q) for 0 ≤ x ≤ 1 and p, q > 0. Based on the <em>NSWC Library of Mathematics Subroutines</em> implementation,  {@code DBETLN}.
 * @param p First argument.
 * @param q Second argument.
 * @return the value of {@code log(Beta(p, q))},   {@code NaN} if{@code p <= 0} or {@code q <= 0}.
 */
public static double logBeta(final double p,final double q){
  if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0)|| (q <= 0.0)) {
    return Double.NaN;
  }
  final double a=FastMath.min(p,q);
  final double b=FastMath.max(p,q);
  if (a >= 10.0) {
    final double w=sumDeltaMinusDeltaSum(a,b);
    final double h=a / b;
    final double c=h / (1.0 + h);
    final double u=-(a - 0.5) * FastMath.log(c);
    final double v=b * FastMath.log1p(h);
    if (u <= v) {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;
    }
 else {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;
    }
  }
 else   if (a > 2.0) {
    if (b > 1000.0) {
      final int n=(int)FastMath.floor(a - 1.0);
      double prod=1.0;
      double ared=a;
      for (int i=0; i < n; i++) {
        ared-=1.0;
        prod*=ared / (1.0 + ared / b);
      }
      return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b));
    }
 else {
      double prod1=1.0;
      double ared=a;
      while (ared > 2.0) {
        ared-=1.0;
        final double h=ared / b;
        prod1*=h / (1.0 + h);
      }
      if (b < 10.0) {
        double prod2=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod2*=bred / (ared + bred);
        }
        return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared,bred)));
      }
 else {
        return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b);
      }
    }
  }
 else   if (a >= 1.0) {
    if (b > 2.0) {
      if (b < 10.0) {
        double prod=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod*=bred / (a + bred);
        }
        return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a,bred)));
      }
 else {
        return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
      }
    }
 else {
      return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a,b);
    }
  }
 else {
    if (b >= 10.0) {
      return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
    }
 else {
      return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));
    }
  }
}","/** 
 * Returns the value of   {@code log B(p, q)} for {@code 0 ≤ x ≤ 1} and {@code p, q > 0}. Based on the <em>NSWC Library of Mathematics Subroutines</em> implementation,  {@code DBETLN}.
 * @param p First argument.
 * @param q Second argument.
 * @return the value of {@code log(Beta(p, q))},   {@code NaN} if{@code p <= 0} or {@code q <= 0}.
 */
public static double logBeta(final double p,final double q){
  if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0)|| (q <= 0.0)) {
    return Double.NaN;
  }
  final double a=FastMath.min(p,q);
  final double b=FastMath.max(p,q);
  if (a >= 10.0) {
    final double w=sumDeltaMinusDeltaSum(a,b);
    final double h=a / b;
    final double c=h / (1.0 + h);
    final double u=-(a - 0.5) * FastMath.log(c);
    final double v=b * FastMath.log1p(h);
    if (u <= v) {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;
    }
 else {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;
    }
  }
 else   if (a > 2.0) {
    if (b > 1000.0) {
      final int n=(int)FastMath.floor(a - 1.0);
      double prod=1.0;
      double ared=a;
      for (int i=0; i < n; i++) {
        ared-=1.0;
        prod*=ared / (1.0 + ared / b);
      }
      return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b));
    }
 else {
      double prod1=1.0;
      double ared=a;
      while (ared > 2.0) {
        ared-=1.0;
        final double h=ared / b;
        prod1*=h / (1.0 + h);
      }
      if (b < 10.0) {
        double prod2=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod2*=bred / (ared + bred);
        }
        return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared,bred)));
      }
 else {
        return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b);
      }
    }
  }
 else   if (a >= 1.0) {
    if (b > 2.0) {
      if (b < 10.0) {
        double prod=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod*=bred / (a + bred);
        }
        return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a,bred)));
      }
 else {
        return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
      }
    }
 else {
      return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a,b);
    }
  }
 else {
    if (b >= 10.0) {
      return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
    }
 else {
      return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));
    }
  }
}"
57075,"/** 
 * Returns the complementary error function. <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<sup>2</sup></sup>dt <br> = 1 -   {@link #erf(double) erf(x)} </p><p>This implementation computes erfc(x) using the {@link Gamma#regularizedGammaQ(double,double,double,int) regularized gamma function}, following <a href=""http://mathworld.wolfram.com/Erf.html""> Erf</a>, equation (3).</p> <p>The value returned is always between 0 and 2 (inclusive). If   {@code abs(x) > 40}, then   {@code erf(x)} is indistinguishable fromeither 0 or 2 as a double, so the appropriate extreme value is returned. </p>
 * @param x the value
 * @return the complementary error function erfc(x)
 * @throws org.apache.commons.math4.exception.MaxCountExceededException if the algorithm fails to converge.
 * @see Gamma#regularizedGammaQ(double,double,double,int)
 * @since 2.2
 */
public static double erfc(double x){
  if (FastMath.abs(x) > 40) {
    return x > 0 ? 0 : 2;
  }
  final double ret=Gamma.regularizedGammaQ(0.5,x * x,1.0e-15,10000);
  return x < 0 ? 2 - ret : ret;
}","/** 
 * Returns the complementary error function. <p>erfc(x) = 2/&radic;&pi; <sub>x</sub>&int;<sup>&infin;</sup> e<sup>-t<span style=""position: relative; top: -.5em"">2</span></sup>dt <br> = 1 -   {@link #erf(double) erf(x)} </p><p>This implementation computes erfc(x) using the {@link Gamma#regularizedGammaQ(double,double,double,int) regularized gamma function}, following <a href=""http://mathworld.wolfram.com/Erf.html""> Erf</a>, equation (3).</p> <p>The value returned is always between 0 and 2 (inclusive). If   {@code abs(x) > 40}, then   {@code erf(x)} is indistinguishable fromeither 0 or 2 as a double, so the appropriate extreme value is returned. </p>
 * @param x the value
 * @return the complementary error function erfc(x)
 * @throws org.apache.commons.math4.exception.MaxCountExceededException if the algorithm fails to converge.
 * @see Gamma#regularizedGammaQ(double,double,double,int)
 * @since 2.2
 */
public static double erfc(double x){
  if (FastMath.abs(x) > 40) {
    return x > 0 ? 0 : 2;
  }
  final double ret=Gamma.regularizedGammaQ(0.5,x * x,1.0e-15,10000);
  return x < 0 ? 2 - ret : ret;
}"
57076,"/** 
 * Returns the next pseudorandom, uniformly distributed <code>long</code> value from this random number generator's sequence.  All 2<font size=""-1""><sup>64</sup></font> possible   {@code long} valuesshould be produced with (approximately) equal probability.
 * @return  the next pseudorandom, uniformly distributed <code>long</code>value from this random number generator's sequence
 */
long nextLong();","/** 
 * Returns the next pseudorandom, uniformly distributed <code>long</code> value from this random number generator's sequence.  All 2<sup style=""font-size: smaller"">64</sup> possible   {@code long} valuesshould be produced with (approximately) equal probability.
 * @return  the next pseudorandom, uniformly distributed <code>long</code>value from this random number generator's sequence
 */
long nextLong();"
57077,"/** 
 * Get a spherical cap enclosing the polygon. <p> This method is intended as a first test to quickly identify points that are guaranteed to be outside of the region, hence performing a full  {@link #checkPoint(org.apache.commons.math4.geometry.Vector) checkPoint}only if the point status remains undecided after the quick check. It is is therefore mostly useful to speed up computation for small polygons with complex shapes (say a country boundary on Earth), as the spherical cap will be small and hence will reliably identify a large part of the sphere as outside, whereas the full check can be more computing intensive. A typical use case is therefore: </p> <pre> // compute region, plus an enclosing spherical cap SphericalPolygonsSet complexShape = ...; EnclosingBall<Sphere2D, S2Point> cap = complexShape.getEnclosingCap(); // check lots of points for (Cartesian3D p : points) { final Location l; if (cap.contains(p)) { // we cannot be sure where the point is // we need to perform the full computation l = complexShape.checkPoint(v); } else { // no need to do further computation, // we already know the point is outside l = Location.OUTSIDE; } // use l ... } </pre> <p> In the special cases of empty or whole sphere polygons, special spherical caps are returned, with angular radius set to negative or positive infinity so the   {@link EnclosingBall#contains(org.apache.commons.math4.geometry.Point) ball.contains(point)}method return always false or true. </p> <p> This method is <em>not</em> guaranteed to return the smallest enclosing cap. </p>
 * @return a spherical cap enclosing the polygon
 */
public EnclosingBall<Sphere2D,S2Point> getEnclosingCap(){
  if (isEmpty()) {
    return new EnclosingBall<>(S2Point.PLUS_K,Double.NEGATIVE_INFINITY);
  }
  if (isFull()) {
    return new EnclosingBall<>(S2Point.PLUS_K,Double.POSITIVE_INFINITY);
  }
  final BSPTree<Sphere2D> root=getTree(false);
  if (isEmpty(root.getMinus()) && isFull(root.getPlus())) {
    final Circle circle=(Circle)root.getCut().getHyperplane();
    return new EnclosingBall<>(new S2Point(circle.getPole()).negate(),0.5 * FastMath.PI);
  }
  if (isFull(root.getMinus()) && isEmpty(root.getPlus())) {
    final Circle circle=(Circle)root.getCut().getHyperplane();
    return new EnclosingBall<>(new S2Point(circle.getPole()),0.5 * FastMath.PI);
  }
  final List<Cartesian3D> points=getInsidePoints();
  final List<Vertex> boundary=getBoundaryLoops();
  for (  final Vertex loopStart : boundary) {
    int count=0;
    for (Vertex v=loopStart; count == 0 || v != loopStart; v=v.getOutgoing().getEnd()) {
      ++count;
      points.add(v.getLocation().getVector());
    }
  }
  final SphereGenerator generator=new SphereGenerator();
  final WelzlEncloser<Euclidean3D,Cartesian3D> encloser=new WelzlEncloser<>(getTolerance(),generator);
  EnclosingBall<Euclidean3D,Cartesian3D> enclosing3D=encloser.enclose(points);
  final Cartesian3D[] support3D=enclosing3D.getSupport();
  final double r=enclosing3D.getRadius();
  final double h=enclosing3D.getCenter().getNorm();
  if (h < getTolerance()) {
    EnclosingBall<Sphere2D,S2Point> enclosingS2=new EnclosingBall<>(S2Point.PLUS_K,Double.POSITIVE_INFINITY);
    for (    Cartesian3D outsidePoint : getOutsidePoints()) {
      final S2Point outsideS2=new S2Point(outsidePoint);
      final BoundaryProjection<Sphere2D> projection=projectToBoundary(outsideS2);
      if (FastMath.PI - projection.getOffset() < enclosingS2.getRadius()) {
        enclosingS2=new EnclosingBall<>(outsideS2.negate(),FastMath.PI - projection.getOffset(),(S2Point)projection.getProjected());
      }
    }
    return enclosingS2;
  }
  final S2Point[] support=new S2Point[support3D.length];
  for (int i=0; i < support3D.length; ++i) {
    support[i]=new S2Point(support3D[i]);
  }
  final EnclosingBall<Sphere2D,S2Point> enclosingS2=new EnclosingBall<>(new S2Point(enclosing3D.getCenter()),FastMath.acos((1 + h * h - r * r) / (2 * h)),support);
  return enclosingS2;
}","/** 
 * Get a spherical cap enclosing the polygon. <p> This method is intended as a first test to quickly identify points that are guaranteed to be outside of the region, hence performing a full  {@link #checkPoint(org.apache.commons.math4.geometry.Point) checkPoint}only if the point status remains undecided after the quick check. It is is therefore mostly useful to speed up computation for small polygons with complex shapes (say a country boundary on Earth), as the spherical cap will be small and hence will reliably identify a large part of the sphere as outside, whereas the full check can be more computing intensive. A typical use case is therefore: </p> <pre>  {@code // compute region, plus an enclosing spherical cap SphericalPolygonsSet complexShape = ...; EnclosingBall<Sphere2D, S2Point> cap = complexShape.getEnclosingCap(); // check lots of points}for (Cartesian3D p : points)  final Location l; if (cap.contains(p)) { // we cannot be sure where the point is // we need to perform the full computation l = complexShape.checkPoint(v); } else { // no need to do further computation, // we already know the point is outside l = Location.OUTSIDE; } // use l ... } }</pre> <p> In the special cases of empty or whole sphere polygons, special spherical caps are returned, with angular radius set to negative or positive infinity so the   {@link EnclosingBall#contains(org.apache.commons.math4.geometry.Point) ball.contains(point)}method return always false or true. </p> <p> This method is <em>not</em> guaranteed to return the smallest enclosing cap. </p>
 * @return a spherical cap enclosing the polygon
 */
public EnclosingBall<Sphere2D,S2Point> getEnclosingCap(){
  if (isEmpty()) {
    return new EnclosingBall<>(S2Point.PLUS_K,Double.NEGATIVE_INFINITY);
  }
  if (isFull()) {
    return new EnclosingBall<>(S2Point.PLUS_K,Double.POSITIVE_INFINITY);
  }
  final BSPTree<Sphere2D> root=getTree(false);
  if (isEmpty(root.getMinus()) && isFull(root.getPlus())) {
    final Circle circle=(Circle)root.getCut().getHyperplane();
    return new EnclosingBall<>(new S2Point(circle.getPole()).negate(),0.5 * FastMath.PI);
  }
  if (isFull(root.getMinus()) && isEmpty(root.getPlus())) {
    final Circle circle=(Circle)root.getCut().getHyperplane();
    return new EnclosingBall<>(new S2Point(circle.getPole()),0.5 * FastMath.PI);
  }
  final List<Cartesian3D> points=getInsidePoints();
  final List<Vertex> boundary=getBoundaryLoops();
  for (  final Vertex loopStart : boundary) {
    int count=0;
    for (Vertex v=loopStart; count == 0 || v != loopStart; v=v.getOutgoing().getEnd()) {
      ++count;
      points.add(v.getLocation().getVector());
    }
  }
  final SphereGenerator generator=new SphereGenerator();
  final WelzlEncloser<Euclidean3D,Cartesian3D> encloser=new WelzlEncloser<>(getTolerance(),generator);
  EnclosingBall<Euclidean3D,Cartesian3D> enclosing3D=encloser.enclose(points);
  final Cartesian3D[] support3D=enclosing3D.getSupport();
  final double r=enclosing3D.getRadius();
  final double h=enclosing3D.getCenter().getNorm();
  if (h < getTolerance()) {
    EnclosingBall<Sphere2D,S2Point> enclosingS2=new EnclosingBall<>(S2Point.PLUS_K,Double.POSITIVE_INFINITY);
    for (    Cartesian3D outsidePoint : getOutsidePoints()) {
      final S2Point outsideS2=new S2Point(outsidePoint);
      final BoundaryProjection<Sphere2D> projection=projectToBoundary(outsideS2);
      if (FastMath.PI - projection.getOffset() < enclosingS2.getRadius()) {
        enclosingS2=new EnclosingBall<>(outsideS2.negate(),FastMath.PI - projection.getOffset(),(S2Point)projection.getProjected());
      }
    }
    return enclosingS2;
  }
  final S2Point[] support=new S2Point[support3D.length];
  for (int i=0; i < support3D.length; ++i) {
    support[i]=new S2Point(support3D[i]);
  }
  final EnclosingBall<Sphere2D,S2Point> enclosingS2=new EnclosingBall<>(new S2Point(enclosing3D.getCenter()),FastMath.acos((1 + h * h - r * r) / (2 * h)),support);
  return enclosingS2;
}"
57078,"/** 
 * Compute the <i>distance</i> between two rotations. <p>The <i>distance</i> is intended here as a way to check if two rotations are almost similar (i.e. they transform vectors the same way) or very different. It is mathematically defined as the angle of the rotation r that prepended to one of the rotations gives the other one:</p> <pre> r<sub>1</sub>(r) = r<sub>2</sub> </pre> <p>This distance is an angle between 0 and &pi;. Its value is the smallest possible upper bound of the angle in radians between r<sub>1</sub>(v) and r<sub>2</sub>(v) for all possible vectors v. This upper bound is reached for some v. The distance is equal to 0 if and only if the two rotations are identical.</p> <p>Comparing two rotations should always be done using this value rather than for example comparing the components of the quaternions. It is much more stable, and has a geometric meaning. Also comparing quaternions components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64) and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite their components are different (they are exact opposites).</p>
 * @param r1 first rotation
 * @param r2 second rotation
 * @param < T > the type of the field elements
 * @return <i>distance</i> between r1 and r2
 */
public static <T extends RealFieldElement<T>>T distance(final FieldRotation<T> r1,final FieldRotation<T> r2){
  return r1.composeInverseInternal(r2).getAngle();
}","/** 
 * Compute the <i>distance</i> between two rotations. <p>The <i>distance</i> is intended here as a way to check if two rotations are almost similar (i.e. they transform vectors the same way) or very different. It is mathematically defined as the angle of the rotation r that prepended to one of the rotations gives the other one:</p> <div style=""white-space: pre""><code> r<sub>1</sub>(r) = r<sub>2</sub> </code></div> <p>This distance is an angle between 0 and &pi;. Its value is the smallest possible upper bound of the angle in radians between r<sub>1</sub>(v) and r<sub>2</sub>(v) for all possible vectors v. This upper bound is reached for some v. The distance is equal to 0 if and only if the two rotations are identical.</p> <p>Comparing two rotations should always be done using this value rather than for example comparing the components of the quaternions. It is much more stable, and has a geometric meaning. Also comparing quaternions components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64) and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite their components are different (they are exact opposites).</p>
 * @param r1 first rotation
 * @param r2 second rotation
 * @param < T > the type of the field elements
 * @return <i>distance</i> between r1 and r2
 */
public static <T extends RealFieldElement<T>>T distance(final FieldRotation<T> r1,final FieldRotation<T> r2){
  return r1.composeInverseInternal(r2).getAngle();
}"
57079,"/** 
 * Compute the <i>distance</i> between two rotations. <p>The <i>distance</i> is intended here as a way to check if two rotations are almost similar (i.e. they transform vectors the same way) or very different. It is mathematically defined as the angle of the rotation r that prepended to one of the rotations gives the other one:</p> <pre> r<sub>1</sub>(r) = r<sub>2</sub> </pre> <p>This distance is an angle between 0 and &pi;. Its value is the smallest possible upper bound of the angle in radians between r<sub>1</sub>(v) and r<sub>2</sub>(v) for all possible vectors v. This upper bound is reached for some v. The distance is equal to 0 if and only if the two rotations are identical.</p> <p>Comparing two rotations should always be done using this value rather than for example comparing the components of the quaternions. It is much more stable, and has a geometric meaning. Also comparing quaternions components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64) and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite their components are different (they are exact opposites).</p>
 * @param r1 first rotation
 * @param r2 second rotation
 * @return <i>distance</i> between r1 and r2
 */
public static double distance(Rotation r1,Rotation r2){
  return r1.composeInverseInternal(r2).getAngle();
}","/** 
 * Compute the <i>distance</i> between two rotations. <p>The <i>distance</i> is intended here as a way to check if two rotations are almost similar (i.e. they transform vectors the same way) or very different. It is mathematically defined as the angle of the rotation r that prepended to one of the rotations gives the other one:</p> <div style=""white-space: pre""><code> r<sub>1</sub>(r) = r<sub>2</sub> </code></div> <p>This distance is an angle between 0 and &pi;. Its value is the smallest possible upper bound of the angle in radians between r<sub>1</sub>(v) and r<sub>2</sub>(v) for all possible vectors v. This upper bound is reached for some v. The distance is equal to 0 if and only if the two rotations are identical.</p> <p>Comparing two rotations should always be done using this value rather than for example comparing the components of the quaternions. It is much more stable, and has a geometric meaning. Also comparing quaternions components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64) and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite their components are different (they are exact opposites).</p>
 * @param r1 first rotation
 * @param r2 second rotation
 * @return <i>distance</i> between r1 and r2
 */
public static double distance(Rotation r1,Rotation r2){
  return r1.composeInverseInternal(r2).getAngle();
}"
57080,"/** 
 * Compute ln(a). Let f(x) = ln(x), We know that f'(x) = 1/x, thus from Taylor's theorem we have: -----          n+1         n f(x) =   \           (-1)    (x - 1) /          ----------------    for 1 <= n <= infinity -----             n or 2        3       4 (x-1)   (x-1)    (x-1) ln(x) =  (x-1) - ----- + ------ - ------ + ... 2       3        4 alternatively, 2    3   4 x    x   x ln(x+1) =  x - -  + - - - + ... 2    3   4 This series can be used to compute ln(x), but it converges too slowly. If we substitute -x for x above, we get 2    3    4 x    x    x ln(1-x) =  -x - -  - -  - - + ... 2    3    4 Note that all terms are now negative.  Because the even powered ones absorbed the sign.  Now, subtract the series above from the previous one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving only the odd ones 3     5      7 2x    2x     2x ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ... 3     5      7 By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have: 3        5        7 x+1           /          x        x        x          \ ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  | x-1           \          3        5        7          / But now we want to find ln(a), so we need to find the value of x such that a = (x+1)/(x-1).   This is easily solved to find that x = (a-1)/(a+1).
 * @param a number for which we want the exponential
 * @param one constant with value 1 at desired precision
 * @param two constant with value 2 at desired precision
 * @return ln(a)
 */
public static Dfp computeLn(final Dfp a,final Dfp one,final Dfp two){
  int den=1;
  Dfp x=a.add(new Dfp(a.getField(),-1)).divide(a.add(one));
  Dfp y=new Dfp(x);
  Dfp num=new Dfp(x);
  Dfp py=new Dfp(y);
  for (int i=0; i < 10000; i++) {
    num=num.multiply(x);
    num=num.multiply(x);
    den+=2;
    Dfp t=num.divide(den);
    y=y.add(t);
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y.multiply(two);
}","/** 
 * Compute ln(a). <pre>  {@code Let f(x) = ln(x), We know that f'(x) = 1/x, thus from Taylor's theorem we have: -----          n+1         n f(x) =   \           (-1)    (x - 1) /          ----------------    for 1 <= n <= infinity -----             n or 2        3       4 (x-1)   (x-1)    (x-1) ln(x) =  (x-1) - ----- + ------ - ------ + ... 2       3        4 alternatively, 2    3   4 x    x   x ln(x+1) =  x - -  + - - - + ... 2    3   4 This series can be used to compute ln(x), but it converges too slowly. If we substitute -x for x above, we get 2    3    4 x    x    x ln(1-x) =  -x - -  - -  - - + ... 2    3    4 Note that all terms are now negative.  Because the even powered ones absorbed the sign.  Now, subtract the series above from the previous one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving only the odd ones 3     5      7 2x    2x     2x ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ... 3     5      7 By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have: 3        5        7 x+1           /          x        x        x          \ ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  | x-1           \          3        5        7          / But now we want to find ln(a), so we need to find the value of x such that a = (x+1)/(x-1).   This is easily solved to find that x = (a-1)/(a+1).}</pre>
 * @param a number for which we want the exponential
 * @param one constant with value 1 at desired precision
 * @param two constant with value 2 at desired precision
 * @return ln(a)
 */
public static Dfp computeLn(final Dfp a,final Dfp one,final Dfp two){
  int den=1;
  Dfp x=a.add(new Dfp(a.getField(),-1)).divide(a.add(one));
  Dfp y=new Dfp(x);
  Dfp num=new Dfp(x);
  Dfp py=new Dfp(y);
  for (int i=0; i < 10000; i++) {
    num=num.multiply(x);
    num=num.multiply(x);
    den+=2;
    Dfp t=num.divide(den);
    y=y.add(t);
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y.multiply(two);
}"
57081,"/** 
 * Returns the natural logarithm of a. a is first split into three parts such that  a = (10000^h)(2^j)k. ln(a) is computed by ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k) k is in the range 2/3 < k <4/3 and is passed on to a series expansion.
 * @param a number from which logarithm is requested
 * @return log(a)
 */
public static Dfp log(Dfp a){
  int lr;
  Dfp x;
  int ix;
  int p2=0;
  if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {
    a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return a.dotrap(DfpField.FLAG_INVALID,""String_Node_Str"",a,a.newInstance((byte)1,Dfp.QNAN));
  }
  if (a.classify() == Dfp.INFINITE) {
    return a;
  }
  x=new Dfp(a);
  lr=x.log10K();
  x=x.divide(pow(a.newInstance(10000),lr));
  ix=x.floor().intValue();
  while (ix > 2) {
    ix>>=1;
    p2++;
  }
  Dfp[] spx=split(x);
  Dfp[] spy=new Dfp[2];
  spy[0]=pow(a.getTwo(),p2);
  spx[0]=spx[0].divide(spy[0]);
  spx[1]=spx[1].divide(spy[0]);
  spy[0]=a.newInstance(""String_Node_Str"");
  while (spx[0].add(spx[1]).greaterThan(spy[0])) {
    spx[0]=spx[0].divide(2);
    spx[1]=spx[1].divide(2);
    p2++;
  }
  Dfp[] spz=logInternal(spx);
  spx[0]=a.newInstance(new StringBuilder().append(p2 + 4 * lr).toString());
  spx[1]=a.getZero();
  spy=splitMult(a.getField().getLn2Split(),spx);
  spz[0]=spz[0].add(spy[0]);
  spz[1]=spz[1].add(spy[1]);
  spx[0]=a.newInstance(new StringBuilder().append(4 * lr).toString());
  spx[1]=a.getZero();
  spy=splitMult(a.getField().getLn5Split(),spx);
  spz[0]=spz[0].add(spy[0]);
  spz[1]=spz[1].add(spy[1]);
  return a.newInstance(spz[0].add(spz[1]));
}","/** 
 * Returns the natural logarithm of a. a is first split into three parts such that   {@code a = (10000^h)(2^j)k}. ln(a) is computed by   {@code ln(a) = ln(5)*h + ln(2)*(h+j) + ln(k)}. k is in the range   {@code 2/3 < k <4/3} and is passed on to a series expansion.
 * @param a number from which logarithm is requested
 * @return log(a)
 */
public static Dfp log(Dfp a){
  int lr;
  Dfp x;
  int ix;
  int p2=0;
  if (a.equals(a.getZero()) || a.lessThan(a.getZero()) || a.isNaN()) {
    a.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return a.dotrap(DfpField.FLAG_INVALID,""String_Node_Str"",a,a.newInstance((byte)1,Dfp.QNAN));
  }
  if (a.classify() == Dfp.INFINITE) {
    return a;
  }
  x=new Dfp(a);
  lr=x.log10K();
  x=x.divide(pow(a.newInstance(10000),lr));
  ix=x.floor().intValue();
  while (ix > 2) {
    ix>>=1;
    p2++;
  }
  Dfp[] spx=split(x);
  Dfp[] spy=new Dfp[2];
  spy[0]=pow(a.getTwo(),p2);
  spx[0]=spx[0].divide(spy[0]);
  spx[1]=spx[1].divide(spy[0]);
  spy[0]=a.newInstance(""String_Node_Str"");
  while (spx[0].add(spx[1]).greaterThan(spy[0])) {
    spx[0]=spx[0].divide(2);
    spx[1]=spx[1].divide(2);
    p2++;
  }
  Dfp[] spz=logInternal(spx);
  spx[0]=a.newInstance(new StringBuilder().append(p2 + 4 * lr).toString());
  spx[1]=a.getZero();
  spy=splitMult(a.getField().getLn2Split(),spx);
  spz[0]=spz[0].add(spy[0]);
  spz[1]=spz[1].add(spy[1]);
  spx[0]=a.newInstance(new StringBuilder().append(4 * lr).toString());
  spx[1]=a.getZero();
  spy=splitMult(a.getField().getLn5Split(),spx);
  spz[0]=spz[0].add(spy[0]);
  spz[1]=spz[1].add(spy[1]);
  return a.newInstance(spz[0].add(spz[1]));
}"
57082,"/** 
 * Computes cos(a)  Used when 0 < a < pi/4. Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...
 * @param a number from which cosine is desired, in split form
 * @return cos(a)
 */
protected static Dfp cosInternal(Dfp a[]){
  final Dfp one=a[0].getOne();
  Dfp x=one;
  Dfp y=one;
  Dfp c=a[0].add(a[1]);
  c=c.multiply(c);
  Dfp fact=one;
  Dfp py=new Dfp(y);
  for (int i=2; i < 90; i+=2) {
    x=x.multiply(c);
    x=x.negate();
    fact=fact.divide((i - 1) * i);
    y=y.add(x.multiply(fact));
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y;
}","/** 
 * Computes cos(a)  Used when   {@code 0 < a < pi/4}. Uses the classic Taylor series for cosine.  1 - x**2/2! + x**4/4!  ...
 * @param a number from which cosine is desired, in split form
 * @return cos(a)
 */
protected static Dfp cosInternal(Dfp a[]){
  final Dfp one=a[0].getOne();
  Dfp x=one;
  Dfp y=one;
  Dfp c=a[0].add(a[1]);
  c=c.multiply(c);
  Dfp fact=one;
  Dfp py=new Dfp(y);
  for (int i=2; i < 90; i+=2) {
    x=x.multiply(c);
    x=x.negate();
    fact=fact.divide((i - 1) * i);
    y=y.add(x.multiply(fact));
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y;
}"
57083,"/** 
 * Computes e to the given power. Where -1 < a < 1.  Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...
 * @param a power at which e should be raised
 * @return e<sup>a</sup>
 */
protected static Dfp expInternal(final Dfp a){
  Dfp y=a.getOne();
  Dfp x=a.getOne();
  Dfp fact=a.getOne();
  Dfp py=new Dfp(y);
  for (int i=1; i < 90; i++) {
    x=x.multiply(a);
    fact=fact.divide(i);
    y=y.add(x.multiply(fact));
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y;
}","/** 
 * Computes e to the given power. Where   {@code -1 < a < 1}.  Use the classic Taylor series.  {@code 1 + x**2/2! + x**3/3! + x**4/4!  ... }
 * @param a power at which e should be raised
 * @return e<sup>a</sup>
 */
protected static Dfp expInternal(final Dfp a){
  Dfp y=a.getOne();
  Dfp x=a.getOne();
  Dfp fact=a.getOne();
  Dfp py=new Dfp(y);
  for (int i=1; i < 90; i++) {
    x=x.multiply(a);
    fact=fact.divide(i);
    y=y.add(x.multiply(fact));
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y;
}"
57084,"/** 
 * Computes sin(a)  Used when 0 < a < pi/4. Uses the classic Taylor series.  x - x**3/3! + x**5/5!  ...
 * @param a number from which sine is desired, in split form
 * @return sin(a)
 */
protected static Dfp sinInternal(Dfp a[]){
  Dfp c=a[0].add(a[1]);
  Dfp y=c;
  c=c.multiply(c);
  Dfp x=y;
  Dfp fact=a[0].getOne();
  Dfp py=new Dfp(y);
  for (int i=3; i < 90; i+=2) {
    x=x.multiply(c);
    x=x.negate();
    fact=fact.divide((i - 1) * i);
    y=y.add(x.multiply(fact));
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y;
}","/** 
 * Computes sin(a)  Used when   {@code} {@code 0 < a < pi/4}}. Uses the classic Taylor series.    {@code x - x**3/3! + x**5/5!  ... }
 * @param a number from which sine is desired, in split form
 * @return sin(a)
 */
protected static Dfp sinInternal(Dfp a[]){
  Dfp c=a[0].add(a[1]);
  Dfp y=c;
  c=c.multiply(c);
  Dfp x=y;
  Dfp fact=a[0].getOne();
  Dfp py=new Dfp(y);
  for (int i=3; i < 90; i+=2) {
    x=x.multiply(c);
    x=x.negate();
    fact=fact.divide((i - 1) * i);
    y=y.add(x.multiply(fact));
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  return y;
}"
57085,"/** 
 * Computes the natural log of a number between 0 and 2. Let f(x) = ln(x), We know that f'(x) = 1/x, thus from Taylor's theorum we have: -----          n+1         n f(x) =   \           (-1)    (x - 1) /          ----------------    for 1 <= n <= infinity -----             n or 2        3       4 (x-1)   (x-1)    (x-1) ln(x) =  (x-1) - ----- + ------ - ------ + ... 2       3        4 alternatively, 2    3   4 x    x   x ln(x+1) =  x - -  + - - - + ... 2    3   4 This series can be used to compute ln(x), but it converges too slowly. If we substitute -x for x above, we get 2    3    4 x    x    x ln(1-x) =  -x - -  - -  - - + ... 2    3    4 Note that all terms are now negative.  Because the even powered ones absorbed the sign.  Now, subtract the series above from the previous one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving only the odd ones 3     5      7 2x    2x     2x ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ... 3     5      7 By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have: 3        5        7 x+1           /          x        x        x          \ ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  | x-1           \          3        5        7          / But now we want to find ln(a), so we need to find the value of x such that a = (x+1)/(x-1).   This is easily solved to find that x = (a-1)/(a+1).
 * @param a number from which logarithm is requested, in split form
 * @return log(a)
 */
protected static Dfp[] logInternal(final Dfp a[]){
  Dfp t=a[0].divide(4).add(a[1].divide(4));
  Dfp x=t.add(a[0].newInstance(""String_Node_Str"")).divide(t.add(a[0].newInstance(""String_Node_Str"")));
  Dfp y=new Dfp(x);
  Dfp num=new Dfp(x);
  Dfp py=new Dfp(y);
  int den=1;
  for (int i=0; i < 10000; i++) {
    num=num.multiply(x);
    num=num.multiply(x);
    den+=2;
    t=num.divide(den);
    y=y.add(t);
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  y=y.multiply(a[0].getTwo());
  return split(y);
}","/** 
 * Computes the natural log of a number between 0 and 2. <pre>  {@code Let f(x) = ln(x), We know that f'(x) = 1/x, thus from Taylor's theorum we have: -----          n+1         n f(x) =   \           (-1)    (x - 1) /          ----------------    for 1 <= n <= infinity -----             n or 2        3       4 (x-1)   (x-1)    (x-1) ln(x) =  (x-1) - ----- + ------ - ------ + ... 2       3        4 alternatively, 2    3   4 x    x   x ln(x+1) =  x - -  + - - - + ... 2    3   4 This series can be used to compute ln(x), but it converges too slowly. If we substitute -x for x above, we get 2    3    4 x    x    x ln(1-x) =  -x - -  - -  - - + ... 2    3    4 Note that all terms are now negative.  Because the even powered ones absorbed the sign.  Now, subtract the series above from the previous one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving only the odd ones 3     5      7 2x    2x     2x ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ... 3     5      7 By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have: 3        5        7 x+1           /          x        x        x          \ ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  | x-1           \          3        5        7          / But now we want to find ln(a), so we need to find the value of x such that a = (x+1)/(x-1).   This is easily solved to find that x = (a-1)/(a+1).}</pre>
 * @param a number from which logarithm is requested, in split form
 * @return log(a)
 */
protected static Dfp[] logInternal(final Dfp a[]){
  Dfp t=a[0].divide(4).add(a[1].divide(4));
  Dfp x=t.add(a[0].newInstance(""String_Node_Str"")).divide(t.add(a[0].newInstance(""String_Node_Str"")));
  Dfp y=new Dfp(x);
  Dfp num=new Dfp(x);
  Dfp py=new Dfp(y);
  int den=1;
  for (int i=0; i < 10000; i++) {
    num=num.multiply(x);
    num=num.multiply(x);
    den+=2;
    t=num.divide(den);
    y=y.add(t);
    if (y.equals(py)) {
      break;
    }
    py=new Dfp(y);
  }
  y=y.multiply(a[0].getTwo());
  return split(y);
}"
57086,"/** 
 * Computes x to the y power.<p> Uses the following method:<p> <ol> <li> Set u = rint(y), v = y-u <li> Compute a = v * ln(x) <li> Compute b = rint( a/ln(2) ) <li> Compute c = a - b*ln(2) <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup> </ol> if |y| > 1e8, then we compute by exp(y*ln(x))   <p> <b>Special Cases</b><p> <ul> <li>  if y is 0.0 or -0.0 then result is 1.0 <li>  if y is 1.0 then result is x <li>  if y is NaN then result is NaN <li>  if x is NaN and y is not zero then result is NaN <li>  if |x| > 1.0 and y is +Infinity then result is +Infinity <li>  if |x| < 1.0 and y is -Infinity then result is +Infinity <li>  if |x| > 1.0 and y is -Infinity then result is +0 <li>  if |x| < 1.0 and y is +Infinity then result is +0 <li>  if |x| = 1.0 and y is +/-Infinity then result is NaN <li>  if x = +0 and y > 0 then result is +0 <li>  if x = +Inf and y < 0 then result is +0 <li>  if x = +0 and y < 0 then result is +Inf <li>  if x = +Inf and y > 0 then result is +Inf <li>  if x = -0 and y > 0, finite, not odd integer then result is +0 <li>  if x = -0 and y < 0, finite, and odd integer then result is -Inf <li>  if x = -Inf and y > 0, finite, and odd integer then result is -Inf <li>  if x = -0 and y < 0, not finite odd integer then result is +Inf <li>  if x = -Inf and y > 0, not finite odd integer then result is +Inf <li>  if x < 0 and y > 0, finite, and odd integer then result is -(|x|<sup>y</sup>) <li>  if x < 0 and y > 0, finite, and not integer then result is NaN </ul>
 * @param x base to be raised
 * @param y power to which base should be raised
 * @return x<sup>y</sup>
 */
public static Dfp pow(Dfp x,final Dfp y){
  if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    final Dfp result=x.newInstance(x.getZero());
    result.nans=Dfp.QNAN;
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,result);
  }
  final Dfp zero=x.getZero();
  final Dfp one=x.getOne();
  final Dfp two=x.getTwo();
  boolean invert=false;
  int ui;
  if (y.equals(zero)) {
    return x.newInstance(one);
  }
  if (y.equals(one)) {
    if (x.isNaN()) {
      x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
      return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x);
    }
    return x;
  }
  if (x.isNaN() || y.isNaN()) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x.newInstance((byte)1,Dfp.QNAN));
  }
  if (x.equals(zero)) {
    if (Dfp.copysign(one,x).greaterThan(zero)) {
      if (y.greaterThan(zero)) {
        return x.newInstance(zero);
      }
 else {
        return x.newInstance(x.newInstance((byte)1,Dfp.INFINITE));
      }
    }
 else {
      if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {
        if (y.greaterThan(zero)) {
          return x.newInstance(zero.negate());
        }
 else {
          return x.newInstance(x.newInstance((byte)-1,Dfp.INFINITE));
        }
      }
 else {
        if (y.greaterThan(zero)) {
          return x.newInstance(zero);
        }
 else {
          return x.newInstance(x.newInstance((byte)1,Dfp.INFINITE));
        }
      }
    }
  }
  if (x.lessThan(zero)) {
    x=x.negate();
    invert=true;
  }
  if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {
    if (y.greaterThan(zero)) {
      return y;
    }
 else {
      return x.newInstance(zero);
    }
  }
  if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {
    if (y.greaterThan(zero)) {
      return x.newInstance(zero);
    }
 else {
      return x.newInstance(Dfp.copysign(y,one));
    }
  }
  if (x.equals(one) && y.classify() == Dfp.INFINITE) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x.newInstance((byte)1,Dfp.QNAN));
  }
  if (x.classify() == Dfp.INFINITE) {
    if (invert) {
      if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {
        if (y.greaterThan(zero)) {
          return x.newInstance(x.newInstance((byte)-1,Dfp.INFINITE));
        }
 else {
          return x.newInstance(zero.negate());
        }
      }
 else {
        if (y.greaterThan(zero)) {
          return x.newInstance(x.newInstance((byte)1,Dfp.INFINITE));
        }
 else {
          return x.newInstance(zero);
        }
      }
    }
 else {
      if (y.greaterThan(zero)) {
        return x;
      }
 else {
        return x.newInstance(zero);
      }
    }
  }
  if (invert && !y.rint().equals(y)) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x.newInstance((byte)1,Dfp.QNAN));
  }
  Dfp r;
  if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {
    final Dfp u=y.rint();
    ui=u.intValue();
    final Dfp v=y.subtract(u);
    if (v.unequal(zero)) {
      final Dfp a=v.multiply(log(x));
      final Dfp b=a.divide(x.getField().getLn2()).rint();
      final Dfp c=a.subtract(b.multiply(x.getField().getLn2()));
      r=splitPow(split(x),ui);
      r=r.multiply(pow(two,b.intValue()));
      r=r.multiply(exp(c));
    }
 else {
      r=splitPow(split(x),ui);
    }
  }
 else {
    r=exp(log(x).multiply(y));
  }
  if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) {
    r=r.negate();
  }
  return x.newInstance(r);
}","/** 
 * Computes x to the y power.<p> Uses the following method: <ol> <li> Set u = rint(y), v = y-u <li> Compute a = v * ln(x) <li> Compute b = rint( a/ln(2) ) <li> Compute c = a - b*ln(2) <li> x<sup>y</sup> = x<sup>u</sup>  *   2<sup>b</sup> * e<sup>c</sup> </ol> if   {@code |y| > 1e8}, then we compute by   {@code exp(y*ln(x))}<p> <b>Special Cases</b> <ul> <li>  if y is 0.0 or -0.0 then result is 1.0 <li>  if y is 1.0 then result is x <li>  if y is NaN then result is NaN <li>  if x is NaN and y is not zero then result is NaN <li>  if   {@code |x| > 1.0} and y is +Infinity then result is +Infinity<li>  if  {@code |x| < 1.0} and y is -Infinity then result is +Infinity<li>  if  {@code |x| > 1.0} and y is -Infinity then result is +0<li>  if  {@code |x| < 1.0} and y is +Infinity then result is +0<li>  if  {@code |x| = 1.0} and y is +/-Infinity then result is NaN<li>  if  {@code x = +0} and {@code y > 0} then result is +0<li>  if  {@code x = +Inf} and {@code y < 0} then result is +0<li>  if  {@code x = +0} and {@code y < 0} then result is +Inf<li>  if  {@code x = +Inf} and {@code y > 0} then result is +Inf<li>  if  {@code x = -0} and {@code y > 0}, finite, not odd integer then result is +0 <li>  if   {@code x = -0} and {@code y < 0}, finite, and odd integer then result is -Inf <li>  if   {@code x = -Inf} and {@code y > 0}, finite, and odd integer then result is -Inf <li>  if   {@code x = -0} and {@code y < 0}, not finite odd integer then result is +Inf <li>  if   {@code x = -Inf} and {@code y > 0}, not finite odd integer then result is +Inf <li>  if   {@code x < 0} and {@code y > 0}, finite, and odd integer then result is -(|x|<sup>y</sup>) <li>  if   {@code x < 0} and {@code y > 0}, finite, and not integer then result is NaN </ul>
 * @param x base to be raised
 * @param y power to which base should be raised
 * @return x<sup>y</sup>
 */
public static Dfp pow(Dfp x,final Dfp y){
  if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    final Dfp result=x.newInstance(x.getZero());
    result.nans=Dfp.QNAN;
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,result);
  }
  final Dfp zero=x.getZero();
  final Dfp one=x.getOne();
  final Dfp two=x.getTwo();
  boolean invert=false;
  int ui;
  if (y.equals(zero)) {
    return x.newInstance(one);
  }
  if (y.equals(one)) {
    if (x.isNaN()) {
      x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
      return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x);
    }
    return x;
  }
  if (x.isNaN() || y.isNaN()) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x.newInstance((byte)1,Dfp.QNAN));
  }
  if (x.equals(zero)) {
    if (Dfp.copysign(one,x).greaterThan(zero)) {
      if (y.greaterThan(zero)) {
        return x.newInstance(zero);
      }
 else {
        return x.newInstance(x.newInstance((byte)1,Dfp.INFINITE));
      }
    }
 else {
      if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {
        if (y.greaterThan(zero)) {
          return x.newInstance(zero.negate());
        }
 else {
          return x.newInstance(x.newInstance((byte)-1,Dfp.INFINITE));
        }
      }
 else {
        if (y.greaterThan(zero)) {
          return x.newInstance(zero);
        }
 else {
          return x.newInstance(x.newInstance((byte)1,Dfp.INFINITE));
        }
      }
    }
  }
  if (x.lessThan(zero)) {
    x=x.negate();
    invert=true;
  }
  if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) {
    if (y.greaterThan(zero)) {
      return y;
    }
 else {
      return x.newInstance(zero);
    }
  }
  if (x.lessThan(one) && y.classify() == Dfp.INFINITE) {
    if (y.greaterThan(zero)) {
      return x.newInstance(zero);
    }
 else {
      return x.newInstance(Dfp.copysign(y,one));
    }
  }
  if (x.equals(one) && y.classify() == Dfp.INFINITE) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x.newInstance((byte)1,Dfp.QNAN));
  }
  if (x.classify() == Dfp.INFINITE) {
    if (invert) {
      if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) {
        if (y.greaterThan(zero)) {
          return x.newInstance(x.newInstance((byte)-1,Dfp.INFINITE));
        }
 else {
          return x.newInstance(zero.negate());
        }
      }
 else {
        if (y.greaterThan(zero)) {
          return x.newInstance(x.newInstance((byte)1,Dfp.INFINITE));
        }
 else {
          return x.newInstance(zero);
        }
      }
    }
 else {
      if (y.greaterThan(zero)) {
        return x;
      }
 else {
        return x.newInstance(zero);
      }
    }
  }
  if (invert && !y.rint().equals(y)) {
    x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);
    return x.dotrap(DfpField.FLAG_INVALID,POW_TRAP,x,x.newInstance((byte)1,Dfp.QNAN));
  }
  Dfp r;
  if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) {
    final Dfp u=y.rint();
    ui=u.intValue();
    final Dfp v=y.subtract(u);
    if (v.unequal(zero)) {
      final Dfp a=v.multiply(log(x));
      final Dfp b=a.divide(x.getField().getLn2()).rint();
      final Dfp c=a.subtract(b.multiply(x.getField().getLn2()));
      r=splitPow(split(x),ui);
      r=r.multiply(pow(two,b.intValue()));
      r=r.multiply(exp(c));
    }
 else {
      r=splitPow(split(x),ui);
    }
  }
 else {
    r=exp(log(x).multiply(y));
  }
  if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) {
    r=r.negate();
  }
  return x.newInstance(r);
}"
57087,"/** 
 * Evolve the given population into the next generation. <ol> <li>Get nextGeneration population to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled:</li> <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each of the offspring</li><li>Add offspring individually to nextGeneration, space permitting</li> </ul> <li>Return nextGeneration</li> </ol>
 * @param current the current population.
 * @return the population for the next generation.
 */
public Population nextGeneration(final Population current){
  Population nextGeneration=current.nextGeneration();
  UniformRandomProvider randGen=getRandomGenerator();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (randGen.nextDouble() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (randGen.nextDouble() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}","/** 
 * Evolve the given population into the next generation. <ol> <li>Get nextGeneration population to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled: <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each of the offspring</li><li>Add offspring individually to nextGeneration, space permitting</li> </ul></li> <li>Return nextGeneration</li> </ol>
 * @param current the current population.
 * @return the population for the next generation.
 */
public Population nextGeneration(final Population current){
  Population nextGeneration=current.nextGeneration();
  UniformRandomProvider randGen=getRandomGenerator();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (randGen.nextDouble() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (randGen.nextDouble() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}"
57088,"/** 
 * Generates a representation of a permutation corresponding to a permutation which yields <code>permutedData</code> when applied to <code>originalData</code>. This method can be viewed as an inverse to   {@link #decode(List)}.
 * @param < S > type of the data
 * @param originalData the original, unpermuted data
 * @param permutedData the data, somehow permuted
 * @return representation of a permutation corresponding to the permutation<code>originalData -> permutedData</code>
 * @throws DimensionMismatchException iff the length of <code>originalData</code>and <code>permutedData</code> lists are not equal
 * @throws MathIllegalArgumentException iff the <code>permutedData</code> and<code>originalData</code> lists contain different data
 */
public static <S>List<Double> inducedPermutation(final List<S> originalData,final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException {
  if (originalData.size() != permutedData.size()) {
    throw new DimensionMismatchException(permutedData.size(),originalData.size());
  }
  int l=originalData.size();
  List<S> origDataCopy=new ArrayList<>(originalData);
  Double[] res=new Double[l];
  for (int i=0; i < l; i++) {
    int index=origDataCopy.indexOf(permutedData.get(i));
    if (index == -1) {
      throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_ORIG_AND_PERMUTED_DATA);
    }
    res[index]=(double)i / l;
    origDataCopy.set(index,null);
  }
  return Arrays.asList(res);
}","/** 
 * Generates a representation of a permutation corresponding to a permutation which yields <code>permutedData</code> when applied to <code>originalData</code>. This method can be viewed as an inverse to   {@link #decode(List)}.
 * @param < S > type of the data
 * @param originalData the original, unpermuted data
 * @param permutedData the data, somehow permuted
 * @return representation of a permutation corresponding to the permutation{@code originalData -> permutedData}
 * @throws DimensionMismatchException iff the length of <code>originalData</code>and <code>permutedData</code> lists are not equal
 * @throws MathIllegalArgumentException iff the <code>permutedData</code> and<code>originalData</code> lists contain different data
 */
public static <S>List<Double> inducedPermutation(final List<S> originalData,final List<S> permutedData) throws DimensionMismatchException, MathIllegalArgumentException {
  if (originalData.size() != permutedData.size()) {
    throw new DimensionMismatchException(permutedData.size(),originalData.size());
  }
  int l=originalData.size();
  List<S> origDataCopy=new ArrayList<>(originalData);
  Double[] res=new Double[l];
  for (int i=0; i < l; i++) {
    int index=origDataCopy.indexOf(permutedData.get(i));
    if (index == -1) {
      throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_ORIG_AND_PERMUTED_DATA);
    }
    res[index]=(double)i / l;
    origDataCopy.set(index,null);
  }
  return Arrays.asList(res);
}"
57089,"/** 
 * Computes the digamma function, defined as the logarithmic derivative of the \( \Gamma \) function: \( \frac{d}{dx}(\ln \Gamma(x)) = \frac{\Gamma^\prime(x)}{\Gamma(x)} \). <p>This is an independently written implementation of the algorithm described in Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976. A <a href=""https://en.wikipedia.org/wiki/Digamma_function#Reflection_formula""> reflection formula</a> is incorporated to improve performance on negative values.</p> <p>Some of the constants have been changed to increase accuracy at the moderate expense of run-time.  The result should be accurate to within \( 10^{-8} \) relative tolerance for \( 0 < x < 10^{-5} \) and within \( 10^{-8} \) absolute tolerance otherwise.</p>
 * @param x Argument.
 * @return digamma(x) to within \( 10^{-8} \) relative or absolute error whichever is larger.
 * @see <a href=""http://en.wikipedia.org/wiki/Digamma_function"">Digamma</a>
 * @see <a href=""http://www.uv.es/~bernardo/1976AppStatist.pdf"">Bernardo&apos;s original article</a>
 * @since 2.0
 */
public static double digamma(double x){
  if (Double.isNaN(x) || Double.isInfinite(x)) {
    return x;
  }
  double digamma=0.0;
  if (x < 0) {
    digamma-=FastMath.PI / FastMath.tan(FastMath.PI * x);
    x=1 - x;
  }
  if (x > 0 && x <= S_LIMIT) {
    return digamma - GAMMA - 1 / x;
  }
  while (x < C_LIMIT) {
    digamma-=1.0 / x;
    x+=1.0;
  }
  double inv=1 / (x * x);
  digamma+=FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));
  return digamma;
}","/** 
 * Computes the digamma function, defined as the logarithmic derivative of the \( \Gamma \) function: \( \frac{d}{dx}(\ln \Gamma(x)) = \frac{\Gamma^\prime(x)}{\Gamma(x)} \). <p>This is an independently written implementation of the algorithm described in Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976. A <a href=""https://en.wikipedia.org/wiki/Digamma_function#Reflection_formula""> reflection formula</a> is incorporated to improve performance on negative values.</p> <p>Some of the constants have been changed to increase accuracy at the moderate expense of run-time.  The result should be accurate to within \( 10^{-8} \) relative tolerance for \( 0 \le x \le 10^{-5} \) and within \( 10^{-8} \) absolute tolerance otherwise.</p>
 * @param x Argument.
 * @return digamma(x) to within \( 10^{-8} \) relative or absolute error whichever is larger.
 * @see <a href=""http://en.wikipedia.org/wiki/Digamma_function"">Digamma</a>
 * @see <a href=""http://www.uv.es/~bernardo/1976AppStatist.pdf"">Bernardo's original article</a>
 * @since 2.0
 */
public static double digamma(double x){
  if (Double.isNaN(x) || Double.isInfinite(x)) {
    return x;
  }
  double digamma=0.0;
  if (x < 0) {
    digamma-=FastMath.PI / FastMath.tan(FastMath.PI * x);
    x=1 - x;
  }
  if (x > 0 && x <= S_LIMIT) {
    return digamma - GAMMA - 1 / x;
  }
  while (x < C_LIMIT) {
    digamma-=1.0 / x;
    x+=1.0;
  }
  double inv=1 / (x * x);
  digamma+=FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));
  return digamma;
}"
57090,"/** 
 * Returns the <i>observed significance level</i>, or <a href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue"">p-value</a>, associated with a <a href=""http://en.wikipedia.org/wiki/Binomial_test""> Binomial test</a>. <p> The number returned is the smallest significance level at which one can reject the null hypothesis. The form of the hypothesis depends on   {@code alternativeHypothesis}.</p> <p> The p-Value represents the likelihood of getting a result at least as extreme as the sample, given the provided   {@code probability} of success on a single trial. For single-sided tests,this value can be directly derived from the Binomial distribution. For the two-sided test, the implementation works as follows: we start by looking at the most extreme cases (0 success and n success where n is the number of trials from the sample) and determine their likelihood. The lower value is added to the p-Value (if both values are equal, both are added). Then we continue with the next extreme value, until we added the value for the actual observed sample.</p> <p> <strong>Preconditions</strong>: <ul> <li>Number of trials must be &ge; 0.</li> <li>Number of successes must be &ge; 0.</li> <li>Number of successes must be &le; number of trials.</li> <li>Probability must be &ge; 0 and &le; 1.</li> </ul>
 * @param numberOfTrials number of trials performed
 * @param numberOfSuccesses number of successes observed
 * @param probability assumed probability of a single trial under the null hypothesis
 * @param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)
 * @return p-value
 * @throws NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative
 * @throws OutOfRangeException if {@code probability} is not between 0 and 1
 * @throws MathIllegalArgumentException if {@code numberOfTrials} &lt; {@code numberOfSuccesses} orif  {@code alternateHypothesis} is null.
 * @see AlternativeHypothesis
 */
public double binomialTest(int numberOfTrials,int numberOfSuccesses,double probability,AlternativeHypothesis alternativeHypothesis){
  if (numberOfTrials < 0) {
    throw new NotPositiveException(numberOfTrials);
  }
  if (numberOfSuccesses < 0) {
    throw new NotPositiveException(numberOfSuccesses);
  }
  if (probability < 0 || probability > 1) {
    throw new OutOfRangeException(probability,0,1);
  }
  if (numberOfTrials < numberOfSuccesses) {
    throw new MathIllegalArgumentException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,numberOfTrials,numberOfSuccesses);
  }
  if (alternativeHypothesis == null) {
    throw new NullArgumentException();
  }
  final BinomialDistribution distribution=new BinomialDistribution(numberOfTrials,probability);
switch (alternativeHypothesis) {
case GREATER_THAN:
    return 1 - distribution.cumulativeProbability(numberOfSuccesses - 1);
case LESS_THAN:
  return distribution.cumulativeProbability(numberOfSuccesses);
case TWO_SIDED:
int criticalValueLow=0;
int criticalValueHigh=numberOfTrials;
double pTotal=0;
while (true) {
double pLow=distribution.probability(criticalValueLow);
double pHigh=distribution.probability(criticalValueHigh);
if (pLow == pHigh) {
pTotal+=2 * pLow;
criticalValueLow++;
criticalValueHigh--;
}
 else if (pLow < pHigh) {
pTotal+=pLow;
criticalValueLow++;
}
 else {
pTotal+=pHigh;
criticalValueHigh--;
}
if (criticalValueLow > numberOfSuccesses || criticalValueHigh < numberOfSuccesses) {
break;
}
}
return pTotal;
default :
throw new MathInternalError(LocalizedFormats.OUT_OF_RANGE_SIMPLE,alternativeHypothesis,AlternativeHypothesis.TWO_SIDED,AlternativeHypothesis.LESS_THAN);
}
}","/** 
 * Returns the <i>observed significance level</i>, or <a href=""http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue"">p-value</a>, associated with a <a href=""http://en.wikipedia.org/wiki/Binomial_test""> Binomial test</a>. <p> The number returned is the smallest significance level at which one can reject the null hypothesis. The form of the hypothesis depends on   {@code alternativeHypothesis}.</p> <p> The p-Value represents the likelihood of getting a result at least as extreme as the sample, given the provided   {@code probability} of success on a single trial. For single-sided tests,this value can be directly derived from the Binomial distribution. For the two-sided test, the implementation works as follows: we start by looking at the most extreme cases (0 success and n success where n is the number of trials from the sample) and determine their likelihood. The lower value is added to the p-Value (if both values are equal, both are added). Then we continue with the next extreme value, until we added the value for the actual observed sample.</p> <p> <strong>Preconditions</strong>: <ul> <li>Number of trials must be &ge; 0.</li> <li>Number of successes must be &ge; 0.</li> <li>Number of successes must be &le; number of trials.</li> <li>Probability must be &ge; 0 and &le; 1.</li> </ul>
 * @param numberOfTrials number of trials performed
 * @param numberOfSuccesses number of successes observed
 * @param probability assumed probability of a single trial under the null hypothesis
 * @param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)
 * @return p-value
 * @throws NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative
 * @throws OutOfRangeException if {@code probability} is not between 0 and 1
 * @throws MathIllegalArgumentException if {@code numberOfTrials} &lt; {@code numberOfSuccesses} orif  {@code alternateHypothesis} is null.
 * @see AlternativeHypothesis
 */
public double binomialTest(int numberOfTrials,int numberOfSuccesses,double probability,AlternativeHypothesis alternativeHypothesis){
  if (numberOfTrials < 0) {
    throw new NotPositiveException(numberOfTrials);
  }
  if (numberOfSuccesses < 0) {
    throw new NotPositiveException(numberOfSuccesses);
  }
  if (probability < 0 || probability > 1) {
    throw new OutOfRangeException(probability,0,1);
  }
  if (numberOfTrials < numberOfSuccesses) {
    throw new MathIllegalArgumentException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,numberOfTrials,numberOfSuccesses);
  }
  if (alternativeHypothesis == null) {
    throw new NullArgumentException();
  }
  final BinomialDistribution distribution=new BinomialDistribution(numberOfTrials,probability);
switch (alternativeHypothesis) {
case GREATER_THAN:
    return 1 - distribution.cumulativeProbability(numberOfSuccesses - 1);
case LESS_THAN:
  return distribution.cumulativeProbability(numberOfSuccesses);
case TWO_SIDED:
int criticalValueLow=0;
int criticalValueHigh=numberOfTrials;
double pTotal=0;
while (true) {
double pLow=distribution.probability(criticalValueLow);
double pHigh=distribution.probability(criticalValueHigh);
if (pLow == pHigh) {
if (criticalValueLow == criticalValueHigh) {
pTotal+=pLow;
}
 else {
pTotal+=2 * pLow;
}
criticalValueLow++;
criticalValueHigh--;
}
 else if (pLow < pHigh) {
pTotal+=pLow;
criticalValueLow++;
}
 else {
pTotal+=pHigh;
criticalValueHigh--;
}
if (criticalValueLow > numberOfSuccesses || criticalValueHigh < numberOfSuccesses) {
break;
}
}
return pTotal;
default :
throw new MathInternalError(LocalizedFormats.OUT_OF_RANGE_SIMPLE,alternativeHypothesis,AlternativeHypothesis.TWO_SIDED,AlternativeHypothesis.LESS_THAN);
}
}"
57091,"@Test public void testBinomialTestPValues(){
  Assert.assertEquals(0.04375,testStatistic.binomialTest(trials,successes,probability,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.02654,testStatistic.binomialTest(trials,successes,probability,AlternativeHypothesis.GREATER_THAN),1E-4);
  Assert.assertEquals(0.982,testStatistic.binomialTest(trials,successes,probability,AlternativeHypothesis.LESS_THAN),1E-4);
}","@Test public void testBinomialTestPValues(){
  Assert.assertEquals(0.04375,testStatistic.binomialTest(trials,successes,probability,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.02654,testStatistic.binomialTest(trials,successes,probability,AlternativeHypothesis.GREATER_THAN),1E-4);
  Assert.assertEquals(0.982,testStatistic.binomialTest(trials,successes,probability,AlternativeHypothesis.LESS_THAN),1E-4);
  Assert.assertEquals(1,testStatistic.binomialTest(3,3,1,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(1,testStatistic.binomialTest(3,3,0.9,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(1,testStatistic.binomialTest(3,3,0.8,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.559,testStatistic.binomialTest(3,3,0.7,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.28,testStatistic.binomialTest(3,3,0.6,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.25,testStatistic.binomialTest(3,3,0.5,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.064,testStatistic.binomialTest(3,3,0.4,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.027,testStatistic.binomialTest(3,3,0.3,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.008,testStatistic.binomialTest(3,3,0.2,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.001,testStatistic.binomialTest(3,3,0.1,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0,testStatistic.binomialTest(3,3,0.0,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0,testStatistic.binomialTest(3,0,1,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.001,testStatistic.binomialTest(3,0,0.9,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.008,testStatistic.binomialTest(3,0,0.8,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.027,testStatistic.binomialTest(3,0,0.7,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.064,testStatistic.binomialTest(3,0,0.6,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.25,testStatistic.binomialTest(3,0,0.5,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.28,testStatistic.binomialTest(3,0,0.4,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(0.559,testStatistic.binomialTest(3,0,0.3,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(1,testStatistic.binomialTest(3,0,0.2,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(1,testStatistic.binomialTest(3,0,0.1,AlternativeHypothesis.TWO_SIDED),1E-4);
  Assert.assertEquals(1,testStatistic.binomialTest(3,0,0.0,AlternativeHypothesis.TWO_SIDED),1E-4);
}"
57092,"/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    private final DiscreteSampler sampler=new InverseTransformDiscreteSampler(rng,createICPF());
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    /** 
 * Inversion method distribution sampler.
 */
    private final DiscreteSampler sampler=new InverseTransformDiscreteSampler(rng,createICPF());
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}"
57093,"/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new InverseTransformContinuousSampler(rng,createICPF());
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Inversion method distribution sampler.
 */
    private final ContinuousSampler sampler=new InverseTransformContinuousSampler(rng,createICPF());
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57094,"/** 
 * {@inheritDoc}Sampling is performed using Cheng's algorithm: <blockquote> <pre> R. C. H. Cheng, ""Generating beta variates with nonintegral shape parameters"", Communications of the ACM, 21, 317-322, 1978. </pre> </blockquote>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new ChengBetaSampler(rng,alpha,beta);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc}Sampling is performed using Cheng's algorithm: <blockquote> <pre> R. C. H. Cheng, ""Generating beta variates with nonintegral shape parameters"", Communications of the ACM, 21, 317-322, 1978. </pre> </blockquote>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Beta distribution sampler.
 */
    private final ContinuousSampler sampler=new ChengBetaSampler(rng,alpha,beta);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57095,"/** 
 * {@inheritDoc}<p>Sampling algorithm uses the <a href=""http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html""> inversion method</a> to generate exponentially distributed random values from uniform deviates. </p>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new AhrensDieterExponentialSampler(rng,mean);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc}<p>Sampling algorithm uses the <a href=""http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html""> inversion method</a> to generate exponentially distributed random values from uniform deviates. </p>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Exponential distribution sampler.
 */
    private final ContinuousSampler sampler=new AhrensDieterExponentialSampler(rng,mean);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57096,"/** 
 * {@inheritDoc}<p> Sampling algorithms: <ul> <li> For   {@code 0 < shape < 1}: <blockquote> Ahrens, J. H. and Dieter, U., <i>Computer methods for sampling from gamma, beta, Poisson and binomial distributions,</i> Computing, 12, 223-246, 1974. </blockquote> </li> <li> For   {@code shape >= 1}: <blockquote> Marsaglia and Tsang, <i>A Simple Method for Generating Gamma Variables.</i> ACM Transactions on Mathematical Software, Volume 26 Issue 3, September, 2000. </blockquote> </li> </ul>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new AhrensDieterMarsagliaTsangGammaSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc}<p> Sampling algorithms: <ul> <li> For   {@code 0 < shape < 1}: <blockquote> Ahrens, J. H. and Dieter, U., <i>Computer methods for sampling from gamma, beta, Poisson and binomial distributions,</i> Computing, 12, 223-246, 1974. </blockquote> </li> <li> For   {@code shape >= 1}: <blockquote> Marsaglia and Tsang, <i>A Simple Method for Generating Gamma Variables.</i> ACM Transactions on Mathematical Software, Volume 26 Issue 3, September, 2000. </blockquote> </li> </ul>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Gamma distribution sampler.
 */
    private final ContinuousSampler sampler=new AhrensDieterMarsagliaTsangGammaSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57097,"/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new MarsagliaLogNormalSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Log normal distribution sampler.
 */
    private final ContinuousSampler sampler=new MarsagliaLogNormalSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57098,"/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new GaussianSampler(new MarsagliaNormalizedGaussianSampler(rng),mean,standardDeviation);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Gaussian distribution sampler.
 */
    private final ContinuousSampler sampler=new GaussianSampler(new MarsagliaNormalizedGaussianSampler(rng),mean,standardDeviation);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57099,"/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new InverseTransformParetoSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Pareto distribution sampler.
 */
    private final ContinuousSampler sampler=new InverseTransformParetoSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57100,"/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    private final DiscreteSampler sampler=new PoissonSampler(rng,mean);
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    /** 
 * Poisson distribution sampler.
 */
    private final DiscreteSampler sampler=new PoissonSampler(rng,mean);
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}"
57101,"/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    private final DiscreteSampler sampler=new DiscreteUniformSampler(rng,lower,upper);
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    /** 
 * Discrete uniform distribution sampler.
 */
    private final DiscreteSampler sampler=new DiscreteUniformSampler(rng,lower,upper);
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}"
57102,"/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new ContinuousUniformSampler(rng,lower,upper);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    /** 
 * Uniform distribution sampler.
 */
    private final ContinuousSampler sampler=new ContinuousUniformSampler(rng,lower,upper);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57103,"/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    private final DiscreteSampler sampler=new RejectionInversionZipfSampler(rng,numberOfElements,exponent);
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc} 
 */
@Override public IntegerDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new IntegerDistribution.Sampler(){
    /** 
 * Zipf distribution sampler.
 */
    private final DiscreteSampler sampler=new RejectionInversionZipfSampler(rng,numberOfElements,exponent);
    /** 
 * {@inheritDoc} 
 */
    @Override public int sample(){
      return sampler.sample();
    }
  }
;
}"
57104,"/** 
 * <p> Computes the   {@code n}-th roots of unity. The roots are stored in  {@code omega[]}, such that   {@code omega[k] = w ^ k}, where  {@code k = 0, ..., n - 1},   {@code w = exp(2 * pi * i / n)} and{@code i = sqrt(-1)}. </p> <p> Note that   {@code n} can be positive of negative</p> <ul> <li> {@code abs(n)} is always the number of roots of unity.</li><li>If  {@code n > 0}, then the roots are stored in counter-clockwise order.</li> <li>If   {@code n < 0}, then the roots are stored in clockwise order.</p> </ul>
 * @param n the (signed) number of roots of unity to be computed
 * @throws ZeroException if {@code n = 0}
 */
public synchronized void computeRoots(int n) throws ZeroException {
  if (n == 0) {
    throw new ZeroException(LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY);
  }
  isCounterClockWise=n > 0;
  final int absN=FastMath.abs(n);
  if (absN == omegaCount) {
    return;
  }
  final double t=2.0 * FastMath.PI / absN;
  final double cosT=FastMath.cos(t);
  final double sinT=FastMath.sin(t);
  omegaReal=new double[absN];
  omegaImaginaryCounterClockwise=new double[absN];
  omegaImaginaryClockwise=new double[absN];
  omegaReal[0]=1.0;
  omegaImaginaryCounterClockwise[0]=0.0;
  omegaImaginaryClockwise[0]=0.0;
  for (int i=1; i < absN; i++) {
    omegaReal[i]=omegaReal[i - 1] * cosT - omegaImaginaryCounterClockwise[i - 1] * sinT;
    omegaImaginaryCounterClockwise[i]=omegaReal[i - 1] * sinT + omegaImaginaryCounterClockwise[i - 1] * cosT;
    omegaImaginaryClockwise[i]=-omegaImaginaryCounterClockwise[i];
  }
  omegaCount=absN;
}","/** 
 * <p> Computes the   {@code n}-th roots of unity. The roots are stored in  {@code omega[]}, such that   {@code omega[k] = w ^ k}, where  {@code k = 0, ..., n - 1},   {@code w = exp(2 * pi * i / n)} and{@code i = sqrt(-1)}. </p> <p> Note that   {@code n} can be positive of negative</p> <ul> <li> {@code abs(n)} is always the number of roots of unity.</li><li>If  {@code n > 0}, then the roots are stored in counter-clockwise order.</li> <li>If   {@code n < 0}, then the roots are stored in clockwise order. </ul>
 * @param n the (signed) number of roots of unity to be computed
 * @throws ZeroException if {@code n = 0}
 */
public synchronized void computeRoots(int n) throws ZeroException {
  if (n == 0) {
    throw new ZeroException(LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY);
  }
  isCounterClockWise=n > 0;
  final int absN=FastMath.abs(n);
  if (absN == omegaCount) {
    return;
  }
  final double t=2.0 * FastMath.PI / absN;
  final double cosT=FastMath.cos(t);
  final double sinT=FastMath.sin(t);
  omegaReal=new double[absN];
  omegaImaginaryCounterClockwise=new double[absN];
  omegaImaginaryClockwise=new double[absN];
  omegaReal[0]=1.0;
  omegaImaginaryCounterClockwise[0]=0.0;
  omegaImaginaryClockwise[0]=0.0;
  for (int i=1; i < absN; i++) {
    omegaReal[i]=omegaReal[i - 1] * cosT - omegaImaginaryCounterClockwise[i - 1] * sinT;
    omegaImaginaryCounterClockwise[i]=omegaReal[i - 1] * sinT + omegaImaginaryCounterClockwise[i - 1] * cosT;
    omegaImaginaryClockwise[i]=-omegaImaginaryCounterClockwise[i];
  }
  omegaCount=absN;
}"
57105,"/** 
 * {@inheritDoc}<p>Returns the kernel density normalized so that its integral over each bin equals the bin mass.</p> <p>Algorithm description: <ol> <li>Find the bin B that x belongs to.</li> <li>Compute K(B) = the mass of B with respect to the within-bin kernel (i.e., the integral of the kernel density over B).</li> <li>Return k(x) * P(B) / K(B), where k is the within-bin kernel density and P(B) is the mass of B.</li></ol></p>
 * @since 3.1
 */
@Override public double density(double x){
  if (x < min || x > max) {
    return 0d;
  }
  final int binIndex=findBin(x);
  final RealDistribution kernel=getKernel(binStats.get(binIndex));
  return kernel.density(x) * pB(binIndex) / kB(binIndex);
}","/** 
 * {@inheritDoc}<p>Returns the kernel density normalized so that its integral over each bin equals the bin mass.</p> <p>Algorithm description: <ol> <li>Find the bin B that x belongs to.</li> <li>Compute K(B) = the mass of B with respect to the within-bin kernel (i.e., the integral of the kernel density over B).</li> <li>Return k(x) * P(B) / K(B), where k is the within-bin kernel density and P(B) is the mass of B.</li></ol>
 * @since 3.1
 */
@Override public double density(double x){
  if (x < min || x > max) {
    return 0d;
  }
  final int binIndex=findBin(x);
  final RealDistribution kernel=getKernel(binStats.get(binIndex));
  return kernel.density(x) * pB(binIndex) / kB(binIndex);
}"
57106,"/** 
 * {@inheritDoc}<p>Algorithm description:<ol> <li>Find the smallest i such that the sum of the masses of the bins through i is at least p.</li> <li> Let K be the within-bin kernel distribution for bin i.</br> Let K(B) be the mass of B under K. <br/> Let K(B-) be K evaluated at the lower endpoint of B (the combined mass of the bins below B under K).<br/> Let P(B) be the probability of bin i.<br/> Let P(B-) be the sum of the bin masses below bin i. <br/> Let pCrit = p - P(B-)<br/> <li>Return the inverse of K evaluated at <br/> K(B-) + pCrit * K(B) / P(B) </li> </ol></p>
 * @since 3.1
 */
@Override public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
  if (p < 0.0 || p > 1.0) {
    throw new OutOfRangeException(p,0,1);
  }
  if (p == 0.0) {
    return getSupportLowerBound();
  }
  if (p == 1.0) {
    return getSupportUpperBound();
  }
  int i=0;
  while (cumBinP(i) < p) {
    i++;
  }
  final RealDistribution kernel=getKernel(binStats.get(i));
  final double kB=kB(i);
  final double[] binBounds=getUpperBounds();
  final double lower=i == 0 ? min : binBounds[i - 1];
  final double kBminus=kernel.cumulativeProbability(lower);
  final double pB=pB(i);
  final double pBminus=pBminus(i);
  final double pCrit=p - pBminus;
  if (pCrit <= 0) {
    return lower;
  }
  return kernel.inverseCumulativeProbability(kBminus + pCrit * kB / pB);
}","/** 
 * {@inheritDoc}<p>Algorithm description:<ol> <li>Find the smallest i such that the sum of the masses of the bins through i is at least p.</li> <li> Let K be the within-bin kernel distribution for bin i.<br> Let K(B) be the mass of B under K. <br> Let K(B-) be K evaluated at the lower endpoint of B (the combined mass of the bins below B under K).<br> Let P(B) be the probability of bin i.<br> Let P(B-) be the sum of the bin masses below bin i. <br> Let pCrit = p - P(B-)<br> <li>Return the inverse of K evaluated at <br> K(B-) + pCrit * K(B) / P(B) </li> </ol>
 * @since 3.1
 */
@Override public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
  if (p < 0.0 || p > 1.0) {
    throw new OutOfRangeException(p,0,1);
  }
  if (p == 0.0) {
    return getSupportLowerBound();
  }
  if (p == 1.0) {
    return getSupportUpperBound();
  }
  int i=0;
  while (cumBinP(i) < p) {
    i++;
  }
  final RealDistribution kernel=getKernel(binStats.get(i));
  final double kB=kB(i);
  final double[] binBounds=getUpperBounds();
  final double lower=i == 0 ? min : binBounds[i - 1];
  final double kBminus=kernel.cumulativeProbability(lower);
  final double pB=pB(i);
  final double pBminus=pBminus(i);
  final double pCrit=p - pBminus;
  if (pCrit <= 0) {
    return lower;
  }
  return kernel.inverseCumulativeProbability(kBminus + pCrit * kB / pB);
}"
57107,"/** 
 * <p>Returns a fresh copy of the array of upper bounds for the bins. Bins are: <br/> [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],..., (upperBounds[binCount-2], upperBounds[binCount-1] = max].</p> <p>Note: In versions 1.0-2.0 of commons-math, this method incorrectly returned the array of probability generator upper bounds now returned by   {@link #getGeneratorUpperBounds()}.</p>
 * @return array of bin upper bounds
 * @since 2.1
 */
public double[] getUpperBounds(){
  double[] binUpperBounds=new double[binCount];
  for (int i=0; i < binCount - 1; i++) {
    binUpperBounds[i]=min + delta * (i + 1);
  }
  binUpperBounds[binCount - 1]=max;
  return binUpperBounds;
}","/** 
 * <p>Returns a fresh copy of the array of upper bounds for the bins. Bins are: <br> [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],..., (upperBounds[binCount-2], upperBounds[binCount-1] = max].</p> <p>Note: In versions 1.0-2.0 of commons-math, this method incorrectly returned the array of probability generator upper bounds now returned by   {@link #getGeneratorUpperBounds()}.</p>
 * @return array of bin upper bounds
 * @since 2.1
 */
public double[] getUpperBounds(){
  double[] binUpperBounds=new double[binCount];
  for (int i=0; i < binCount - 1; i++) {
    binUpperBounds[i]=min + delta * (i + 1);
  }
  binUpperBounds[binCount - 1]=max;
  return binUpperBounds;
}"
57108,"/** 
 * {@inheritDoc}<p> Sampling algorithms: <ul> <li> For   {@code 0 < shape < 1}: <blockquote> Ahrens, J. H. and Dieter, U., <i>Computer methods for sampling from gamma, beta, Poisson and binomial distributions,</i> Computing, 12, 223-246, 1974. </blockquote> </li> <li> For   {@code shape >= 1}: <blockquote> Marsaglia and Tsang, <i>A Simple Method for Generating Gamma Variables.</i> ACM Transactions on Mathematical Software, Volume 26 Issue 3, September, 2000. </blockquote> </li> </ul> </p>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new AhrensDieterMarsagliaTsangGammaSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}","/** 
 * {@inheritDoc}<p> Sampling algorithms: <ul> <li> For   {@code 0 < shape < 1}: <blockquote> Ahrens, J. H. and Dieter, U., <i>Computer methods for sampling from gamma, beta, Poisson and binomial distributions,</i> Computing, 12, 223-246, 1974. </blockquote> </li> <li> For   {@code shape >= 1}: <blockquote> Marsaglia and Tsang, <i>A Simple Method for Generating Gamma Variables.</i> ACM Transactions on Mathematical Software, Volume 26 Issue 3, September, 2000. </blockquote> </li> </ul>
 */
@Override public RealDistribution.Sampler createSampler(final UniformRandomProvider rng){
  return new RealDistribution.Sampler(){
    private final ContinuousSampler sampler=new AhrensDieterMarsagliaTsangGammaSampler(rng,scale,shape);
    /** 
 * {@inheritDoc} 
 */
    @Override public double sample(){
      return sampler.sample();
    }
  }
;
}"
57109,"/** 
 * Solve the linear least squares problem Jx=r.
 * @param jacobian  the Jacobian matrix, J. the number of rows >= the number orcolumns.
 * @param residuals the computed residuals, r.
 * @return the solution x, to the linear least squares problem Jx=r.
 * @throws ConvergenceException if the matrix properties (e.g. singular) do notpermit a solution.
 */
protected abstract RealVector solve(RealMatrix jacobian,RealVector residuals);","/** 
 * Solve the linear least squares problem Jx=r.
 * @param jacobian  the Jacobian matrix, J. the number of rows &gt;= the number orcolumns.
 * @param residuals the computed residuals, r.
 * @return the solution x, to the linear least squares problem Jx=r.
 * @throws ConvergenceException if the matrix properties (e.g. singular) do notpermit a solution.
 */
protected abstract RealVector solve(RealMatrix jacobian,RealVector residuals);"
57110,"/** 
 * {@inheritDoc}
 * @param point
 */
@Override public Evaluation evaluate(final RealVector point){
  return problem.evaluate(point);
}","/** 
 * {@inheritDoc}
 */
@Override public Evaluation evaluate(final RealVector point){
  return problem.evaluate(point);
}"
57111,"/** 
 * Configure the convergence checker. <p/> This function is an overloaded version of   {@link #checker(ConvergenceChecker)}.
 * @param newChecker the convergence checker.
 * @return this
 */
public LeastSquaresBuilder checkerPair(final ConvergenceChecker<PointVectorValuePair> newChecker){
  return this.checker(LeastSquaresFactory.evaluationChecker(newChecker));
}","/** 
 * Configure the convergence checker. <p> This function is an overloaded version of   {@link #checker(ConvergenceChecker)}.
 * @param newChecker the convergence checker.
 * @return this
 */
public LeastSquaresBuilder checkerPair(final ConvergenceChecker<PointVectorValuePair> newChecker){
  return this.checker(LeastSquaresFactory.evaluationChecker(newChecker));
}"
57112,"/** 
 * Get the covariance matrix of the optimized parameters. <br/> Note that this operation involves the inversion of the <code>J<sup>T</sup>J</code> matrix, where   {@code J} is the Jacobian matrix. The {@code threshold} parameter is away for the caller to specify that the result of this computation should be considered meaningless, and thus trigger an exception.
 * @param threshold Singularity threshold.
 * @return the covariance matrix.
 * @throws org.apache.commons.math4.linear.SingularMatrixException if the covariance matrix cannot be computed (singular problem).
 */
RealMatrix getCovariances(double threshold);","/** 
 * Get the covariance matrix of the optimized parameters. <br> Note that this operation involves the inversion of the <code>J<sup>T</sup>J</code> matrix, where   {@code J} is the Jacobian matrix. The {@code threshold} parameter is away for the caller to specify that the result of this computation should be considered meaningless, and thus trigger an exception.
 * @param threshold Singularity threshold.
 * @return the covariance matrix.
 * @throws org.apache.commons.math4.linear.SingularMatrixException if the covariance matrix cannot be computed (singular problem).
 */
RealMatrix getCovariances(double threshold);"
57113,"/** 
 * Evolve the given population into the next generation. <p> <ol> <li>Get nextGeneration population to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled:</li> <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each of the offspring</li><li>Add offspring individually to nextGeneration, space permitting</li> </ul> <li>Return nextGeneration</li> </ol>
 * @param current the current population.
 * @return the population for the next generation.
 */
public Population nextGeneration(final Population current){
  Population nextGeneration=current.nextGeneration();
  UniformRandomProvider randGen=getRandomGenerator();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (randGen.nextDouble() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (randGen.nextDouble() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}","/** 
 * Evolve the given population into the next generation. <ol> <li>Get nextGeneration population to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled:</li> <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each of the offspring</li><li>Add offspring individually to nextGeneration, space permitting</li> </ul> <li>Return nextGeneration</li> </ol>
 * @param current the current population.
 * @return the population for the next generation.
 */
public Population nextGeneration(final Population current){
  Population nextGeneration=current.nextGeneration();
  UniformRandomProvider randGen=getRandomGenerator();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (randGen.nextDouble() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (randGen.nextDouble() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}"
57114,"/** 
 * <p>Loads model x and y sample data from a flat input array, overriding any previous sample. </p> <p>Assumes that rows are concatenated with y values first in each row.  For example, an input <code>data</code> array containing the sequence of values (1, 2, 3, 4, 5, 6, 7, 8, 9) with <code>nobs = 3</code> and <code>nvars = 2</code> creates a regression dataset with two independent variables, as below: <pre> y   x[0]  x[1] -------------- 1     2     3 4     5     6 7     8     9 </pre> </p> <p>Note that there is no need to add an initial unitary column (column of 1's) when specifying a model including an intercept term.  If   {@link #isNoIntercept()} is <code>true</code>,the X matrix will be created without an initial column of ""1""s; otherwise this column will be added. </p> <p>Throws IllegalArgumentException if any of the following preconditions fail: <ul><li><code>data</code> cannot be null</li> <li><code>data.length = nobs * (nvars + 1)</code></li> <li><code>nobs > nvars</code></li></ul>
 * @param data input data array
 * @param nobs number of observations (rows)
 * @param nvars number of independent variables (columns, not counting y)
 * @throws NullArgumentException if the data array is null
 * @throws DimensionMismatchException if the length of the data array is not equalto <code>nobs * (nvars + 1)</code>
 * @throws InsufficientDataException if <code>nobs</code> is less than<code>nvars + 1</code>
 */
public void newSampleData(double[] data,int nobs,int nvars){
  if (data == null) {
    throw new NullArgumentException();
  }
  if (data.length != nobs * (nvars + 1)) {
    throw new DimensionMismatchException(data.length,nobs * (nvars + 1));
  }
  if (nobs <= nvars) {
    throw new InsufficientDataException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,nobs,nvars + 1);
  }
  double[] y=new double[nobs];
  final int cols=noIntercept ? nvars : nvars + 1;
  double[][] x=new double[nobs][cols];
  int pointer=0;
  for (int i=0; i < nobs; i++) {
    y[i]=data[pointer++];
    if (!noIntercept) {
      x[i][0]=1.0d;
    }
    for (int j=noIntercept ? 0 : 1; j < cols; j++) {
      x[i][j]=data[pointer++];
    }
  }
  this.xMatrix=new Array2DRowRealMatrix(x);
  this.yVector=new ArrayRealVector(y);
}","/** 
 * <p>Loads model x and y sample data from a flat input array, overriding any previous sample. </p> <p>Assumes that rows are concatenated with y values first in each row.  For example, an input <code>data</code> array containing the sequence of values (1, 2, 3, 4, 5, 6, 7, 8, 9) with <code>nobs = 3</code> and <code>nvars = 2</code> creates a regression dataset with two independent variables, as below: <pre> y   x[0]  x[1] -------------- 1     2     3 4     5     6 7     8     9 </pre> <p>Note that there is no need to add an initial unitary column (column of 1's) when specifying a model including an intercept term.  If   {@link #isNoIntercept()} is <code>true</code>,the X matrix will be created without an initial column of ""1""s; otherwise this column will be added. </p> <p>Throws IllegalArgumentException if any of the following preconditions fail: <ul><li><code>data</code> cannot be null</li> <li><code>data.length = nobs * (nvars + 1)</code></li> <li> {@code nobs > nvars}</li></ul>
 * @param data input data array
 * @param nobs number of observations (rows)
 * @param nvars number of independent variables (columns, not counting y)
 * @throws NullArgumentException if the data array is null
 * @throws DimensionMismatchException if the length of the data array is not equalto <code>nobs * (nvars + 1)</code>
 * @throws InsufficientDataException if <code>nobs</code> is less than<code>nvars + 1</code>
 */
public void newSampleData(double[] data,int nobs,int nvars){
  if (data == null) {
    throw new NullArgumentException();
  }
  if (data.length != nobs * (nvars + 1)) {
    throw new DimensionMismatchException(data.length,nobs * (nvars + 1));
  }
  if (nobs <= nvars) {
    throw new InsufficientDataException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,nobs,nvars + 1);
  }
  double[] y=new double[nobs];
  final int cols=noIntercept ? nvars : nvars + 1;
  double[][] x=new double[nobs][cols];
  int pointer=0;
  for (int i=0; i < nobs; i++) {
    y[i]=data[pointer++];
    if (!noIntercept) {
      x[i][0]=1.0d;
    }
    for (int j=noIntercept ? 0 : 1; j < cols; j++) {
      x[i][j]=data[pointer++];
    }
  }
  this.xMatrix=new Array2DRowRealMatrix(x);
  this.yVector=new ArrayRealVector(y);
}"
57115,"/** 
 * In the original algorithm only the partial correlations of the regressors is returned to the user. In this implementation, we have <pre> corr = { corrxx - lower triangular corrxy - bottom row of the matrix } Replaces subroutines PCORR and COR of: ALGORITHM AS274  APPL. STATIST. (1992) VOL.41, NO. 2 </pre> <p>Calculate partial correlations after the variables in rows 1, 2, ..., IN have been forced into the regression. If IN = 1, and the first row of R represents a constant in the model, then the usual simple correlations are returned.</p> <p>If IN = 0, the value returned in array CORMAT for the correlation of variables Xi & Xj is: <pre> sum ( Xi.Xj ) / Sqrt ( sum (Xi^2) . sum (Xj^2) )</pre> <p>On return, array CORMAT contains the upper triangle of the matrix of partial correlations stored by rows, excluding the 1's on the diagonal. e.g. if IN = 2, the consecutive elements returned are: (3,4) (3,5) ... (3,ncol), (4,5) (4,6) ... (4,ncol), etc. Array YCORR stores the partial correlations with the Y-variable starting with YCORR(IN+1) = partial correlation with the variable in position (IN+1). </p>
 * @param in how many of the regressors to include (either in canonicalorder, or in the current reordered state)
 * @return an array with the partial correlations of the remainder ofregressors with each other and the regressand, in lower triangular form
 */
public double[] getPartialCorrelations(int in){
  final double[] output=new double[(nvars - in + 1) * (nvars - in) / 2];
  int pos;
  int pos1;
  int pos2;
  final int rms_off=-in;
  final int wrk_off=-(in + 1);
  final double[] rms=new double[nvars - in];
  final double[] work=new double[nvars - in - 1];
  double sumxx;
  double sumxy;
  double sumyy;
  final int offXX=(nvars - in) * (nvars - in - 1) / 2;
  if (in < -1 || in >= nvars) {
    return null;
  }
  final int nvm=nvars - 1;
  final int base_pos=r.length - (nvm - in) * (nvm - in + 1) / 2;
  if (d[in] > 0.0) {
    rms[in + rms_off]=1.0 / FastMath.sqrt(d[in]);
  }
  for (int col=in + 1; col < nvars; col++) {
    pos=base_pos + col - 1 - in;
    sumxx=d[col];
    for (int row=in; row < col; row++) {
      sumxx+=d[row] * r[pos] * r[pos];
      pos+=nvars - row - 2;
    }
    if (sumxx > 0.0) {
      rms[col + rms_off]=1.0 / FastMath.sqrt(sumxx);
    }
 else {
      rms[col + rms_off]=0.0;
    }
  }
  sumyy=sserr;
  for (int row=in; row < nvars; row++) {
    sumyy+=d[row] * rhs[row] * rhs[row];
  }
  if (sumyy > 0.0) {
    sumyy=1.0 / FastMath.sqrt(sumyy);
  }
  pos=0;
  for (int col1=in; col1 < nvars; col1++) {
    sumxy=0.0;
    Arrays.fill(work,0.0);
    pos1=base_pos + col1 - in - 1;
    for (int row=in; row < col1; row++) {
      pos2=pos1 + 1;
      for (int col2=col1 + 1; col2 < nvars; col2++) {
        work[col2 + wrk_off]+=d[row] * r[pos1] * r[pos2];
        pos2++;
      }
      sumxy+=d[row] * r[pos1] * rhs[row];
      pos1+=nvars - row - 2;
    }
    pos2=pos1 + 1;
    for (int col2=col1 + 1; col2 < nvars; col2++) {
      work[col2 + wrk_off]+=d[col1] * r[pos2];
      ++pos2;
      output[(col2 - 1 - in) * (col2 - in) / 2 + col1 - in]=work[col2 + wrk_off] * rms[col1 + rms_off] * rms[col2 + rms_off];
      ++pos;
    }
    sumxy+=d[col1] * rhs[col1];
    output[col1 + rms_off + offXX]=sumxy * rms[col1 + rms_off] * sumyy;
  }
  return output;
}","/** 
 * In the original algorithm only the partial correlations of the regressors is returned to the user. In this implementation, we have <pre> corr = { corrxx - lower triangular corrxy - bottom row of the matrix } Replaces subroutines PCORR and COR of: ALGORITHM AS274  APPL. STATIST. (1992) VOL.41, NO. 2 </pre> <p>Calculate partial correlations after the variables in rows 1, 2, ..., IN have been forced into the regression. If IN = 1, and the first row of R represents a constant in the model, then the usual simple correlations are returned.</p> <p>If IN = 0, the value returned in array CORMAT for the correlation of variables Xi &amp; Xj is: <pre> sum ( Xi.Xj ) / Sqrt ( sum (Xi^2) . sum (Xj^2) )</pre> <p>On return, array CORMAT contains the upper triangle of the matrix of partial correlations stored by rows, excluding the 1's on the diagonal. e.g. if IN = 2, the consecutive elements returned are: (3,4) (3,5) ... (3,ncol), (4,5) (4,6) ... (4,ncol), etc. Array YCORR stores the partial correlations with the Y-variable starting with YCORR(IN+1) = partial correlation with the variable in position (IN+1). </p>
 * @param in how many of the regressors to include (either in canonicalorder, or in the current reordered state)
 * @return an array with the partial correlations of the remainder ofregressors with each other and the regressand, in lower triangular form
 */
public double[] getPartialCorrelations(int in){
  final double[] output=new double[(nvars - in + 1) * (nvars - in) / 2];
  int pos;
  int pos1;
  int pos2;
  final int rms_off=-in;
  final int wrk_off=-(in + 1);
  final double[] rms=new double[nvars - in];
  final double[] work=new double[nvars - in - 1];
  double sumxx;
  double sumxy;
  double sumyy;
  final int offXX=(nvars - in) * (nvars - in - 1) / 2;
  if (in < -1 || in >= nvars) {
    return null;
  }
  final int nvm=nvars - 1;
  final int base_pos=r.length - (nvm - in) * (nvm - in + 1) / 2;
  if (d[in] > 0.0) {
    rms[in + rms_off]=1.0 / FastMath.sqrt(d[in]);
  }
  for (int col=in + 1; col < nvars; col++) {
    pos=base_pos + col - 1 - in;
    sumxx=d[col];
    for (int row=in; row < col; row++) {
      sumxx+=d[row] * r[pos] * r[pos];
      pos+=nvars - row - 2;
    }
    if (sumxx > 0.0) {
      rms[col + rms_off]=1.0 / FastMath.sqrt(sumxx);
    }
 else {
      rms[col + rms_off]=0.0;
    }
  }
  sumyy=sserr;
  for (int row=in; row < nvars; row++) {
    sumyy+=d[row] * rhs[row] * rhs[row];
  }
  if (sumyy > 0.0) {
    sumyy=1.0 / FastMath.sqrt(sumyy);
  }
  pos=0;
  for (int col1=in; col1 < nvars; col1++) {
    sumxy=0.0;
    Arrays.fill(work,0.0);
    pos1=base_pos + col1 - in - 1;
    for (int row=in; row < col1; row++) {
      pos2=pos1 + 1;
      for (int col2=col1 + 1; col2 < nvars; col2++) {
        work[col2 + wrk_off]+=d[row] * r[pos1] * r[pos2];
        pos2++;
      }
      sumxy+=d[row] * r[pos1] * rhs[row];
      pos1+=nvars - row - 2;
    }
    pos2=pos1 + 1;
    for (int col2=col1 + 1; col2 < nvars; col2++) {
      work[col2 + wrk_off]+=d[col1] * r[pos2];
      ++pos2;
      output[(col2 - 1 - in) * (col2 - in) / 2 + col1 - in]=work[col2 + wrk_off] * rms[col1 + rms_off] * rms[col2 + rms_off];
      ++pos;
    }
    sumxy+=d[col1] * rhs[col1];
    output[col1 + rms_off + offXX]=sumxy * rms[col1 + rms_off] * sumyy;
  }
  return output;
}"
57116,"/** 
 * Returns the R-Squared statistic, defined by the formula <pre> R<sup>2</sup> = 1 - SSR / SSTO </pre> where SSR is the   {@link #calculateResidualSumOfSquares() sum of squared residuals}and SSTO is the   {@link #calculateTotalSumOfSquares() total sum of squares}<p>If there is no variance in y, i.e., SSTO = 0, NaN is returned.</p>
 * @return R-square statistic
 * @throws NullPointerException if the sample has not been set
 * @throws org.apache.commons.math4.linear.SingularMatrixException if the design matrix is singular
 * @since 2.2
 */
public double calculateRSquared(){
  return 1 - calculateResidualSumOfSquares() / calculateTotalSumOfSquares();
}","/** 
 * Returns the R-Squared statistic, defined by the formula <div style=""white-space: pre""><code> R<sup>2</sup> = 1 - SSR / SSTO </code></div> where SSR is the   {@link #calculateResidualSumOfSquares() sum of squared residuals}and SSTO is the   {@link #calculateTotalSumOfSquares() total sum of squares}<p>If there is no variance in y, i.e., SSTO = 0, NaN is returned.</p>
 * @return R-square statistic
 * @throws NullPointerException if the sample has not been set
 * @throws org.apache.commons.math4.linear.SingularMatrixException if the design matrix is singular
 * @since 2.2
 */
public double calculateRSquared(){
  return 1 - calculateResidualSumOfSquares() / calculateTotalSumOfSquares();
}"
57117,"/** 
 * <p>Returns the adjusted R-squared statistic, defined by the formula <pre> R<sup>2</sup><sub>adj</sub> = 1 - [SSR (n - 1)] / [SSTO (n - p)] </pre> where SSR is the   {@link #calculateResidualSumOfSquares() sum of squared residuals}, SSTO is the   {@link #calculateTotalSumOfSquares() total sum of squares}, n is the number of observations and p is the number of parameters estimated (including the intercept).</p> <p>If the regression is estimated without an intercept term, what is returned is <pre> <code> 1 - (1 -   {@link #calculateRSquared()}) * (n / (n - p)) </code> </pre> <p>If there is no variance in y, i.e., SSTO = 0, NaN is returned.</p>
 * @return adjusted R-Squared statistic
 * @throws NullPointerException if the sample has not been set
 * @throws org.apache.commons.math4.linear.SingularMatrixException if the design matrix is singular
 * @see #isNoIntercept()
 * @since 2.2
 */
public double calculateAdjustedRSquared(){
  final double n=getX().getRowDimension();
  if (isNoIntercept()) {
    return 1 - (1 - calculateRSquared()) * (n / (n - getX().getColumnDimension()));
  }
 else {
    return 1 - (calculateResidualSumOfSquares() * (n - 1)) / (calculateTotalSumOfSquares() * (n - getX().getColumnDimension()));
  }
}","/** 
 * <p>Returns the adjusted R-squared statistic, defined by the formula <div style=""white-space: pre""><code> R<sup>2</sup><sub>adj</sub> = 1 - [SSR (n - 1)] / [SSTO (n - p)] </code></div> where SSR is the   {@link #calculateResidualSumOfSquares() sum of squared residuals}, SSTO is the   {@link #calculateTotalSumOfSquares() total sum of squares}, n is the number of observations and p is the number of parameters estimated (including the intercept). <p>If the regression is estimated without an intercept term, what is returned is <pre> <code> 1 - (1 -   {@link #calculateRSquared()}) * (n / (n - p)) </code> </pre> <p>If there is no variance in y, i.e., SSTO = 0, NaN is returned.</p>
 * @return adjusted R-Squared statistic
 * @throws NullPointerException if the sample has not been set
 * @throws org.apache.commons.math4.linear.SingularMatrixException if the design matrix is singular
 * @see #isNoIntercept()
 * @since 2.2
 */
public double calculateAdjustedRSquared(){
  final double n=getX().getRowDimension();
  if (isNoIntercept()) {
    return 1 - (1 - calculateRSquared()) * (n / (n - getX().getColumnDimension()));
  }
 else {
    return 1 - (calculateResidualSumOfSquares() * (n - 1)) / (calculateTotalSumOfSquares() * (n - getX().getColumnDimension()));
  }
}"
57118,"/** 
 * <p>Returns the adjusted R-squared statistic, defined by the formula <pre> R<sup>2</sup><sub>adj</sub> = 1 - [SSR (n - 1)] / [SSTO (n - p)] </pre> where SSR is the sum of squared residuals}, SSTO is the total sum of squares}, n is the number of observations and p is the number of parameters estimated (including the intercept).</p> <p>If the regression is estimated without an intercept term, what is returned is <pre> <code> 1 - (1 -   {@link #getRSquared()} ) * (n / (n - p)) </code></pre>
 * @return adjusted R-Squared statistic
 */
public double getAdjustedRSquared(){
  return this.globalFitInfo[ADJRSQ_IDX];
}","/** 
 * <p>Returns the adjusted R-squared statistic, defined by the formula <div style=""white-space: pre""><code> R<sup>2</sup><sub>adj</sub> = 1 - [SSR (n - 1)] / [SSTO (n - p)] </code></div> where SSR is the sum of squared residuals}, SSTO is the total sum of squares}, n is the number of observations and p is the number of parameters estimated (including the intercept). <p>If the regression is estimated without an intercept term, what is returned is <pre> <code> 1 - (1 -   {@link #getRSquared()} ) * (n / (n - p)) </code></pre>
 * @return adjusted R-Squared statistic
 */
public double getAdjustedRSquared(){
  return this.globalFitInfo[ADJRSQ_IDX];
}"
57119,"/** 
 * Returns the significance level of the slope (equiv) correlation. <p> Specifically, the returned value is the smallest <code>alpha</code> such that the slope confidence interval with significance level equal to <code>alpha</code> does not include <code>0</code>. On regression output, this is often denoted <code>Prob(|t| > 0)</code> </p><p> <strong>Usage Note</strong>:<br> The validity of this statistic depends on the assumption that the observations included in the model are drawn from a <a href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a>.</p> <p> If there are fewer that <strong>three</strong> observations in the model, or if there is no variation in x, this returns <code>Double.NaN</code>.</p>
 * @return significance level for slope/correlation
 * @throws org.apache.commons.math4.exception.MaxCountExceededException if the significance level can not be computed.
 */
public double getSignificance(){
  if (n < 3) {
    return Double.NaN;
  }
  TDistribution distribution=new TDistribution(n - 2);
  return 2d * (1.0 - distribution.cumulativeProbability(FastMath.abs(getSlope()) / getSlopeStdErr()));
}","/** 
 * Returns the significance level of the slope (equiv) correlation. <p> Specifically, the returned value is the smallest <code>alpha</code> such that the slope confidence interval with significance level equal to <code>alpha</code> does not include <code>0</code>. On regression output, this is often denoted   {@code Prob(|t| > 0)}</p><p> <strong>Usage Note</strong>:<br> The validity of this statistic depends on the assumption that the observations included in the model are drawn from a <a href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a>.</p> <p> If there are fewer that <strong>three</strong> observations in the model, or if there is no variation in x, this returns <code>Double.NaN</code>.</p>
 * @return significance level for slope/correlation
 * @throws org.apache.commons.math4.exception.MaxCountExceededException if the significance level can not be computed.
 */
public double getSignificance(){
  if (n < 3) {
    return Double.NaN;
  }
  TDistribution distribution=new TDistribution(n - 2);
  return 2d * (1.0 - distribution.cumulativeProbability(FastMath.abs(getSlope()) / getSlopeStdErr()));
}"
57120,"/** 
 * Returns the sum of squared deviations of the y values about their mean. <p> This is defined as SSTO <a href=""http://www.xycoon.com/SumOfSquares.htm"">here</a>.</p> <p> If <code>n < 2</code>, this returns <code>Double.NaN</code>.</p>
 * @return sum of squared deviations of y values
 */
public double getTotalSumSquares(){
  if (n < 2) {
    return Double.NaN;
  }
  return sumYY;
}","/** 
 * Returns the sum of squared deviations of the y values about their mean. <p> This is defined as SSTO <a href=""http://www.xycoon.com/SumOfSquares.htm"">here</a>.</p> <p> If   {@code n < 2}, this returns <code>Double.NaN</code>.</p>
 * @return sum of squared deviations of y values
 */
public double getTotalSumSquares(){
  if (n < 2) {
    return Double.NaN;
  }
  return sumYY;
}"
57121,"/** 
 * Returns the half-width of a (100-100*alpha)% confidence interval for the slope estimate. <p> The (100-100*alpha)% confidence interval is </p> <p> <code>(getSlope() - getSlopeConfidenceInterval(), getSlope() + getSlopeConfidenceInterval())</code></p> <p> To request, for example, a 99% confidence interval, use <code>alpha = .01</code></p> <p> <strong>Usage Note</strong>:<br> The validity of this statistic depends on the assumption that the observations included in the model are drawn from a <a href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a>.</p> <p> <strong> Preconditions:</strong><ul> <li>If there are fewer that <strong>three</strong> observations in the model, or if there is no variation in x, this returns <code>Double.NaN</code>. </li> <li><code>(0 < alpha < 1)</code>; otherwise an <code>OutOfRangeException</code> is thrown. </li></ul>
 * @param alpha the desired significance level
 * @return half-width of 95% confidence interval for the slope estimate
 * @throws OutOfRangeException if the confidence interval can not be computed.
 */
public double getSlopeConfidenceInterval(final double alpha) throws OutOfRangeException {
  if (n < 3) {
    return Double.NaN;
  }
  if (alpha >= 1 || alpha <= 0) {
    throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,alpha,0,1);
  }
  TDistribution distribution=new TDistribution(n - 2);
  return getSlopeStdErr() * distribution.inverseCumulativeProbability(1d - alpha / 2d);
}","/** 
 * Returns the half-width of a (100-100*alpha)% confidence interval for the slope estimate. <p> The (100-100*alpha)% confidence interval is </p> <p> <code>(getSlope() - getSlopeConfidenceInterval(), getSlope() + getSlopeConfidenceInterval())</code></p> <p> To request, for example, a 99% confidence interval, use <code>alpha = .01</code></p> <p> <strong>Usage Note</strong>:<br> The validity of this statistic depends on the assumption that the observations included in the model are drawn from a <a href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a>.</p> <p> <strong> Preconditions:</strong><ul> <li>If there are fewer that <strong>three</strong> observations in the model, or if there is no variation in x, this returns <code>Double.NaN</code>. </li> <li>  {@code (0 < alpha < 1)}; otherwise an <code>OutOfRangeException</code> is thrown. </li></ul>
 * @param alpha the desired significance level
 * @return half-width of 95% confidence interval for the slope estimate
 * @throws OutOfRangeException if the confidence interval can not be computed.
 */
public double getSlopeConfidenceInterval(final double alpha) throws OutOfRangeException {
  if (n < 3) {
    return Double.NaN;
  }
  if (alpha >= 1 || alpha <= 0) {
    throw new OutOfRangeException(LocalizedFormats.SIGNIFICANCE_LEVEL,alpha,0,1);
  }
  TDistribution distribution=new TDistribution(n - 2);
  return getSlopeStdErr() * distribution.inverseCumulativeProbability(1d - alpha / 2d);
}"
57122,"/** 
 * This is a utility function used by   {@link #inverseCumulativeProbability(double)}. It assumes   {@code 0 < p < 1} andthat the inverse cumulative probability lies in the bracket  {@code (lower, upper]}. The implementation does simple bisection to find the smallest   {@code p}-quantile <code>inf{x in Z | P(X<=x) >= p}</code>.
 * @param p the cumulative probability
 * @param lower a value satisfying {@code cumulativeProbability(lower) < p}
 * @param upper a value satisfying {@code p <= cumulativeProbability(upper)}
 * @return the smallest {@code p}-quantile of this distribution
 */
protected int solveInverseCumulativeProbability(final double p,int lower,int upper){
  while (lower + 1 < upper) {
    int xm=(lower + upper) / 2;
    if (xm < lower || xm > upper) {
      xm=lower + (upper - lower) / 2;
    }
    double pm=checkedCumulativeProbability(xm);
    if (pm >= p) {
      upper=xm;
    }
 else {
      lower=xm;
    }
  }
  return upper;
}","/** 
 * This is a utility function used by   {@link #inverseCumulativeProbability(double)}. It assumes   {@code 0 < p < 1} andthat the inverse cumulative probability lies in the bracket  {@code (lower, upper]}. The implementation does simple bisection to find the smallest   {@code p}-quantile   {@code} infx in Z | P(X<=x) >= p}}.
 * @param p the cumulative probability
 * @param lower a value satisfying {@code cumulativeProbability(lower) < p}
 * @param upper a value satisfying {@code p <= cumulativeProbability(upper)}
 * @return the smallest {@code p}-quantile of this distribution
 */
protected int solveInverseCumulativeProbability(final double p,int lower,int upper){
  while (lower + 1 < upper) {
    int xm=(lower + upper) / 2;
    if (xm < lower || xm > upper) {
      xm=lower + (upper - lower) / 2;
    }
    double pm=checkedCumulativeProbability(xm);
    if (pm >= p) {
      upper=xm;
    }
 else {
      lower=xm;
    }
  }
  return upper;
}"
57123,"/** 
 * {@inheritDoc}<p>Algorithm description:<ol> <li>Find the bin B that x belongs to.</li> <li>Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B.</li> <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel and K(B-) = the kernel distribution evaluated at the lower endpoint of B</li> <li>Return P(B-) + P(B) * [K(x) - K(B-)] / K(B) where K(x) is the within-bin kernel distribution function evaluated at x.</li></ol> If K is a constant distribution, we return P(B-) + P(B) (counting the full mass of B).</p>
 * @since 3.1
 */
@Override public double cumulativeProbability(double x){
  if (x < min) {
    return 0d;
  }
 else   if (x >= max) {
    return 1d;
  }
  final int binIndex=findBin(x);
  final double pBminus=pBminus(binIndex);
  final double pB=pB(binIndex);
  final RealDistribution kernel=k(x);
  if (kernel instanceof ConstantRealDistribution) {
    if (x < kernel.getNumericalMean()) {
      return pBminus;
    }
 else {
      return pBminus + pB;
    }
  }
  final double[] binBounds=getUpperBounds();
  final double kB=kB(binIndex);
  final double lower=binIndex == 0 ? min : binBounds[binIndex - 1];
  final double withinBinCum=(kernel.cumulativeProbability(x) - kernel.cumulativeProbability(lower)) / kB;
  return pBminus + pB * withinBinCum;
}","/** 
 * {@inheritDoc}<p>Algorithm description:<ol> <li>Find the bin B that x belongs to.</li> <li>Compute P(B) = the mass of B and P(B-) = the combined mass of the bins below B.</li> <li>Compute K(B) = the probability mass of B with respect to the within-bin kernel and K(B-) = the kernel distribution evaluated at the lower endpoint of B</li> <li>Return P(B-) + P(B) * [K(x) - K(B-)] / K(B) where K(x) is the within-bin kernel distribution function evaluated at x.</li></ol> If K is a constant distribution, we return P(B-) + P(B) (counting the full mass of B).
 * @since 3.1
 */
@Override public double cumulativeProbability(double x){
  if (x < min) {
    return 0d;
  }
 else   if (x >= max) {
    return 1d;
  }
  final int binIndex=findBin(x);
  final double pBminus=pBminus(binIndex);
  final double pB=pB(binIndex);
  final RealDistribution kernel=k(x);
  if (kernel instanceof ConstantRealDistribution) {
    if (x < kernel.getNumericalMean()) {
      return pBminus;
    }
 else {
      return pBminus + pB;
    }
  }
  final double[] binBounds=getUpperBounds();
  final double kB=kB(binIndex);
  final double lower=binIndex == 0 ? min : binBounds[binIndex - 1];
  final double withinBinCum=(kernel.cumulativeProbability(x) - kernel.cumulativeProbability(lower)) / kB;
  return pBminus + pB * withinBinCum;
}"
57124,"/** 
 * <p>Return the probability mass function as a list of <value, probability> pairs.</p> <p>Note that if duplicate and / or null values were provided to the constructor when creating this EnumeratedDistribution, the returned list will contain these values.  If duplicates values exist, what is returned will not represent a pmf (i.e., it is up to the caller to consolidate duplicate mass points).</p>
 * @return the probability mass function.
 */
public List<Pair<T,Double>> getPmf(){
  final List<Pair<T,Double>> samples=new ArrayList<>(probabilities.length);
  for (int i=0; i < probabilities.length; i++) {
    samples.add(new Pair<>(singletons.get(i),probabilities[i]));
  }
  return samples;
}","/** 
 * <p>Return the probability mass function as a list of &lt;value, probability&gt; pairs.</p> <p>Note that if duplicate and / or null values were provided to the constructor when creating this EnumeratedDistribution, the returned list will contain these values.  If duplicates values exist, what is returned will not represent a pmf (i.e., it is up to the caller to consolidate duplicate mass points).</p>
 * @return the probability mass function.
 */
public List<Pair<T,Double>> getPmf(){
  final List<Pair<T,Double>> samples=new ArrayList<>(probabilities.length);
  for (int i=0; i < probabilities.length; i++) {
    samples.add(new Pair<>(singletons.get(i),probabilities[i]));
  }
  return samples;
}"
57125,"/** 
 * {@inheritDoc}The implementation of this method is based on: <ul> <li> <a href=""http://mathworld.wolfram.com/Chi-SquaredDistribution.html""> Chi-Squared Distribution</a>, equation (9). </li> <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>. Belmont, CA: Duxbury Press. </li> </ul>
 */
@Override public double cumulativeProbability(double x){
  double ret;
  if (x <= 0) {
    ret=0;
  }
 else {
    ret=Gamma.regularizedGammaP(shape,x / scale);
  }
  return ret;
}","/** 
 * {@inheritDoc}The implementation of this method is based on: <ul> <li> <a href=""http://mathworld.wolfram.com/Chi-SquaredDistribution.html""> Chi-Squared Distribution</a>, equation (9). </li> <li>Casella, G., &amp; Berger, R. (1990). <i>Statistical Inference</i>. Belmont, CA: Duxbury Press. </li> </ul>
 */
@Override public double cumulativeProbability(double x){
  double ret;
  if (x <= 0) {
    ret=0;
  }
 else {
    ret=Gamma.regularizedGammaP(shape,x / scale);
  }
  return ret;
}"
57126,"/** 
 * Computes the quantile function of this distribution. For a random variable   {@code X} distributed according to this distribution,the returned value is <ul> <li><code>inf{x in Z | P(X<=x) >= p}</code> for  {@code 0 < p <= 1},</li> <li><code>inf{x in Z | P(X<=x) > 0}</code> for   {@code p = 0}.</li> </ul> If the result exceeds the range of the data type   {@code int}, then   {@code Integer.MIN_VALUE} or {@code Integer.MAX_VALUE} is returned.
 * @param p the cumulative probability
 * @return the smallest {@code p}-quantile of this distribution (largest 0-quantile for   {@code p = 0})
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}
 */
int inverseCumulativeProbability(double p) throws OutOfRangeException ;","/** 
 * Computes the quantile function of this distribution. For a random variable   {@code X} distributed according to this distribution,the returned value is <ul> <li> {@code} infx in Z | P(X<=x) >= p}} for  {@code 0 < p <= 1},</li> <li>  {@code} infx in Z | P(X<=x) > 0}} for  {@code p = 0}.</li> </ul> If the result exceeds the range of the data type   {@code int}, then   {@code Integer.MIN_VALUE} or {@code Integer.MAX_VALUE} is returned.
 * @param p the cumulative probability
 * @return the smallest {@code p}-quantile of this distribution (largest 0-quantile for   {@code p = 0})
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}
 */
int inverseCumulativeProbability(double p) throws OutOfRangeException ;"
57127,"/** 
 * Access the lower bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(0)}. In other words, this method must return <p><code>inf {x in Z | P(X <= x) > 0}</code>.</p>
 * @return lower bound of the support ({@code Integer.MIN_VALUE}for negative infinity)
 */
int getSupportLowerBound();","/** 
 * Access the lower bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(0)}. In other words, this method must return <p>  {@code} inf x in Z | P(X <= x) > 0}}.</p>
 * @return lower bound of the support ({@code Integer.MIN_VALUE}for negative infinity)
 */
int getSupportLowerBound();"
57128,"/** 
 * Access the upper bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(1)}. In other words, this method must return <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>
 * @return upper bound of the support ({@code Integer.MAX_VALUE}for positive infinity)
 */
int getSupportUpperBound();","/** 
 * Access the upper bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(1)}. In other words, this method must return <p>  {@code} inf x in R | P(X <= x) = 1}}.</p>
 * @return upper bound of the support ({@code Integer.MAX_VALUE}for positive infinity)
 */
int getSupportUpperBound();"
57129,"/** 
 * {@inheritDoc}<p> From Wikipedia: The probability density function of the L&eacute;vy distribution over the domain is </p> <pre> f(x; &mu;, c) = &radic;(c / 2&pi;) * e<sup>-c / 2 (x - &mu;)</sup> / (x - &mu;)<sup>3/2</sup> </pre> <p> For this distribution,   {@code X}, this method returns   {@code P(X < x)}. If   {@code x} is less than location parameter &mu;, {@code Double.NaN} isreturned, as in these cases the distribution is not defined. </p>
 */
@Override public double density(final double x){
  if (x < mu) {
    return Double.NaN;
  }
  final double delta=x - mu;
  final double f=halfC / delta;
  return FastMath.sqrt(f / FastMath.PI) * FastMath.exp(-f) / delta;
}","/** 
 * {@inheritDoc}<p> From Wikipedia: The probability density function of the L&eacute;vy distribution over the domain is </p> <div style=""white-space: pre""><code> f(x; &mu;, c) = &radic;(c / 2&pi;) * e<sup>-c / 2 (x - &mu;)</sup> / (x - &mu;)<sup>3/2</sup> </code></div> <p> For this distribution,   {@code X}, this method returns   {@code P(X < x)}. If   {@code x} is less than location parameter &mu;, {@code Double.NaN} isreturned, as in these cases the distribution is not defined. </p>
 */
@Override public double density(final double x){
  if (x < mu) {
    return Double.NaN;
  }
  final double delta=x - mu;
  final double f=halfC / delta;
  return FastMath.sqrt(f / FastMath.PI) * FastMath.exp(-f) / delta;
}"
57130,"/** 
 * Computes the quantile function of this distribution. For a random variable   {@code X} distributed according to this distribution, thereturned value is <ul> <li><code>inf{x in R | P(X<=x) >= p}</code> for  {@code 0 < p <= 1},</li> <li><code>inf{x in R | P(X<=x) > 0}</code> for   {@code p = 0}.</li> </ul>
 * @param p the cumulative probability
 * @return the smallest {@code p}-quantile of this distribution (largest 0-quantile for   {@code p = 0})
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}
 */
double inverseCumulativeProbability(double p) throws OutOfRangeException ;","/** 
 * Computes the quantile function of this distribution. For a random variable   {@code X} distributed according to this distribution, thereturned value is <ul> <li> {@code} infx in R | P(X<=x) >= p}} for  {@code 0 < p <= 1},</li> <li>  {@code} infx in R | P(X<=x) > 0}} for  {@code p = 0}.</li> </ul>
 * @param p the cumulative probability
 * @return the smallest {@code p}-quantile of this distribution (largest 0-quantile for   {@code p = 0})
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}
 */
double inverseCumulativeProbability(double p) throws OutOfRangeException ;"
57131,"/** 
 * Access the lower bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(0)}. In other words, this method must return <p><code>inf {x in R | P(X <= x) > 0}</code>.</p>
 * @return lower bound of the support (might be{@code Double.NEGATIVE_INFINITY})
 */
double getSupportLowerBound();","/** 
 * Access the lower bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(0)}. In other words, this method must return <p>  {@code} inf x in R | P(X <= x) > 0}}.</p>
 * @return lower bound of the support (might be{@code Double.NEGATIVE_INFINITY})
 */
double getSupportLowerBound();"
57132,"/** 
 * Access the upper bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(1)}. In other words, this method must return <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>
 * @return upper bound of the support (might be{@code Double.POSITIVE_INFINITY})
 */
double getSupportUpperBound();","/** 
 * Access the upper bound of the support. This method must return the same value as   {@code inverseCumulativeProbability(1)}. In other words, this method must return <p>  {@code} inf x in R | P(X <= x) = 1}}.</p>
 * @return upper bound of the support (might be{@code Double.POSITIVE_INFINITY})
 */
double getSupportUpperBound();"
57133,"/** 
 * <p>Returns the weighted product of the entries in the input array.</p> <p>Throws <code>MathIllegalArgumentException</code> if any of the following are true: <ul><li>the values array is null</li> <li>the weights array is null</li> <li>the weights array does not have the same length as the values array</li> <li>the weights array contains one or more infinite values</li> <li>the weights array contains one or more NaN values</li> <li>the weights array contains negative values</li> </ul> <p>Uses the formula, <pre> weighted product = &prod;values[i]<sup>weights[i]</sup> </pre> that is, the weights are applied as exponents when computing the weighted product.</p>
 * @param values the input array
 * @param weights the weights array
 * @return the product of the values or Double.NaN if length = 0
 * @throws MathIllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
@Override public double evaluate(final double[] values,final double[] weights) throws MathIllegalArgumentException {
  return evaluate(values,weights,0,values.length);
}","/** 
 * <p>Returns the weighted product of the entries in the input array.</p> <p>Throws <code>MathIllegalArgumentException</code> if any of the following are true: <ul><li>the values array is null</li> <li>the weights array is null</li> <li>the weights array does not have the same length as the values array</li> <li>the weights array contains one or more infinite values</li> <li>the weights array contains one or more NaN values</li> <li>the weights array contains negative values</li> </ul> <p>Uses the formula, <div style=""white-space: pre""><code> weighted product = &prod;values[i]<sup>weights[i]</sup> </code></div> that is, the weights are applied as exponents when computing the weighted product.
 * @param values the input array
 * @param weights the weights array
 * @return the product of the values or Double.NaN if length = 0
 * @throws MathIllegalArgumentException if the parameters are not valid
 * @since 2.1
 */
@Override public double evaluate(final double[] values,final double[] weights) throws MathIllegalArgumentException {
  return evaluate(values,weights,0,values.length);
}"
57134,"/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #Cartesian1D(double)
 */
public abstract double getX();","/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see Cartesian1D#Cartesian1D(double)
 */
public abstract double getX();"
57135,"/** 
 * Get a vector orthogonal to the instance. <p>There are an infinite number of normalized vectors orthogonal to the instance. This method picks up one of them almost arbitrarily. It is useful when one needs to compute a reference frame with one of the axes in a predefined direction. The following example shows how to build a frame having the k axis aligned with the known vector u : <pre><code> Cartesian3D k = u.normalize(); Cartesian3D i = k.orthogonal(); Cartesian3D j = Cartesian3D.crossProduct(k, i); </code></pre></p>
 * @return a new normalized vector orthogonal to the instance
 * @exception MathArithmeticException if the norm of the instance is null
 */
public Cartesian3D orthogonal() throws MathArithmeticException {
  double threshold=0.6 * getNorm();
  if (threshold == 0) {
    throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
  }
  if (FastMath.abs(x) <= threshold) {
    double inverse=1 / FastMath.sqrt(y * y + z * z);
    return new Cartesian3D(0,inverse * z,-inverse * y);
  }
 else   if (FastMath.abs(y) <= threshold) {
    double inverse=1 / FastMath.sqrt(x * x + z * z);
    return new Cartesian3D(-inverse * z,0,inverse * x);
  }
  double inverse=1 / FastMath.sqrt(x * x + y * y);
  return new Cartesian3D(inverse * y,-inverse * x,0);
}","/** 
 * Get a vector orthogonal to the instance. <p>There are an infinite number of normalized vectors orthogonal to the instance. This method picks up one of them almost arbitrarily. It is useful when one needs to compute a reference frame with one of the axes in a predefined direction. The following example shows how to build a frame having the k axis aligned with the known vector u : <pre><code> Cartesian3D k = u.normalize(); Cartesian3D i = k.orthogonal(); Cartesian3D j = Cartesian3D.crossProduct(k, i); </code></pre>
 * @return a new normalized vector orthogonal to the instance
 * @exception MathArithmeticException if the norm of the instance is null
 */
public Cartesian3D orthogonal() throws MathArithmeticException {
  double threshold=0.6 * getNorm();
  if (threshold == 0) {
    throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
  }
  if (FastMath.abs(x) <= threshold) {
    double inverse=1 / FastMath.sqrt(y * y + z * z);
    return new Cartesian3D(0,inverse * z,-inverse * y);
  }
 else   if (FastMath.abs(y) <= threshold) {
    double inverse=1 / FastMath.sqrt(x * x + z * z);
    return new Cartesian3D(-inverse * z,0,inverse * x);
  }
  double inverse=1 / FastMath.sqrt(x * x + y * y);
  return new Cartesian3D(inverse * y,-inverse * x,0);
}"
57136,"/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #Cartesian3D(double,double,double)
 */
public abstract double getX();","/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see Cartesian3D#Cartesian3D(double,double,double)
 */
public abstract double getX();"
57137,"/** 
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #Cartesian3D(double,double,double)
 */
public abstract double getY();","/** 
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see Cartesian3D#Cartesian3D(double,double,double)
 */
public abstract double getY();"
57138,"/** 
 * Get the height of the vector.
 * @return height of the vector
 * @see #Cartesian3D(double,double,double)
 */
public abstract double getZ();","/** 
 * Get the height of the vector.
 * @return height of the vector
 * @see Cartesian3D#Cartesian3D(double,double,double)
 */
public abstract double getZ();"
57139,"/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #Cartesian2D(double,double)
 */
public abstract double getX();","/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see Cartesian2D#Cartesian2D(double,double)
 */
public abstract double getX();"
57140,"/** 
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #Cartesian2D(double,double)
 */
public abstract double getY();","/** 
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see Cartesian2D#Cartesian2D(double,double)
 */
public abstract double getY();"
57141,"/** 
 * Adds random jitter to   {@code data} using deviates sampled from {@code dist}. <p> Note that jitter is applied in-place - i.e., the array values are overwritten with the result of applying jitter.</p>
 * @param data input/output data array - entries overwritten by the method
 * @param sampler probability distribution to sample for jitter values
 * @throws NullPointerException if either of the parameters is null
 */
private static void jitter(double[] data,UniformRandomProvider rng,int ulp){
  final int range=ulp * 2;
  for (int i=0; i < data.length; i++) {
    final int rand=rng.nextInt(range) - ulp;
    data[i]+=rand * Math.ulp(data[i]);
  }
}","/** 
 * Adds random jitter to   {@code data} using deviates sampled from {@code dist}. <p> Note that jitter is applied in-place - i.e., the array values are overwritten with the result of applying jitter.</p>
 * @param data input/output data array - entries overwritten by the method
 * @param rng probability distribution to sample for jitter values
 * @param ulp ulp used when generating random numbers
 * @throws NullPointerException if either of the parameters is null
 */
private static void jitter(double[] data,UniformRandomProvider rng,int ulp){
  final int range=ulp * 2;
  for (int i=0; i < data.length; i++) {
    final int rand=rng.nextInt(range) - ulp;
    data[i]+=rand * Math.ulp(data[i]);
  }
}"
57142,"@Test public void testFormatObjectStringBufferFieldPositionWitNumber(){
  ComplexFormat cf=ComplexFormat.getInstance();
  String source=""String_Node_Str"" + getDecimalCharacter() + ""String_Node_Str"";
  Number expected=new Double(1.23);
  String formatted=cf.format(expected,new StringBuffer(),new FieldPosition(0)).toString();
  Assert.assertEquals(source,formatted);
}","@Test public void testFormatObjectStringBufferFieldPositionWitNumber(){
  ComplexFormat cf=ComplexFormat.getInstance(getLocale());
  String source=""String_Node_Str"" + getDecimalCharacter() + ""String_Node_Str"";
  Number expected=new Double(1.23);
  String formatted=cf.format(expected,new StringBuffer(),new FieldPosition(0)).toString();
  Assert.assertEquals(source,formatted);
}"
57143,"@Test public void testFormatObjectStringBufferFieldPositionWithComplex(){
  ComplexFormat cf=ComplexFormat.getInstance();
  String source=""String_Node_Str"" + getDecimalCharacter() + ""String_Node_Str""+ getDecimalCharacter()+ ""String_Node_Str"";
  Object expected=new Complex(1.23,1.43);
  String formatted=cf.format(expected,new StringBuffer(),new FieldPosition(0)).toString();
  Assert.assertEquals(source,formatted);
}","@Test public void testFormatObjectStringBufferFieldPositionWithComplex(){
  ComplexFormat cf=ComplexFormat.getInstance(getLocale());
  String source=""String_Node_Str"" + getDecimalCharacter() + ""String_Node_Str""+ getDecimalCharacter()+ ""String_Node_Str"";
  Object expected=new Complex(1.23,1.43);
  String formatted=cf.format(expected,new StringBuffer(),new FieldPosition(0)).toString();
  Assert.assertEquals(source,formatted);
}"
57144,"/** 
 * {@inheritDoc} 
 */
@SuppressWarnings(""String_Node_Str"") @Override protected FieldODEStateAndDerivative<T> computeInterpolatedStateAndDerivatives(final FieldEquationsMapper<T> mapper,final T time,final T theta,final T oneMinusThetaH){
  final T coeffDot1=theta.multiply(theta.multiply(theta.multiply(theta.multiply(21).add(-47)).add(36)).add(-54 / 5.0)).add(1);
  final T coeffDot2=getField().getZero();
  final T coeffDot3=theta.multiply(theta.multiply(theta.multiply(theta.multiply(112).add(-608 / 3.0)).add(320 / 3.0)).add(-208 / 15.0));
  final T coeffDot4=theta.multiply(theta.multiply(theta.multiply(theta.multiply(-567 / 5.0).add(972 / 5.0)).add(-486 / 5.0)).add(324 / 25.0));
  final T coeffDot5=theta.multiply(theta.multiply(theta.multiply(theta.multiply(c5a.divide(5)).add(c5b.divide(15))).add(c5c.divide(30))).add(c5d.divide(150)));
  final T coeffDot6=theta.multiply(theta.multiply(theta.multiply(theta.multiply(c6a.divide(5)).add(c6b.divide(15))).add(c6c.divide(30))).add(c6d.divide(150)));
  final T coeffDot7=theta.multiply(theta.multiply(theta.multiply(3)).add(-3)).add(3 / 5.0);
  final T[] interpolatedState;
  final T[] interpolatedDerivatives;
  if (getGlobalPreviousState() != null && theta.getReal() <= 0.5) {
    final T s=theta.multiply(theta.multiply(h));
    final T coeff1=s.multiply(theta.multiply(theta.multiply(theta.multiply(21 / 5.0).add(-47 / 4.0)).add(12)).add(-27 / 5.0)).add(1);
    final T coeff2=getField().getZero();
    final T coeff3=s.multiply(theta.multiply(theta.multiply(theta.multiply(112 / 5.0).add(-152 / 3.0)).add(320 / 9.0)).add(-104 / 15.0));
    final T coeff4=s.multiply(theta.multiply(theta.multiply(theta.multiply(-567 / 25.0).add(243 / 5.0)).add(-162 / 5.0)).add(162 / 25.0));
    final T coeff5=s.multiply(theta.multiply(theta.multiply(theta.multiply(c5a.divide(25)).add(c5b.divide(60))).add(c5c.divide(90))).add(c5d.divide(300)));
    final T coeff6=s.multiply(theta.multiply(theta.multiply(theta.multiply(c5a.divide(25)).add(c6b.divide(60))).add(c6c.divide(90))).add(c6d.divide(300)));
    final T coeff7=s.multiply(theta.multiply(theta.multiply(3 / 4.0)).add(-1)).add(3 / 10.0);
    interpolatedState=previousStateLinearCombination(coeff1,coeff2,coeff3,coeff4,coeff5,coeff6,coeff7);
    interpolatedDerivatives=derivativeLinearCombination(coeffDot1,coeffDot2,coeffDot3,coeffDot4,coeffDot5,coeffDot6,coeffDot7);
  }
 else {
    final T s=oneMinusThetaH.multiply(theta);
    final T coeff1=s.multiply(theta.multiply(theta.multiply(theta.multiply(-21 / 5.0).add(151 / 20.0)).add(-89 / 20.0)).add(19 / 20.0)).add(-1 / 20.0);
    final T coeff2=getField().getZero();
    final T coeff3=s.multiply(theta.multiply(theta.multiply(theta.multiply(-112 / 5.0).add(424 / 15.0)).add(-328 / 45.0)).add(-16 / 45.0)).add(-16 / 45.0);
    final T coeff4=s.multiply(theta.multiply(theta.multiply(theta.multiply(567 / 25.0).add(-648 / 25.0)).add(162 / 25.0)));
    final T coeff5=s.multiply(theta.multiply(theta.multiply(theta.multiply(d5a.divide(25)).add(d5b.divide(300))).add(d5c.divide(900))).add(-49 / 180.0)).add(-49 / 180.0);
    final T coeff6=s.multiply(theta.multiply(theta.multiply(theta.multiply(d6a.divide(25)).add(d6b.divide(300))).add(d6c.divide(900))).add(-49 / 180.0)).add(-49 / 180.0);
    final T coeff7=s.multiply(theta.multiply(theta.multiply(-3 / 4.0).add(1 / 4.0)).add(-1 / 20.0)).add(-1 / 20.0);
    interpolatedState=currentStateLinearCombination(coeff1,coeff2,coeff3,coeff4,coeff5,coeff6,coeff7);
    interpolatedDerivatives=derivativeLinearCombination(coeffDot1,coeffDot2,coeffDot3,coeffDot4,coeffDot5,coeffDot6,coeffDot7);
  }
  return new FieldODEStateAndDerivative<T>(time,interpolatedState,interpolatedDerivatives);
}","/** 
 * {@inheritDoc} 
 */
@SuppressWarnings(""String_Node_Str"") @Override protected FieldODEStateAndDerivative<T> computeInterpolatedStateAndDerivatives(final FieldEquationsMapper<T> mapper,final T time,final T theta,final T oneMinusThetaH){
  final T coeffDot1=theta.multiply(theta.multiply(theta.multiply(theta.multiply(21).add(-47)).add(36)).add(-54 / 5.0)).add(1);
  final T coeffDot2=getField().getZero();
  final T coeffDot3=theta.multiply(theta.multiply(theta.multiply(theta.multiply(112).add(-608 / 3.0)).add(320 / 3.0)).add(-208 / 15.0));
  final T coeffDot4=theta.multiply(theta.multiply(theta.multiply(theta.multiply(-567 / 5.0).add(972 / 5.0)).add(-486 / 5.0)).add(324 / 25.0));
  final T coeffDot5=theta.multiply(theta.multiply(theta.multiply(theta.multiply(c5a.divide(5)).add(c5b.divide(15))).add(c5c.divide(30))).add(c5d.divide(150)));
  final T coeffDot6=theta.multiply(theta.multiply(theta.multiply(theta.multiply(c6a.divide(5)).add(c6b.divide(15))).add(c6c.divide(30))).add(c6d.divide(150)));
  final T coeffDot7=theta.multiply(theta.multiply(theta.multiply(3.0).add(-3)).add(3 / 5.0));
  final T[] interpolatedState;
  final T[] interpolatedDerivatives;
  if (getGlobalPreviousState() != null && theta.getReal() <= 0.5) {
    final T s=theta.multiply(h);
    final T coeff1=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(21 / 5.0).add(-47 / 4.0)).add(12)).add(-27 / 5.0)).add(1));
    final T coeff2=getField().getZero();
    final T coeff3=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(112 / 5.0).add(-152 / 3.0)).add(320 / 9.0)).add(-104 / 15.0)));
    final T coeff4=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(-567 / 25.0).add(243 / 5.0)).add(-162 / 5.0)).add(162 / 25.0)));
    final T coeff5=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(c5a.divide(25)).add(c5b.divide(60))).add(c5c.divide(90))).add(c5d.divide(300))));
    final T coeff6=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(c6a.divide(25)).add(c6b.divide(60))).add(c6c.divide(90))).add(c6d.divide(300))));
    final T coeff7=s.multiply(theta.multiply(theta.multiply(theta.multiply(3 / 4.0).add(-1)).add(3 / 10.0)));
    interpolatedState=previousStateLinearCombination(coeff1,coeff2,coeff3,coeff4,coeff5,coeff6,coeff7);
    interpolatedDerivatives=derivativeLinearCombination(coeffDot1,coeffDot2,coeffDot3,coeffDot4,coeffDot5,coeffDot6,coeffDot7);
  }
 else {
    final T s=oneMinusThetaH;
    final T coeff1=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(-21 / 5.0).add(151 / 20.0)).add(-89 / 20.0)).add(19 / 20.0)).add(-1 / 20.0));
    final T coeff2=getField().getZero();
    final T coeff3=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(-112 / 5.0).add(424 / 15.0)).add(-328 / 45.0)).add(-16 / 45.0)).add(-16 / 45.0));
    final T coeff4=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(567 / 25.0).add(-648 / 25.0)).add(162 / 25.0))));
    final T coeff5=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(d5a.divide(25)).add(d5b.divide(300))).add(d5c.divide(900))).add(-49 / 180.0)).add(-49 / 180.0));
    final T coeff6=s.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(d6a.divide(25)).add(d6b.divide(300))).add(d6c.divide(900))).add(-49 / 180.0)).add(-49 / 180.0));
    final T coeff7=s.multiply(theta.multiply(theta.multiply(theta.multiply(-3 / 4.0).add(1 / 4.0)).add(-1 / 20.0)).add(-1 / 20.0));
    interpolatedState=currentStateLinearCombination(coeff1,coeff2,coeff3,coeff4,coeff5,coeff6,coeff7);
    interpolatedDerivatives=derivativeLinearCombination(coeffDot1,coeffDot2,coeffDot3,coeffDot4,coeffDot5,coeffDot6,coeffDot7);
  }
  return new FieldODEStateAndDerivative<T>(time,interpolatedState,interpolatedDerivatives);
}"
57145,"@Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestBigStep(Decimal64Field.getInstance(),0.00002,0.001,1.0e-12,""String_Node_Str"");
}","@Test public void testBigStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestBigStep(Decimal64Field.getInstance(),2.7e-5,1.7e-3,1.0e-12,""String_Node_Str"");
}"
57146,"@Test public void testSingleStep(){
  doTestSingleStep(Decimal64Field.getInstance(),1.0e-11);
}","@Test public void testSingleStep(){
  doTestSingleStep(Decimal64Field.getInstance(),6.0e-12);
}"
57147,"@Test public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestStepSize(Decimal64Field.getInstance(),1.0e-12);
}","@Test public void testStepSize() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestStepSize(Decimal64Field.getInstance(),1.0e-22);
}"
57148,"@Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestSmallStep(Decimal64Field.getInstance(),9.0e-17,4.0e-15,1.0e-12,""String_Node_Str"");
}","@Test public void testSmallStep() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestSmallStep(Decimal64Field.getInstance(),8.7e-17,3.6e-15,1.0e-12,""String_Node_Str"");
}"
57149,"@Test public void testDerivativesConsistency(){
  doTestDerivativesConsistency(Decimal64Field.getInstance(),1.0e-10);
}","@Test public void testDerivativesConsistency(){
  doTestDerivativesConsistency(Decimal64Field.getInstance(),1.0e-20);
}"
57150,"@Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestKepler(Decimal64Field.getInstance(),2.2e-7,1.0e-8);
}","@Test public void testKepler() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestKepler(Decimal64Field.getInstance(),2.18e-7,4.0e-10);
}"
57151,"@Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestBackward(Decimal64Field.getInstance(),3.0e-13,5.0e-13,1.0e-12,""String_Node_Str"");
}","@Test public void testBackward() throws DimensionMismatchException, NumberIsTooSmallException, MaxCountExceededException, NoBracketingException {
  doTestBackward(Decimal64Field.getInstance(),2.4e-13,4.3e-13,1.0e-12,""String_Node_Str"");
}"
57152,"@Test public void testUnstableDerivative(){
  doTestUnstableDerivative(Decimal64Field.getInstance(),1.0e-12);
}","@Test public void testUnstableDerivative(){
  doTestUnstableDerivative(Decimal64Field.getInstance(),4.0e-15);
}"
57153,"@Test public void interpolationInside(){
  doInterpolationInside(Decimal64Field.getInstance(),3.3e-14,7.9e-13);
}","@Test public void interpolationInside(){
  doInterpolationInside(Decimal64Field.getInstance(),1.1e-7,9.6e-9);
}"
57154,"/** 
 * {@inheritDoc} 
 */
@SuppressWarnings(""String_Node_Str"") @Override protected FieldODEStateAndDerivative<T> computeInterpolatedStateAndDerivatives(final FieldEquationsMapper<T> mapper,final T time,final T theta,final T oneMinusThetaH){
  final T bDot0=theta.multiply(theta.multiply(theta.multiply(-10.0).add(16.0)).add(-15.0 / 2.0)).add(1);
  final T bDot1=getField().getZero();
  final T bDot2=theta.multiply(theta.multiply(theta.multiply(135.0 / 2.0).add(-729.0 / 8.0)).add(459.0 / 16.0));
  final T bDot3=theta.multiply(theta.multiply(theta.multiply(-120.0).add(152.0)).add(-44.0));
  final T bDot4=theta.multiply(theta.multiply(theta.multiply(125.0 / 2.0).add(-625.0 / 8.0)).add(375.0 / 16.0));
  final T bDot5=theta.multiply(5.0 / 8.0).multiply(theta.multiply(2).subtract(1));
  final T[] interpolatedState;
  final T[] interpolatedDerivatives;
  if (getGlobalPreviousState() != null && theta.getReal() <= 0.5) {
    final T hTheta=h.multiply(theta);
    final T b0=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(-5.0 / 2.0).add(16.0 / 3.0)).add(-15.0 / 4.0)).add(1));
    final T b1=getField().getZero();
    final T b2=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(135.0 / 8.0).add(-243.0 / 8.0)).add(459.0 / 32.0)));
    final T b3=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(-30.0).add(152.0 / 3.0)).add(-22.0)));
    final T b4=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(125.0 / 8.0).add(-625.0 / 24.0)).add(375.0 / 32.0)));
    final T b5=hTheta.multiply(theta.multiply(theta.multiply(5.0 / 12.0)).add(-5.0 / 16.0));
    interpolatedState=previousStateLinearCombination(b0,b1,b2,b3,b4,b5);
    interpolatedDerivatives=derivativeLinearCombination(bDot0,bDot1,bDot2,bDot3,bDot4,bDot5);
  }
 else {
    final T theta2=theta.multiply(theta);
    final T b0=h.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(-5.0 / 2.0).add(16.0 / 3.0)).add(-15.0 / 4.0)).add(1.0)).add(-1.0 / 12.0));
    final T b1=getField().getZero();
    final T b2=h.multiply(theta2.multiply(theta.multiply(theta.multiply(135.0 / 8.0).add(-243.0 / 8.0)).add(459.0 / 32.0)).add(-27.0 / 32.0));
    final T b3=h.multiply(theta2.multiply(theta.multiply(theta.multiply(-30.0).add(152.0 / 3.0)).add(-22.0)).add(4.0 / 3.0));
    final T b4=h.multiply(theta2.multiply(theta.multiply(theta.multiply(125.0 / 8.0).add(-625.0 / 24.0)).add(375.0 / 32.0)).add(-125.0 / 96.0));
    final T b5=h.multiply(theta2.multiply(theta.multiply(5.0 / 12.0).add(-5.0 / 16.0)).add(-5.0 / 48.0));
    interpolatedState=currentStateLinearCombination(b0,b1,b2,b3,b4,b5);
    interpolatedDerivatives=derivativeLinearCombination(bDot0,bDot1,bDot2,bDot3,bDot4,bDot5);
  }
  return new FieldODEStateAndDerivative<T>(time,interpolatedState,interpolatedDerivatives);
}","/** 
 * {@inheritDoc} 
 */
@SuppressWarnings(""String_Node_Str"") @Override protected FieldODEStateAndDerivative<T> computeInterpolatedStateAndDerivatives(final FieldEquationsMapper<T> mapper,final T time,final T theta,final T oneMinusThetaH){
  final T bDot0=theta.multiply(theta.multiply(theta.multiply(-10.0).add(16.0)).add(-15.0 / 2.0)).add(1);
  final T bDot1=getField().getZero();
  final T bDot2=theta.multiply(theta.multiply(theta.multiply(135.0 / 2.0).add(-729.0 / 8.0)).add(459.0 / 16.0));
  final T bDot3=theta.multiply(theta.multiply(theta.multiply(-120.0).add(152.0)).add(-44.0));
  final T bDot4=theta.multiply(theta.multiply(theta.multiply(125.0 / 2.0).add(-625.0 / 8.0)).add(375.0 / 16.0));
  final T bDot5=theta.multiply(5.0 / 8.0).multiply(theta.multiply(2).subtract(1));
  final T[] interpolatedState;
  final T[] interpolatedDerivatives;
  if (getGlobalPreviousState() != null && theta.getReal() <= 0.5) {
    final T hTheta=h.multiply(theta);
    final T b0=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(-5.0 / 2.0).add(16.0 / 3.0)).add(-15.0 / 4.0)).add(1));
    final T b1=getField().getZero();
    final T b2=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(135.0 / 8.0).add(-243.0 / 8.0)).add(459.0 / 32.0)));
    final T b3=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(-30.0).add(152.0 / 3.0)).add(-22.0)));
    final T b4=hTheta.multiply(theta.multiply(theta.multiply(theta.multiply(125.0 / 8.0).add(-625.0 / 24.0)).add(375.0 / 32.0)));
    final T b5=hTheta.multiply(theta.multiply(theta.multiply(5.0 / 12.0).add(-5.0 / 16.0)));
    interpolatedState=previousStateLinearCombination(b0,b1,b2,b3,b4,b5);
    interpolatedDerivatives=derivativeLinearCombination(bDot0,bDot1,bDot2,bDot3,bDot4,bDot5);
  }
 else {
    final T theta2=theta.multiply(theta);
    final T b0=h.multiply(theta.multiply(theta.multiply(theta.multiply(theta.multiply(-5.0 / 2.0).add(16.0 / 3.0)).add(-15.0 / 4.0)).add(1.0)).add(-1.0 / 12.0));
    final T b1=getField().getZero();
    final T b2=h.multiply(theta2.multiply(theta.multiply(theta.multiply(135.0 / 8.0).add(-243.0 / 8.0)).add(459.0 / 32.0)).add(-27.0 / 32.0));
    final T b3=h.multiply(theta2.multiply(theta.multiply(theta.multiply(-30.0).add(152.0 / 3.0)).add(-22.0)).add(4.0 / 3.0));
    final T b4=h.multiply(theta2.multiply(theta.multiply(theta.multiply(125.0 / 8.0).add(-625.0 / 24.0)).add(375.0 / 32.0)).add(-125.0 / 96.0));
    final T b5=h.multiply(theta2.multiply(theta.multiply(5.0 / 12.0).add(-5.0 / 16.0)).add(-5.0 / 48.0));
    interpolatedState=currentStateLinearCombination(b0,b1,b2,b3,b4,b5);
    interpolatedDerivatives=derivativeLinearCombination(bDot0,bDot1,bDot2,bDot3,bDot4,bDot5);
  }
  return new FieldODEStateAndDerivative<T>(time,interpolatedState,interpolatedDerivatives);
}"
57155,"/** 
 * Returns the skewness of the available values. Skewness is a measure of the asymmetry of a given distribution.
 * @return The skewness, Double.NaN if no values have been addedor 0.0 for a value set &lt;=2.
 */
public double getSkewness(){
  return apply(skewnessImpl);
}","/** 
 * Returns the skewness of the available values. Skewness is a measure of the asymmetry of a given distribution.
 * @return The skewness, Double.NaN if less than 3 values have been added.
 */
public double getSkewness(){
  return apply(skewnessImpl);
}"
57156,"/** 
 * Returns the <a href=""http://www.xycoon.com/geometric_mean.htm""> geometric mean </a> of the available values
 * @return The geometricMean, Double.NaN if no values have been added,or if the product of the available values is less than or equal to 0.
 */
public double getGeometricMean(){
  return apply(geometricMeanImpl);
}","/** 
 * Returns the <a href=""http://www.xycoon.com/geometric_mean.htm""> geometric mean </a> of the available values. <p> See   {@link GeometricMean} for details on the computing algorithm.</p>
 * @return The geometricMean, Double.NaN if no values have been added,or if any negative values have been added.
 */
public double getGeometricMean(){
  return apply(geometricMeanImpl);
}"
57157,"/** 
 * Returns the Kurtosis of the available values. Kurtosis is a measure of the ""peakedness"" of a distribution
 * @return The kurtosis, Double.NaN if no values have been added, or 0.0for a value set &lt;=3.
 */
public double getKurtosis(){
  return apply(kurtosisImpl);
}","/** 
 * Returns the Kurtosis of the available values. Kurtosis is a measure of the ""peakedness"" of a distribution.
 * @return The kurtosis, Double.NaN if less than 4 values have been added.
 */
public double getKurtosis(){
  return apply(kurtosisImpl);
}"
57158,"/** 
 * Sort the observations.
 * @param unsorted Input observations.
 * @return the input observations, sorted.
 */
private List<WeightedObservedPoint> sortObservations(Collection<WeightedObservedPoint> unsorted){
  final List<WeightedObservedPoint> observations=new ArrayList<WeightedObservedPoint>(unsorted);
  final Comparator<WeightedObservedPoint> cmp=new Comparator<WeightedObservedPoint>(){
    @Override public int compare(    WeightedObservedPoint p1,    WeightedObservedPoint p2){
      if (p1 == null && p2 == null) {
        return 0;
      }
      if (p1 == null) {
        return -1;
      }
      if (p2 == null) {
        return 1;
      }
      if (p1.getX() < p2.getX()) {
        return -1;
      }
      if (p1.getX() > p2.getX()) {
        return 1;
      }
      if (p1.getY() < p2.getY()) {
        return -1;
      }
      if (p1.getY() > p2.getY()) {
        return 1;
      }
      if (p1.getWeight() < p2.getWeight()) {
        return -1;
      }
      if (p1.getWeight() > p2.getWeight()) {
        return 1;
      }
      return 0;
    }
  }
;
  Collections.sort(observations,cmp);
  return observations;
}","/** 
 * Sort the observations.
 * @param unsorted Input observations.
 * @return the input observations, sorted.
 */
private List<WeightedObservedPoint> sortObservations(Collection<WeightedObservedPoint> unsorted){
  final List<WeightedObservedPoint> observations=new ArrayList<WeightedObservedPoint>(unsorted);
  final Comparator<WeightedObservedPoint> cmp=new Comparator<WeightedObservedPoint>(){
    @Override public int compare(    WeightedObservedPoint p1,    WeightedObservedPoint p2){
      if (p1 == null && p2 == null) {
        return 0;
      }
      if (p1 == null) {
        return -1;
      }
      if (p2 == null) {
        return 1;
      }
      int comp=Double.compare(p1.getX(),p2.getX());
      if (comp != 0) {
        return comp;
      }
      comp=Double.compare(p1.getY(),p2.getY());
      if (comp != 0) {
        return comp;
      }
      comp=Double.compare(p1.getWeight(),p2.getWeight());
      if (comp != 0) {
        return comp;
      }
      return 0;
    }
  }
;
  Collections.sort(observations,cmp);
  return observations;
}"
57159,"@Override public int compare(WeightedObservedPoint p1,WeightedObservedPoint p2){
  if (p1 == null && p2 == null) {
    return 0;
  }
  if (p1 == null) {
    return -1;
  }
  if (p2 == null) {
    return 1;
  }
  if (p1.getX() < p2.getX()) {
    return -1;
  }
  if (p1.getX() > p2.getX()) {
    return 1;
  }
  if (p1.getY() < p2.getY()) {
    return -1;
  }
  if (p1.getY() > p2.getY()) {
    return 1;
  }
  if (p1.getWeight() < p2.getWeight()) {
    return -1;
  }
  if (p1.getWeight() > p2.getWeight()) {
    return 1;
  }
  return 0;
}","@Override public int compare(WeightedObservedPoint p1,WeightedObservedPoint p2){
  if (p1 == null && p2 == null) {
    return 0;
  }
  if (p1 == null) {
    return -1;
  }
  if (p2 == null) {
    return 1;
  }
  int comp=Double.compare(p1.getX(),p2.getX());
  if (comp != 0) {
    return comp;
  }
  comp=Double.compare(p1.getY(),p2.getY());
  if (comp != 0) {
    return comp;
  }
  comp=Double.compare(p1.getWeight(),p2.getWeight());
  if (comp != 0) {
    return comp;
  }
  return 0;
}"
57160,"/** 
 * Add a sample point. <p> This method must be called once for each sample point. It is allowed to mix some calls with values only with calls with values and first derivatives. </p> <p> The point abscissae for all calls <em>must</em> be different. </p>
 * @param x abscissa of the sample point
 * @param value value and derivatives of the sample point(if only one row is passed, it is the value, if two rows are passed the first one is the value and the second the derivative and so on)
 * @exception ZeroException if the abscissa difference between added pointand a previous point is zero (i.e. the two points are at same abscissa)
 * @exception MathArithmeticException if the number of derivatives is largerthan 20, which prevents computation of a factorial
 * @throws DimensionMismatchException if derivative structures are inconsistent
 * @throws NullArgumentException if x is null
 */
public void addSamplePoint(final T x,final T[]... value) throws ZeroException, MathArithmeticException, DimensionMismatchException, NullArgumentException {
  MathUtils.checkNotNull(x);
  T factorial=x.getField().getOne();
  for (int i=0; i < value.length; ++i) {
    final T[] y=value[i].clone();
    if (i > 1) {
      factorial=factorial.multiply(i);
      final T inv=factorial.reciprocal();
      for (int j=0; j < y.length; ++j) {
        y[j]=y[j].multiply(inv);
      }
    }
    final int n=abscissae.size();
    bottomDiagonal.add(n - i,y);
    T[] bottom0=y;
    for (int j=i; j < n; ++j) {
      final T[] bottom1=bottomDiagonal.get(n - (j + 1));
      if (x.equals(abscissae.get(n - (j + 1)))) {
        throw new ZeroException(LocalizedFormats.DUPLICATED_ABSCISSA_DIVISION_BY_ZERO,x);
      }
      final T inv=x.subtract(abscissae.get(n - (j + 1))).reciprocal();
      for (int k=0; k < y.length; ++k) {
        bottom1[k]=inv.multiply(bottom0[k].subtract(bottom1[k]));
      }
      bottom0=bottom1;
    }
    topDiagonal.add(bottom0.clone());
    abscissae.add(x);
  }
}","/** 
 * Add a sample point. <p> This method must be called once for each sample point. It is allowed to mix some calls with values only with calls with values and first derivatives. </p> <p> The point abscissae for all calls <em>must</em> be different. </p>
 * @param x abscissa of the sample point
 * @param value value and derivatives of the sample point(if only one row is passed, it is the value, if two rows are passed the first one is the value and the second the derivative and so on)
 * @exception ZeroException if the abscissa difference between added pointand a previous point is zero (i.e. the two points are at same abscissa)
 * @exception MathArithmeticException if the number of derivatives is largerthan 20, which prevents computation of a factorial
 * @throws DimensionMismatchException if derivative structures are inconsistent
 * @throws NullArgumentException if x is null
 */
@SafeVarargs public final void addSamplePoint(final T x,final T[]... value) throws ZeroException, MathArithmeticException, DimensionMismatchException, NullArgumentException {
  MathUtils.checkNotNull(x);
  T factorial=x.getField().getOne();
  for (int i=0; i < value.length; ++i) {
    final T[] y=value[i].clone();
    if (i > 1) {
      factorial=factorial.multiply(i);
      final T inv=factorial.reciprocal();
      for (int j=0; j < y.length; ++j) {
        y[j]=y[j].multiply(inv);
      }
    }
    final int n=abscissae.size();
    bottomDiagonal.add(n - i,y);
    T[] bottom0=y;
    for (int j=i; j < n; ++j) {
      final T[] bottom1=bottomDiagonal.get(n - (j + 1));
      if (x.equals(abscissae.get(n - (j + 1)))) {
        throw new ZeroException(LocalizedFormats.DUPLICATED_ABSCISSA_DIVISION_BY_ZERO,x);
      }
      final T inv=x.subtract(abscissae.get(n - (j + 1))).reciprocal();
      for (int k=0; k < y.length; ++k) {
        bottom1[k]=inv.multiply(bottom0[k].subtract(bottom1[k]));
      }
      bottom0=bottom1;
    }
    topDiagonal.add(bottom0.clone());
    abscissae.add(x);
  }
}"
57161,"/** 
 * Simple constructor.
 * @param center center of the ball
 * @param radius radius of the ball
 * @param support support points used to define the ball
 */
public EnclosingBall(final P center,final double radius,final P... support){
  this.center=center;
  this.radius=radius;
  this.support=support.clone();
}","/** 
 * Simple constructor.
 * @param center center of the ball
 * @param radius radius of the ball
 * @param support support points used to define the ball
 */
@SafeVarargs public EnclosingBall(final P center,final double radius,final P... support){
  this.center=center;
  this.radius=radius;
  this.support=support.clone();
}"
57162,"/** 
 * Build a convex region from a collection of bounding hyperplanes.
 * @param hyperplanes collection of bounding hyperplanes
 * @return a new convex region, or null if the collection is empty
 */
public Region<S> buildConvex(final Hyperplane<S>... hyperplanes){
  if ((hyperplanes == null) || (hyperplanes.length == 0)) {
    return null;
  }
  final Region<S> region=hyperplanes[0].wholeSpace();
  BSPTree<S> node=region.getTree(false);
  node.setAttribute(Boolean.TRUE);
  for (  final Hyperplane<S> hyperplane : hyperplanes) {
    if (node.insertCut(hyperplane)) {
      node.setAttribute(null);
      node.getPlus().setAttribute(Boolean.FALSE);
      node=node.getMinus();
      node.setAttribute(Boolean.TRUE);
    }
  }
  return region;
}","/** 
 * Build a convex region from a collection of bounding hyperplanes.
 * @param hyperplanes collection of bounding hyperplanes
 * @return a new convex region, or null if the collection is empty
 */
@SafeVarargs public final Region<S> buildConvex(final Hyperplane<S>... hyperplanes){
  if ((hyperplanes == null) || (hyperplanes.length == 0)) {
    return null;
  }
  final Region<S> region=hyperplanes[0].wholeSpace();
  BSPTree<S> node=region.getTree(false);
  node.setAttribute(Boolean.TRUE);
  for (  final Hyperplane<S> hyperplane : hyperplanes) {
    if (node.insertCut(hyperplane)) {
      node.setAttribute(null);
      node.getPlus().setAttribute(Boolean.FALSE);
      node=node.getMinus();
      node.setAttribute(Boolean.TRUE);
    }
  }
  return region;
}"
57163,"/** 
 * Timing.
 * @param repeatChunk Each timing measurement will done done for thatnumber of repeats of the code.
 * @param repeatStat Timing will be averaged over that number of runs.
 * @param runGC Call {@code System.gc()} between each timed block. Whenset to  {@code true}, the test will run much slower.
 * @param methods Codes being timed.
 * @return for each of the given {@code methods} (first dimension), andeach of the  {@code repeatStat} runs (second dimension):<ul> <li> the average time (in milliseconds) taken by a single call to the {@code call} method (i.e. the time taken by each timed block dividedby  {@code repeatChunk}) </li> <li> the result returned by the   {@code call} method.</li> </ul>
 */
public static double[][][] timesAndResults(int repeatChunk,int repeatStat,boolean runGC,Callable<Double>... methods){
  final int numMethods=methods.length;
  final double[][][] timesAndResults=new double[numMethods][repeatStat][2];
  try {
    for (int k=0; k < repeatStat; k++) {
      for (int j=0; j < numMethods; j++) {
        if (runGC) {
          System.gc();
        }
        final Callable<Double> r=methods[j];
        final double[] result=new double[repeatChunk];
        final long start=System.nanoTime();
        for (int i=0; i < repeatChunk; i++) {
          result[i]=r.call().doubleValue();
        }
        final long stop=System.nanoTime();
        timesAndResults[j][k][0]=(stop - start) * NANO_TO_MILLI;
        timesAndResults[j][k][1]=result[rng.nextInt(repeatChunk)];
      }
    }
  }
 catch (  Exception e) {
    throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE,e.getMessage());
  }
  final double normFactor=1d / repeatChunk;
  for (int j=0; j < numMethods; j++) {
    for (int k=0; k < repeatStat; k++) {
      timesAndResults[j][k][0]*=normFactor;
    }
  }
  return timesAndResults;
}","/** 
 * Timing.
 * @param repeatChunk Each timing measurement will done done for thatnumber of repeats of the code.
 * @param repeatStat Timing will be averaged over that number of runs.
 * @param runGC Call {@code System.gc()} between each timed block. Whenset to  {@code true}, the test will run much slower.
 * @param methods Codes being timed.
 * @return for each of the given {@code methods} (first dimension), andeach of the  {@code repeatStat} runs (second dimension):<ul> <li> the average time (in milliseconds) taken by a single call to the {@code call} method (i.e. the time taken by each timed block dividedby  {@code repeatChunk}) </li> <li> the result returned by the   {@code call} method.</li> </ul>
 */
@SafeVarargs public static double[][][] timesAndResults(int repeatChunk,int repeatStat,boolean runGC,Callable<Double>... methods){
  final int numMethods=methods.length;
  final double[][][] timesAndResults=new double[numMethods][repeatStat][2];
  try {
    for (int k=0; k < repeatStat; k++) {
      for (int j=0; j < numMethods; j++) {
        if (runGC) {
          System.gc();
        }
        final Callable<Double> r=methods[j];
        final double[] result=new double[repeatChunk];
        final long start=System.nanoTime();
        for (int i=0; i < repeatChunk; i++) {
          result[i]=r.call().doubleValue();
        }
        final long stop=System.nanoTime();
        timesAndResults[j][k][0]=(stop - start) * NANO_TO_MILLI;
        timesAndResults[j][k][1]=result[rng.nextInt(repeatChunk)];
      }
    }
  }
 catch (  Exception e) {
    throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE,e.getMessage());
  }
  final double normFactor=1d / repeatChunk;
  for (int j=0; j < numMethods; j++) {
    for (int k=0; k < repeatStat; k++) {
      timesAndResults[j][k][0]*=normFactor;
    }
  }
  return timesAndResults;
}"
57164,"/** 
 * Timing.
 * @param repeatChunk Each timing measurement will done done for thatnumber of repeats of the code.
 * @param repeatStat Timing will be averaged over that number of runs.
 * @param runGC Call {@code System.gc()} between each timed block. Whenset to  {@code true}, the test will run much slower.
 * @param methods Codes being timed.
 * @return for each of the given {@code methods}, a  {@link StatisticalSummary} of the average times (in milliseconds)taken by a single call to the  {@code call} method (i.e. the timetaken by each timed block divided by  {@code repeatChunk}).
 */
public static StatisticalSummary[] time(int repeatChunk,int repeatStat,boolean runGC,Callable<Double>... methods){
  final double[][][] times=timesAndResults(repeatChunk,repeatStat,runGC,methods);
  final int len=methods.length;
  final StatisticalSummary[] stats=new StatisticalSummary[len];
  for (int j=0; j < len; j++) {
    final SummaryStatistics s=new SummaryStatistics();
    for (int k=0; k < repeatStat; k++) {
      s.addValue(times[j][k][0]);
    }
    stats[j]=s.getSummary();
  }
  return stats;
}","/** 
 * Timing.
 * @param repeatChunk Each timing measurement will done done for thatnumber of repeats of the code.
 * @param repeatStat Timing will be averaged over that number of runs.
 * @param runGC Call {@code System.gc()} between each timed block. Whenset to  {@code true}, the test will run much slower.
 * @param methods Codes being timed.
 * @return for each of the given {@code methods}, a  {@link StatisticalSummary} of the average times (in milliseconds)taken by a single call to the  {@code call} method (i.e. the timetaken by each timed block divided by  {@code repeatChunk}).
 */
@SafeVarargs public static StatisticalSummary[] time(int repeatChunk,int repeatStat,boolean runGC,Callable<Double>... methods){
  final double[][][] times=timesAndResults(repeatChunk,repeatStat,runGC,methods);
  final int len=methods.length;
  final StatisticalSummary[] stats=new StatisticalSummary[len];
  for (int j=0; j < len; j++) {
    final SummaryStatistics s=new SummaryStatistics();
    for (int k=0; k < repeatStat; k++) {
      s.addValue(times[j][k][0]);
    }
    stats[j]=s.getSummary();
  }
  return stats;
}"
57165,"public void testIsValid(){
  double[] xval=new double[]{3,4,5,6.5};
  double[] yval=new double[]{-4,-3,-1,2.5};
  double[] zval=new double[]{-12,-8,-5.5,-3,0,2.5};
  double[][][] fval=new double[xval.length][yval.length][zval.length];
  @SuppressWarnings(""String_Node_Str"") TricubicInterpolatingFunction tcf=new TricubicInterpolator().interpolate(xval,yval,zval,fval);
  Assert.assertTrue(tcf.isValidPoint(4,-3,-8));
  Assert.assertTrue(tcf.isValidPoint(5,-3,-8));
  Assert.assertTrue(tcf.isValidPoint(4,-1,-8));
  Assert.assertTrue(tcf.isValidPoint(5,-1,-8));
  Assert.assertTrue(tcf.isValidPoint(4,-3,0));
  Assert.assertTrue(tcf.isValidPoint(5,-3,0));
  Assert.assertTrue(tcf.isValidPoint(4,-1,0));
  Assert.assertTrue(tcf.isValidPoint(5,-1,0));
  Assert.assertFalse(tcf.isValidPoint(3.5,-3,-8));
  Assert.assertFalse(tcf.isValidPoint(4.5,-3.1,-8));
  Assert.assertFalse(tcf.isValidPoint(4.5,-2,0));
  Assert.assertFalse(tcf.isValidPoint(4.5,0,-3.5));
  Assert.assertFalse(tcf.isValidPoint(-10,4.1,-1));
}","public void testIsValid(){
  double[] xval=new double[]{3,4,5,6.5};
  double[] yval=new double[]{-4,-3,-1,2.5};
  double[] zval=new double[]{-12,-8,-5.5,-3,0,2.5};
  double[][][] fval=new double[xval.length][yval.length][zval.length];
  TricubicInterpolatingFunction tcf=new TricubicInterpolator().interpolate(xval,yval,zval,fval);
  Assert.assertTrue(tcf.isValidPoint(4,-3,-8));
  Assert.assertTrue(tcf.isValidPoint(5,-3,-8));
  Assert.assertTrue(tcf.isValidPoint(4,-1,-8));
  Assert.assertTrue(tcf.isValidPoint(5,-1,-8));
  Assert.assertTrue(tcf.isValidPoint(4,-3,0));
  Assert.assertTrue(tcf.isValidPoint(5,-3,0));
  Assert.assertTrue(tcf.isValidPoint(4,-1,0));
  Assert.assertTrue(tcf.isValidPoint(5,-1,0));
  Assert.assertFalse(tcf.isValidPoint(3.5,-3,-8));
  Assert.assertFalse(tcf.isValidPoint(4.5,-3.1,-8));
  Assert.assertFalse(tcf.isValidPoint(4.5,-2,0));
  Assert.assertFalse(tcf.isValidPoint(4.5,0,-3.5));
  Assert.assertFalse(tcf.isValidPoint(-10,4.1,-1));
}"
57166,"@Test public void testIsometry() throws MathArithmeticException, MathIllegalArgumentException {
  Vector3D vertex1=new Vector3D(1.1,2.2,3.3);
  Vector3D vertex2=new Vector3D(2.0,2.4,4.2);
  Vector3D vertex3=new Vector3D(2.8,3.3,3.7);
  Vector3D vertex4=new Vector3D(1.0,3.6,4.5);
  @SuppressWarnings(""String_Node_Str"") PolyhedronsSet tree=(PolyhedronsSet)new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3,vertex2,vertex1,1.0e-10),new Plane(vertex2,vertex3,vertex4,1.0e-10),new Plane(vertex4,vertex3,vertex1,1.0e-10),new Plane(vertex1,vertex2,vertex4,1.0e-10));
  Vector3D barycenter=(Vector3D)tree.getBarycenter();
  Vector3D s=new Vector3D(10.2,4.3,-6.7);
  Vector3D c=new Vector3D(-0.2,2.1,-3.2);
  Rotation r=new Rotation(new Vector3D(6.2,-4.4,2.1),0.12);
  tree=tree.rotate(c,r).translate(s);
  Vector3D newB=new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(barycenter.subtract(c)));
  Assert.assertEquals(0.0,newB.subtract((Vector<Euclidean3D>)tree.getBarycenter()).getNorm(),1.0e-10);
  final Vector3D[] expectedV=new Vector3D[]{new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex1.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex2.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex3.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex4.subtract(c)))};
  tree.getTree(true).visit(new BSPTreeVisitor<Euclidean3D>(){
    public Order visitOrder(    BSPTree<Euclidean3D> node){
      return Order.MINUS_SUB_PLUS;
    }
    public void visitInternalNode(    BSPTree<Euclidean3D> node){
      @SuppressWarnings(""String_Node_Str"") BoundaryAttribute<Euclidean3D> attribute=(BoundaryAttribute<Euclidean3D>)node.getAttribute();
      if (attribute.getPlusOutside() != null) {
        checkFacet((SubPlane)attribute.getPlusOutside());
      }
      if (attribute.getPlusInside() != null) {
        checkFacet((SubPlane)attribute.getPlusInside());
      }
    }
    public void visitLeafNode(    BSPTree<Euclidean3D> node){
    }
    private void checkFacet(    SubPlane facet){
      Plane plane=(Plane)facet.getHyperplane();
      Vector2D[][] vertices=((PolygonsSet)facet.getRemainingRegion()).getVertices();
      Assert.assertEquals(1,vertices.length);
      for (int i=0; i < vertices[0].length; ++i) {
        Vector3D v=plane.toSpace(vertices[0][i]);
        double d=Double.POSITIVE_INFINITY;
        for (int k=0; k < expectedV.length; ++k) {
          d=FastMath.min(d,v.subtract(expectedV[k]).getNorm());
        }
        Assert.assertEquals(0,d,1.0e-10);
      }
    }
  }
);
}","@Test public void testIsometry() throws MathArithmeticException, MathIllegalArgumentException {
  Vector3D vertex1=new Vector3D(1.1,2.2,3.3);
  Vector3D vertex2=new Vector3D(2.0,2.4,4.2);
  Vector3D vertex3=new Vector3D(2.8,3.3,3.7);
  Vector3D vertex4=new Vector3D(1.0,3.6,4.5);
  PolyhedronsSet tree=(PolyhedronsSet)new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3,vertex2,vertex1,1.0e-10),new Plane(vertex2,vertex3,vertex4,1.0e-10),new Plane(vertex4,vertex3,vertex1,1.0e-10),new Plane(vertex1,vertex2,vertex4,1.0e-10));
  Vector3D barycenter=(Vector3D)tree.getBarycenter();
  Vector3D s=new Vector3D(10.2,4.3,-6.7);
  Vector3D c=new Vector3D(-0.2,2.1,-3.2);
  Rotation r=new Rotation(new Vector3D(6.2,-4.4,2.1),0.12);
  tree=tree.rotate(c,r).translate(s);
  Vector3D newB=new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(barycenter.subtract(c)));
  Assert.assertEquals(0.0,newB.subtract((Vector<Euclidean3D>)tree.getBarycenter()).getNorm(),1.0e-10);
  final Vector3D[] expectedV=new Vector3D[]{new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex1.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex2.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex3.subtract(c))),new Vector3D(1.0,s,1.0,c,1.0,r.applyTo(vertex4.subtract(c)))};
  tree.getTree(true).visit(new BSPTreeVisitor<Euclidean3D>(){
    public Order visitOrder(    BSPTree<Euclidean3D> node){
      return Order.MINUS_SUB_PLUS;
    }
    public void visitInternalNode(    BSPTree<Euclidean3D> node){
      @SuppressWarnings(""String_Node_Str"") BoundaryAttribute<Euclidean3D> attribute=(BoundaryAttribute<Euclidean3D>)node.getAttribute();
      if (attribute.getPlusOutside() != null) {
        checkFacet((SubPlane)attribute.getPlusOutside());
      }
      if (attribute.getPlusInside() != null) {
        checkFacet((SubPlane)attribute.getPlusInside());
      }
    }
    public void visitLeafNode(    BSPTree<Euclidean3D> node){
    }
    private void checkFacet(    SubPlane facet){
      Plane plane=(Plane)facet.getHyperplane();
      Vector2D[][] vertices=((PolygonsSet)facet.getRemainingRegion()).getVertices();
      Assert.assertEquals(1,vertices.length);
      for (int i=0; i < vertices[0].length; ++i) {
        Vector3D v=plane.toSpace(vertices[0][i]);
        double d=Double.POSITIVE_INFINITY;
        for (int k=0; k < expectedV.length; ++k) {
          d=FastMath.min(d,v.subtract(expectedV[k]).getNorm());
        }
        Assert.assertEquals(0,d,1.0e-10);
      }
    }
  }
);
}"
57167,"@Test public void testTetrahedron() throws MathArithmeticException {
  Vector3D vertex1=new Vector3D(1,2,3);
  Vector3D vertex2=new Vector3D(2,2,4);
  Vector3D vertex3=new Vector3D(2,3,3);
  Vector3D vertex4=new Vector3D(1,3,4);
  @SuppressWarnings(""String_Node_Str"") PolyhedronsSet tree=(PolyhedronsSet)new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3,vertex2,vertex1,1.0e-10),new Plane(vertex2,vertex3,vertex4,1.0e-10),new Plane(vertex4,vertex3,vertex1,1.0e-10),new Plane(vertex1,vertex2,vertex4,1.0e-10));
  Assert.assertEquals(1.0 / 3.0,tree.getSize(),1.0e-10);
  Assert.assertEquals(2.0 * FastMath.sqrt(3.0),tree.getBoundarySize(),1.0e-10);
  Vector3D barycenter=(Vector3D)tree.getBarycenter();
  Assert.assertEquals(1.5,barycenter.getX(),1.0e-10);
  Assert.assertEquals(2.5,barycenter.getY(),1.0e-10);
  Assert.assertEquals(3.5,barycenter.getZ(),1.0e-10);
  double third=1.0 / 3.0;
  checkPoints(Region.Location.BOUNDARY,tree,new Vector3D[]{vertex1,vertex2,vertex3,vertex4,new Vector3D(third,vertex1,third,vertex2,third,vertex3),new Vector3D(third,vertex2,third,vertex3,third,vertex4),new Vector3D(third,vertex3,third,vertex4,third,vertex1),new Vector3D(third,vertex4,third,vertex1,third,vertex2)});
  checkPoints(Region.Location.OUTSIDE,tree,new Vector3D[]{new Vector3D(1,2,4),new Vector3D(2,2,3),new Vector3D(2,3,4),new Vector3D(1,3,3)});
}","@Test public void testTetrahedron() throws MathArithmeticException {
  Vector3D vertex1=new Vector3D(1,2,3);
  Vector3D vertex2=new Vector3D(2,2,4);
  Vector3D vertex3=new Vector3D(2,3,3);
  Vector3D vertex4=new Vector3D(1,3,4);
  PolyhedronsSet tree=(PolyhedronsSet)new RegionFactory<Euclidean3D>().buildConvex(new Plane(vertex3,vertex2,vertex1,1.0e-10),new Plane(vertex2,vertex3,vertex4,1.0e-10),new Plane(vertex4,vertex3,vertex1,1.0e-10),new Plane(vertex1,vertex2,vertex4,1.0e-10));
  Assert.assertEquals(1.0 / 3.0,tree.getSize(),1.0e-10);
  Assert.assertEquals(2.0 * FastMath.sqrt(3.0),tree.getBoundarySize(),1.0e-10);
  Vector3D barycenter=(Vector3D)tree.getBarycenter();
  Assert.assertEquals(1.5,barycenter.getX(),1.0e-10);
  Assert.assertEquals(2.5,barycenter.getY(),1.0e-10);
  Assert.assertEquals(3.5,barycenter.getZ(),1.0e-10);
  double third=1.0 / 3.0;
  checkPoints(Region.Location.BOUNDARY,tree,new Vector3D[]{vertex1,vertex2,vertex3,vertex4,new Vector3D(third,vertex1,third,vertex2,third,vertex3),new Vector3D(third,vertex2,third,vertex3,third,vertex4),new Vector3D(third,vertex3,third,vertex4,third,vertex1),new Vector3D(third,vertex4,third,vertex1,third,vertex2)});
  checkPoints(Region.Location.OUTSIDE,tree,new Vector3D[]{new Vector3D(1,2,4),new Vector3D(2,2,3),new Vector3D(2,3,4),new Vector3D(1,3,3)});
}"
57168,"/** 
 * Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default.
 * @return the maximum absolute error in inverse cumulative probability estimates
 */
protected double getSolverAbsoluteAccuracy(){
  return solverAbsoluteAccuracy;
}","/** 
 * Returns the solver absolute accuracy for inverse cumulative computation. You can override this method in order to use a Brent solver with an absolute accuracy different from the default.
 * @return the maximum absolute error in inverse cumulative probability estimates
 */
protected double getSolverAbsoluteAccuracy(){
  return SOLVER_DEFAULT_ABSOLUTE_ACCURACY;
}"
57169,"/** 
 * Internal helper method for exponential function.
 * @param x original argument of the exponential function
 * @param extra extra bits of precision on input (To Be Confirmed)
 * @param hiPrec extra bits of precision on output (To Be Confirmed)
 * @return exp(x)
 */
private static double exp(double x,double extra,double[] hiPrec){
  double intPartA;
  double intPartB;
  int intVal;
  System.out.println(""String_Node_Str"" + x + ""String_Node_Str"");
  if (x < 0.0) {
    intVal=(int)-x;
    System.out.println(""String_Node_Str"" + intVal);
    if (intVal > 746) {
      if (hiPrec != null) {
        hiPrec[0]=0.0;
        hiPrec[1]=0.0;
      }
      return 0.0;
    }
    if (intVal > 709) {
      final double result=exp(x + 40.19140625,extra,hiPrec) / 285040095144011776.0;
      if (hiPrec != null) {
        hiPrec[0]/=285040095144011776.0;
        hiPrec[1]/=285040095144011776.0;
      }
      return result;
    }
    if (intVal == 709) {
      final double result=exp(x + 1.494140625,extra,hiPrec) / 4.455505956692756620;
      if (hiPrec != null) {
        hiPrec[0]/=4.455505956692756620;
        hiPrec[1]/=4.455505956692756620;
      }
      return result;
    }
    intVal++;
    intPartA=ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX - intVal];
    intPartB=ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX - intVal];
    intVal=-intVal;
  }
 else {
    intVal=(int)x;
    if (intVal > 709) {
      if (hiPrec != null) {
        hiPrec[0]=Double.POSITIVE_INFINITY;
        hiPrec[1]=0.0;
      }
      return Double.POSITIVE_INFINITY;
    }
    intPartA=ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal];
    intPartB=ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal];
  }
  final int intFrac=(int)((x - intVal) * 1024.0);
  final double fracPartA=ExpFracTable.EXP_FRAC_TABLE_A[intFrac];
  final double fracPartB=ExpFracTable.EXP_FRAC_TABLE_B[intFrac];
  final double epsilon=x - (intVal + intFrac / 1024.0);
  double z=0.04168701738764507;
  z=z * epsilon + 0.1666666505023083;
  z=z * epsilon + 0.5000000000042687;
  z=z * epsilon + 1.0;
  z=z * epsilon + -3.940510424527919E-20;
  double tempA=intPartA * fracPartA;
  double tempB=intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;
  final double tempC=tempB + tempA;
  final double result;
  if (extra != 0.0) {
    result=tempC * extra * z + tempC * extra + tempC * z + tempB + tempA;
  }
 else {
    result=tempC * z + tempB + tempA;
  }
  if (hiPrec != null) {
    hiPrec[0]=tempA;
    hiPrec[1]=tempC * extra * z + tempC * extra + tempC * z + tempB;
  }
  return result;
}","/** 
 * Internal helper method for exponential function.
 * @param x original argument of the exponential function
 * @param extra extra bits of precision on input (To Be Confirmed)
 * @param hiPrec extra bits of precision on output (To Be Confirmed)
 * @return exp(x)
 */
private static double exp(double x,double extra,double[] hiPrec){
  double intPartA;
  double intPartB;
  int intVal;
  if (x < 0.0) {
    intVal=(int)-x;
    if (intVal > 746) {
      if (hiPrec != null) {
        hiPrec[0]=0.0;
        hiPrec[1]=0.0;
      }
      return 0.0;
    }
    if (intVal > 709) {
      final double result=exp(x + 40.19140625,extra,hiPrec) / 285040095144011776.0;
      if (hiPrec != null) {
        hiPrec[0]/=285040095144011776.0;
        hiPrec[1]/=285040095144011776.0;
      }
      return result;
    }
    if (intVal == 709) {
      final double result=exp(x + 1.494140625,extra,hiPrec) / 4.455505956692756620;
      if (hiPrec != null) {
        hiPrec[0]/=4.455505956692756620;
        hiPrec[1]/=4.455505956692756620;
      }
      return result;
    }
    intVal++;
    intPartA=ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX - intVal];
    intPartB=ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX - intVal];
    intVal=-intVal;
  }
 else {
    intVal=(int)x;
    if (intVal > 709) {
      if (hiPrec != null) {
        hiPrec[0]=Double.POSITIVE_INFINITY;
        hiPrec[1]=0.0;
      }
      return Double.POSITIVE_INFINITY;
    }
    intPartA=ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal];
    intPartB=ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal];
  }
  final int intFrac=(int)((x - intVal) * 1024.0);
  final double fracPartA=ExpFracTable.EXP_FRAC_TABLE_A[intFrac];
  final double fracPartB=ExpFracTable.EXP_FRAC_TABLE_B[intFrac];
  final double epsilon=x - (intVal + intFrac / 1024.0);
  double z=0.04168701738764507;
  z=z * epsilon + 0.1666666505023083;
  z=z * epsilon + 0.5000000000042687;
  z=z * epsilon + 1.0;
  z=z * epsilon + -3.940510424527919E-20;
  double tempA=intPartA * fracPartA;
  double tempB=intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;
  final double tempC=tempB + tempA;
  final double result;
  if (extra != 0.0) {
    result=tempC * extra * z + tempC * extra + tempC * z + tempB + tempA;
  }
 else {
    result=tempC * z + tempB + tempA;
  }
  if (hiPrec != null) {
    hiPrec[0]=tempA;
    hiPrec[1]=tempC * extra * z + tempC * extra + tempC * z + tempB;
  }
  return result;
}"
57170,"/** 
 * Optimize an objective function. Optimization is considered to be a weighted least-squares minimization. The cost function to be minimized is <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>
 * @param f Objective function.
 * @param target Target value for the objective functions at optimum.
 * @param weights Weights for the least squares cost computation.
 * @param startPoint Start point for optimization.
 * @return the point/value pair giving the optimal value for objectivefunction.
 * @param maxEval Maximum number of function evaluations.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong.
 * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.
 * @throws org.apache.commons.math3.exception.NullArgumentException ifany argument is  {@code null}.
 * @deprecated As of 3.1. Please use{@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[]) optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}instead.
 */
@Deprecated public PointVectorValuePair optimize(final int maxEval,final MultivariateDifferentiableVectorFunction f,final double[] target,final double[] weights,final double[] startPoint){
  return optimizeInternal(maxEval,f,new Target(target),new Weight(weights),new InitialGuess(startPoint));
}","/** 
 * Optimize an objective function. Optimization is considered to be a weighted least-squares minimization. The cost function to be minimized is <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>
 * @param f Objective function.
 * @param target Target value for the objective functions at optimum.
 * @param weights Weights for the least squares cost computation.
 * @param startPoint Start point for optimization.
 * @return the point/value pair giving the optimal value for objectivefunction.
 * @param maxEval Maximum number of function evaluations.
 * @throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong.
 * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.
 * @throws org.apache.commons.math3.exception.NullArgumentException ifany argument is  {@code null}.
 * @deprecated As of 3.1. Please use{@link BaseAbstractMultivariateVectorOptimizer#optimize(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,OptimizationData[]) optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}instead.
 */
@Deprecated public PointVectorValuePair optimize(final int maxEval,final MultivariateDifferentiableVectorFunction f,final double[] target,final double[] weights,final double[] startPoint){
  return optimizeInternal(maxEval,f,new Target(target),new Weight(weights),new InitialGuess(startPoint));
}"
57171,"/** 
 * Optimize an objective function. Optimization is considered to be a weighted least-squares minimization. The cost function to be minimized is <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>
 * @param maxEval Allowed number of evaluations of the objective function.
 * @param f Objective function.
 * @param optData Optimization data. The following data will be looked for:<ul> <li> {@link Target}</li> <li>  {@link Weight}</li> <li>  {@link InitialGuess}</li> </ul>
 * @return the point/value pair giving the optimal value of the objectivefunction.
 * @throws org.apache.commons.math3.exception.TooManyEvaluationsException ifthe maximal number of evaluations is exceeded.
 * @throws DimensionMismatchException if the target, and weight argumentshave inconsistent dimensions.
 * @see BaseAbstractMultivariateVectorOptimizer#optimizeInternal(int,MultivariateVectorFunction,OptimizationData[])
 * @since 3.1
 * @deprecated As of 3.1. Override is necessary only until this class's genericargument is changed to  {@code MultivariateDifferentiableVectorFunction}.
 */
@Deprecated protected PointVectorValuePair optimizeInternal(final int maxEval,final MultivariateDifferentiableVectorFunction f,OptimizationData... optData){
  return super.optimizeInternal(maxEval,FunctionUtils.toDifferentiableMultivariateVectorFunction(f),optData);
}","/** 
 * Optimize an objective function. Optimization is considered to be a weighted least-squares minimization. The cost function to be minimized is <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>
 * @param maxEval Allowed number of evaluations of the objective function.
 * @param f Objective function.
 * @param optData Optimization data. The following data will be looked for:<ul> <li> {@link Target}</li> <li>  {@link Weight}</li> <li>  {@link InitialGuess}</li> </ul>
 * @return the point/value pair giving the optimal value of the objectivefunction.
 * @throws org.apache.commons.math3.exception.TooManyEvaluationsException ifthe maximal number of evaluations is exceeded.
 * @throws DimensionMismatchException if the target, and weight argumentshave inconsistent dimensions.
 * @see BaseAbstractMultivariateVectorOptimizer#optimizeInternal(int,org.apache.commons.math3.analysis.MultivariateVectorFunction,OptimizationData[])
 * @since 3.1
 * @deprecated As of 3.1. Override is necessary only until this class's genericargument is changed to  {@code MultivariateDifferentiableVectorFunction}.
 */
@Deprecated protected PointVectorValuePair optimizeInternal(final int maxEval,final MultivariateDifferentiableVectorFunction f,OptimizationData... optData){
  return super.optimizeInternal(maxEval,FunctionUtils.toDifferentiableMultivariateVectorFunction(f),optData);
}"
57172,"public Optimum optimize(final LeastSquaresProblem lsp){
  final Incrementor evaluationCounter=lsp.getEvaluationCounter();
  final Incrementor iterationCounter=lsp.getIterationCounter();
  final ConvergenceChecker<Evaluation> checker=lsp.getConvergenceChecker();
  if (checker == null) {
    throw new NullArgumentException();
  }
  final int nR=lsp.getObservationSize();
  final int nC=lsp.getParameterSize();
  final RealVector currentPoint=lsp.getStart();
  Evaluation current=null;
  while (true) {
    iterationCounter.incrementCount();
    Evaluation previous=current;
    evaluationCounter.incrementCount();
    current=lsp.evaluate(currentPoint);
    final RealVector currentResiduals=current.computeResiduals();
    final RealMatrix weightedJacobian=current.computeJacobian();
    if (previous != null) {
      if (checker.converged(iterationCounter.getCount(),previous,current)) {
        return new OptimumImpl(current,evaluationCounter.getCount(),iterationCounter.getCount());
      }
    }
    final double[] b=new double[nC];
    final double[][] a=new double[nC][nC];
    for (int i=0; i < nR; ++i) {
      final double[] grad=weightedJacobian.getRow(i);
      final double residual=currentResiduals.getEntry(i);
      for (int j=0; j < nC; ++j) {
        b[j]+=residual * grad[j];
      }
      for (int k=0; k < nC; ++k) {
        double[] ak=a[k];
        for (int l=0; l < nC; ++l) {
          ak[l]+=grad[k] * grad[l];
        }
      }
    }
    try {
      RealMatrix mA=new BlockRealMatrix(a);
      DecompositionSolver solver=this.decomposition.getSolver(mA);
      final RealVector dX=solver.solve(new ArrayRealVector(b,false));
      for (int i=0; i < nC; ++i) {
        currentPoint.setEntry(i,currentPoint.getEntry(i) + dX.getEntry(i));
      }
    }
 catch (    SingularMatrixException e) {
      throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
    }
  }
}","/** 
 * {@inheritDoc} 
 */
public Optimum optimize(final LeastSquaresProblem lsp){
  final Incrementor evaluationCounter=lsp.getEvaluationCounter();
  final Incrementor iterationCounter=lsp.getIterationCounter();
  final ConvergenceChecker<Evaluation> checker=lsp.getConvergenceChecker();
  if (checker == null) {
    throw new NullArgumentException();
  }
  final int nR=lsp.getObservationSize();
  final int nC=lsp.getParameterSize();
  final RealVector currentPoint=lsp.getStart();
  Evaluation current=null;
  while (true) {
    iterationCounter.incrementCount();
    Evaluation previous=current;
    evaluationCounter.incrementCount();
    current=lsp.evaluate(currentPoint);
    final RealVector currentResiduals=current.computeResiduals();
    final RealMatrix weightedJacobian=current.computeJacobian();
    if (previous != null) {
      if (checker.converged(iterationCounter.getCount(),previous,current)) {
        return new OptimumImpl(current,evaluationCounter.getCount(),iterationCounter.getCount());
      }
    }
    final double[] b=new double[nC];
    final double[][] a=new double[nC][nC];
    for (int i=0; i < nR; ++i) {
      final double[] grad=weightedJacobian.getRow(i);
      final double residual=currentResiduals.getEntry(i);
      for (int j=0; j < nC; ++j) {
        b[j]+=residual * grad[j];
      }
      for (int k=0; k < nC; ++k) {
        double[] ak=a[k];
        for (int l=0; l < nC; ++l) {
          ak[l]+=grad[k] * grad[l];
        }
      }
    }
    try {
      RealMatrix mA=new BlockRealMatrix(a);
      DecompositionSolver solver=this.decomposition.getSolver(mA);
      final RealVector dX=solver.solve(new ArrayRealVector(b,false));
      for (int i=0; i < nC; ++i) {
        currentPoint.setEntry(i,currentPoint.getEntry(i) + dX.getEntry(i));
      }
    }
 catch (    SingularMatrixException e) {
      throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
    }
  }
}"
57173,"public RealVector getPoint(){
  return this.point;
}","/** 
 * {@inheritDoc} 
 */
public RealVector getPoint(){
  return this.point;
}"
57174,"public int getObservationSize(){
  return target.getDimension();
}","/** 
 * {@inheritDoc} 
 */
public int getObservationSize(){
  return target.getDimension();
}"
57175,"public RealVector getStart(){
  return start == null ? null : start.copy();
}","/** 
 * {@inheritDoc} 
 */
public RealVector getStart(){
  return start == null ? null : start.copy();
}"
57176,"public int getParameterSize(){
  return start.getDimension();
}","/** 
 * {@inheritDoc} 
 */
public int getParameterSize(){
  return start.getDimension();
}"
57177,"private UnweightedEvaluation(final RealVector values,final RealMatrix jacobian,final RealVector target,final RealVector point){
  super(target.getDimension());
  this.values=values;
  this.jacobian=jacobian;
  this.target=target;
  this.point=point;
}","/** 
 * Create an   {@link Evaluation} with no weights.
 * @param values   the computed function values
 * @param jacobian the computed function Jacobian
 * @param target   the observed values
 * @param point    the abscissa
 */
private UnweightedEvaluation(final RealVector values,final RealMatrix jacobian,final RealVector target,final RealVector point){
  super(target.getDimension());
  this.values=values;
  this.jacobian=jacobian;
  this.target=target;
  this.point=point;
}"
57178,"LeastSquaresProblemImpl(final MultivariateJacobianFunction model,final RealVector target,final RealVector start,final ConvergenceChecker<Evaluation> checker,final int maxEvaluations,final int maxIterations){
  super(maxEvaluations,maxIterations,checker);
  this.target=target;
  this.model=model;
  this.start=start;
}","/** 
 * Create a   {@link LeastSquaresProblem} from the given data.
 * @param model          the model function
 * @param target         the observed data
 * @param start          the initial guess
 * @param checker        the convergence checker
 * @param maxEvaluations the allowed evaluations
 * @param maxIterations  the allowed iterations
 */
LeastSquaresProblemImpl(final MultivariateJacobianFunction model,final RealVector target,final RealVector start,final ConvergenceChecker<Evaluation> checker,final int maxEvaluations,final int maxIterations){
  super(maxEvaluations,maxIterations,checker);
  this.target=target;
  this.model=model;
  this.start=start;
}"
57179,"public RealVector computeValue(){
  return this.values;
}","/** 
 * {@inheritDoc} 
 */
public RealVector computeValue(){
  return this.values;
}"
57180,"public RealVector computeResiduals(){
  return target.subtract(this.computeValue());
}","/** 
 * {@inheritDoc} 
 */
public RealVector computeResiduals(){
  return target.subtract(this.computeValue());
}"
57181,"public Evaluation evaluate(final RealVector point){
  final Pair<RealVector,RealMatrix> value=this.model.value(point);
  return new UnweightedEvaluation(value.getFirst(),value.getSecond(),this.target,point);
}","/** 
 * {@inheritDoc} 
 */
public Evaluation evaluate(final RealVector point){
  final Pair<RealVector,RealMatrix> value=this.model.value(point);
  return new UnweightedEvaluation(value.getFirst(),value.getSecond(),this.target,point);
}"
57182,"public RealMatrix computeJacobian(){
  return this.jacobian;
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix computeJacobian(){
  return this.jacobian;
}"
57183,"/** 
 * Get a independent Incrementor that counts up to   {@link #getMaxEvaluations()} andthen throws an exception.
 * @return a counter for the evaluations.
 */
Incrementor getEvaluationCounter();","/** 
 * Get a independent Incrementor that counts up to the maximum number of evaluations and then throws an exception.
 * @return a counter for the evaluations.
 */
Incrementor getEvaluationCounter();"
57184,"/** 
 * Get a independent Incrementor that counts up to   {@link #getMaxIterations()} andthen throws an exception.
 * @return a counter for the evaluations.
 */
Incrementor getIterationCounter();","/** 
 * Get a independent Incrementor that counts up to the maximum number of iterations and then throws an exception.
 * @return a counter for the evaluations.
 */
Incrementor getIterationCounter();"
57185,"public Incrementor getEvaluationCounter(){
  return new Incrementor(this.maxEvaluations,MAX_EVAL_CALLBACK);
}","/** 
 * {@inheritDoc} 
 */
public Incrementor getEvaluationCounter(){
  return new Incrementor(this.maxEvaluations,MAX_EVAL_CALLBACK);
}"
57186,"public ConvergenceChecker<PAIR> getConvergenceChecker(){
  return checker;
}","/** 
 * {@inheritDoc} 
 */
public ConvergenceChecker<PAIR> getConvergenceChecker(){
  return checker;
}"
57187,"protected AbstractOptimizationProblem(final int maxEvaluations,final int maxIterations,final ConvergenceChecker<PAIR> checker){
  this.maxEvaluations=maxEvaluations;
  this.maxIterations=maxIterations;
  this.checker=checker;
}","/** 
 * Create an   {@link AbstractOptimizationProblem} from the given data.
 * @param maxEvaluations the number of allowed model function evaluations.
 * @param maxIterations  the number of allowed iterations.
 * @param checker        the convergence checker.
 */
protected AbstractOptimizationProblem(final int maxEvaluations,final int maxIterations,final ConvergenceChecker<PAIR> checker){
  this.maxEvaluations=maxEvaluations;
  this.maxIterations=maxIterations;
  this.checker=checker;
}"
57188,"public Incrementor getIterationCounter(){
  return new Incrementor(this.maxIterations,MAX_ITER_CALLBACK);
}","/** 
 * {@inheritDoc} 
 */
public Incrementor getIterationCounter(){
  return new Incrementor(this.maxIterations,MAX_ITER_CALLBACK);
}"
57189,"/** 
 * Fits a curve. This method computes the coefficients of the curve that best fit the sample of observed points.
 * @param points Observations.
 * @return the fitted parameters.
 */
public double[] fit(Collection<WeightedObservedPoint> points){
  return getOptimizer().optimize(getProblem(points)).getPoint();
}","/** 
 * Fits a curve. This method computes the coefficients of the curve that best fit the sample of observed points.
 * @param points Observations.
 * @return the fitted parameters.
 */
public double[] fit(Collection<WeightedObservedPoint> points){
  return getOptimizer().optimize(getProblem(points)).getPoint().toArray();
}"
57190,"/** 
 * {@inheritDoc} 
 */
@Override protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> observations){
  final int len=observations.size();
  final double[] target=new double[len];
  final double[] weights=new double[len];
  int i=0;
  for (  WeightedObservedPoint obs : observations) {
    target[i]=obs.getY();
    weights[i]=obs.getWeight();
    ++i;
  }
  final AbstractCurveFitter.TheoreticalValuesFunction model=new AbstractCurveFitter.TheoreticalValuesFunction(FUNCTION,observations);
  final double[] startPoint=initialGuess != null ? initialGuess : new ParameterGuesser(observations).guess();
  return new LeastSquaresBuilder().maxEvaluations(Integer.MAX_VALUE).maxIterations(maxIter).start(startPoint).target(target).weight(new DiagonalMatrix(weights)).model(model.getModelFunction()).jacobian(model.getModelFunctionJacobian()).build();
}","/** 
 * {@inheritDoc} 
 */
@Override protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> observations){
  final int len=observations.size();
  final double[] target=new double[len];
  final double[] weights=new double[len];
  int i=0;
  for (  WeightedObservedPoint obs : observations) {
    target[i]=obs.getY();
    weights[i]=obs.getWeight();
    ++i;
  }
  final AbstractCurveFitter.TheoreticalValuesFunction model=new AbstractCurveFitter.TheoreticalValuesFunction(FUNCTION,observations);
  final double[] startPoint=initialGuess != null ? initialGuess : new ParameterGuesser(observations).guess();
  return new LeastSquaresBuilder().maxEvaluations(Integer.MAX_VALUE).maxIterations(maxIter).start(startPoint).target(target).weight(new DiagonalMatrix(weights)).model(model.getModelFunction(),model.getModelFunctionJacobian()).build();
}"
57191,"/** 
 * {@inheritDoc} 
 */
@Override protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> observations){
  final int len=observations.size();
  final double[] target=new double[len];
  final double[] weights=new double[len];
  int i=0;
  for (  WeightedObservedPoint obs : observations) {
    target[i]=obs.getY();
    weights[i]=obs.getWeight();
    ++i;
  }
  final AbstractCurveFitter.TheoreticalValuesFunction model=new AbstractCurveFitter.TheoreticalValuesFunction(FUNCTION,observations);
  final double[] startPoint=initialGuess != null ? initialGuess : new ParameterGuesser(observations).guess();
  return new LeastSquaresBuilder().maxEvaluations(Integer.MAX_VALUE).maxIterations(maxIter).start(startPoint).target(target).weight(new DiagonalMatrix(weights)).model(model.getModelFunction()).jacobian(model.getModelFunctionJacobian()).build();
}","/** 
 * {@inheritDoc} 
 */
@Override protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> observations){
  final int len=observations.size();
  final double[] target=new double[len];
  final double[] weights=new double[len];
  int i=0;
  for (  WeightedObservedPoint obs : observations) {
    target[i]=obs.getY();
    weights[i]=obs.getWeight();
    ++i;
  }
  final AbstractCurveFitter.TheoreticalValuesFunction model=new AbstractCurveFitter.TheoreticalValuesFunction(FUNCTION,observations);
  final double[] startPoint=initialGuess != null ? initialGuess : new ParameterGuesser(observations).guess();
  return new LeastSquaresBuilder().maxEvaluations(Integer.MAX_VALUE).maxIterations(maxIter).start(startPoint).target(target).weight(new DiagonalMatrix(weights)).model(model.getModelFunction(),model.getModelFunctionJacobian()).build();
}"
57192,"/** 
 * {@inheritDoc} 
 */
@Override protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> observations){
  final int len=observations.size();
  final double[] target=new double[len];
  final double[] weights=new double[len];
  int i=0;
  for (  WeightedObservedPoint obs : observations) {
    target[i]=obs.getY();
    weights[i]=obs.getWeight();
    ++i;
  }
  final AbstractCurveFitter.TheoreticalValuesFunction model=new AbstractCurveFitter.TheoreticalValuesFunction(FUNCTION,observations);
  if (initialGuess == null) {
    throw new MathInternalError();
  }
  return new LeastSquaresBuilder().maxEvaluations(Integer.MAX_VALUE).maxIterations(maxIter).start(initialGuess).target(target).weight(new DiagonalMatrix(weights)).model(model.getModelFunction()).jacobian(model.getModelFunctionJacobian()).build();
}","/** 
 * {@inheritDoc} 
 */
@Override protected LeastSquaresProblem getProblem(Collection<WeightedObservedPoint> observations){
  final int len=observations.size();
  final double[] target=new double[len];
  final double[] weights=new double[len];
  int i=0;
  for (  WeightedObservedPoint obs : observations) {
    target[i]=obs.getY();
    weights[i]=obs.getWeight();
    ++i;
  }
  final AbstractCurveFitter.TheoreticalValuesFunction model=new AbstractCurveFitter.TheoreticalValuesFunction(FUNCTION,observations);
  if (initialGuess == null) {
    throw new MathInternalError();
  }
  return new LeastSquaresBuilder().maxEvaluations(Integer.MAX_VALUE).maxIterations(maxIter).start(initialGuess).target(target).weight(new DiagonalMatrix(weights)).model(model.getModelFunction(),model.getModelFunctionJacobian()).build();
}"
57193,"/** 
 * Computes an estimate of the standard deviation of the parameters. The returned values are the square root of the diagonal coefficients of the covariance matrix,   {@code sd(a[i]) ~= sqrt(C[i][i])}, where   {@code a[i]} is the optimizedvalue of the  {@code i}-th parameter, and   {@code C} is the covariance matrix.
 * @param covarianceSingularityThreshold Singularity threshold (see {@link #computeCovariances(double[],double) computeCovariances}).
 * @return an estimate of the standard deviation of the optimized parameters
 * @throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed.
 */
double[] computeSigma(double covarianceSingularityThreshold);","/** 
 * Computes an estimate of the standard deviation of the parameters. The returned values are the square root of the diagonal coefficients of the covariance matrix,   {@code sd(a[i]) ~= sqrt(C[i][i])}, where   {@code a[i]} is the optimizedvalue of the  {@code i}-th parameter, and   {@code C} is the covariance matrix.
 * @param covarianceSingularityThreshold Singularity threshold (see {@link #computeCovariances(double) computeCovariances}).
 * @return an estimate of the standard deviation of the optimized parameters
 * @throws org.apache.commons.math3.linear.SingularMatrixException if the covariance matrix cannot be computed.
 */
double[] computeSigma(double covarianceSingularityThreshold);"
57194,"/** 
 * Computes the objective (model) function value.
 * @return the objective function value at the specified point.
 * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations (of the model vector function) is exceeded.
 */
double[] computeValue();","/** 
 * Computes the objective (model) function value.
 * @return the objective function value at the specified point.
 */
double[] computeValue();"
57195,"/** 
 * Computes the weighted residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function. The raw residuals are then multiplied by the square root of the weight matrix.
 * @return the weighted residuals: W<sup>1/2</sup> K.
 * @throws DimensionMismatchException if {@code params} has a wrong length.
 */
double[] computeResiduals();","/** 
 * Computes the weighted residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function. The raw residuals are then multiplied by the square root of the weight matrix.
 * @return the weighted residuals: W<sup>1/2</sup> K.
 * @throws DimensionMismatchException if the residuals have the wrong length.
 */
double[] computeResiduals();"
57196,"/** 
 * Evaluate the model at the specified point.
 * @param point the parameter values.
 * @return the model's value and derivative at the given point.
 */
Evaluation evaluate(double[] point);","/** 
 * Evaluate the model at the specified point.
 * @param point the parameter values.
 * @return the model's value and derivative at the given point.
 * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations (of the model vector function) is exceeded.
 */
Evaluation evaluate(double[] point);"
57197,"/** 
 * Computes the cost.
 * @return the cost.
 * @see #computeResiduals(double[])
 */
double computeCost();","/** 
 * Computes the cost.
 * @return the cost.
 * @see #computeResiduals()
 */
double computeCost();"
57198,"/** 
 * Create a split part.
 * @param tree BSP tree containing the limit angles of the split part
 * @return split part (may be null)
 */
private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree){
  if (tree.getCut() == null && !(Boolean)tree.getAttribute()) {
    return null;
  }
 else {
    return new ArcsSet(tree,getTolerance());
  }
}","/** 
 * Create a split part. <p> As per construction, the list of limit angles is known to have an even number of entries, with start angles at even indices and end angles at odd indices. </p>
 * @param limits limit angles of the split part
 * @return split part (may be null)
 */
private ArcsSet createSplitPart(final List<Double> limits){
  if (limits.isEmpty()) {
    return null;
  }
 else {
    for (int i=0; i < limits.size(); ++i) {
      final int j=(i + 1) % limits.size();
      final double lA=limits.get(i);
      final double lB=MathUtils.normalizeAngle(limits.get(j),lA);
      if (FastMath.abs(lB - lA) <= getTolerance()) {
        if (j > 0) {
          limits.remove(j);
          limits.remove(i);
          i=i - 1;
        }
 else {
          final double lEnd=limits.remove(limits.size() - 1);
          final double lStart=limits.remove(0);
          if (limits.isEmpty()) {
            if (lEnd - lStart > FastMath.PI) {
              return new ArcsSet(new BSPTree<Sphere1D>(Boolean.TRUE),getTolerance());
            }
 else {
              return null;
            }
          }
 else {
            limits.add(limits.remove(0) + MathUtils.TWO_PI);
          }
        }
      }
    }
    BSPTree<Sphere1D> tree=new BSPTree<Sphere1D>(Boolean.FALSE);
    for (int i=0; i < limits.size() - 1; i+=2) {
      addArcLimit(tree,limits.get(i),true);
      addArcLimit(tree,limits.get(i + 1),false);
    }
    if (tree.getCut() == null) {
      return null;
    }
    return new ArcsSet(tree,getTolerance());
  }
}"
57199,"/** 
 * Split the instance in two parts by an arc.
 * @param arc splitting arc
 * @return an object containing both the part of the instanceon the plus side of the arc and the part of the instance on the minus side of the arc
 */
public Split split(final Arc arc){
  final BSPTree<Sphere1D> minus=new BSPTree<Sphere1D>();
  minus.setAttribute(Boolean.FALSE);
  final BSPTree<Sphere1D> plus=new BSPTree<Sphere1D>();
  plus.setAttribute(Boolean.FALSE);
  final double reference=FastMath.PI + arc.getInf();
  final double arcLength=arc.getSup() - arc.getInf();
  for (  final double[] a : this) {
    final double syncedStart=MathUtils.normalizeAngle(a[0],reference) - arc.getInf();
    final double arcOffset=a[0] - syncedStart;
    final double syncedEnd=a[1] - arcOffset;
    if (syncedStart < arcLength) {
      addArcLimit(minus,a[0],true);
      if (syncedEnd > arcLength) {
        final double minusToPlus=arcLength + arcOffset;
        addArcLimit(minus,minusToPlus,false);
        addArcLimit(plus,minusToPlus,true);
        if (syncedEnd > MathUtils.TWO_PI) {
          final double plusToMinus=MathUtils.TWO_PI + arcOffset;
          addArcLimit(plus,plusToMinus,false);
          addArcLimit(minus,plusToMinus,true);
          addArcLimit(minus,a[1],false);
        }
 else {
          addArcLimit(plus,a[1],false);
        }
      }
 else {
        addArcLimit(minus,a[1],false);
      }
    }
 else {
      addArcLimit(plus,a[0],true);
      if (syncedEnd > MathUtils.TWO_PI) {
        final double plusToMinus=MathUtils.TWO_PI + arcOffset;
        addArcLimit(plus,plusToMinus,false);
        addArcLimit(minus,plusToMinus,true);
        if (syncedEnd > MathUtils.TWO_PI + arcLength) {
          final double minusToPlus=MathUtils.TWO_PI + arcLength + arcOffset;
          addArcLimit(minus,minusToPlus,false);
          addArcLimit(plus,minusToPlus,true);
          addArcLimit(plus,a[1],false);
        }
 else {
          addArcLimit(minus,a[1],false);
        }
      }
 else {
        addArcLimit(plus,a[1],false);
      }
    }
  }
  return new Split(createSplitPart(plus),createSplitPart(minus));
}","/** 
 * Split the instance in two parts by an arc.
 * @param arc splitting arc
 * @return an object containing both the part of the instanceon the plus side of the arc and the part of the instance on the minus side of the arc
 */
public Split split(final Arc arc){
  final List<Double> minus=new ArrayList<Double>();
  final List<Double> plus=new ArrayList<Double>();
  final double reference=FastMath.PI + arc.getInf();
  final double arcLength=arc.getSup() - arc.getInf();
  for (  final double[] a : this) {
    final double syncedStart=MathUtils.normalizeAngle(a[0],reference) - arc.getInf();
    final double arcOffset=a[0] - syncedStart;
    final double syncedEnd=a[1] - arcOffset;
    if (syncedStart < arcLength) {
      minus.add(a[0]);
      if (syncedEnd > arcLength) {
        final double minusToPlus=arcLength + arcOffset;
        minus.add(minusToPlus);
        plus.add(minusToPlus);
        if (syncedEnd > MathUtils.TWO_PI) {
          final double plusToMinus=MathUtils.TWO_PI + arcOffset;
          plus.add(plusToMinus);
          minus.add(plusToMinus);
          minus.add(a[1]);
        }
 else {
          plus.add(a[1]);
        }
      }
 else {
        minus.add(a[1]);
      }
    }
 else {
      plus.add(a[0]);
      if (syncedEnd > MathUtils.TWO_PI) {
        final double plusToMinus=MathUtils.TWO_PI + arcOffset;
        plus.add(plusToMinus);
        minus.add(plusToMinus);
        if (syncedEnd > MathUtils.TWO_PI + arcLength) {
          final double minusToPlus=MathUtils.TWO_PI + arcLength + arcOffset;
          minus.add(minusToPlus);
          plus.add(minusToPlus);
          plus.add(a[1]);
        }
 else {
          minus.add(a[1]);
        }
      }
 else {
        plus.add(a[1]);
      }
    }
  }
  return new Split(createSplitPart(plus),createSplitPart(minus));
}"
57200,"/** 
 * Add an arc limit to a BSP tree under construction.
 * @param tree BSP tree under construction
 * @param alpha arc limit
 * @param isStart if true, the limit is the start of an arc
 */
private void addArcLimit(final BSPTree<Sphere1D> tree,final double alpha,final boolean isStart){
  final LimitAngle limit=new LimitAngle(new S1Point(alpha),!isStart,getTolerance());
  final BSPTree<Sphere1D> node=tree.getCell(limit.getLocation(),getTolerance());
  if (node.getCut() != null) {
    leafBefore(node).setAttribute(Boolean.valueOf(!isStart));
  }
 else {
    node.insertCut(limit);
    node.setAttribute(null);
    node.getPlus().setAttribute(Boolean.FALSE);
    node.getMinus().setAttribute(Boolean.TRUE);
  }
}","/** 
 * Add an arc limit to a BSP tree under construction.
 * @param tree BSP tree under construction
 * @param alpha arc limit
 * @param isStart if true, the limit is the start of an arc
 */
private void addArcLimit(final BSPTree<Sphere1D> tree,final double alpha,final boolean isStart){
  final LimitAngle limit=new LimitAngle(new S1Point(alpha),!isStart,getTolerance());
  final BSPTree<Sphere1D> node=tree.getCell(limit.getLocation(),getTolerance());
  if (node.getCut() != null) {
    throw new MathInternalError();
  }
  node.insertCut(limit);
  node.setAttribute(null);
  node.getPlus().setAttribute(Boolean.FALSE);
  node.getMinus().setAttribute(Boolean.TRUE);
}"
57201,"/** 
 * Compute the relative position of the instance with respect to an arc. <p> The   {@link Side#MINUS} side of the arc is the one covered by the arc.</p>
 * @param arc arc to check instance against
 * @return one of {@link Side#PLUS},   {@link Side#MINUS},   {@link Side#BOTH}or   {@link Side#HYPER}
 */
public Side side(final Arc arc){
  final double reference=FastMath.PI + arc.getInf();
  final double arcLength=arc.getSup() - arc.getInf();
  boolean inMinus=false;
  boolean inPlus=false;
  for (  final double[] a : this) {
    final double syncedStart=MathUtils.normalizeAngle(a[0],reference) - arc.getInf();
    final double arcOffset=a[0] - syncedStart;
    final double syncedEnd=a[1] - arcOffset;
    if (syncedStart < arcLength || syncedEnd > MathUtils.TWO_PI) {
      inMinus=true;
    }
    if (syncedEnd > arcLength) {
      inPlus=true;
    }
  }
  if (inMinus) {
    if (inPlus) {
      return Side.BOTH;
    }
 else {
      return Side.MINUS;
    }
  }
 else {
    if (inPlus) {
      return Side.PLUS;
    }
 else {
      return Side.HYPER;
    }
  }
}","/** 
 * Compute the relative position of the instance with respect to an arc. <p> The   {@link Side#MINUS} side of the arc is the one covered by the arc.</p>
 * @param arc arc to check instance against
 * @return one of {@link Side#PLUS},   {@link Side#MINUS},   {@link Side#BOTH}or   {@link Side#HYPER}
 */
public Side side(final Arc arc){
  final double reference=FastMath.PI + arc.getInf();
  final double arcLength=arc.getSup() - arc.getInf();
  boolean inMinus=false;
  boolean inPlus=false;
  for (  final double[] a : this) {
    final double syncedStart=MathUtils.normalizeAngle(a[0],reference) - arc.getInf();
    final double arcOffset=a[0] - syncedStart;
    final double syncedEnd=a[1] - arcOffset;
    if (syncedStart <= arcLength - getTolerance() || syncedEnd >= MathUtils.TWO_PI + getTolerance()) {
      inMinus=true;
    }
    if (syncedEnd >= arcLength + getTolerance()) {
      inPlus=true;
    }
  }
  if (inMinus) {
    if (inPlus) {
      return Side.BOTH;
    }
 else {
      return Side.MINUS;
    }
  }
 else {
    if (inPlus) {
      return Side.PLUS;
    }
 else {
      return Side.HYPER;
    }
  }
}"
57202,"/** 
 * Simple constructor.
 */
public SubArcsIterator(){
  firstStart=getFirstArcStart();
  current=firstStart;
  if (firstStart == null) {
    if ((Boolean)getTree(false).getAttribute()) {
      pending=new double[]{0,MathUtils.TWO_PI};
    }
 else {
      pending=null;
    }
  }
 else {
    selectPending();
  }
}","/** 
 * Simple constructor.
 */
public SubArcsIterator(){
  firstStart=getFirstArcStart();
  current=firstStart;
  if (firstStart == null) {
    if ((Boolean)getFirstLeaf(getTree(false)).getAttribute()) {
      pending=new double[]{0,MathUtils.TWO_PI};
    }
 else {
      pending=null;
    }
  }
 else {
    selectPending();
  }
}"
57203,"/** 
 * {@inheritDoc} 
 */
public void visitInternalNode(final BSPTree<Sphere2D> node){
  nodeToEdgesList.put(node,new ArrayList<Edge>());
  @SuppressWarnings(""String_Node_Str"") final BoundaryAttribute<Sphere2D> attribute=(BoundaryAttribute<Sphere2D>)node.getAttribute();
  if (attribute.getPlusOutside() != null) {
    addContribution((SubCircle)attribute.getPlusOutside(),false,node);
  }
  if (attribute.getPlusInside() != null) {
    addContribution((SubCircle)attribute.getPlusInside(),true,node);
  }
}","/** 
 * {@inheritDoc} 
 */
public void visitInternalNode(final BSPTree<Sphere2D> node){
}"
57204,"/** 
 * {@inheritDoc}
 * @exception MathIllegalStateException if the tolerance setting does not allow to builda clean non-ambiguous boundary
 */
@Override protected void computeGeometricalProperties() throws MathIllegalStateException {
  final List<Vertex> boundary=getBoundaryLoops();
  if (boundary.isEmpty()) {
    final BSPTree<Sphere2D> tree=getTree(false);
    if (tree.getCut() == null && (Boolean)tree.getAttribute()) {
      setSize(4 * FastMath.PI);
    }
 else {
      setSize(0);
    }
    setBarycenter(new S2Point(0,0));
  }
 else {
    double sumArea=0;
    Vector3D sumB=Vector3D.ZERO;
    for (    final Vertex startVertex : boundary) {
      int n=0;
      double sum=0;
      Vector3D sumP=Vector3D.ZERO;
      for (Edge edge=startVertex.getOutgoing(); n == 0 || edge.getStart() != startVertex; edge=edge.getEnd().getOutgoing()) {
        final Vector3D middle=edge.getPointAt(0.5 * edge.getLength());
        sumP=new Vector3D(1,sumP,edge.getLength(),middle);
        final Vector3D previousPole=edge.getCircle().getPole();
        final Vector3D nextPole=edge.getEnd().getOutgoing().getCircle().getPole();
        final Vector3D point=edge.getEnd().getLocation().getVector();
        double alpha=FastMath.atan2(Vector3D.dotProduct(nextPole,Vector3D.crossProduct(point,previousPole)),-Vector3D.dotProduct(nextPole,previousPole));
        if (alpha < 0) {
          alpha+=MathUtils.TWO_PI;
        }
        sum+=alpha;
        n++;
      }
      final double area=sum - (n - 2) * FastMath.PI;
      sumArea+=area;
      sumB=new Vector3D(1,sumB,area,sumP);
    }
    if (sumArea < 0) {
      sumArea=4 * FastMath.PI - sumArea;
      sumB=sumB.negate();
    }
    setSize(sumArea);
    final double norm=sumB.getNorm();
    if (norm == 0.0) {
      setBarycenter(S2Point.NaN);
    }
 else {
      setBarycenter(new S2Point(new Vector3D(1.0 / norm,sumB)));
    }
  }
}","/** 
 * {@inheritDoc}
 * @exception MathIllegalStateException if the tolerance setting does not allow to builda clean non-ambiguous boundary
 */
@Override protected void computeGeometricalProperties() throws MathIllegalStateException {
  final BSPTree<Sphere2D> tree=getTree(true);
  if (tree.getCut() == null) {
    if (tree.getCut() == null && (Boolean)tree.getAttribute()) {
      setSize(4 * FastMath.PI);
      setBarycenter(new S2Point(0,0));
    }
 else {
      setSize(0);
      setBarycenter(S2Point.NaN);
    }
  }
 else {
    final PropertiesComputer pc=new PropertiesComputer(getTolerance());
    tree.visit(pc);
    setSize(pc.getArea());
    setBarycenter(pc.getBarycenter());
  }
}"
57205,"/** 
 * {@inheritDoc} 
 */
public void visitLeafNode(final BSPTree<Sphere2D> node){
}","/** 
 * {@inheritDoc} 
 */
public void visitLeafNode(final BSPTree<Sphere2D> node){
  if ((Boolean)node.getAttribute()) {
    final SphericalPolygonsSet convex=new SphericalPolygonsSet(node.pruneAroundConvexCell(Boolean.TRUE,Boolean.FALSE,null),tolerance);
    final List<Vertex> boundary=convex.getBoundaryLoops();
    if (boundary.size() != 1) {
      throw new MathInternalError();
    }
    final double area=convexCellArea(boundary.get(0));
    final Vector3D barycenter=convexCellBarycenter(boundary.get(0));
    summedArea+=area;
    summedBarycenter=new Vector3D(1,summedBarycenter,area,barycenter);
  }
}"
57206,"/** 
 * Filter the parts of an hyperplane belonging to the boundary. <p>The filtering consist in splitting the specified sub-hyperplane into several parts lying in inside and outside cells of the tree. The principle is to call this method twice for each cut sub-hyperplane in the tree, once one the plus node and once on the minus node. The parts that have the same flag (inside/inside or outside/outside) do not belong to the boundary while parts that have different flags (inside/outside or outside/inside) do belong to the boundary.</p>
 * @param node current BSP tree node
 * @param sub sub-hyperplane to characterize
 * @param characterization placeholder where to put the characterized parts
 */
private void characterize(final BSPTree<S> node,final SubHyperplane<S> sub,final SubHyperplane<S>[] characterization){
  if (node.getCut() == null) {
    final boolean inside=(Boolean)node.getAttribute();
    if (inside) {
      if (characterization[1] == null) {
        characterization[1]=sub;
      }
 else {
        characterization[1]=characterization[1].reunite(sub);
      }
    }
 else {
      if (characterization[0] == null) {
        characterization[0]=sub;
      }
 else {
        characterization[0]=characterization[0].reunite(sub);
      }
    }
  }
 else {
    final Hyperplane<S> hyperplane=node.getCut().getHyperplane();
switch (sub.side(hyperplane)) {
case PLUS:
      characterize(node.getPlus(),sub,characterization);
    break;
case MINUS:
  characterize(node.getMinus(),sub,characterization);
break;
case BOTH:
final SubHyperplane.SplitSubHyperplane<S> split=sub.split(hyperplane);
characterize(node.getPlus(),split.getPlus(),characterization);
characterize(node.getMinus(),split.getMinus(),characterization);
break;
default :
throw new MathInternalError();
}
}
}","/** 
 * Filter the parts of an hyperplane belonging to the boundary. <p>The filtering consist in splitting the specified sub-hyperplane into several parts lying in inside and outside cells of the tree. The principle is to call this method twice for each cut sub-hyperplane in the tree, once on the plus node and once on the minus node. The parts that have the same flag (inside/inside or outside/outside) do not belong to the boundary while parts that have different flags (inside/outside or outside/inside) do belong to the boundary.</p>
 * @param node current BSP tree node
 * @param sub sub-hyperplane to characterize
 * @param characterization placeholder where to put the characterized parts
 */
private void characterize(final BSPTree<S> node,final SubHyperplane<S> sub,final SubHyperplane<S>[] characterization){
  if (node.getCut() == null) {
    final boolean inside=(Boolean)node.getAttribute();
    if (inside) {
      if (characterization[1] == null) {
        characterization[1]=sub;
      }
 else {
        characterization[1]=characterization[1].reunite(sub);
      }
    }
 else {
      if (characterization[0] == null) {
        characterization[0]=sub;
      }
 else {
        characterization[0]=characterization[0].reunite(sub);
      }
    }
  }
 else {
    final Hyperplane<S> hyperplane=node.getCut().getHyperplane();
switch (sub.side(hyperplane)) {
case PLUS:
      characterize(node.getPlus(),sub,characterization);
    break;
case MINUS:
  characterize(node.getMinus(),sub,characterization);
break;
case BOTH:
final SubHyperplane.SplitSubHyperplane<S> split=sub.split(hyperplane);
characterize(node.getPlus(),split.getPlus(),characterization);
characterize(node.getMinus(),split.getMinus(),characterization);
break;
default :
throw new MathInternalError();
}
}
}"
57207,"/** 
 * Create a split part.
 * @param tree BSP tree containing the limit angles of the split part
 * @param ignored if true, some end points have been ignored previously
 * @return split part (may be null)
 */
private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree,final boolean ignored){
  if (ignored) {
    final BSPTree<Sphere1D> first=getFirstLeaf(tree);
    final boolean firstState=(Boolean)first.getAttribute();
    final BSPTree<Sphere1D> last=getLastLeaf(tree);
    final boolean lastState=(Boolean)last.getAttribute();
    if (firstState ^ lastState) {
      first.insertCut(new LimitAngle(new S1Point(0.0),true,getTolerance()));
      first.getPlus().setAttribute(firstState);
      first.getMinus().setAttribute(lastState);
    }
  }
  if (tree.getCut() == null && !(Boolean)tree.getAttribute()) {
    return null;
  }
 else {
    return new ArcsSet(tree,getTolerance());
  }
}","/** 
 * Create a split part.
 * @param tree BSP tree containing the limit angles of the split part
 * @return split part (may be null)
 */
private ArcsSet createSplitPart(final BSPTree<Sphere1D> tree){
  if (tree.getCut() == null && !(Boolean)tree.getAttribute()) {
    return null;
  }
 else {
    return new ArcsSet(tree,getTolerance());
  }
}"
57208,"/** 
 * Split the instance in two parts by an arc.
 * @param arc splitting arc
 * @return an object containing both the part of the instanceon the plus side of the arc and the part of the instance on the minus side of the arc
 */
public Split split(final Arc arc){
  final BSPTree<Sphere1D> minus=new BSPTree<Sphere1D>();
  minus.setAttribute(Boolean.FALSE);
  boolean minusIgnored=false;
  final BSPTree<Sphere1D> plus=new BSPTree<Sphere1D>();
  plus.setAttribute(Boolean.FALSE);
  boolean plusIgnored=false;
  final double reference=FastMath.PI + arc.getInf();
  final double arcLength=arc.getSup() - arc.getInf();
  for (  final double[] a : this) {
    final double syncedStart=MathUtils.normalizeAngle(a[0],reference) - arc.getInf();
    final double arcOffset=a[0] - syncedStart;
    final double syncedEnd=a[1] - arcOffset;
    if (syncedStart < arcLength) {
      minusIgnored=addArcStart(minus,a[0],minusIgnored);
      if (syncedEnd > arcLength) {
        final double minusToPlus=arcLength + arcOffset;
        minusIgnored=addArcEnd(minus,minusToPlus,minusIgnored);
        plusIgnored=addArcStart(plus,minusToPlus,plusIgnored);
        if (syncedEnd > MathUtils.TWO_PI) {
          final double plusToMinus=MathUtils.TWO_PI + arcOffset;
          plusIgnored=addArcEnd(plus,plusToMinus,plusIgnored);
          minusIgnored=addArcStart(minus,plusToMinus,minusIgnored);
          minusIgnored=addArcEnd(minus,a[1],minusIgnored);
        }
 else {
          plusIgnored=addArcEnd(plus,a[1],plusIgnored);
        }
      }
 else {
        minusIgnored=addArcEnd(minus,a[1],minusIgnored);
      }
    }
 else {
      plusIgnored=addArcStart(plus,a[0],plusIgnored);
      if (syncedEnd > MathUtils.TWO_PI) {
        final double plusToMinus=MathUtils.TWO_PI + arcOffset;
        plusIgnored=addArcEnd(plus,plusToMinus,plusIgnored);
        minusIgnored=addArcStart(minus,plusToMinus,minusIgnored);
        if (syncedEnd > MathUtils.TWO_PI + arcLength) {
          final double minusToPlus=MathUtils.TWO_PI + arcLength + arcOffset;
          minusIgnored=addArcEnd(minus,minusToPlus,minusIgnored);
          plusIgnored=addArcStart(plus,minusToPlus,plusIgnored);
          plusIgnored=addArcEnd(plus,a[1],plusIgnored);
        }
 else {
          minusIgnored=addArcEnd(minus,a[1],minusIgnored);
        }
      }
 else {
        plusIgnored=addArcEnd(plus,a[1],plusIgnored);
      }
    }
  }
  return new Split(createSplitPart(plus,plusIgnored),createSplitPart(minus,minusIgnored));
}","/** 
 * Split the instance in two parts by an arc.
 * @param arc splitting arc
 * @return an object containing both the part of the instanceon the plus side of the arc and the part of the instance on the minus side of the arc
 */
public Split split(final Arc arc){
  final BSPTree<Sphere1D> minus=new BSPTree<Sphere1D>();
  minus.setAttribute(Boolean.FALSE);
  final BSPTree<Sphere1D> plus=new BSPTree<Sphere1D>();
  plus.setAttribute(Boolean.FALSE);
  final double reference=FastMath.PI + arc.getInf();
  final double arcLength=arc.getSup() - arc.getInf();
  for (  final double[] a : this) {
    final double syncedStart=MathUtils.normalizeAngle(a[0],reference) - arc.getInf();
    final double arcOffset=a[0] - syncedStart;
    final double syncedEnd=a[1] - arcOffset;
    if (syncedStart < arcLength) {
      addArcLimit(minus,a[0],true);
      if (syncedEnd > arcLength) {
        final double minusToPlus=arcLength + arcOffset;
        addArcLimit(minus,minusToPlus,false);
        addArcLimit(plus,minusToPlus,true);
        if (syncedEnd > MathUtils.TWO_PI) {
          final double plusToMinus=MathUtils.TWO_PI + arcOffset;
          addArcLimit(plus,plusToMinus,false);
          addArcLimit(minus,plusToMinus,true);
          addArcLimit(minus,a[1],false);
        }
 else {
          addArcLimit(plus,a[1],false);
        }
      }
 else {
        addArcLimit(minus,a[1],false);
      }
    }
 else {
      addArcLimit(plus,a[0],true);
      if (syncedEnd > MathUtils.TWO_PI) {
        final double plusToMinus=MathUtils.TWO_PI + arcOffset;
        addArcLimit(plus,plusToMinus,false);
        addArcLimit(minus,plusToMinus,true);
        if (syncedEnd > MathUtils.TWO_PI + arcLength) {
          final double minusToPlus=MathUtils.TWO_PI + arcLength + arcOffset;
          addArcLimit(minus,minusToPlus,false);
          addArcLimit(plus,minusToPlus,true);
          addArcLimit(plus,a[1],false);
        }
 else {
          addArcLimit(minus,a[1],false);
        }
      }
 else {
        addArcLimit(plus,a[1],false);
      }
    }
  }
  return new Split(createSplitPart(plus),createSplitPart(minus));
}"
57209,"@Test public void testSplitEmbedded(){
  ArcsSet s35=new ArcsSet(3.0,5.0,1.0e-10);
  ArcsSet s16=new ArcsSet(1.0,6.0,1.0e-10);
  ArcsSet.Split split1=s16.split(new Arc(3.0,5.0,1.0e-10));
  ArcsSet split1Plus=(ArcsSet)split1.getPlus();
  ArcsSet split1Minus=(ArcsSet)split1.getMinus();
  Assert.assertEquals(3.0,split1Plus.getSize(),1.0e-10);
  Assert.assertEquals(2,split1Plus.asList().size());
  Assert.assertEquals(1.0,split1Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(3.0,split1Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(5.0,split1Plus.asList().get(1).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split1Plus.asList().get(1).getSup(),1.0e-10);
  Assert.assertEquals(2.0,split1Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split1Minus.asList().size());
  Assert.assertEquals(3.0,split1Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split1Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split2=s16.split(new Arc(5.0,3.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split2Plus=(ArcsSet)split2.getPlus();
  ArcsSet split2Minus=(ArcsSet)split2.getMinus();
  Assert.assertEquals(2.0,split2Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split2Plus.asList().size());
  Assert.assertEquals(3.0,split2Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split2Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(3.0,split2Minus.getSize(),1.0e-10);
  Assert.assertEquals(2,split2Minus.asList().size());
  Assert.assertEquals(1.0,split2Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(3.0,split2Minus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(5.0,split2Minus.asList().get(1).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split2Minus.asList().get(1).getSup(),1.0e-10);
  ArcsSet.Split split3=s35.split(new Arc(1.0,6.0,1.0e-10));
  ArcsSet split3Plus=(ArcsSet)split3.getPlus();
  ArcsSet split3Minus=(ArcsSet)split3.getMinus();
  Assert.assertNull(split3Plus);
  Assert.assertEquals(2.0,split3Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split3Minus.asList().size());
  Assert.assertEquals(3.0,split3Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split3Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split4=s35.split(new Arc(6.0,1.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split4Plus=(ArcsSet)split4.getPlus();
  ArcsSet split4Minus=(ArcsSet)split4.getMinus();
  Assert.assertEquals(2.0,split4Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split4Plus.asList().size());
  Assert.assertEquals(3.0,split4Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split4Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertNull(split4Minus);
}","@Test public void testSplitEmbedded(){
  ArcsSet s35=new ArcsSet(3.0,5.0,1.0e-10);
  ArcsSet s16=new ArcsSet(1.0,6.0,1.0e-10);
  ArcsSet.Split split1=s16.split(new Arc(3.0,5.0,1.0e-10));
  ArcsSet split1Plus=split1.getPlus();
  ArcsSet split1Minus=split1.getMinus();
  Assert.assertEquals(3.0,split1Plus.getSize(),1.0e-10);
  Assert.assertEquals(2,split1Plus.asList().size());
  Assert.assertEquals(1.0,split1Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(3.0,split1Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(5.0,split1Plus.asList().get(1).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split1Plus.asList().get(1).getSup(),1.0e-10);
  Assert.assertEquals(2.0,split1Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split1Minus.asList().size());
  Assert.assertEquals(3.0,split1Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split1Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split2=s16.split(new Arc(5.0,3.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split2Plus=split2.getPlus();
  ArcsSet split2Minus=split2.getMinus();
  Assert.assertEquals(2.0,split2Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split2Plus.asList().size());
  Assert.assertEquals(3.0,split2Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split2Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(3.0,split2Minus.getSize(),1.0e-10);
  Assert.assertEquals(2,split2Minus.asList().size());
  Assert.assertEquals(1.0,split2Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(3.0,split2Minus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(5.0,split2Minus.asList().get(1).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split2Minus.asList().get(1).getSup(),1.0e-10);
  ArcsSet.Split split3=s35.split(new Arc(1.0,6.0,1.0e-10));
  ArcsSet split3Plus=split3.getPlus();
  ArcsSet split3Minus=split3.getMinus();
  Assert.assertNull(split3Plus);
  Assert.assertEquals(2.0,split3Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split3Minus.asList().size());
  Assert.assertEquals(3.0,split3Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split3Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split4=s35.split(new Arc(6.0,1.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split4Plus=split4.getPlus();
  ArcsSet split4Minus=split4.getMinus();
  Assert.assertEquals(2.0,split4Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split4Plus.asList().size());
  Assert.assertEquals(3.0,split4Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split4Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertNull(split4Minus);
}"
57210,"@Test public void testSplitOverlapping(){
  ArcsSet s35=new ArcsSet(3.0,5.0,1.0e-10);
  ArcsSet s46=new ArcsSet(4.0,6.0,1.0e-10);
  ArcsSet.Split split1=s46.split(new Arc(3.0,5.0,1.0e-10));
  ArcsSet split1Plus=(ArcsSet)split1.getPlus();
  ArcsSet split1Minus=(ArcsSet)split1.getMinus();
  Assert.assertEquals(1.0,split1Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split1Plus.asList().size());
  Assert.assertEquals(5.0,split1Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split1Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split1Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split1Minus.asList().size());
  Assert.assertEquals(4.0,split1Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split1Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split2=s46.split(new Arc(5.0,3.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split2Plus=(ArcsSet)split2.getPlus();
  ArcsSet split2Minus=(ArcsSet)split2.getMinus();
  Assert.assertEquals(1.0,split2Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split2Plus.asList().size());
  Assert.assertEquals(4.0,split2Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split2Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split2Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split2Minus.asList().size());
  Assert.assertEquals(5.0,split2Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split2Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split3=s35.split(new Arc(4.0,6.0,1.0e-10));
  ArcsSet split3Plus=(ArcsSet)split3.getPlus();
  ArcsSet split3Minus=(ArcsSet)split3.getMinus();
  Assert.assertEquals(1.0,split3Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split3Plus.asList().size());
  Assert.assertEquals(3.0,split3Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(4.0,split3Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split3Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split3Minus.asList().size());
  Assert.assertEquals(4.0,split3Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split3Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split4=s35.split(new Arc(6.0,4.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split4Plus=(ArcsSet)split4.getPlus();
  ArcsSet split4Minus=(ArcsSet)split4.getMinus();
  Assert.assertEquals(1.0,split4Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split4Plus.asList().size());
  Assert.assertEquals(4.0,split4Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split4Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split4Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split4Minus.asList().size());
  Assert.assertEquals(3.0,split4Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(4.0,split4Minus.asList().get(0).getSup(),1.0e-10);
}","@Test public void testSplitOverlapping(){
  ArcsSet s35=new ArcsSet(3.0,5.0,1.0e-10);
  ArcsSet s46=new ArcsSet(4.0,6.0,1.0e-10);
  ArcsSet.Split split1=s46.split(new Arc(3.0,5.0,1.0e-10));
  ArcsSet split1Plus=split1.getPlus();
  ArcsSet split1Minus=split1.getMinus();
  Assert.assertEquals(1.0,split1Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split1Plus.asList().size());
  Assert.assertEquals(5.0,split1Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split1Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split1Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split1Minus.asList().size());
  Assert.assertEquals(4.0,split1Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split1Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split2=s46.split(new Arc(5.0,3.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split2Plus=split2.getPlus();
  ArcsSet split2Minus=split2.getMinus();
  Assert.assertEquals(1.0,split2Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split2Plus.asList().size());
  Assert.assertEquals(4.0,split2Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split2Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split2Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split2Minus.asList().size());
  Assert.assertEquals(5.0,split2Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(6.0,split2Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split3=s35.split(new Arc(4.0,6.0,1.0e-10));
  ArcsSet split3Plus=split3.getPlus();
  ArcsSet split3Minus=split3.getMinus();
  Assert.assertEquals(1.0,split3Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split3Plus.asList().size());
  Assert.assertEquals(3.0,split3Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(4.0,split3Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split3Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split3Minus.asList().size());
  Assert.assertEquals(4.0,split3Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split3Minus.asList().get(0).getSup(),1.0e-10);
  ArcsSet.Split split4=s35.split(new Arc(6.0,4.0 + MathUtils.TWO_PI,1.0e-10));
  ArcsSet split4Plus=split4.getPlus();
  ArcsSet split4Minus=split4.getMinus();
  Assert.assertEquals(1.0,split4Plus.getSize(),1.0e-10);
  Assert.assertEquals(1,split4Plus.asList().size());
  Assert.assertEquals(4.0,split4Plus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(5.0,split4Plus.asList().get(0).getSup(),1.0e-10);
  Assert.assertEquals(1.0,split4Minus.getSize(),1.0e-10);
  Assert.assertEquals(1,split4Minus.asList().size());
  Assert.assertEquals(3.0,split4Minus.asList().get(0).getInf(),1.0e-10);
  Assert.assertEquals(4.0,split4Minus.asList().get(0).getSup(),1.0e-10);
}"
57211,"@Test public void testSplitOver2Pi(){
  ArcsSet set=new ArcsSet(1.0e-10);
  Arc arc=new Arc(1.5 * FastMath.PI,2.5 * FastMath.PI,1.0e-10);
  ArcsSet.Split split=set.split(arc);
  for (double alpha=0; alpha <= MathUtils.TWO_PI; alpha+=0.01) {
    S1Point p=new S1Point(alpha);
    if (alpha < 0.5 * FastMath.PI || alpha > 1.5 * FastMath.PI) {
      Assert.assertEquals(Location.OUTSIDE,split.getPlus().checkPoint(p));
      Assert.assertEquals(Location.INSIDE,split.getMinus().checkPoint(p));
    }
 else {
      Assert.assertEquals(Location.INSIDE,split.getPlus().checkPoint(p));
      Assert.assertEquals(Location.OUTSIDE,split.getMinus().checkPoint(p));
    }
  }
}","@Test public void testSplitOver2Pi(){
  ArcsSet set=new ArcsSet(1.0e-10);
  Arc arc=new Arc(1.5 * FastMath.PI,2.5 * FastMath.PI,1.0e-10);
  ArcsSet.Split split=set.split(arc);
  for (double alpha=0.0; alpha <= MathUtils.TWO_PI; alpha+=0.01) {
    S1Point p=new S1Point(alpha);
    if (alpha < 0.5 * FastMath.PI || alpha > 1.5 * FastMath.PI) {
      Assert.assertEquals(Location.OUTSIDE,split.getPlus().checkPoint(p));
      Assert.assertEquals(Location.INSIDE,split.getMinus().checkPoint(p));
    }
 else {
      Assert.assertEquals(Location.INSIDE,split.getPlus().checkPoint(p));
      Assert.assertEquals(Location.OUTSIDE,split.getMinus().checkPoint(p));
    }
  }
}"
57212,"/** 
 * Split the edge. <p> Once split, this edge is not referenced anymore by the vertices, it is replaced by the two or three sub-edges and intermediate splitting vertices are introduced to connect these sub-edges together. </p>
 * @param splitCircle circle splitting the edge in several parts
 * @param outsideList list where to put parts that are outside of the split circle
 * @param insideList list where to put parts that are inside the split circle
 */
private void split(final Circle splitCircle,final List<Edge> outsideList,final List<Edge> insideList){
  final double edgeStart=circle.getPhase(start.getLocation().getVector());
  final double arcRelativeStart=MathUtils.normalizeAngle(circle.getInsideArc(splitCircle).getInf(),edgeStart + FastMath.PI) - edgeStart;
  final double arcRelativeEnd=arcRelativeStart + FastMath.PI;
  final double unwrappedEnd=arcRelativeStart - FastMath.PI;
  if (arcRelativeStart < length) {
    if (unwrappedEnd > 0) {
      final Vertex vExit=new Vertex(new S2Point(circle.getPointAt(edgeStart + arcRelativeEnd)));
      final Vertex vEnter=new Vertex(new S2Point(circle.getPointAt(edgeStart + arcRelativeStart)));
      vExit.bindWith(splitCircle);
      vEnter.bindWith(splitCircle);
      final Edge eStartIn=new Edge(start,vExit,unwrappedEnd,circle);
      final Edge eMiddleOut=new Edge(vExit,vEnter,arcRelativeStart - unwrappedEnd,circle);
      final Edge eEndIn=new Edge(vEnter,end,length - arcRelativeStart,circle);
      eStartIn.setNode(node);
      eMiddleOut.setNode(node);
      eEndIn.setNode(node);
      insideList.add(eStartIn);
      insideList.add(eEndIn);
      outsideList.add(eMiddleOut);
    }
 else {
      final Vertex vEnter=new Vertex(new S2Point(circle.getPointAt(edgeStart + arcRelativeStart)));
      vEnter.bindWith(splitCircle);
      final Edge eStartOut=new Edge(start,vEnter,arcRelativeStart,circle);
      final Edge eEndIn=new Edge(vEnter,end,length - arcRelativeStart,circle);
      eStartOut.setNode(node);
      eEndIn.setNode(node);
      outsideList.add(eStartOut);
      insideList.add(eEndIn);
    }
  }
 else {
    if (unwrappedEnd > 0) {
      if (unwrappedEnd > length) {
        insideList.add(this);
      }
 else {
        final Vertex vExit=new Vertex(new S2Point(circle.getPointAt(edgeStart + arcRelativeEnd)));
        vExit.bindWith(splitCircle);
        final Edge eStartIn=new Edge(start,vExit,arcRelativeEnd,circle);
        final Edge eEndOut=new Edge(vExit,end,length - arcRelativeEnd,circle);
        eStartIn.setNode(node);
        eEndOut.setNode(node);
        insideList.add(eStartIn);
        outsideList.add(eEndOut);
      }
    }
 else {
      outsideList.add(this);
    }
  }
}","/** 
 * Split the edge. <p> Once split, this edge is not referenced anymore by the vertices, it is replaced by the two or three sub-edges and intermediate splitting vertices are introduced to connect these sub-edges together. </p>
 * @param splitCircle circle splitting the edge in several parts
 * @param outsideList list where to put parts that are outside of the split circle
 * @param insideList list where to put parts that are inside the split circle
 */
private void split(final Circle splitCircle,final List<Edge> outsideList,final List<Edge> insideList){
  final double edgeStart=circle.getPhase(start.getLocation().getVector());
  final double arcRelativeStart=MathUtils.normalizeAngle(circle.getInsideArc(splitCircle).getInf(),edgeStart + FastMath.PI) - edgeStart;
  final double arcRelativeEnd=arcRelativeStart + FastMath.PI;
  final double unwrappedEnd=arcRelativeStart - FastMath.PI;
  final double tolerance=circle.getTolerance();
  Vertex previousVertex=start;
  if (unwrappedEnd >= length - tolerance) {
    insideList.add(this);
  }
 else {
    double alreadyManagedLength=0;
    if (unwrappedEnd >= 0) {
      previousVertex=addSubEdge(previousVertex,new Vertex(new S2Point(circle.getPointAt(edgeStart + unwrappedEnd))),unwrappedEnd,insideList,splitCircle);
      alreadyManagedLength=unwrappedEnd;
    }
    if (arcRelativeStart >= length - tolerance) {
      if (unwrappedEnd >= 0) {
        previousVertex=addSubEdge(previousVertex,end,length - alreadyManagedLength,outsideList,splitCircle);
      }
 else {
        outsideList.add(this);
      }
    }
 else {
      previousVertex=addSubEdge(previousVertex,new Vertex(new S2Point(circle.getPointAt(edgeStart + arcRelativeStart))),arcRelativeStart - alreadyManagedLength,outsideList,splitCircle);
      alreadyManagedLength=arcRelativeStart;
      if (arcRelativeEnd >= length - tolerance) {
        previousVertex=addSubEdge(previousVertex,end,length - alreadyManagedLength,insideList,splitCircle);
      }
 else {
        previousVertex=addSubEdge(previousVertex,new Vertex(new S2Point(circle.getPointAt(edgeStart + arcRelativeStart))),arcRelativeStart - alreadyManagedLength,insideList,splitCircle);
        alreadyManagedLength=arcRelativeStart;
        previousVertex=addSubEdge(previousVertex,end,length - alreadyManagedLength,outsideList,splitCircle);
      }
    }
  }
}"
57213,"/** 
 * Recursively build a tree by inserting cut sub-hyperplanes.
 * @param hyperplaneThickness tolerance below which points are consider tobelong to the hyperplane (which is therefore more a slab)
 * @param node current tree node (it is a leaf node at the beginningof the call)
 * @param edges list of edges to insert in the cell defined by this node(excluding edges not belonging to the cell defined by this node)
 */
private static void insertEdges(final double hyperplaneThickness,final BSPTree<Sphere2D> node,final List<Edge> edges){
  int index=0;
  Edge inserted=null;
  while (inserted == null && index < edges.size()) {
    inserted=edges.get(index++);
    if (inserted.getNode() == null) {
      if (node.insertCut(inserted.getCircle())) {
        inserted.setNode(node);
      }
 else {
        inserted=null;
      }
    }
 else {
      inserted=null;
    }
  }
  if (inserted == null) {
    final BSPTree<Sphere2D> parent=node.getParent();
    if (parent == null || node == parent.getMinus()) {
      node.setAttribute(Boolean.TRUE);
    }
 else {
      node.setAttribute(Boolean.FALSE);
    }
    return;
  }
  final List<Edge> outsideList=new ArrayList<Edge>();
  final List<Edge> insideList=new ArrayList<Edge>();
  for (  final Edge edge : edges) {
    if (edge != inserted) {
      edge.split(inserted.getCircle(),outsideList,insideList);
    }
  }
  if (!outsideList.isEmpty()) {
    insertEdges(hyperplaneThickness,node.getPlus(),outsideList);
  }
 else {
    node.getMinus().setAttribute(Boolean.FALSE);
  }
  if (!insideList.isEmpty()) {
    insertEdges(hyperplaneThickness,node.getMinus(),insideList);
  }
 else {
    node.getPlus().setAttribute(Boolean.TRUE);
  }
}","/** 
 * Recursively build a tree by inserting cut sub-hyperplanes.
 * @param hyperplaneThickness tolerance below which points are considered tobelong to the hyperplane (which is therefore more a slab)
 * @param node current tree node (it is a leaf node at the beginningof the call)
 * @param edges list of edges to insert in the cell defined by this node(excluding edges not belonging to the cell defined by this node)
 */
private static void insertEdges(final double hyperplaneThickness,final BSPTree<Sphere2D> node,final List<Edge> edges){
  int index=0;
  Edge inserted=null;
  while (inserted == null && index < edges.size()) {
    inserted=edges.get(index++);
    if (inserted.getNode() == null) {
      if (node.insertCut(inserted.getCircle())) {
        inserted.setNode(node);
      }
 else {
        inserted=null;
      }
    }
 else {
      inserted=null;
    }
  }
  if (inserted == null) {
    final BSPTree<Sphere2D> parent=node.getParent();
    if (parent == null || node == parent.getMinus()) {
      node.setAttribute(Boolean.TRUE);
    }
 else {
      node.setAttribute(Boolean.FALSE);
    }
    return;
  }
  final List<Edge> outsideList=new ArrayList<Edge>();
  final List<Edge> insideList=new ArrayList<Edge>();
  for (  final Edge edge : edges) {
    if (edge != inserted) {
      edge.split(inserted.getCircle(),outsideList,insideList);
    }
  }
  if (!outsideList.isEmpty()) {
    insertEdges(hyperplaneThickness,node.getPlus(),outsideList);
  }
 else {
    node.getPlus().setAttribute(Boolean.FALSE);
  }
  if (!insideList.isEmpty()) {
    insertEdges(hyperplaneThickness,node.getMinus(),insideList);
  }
 else {
    node.getMinus().setAttribute(Boolean.TRUE);
  }
}"
57214,"@Test public void testFullSphere(){
  SphericalPolygonsSet full=new SphericalPolygonsSet(1.0e-10);
  UnitSphereRandomVectorGenerator random=new UnitSphereRandomVectorGenerator(3,new Well1024a(0x852fd2a0ed8d2f6dl));
  for (int i=0; i < 1000; ++i) {
    Vector3D v=new Vector3D(random.nextVector());
    Assert.assertEquals(Location.INSIDE,full.checkPoint(new S2Point(v)));
  }
}","@Test public void testFullSphere(){
  SphericalPolygonsSet full=new SphericalPolygonsSet(1.0e-10);
  UnitSphereRandomVectorGenerator random=new UnitSphereRandomVectorGenerator(3,new Well1024a(0x852fd2a0ed8d2f6dl));
  for (int i=0; i < 1000; ++i) {
    Vector3D v=new Vector3D(random.nextVector());
    Assert.assertEquals(Location.INSIDE,full.checkPoint(new S2Point(v)));
  }
  Assert.assertEquals(4 * FastMath.PI,new SphericalPolygonsSet(0.01,new S2Point[0]).getSize(),1.0e-10);
  Assert.assertEquals(0,new SphericalPolygonsSet(0.01,new S2Point[0]).getBoundarySize(),1.0e-10);
}"
57215,"@Test public void testSouthHemisphere(){
  double tol=0.01;
  double sinTol=FastMath.sin(tol);
  SphericalPolygonsSet south=new SphericalPolygonsSet(Vector3D.MINUS_K,tol);
  UnitSphereRandomVectorGenerator random=new UnitSphereRandomVectorGenerator(3,new Well1024a(0x852fd2a0ed8d2f6dl));
  for (int i=0; i < 1000; ++i) {
    Vector3D v=new Vector3D(random.nextVector());
    if (v.getZ() < -sinTol) {
      Assert.assertEquals(Location.INSIDE,south.checkPoint(new S2Point(v)));
    }
 else     if (v.getZ() > sinTol) {
      Assert.assertEquals(Location.OUTSIDE,south.checkPoint(new S2Point(v)));
    }
 else {
      Assert.assertEquals(""String_Node_Str"" + v.getX() + ""String_Node_Str""+ v.getY()+ ""String_Node_Str""+ v.getZ(),Location.BOUNDARY,south.checkPoint(new S2Point(v)));
    }
  }
}","@Test public void testSouthHemisphere(){
  double tol=0.01;
  double sinTol=FastMath.sin(tol);
  SphericalPolygonsSet south=new SphericalPolygonsSet(Vector3D.MINUS_K,tol);
  UnitSphereRandomVectorGenerator random=new UnitSphereRandomVectorGenerator(3,new Well1024a(0x6b9d4a6ad90d7b0bl));
  for (int i=0; i < 1000; ++i) {
    Vector3D v=new Vector3D(random.nextVector());
    if (v.getZ() < -sinTol) {
      Assert.assertEquals(Location.INSIDE,south.checkPoint(new S2Point(v)));
    }
 else     if (v.getZ() > sinTol) {
      Assert.assertEquals(Location.OUTSIDE,south.checkPoint(new S2Point(v)));
    }
 else {
      Assert.assertEquals(Location.BOUNDARY,south.checkPoint(new S2Point(v)));
    }
  }
}"
57216,"/** 
 * Compute the distance between the instance and another vector according to the L<sub>2</sub> norm. <p>Calling this method is equivalent to calling: <code>q.subtract(p).getNorm()</code> except that no intermediate vector is built</p>
 * @param v second vector
 * @return the distance between the instance and p according to the L<sub>2</sub> norm
 */
double distance(Vector<S> v);","/** 
 * Compute the distance between the instance and another vector according to the L<sub>2</sub> norm. <p>Calling this method is equivalent to calling: <code>q.subtract(p).getNorm()</code> except that no intermediate vector is built</p>
 * @param v second vector
 * @return the distance between the instance and p according to the L<sub>2</sub> norm
 * @deprecated as of 3.3 replaced with {@link Point#distance(Point)}
 */
@Deprecated double distance(Vector<S> v);"
57217,"/** 
 * Build an intervals set from a Boundary REPresentation (B-rep). <p>The boundary is provided as a collection of   {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.</p> <p>The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the   {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector) checkPoint} method will not be meaningful anymore.</p><p>If the boundary is empty, the region will represent the whole space.</p>
 * @param boundary collection of boundary elements
 */
public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary){
  super(boundary);
}","/** 
 * Build an intervals set from a Boundary REPresentation (B-rep). <p>The boundary is provided as a collection of   {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.</p> <p>The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the   {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Point) checkPoint} method will not be meaningful anymore.</p><p>If the boundary is empty, the region will represent the whole space.</p>
 * @param boundary collection of boundary elements
 */
public IntervalsSet(final Collection<SubHyperplane<Euclidean1D>> boundary){
  super(boundary);
}"
57218,"/** 
 * {@inheritDoc} 
 */
@Override protected void computeGeometricalProperties(){
  if (getTree(false).getCut() == null) {
    setBarycenter(Vector1D.NaN);
    setSize(((Boolean)getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);
  }
 else {
    double size=0.0;
    double sum=0.0;
    for (    final Interval interval : asList()) {
      size+=interval.getSize();
      sum+=interval.getSize() * interval.getBarycenter();
    }
    setSize(size);
    if (Double.isInfinite(size)) {
      setBarycenter(Vector1D.NaN);
    }
 else     if (size >= Precision.SAFE_MIN) {
      setBarycenter(new Vector1D(sum / size));
    }
 else {
      setBarycenter(((OrientedPoint)getTree(false).getCut().getHyperplane()).getLocation());
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void computeGeometricalProperties(){
  if (getTree(false).getCut() == null) {
    setBarycenter((Point<Euclidean1D>)Vector1D.NaN);
    setSize(((Boolean)getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);
  }
 else {
    double size=0.0;
    double sum=0.0;
    for (    final Interval interval : asList()) {
      size+=interval.getSize();
      sum+=interval.getSize() * interval.getBarycenter();
    }
    setSize(size);
    if (Double.isInfinite(size)) {
      setBarycenter((Point<Euclidean1D>)Vector1D.NaN);
    }
 else     if (size >= Precision.SAFE_MIN) {
      setBarycenter((Point<Euclidean1D>)new Vector1D(sum / size));
    }
 else {
      setBarycenter((Point<Euclidean1D>)((OrientedPoint)getTree(false).getCut().getHyperplane()).getLocation());
    }
  }
}"
57219,"/** 
 * Update an intervals list.
 * @param node current node
 * @param list list to update
 * @param lower lower bound of the current convex cell
 * @param upper upper bound of the current convex cell
 */
private void recurseList(final BSPTree<Euclidean1D> node,final List<Interval> list,final double lower,final double upper){
  if (node.getCut() == null) {
    if ((Boolean)node.getAttribute()) {
      list.add(new Interval(lower,upper));
    }
  }
 else {
    final OrientedPoint op=(OrientedPoint)node.getCut().getHyperplane();
    final Vector1D loc=op.getLocation();
    double x=loc.getX();
    final BSPTree<Euclidean1D> low=op.isDirect() ? node.getMinus() : node.getPlus();
    final BSPTree<Euclidean1D> high=op.isDirect() ? node.getPlus() : node.getMinus();
    recurseList(low,list,lower,x);
    if ((checkPoint(low,loc) == Location.INSIDE) && (checkPoint(high,loc) == Location.INSIDE)) {
      x=list.remove(list.size() - 1).getInf();
    }
    recurseList(high,list,x,upper);
  }
}","/** 
 * Update an intervals list.
 * @param node current node
 * @param list list to update
 * @param lower lower bound of the current convex cell
 * @param upper upper bound of the current convex cell
 */
private void recurseList(final BSPTree<Euclidean1D> node,final List<Interval> list,final double lower,final double upper){
  if (node.getCut() == null) {
    if ((Boolean)node.getAttribute()) {
      list.add(new Interval(lower,upper));
    }
  }
 else {
    final OrientedPoint op=(OrientedPoint)node.getCut().getHyperplane();
    final Vector1D loc=op.getLocation();
    double x=loc.getX();
    final BSPTree<Euclidean1D> low=op.isDirect() ? node.getMinus() : node.getPlus();
    final BSPTree<Euclidean1D> high=op.isDirect() ? node.getPlus() : node.getMinus();
    recurseList(low,list,lower,x);
    if ((checkPoint(low,(Point<Euclidean1D>)loc) == Location.INSIDE) && (checkPoint(high,(Point<Euclidean1D>)loc) == Location.INSIDE)) {
      x=list.remove(list.size() - 1).getInf();
    }
    recurseList(high,list,x,upper);
  }
}"
57220,"/** 
 * Add he contribution of a boundary facet.
 * @param facet boundary facet
 * @param reversed if true, the facet has the inside on its plus side
 */
private void addContribution(final SubHyperplane<Euclidean3D> facet,final boolean reversed){
  @SuppressWarnings(""String_Node_Str"") final AbstractSubHyperplane<Euclidean3D,Euclidean2D> absFacet=(AbstractSubHyperplane<Euclidean3D,Euclidean2D>)facet;
  final Plane plane=(Plane)facet.getHyperplane();
  final double scal=plane.getNormal().dotProduct(w);
  if (FastMath.abs(scal) > 1.0e-3) {
    Vector2D[][] vertices=((PolygonsSet)absFacet.getRemainingRegion()).getVertices();
    if ((scal < 0) ^ reversed) {
      final Vector2D[][] newVertices=new Vector2D[vertices.length][];
      for (int i=0; i < vertices.length; ++i) {
        final Vector2D[] loop=vertices[i];
        final Vector2D[] newLoop=new Vector2D[loop.length];
        if (loop[0] == null) {
          newLoop[0]=null;
          for (int j=1; j < loop.length; ++j) {
            newLoop[j]=loop[loop.length - j];
          }
        }
 else {
          for (int j=0; j < loop.length; ++j) {
            newLoop[j]=loop[loop.length - (j + 1)];
          }
        }
        newVertices[i]=newLoop;
      }
      vertices=newVertices;
    }
    final ArrayList<SubHyperplane<Euclidean2D>> edges=new ArrayList<SubHyperplane<Euclidean2D>>();
    for (    Vector2D[] loop : vertices) {
      final boolean closed=loop[0] != null;
      int previous=closed ? (loop.length - 1) : 1;
      Vector3D previous3D=plane.toSpace(loop[previous]);
      int current=(previous + 1) % loop.length;
      Vector2D pPoint=new Vector2D(previous3D.dotProduct(u),previous3D.dotProduct(v));
      while (current < loop.length) {
        final Vector3D current3D=plane.toSpace(loop[current]);
        final Vector2D cPoint=new Vector2D(current3D.dotProduct(u),current3D.dotProduct(v));
        final org.apache.commons.math3.geometry.euclidean.twod.Line line=new org.apache.commons.math3.geometry.euclidean.twod.Line(pPoint,cPoint);
        SubHyperplane<Euclidean2D> edge=line.wholeHyperplane();
        if (closed || (previous != 1)) {
          final double angle=line.getAngle() + 0.5 * FastMath.PI;
          final org.apache.commons.math3.geometry.euclidean.twod.Line l=new org.apache.commons.math3.geometry.euclidean.twod.Line(pPoint,angle);
          edge=edge.split(l).getPlus();
        }
        if (closed || (current != (loop.length - 1))) {
          final double angle=line.getAngle() + 0.5 * FastMath.PI;
          final org.apache.commons.math3.geometry.euclidean.twod.Line l=new org.apache.commons.math3.geometry.euclidean.twod.Line(cPoint,angle);
          edge=edge.split(l).getMinus();
        }
        edges.add(edge);
        previous=current++;
        previous3D=current3D;
        pPoint=cPoint;
      }
    }
    final PolygonsSet projectedFacet=new PolygonsSet(edges);
    projected=(PolygonsSet)new RegionFactory<Euclidean2D>().union(projected,projectedFacet);
  }
}","/** 
 * Add he contribution of a boundary facet.
 * @param facet boundary facet
 * @param reversed if true, the facet has the inside on its plus side
 */
private void addContribution(final SubHyperplane<Euclidean3D> facet,final boolean reversed){
  @SuppressWarnings(""String_Node_Str"") final AbstractSubHyperplane<Euclidean3D,Euclidean2D> absFacet=(AbstractSubHyperplane<Euclidean3D,Euclidean2D>)facet;
  final Plane plane=(Plane)facet.getHyperplane();
  final double scal=plane.getNormal().dotProduct(w);
  if (FastMath.abs(scal) > 1.0e-3) {
    Vector2D[][] vertices=((PolygonsSet)absFacet.getRemainingRegion()).getVertices();
    if ((scal < 0) ^ reversed) {
      final Vector2D[][] newVertices=new Vector2D[vertices.length][];
      for (int i=0; i < vertices.length; ++i) {
        final Vector2D[] loop=vertices[i];
        final Vector2D[] newLoop=new Vector2D[loop.length];
        if (loop[0] == null) {
          newLoop[0]=null;
          for (int j=1; j < loop.length; ++j) {
            newLoop[j]=loop[loop.length - j];
          }
        }
 else {
          for (int j=0; j < loop.length; ++j) {
            newLoop[j]=loop[loop.length - (j + 1)];
          }
        }
        newVertices[i]=newLoop;
      }
      vertices=newVertices;
    }
    final ArrayList<SubHyperplane<Euclidean2D>> edges=new ArrayList<SubHyperplane<Euclidean2D>>();
    for (    Vector2D[] loop : vertices) {
      final boolean closed=loop[0] != null;
      int previous=closed ? (loop.length - 1) : 1;
      Vector3D previous3D=plane.toSpace((Point<Euclidean2D>)loop[previous]);
      int current=(previous + 1) % loop.length;
      Vector2D pPoint=new Vector2D(previous3D.dotProduct(u),previous3D.dotProduct(v));
      while (current < loop.length) {
        final Vector3D current3D=plane.toSpace((Point<Euclidean2D>)loop[current]);
        final Vector2D cPoint=new Vector2D(current3D.dotProduct(u),current3D.dotProduct(v));
        final org.apache.commons.math3.geometry.euclidean.twod.Line line=new org.apache.commons.math3.geometry.euclidean.twod.Line(pPoint,cPoint);
        SubHyperplane<Euclidean2D> edge=line.wholeHyperplane();
        if (closed || (previous != 1)) {
          final double angle=line.getAngle() + 0.5 * FastMath.PI;
          final org.apache.commons.math3.geometry.euclidean.twod.Line l=new org.apache.commons.math3.geometry.euclidean.twod.Line(pPoint,angle);
          edge=edge.split(l).getPlus();
        }
        if (closed || (current != (loop.length - 1))) {
          final double angle=line.getAngle() + 0.5 * FastMath.PI;
          final org.apache.commons.math3.geometry.euclidean.twod.Line l=new org.apache.commons.math3.geometry.euclidean.twod.Line(cPoint,angle);
          edge=edge.split(l).getMinus();
        }
        edges.add(edge);
        previous=current++;
        previous3D=current3D;
        pPoint=cPoint;
      }
    }
    final PolygonsSet projectedFacet=new PolygonsSet(edges);
    projected=(PolygonsSet)new RegionFactory<Euclidean2D>().union(projected,projectedFacet);
  }
}"
57221,"/** 
 * {@inheritDoc} 
 */
public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub,final Hyperplane<Euclidean3D> original,final Hyperplane<Euclidean3D> transformed){
  if (original != cachedOriginal) {
    final Plane oPlane=(Plane)original;
    final Plane tPlane=(Plane)transformed;
    final Vector2D shift=tPlane.toSubSpace(apply(oPlane.getOrigin()));
    final AffineTransform at=AffineTransform.getTranslateInstance(shift.getX(),shift.getY());
    cachedOriginal=(Plane)original;
    cachedTransform=org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);
  }
  return ((SubLine)sub).applyTransform(cachedTransform);
}","/** 
 * {@inheritDoc} 
 */
public SubHyperplane<Euclidean2D> apply(final SubHyperplane<Euclidean2D> sub,final Hyperplane<Euclidean3D> original,final Hyperplane<Euclidean3D> transformed){
  if (original != cachedOriginal) {
    final Plane oPlane=(Plane)original;
    final Plane tPlane=(Plane)transformed;
    final Vector2D shift=tPlane.toSubSpace((Point<Euclidean3D>)apply(oPlane.getOrigin()));
    final AffineTransform at=AffineTransform.getTranslateInstance(shift.getX(),shift.getY());
    cachedOriginal=(Plane)original;
    cachedTransform=org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(at);
  }
  return ((SubLine)sub).applyTransform(cachedTransform);
}"
57222,"/** 
 * Get the first sub-hyperplane crossed by a semi-infinite line.
 * @param node current node
 * @param point start point of the part of the line considered
 * @param line line to consider (contains point)
 * @return the first sub-hyperplaned crossed by the line after thegiven point, or null if the line does not intersect any sub-hyperplaned
 */
private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node,final Vector3D point,final Line line){
  final SubHyperplane<Euclidean3D> cut=node.getCut();
  if (cut == null) {
    return null;
  }
  final BSPTree<Euclidean3D> minus=node.getMinus();
  final BSPTree<Euclidean3D> plus=node.getPlus();
  final Plane plane=(Plane)cut.getHyperplane();
  final double offset=plane.getOffset(point);
  final boolean in=FastMath.abs(offset) < 1.0e-10;
  final BSPTree<Euclidean3D> near;
  final BSPTree<Euclidean3D> far;
  if (offset < 0) {
    near=minus;
    far=plus;
  }
 else {
    near=plus;
    far=minus;
  }
  if (in) {
    final SubHyperplane<Euclidean3D> facet=boundaryFacet(point,node);
    if (facet != null) {
      return facet;
    }
  }
  final SubHyperplane<Euclidean3D> crossed=recurseFirstIntersection(near,point,line);
  if (crossed != null) {
    return crossed;
  }
  if (!in) {
    final Vector3D hit3D=plane.intersection(line);
    if (hit3D != null) {
      final SubHyperplane<Euclidean3D> facet=boundaryFacet(hit3D,node);
      if (facet != null) {
        return facet;
      }
    }
  }
  return recurseFirstIntersection(far,point,line);
}","/** 
 * Get the first sub-hyperplane crossed by a semi-infinite line.
 * @param node current node
 * @param point start point of the part of the line considered
 * @param line line to consider (contains point)
 * @return the first sub-hyperplaned crossed by the line after thegiven point, or null if the line does not intersect any sub-hyperplaned
 */
private SubHyperplane<Euclidean3D> recurseFirstIntersection(final BSPTree<Euclidean3D> node,final Vector3D point,final Line line){
  final SubHyperplane<Euclidean3D> cut=node.getCut();
  if (cut == null) {
    return null;
  }
  final BSPTree<Euclidean3D> minus=node.getMinus();
  final BSPTree<Euclidean3D> plus=node.getPlus();
  final Plane plane=(Plane)cut.getHyperplane();
  final double offset=plane.getOffset((Point<Euclidean3D>)point);
  final boolean in=FastMath.abs(offset) < 1.0e-10;
  final BSPTree<Euclidean3D> near;
  final BSPTree<Euclidean3D> far;
  if (offset < 0) {
    near=minus;
    far=plus;
  }
 else {
    near=plus;
    far=minus;
  }
  if (in) {
    final SubHyperplane<Euclidean3D> facet=boundaryFacet(point,node);
    if (facet != null) {
      return facet;
    }
  }
  final SubHyperplane<Euclidean3D> crossed=recurseFirstIntersection(near,point,line);
  if (crossed != null) {
    return crossed;
  }
  if (!in) {
    final Vector3D hit3D=plane.intersection(line);
    if (hit3D != null) {
      final SubHyperplane<Euclidean3D> facet=boundaryFacet(hit3D,node);
      if (facet != null) {
        return facet;
      }
    }
  }
  return recurseFirstIntersection(far,point,line);
}"
57223,"/** 
 * Simple constructor. 
 */
public FacetsContributionVisitor(){
  setSize(0);
  setBarycenter(new Vector3D(0,0,0));
}","/** 
 * Simple constructor. 
 */
public FacetsContributionVisitor(){
  setSize(0);
  setBarycenter((Point<Euclidean3D>)new Vector3D(0,0,0));
}"
57224,"/** 
 * Add he contribution of a boundary facet.
 * @param facet boundary facet
 * @param reversed if true, the facet has the inside on its plus side
 */
private void addContribution(final SubHyperplane<Euclidean3D> facet,final boolean reversed){
  final Region<Euclidean2D> polygon=((SubPlane)facet).getRemainingRegion();
  final double area=polygon.getSize();
  if (Double.isInfinite(area)) {
    setSize(Double.POSITIVE_INFINITY);
    setBarycenter(Vector3D.NaN);
  }
 else {
    final Plane plane=(Plane)facet.getHyperplane();
    final Vector3D facetB=plane.toSpace(polygon.getBarycenter());
    double scaled=area * facetB.dotProduct(plane.getNormal());
    if (reversed) {
      scaled=-scaled;
    }
    setSize(getSize() + scaled);
    setBarycenter(new Vector3D(1.0,(Vector3D)getBarycenter(),scaled,facetB));
  }
}","/** 
 * Add he contribution of a boundary facet.
 * @param facet boundary facet
 * @param reversed if true, the facet has the inside on its plus side
 */
private void addContribution(final SubHyperplane<Euclidean3D> facet,final boolean reversed){
  final Region<Euclidean2D> polygon=((SubPlane)facet).getRemainingRegion();
  final double area=polygon.getSize();
  if (Double.isInfinite(area)) {
    setSize(Double.POSITIVE_INFINITY);
    setBarycenter((Point<Euclidean3D>)Vector3D.NaN);
  }
 else {
    final Plane plane=(Plane)facet.getHyperplane();
    final Vector3D facetB=plane.toSpace(polygon.getBarycenter());
    double scaled=area * facetB.dotProduct(plane.getNormal());
    if (reversed) {
      scaled=-scaled;
    }
    setSize(getSize() + scaled);
    setBarycenter((Point<Euclidean3D>)new Vector3D(1.0,(Vector3D)getBarycenter(),scaled,facetB));
  }
}"
57225,"/** 
 * {@inheritDoc} 
 */
@Override protected void computeGeometricalProperties(){
  getTree(true).visit(new FacetsContributionVisitor());
  if (getSize() < 0) {
    setSize(Double.POSITIVE_INFINITY);
    setBarycenter(Vector3D.NaN);
  }
 else {
    setSize(getSize() / 3.0);
    setBarycenter(new Vector3D(1.0 / (4 * getSize()),(Vector3D)getBarycenter()));
  }
}","/** 
 * {@inheritDoc} 
 */
@Override protected void computeGeometricalProperties(){
  getTree(true).visit(new FacetsContributionVisitor());
  if (getSize() < 0) {
    setSize(Double.POSITIVE_INFINITY);
    setBarycenter((Point<Euclidean3D>)Vector3D.NaN);
  }
 else {
    setSize(getSize() / 3.0);
    setBarycenter((Point<Euclidean3D>)new Vector3D(1.0 / (4 * getSize()),(Vector3D)getBarycenter()));
  }
}"
57226,"/** 
 * Check if a point belongs to the boundary part of a node.
 * @param point point to check
 * @param node node containing the boundary facet to check
 * @return the boundary facet this points belongs to (or null if itdoes not belong to any boundary facet)
 */
private SubHyperplane<Euclidean3D> boundaryFacet(final Vector3D point,final BSPTree<Euclidean3D> node){
  final Vector2D point2D=((Plane)node.getCut().getHyperplane()).toSubSpace(point);
  @SuppressWarnings(""String_Node_Str"") final BoundaryAttribute<Euclidean3D> attribute=(BoundaryAttribute<Euclidean3D>)node.getAttribute();
  if ((attribute.getPlusOutside() != null) && (((SubPlane)attribute.getPlusOutside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {
    return attribute.getPlusOutside();
  }
  if ((attribute.getPlusInside() != null) && (((SubPlane)attribute.getPlusInside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {
    return attribute.getPlusInside();
  }
  return null;
}","/** 
 * Check if a point belongs to the boundary part of a node.
 * @param point point to check
 * @param node node containing the boundary facet to check
 * @return the boundary facet this points belongs to (or null if itdoes not belong to any boundary facet)
 */
private SubHyperplane<Euclidean3D> boundaryFacet(final Vector3D point,final BSPTree<Euclidean3D> node){
  final Vector2D point2D=((Plane)node.getCut().getHyperplane()).toSubSpace((Point<Euclidean3D>)point);
  @SuppressWarnings(""String_Node_Str"") final BoundaryAttribute<Euclidean3D> attribute=(BoundaryAttribute<Euclidean3D>)node.getAttribute();
  if ((attribute.getPlusOutside() != null) && (((SubPlane)attribute.getPlusOutside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {
    return attribute.getPlusOutside();
  }
  if ((attribute.getPlusInside() != null) && (((SubPlane)attribute.getPlusInside()).getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {
    return attribute.getPlusInside();
  }
  return null;
}"
57227,"/** 
 * Build an interval set from two points.
 * @param start start point
 * @param end end point
 * @return an interval set
 * @exception MathIllegalArgumentException if the points are equal
 */
private static IntervalsSet buildIntervalSet(final Vector3D start,final Vector3D end) throws MathIllegalArgumentException {
  final Line line=new Line(start,end);
  return new IntervalsSet(line.toSubSpace(start).getX(),line.toSubSpace(end).getX());
}","/** 
 * Build an interval set from two points.
 * @param start start point
 * @param end end point
 * @return an interval set
 * @exception MathIllegalArgumentException if the points are equal
 */
private static IntervalsSet buildIntervalSet(final Vector3D start,final Vector3D end) throws MathIllegalArgumentException {
  final Line line=new Line(start,end);
  return new IntervalsSet(line.toSubSpace((Point<Euclidean3D>)start).getX(),line.toSubSpace((Point<Euclidean3D>)end).getX());
}"
57228,"/** 
 * Get the intersection of the instance and another sub-line. <p> This method is related to the   {@link Line#intersection(Line) intersection} method in the {@link Line Line} class, but in additionto compute the point along infinite lines, it also checks the point lies on both sub-line ranges. </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong toinstance (i.e. they are closed sets) and may be returned, otherwise endpoints are considered to not belong to instance (i.e. they are open sets) and intersection occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
public Vector3D intersection(final SubLine subLine,final boolean includeEndPoints){
  Vector3D v1D=line.intersection(subLine.line);
  if (v1D == null) {
    return null;
  }
  Location loc1=remainingRegion.checkPoint(line.toSubSpace(v1D));
  Location loc2=subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));
  if (includeEndPoints) {
    return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
  }
 else {
    return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
  }
}","/** 
 * Get the intersection of the instance and another sub-line. <p> This method is related to the   {@link Line#intersection(Line) intersection} method in the {@link Line Line} class, but in additionto compute the point along infinite lines, it also checks the point lies on both sub-line ranges. </p>
 * @param subLine other sub-line which may intersect instance
 * @param includeEndPoints if true, endpoints are considered to belong toinstance (i.e. they are closed sets) and may be returned, otherwise endpoints are considered to not belong to instance (i.e. they are open sets) and intersection occurring on endpoints lead to null being returned
 * @return the intersection point if there is one, null if the sub-lines don't intersect
 */
public Vector3D intersection(final SubLine subLine,final boolean includeEndPoints){
  Vector3D v1D=line.intersection(subLine.line);
  if (v1D == null) {
    return null;
  }
  Location loc1=remainingRegion.checkPoint((Point<Euclidean1D>)line.toSubSpace((Point<Euclidean3D>)v1D));
  Location loc2=subLine.remainingRegion.checkPoint((Point<Euclidean1D>)subLine.line.toSubSpace((Point<Euclidean3D>)v1D));
  if (includeEndPoints) {
    return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
  }
 else {
    return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
  }
}"
57229,"/** 
 * Get the endpoints of the sub-line. <p> A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. </p>
 * @return list of segments endpoints
 */
public List<Segment> getSegments(){
  final List<Interval> list=remainingRegion.asList();
  final List<Segment> segments=new ArrayList<Segment>(list.size());
  for (  final Interval interval : list) {
    final Vector3D start=line.toSpace(new Vector1D(interval.getInf()));
    final Vector3D end=line.toSpace(new Vector1D(interval.getSup()));
    segments.add(new Segment(start,end,line));
  }
  return segments;
}","/** 
 * Get the endpoints of the sub-line. <p> A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. </p>
 * @return list of segments endpoints
 */
public List<Segment> getSegments(){
  final List<Interval> list=remainingRegion.asList();
  final List<Segment> segments=new ArrayList<Segment>(list.size());
  for (  final Interval interval : list) {
    final Vector3D start=line.toSpace((Point<Euclidean1D>)new Vector1D(interval.getInf()));
    final Vector3D end=line.toSpace((Point<Euclidean1D>)new Vector1D(interval.getSup()));
    segments.add(new Segment(start,end,line));
  }
  return segments;
}"
57230,"@Test public void testNextPoissonConsistency(){
  for (int i=1; i < 100; i++) {
    checkNextPoissonConsistency(i);
  }
  for (int i=1; i < 10; i++) {
    checkNextPoissonConsistency(randomData.nextUniform(1,1000));
  }
  for (int i=1; i < 10; i++) {
    checkNextPoissonConsistency(randomData.nextUniform(1000,3000));
  }
}","@Test public void testNextPoissonConsistency(){
  for (int i=1; i < 100; i++) {
    checkNextPoissonConsistency(i);
  }
  for (int i=1; i < 10; i++) {
    checkNextPoissonConsistency(randomData.nextUniform(1,1000));
  }
  for (int i=1; i < 10; i++) {
    checkNextPoissonConsistency(randomData.nextUniform(1000,10000));
  }
}"
57231,"/** 
 * Construct a new Sobol sequence generator for the given space dimension with direction vectors loaded from the given stream. <p> The expected format is identical to the files available from <a href=""http://web.maths.unsw.edu.au/~fkuo/sobol/"">Stephen Joe and Frances Kuo</a>. The first line will be ignored as it is assumed to contain only the column headers. The columns are: <ul> <li>d: the dimension</li> <li>s: the degree of the primitive polynomial</li> <li>a: the number representing the coefficients</li> <li>m: the list of initial direction numbers</li> </ul> Example: <pre> d       s       a       m_i 2       1       0       1 3       2       1       1 3 </pre>
 * @param dimension the space dimension
 * @param is the stream to read the direction vectors from
 * @throws NotStrictlyPositiveException if the space dimension is &lt; 1
 * @throws OutOfRangeException if the space dimension is outside the range [1, max], wheremax refers to the maximum dimension found in the input stream
 * @throws MathParseException if the content in the stream could not be parsed successfully
 * @throws IOException if an error occurs while reading from the input stream
 */
public SobolSequenceGenerator(final int dimension,final InputStream is) throws NotStrictlyPositiveException, MathParseException, IOException {
  if (dimension < 1) {
    throw new NotStrictlyPositiveException(dimension);
  }
  this.dimension=dimension;
  direction=new long[dimension][BITS + 1];
  x=new long[dimension];
  int lastDimension=initFromStream(is);
  if (lastDimension < dimension) {
    throw new OutOfRangeException(dimension,1,lastDimension);
  }
}","/** 
 * Construct a new Sobol sequence generator for the given space dimension with direction vectors loaded from the given stream. <p> The expected format is identical to the files available from <a href=""http://web.maths.unsw.edu.au/~fkuo/sobol/"">Stephen Joe and Frances Kuo</a>. The first line will be ignored as it is assumed to contain only the column headers. The columns are: <ul> <li>d: the dimension</li> <li>s: the degree of the primitive polynomial</li> <li>a: the number representing the coefficients</li> <li>m: the list of initial direction numbers</li> </ul> Example: <pre> d       s       a       m_i 2       1       0       1 3       2       1       1 3 </pre> <p> The input stream <i>must</i> be an ASCII text containing one valid direction vector per line.
 * @param dimension the space dimension
 * @param is the stream to read the direction vectors from
 * @throws NotStrictlyPositiveException if the space dimension is &lt; 1
 * @throws OutOfRangeException if the space dimension is outside the range [1, max], wheremax refers to the maximum dimension found in the input stream
 * @throws MathParseException if the content in the stream could not be parsed successfully
 * @throws IOException if an error occurs while reading from the input stream
 */
public SobolSequenceGenerator(final int dimension,final InputStream is) throws NotStrictlyPositiveException, MathParseException, IOException {
  if (dimension < 1) {
    throw new NotStrictlyPositiveException(dimension);
  }
  this.dimension=dimension;
  direction=new long[dimension][BITS + 1];
  x=new long[dimension];
  int lastDimension=initFromStream(is);
  if (lastDimension < dimension) {
    throw new OutOfRangeException(dimension,1,lastDimension);
  }
}"
57232,"/** 
 * Load the direction vector for each dimension from the given stream.
 * @param is the input stream to read the direction vector from
 * @return the last dimension that has been read from the input stream
 * @throws IOException if the stream could not be read
 * @throws MathParseException if the content could not be parsed successfully
 */
private int initFromStream(final InputStream is) throws MathParseException, IOException {
  for (int i=1; i <= BITS; i++) {
    direction[0][i]=1l << (BITS - i);
  }
  final BufferedReader reader=new BufferedReader(new InputStreamReader(is));
  int dim=-1;
  try {
    reader.readLine();
    int lineNumber=2;
    int index=1;
    String line=null;
    while ((line=reader.readLine()) != null) {
      StringTokenizer st=new StringTokenizer(line,""String_Node_Str"");
      try {
        dim=Integer.valueOf(st.nextToken());
        if (dim >= 2 && dim <= dimension) {
          final int s=Integer.valueOf(st.nextToken());
          final int a=Integer.valueOf(st.nextToken());
          final int[] m=new int[s + 1];
          for (int i=1; i <= s; i++) {
            m[i]=Integer.valueOf(st.nextToken());
          }
          initDirectionVector(index++,a,m);
        }
        if (dim > dimension) {
          return dim;
        }
      }
 catch (      NoSuchElementException e) {
        throw new MathParseException(line,lineNumber);
      }
catch (      NumberFormatException e) {
        throw new MathParseException(line,lineNumber);
      }
      lineNumber++;
    }
  }
  finally {
    reader.close();
  }
  return dim;
}","/** 
 * Load the direction vector for each dimension from the given stream. <p> The input stream <i>must</i> be an ASCII text containing one valid direction vector per line.
 * @param is the input stream to read the direction vector from
 * @return the last dimension that has been read from the input stream
 * @throws IOException if the stream could not be read
 * @throws MathParseException if the content could not be parsed successfully
 */
private int initFromStream(final InputStream is) throws MathParseException, IOException {
  for (int i=1; i <= BITS; i++) {
    direction[0][i]=1l << (BITS - i);
  }
  final Charset charset=Charset.forName(FILE_CHARSET);
  final BufferedReader reader=new BufferedReader(new InputStreamReader(is,charset));
  int dim=-1;
  try {
    reader.readLine();
    int lineNumber=2;
    int index=1;
    String line=null;
    while ((line=reader.readLine()) != null) {
      StringTokenizer st=new StringTokenizer(line,""String_Node_Str"");
      try {
        dim=Integer.valueOf(st.nextToken());
        if (dim >= 2 && dim <= dimension) {
          final int s=Integer.valueOf(st.nextToken());
          final int a=Integer.valueOf(st.nextToken());
          final int[] m=new int[s + 1];
          for (int i=1; i <= s; i++) {
            m[i]=Integer.valueOf(st.nextToken());
          }
          initDirectionVector(index++,a,m);
        }
        if (dim > dimension) {
          return dim;
        }
      }
 catch (      NoSuchElementException e) {
        throw new MathParseException(line,lineNumber);
      }
catch (      NumberFormatException e) {
        throw new MathParseException(line,lineNumber);
      }
      lineNumber++;
    }
  }
  finally {
    reader.close();
  }
  return dim;
}"
57233,"/** 
 * Helper method to create a multivariate normal mixture model which can be used to initialize   {@link #fit(MixtureMultivariateNormalDistribution)}. This method uses the data supplied to the constructor to try to determine a good mixture model at which to start the fit, but it is not guaranteed to supply a model which will find the optimal solution or even converge.
 * @param data Data to estimate distribution
 * @param numComponents Number of components for estimated mixture
 * @return Multivariate normal mixture model estimated from the data
 * @throws NumberIsTooLargeException if {@code numComponents} is greaterthan the number of data rows.
 * @throws NumberIsTooSmallException if {@code numComponents < 2}.
 * @throws NotStrictlyPositiveException if data has less than 2 rows
 * @throws DimensionMismatchException if rows of data have different numbersof columns
 */
public static MixtureMultivariateNormalDistribution estimate(final double[][] data,final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {
  if (data.length < 2) {
    throw new NotStrictlyPositiveException(data.length);
  }
  if (numComponents < 2) {
    throw new NumberIsTooSmallException(numComponents,2,true);
  }
  if (numComponents > data.length) {
    throw new NumberIsTooLargeException(numComponents,data.length,true);
  }
  final int numRows=data.length;
  final int numCols=data[0].length;
  final DataRow[] sortedData=new DataRow[numRows];
  for (int i=0; i < numRows; i++) {
    sortedData[i]=new DataRow(data[i]);
  }
  Arrays.sort(sortedData);
  final int totalBins=numComponents;
  final double weight=1d / totalBins;
  final List<Pair<Double,MultivariateNormalDistribution>> components=new ArrayList<Pair<Double,MultivariateNormalDistribution>>();
  for (int binNumber=1; binNumber <= totalBins; binNumber++) {
    final int minIndex=(int)FastMath.max(0,FastMath.floor((binNumber - 1) * numRows / totalBins));
    final int maxIndex=(int)FastMath.ceil(binNumber * numRows / numComponents) - 1;
    final int numBinRows=maxIndex - minIndex + 1;
    final double[][] binData=new double[numBinRows][numCols];
    final double[] columnMeans=new double[numCols];
    for (int i=minIndex, iBin=0; i <= maxIndex; i++, iBin++) {
      for (int j=0; j < numCols; j++) {
        final double val=sortedData[i].getRow()[j];
        columnMeans[j]+=val;
        binData[iBin][j]=val;
      }
    }
    MathArrays.scaleInPlace(1d / numBinRows,columnMeans);
    final double[][] covMat=new Covariance(binData).getCovarianceMatrix().getData();
    final MultivariateNormalDistribution mvn=new MultivariateNormalDistribution(columnMeans,covMat);
    components.add(new Pair<Double,MultivariateNormalDistribution>(weight,mvn));
  }
  return new MixtureMultivariateNormalDistribution(components);
}","/** 
 * Helper method to create a multivariate normal mixture model which can be used to initialize   {@link #fit(MixtureMultivariateNormalDistribution)}. This method uses the data supplied to the constructor to try to determine a good mixture model at which to start the fit, but it is not guaranteed to supply a model which will find the optimal solution or even converge.
 * @param data Data to estimate distribution
 * @param numComponents Number of components for estimated mixture
 * @return Multivariate normal mixture model estimated from the data
 * @throws NumberIsTooLargeException if {@code numComponents} is greaterthan the number of data rows.
 * @throws NumberIsTooSmallException if {@code numComponents < 2}.
 * @throws NotStrictlyPositiveException if data has less than 2 rows
 * @throws DimensionMismatchException if rows of data have different numbersof columns
 */
public static MixtureMultivariateNormalDistribution estimate(final double[][] data,final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {
  if (data.length < 2) {
    throw new NotStrictlyPositiveException(data.length);
  }
  if (numComponents < 2) {
    throw new NumberIsTooSmallException(numComponents,2,true);
  }
  if (numComponents > data.length) {
    throw new NumberIsTooLargeException(numComponents,data.length,true);
  }
  final int numRows=data.length;
  final int numCols=data[0].length;
  final DataRow[] sortedData=new DataRow[numRows];
  for (int i=0; i < numRows; i++) {
    sortedData[i]=new DataRow(data[i]);
  }
  Arrays.sort(sortedData);
  final double weight=1d / numComponents;
  final List<Pair<Double,MultivariateNormalDistribution>> components=new ArrayList<Pair<Double,MultivariateNormalDistribution>>();
  for (int binIndex=0; binIndex < numComponents; binIndex++) {
    final int minIndex=(binIndex * numRows) / numComponents;
    final int maxIndex=((binIndex + 1) * numRows) / numComponents;
    final int numBinRows=maxIndex - minIndex;
    final double[][] binData=new double[numBinRows][numCols];
    final double[] columnMeans=new double[numCols];
    for (int i=minIndex, iBin=0; i < maxIndex; i++, iBin++) {
      for (int j=0; j < numCols; j++) {
        final double val=sortedData[i].getRow()[j];
        columnMeans[j]+=val;
        binData[iBin][j]=val;
      }
    }
    MathArrays.scaleInPlace(1d / numBinRows,columnMeans);
    final double[][] covMat=new Covariance(binData).getCovarianceMatrix().getData();
    final MultivariateNormalDistribution mvn=new MultivariateNormalDistribution(columnMeans,covMat);
    components.add(new Pair<Double,MultivariateNormalDistribution>(weight,mvn));
  }
  return new MixtureMultivariateNormalDistribution(components);
}"
57234,"/** 
 * Performs an operation on the addressable elements of the array.
 * @param f Function to be applied on this array.
 * @return the result.
 * @since 3.1
 */
public double compute(MathArrays.Function f){
  return f.evaluate(internalArray,startIndex,numElements);
}","/** 
 * Performs an operation on the addressable elements of the array.
 * @param f Function to be applied on this array.
 * @return the result.
 * @since 3.1
 */
public double compute(MathArrays.Function f){
  final double[] array;
  final int start;
  final int num;
synchronized (this) {
    array=internalArray;
    start=startIndex;
    num=numElements;
  }
  return f.evaluate(array,start,num);
}"
57235,"/** 
 * Fit a mixture model to the data supplied to the constructor. The quality of the fit depends on the concavity of the data provided to the constructor and the initial mixture provided to this function. If the data has many local optima, multiple runs of the fitting function with different initial mixtures may be required to find the optimal solution. If a SingularMatrixException is encountered, it is possible that another initialization would work.
 * @param initialMixture Model containing initial values of weights andmultivariate normals
 * @throws SingularMatrixException if any component's covariance matrix issingular during fitting
 * @throws NotStrictlyPositiveException if numComponents is less than one orthreshold is less than Double.MIN_VALUE
 * @see #estimateMultivariateNormalMixtureModelDistribution
 */
public void fit(MixtureMultivariateNormalDistribution initialMixture) throws SingularMatrixException, NotStrictlyPositiveException {
  fit(initialMixture,defaultMaxIterations,defaultThreshold);
}","/** 
 * Fit a mixture model to the data supplied to the constructor. The quality of the fit depends on the concavity of the data provided to the constructor and the initial mixture provided to this function. If the data has many local optima, multiple runs of the fitting function with different initial mixtures may be required to find the optimal solution. If a SingularMatrixException is encountered, it is possible that another initialization would work.
 * @param initialMixture Model containing initial values of weights andmultivariate normals
 * @throws SingularMatrixException if any component's covariance matrix issingular during fitting
 * @throws NotStrictlyPositiveException if numComponents is less than one orthreshold is less than Double.MIN_VALUE
 */
public void fit(MixtureMultivariateNormalDistribution initialMixture) throws SingularMatrixException, NotStrictlyPositiveException {
  fit(initialMixture,defaultMaxIterations,defaultThreshold);
}"
57236,"/** 
 * Helper method to create a multivariate normal mixture model which can be used to initialize   {@link #fit(MixtureMultivariateRealDistribution)}. This method uses the data supplied to the constructor to try to determine a good mixture model at which to start the fit, but it is not guaranteed to supply a model which will find the optimal solution or even converge.
 * @param data Data to estimate distribution
 * @param numComponents Number of components for estimated mixture
 * @return Multivariate normal mixture model estimated from the data
 * @throws NumberIsTooLargeException if {@code numComponents\ is greaterthan the number of data rows.}
 * @throws NumberIsTooSmallException if {@code numComponents < 2}.
 * @throws NotStrictlyPositiveException if data has less than 2 rows
 * @throws DimensionMismatchException if rows of data have different numbersof columns
 * @see #fit
 */
public static MixtureMultivariateNormalDistribution estimate(final double[][] data,final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {
  if (data.length < 2) {
    throw new NotStrictlyPositiveException(data.length);
  }
  if (numComponents < 2) {
    throw new NumberIsTooSmallException(numComponents,2,true);
  }
  if (numComponents > data.length) {
    throw new NumberIsTooLargeException(numComponents,data.length,true);
  }
  final int numRows=data.length;
  final int numCols=data[0].length;
  final DataRow[] sortedData=new DataRow[numRows];
  for (int i=0; i < numRows; i++) {
    sortedData[i]=new DataRow(data[i]);
  }
  Arrays.sort(sortedData);
  final int totalBins=numComponents;
  final double weight=1d / totalBins;
  final List<Pair<Double,MultivariateNormalDistribution>> components=new ArrayList<Pair<Double,MultivariateNormalDistribution>>();
  for (int binNumber=1; binNumber <= totalBins; binNumber++) {
    final int minIndex=(int)FastMath.max(0,FastMath.floor((binNumber - 1) * numRows / totalBins));
    final int maxIndex=(int)FastMath.ceil(binNumber * numRows / numComponents) - 1;
    final int numBinRows=maxIndex - minIndex + 1;
    final double[][] binData=new double[numBinRows][numCols];
    final double[] columnMeans=new double[numCols];
    for (int i=minIndex, iBin=0; i <= maxIndex; i++, iBin++) {
      for (int j=0; j < numCols; j++) {
        final double val=sortedData[i].getRow()[j];
        columnMeans[j]+=val;
        binData[iBin][j]=val;
      }
    }
    MathArrays.scaleInPlace(1d / numBinRows,columnMeans);
    final double[][] covMat=new Covariance(binData).getCovarianceMatrix().getData();
    final MultivariateNormalDistribution mvn=new MultivariateNormalDistribution(columnMeans,covMat);
    components.add(new Pair<Double,MultivariateNormalDistribution>(weight,mvn));
  }
  return new MixtureMultivariateNormalDistribution(components);
}","/** 
 * Helper method to create a multivariate normal mixture model which can be used to initialize   {@link #fit(MixtureMultivariateNormalDistribution)}. This method uses the data supplied to the constructor to try to determine a good mixture model at which to start the fit, but it is not guaranteed to supply a model which will find the optimal solution or even converge.
 * @param data Data to estimate distribution
 * @param numComponents Number of components for estimated mixture
 * @return Multivariate normal mixture model estimated from the data
 * @throws NumberIsTooLargeException if {@code numComponents} is greaterthan the number of data rows.
 * @throws NumberIsTooSmallException if {@code numComponents < 2}.
 * @throws NotStrictlyPositiveException if data has less than 2 rows
 * @throws DimensionMismatchException if rows of data have different numbersof columns
 */
public static MixtureMultivariateNormalDistribution estimate(final double[][] data,final int numComponents) throws NotStrictlyPositiveException, DimensionMismatchException {
  if (data.length < 2) {
    throw new NotStrictlyPositiveException(data.length);
  }
  if (numComponents < 2) {
    throw new NumberIsTooSmallException(numComponents,2,true);
  }
  if (numComponents > data.length) {
    throw new NumberIsTooLargeException(numComponents,data.length,true);
  }
  final int numRows=data.length;
  final int numCols=data[0].length;
  final DataRow[] sortedData=new DataRow[numRows];
  for (int i=0; i < numRows; i++) {
    sortedData[i]=new DataRow(data[i]);
  }
  Arrays.sort(sortedData);
  final int totalBins=numComponents;
  final double weight=1d / totalBins;
  final List<Pair<Double,MultivariateNormalDistribution>> components=new ArrayList<Pair<Double,MultivariateNormalDistribution>>();
  for (int binNumber=1; binNumber <= totalBins; binNumber++) {
    final int minIndex=(int)FastMath.max(0,FastMath.floor((binNumber - 1) * numRows / totalBins));
    final int maxIndex=(int)FastMath.ceil(binNumber * numRows / numComponents) - 1;
    final int numBinRows=maxIndex - minIndex + 1;
    final double[][] binData=new double[numBinRows][numCols];
    final double[] columnMeans=new double[numCols];
    for (int i=minIndex, iBin=0; i <= maxIndex; i++, iBin++) {
      for (int j=0; j < numCols; j++) {
        final double val=sortedData[i].getRow()[j];
        columnMeans[j]+=val;
        binData[iBin][j]=val;
      }
    }
    MathArrays.scaleInPlace(1d / numBinRows,columnMeans);
    final double[][] covMat=new Covariance(binData).getCovarianceMatrix().getData();
    final MultivariateNormalDistribution mvn=new MultivariateNormalDistribution(columnMeans,covMat);
    components.add(new Pair<Double,MultivariateNormalDistribution>(weight,mvn));
  }
  return new MixtureMultivariateNormalDistribution(components);
}"
57237,"/** 
 * Runs the K-means++ clustering algorithm.
 * @param points the points to cluster
 * @return a list of clusters containing the points
 * @throws MathIllegalArgumentException if the data points are null or the numberof clusters is larger than the number of data points
 * @throws ConvergenceException if an empty cluster is encountered and the{@link #emptyStrategy} is set to {@code ERROR}
 */
public List<CentroidCluster<T>> cluster(final Collection<T> points) throws MathIllegalArgumentException, ConvergenceException {
  List<CentroidCluster<T>> best=null;
  double bestVarianceSum=Double.POSITIVE_INFINITY;
  for (int i=0; i < numTrials; ++i) {
    List<CentroidCluster<T>> clusters=clusterer.cluster(points);
    double varianceSum=0.0;
    for (    final CentroidCluster<T> cluster : clusters) {
      if (!cluster.getPoints().isEmpty()) {
        final Clusterable center=cluster.getCenter();
        final Variance stat=new Variance();
        for (        final T point : cluster.getPoints()) {
          stat.increment(distance(point,center));
        }
        varianceSum+=stat.getResult();
      }
    }
    if (varianceSum <= bestVarianceSum) {
      best=clusters;
      bestVarianceSum=varianceSum;
    }
  }
  return best;
}","/** 
 * Runs the K-means++ clustering algorithm.
 * @param points the points to cluster
 * @return a list of clusters containing the points
 * @throws MathIllegalArgumentException if the data points are null or the numberof clusters is larger than the number of data points
 * @throws ConvergenceException if an empty cluster is encountered and theunderlying  {@link KMeansPlusPlusClusterer} has its{@link KMeansPlusPlusClusterer.EmptyClusterStrategy} is set to {@code ERROR}.
 */
public List<CentroidCluster<T>> cluster(final Collection<T> points) throws MathIllegalArgumentException, ConvergenceException {
  List<CentroidCluster<T>> best=null;
  double bestVarianceSum=Double.POSITIVE_INFINITY;
  for (int i=0; i < numTrials; ++i) {
    List<CentroidCluster<T>> clusters=clusterer.cluster(points);
    double varianceSum=0.0;
    for (    final CentroidCluster<T> cluster : clusters) {
      if (!cluster.getPoints().isEmpty()) {
        final Clusterable center=cluster.getCenter();
        final Variance stat=new Variance();
        for (        final T point : cluster.getPoints()) {
          stat.increment(distance(point,center));
        }
        varianceSum+=stat.getResult();
      }
    }
    if (varianceSum <= bestVarianceSum) {
      best=clusters;
      bestVarianceSum=varianceSum;
    }
  }
  return best;
}"
57238,"/** 
 * Create a discrete distribution using the given random number generator and probability mass function definition.
 * @param rng random number generator.
 * @param singletons array of random variable values.
 * @param probabilities array of probabilities.
 * @throws DimensionMismatchException if{@code singletons.length != probabilities.length}
 * @throws NotPositiveException if probability of at least one value isnegative.
 * @throws MathArithmeticException if the probabilities sum to zero.
 * @throws MathIllegalArgumentException if probability of at least one valueis infinite.
 */
public DiscreteIntegerDistribution(final RandomGenerator rng,final int[] singletons,final double[] probabilities) throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
  super(rng);
  if (singletons.length != probabilities.length) {
    throw new DimensionMismatchException(probabilities.length,singletons.length);
  }
  final List<Pair<Integer,Double>> samples=new ArrayList<Pair<Integer,Double>>(singletons.length);
  for (int i=0; i < singletons.length; i++) {
    samples.add(new Pair<Integer,Double>(singletons[i],probabilities[i]));
  }
  innerDistribution=new DiscreteDistribution<Integer>(rng,samples);
}","/** 
 * Create a discrete distribution using the given random number generator and probability mass function definition.
 * @param rng random number generator.
 * @param singletons array of random variable values.
 * @param probabilities array of probabilities.
 * @throws DimensionMismatchException if {@code singletons.length != probabilities.length}
 * @throws NotPositiveException if probability of at least one value is negative.
 * @throws MathArithmeticException if the probabilities sum to zero.
 * @throws MathIllegalArgumentException if probability of at least one value is infinite.
 */
public DiscreteIntegerDistribution(final RandomGenerator rng,final int[] singletons,final double[] probabilities) throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
  super(rng);
  if (singletons.length != probabilities.length) {
    throw new DimensionMismatchException(probabilities.length,singletons.length);
  }
  final List<Pair<Integer,Double>> samples=new ArrayList<Pair<Integer,Double>>(singletons.length);
  for (int i=0; i < singletons.length; i++) {
    samples.add(new Pair<Integer,Double>(singletons[i],probabilities[i]));
  }
  innerDistribution=new DiscreteDistribution<Integer>(rng,samples);
}"
57239,"/** 
 * {@inheritDoc}
 */
@Override public int sample(){
  return innerDistribution.sample();
}","@Override public int sample(){
  return innerDistribution.sample();
}"
57240,"/** 
 * {@inheritDoc}
 */
@Override public double probability(final double x){
  return innerDistribution.probability(x);
}","@Override public double probability(final double x){
  return innerDistribution.probability(x);
}"
57241,"/** 
 * Create a discrete distribution using the given random number generator and probability mass function definition.
 * @param rng random number generator.
 * @param singletons array of random variable values.
 * @param probabilities array of probabilities.
 * @throws DimensionMismatchException if{@code singletons.length != probabilities.length}
 * @throws NotPositiveException if probability of at least one value isnegative.
 * @throws MathArithmeticException if the probabilities sum to zero.
 * @throws MathIllegalArgumentException if probability of at least one valueis infinite.
 */
public DiscreteRealDistribution(final RandomGenerator rng,final double[] singletons,final double[] probabilities) throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
  super(rng);
  if (singletons.length != probabilities.length) {
    throw new DimensionMismatchException(probabilities.length,singletons.length);
  }
  List<Pair<Double,Double>> samples=new ArrayList<Pair<Double,Double>>(singletons.length);
  for (int i=0; i < singletons.length; i++) {
    samples.add(new Pair<Double,Double>(singletons[i],probabilities[i]));
  }
  innerDistribution=new DiscreteDistribution<Double>(rng,samples);
}","/** 
 * Create a discrete distribution using the given random number generator and probability mass function definition.
 * @param rng random number generator.
 * @param singletons array of random variable values.
 * @param probabilities array of probabilities.
 * @throws DimensionMismatchException if {@code singletons.length != probabilities.length}
 * @throws NotPositiveException if probability of at least one value is negative.
 * @throws MathArithmeticException if the probabilities sum to zero.
 * @throws MathIllegalArgumentException if probability of at least one value is infinite.
 */
public DiscreteRealDistribution(final RandomGenerator rng,final double[] singletons,final double[] probabilities) throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
  super(rng);
  if (singletons.length != probabilities.length) {
    throw new DimensionMismatchException(probabilities.length,singletons.length);
  }
  List<Pair<Double,Double>> samples=new ArrayList<Pair<Double,Double>>(singletons.length);
  for (int i=0; i < singletons.length; i++) {
    samples.add(new Pair<Double,Double>(singletons[i],probabilities[i]));
  }
  innerDistribution=new DiscreteDistribution<Double>(rng,samples);
}"
57242,"/** 
 * {@inheritDoc}
 */
@Override public double sample(){
  return innerDistribution.sample();
}","@Override public double sample(){
  return innerDistribution.sample();
}"
57243,"/** 
 * {@inheritDoc} 
 */
@Override public DiagonalMatrix copy(){
  return new DiagonalMatrix(data);
}","/** 
 * {@inheritDoc} 
 */
@Override public RealMatrix copy(){
  return new DiagonalMatrix(data);
}"
57244,"@Test public void testCopy(){
  final double[] d={-1.2,3.4,5};
  final DiagonalMatrix m=new DiagonalMatrix(d,false);
  final DiagonalMatrix p=m.copy();
  for (int i=0; i < m.getRowDimension(); ++i) {
    Assert.assertEquals(m.getEntry(i,i),p.getEntry(i,i),1.0e-20);
  }
}","@Test public void testCopy(){
  final double[] d={-1.2,3.4,5};
  final DiagonalMatrix m=new DiagonalMatrix(d,false);
  final DiagonalMatrix p=(DiagonalMatrix)m.copy();
  for (int i=0; i < m.getRowDimension(); ++i) {
    Assert.assertEquals(m.getEntry(i,i),p.getEntry(i,i),1.0e-20);
  }
}"
57245,"/** 
 * Calculates the QR-decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @param threshold Singularity threshold.
 */
public RRQRDecomposition(RealMatrix matrix,double threshold){
  super(matrix,threshold);
}","/** 
 * Calculates the QR-decomposition of the given matrix.
 * @param matrix The matrix to decompose.
 * @param threshold Singularity threshold.
 * @see #RRQRDecomposition(RealMatrix)
 */
public RRQRDecomposition(RealMatrix matrix,double threshold){
  super(matrix,threshold);
}"
57246,"/** 
 * Compute a linear combination accurately. <p> This method computes a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> + a<sub>4</sub>&times;b<sub>4</sub> to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547""> Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput. </p> <p> Note that the instance is only used as a prototype to get proper elements dimensions. Its value is not used, only the parameters values are used. </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @param a4 first factor of the third term
 * @param b4 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> + a<sub>4</sub>&times;b<sub>4</sub>
 * @see #linearCombination(double,T,double,T)
 * @see #linearCombination(double,T,double,T,double,T)
 * @since 3.2
 */
T linearCombination(double a1,T b1,double a2,T b2,double a3,T b3,double a4,T b4);","/** 
 * Compute a linear combination accurately. <p> This method computes a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> + a<sub>4</sub>&times;b<sub>4</sub> to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper <a href=""http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547""> Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput. </p> <p> Note that the instance is only used as a prototype to get proper elements dimensions. Its value is not used, only the parameters values are used. </p>
 * @param a1 first factor of the first term
 * @param b1 second factor of the first term
 * @param a2 first factor of the second term
 * @param b2 second factor of the second term
 * @param a3 first factor of the third term
 * @param b3 second factor of the third term
 * @param a4 first factor of the third term
 * @param b4 second factor of the third term
 * @return a<sub>1</sub>&times;b<sub>1</sub> +a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> + a<sub>4</sub>&times;b<sub>4</sub>
 * @see #linearCombination(double,Object,double,Object)
 * @see #linearCombination(double,Object,double,Object,double,Object)
 * @since 3.2
 */
T linearCombination(double a1,T b1,double a2,T b2,double a3,T b3,double a4,T b4);"
57247,"/** 
 * Get the closest long to instance value.
 * @return closest long to {@link #getValue()}
 */
long round();","/** 
 * Get the closest long to instance value.
 * @return closest long to {@link #getReal()}
 */
long round();"
57248,"/** 
 * Get the normalized axis of the rotation.
 * @return normalized axis of the rotation
 * @see #Rotation(FieldVector3D,T)
 */
public FieldVector3D<T> getAxis(){
  final T squaredSine=q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));
  if (squaredSine.getReal() == 0) {
    final Field<T> field=squaredSine.getField();
    return new FieldVector3D<T>(field.getOne(),field.getZero(),field.getZero());
  }
 else   if (q0.getReal() < 0) {
    T inverse=squaredSine.sqrt().reciprocal();
    return new FieldVector3D<T>(q1.multiply(inverse),q2.multiply(inverse),q3.multiply(inverse));
  }
  final T inverse=squaredSine.sqrt().reciprocal().negate();
  return new FieldVector3D<T>(q1.multiply(inverse),q2.multiply(inverse),q3.multiply(inverse));
}","/** 
 * Get the normalized axis of the rotation.
 * @return normalized axis of the rotation
 * @see #FieldRotation(FieldVector3D,ExtendedFieldElement)
 */
public FieldVector3D<T> getAxis(){
  final T squaredSine=q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3));
  if (squaredSine.getReal() == 0) {
    final Field<T> field=squaredSine.getField();
    return new FieldVector3D<T>(field.getOne(),field.getZero(),field.getZero());
  }
 else   if (q0.getReal() < 0) {
    T inverse=squaredSine.sqrt().reciprocal();
    return new FieldVector3D<T>(q1.multiply(inverse),q2.multiply(inverse),q3.multiply(inverse));
  }
  final T inverse=squaredSine.sqrt().reciprocal().negate();
  return new FieldVector3D<T>(q1.multiply(inverse),q2.multiply(inverse),q3.multiply(inverse));
}"
57249,"/** 
 * Get the angle of the rotation.
 * @return angle of the rotation (between 0 and &pi;)
 * @see #Rotation(FieldVector3D,T)
 */
public T getAngle(){
  if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {
    return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);
  }
 else   if (q0.getReal() < 0) {
    return q0.negate().acos().multiply(2);
  }
  return q0.acos().multiply(2);
}","/** 
 * Get the angle of the rotation.
 * @return angle of the rotation (between 0 and &pi;)
 * @see #FieldRotation(FieldVector3D,ExtendedFieldElement)
 */
public T getAngle(){
  if ((q0.getReal() < -0.1) || (q0.getReal() > 0.1)) {
    return q1.multiply(q1).add(q2.multiply(q2)).add(q3.multiply(q3)).sqrt().asin().multiply(2);
  }
 else   if (q0.getReal() < 0) {
    return q0.negate().acos().multiply(2);
  }
  return q0.acos().multiply(2);
}"
57250,"/** 
 * Get the elevation of the vector.
 * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2
 * @see #Vector3D(T,T)
 */
public T getDelta(){
  return z.divide(getNorm()).asin();
}","/** 
 * Get the elevation of the vector.
 * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2
 * @see #FieldVector3D(ExtendedFieldElement,ExtendedFieldElement)
 */
public T getDelta(){
  return z.divide(getNorm()).asin();
}"
57251,"/** 
 * Get the azimuth of the vector.
 * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;
 * @see #Vector3D(T,T)
 */
public T getAlpha(){
  return y.atan2(x);
}","/** 
 * Get the azimuth of the vector.
 * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;
 * @see #FieldVector3D(ExtendedFieldElement,ExtendedFieldElement)
 */
public T getAlpha(){
  return y.atan2(x);
}"
57252,"/** 
 * Get the vector coordinates as a dimension 3 array.
 * @return vector coordinates
 * @see #Vector3D(T[])
 */
public T[] toArray(){
  final T[] array=MathArrays.buildArray(x.getField(),3);
  array[0]=x;
  array[1]=y;
  array[2]=z;
  return array;
}","/** 
 * Get the vector coordinates as a dimension 3 array.
 * @return vector coordinates
 * @see #FieldVector3D(ExtendedFieldElement[])
 */
public T[] toArray(){
  final T[] array=MathArrays.buildArray(x.getField(),3);
  array[0]=x;
  array[1]=y;
  array[2]=z;
  return array;
}"
57253,"/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #Vector3D(T,T,T)
 */
public T getX(){
  return x;
}","/** 
 * Get the abscissa of the vector.
 * @return abscissa of the vector
 * @see #FieldVector3D(ExtendedFieldElement,ExtendedFieldElement,ExtendedFieldElement)
 */
public T getX(){
  return x;
}"
57254,"/** 
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #Vector3D(T,T,T)
 */
public T getY(){
  return y;
}","/** 
 * Get the ordinate of the vector.
 * @return ordinate of the vector
 * @see #FieldVector3D(ExtendedFieldElement,ExtendedFieldElement,ExtendedFieldElement)
 */
public T getY(){
  return y;
}"
57255,"/** 
 * Get the height of the vector.
 * @return height of the vector
 * @see #Vector3D(T,T,T)
 */
public T getZ(){
  return z;
}","/** 
 * Get the height of the vector.
 * @return height of the vector
 * @see #FieldVector3D(ExtendedFieldElement,ExtendedFieldElement,ExtendedFieldElement)
 */
public T getZ(){
  return z;
}"
57256,"/** 
 * Test for the equality of two 3D vectors. <p> If all coordinates of two 3D vectors are exactly the same, and none are <code>T.NaN</code>, the two 3D vectors are considered to be equal. </p> <p> <code>NaN</code> coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 3D vector are equal to <code>T.NaN</code>, the 3D vector is equal to  {@link #NaN}. </p>
 * @param other Object to test for equality to this
 * @return true if two 3D vector objects are equal, false ifobject is null, not an instance of Vector3D, or not equal to this Vector3D instance
 */
@Override public boolean equals(Object other){
  if (this == other) {
    return true;
  }
  if (other instanceof FieldVector3D) {
    @SuppressWarnings(""String_Node_Str"") final FieldVector3D<T> rhs=(FieldVector3D<T>)other;
    if (rhs.isNaN()) {
      return this.isNaN();
    }
    return x.equals(rhs.x) && y.equals(rhs.y) && z.equals(rhs.z);
  }
  return false;
}","/** 
 * Test for the equality of two 3D vectors. <p> If all coordinates of two 3D vectors are exactly the same, and none of their  {@link ExtendedFieldElement#getReal() real part} are <code>NaN</code>, thetwo 3D vectors are considered to be equal. </p> <p> <code>NaN</code> coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) real part of the coordinates of the 3D vector are <code>NaN</code>, the 3D vector is <code>NaN</code>. </p>
 * @param other Object to test for equality to this
 * @return true if two 3D vector objects are equal, false ifobject is null, not an instance of Vector3D, or not equal to this Vector3D instance
 */
@Override public boolean equals(Object other){
  if (this == other) {
    return true;
  }
  if (other instanceof FieldVector3D) {
    @SuppressWarnings(""String_Node_Str"") final FieldVector3D<T> rhs=(FieldVector3D<T>)other;
    if (rhs.isNaN()) {
      return this.isNaN();
    }
    return x.equals(rhs.x) && y.equals(rhs.y) && z.equals(rhs.z);
  }
  return false;
}"
57257,"/** 
 * {@inheritDoc} 
 */
public String toString(final NumberFormat format){
  return new Vector3DFormat(format).format(toVector3D());
}","/** 
 * Get a string representation of this vector.
 * @param format the custom format for components
 * @return a string representation of this vector
 */
public String toString(final NumberFormat format){
  return new Vector3DFormat(format).format(toVector3D());
}"
57258,"/** 
 * Scans the list of (required and optional) optimization data that characterize the problem.
 * @param optData Optimization data.The following data will be looked for: <ul> <li> {@link InitialStep}</li> </ul>
 */
@Override protected void parseOptimizationData(OptimizationData... optData){
  super.parseOptimizationData(optData);
  for (  OptimizationData data : optData) {
    if (data instanceof BracketingStep) {
      initialStep=((BracketingStep)data).getBracketingStep();
      break;
    }
  }
  checkParameters();
}","/** 
 * Scans the list of (required and optional) optimization data that characterize the problem.
 * @param optData Optimization data.The following data will be looked for: <ul> <li> {@link BracketingStep}</li> </ul>
 */
@Override protected void parseOptimizationData(OptimizationData... optData){
  super.parseOptimizationData(optData);
  for (  OptimizationData data : optData) {
    if (data instanceof BracketingStep) {
      initialStep=((BracketingStep)data).getBracketingStep();
      break;
    }
  }
  checkParameters();
}"
57259,"/** 
 * {@inheritDoc}
 * @param optData Optimization data. In addition to those documented in{@link MultivariateOptimizer#parseOptimizationData(OptimizationData[]) MultivariateOptimizer}, this method will register the following data: <ul> <li>  {@link ModelFunctionJacobian}</li> </ul>
 * @return {@inheritDoc}
 * @throws TooManyEvaluationsException if the maximal number ofevaluations is exceeded.
 * @throws DimensionMismatchException if the initial guess, target, and weightarguments have inconsistent dimensions.
 */
@Override public PointVectorValuePair optimize(OptimizationData... optData) throws TooManyEvaluationsException, DimensionMismatchException {
  return super.optimize(optData);
}","/** 
 * {@inheritDoc}
 * @param optData Optimization data. In addition to those documented in{@link MultivariateVectorOptimizer#optimize(OptimizationData)}MultivariateOptimizer}, this method will register the following data: <ul> <li>  {@link ModelFunctionJacobian}</li> </ul>
 * @return {@inheritDoc}
 * @throws TooManyEvaluationsException if the maximal number ofevaluations is exceeded.
 * @throws DimensionMismatchException if the initial guess, target, and weightarguments have inconsistent dimensions.
 */
@Override public PointVectorValuePair optimize(OptimizationData... optData) throws TooManyEvaluationsException, DimensionMismatchException {
  return super.optimize(optData);
}"
57260,"/** 
 * Returns a pseudorandom, uniformly distributed <tt>long</tt> value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence.
 * @param n the bound on the random number to be returned.  Must bepositive.
 * @return  a pseudorandom, uniformly distributed <tt>long</tt>value between 0 (inclusive) and n (exclusive).
 * @throws IllegalArgumentException  if n is not positive.
 */
private static long nextLong(final SecureRandom rng,final long n) throws IllegalArgumentException {
  if (n > 0) {
    final byte[] byteArray=new byte[8];
    long bits;
    long val;
    do {
      rng.nextBytes(byteArray);
      bits=0;
      for (      final byte b : byteArray) {
        bits=(bits << 8) | (((long)b) & 0xffL);
      }
      bits=bits & 0x7fffffffffffffffL;
      val=bits % n;
    }
 while (bits - val + (n - 1) < 0);
    return val;
  }
  throw new NotStrictlyPositiveException(n);
}","/** 
 * Returns a pseudorandom, uniformly distributed <tt>long</tt> value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence.
 * @param rng random generator to use
 * @param n the bound on the random number to be returned.  Must bepositive.
 * @return  a pseudorandom, uniformly distributed <tt>long</tt>value between 0 (inclusive) and n (exclusive).
 * @throws IllegalArgumentException  if n is not positive.
 */
private static long nextLong(final SecureRandom rng,final long n) throws IllegalArgumentException {
  if (n > 0) {
    final byte[] byteArray=new byte[8];
    long bits;
    long val;
    do {
      rng.nextBytes(byteArray);
      bits=0;
      for (      final byte b : byteArray) {
        bits=(bits << 8) | (((long)b) & 0xffL);
      }
      bits=bits & 0x7fffffffffffffffL;
      val=bits % n;
    }
 while (bits - val + (n - 1) < 0);
    return val;
  }
  throw new NotStrictlyPositiveException(n);
}"
57261,"/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public UnivariateFunction derivative(){
  return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative();
}","/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public DifferentiableUnivariateFunction derivative(){
  return new Constant(0);
}"
57262,"/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public UnivariateFunction derivative(){
  return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative();
}","/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public DifferentiableUnivariateFunction derivative(){
  return new Sinh();
}"
57263,"/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public UnivariateFunction derivative(){
  return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative();
}","/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public DifferentiableUnivariateFunction derivative(){
  return new Constant(1);
}"
57264,"/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public UnivariateFunction derivative(){
  return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative();
}","/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public DifferentiableUnivariateFunction derivative(){
  return new Constant(-1);
}"
57265,"/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public UnivariateFunction derivative(){
  return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative();
}","/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public DifferentiableUnivariateFunction derivative(){
  return new Cos();
}"
57266,"/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public UnivariateFunction derivative(){
  return FunctionUtils.toDifferentiableUnivariateFunction(this).derivative();
}","/** 
 * {@inheritDoc}
 * @deprecated as of 3.1, replaced by {@link #value(DerivativeStructure)}
 */
@Deprecated public DifferentiableUnivariateFunction derivative(){
  return new Cosh();
}"
57267,"/** 
 * Creates a new EmpiricalDistribution with default bin count using the provided   {@link RandomDataImpl} as the source of random data.
 * @param randomData random data generator (may be null, resulting in default JDK generator)
 * @since 3.0
 */
public EmpiricalDistribution(RandomDataImpl randomData){
  this(DEFAULT_BIN_COUNT,randomData);
}","/** 
 * Creates a new EmpiricalDistribution with default bin count using the provided   {@link RandomDataImpl} as the source of random data.
 * @param randomData random data generator (may be null, resulting in default JDK generator)
 * @since 3.0
 */
public EmpiricalDistribution(RandomDataGenerator randomData){
  this(DEFAULT_BIN_COUNT,randomData);
}"
57268,"/** 
 * Construct a ValueServer instance using a RandomDataImpl as its source of random data.
 * @param randomData the RandomDataImpl instance used to source random data
 * @since 3.0
 */
public ValueServer(RandomDataImpl randomData){
  this.randomData=randomData;
}","/** 
 * Construct a ValueServer instance using a RandomDataImpl as its source of random data.
 * @param randomData the RandomDataImpl instance used to source random data
 * @since 3.0
 */
public ValueServer(RandomDataGenerator randomData){
  this.randomData=randomData;
}"
57269,"/** 
 * Returns the value of log B(p, q) for 0 ≤ x ≤ 1 and p, q > 0. Based on the <em>NSWC Library of Mathematics Subroutines</em> implementation,  {@code DBETLN}.
 * @param p First argument.
 * @param q Second argument.
 * @return the value of {@code log(Beta(p, q))},   {@code NaN} if{@code p <= 0} or {@code q <= 0}.
 */
public static final double logBeta(final double p,final double q){
  if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0)|| (q <= 0.0)) {
    return Double.NaN;
  }
  final double a=FastMath.min(p,q);
  final double b=FastMath.max(p,q);
  if (a >= 10.0) {
    final double w=sumDeltaMinusDeltaSum(a,b);
    final double h=a / b;
    final double c=h / (1.0 + h);
    final double u=-(a - 0.5) * FastMath.log(c);
    final double v=b * FastMath.log1p(h);
    if (u <= v) {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;
    }
 else {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;
    }
  }
 else   if (a > 2.0) {
    if (b > 1000.0) {
      final int n=(int)FastMath.floor(a - 1.0);
      double prod=1.0;
      double ared=a;
      for (int i=0; i < n; i++) {
        ared-=1.0;
        prod*=ared / (1.0 + ared / b);
      }
      return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b));
    }
 else {
      double prod1=1.0;
      double ared=a;
      while (ared > 2.0) {
        ared-=1.0;
        final double h=ared / b;
        prod1*=h / (1.0 + h);
      }
      if (b < 10.0) {
        double prod2=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod2*=bred / (ared + bred);
        }
        return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared,bred)));
      }
 else {
        return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b);
      }
    }
  }
 else   if (a >= 1.0) {
    if (b > 2.0) {
      if (b < 10.0) {
        double prod=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod*=bred / (a + bred);
        }
        return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a,bred)));
      }
 else {
        return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
      }
    }
 else {
      return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a,b);
    }
  }
 else {
    if (b >= 10.0) {
      return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
    }
 else {
      return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));
    }
  }
}","/** 
 * Returns the value of log B(p, q) for 0 ≤ x ≤ 1 and p, q > 0. Based on the <em>NSWC Library of Mathematics Subroutines</em> implementation,  {@code DBETLN}.
 * @param p First argument.
 * @param q Second argument.
 * @return the value of {@code log(Beta(p, q))},   {@code NaN} if{@code p <= 0} or {@code q <= 0}.
 */
public static double logBeta(final double p,final double q){
  if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0)|| (q <= 0.0)) {
    return Double.NaN;
  }
  final double a=FastMath.min(p,q);
  final double b=FastMath.max(p,q);
  if (a >= 10.0) {
    final double w=sumDeltaMinusDeltaSum(a,b);
    final double h=a / b;
    final double c=h / (1.0 + h);
    final double u=-(a - 0.5) * FastMath.log(c);
    final double v=b * FastMath.log1p(h);
    if (u <= v) {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;
    }
 else {
      return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;
    }
  }
 else   if (a > 2.0) {
    if (b > 1000.0) {
      final int n=(int)FastMath.floor(a - 1.0);
      double prod=1.0;
      double ared=a;
      for (int i=0; i < n; i++) {
        ared-=1.0;
        prod*=ared / (1.0 + ared / b);
      }
      return (FastMath.log(prod) - n * FastMath.log(b)) + (Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b));
    }
 else {
      double prod1=1.0;
      double ared=a;
      while (ared > 2.0) {
        ared-=1.0;
        final double h=ared / b;
        prod1*=h / (1.0 + h);
      }
      if (b < 10.0) {
        double prod2=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod2*=bred / (ared + bred);
        }
        return FastMath.log(prod1) + FastMath.log(prod2) + (Gamma.logGamma(ared) + (Gamma.logGamma(bred) - logGammaSum(ared,bred)));
      }
 else {
        return FastMath.log(prod1) + Gamma.logGamma(ared) + logGammaMinusLogGammaSum(ared,b);
      }
    }
  }
 else   if (a >= 1.0) {
    if (b > 2.0) {
      if (b < 10.0) {
        double prod=1.0;
        double bred=b;
        while (bred > 2.0) {
          bred-=1.0;
          prod*=bred / (a + bred);
        }
        return FastMath.log(prod) + (Gamma.logGamma(a) + (Gamma.logGamma(bred) - logGammaSum(a,bred)));
      }
 else {
        return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
      }
    }
 else {
      return Gamma.logGamma(a) + Gamma.logGamma(b) - logGammaSum(a,b);
    }
  }
 else {
    if (b >= 10.0) {
      return Gamma.logGamma(a) + logGammaMinusLogGammaSum(a,b);
    }
 else {
      return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) / Gamma.gamma(a + b));
    }
  }
}"
57270,"/** 
 * Find eigenvectors from a matrix transformed to Schur form.
 * @param schur the schur transformation of the matrix
 * @throws MathArithmeticException if the Schur form has a norm of zero
 */
private void findEigenVectorsFromSchur(final SchurTransformer schur){
  final double[][] matrixT=schur.getT().getData();
  final double[][] matrixP=schur.getP().getData();
  final int n=matrixT.length;
  double norm=0.0;
  for (int i=0; i < n; i++) {
    for (int j=FastMath.max(i - 1,0); j < n; j++) {
      norm=norm + FastMath.abs(matrixT[i][j]);
    }
  }
  if (Precision.equals(norm,0.0,epsilon)) {
    throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
  }
  double r=0.0;
  double s=0.0;
  double z=0.0;
  for (int idx=n - 1; idx >= 0; idx--) {
    double p=realEigenvalues[idx];
    double q=imagEigenvalues[idx];
    if (Precision.equals(q,0.0)) {
      int l=idx;
      matrixT[idx][idx]=1.0;
      for (int i=idx - 1; i >= 0; i--) {
        double w=matrixT[i][i] - p;
        r=0.0;
        for (int j=l; j <= idx; j++) {
          r=r + matrixT[i][j] * matrixT[j][idx];
        }
        if (Precision.compareTo(imagEigenvalues[i],0.0,epsilon) < 0.0) {
          z=w;
          s=r;
        }
 else {
          l=i;
          if (Precision.equals(imagEigenvalues[i],0.0)) {
            if (w != 0.0) {
              matrixT[i][idx]=-r / w;
            }
 else {
              matrixT[i][idx]=-r / (Precision.EPSILON * norm);
            }
          }
 else {
            double x=matrixT[i][i + 1];
            double y=matrixT[i + 1][i];
            q=(realEigenvalues[i] - p) * (realEigenvalues[i] - p) + imagEigenvalues[i] * imagEigenvalues[i];
            double t=(x * s - z * r) / q;
            matrixT[i][idx]=t;
            if (FastMath.abs(x) > FastMath.abs(z)) {
              matrixT[i + 1][idx]=(-r - w * t) / x;
            }
 else {
              matrixT[i + 1][idx]=(-s - y * t) / z;
            }
          }
          double t=FastMath.abs(matrixT[i][idx]);
          if ((Precision.EPSILON * t) * t > 1) {
            for (int j=i; j <= idx; j++) {
              matrixT[j][idx]=matrixT[j][idx] / t;
            }
          }
        }
      }
    }
 else     if (q < 0.0) {
      int l=idx - 1;
      if (FastMath.abs(matrixT[idx][idx - 1]) > FastMath.abs(matrixT[idx - 1][idx])) {
        matrixT[idx - 1][idx - 1]=q / matrixT[idx][idx - 1];
        matrixT[idx - 1][idx]=-(matrixT[idx][idx] - p) / matrixT[idx][idx - 1];
      }
 else {
        final Complex result=cdiv(0.0,-matrixT[idx - 1][idx],matrixT[idx - 1][idx - 1] - p,q);
        matrixT[idx - 1][idx - 1]=result.getReal();
        matrixT[idx - 1][idx]=result.getImaginary();
      }
      matrixT[idx][idx - 1]=0.0;
      matrixT[idx][idx]=1.0;
      for (int i=idx - 2; i >= 0; i--) {
        double ra=0.0;
        double sa=0.0;
        for (int j=l; j <= idx; j++) {
          ra=ra + matrixT[i][j] * matrixT[j][idx - 1];
          sa=sa + matrixT[i][j] * matrixT[j][idx];
        }
        double w=matrixT[i][i] - p;
        if (Precision.compareTo(imagEigenvalues[i],0.0,epsilon) < 0.0) {
          z=w;
          r=ra;
          s=sa;
        }
 else {
          l=i;
          if (Precision.equals(imagEigenvalues[i],0.0)) {
            final Complex c=cdiv(-ra,-sa,w,q);
            matrixT[i][idx - 1]=c.getReal();
            matrixT[i][idx]=c.getImaginary();
          }
 else {
            double x=matrixT[i][i + 1];
            double y=matrixT[i + 1][i];
            double vr=(realEigenvalues[i] - p) * (realEigenvalues[i] - p) + imagEigenvalues[i] * imagEigenvalues[i] - q * q;
            final double vi=(realEigenvalues[i] - p) * 2.0 * q;
            if (Precision.equals(vr,0.0) && Precision.equals(vi,0.0)) {
              vr=Precision.EPSILON * norm * (FastMath.abs(w) + FastMath.abs(q) + FastMath.abs(x)+ FastMath.abs(y)+ FastMath.abs(z));
            }
            final Complex c=cdiv(x * r - z * ra + q * sa,x * s - z * sa - q * ra,vr,vi);
            matrixT[i][idx - 1]=c.getReal();
            matrixT[i][idx]=c.getImaginary();
            if (FastMath.abs(x) > (FastMath.abs(z) + FastMath.abs(q))) {
              matrixT[i + 1][idx - 1]=(-ra - w * matrixT[i][idx - 1] + q * matrixT[i][idx]) / x;
              matrixT[i + 1][idx]=(-sa - w * matrixT[i][idx] - q * matrixT[i][idx - 1]) / x;
            }
 else {
              final Complex c2=cdiv(-r - y * matrixT[i][idx - 1],-s - y * matrixT[i][idx],z,q);
              matrixT[i + 1][idx - 1]=c2.getReal();
              matrixT[i + 1][idx]=c2.getImaginary();
            }
          }
          double t=FastMath.max(FastMath.abs(matrixT[i][idx - 1]),FastMath.abs(matrixT[i][idx]));
          if ((Precision.EPSILON * t) * t > 1) {
            for (int j=i; j <= idx; j++) {
              matrixT[j][idx - 1]=matrixT[j][idx - 1] / t;
              matrixT[j][idx]=matrixT[j][idx] / t;
            }
          }
        }
      }
    }
  }
  for (int i=0; i < n; i++) {
    if (i < 0 | i > n - 1) {
      for (int j=i; j < n; j++) {
        matrixP[i][j]=matrixT[i][j];
      }
    }
  }
  for (int j=n - 1; j >= 0; j--) {
    for (int i=0; i <= n - 1; i++) {
      z=0.0;
      for (int k=0; k <= FastMath.min(j,n - 1); k++) {
        z=z + matrixP[i][k] * matrixT[k][j];
      }
      matrixP[i][j]=z;
    }
  }
  eigenvectors=new ArrayRealVector[n];
  final double[] tmp=new double[n];
  for (int i=0; i < n; i++) {
    for (int j=0; j < n; j++) {
      tmp[j]=matrixP[j][i];
    }
    eigenvectors[i]=new ArrayRealVector(tmp);
  }
}","/** 
 * Find eigenvectors from a matrix transformed to Schur form.
 * @param schur the schur transformation of the matrix
 * @throws MathArithmeticException if the Schur form has a norm of zero
 */
private void findEigenVectorsFromSchur(final SchurTransformer schur){
  final double[][] matrixT=schur.getT().getData();
  final double[][] matrixP=schur.getP().getData();
  final int n=matrixT.length;
  double norm=0.0;
  for (int i=0; i < n; i++) {
    for (int j=FastMath.max(i - 1,0); j < n; j++) {
      norm=norm + FastMath.abs(matrixT[i][j]);
    }
  }
  if (Precision.equals(norm,0.0,EPSILON)) {
    throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);
  }
  double r=0.0;
  double s=0.0;
  double z=0.0;
  for (int idx=n - 1; idx >= 0; idx--) {
    double p=realEigenvalues[idx];
    double q=imagEigenvalues[idx];
    if (Precision.equals(q,0.0)) {
      int l=idx;
      matrixT[idx][idx]=1.0;
      for (int i=idx - 1; i >= 0; i--) {
        double w=matrixT[i][i] - p;
        r=0.0;
        for (int j=l; j <= idx; j++) {
          r=r + matrixT[i][j] * matrixT[j][idx];
        }
        if (Precision.compareTo(imagEigenvalues[i],0.0,EPSILON) < 0.0) {
          z=w;
          s=r;
        }
 else {
          l=i;
          if (Precision.equals(imagEigenvalues[i],0.0)) {
            if (w != 0.0) {
              matrixT[i][idx]=-r / w;
            }
 else {
              matrixT[i][idx]=-r / (Precision.EPSILON * norm);
            }
          }
 else {
            double x=matrixT[i][i + 1];
            double y=matrixT[i + 1][i];
            q=(realEigenvalues[i] - p) * (realEigenvalues[i] - p) + imagEigenvalues[i] * imagEigenvalues[i];
            double t=(x * s - z * r) / q;
            matrixT[i][idx]=t;
            if (FastMath.abs(x) > FastMath.abs(z)) {
              matrixT[i + 1][idx]=(-r - w * t) / x;
            }
 else {
              matrixT[i + 1][idx]=(-s - y * t) / z;
            }
          }
          double t=FastMath.abs(matrixT[i][idx]);
          if ((Precision.EPSILON * t) * t > 1) {
            for (int j=i; j <= idx; j++) {
              matrixT[j][idx]=matrixT[j][idx] / t;
            }
          }
        }
      }
    }
 else     if (q < 0.0) {
      int l=idx - 1;
      if (FastMath.abs(matrixT[idx][idx - 1]) > FastMath.abs(matrixT[idx - 1][idx])) {
        matrixT[idx - 1][idx - 1]=q / matrixT[idx][idx - 1];
        matrixT[idx - 1][idx]=-(matrixT[idx][idx] - p) / matrixT[idx][idx - 1];
      }
 else {
        final Complex result=cdiv(0.0,-matrixT[idx - 1][idx],matrixT[idx - 1][idx - 1] - p,q);
        matrixT[idx - 1][idx - 1]=result.getReal();
        matrixT[idx - 1][idx]=result.getImaginary();
      }
      matrixT[idx][idx - 1]=0.0;
      matrixT[idx][idx]=1.0;
      for (int i=idx - 2; i >= 0; i--) {
        double ra=0.0;
        double sa=0.0;
        for (int j=l; j <= idx; j++) {
          ra=ra + matrixT[i][j] * matrixT[j][idx - 1];
          sa=sa + matrixT[i][j] * matrixT[j][idx];
        }
        double w=matrixT[i][i] - p;
        if (Precision.compareTo(imagEigenvalues[i],0.0,EPSILON) < 0.0) {
          z=w;
          r=ra;
          s=sa;
        }
 else {
          l=i;
          if (Precision.equals(imagEigenvalues[i],0.0)) {
            final Complex c=cdiv(-ra,-sa,w,q);
            matrixT[i][idx - 1]=c.getReal();
            matrixT[i][idx]=c.getImaginary();
          }
 else {
            double x=matrixT[i][i + 1];
            double y=matrixT[i + 1][i];
            double vr=(realEigenvalues[i] - p) * (realEigenvalues[i] - p) + imagEigenvalues[i] * imagEigenvalues[i] - q * q;
            final double vi=(realEigenvalues[i] - p) * 2.0 * q;
            if (Precision.equals(vr,0.0) && Precision.equals(vi,0.0)) {
              vr=Precision.EPSILON * norm * (FastMath.abs(w) + FastMath.abs(q) + FastMath.abs(x)+ FastMath.abs(y)+ FastMath.abs(z));
            }
            final Complex c=cdiv(x * r - z * ra + q * sa,x * s - z * sa - q * ra,vr,vi);
            matrixT[i][idx - 1]=c.getReal();
            matrixT[i][idx]=c.getImaginary();
            if (FastMath.abs(x) > (FastMath.abs(z) + FastMath.abs(q))) {
              matrixT[i + 1][idx - 1]=(-ra - w * matrixT[i][idx - 1] + q * matrixT[i][idx]) / x;
              matrixT[i + 1][idx]=(-sa - w * matrixT[i][idx] - q * matrixT[i][idx - 1]) / x;
            }
 else {
              final Complex c2=cdiv(-r - y * matrixT[i][idx - 1],-s - y * matrixT[i][idx],z,q);
              matrixT[i + 1][idx - 1]=c2.getReal();
              matrixT[i + 1][idx]=c2.getImaginary();
            }
          }
          double t=FastMath.max(FastMath.abs(matrixT[i][idx - 1]),FastMath.abs(matrixT[i][idx]));
          if ((Precision.EPSILON * t) * t > 1) {
            for (int j=i; j <= idx; j++) {
              matrixT[j][idx - 1]=matrixT[j][idx - 1] / t;
              matrixT[j][idx]=matrixT[j][idx] / t;
            }
          }
        }
      }
    }
  }
  for (int i=0; i < n; i++) {
    if (i < 0 | i > n - 1) {
      for (int j=i; j < n; j++) {
        matrixP[i][j]=matrixT[i][j];
      }
    }
  }
  for (int j=n - 1; j >= 0; j--) {
    for (int i=0; i <= n - 1; i++) {
      z=0.0;
      for (int k=0; k <= FastMath.min(j,n - 1); k++) {
        z=z + matrixP[i][k] * matrixT[k][j];
      }
      matrixP[i][j]=z;
    }
  }
  eigenvectors=new ArrayRealVector[n];
  final double[] tmp=new double[n];
  for (int i=0; i < n; i++) {
    for (int j=0; j < n; j++) {
      tmp[j]=matrixP[j][i];
    }
    eigenvectors[i]=new ArrayRealVector(tmp);
  }
}"
57271,"/** 
 * Returns whether the calculated eigen values are complex or real. <p>The method performs a zero check for each element of the  {@link #getImagEigenvalues()} array and returns {@code true} if anyelement is not equal to zero.
 * @return {@code true} if the eigen values are complex, {@code false} otherwise
 * @since 3.1
 */
public boolean hasComplexEigenvalues(){
  for (int i=0; i < imagEigenvalues.length; i++) {
    if (!Precision.equals(imagEigenvalues[i],0.0,epsilon)) {
      return true;
    }
  }
  return false;
}","/** 
 * Returns whether the calculated eigen values are complex or real. <p>The method performs a zero check for each element of the  {@link #getImagEigenvalues()} array and returns {@code true} if anyelement is not equal to zero.
 * @return {@code true} if the eigen values are complex, {@code false} otherwise
 * @since 3.1
 */
public boolean hasComplexEigenvalues(){
  for (int i=0; i < imagEigenvalues.length; i++) {
    if (!Precision.equals(imagEigenvalues[i],0.0,EPSILON)) {
      return true;
    }
  }
  return false;
}"
57272,"/** 
 * Transforms the matrix to Schur form and calculates the eigenvalues.
 * @param matrix Matrix to transform.
 * @return the {@link SchurTransform} for this matrix
 */
private SchurTransformer transformToSchur(final RealMatrix matrix){
  final SchurTransformer schurTransform=new SchurTransformer(matrix);
  final double[][] matT=schurTransform.getT().getData();
  realEigenvalues=new double[matT.length];
  imagEigenvalues=new double[matT.length];
  for (int i=0; i < realEigenvalues.length; i++) {
    if (i == (realEigenvalues.length - 1) || Precision.equals(matT[i + 1][i],0.0,epsilon)) {
      realEigenvalues[i]=matT[i][i];
    }
 else {
      final double x=matT[i + 1][i + 1];
      final double p=0.5 * (matT[i][i] - x);
      final double z=FastMath.sqrt(FastMath.abs(p * p + matT[i + 1][i] * matT[i][i + 1]));
      realEigenvalues[i]=x + p;
      imagEigenvalues[i]=z;
      realEigenvalues[i + 1]=x + p;
      imagEigenvalues[i + 1]=-z;
      i++;
    }
  }
  return schurTransform;
}","/** 
 * Transforms the matrix to Schur form and calculates the eigenvalues.
 * @param matrix Matrix to transform.
 * @return the {@link SchurTransform} for this matrix
 */
private SchurTransformer transformToSchur(final RealMatrix matrix){
  final SchurTransformer schurTransform=new SchurTransformer(matrix);
  final double[][] matT=schurTransform.getT().getData();
  realEigenvalues=new double[matT.length];
  imagEigenvalues=new double[matT.length];
  for (int i=0; i < realEigenvalues.length; i++) {
    if (i == (realEigenvalues.length - 1) || Precision.equals(matT[i + 1][i],0.0,EPSILON)) {
      realEigenvalues[i]=matT[i][i];
    }
 else {
      final double x=matT[i + 1][i + 1];
      final double p=0.5 * (matT[i][i] - x);
      final double z=FastMath.sqrt(FastMath.abs(p * p + matT[i + 1][i] * matT[i][i + 1]));
      realEigenvalues[i]=x + p;
      imagEigenvalues[i]=z;
      realEigenvalues[i + 1]=x + p;
      imagEigenvalues[i + 1]=-z;
      i++;
    }
  }
  return schurTransform;
}"
57273,"/** 
 * Gets the block diagonal matrix D of the decomposition. D is a block diagonal matrix. Real eigenvalues are on the diagonal while complex values are on 2x2 blocks { {real +imaginary}, {-imaginary, real} }.
 * @return the D matrix.
 * @see #getRealEigenvalues()
 * @see #getImagEigenvalues()
 */
public RealMatrix getD(){
  if (cachedD == null) {
    cachedD=MatrixUtils.createRealDiagonalMatrix(realEigenvalues);
    for (int i=0; i < imagEigenvalues.length; i++) {
      if (Precision.compareTo(imagEigenvalues[i],0.0,epsilon) > 0) {
        cachedD.setEntry(i,i + 1,imagEigenvalues[i]);
      }
 else       if (Precision.compareTo(imagEigenvalues[i],0.0,epsilon) < 0) {
        cachedD.setEntry(i,i - 1,imagEigenvalues[i]);
      }
    }
  }
  return cachedD;
}","/** 
 * Gets the block diagonal matrix D of the decomposition. D is a block diagonal matrix. Real eigenvalues are on the diagonal while complex values are on 2x2 blocks { {real +imaginary}, {-imaginary, real} }.
 * @return the D matrix.
 * @see #getRealEigenvalues()
 * @see #getImagEigenvalues()
 */
public RealMatrix getD(){
  if (cachedD == null) {
    cachedD=MatrixUtils.createRealDiagonalMatrix(realEigenvalues);
    for (int i=0; i < imagEigenvalues.length; i++) {
      if (Precision.compareTo(imagEigenvalues[i],0.0,EPSILON) > 0) {
        cachedD.setEntry(i,i + 1,imagEigenvalues[i]);
      }
 else       if (Precision.compareTo(imagEigenvalues[i],0.0,EPSILON) < 0) {
        cachedD.setEntry(i,i - 1,imagEigenvalues[i]);
      }
    }
  }
  return cachedD;
}"
57274,"/** 
 * Raise a double to an int power.
 * @param d Number to raise.
 * @param e Exponent.
 * @return d<sup>e</sup>
 */
public static double pow(double d,int e){
  if (e == 0) {
    return 1.0;
  }
 else   if (e < 0) {
    e=-e;
    d=1.0 / d;
  }
  double result=1;
  double d2p=d;
  while (e != 0) {
    if ((e & 0x1) != 0) {
      result*=d2p;
    }
    d2p*=d2p;
    e=e >> 1;
  }
  return result;
}","/** 
 * Raise a double to an int power.
 * @param d Number to raise.
 * @param e Exponent.
 * @return d<sup>e</sup>
 */
public static double pow(double d,int e){
  if (e == 0) {
    return 1.0;
  }
 else   if (e < 0) {
    e=-e;
    d=1.0 / d;
  }
  final int splitFactor=0x8000001;
  final double cd=splitFactor * d;
  final double d1High=cd - (cd - d);
  final double d1Low=d - d1High;
  double resultHigh=1;
  double resultLow=0;
  double d2p=d;
  double d2pHigh=d1High;
  double d2pLow=d1Low;
  while (e != 0) {
    if ((e & 0x1) != 0) {
      final double tmpHigh=resultHigh * d2p;
      final double cRH=splitFactor * resultHigh;
      final double rHH=cRH - (cRH - resultHigh);
      final double rHL=resultHigh - rHH;
      final double tmpLow=rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);
      resultHigh=tmpHigh;
      resultLow=resultLow * d2p + tmpLow;
    }
    final double tmpHigh=d2pHigh * d2p;
    final double cD2pH=splitFactor * d2pHigh;
    final double d2pHH=cD2pH - (cD2pH - d2pHigh);
    final double d2pHL=d2pHigh - d2pHH;
    final double tmpLow=d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);
    final double cTmpH=splitFactor * tmpHigh;
    d2pHigh=cTmpH - (cTmpH - tmpHigh);
    d2pLow=d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);
    d2p=d2pHigh + d2pLow;
    e=e >> 1;
  }
  return resultHigh + resultLow;
}"
57275,"@Test public void testIntPow(){
  final double base=1.23456789;
  final int maxExp=300;
  for (int i=0; i < maxExp; i++) {
    final double expected=FastMath.pow(base,(double)i);
    Assert.assertEquals(""String_Node_Str"" + i,expected,FastMath.pow(base,i),60 * Math.ulp(expected));
  }
}","@Test public void testIntPow(){
  final int maxExp=300;
  DfpField field=new DfpField(40);
  final double base=1.23456789;
  Dfp baseDfp=field.newDfp(base);
  Dfp dfpPower=field.getOne();
  for (int i=0; i < maxExp; i++) {
    Assert.assertEquals(""String_Node_Str"" + i,dfpPower.toDouble(),FastMath.pow(base,i),0.6 * FastMath.ulp(dfpPower.toDouble()));
    dfpPower=dfpPower.multiply(baseDfp);
  }
}"
57276,"/** 
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(SimplexTableau tableau,final int col){
  List<Integer> minRatioPositions=new ArrayList<Integer>();
  double minRatio=Double.MAX_VALUE;
  for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
    final double rhs=tableau.getEntry(i,tableau.getWidth() - 1);
    final double entry=tableau.getEntry(i,col);
    if (Precision.compareTo(entry,0d,maxUlps) > 0) {
      final double ratio=rhs / entry;
      final int cmp=Double.compare(ratio,minRatio);
      if (cmp == 0) {
        minRatioPositions.add(i);
      }
 else       if (cmp < 0) {
        minRatio=ratio;
        minRatioPositions=new ArrayList<Integer>();
        minRatioPositions.add(i);
      }
    }
  }
  if (minRatioPositions.size() == 0) {
    return null;
  }
 else   if (minRatioPositions.size() > 1) {
    if (tableau.getNumArtificialVariables() > 0) {
      for (      Integer row : minRatioPositions) {
        for (int i=0; i < tableau.getNumArtificialVariables(); i++) {
          int column=i + tableau.getArtificialVariableOffset();
          final double entry=tableau.getEntry(row,column);
          if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {
            return row;
          }
        }
      }
    }
    if (getIterations() < getMaxIterations() / 2) {
      Integer minRow=null;
      int minIndex=tableau.getWidth();
      for (      Integer row : minRatioPositions) {
        int i=tableau.getNumObjectiveFunctions();
        for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
          if (row == tableau.getBasicRow(i)) {
            if (i < minIndex) {
              minIndex=i;
              minRow=row;
            }
          }
        }
      }
      return minRow;
    }
  }
  return minRatioPositions.get(0);
}","/** 
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(SimplexTableau tableau,final int col){
  List<Integer> minRatioPositions=new ArrayList<Integer>();
  double minRatio=Double.MAX_VALUE;
  for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
    final double rhs=tableau.getEntry(i,tableau.getWidth() - 1);
    final double entry=tableau.getEntry(i,col);
    if (Precision.compareTo(entry,0d,maxUlps) > 0) {
      final double ratio=rhs / entry;
      final int cmp=Double.compare(ratio,minRatio);
      if (cmp == 0) {
        minRatioPositions.add(i);
      }
 else       if (cmp < 0) {
        minRatio=ratio;
        minRatioPositions=new ArrayList<Integer>();
        minRatioPositions.add(i);
      }
    }
  }
  if (minRatioPositions.size() == 0) {
    return null;
  }
 else   if (minRatioPositions.size() > 1) {
    if (tableau.getNumArtificialVariables() > 0) {
      for (      Integer row : minRatioPositions) {
        for (int i=0; i < tableau.getNumArtificialVariables(); i++) {
          int column=i + tableau.getArtificialVariableOffset();
          final double entry=tableau.getEntry(row,column);
          if (Precision.equals(entry,1d,maxUlps) && row.equals(tableau.getBasicRow(column))) {
            return row;
          }
        }
      }
    }
    if (getIterations() < getMaxIterations() / 2) {
      Integer minRow=null;
      int minIndex=tableau.getWidth();
      for (      Integer row : minRatioPositions) {
        int i=tableau.getNumObjectiveFunctions();
        for (; i < tableau.getWidth() - 1 && !row.equals(minRow); i++) {
          Integer basicRow=tableau.getBasicRow(i);
          if (basicRow != null && basicRow.equals(row)) {
            if (i < minIndex) {
              minIndex=i;
              minRow=row;
            }
          }
        }
      }
      return minRow;
    }
  }
  return minRatioPositions.get(0);
}"
57277,"/** 
 * Transform original matrix to Schur form.
 * @throws MaxCountExceededException if the transformation does not converge
 */
private void transform(){
  final int n=matrixT.length;
  final double norm=getNorm();
  final ShiftInfo shift=new ShiftInfo();
  int iteration=0;
  int idx=n - 1;
  while (idx >= 0) {
    final int l=findSmallSubDiagonalElement(idx,norm);
    if (l == idx) {
      matrixT[idx][idx]=matrixT[idx][idx] + shift.exShift;
      idx--;
      iteration=0;
    }
 else     if (l == idx - 1) {
      shift.w=matrixT[idx][idx - 1] * matrixT[idx - 1][idx];
      double p=(matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;
      double q=p * p + shift.w;
      double z=FastMath.sqrt(FastMath.abs(q));
      matrixT[idx][idx]=matrixT[idx][idx] + shift.exShift;
      matrixT[idx - 1][idx - 1]=matrixT[idx - 1][idx - 1] + shift.exShift;
      shift.x=matrixT[idx][idx];
      if (q >= 0) {
        if (p >= 0) {
          z=p + z;
        }
 else {
          z=p - z;
        }
        shift.x=matrixT[idx][idx - 1];
        double s=FastMath.abs(shift.x) + FastMath.abs(z);
        p=shift.x / s;
        q=z / s;
        double r=FastMath.sqrt(p * p + q * q);
        p=p / r;
        q=q / r;
        for (int j=idx - 1; j < n; j++) {
          z=matrixT[idx - 1][j];
          matrixT[idx - 1][j]=q * z + p * matrixT[idx][j];
          matrixT[idx][j]=q * matrixT[idx][j] - p * z;
        }
        for (int i=0; i <= idx; i++) {
          z=matrixT[i][idx - 1];
          matrixT[i][idx - 1]=q * z + p * matrixT[i][idx];
          matrixT[i][idx]=q * matrixT[i][idx] - p * z;
        }
        for (int i=0; i <= n - 1; i++) {
          z=matrixP[i][idx - 1];
          matrixP[i][idx - 1]=q * z + p * matrixP[i][idx];
          matrixP[i][idx]=q * matrixP[i][idx] - p * z;
        }
      }
      idx-=2;
      iteration=0;
    }
 else {
      computeShift(l,idx,iteration,shift);
      if (++iteration > maxIterations) {
        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,maxIterations);
      }
      int m=idx - 2;
      final double[] hVec=new double[3];
      while (m >= l) {
        double z=matrixT[m][m];
        hVec[2]=shift.x - z;
        double s=shift.y - z;
        hVec[0]=(hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];
        hVec[1]=matrixT[m + 1][m + 1] - z - hVec[2]- s;
        hVec[2]=matrixT[m + 2][m + 1];
        s=FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);
        if (m == l) {
          break;
        }
        for (int i=0; i < hVec.length; i++) {
          hVec[i]/=s;
        }
        final double lhs=FastMath.abs(matrixT[m][m - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));
        final double rhs=FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[m + 1][m + 1]));
        if (lhs < epsilon * rhs) {
          break;
        }
        m--;
      }
      performDoubleQRStep(l,m,idx,shift,hVec);
    }
  }
}","/** 
 * Transform original matrix to Schur form.
 * @throws MaxCountExceededException if the transformation does not converge
 */
private void transform(){
  final int n=matrixT.length;
  final double norm=getNorm();
  final ShiftInfo shift=new ShiftInfo();
  int iteration=0;
  int idx=n - 1;
  while (idx >= 0) {
    final int l=findSmallSubDiagonalElement(idx,norm);
    if (l == idx) {
      matrixT[idx][idx]=matrixT[idx][idx] + shift.exShift;
      idx--;
      iteration=0;
    }
 else     if (l == idx - 1) {
      shift.w=matrixT[idx][idx - 1] * matrixT[idx - 1][idx];
      double p=(matrixT[idx - 1][idx - 1] - matrixT[idx][idx]) / 2.0;
      double q=p * p + shift.w;
      double z=FastMath.sqrt(FastMath.abs(q));
      matrixT[idx][idx]=matrixT[idx][idx] + shift.exShift;
      matrixT[idx - 1][idx - 1]=matrixT[idx - 1][idx - 1] + shift.exShift;
      shift.x=matrixT[idx][idx];
      if (q >= 0) {
        if (p >= 0) {
          z=p + z;
        }
 else {
          z=p - z;
        }
        shift.x=matrixT[idx][idx - 1];
        double s=FastMath.abs(shift.x) + FastMath.abs(z);
        p=shift.x / s;
        q=z / s;
        double r=FastMath.sqrt(p * p + q * q);
        p=p / r;
        q=q / r;
        for (int j=idx - 1; j < n; j++) {
          z=matrixT[idx - 1][j];
          matrixT[idx - 1][j]=q * z + p * matrixT[idx][j];
          matrixT[idx][j]=q * matrixT[idx][j] - p * z;
        }
        for (int i=0; i <= idx; i++) {
          z=matrixT[i][idx - 1];
          matrixT[i][idx - 1]=q * z + p * matrixT[i][idx];
          matrixT[i][idx]=q * matrixT[i][idx] - p * z;
        }
        for (int i=0; i <= n - 1; i++) {
          z=matrixP[i][idx - 1];
          matrixP[i][idx - 1]=q * z + p * matrixP[i][idx];
          matrixP[i][idx]=q * matrixP[i][idx] - p * z;
        }
      }
      idx-=2;
      iteration=0;
    }
 else {
      computeShift(l,idx,iteration,shift);
      if (++iteration > MAX_ITERATIONS) {
        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,MAX_ITERATIONS);
      }
      int m=idx - 2;
      final double[] hVec=new double[3];
      while (m >= l) {
        double z=matrixT[m][m];
        hVec[2]=shift.x - z;
        double s=shift.y - z;
        hVec[0]=(hVec[2] * s - shift.w) / matrixT[m + 1][m] + matrixT[m][m + 1];
        hVec[1]=matrixT[m + 1][m + 1] - z - hVec[2]- s;
        hVec[2]=matrixT[m + 2][m + 1];
        s=FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);
        if (m == l) {
          break;
        }
        for (int i=0; i < hVec.length; i++) {
          hVec[i]/=s;
        }
        final double lhs=FastMath.abs(matrixT[m][m - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));
        final double rhs=FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[m - 1][m - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[m + 1][m + 1]));
        if (lhs < epsilon * rhs) {
          break;
        }
        m--;
      }
      performDoubleQRStep(l,m,idx,shift,hVec);
    }
  }
}"
57278,"/** 
 * Perform a double QR step involving rows l:idx and columns m:n
 * @param l the index of the small sub-diagonal element
 * @param m the start index for the QR step
 * @param idx the current eigenvalue index
 * @param shift shift information holder
 * @param hVec the initial houseHolder vector
 */
private void performDoubleQRStep(final int l,final int m,final int idx,final ShiftInfo shift,final double[] hVec){
  final int n=matrixT.length;
  double p=hVec[0];
  double q=hVec[1];
  double r=hVec[2];
  for (int k=m; k <= idx - 1; k++) {
    boolean notlast=k != idx - 1;
    if (k != m) {
      p=matrixT[k][k - 1];
      q=matrixT[k + 1][k - 1];
      r=notlast ? matrixT[k + 2][k - 1] : 0.0;
      shift.x=FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);
      if (!Precision.equals(shift.x,0.0,epsilon)) {
        p=p / shift.x;
        q=q / shift.x;
        r=r / shift.x;
      }
    }
    if (Precision.equals(shift.x,0.0,epsilon)) {
      break;
    }
    double s=FastMath.sqrt(p * p + q * q + r * r);
    if (Precision.compareTo(p,0.0,epsilon) < 0) {
      s=-s;
    }
    if (!Precision.equals(s,0.0,epsilon)) {
      if (k != m) {
        matrixT[k][k - 1]=-s * shift.x;
      }
 else       if (l != m) {
        matrixT[k][k - 1]=-matrixT[k][k - 1];
      }
      p=p + s;
      shift.x=p / s;
      shift.y=q / s;
      double z=r / s;
      q=q / p;
      r=r / p;
      for (int j=k; j < n; j++) {
        p=matrixT[k][j] + q * matrixT[k + 1][j];
        if (notlast) {
          p=p + r * matrixT[k + 2][j];
          matrixT[k + 2][j]=matrixT[k + 2][j] - p * z;
        }
        matrixT[k][j]=matrixT[k][j] - p * shift.x;
        matrixT[k + 1][j]=matrixT[k + 1][j] - p * shift.y;
      }
      for (int i=0; i <= FastMath.min(idx,k + 3); i++) {
        p=shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];
        if (notlast) {
          p=p + z * matrixT[i][k + 2];
          matrixT[i][k + 2]=matrixT[i][k + 2] - p * r;
        }
        matrixT[i][k]=matrixT[i][k] - p;
        matrixT[i][k + 1]=matrixT[i][k + 1] - p * q;
      }
      final int high=matrixT.length - 1;
      for (int i=0; i <= high; i++) {
        p=shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];
        if (notlast) {
          p=p + z * matrixP[i][k + 2];
          matrixP[i][k + 2]=matrixP[i][k + 2] - p * r;
        }
        matrixP[i][k]=matrixP[i][k] - p;
        matrixP[i][k + 1]=matrixP[i][k + 1] - p * q;
      }
    }
  }
  for (int i=m + 2; i <= idx; i++) {
    matrixT[i][i - 2]=0.0;
    if (i > m + 2) {
      matrixT[i][i - 3]=0.0;
    }
  }
}","/** 
 * Perform a double QR step involving rows l:idx and columns m:n
 * @param l the index of the small sub-diagonal element
 * @param m the start index for the QR step
 * @param idx the current eigenvalue index
 * @param shift shift information holder
 * @param hVec the initial houseHolder vector
 */
private void performDoubleQRStep(final int l,final int m,final int idx,final ShiftInfo shift,final double[] hVec){
  final int n=matrixT.length;
  double p=hVec[0];
  double q=hVec[1];
  double r=hVec[2];
  for (int k=m; k <= idx - 1; k++) {
    boolean notlast=k != idx - 1;
    if (k != m) {
      p=matrixT[k][k - 1];
      q=matrixT[k + 1][k - 1];
      r=notlast ? matrixT[k + 2][k - 1] : 0.0;
      shift.x=FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);
      if (!Precision.equals(shift.x,0.0,epsilon)) {
        p=p / shift.x;
        q=q / shift.x;
        r=r / shift.x;
      }
    }
    if (Precision.equals(shift.x,0.0,epsilon)) {
      break;
    }
    double s=FastMath.sqrt(p * p + q * q + r * r);
    if (p < 0.0) {
      s=-s;
    }
    if (!Precision.equals(s,0.0,epsilon)) {
      if (k != m) {
        matrixT[k][k - 1]=-s * shift.x;
      }
 else       if (l != m) {
        matrixT[k][k - 1]=-matrixT[k][k - 1];
      }
      p=p + s;
      shift.x=p / s;
      shift.y=q / s;
      double z=r / s;
      q=q / p;
      r=r / p;
      for (int j=k; j < n; j++) {
        p=matrixT[k][j] + q * matrixT[k + 1][j];
        if (notlast) {
          p=p + r * matrixT[k + 2][j];
          matrixT[k + 2][j]=matrixT[k + 2][j] - p * z;
        }
        matrixT[k][j]=matrixT[k][j] - p * shift.x;
        matrixT[k + 1][j]=matrixT[k + 1][j] - p * shift.y;
      }
      for (int i=0; i <= FastMath.min(idx,k + 3); i++) {
        p=shift.x * matrixT[i][k] + shift.y * matrixT[i][k + 1];
        if (notlast) {
          p=p + z * matrixT[i][k + 2];
          matrixT[i][k + 2]=matrixT[i][k + 2] - p * r;
        }
        matrixT[i][k]=matrixT[i][k] - p;
        matrixT[i][k + 1]=matrixT[i][k + 1] - p * q;
      }
      final int high=matrixT.length - 1;
      for (int i=0; i <= high; i++) {
        p=shift.x * matrixP[i][k] + shift.y * matrixP[i][k + 1];
        if (notlast) {
          p=p + z * matrixP[i][k + 2];
          matrixP[i][k + 2]=matrixP[i][k + 2] - p * r;
        }
        matrixP[i][k]=matrixP[i][k] - p;
        matrixP[i][k + 1]=matrixP[i][k + 1] - p * q;
      }
    }
  }
  for (int i=m + 2; i <= idx; i++) {
    matrixT[i][i - 2]=0.0;
    if (i > m + 2) {
      matrixT[i][i - 3]=0.0;
    }
  }
}"
57279,"/** 
 * {@inheritDoc} 
 */
@Override public double dotProduct(RealVector v){
  if (v instanceof ArrayRealVector) {
    final double[] vData=((ArrayRealVector)v).data;
    checkVectorDimensions(vData.length);
    double dot=0;
    for (int i=0; i < data.length; i++) {
      dot+=data[i] * vData[i];
    }
    return dot;
  }
 else {
    checkVectorDimensions(v);
    double dot=0;
    Iterator<Entry> it=v.sparseIterator();
    while (it.hasNext()) {
      final Entry e=it.next();
      dot+=data[e.getIndex()] * e.getValue();
    }
    return dot;
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public double dotProduct(RealVector v){
  if (v instanceof ArrayRealVector) {
    final double[] vData=((ArrayRealVector)v).data;
    checkVectorDimensions(vData.length);
    double dot=0;
    for (int i=0; i < data.length; i++) {
      dot+=data[i] * vData[i];
    }
    return dot;
  }
  return super.dotProduct(v);
}"
57280,"/** 
 * @param Umin smallest Mann-Whitney U value
 * @param n1 number of subjects in first sample
 * @param n2 number of subjects in second sample
 * @return two-sided asymptotic p-value
 * @throws ConvergenceException if the p-value can not be computeddue to a convergence error
 * @throws MaxCountExceededException if the maximum number ofiterations is exceeded
 */
private double calculateAsymptoticPValue(final double Umin,final int n1,final int n2) throws ConvergenceException, MaxCountExceededException {
  final double n1n2prod=n1 * n2;
  final double EU=n1n2prod / 2.0;
  final double VarU=n1n2prod * (n1 + n2 + 1) / 12.0;
  final double z=(Umin - EU) / FastMath.sqrt(VarU);
  final NormalDistribution standardNormal=new NormalDistribution(0,1);
  return 2 * standardNormal.cumulativeProbability(z);
}","/** 
 * @param Umin smallest Mann-Whitney U value
 * @param n1 number of subjects in first sample
 * @param n2 number of subjects in second sample
 * @return two-sided asymptotic p-value
 * @throws ConvergenceException if the p-value can not be computeddue to a convergence error
 * @throws MaxCountExceededException if the maximum number ofiterations is exceeded
 */
private double calculateAsymptoticPValue(final double Umin,final int n1,final int n2) throws ConvergenceException, MaxCountExceededException {
  final long n1n2prod=(long)n1 * n2;
  final double EU=n1n2prod / 2.0;
  final double VarU=n1n2prod * (n1 + n2 + 1) / 12.0;
  final double z=(Umin - EU) / FastMath.sqrt(VarU);
  final NormalDistribution standardNormal=new NormalDistribution(0,1);
  return 2 * standardNormal.cumulativeProbability(z);
}"
57281,"/** 
 * @param Umin smallest Mann-Whitney U value
 * @param n1 number of subjects in first sample
 * @param n2 number of subjects in second sample
 * @return two-sided asymptotic p-value
 * @throws ConvergenceException if the p-value can not be computeddue to a convergence error
 * @throws MaxCountExceededException if the maximum number ofiterations is exceeded
 */
private double calculateAsymptoticPValue(final double Umin,final int n1,final int n2) throws ConvergenceException, MaxCountExceededException {
  final int n1n2prod=n1 * n2;
  final double EU=(double)n1n2prod / 2.0;
  final double VarU=(double)(n1n2prod * (n1 + n2 + 1)) / 12.0;
  final double z=(Umin - EU) / FastMath.sqrt(VarU);
  final NormalDistribution standardNormal=new NormalDistribution(0,1);
  return 2 * standardNormal.cumulativeProbability(z);
}","/** 
 * @param Umin smallest Mann-Whitney U value
 * @param n1 number of subjects in first sample
 * @param n2 number of subjects in second sample
 * @return two-sided asymptotic p-value
 * @throws ConvergenceException if the p-value can not be computeddue to a convergence error
 * @throws MaxCountExceededException if the maximum number ofiterations is exceeded
 */
private double calculateAsymptoticPValue(final double Umin,final int n1,final int n2) throws ConvergenceException, MaxCountExceededException {
  final double n1n2prod=n1 * n2;
  final double EU=n1n2prod / 2.0;
  final double VarU=n1n2prod * (n1 + n2 + 1) / 12.0;
  final double z=(Umin - EU) / FastMath.sqrt(VarU);
  final NormalDistribution standardNormal=new NormalDistribution(0,1);
  return 2 * standardNormal.cumulativeProbability(z);
}"
57282,"/** 
 * {@inheritDoc} 
 */
public double cumulativeProbability(int x){
  double ret;
  if (x < 0) {
    ret=0.0;
  }
 else {
    ret=Beta.regularizedBeta(probabilityOfSuccess,numberOfSuccesses,x + 1);
  }
  return ret;
}","/** 
 * {@inheritDoc} 
 */
public double cumulativeProbability(int x){
  double ret;
  if (x < 0) {
    ret=0.0;
  }
 else {
    ret=Beta.regularizedBeta(probabilityOfSuccess,numberOfSuccesses,x + 1.0);
  }
  return ret;
}"
57283,"/** 
 * Simple constructor. Build a Gragg-Bulirsch-Stoer integrator with the given step bounds. All tuning parameters are set to their default values. The default step handler does nothing.
 * @param minStep minimal step (must be positive even for backwardintegration), the last step can be smaller than this
 * @param maxStep maximal step (must be positive even for backwardintegration)
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */
public GraggBulirschStoerIntegrator(final double minStep,final double maxStep,final double[] vecAbsoluteTolerance,final double[] vecRelativeTolerance){
  super(METHOD_NAME,minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);
  setStabilityCheck(true,-1,-1,-1);
  setStepsizeControl(-1,-1,-1,-1);
  setOrderControl(-1,-1,-1);
  setInterpolationControl(true,-1);
}","/** 
 * Simple constructor. Build a Gragg-Bulirsch-Stoer integrator with the given step bounds. All tuning parameters are set to their default values. The default step handler does nothing.
 * @param minStep minimal step (must be positive even for backwardintegration), the last step can be smaller than this
 * @param maxStep maximal step (must be positive even for backwardintegration)
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */
public GraggBulirschStoerIntegrator(final double minStep,final double maxStep,final double[] vecAbsoluteTolerance,final double[] vecRelativeTolerance){
  super(METHOD_NAME,minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);
  setStabilityCheck(true,-1,-1,-1);
  setControlFactors(-1,-1,-1,-1);
  setOrderControl(-1,-1,-1);
  setInterpolationControl(true,-1);
}"
57284,"@Test public void testIntegratorControls(){
  TestProblem3 pb=new TestProblem3(0.999);
  GraggBulirschStoerIntegrator integ=new GraggBulirschStoerIntegrator(0,pb.getFinalTime() - pb.getInitialTime(),1.0e-8,1.0e-10);
  double errorWithDefaultSettings=getMaxError(integ,pb);
  integ.setStabilityCheck(true,2,1,0.99);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setStabilityCheck(true,-1,-1,-1);
  integ.setStepsizeControl(0.5,0.99,0.1,2.5);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setStepsizeControl(-1,-1,-1,-1);
  integ.setOrderControl(10,0.7,0.95);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setOrderControl(-1,-1,-1);
  integ.setInterpolationControl(true,3);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setInterpolationControl(true,-1);
}","@Test public void testIntegratorControls(){
  TestProblem3 pb=new TestProblem3(0.999);
  GraggBulirschStoerIntegrator integ=new GraggBulirschStoerIntegrator(0,pb.getFinalTime() - pb.getInitialTime(),1.0e-8,1.0e-10);
  double errorWithDefaultSettings=getMaxError(integ,pb);
  integ.setStabilityCheck(true,2,1,0.99);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setStabilityCheck(true,-1,-1,-1);
  integ.setControlFactors(0.5,0.99,0.1,2.5);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setControlFactors(-1,-1,-1,-1);
  integ.setOrderControl(10,0.7,0.95);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setOrderControl(-1,-1,-1);
  integ.setInterpolationControl(true,3);
  Assert.assertTrue(errorWithDefaultSettings < getMaxError(integ,pb));
  integ.setInterpolationControl(true,-1);
}"
57285,"/** 
 * Filter the integration step.
 * @param h signed step
 * @param forward forward integration indicator
 * @param acceptSmall if true, steps smaller than the minimal valueare silently increased up to this value, if false such small steps generate an exception
 * @return a bounded integration step (h if no bound is reach, or a bounded value)
 * @exception NumberIsTooSmallException if the step is too small and acceptSmall is false
 */
protected double filterStep(final double h,final boolean forward,final boolean acceptSmall) throws NumberIsTooSmallException {
  double filteredH=h;
  if (FastMath.abs(h) < minStep) {
    if (acceptSmall) {
      filteredH=forward ? minStep : -minStep;
    }
 else {
      throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,minStep,FastMath.abs(h),true);
    }
  }
  if (filteredH > maxStep) {
    filteredH=maxStep;
  }
 else   if (filteredH < -maxStep) {
    filteredH=-maxStep;
  }
  return filteredH;
}","/** 
 * Filter the integration step.
 * @param h signed step
 * @param forward forward integration indicator
 * @param acceptSmall if true, steps smaller than the minimal valueare silently increased up to this value, if false such small steps generate an exception
 * @return a bounded integration step (h if no bound is reach, or a bounded value)
 * @exception NumberIsTooSmallException if the step is too small and acceptSmall is false
 */
protected double filterStep(final double h,final boolean forward,final boolean acceptSmall) throws NumberIsTooSmallException {
  double filteredH=h;
  if (FastMath.abs(h) < minStep) {
    if (acceptSmall) {
      filteredH=forward ? minStep : -minStep;
    }
 else {
      throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,FastMath.abs(h),minStep,true);
    }
  }
  if (filteredH > maxStep) {
    filteredH=maxStep;
  }
 else   if (filteredH < -maxStep) {
    filteredH=-maxStep;
  }
  return filteredH;
}"
57286,"/** 
 * Generate a random int value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses a secure random number generator.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public int nextSecureInt(int lower,int upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  SecureRandom sec=getSecRan();
  return lower + (int)(sec.nextDouble() * (upper - lower + 1));
}","/** 
 * Generate a random int value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses a secure random number generator.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public int nextSecureInt(int lower,int upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  SecureRandom sec=getSecRan();
  double r=sec.nextDouble();
  double scaled=r * upper + (1.0 - r) * lower + r;
  return (int)FastMath.floor(scaled);
}"
57287,"/** 
 * Generate a random long value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses a secure random number generator.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public long nextSecureLong(long lower,long upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  SecureRandom sec=getSecRan();
  return lower + (long)(sec.nextDouble() * (upper - lower + 1));
}","/** 
 * Generate a random long value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses a secure random number generator.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public long nextSecureLong(long lower,long upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  SecureRandom sec=getSecRan();
  double r=sec.nextDouble();
  double scaled=r * upper + (1.0 - r) * lower + r;
  return (long)FastMath.floor(scaled);
}"
57288,"/** 
 * Generate a random int value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public int nextInt(int lower,int upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  double r=getRan().nextDouble();
  return (int)((r * upper) + ((1.0 - r) * lower) + r);
}","/** 
 * Generate a random int value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public int nextInt(int lower,int upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  double r=getRan().nextDouble();
  double scaled=r * upper + (1.0 - r) * lower + r;
  return (int)FastMath.floor(scaled);
}"
57289,"/** 
 * Generate a random long value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public long nextLong(long lower,long upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  double r=getRan().nextDouble();
  return (long)((r * upper) + ((1.0 - r) * lower) + r);
}","/** 
 * Generate a random long value uniformly distributed between <code>lower</code> and <code>upper</code>, inclusive.
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return the random integer.
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public long nextLong(long lower,long upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  double r=getRan().nextDouble();
  double scaled=r * upper + (1.0 - r) * lower + r;
  return (long)FastMath.floor(scaled);
}"
57290,"/** 
 * {@inheritDoc}<p> <strong>Algorithm Description</strong>: scales the output of Random.nextDouble(), but rejects 0 values (i.e., will generate another random double if Random.nextDouble() returns 0). This is necessary to provide a symmetric output interval (both endpoints excluded). </p>
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return a uniformly distributed random value from the interval (lower,upper)
 * @throws NumberIsTooLargeException if {@code lower >= upper}.
 */
public double nextUniform(double lower,double upper){
  if (lower >= upper) {
    throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper,false);
  }
  final RandomGenerator generator=getRan();
  double u=generator.nextDouble();
  while (u <= 0.0) {
    u=generator.nextDouble();
  }
  return lower + u * (upper - lower);
}","/** 
 * {@inheritDoc}<p> <strong>Algorithm Description</strong>: scales the output of Random.nextDouble(), but rejects 0 values (i.e., will generate another random double if Random.nextDouble() returns 0). This is necessary to provide a symmetric output interval (both endpoints excluded). </p>
 * @param lower the lower bound.
 * @param upper the upper bound.
 * @return a uniformly distributed random value from the interval (lower, upper)
 * @throws MathIllegalArgumentException if {@code lower >= upper}or either bound is infinite or NaN
 */
public double nextUniform(double lower,double upper){
  if (lower >= upper) {
    throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,lower,upper);
  }
  if (Double.isInfinite(lower) || Double.isInfinite(upper)) {
    throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_BOUND);
  }
  if (Double.isNaN(lower) || Double.isNaN(upper)) {
    throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);
  }
  final RandomGenerator generator=getRan();
  double u=generator.nextDouble();
  while (u <= 0.0) {
    u=generator.nextDouble();
  }
  return u * upper + (1.0 - u) * lower;
}"
57291,"/** 
 * Add a value to the data
 * @param value the value to add
 */
public void addValue(double value){
  sumImpl.increment(value);
  sumsqImpl.increment(value);
  minImpl.increment(value);
  maxImpl.increment(value);
  sumLogImpl.increment(value);
  secondMoment.increment(value);
  if (!(meanImpl instanceof Mean)) {
    meanImpl.increment(value);
  }
  if (!(varianceImpl instanceof Variance)) {
    varianceImpl.increment(value);
  }
  if (!(geoMeanImpl instanceof GeometricMean)) {
    geoMeanImpl.increment(value);
  }
  n++;
}","/** 
 * Add a value to the data
 * @param value the value to add
 */
public void addValue(double value){
  sumImpl.increment(value);
  sumsqImpl.increment(value);
  minImpl.increment(value);
  maxImpl.increment(value);
  sumLogImpl.increment(value);
  secondMoment.increment(value);
  if (meanImpl != mean) {
    meanImpl.increment(value);
  }
  if (varianceImpl != variance) {
    varianceImpl.increment(value);
  }
  if (geoMeanImpl != geoMean) {
    geoMeanImpl.increment(value);
  }
  n++;
}"
57292,"/** 
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an eventasks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MathIllegalStateException if the value of one event state cannot be evaluated
 * @since 2.2
 */
protected double acceptStep(final AbstractStepInterpolator interpolator,final double[] y,final double[] yDot,final double tEnd) throws MathIllegalStateException {
  double previousT=interpolator.getGlobalPreviousTime();
  final double currentT=interpolator.getGlobalCurrentTime();
  resetOccurred=false;
  if (!statesInitialized) {
    for (    EventState state : eventsStates) {
      state.reinitializeBegin(interpolator);
    }
    statesInitialized=true;
  }
  final int orderingSign=interpolator.isForward() ? +1 : -1;
  SortedSet<EventState> occuringEvents=new TreeSet<EventState>(new Comparator<EventState>(){
    /** 
 * {@inheritDoc} 
 */
    public int compare(    EventState es0,    EventState es1){
      return orderingSign * Double.compare(es0.getEventTime(),es1.getEventTime());
    }
  }
);
  for (  final EventState state : eventsStates) {
    if (state.evaluateStep(interpolator)) {
      occuringEvents.add(state);
    }
  }
  while (!occuringEvents.isEmpty()) {
    final Iterator<EventState> iterator=occuringEvents.iterator();
    final EventState currentEvent=iterator.next();
    iterator.remove();
    final double eventT=currentEvent.getEventTime();
    interpolator.setSoftPreviousTime(previousT);
    interpolator.setSoftCurrentTime(eventT);
    interpolator.setInterpolatedTime(eventT);
    final double[] eventY=interpolator.getInterpolatedState();
    currentEvent.stepAccepted(eventT,eventY);
    isLastStep=currentEvent.stop();
    for (    final StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,isLastStep);
    }
    if (isLastStep) {
      System.arraycopy(eventY,0,y,0,y.length);
      return eventT;
    }
    if (currentEvent.reset(eventT,eventY)) {
      System.arraycopy(eventY,0,y,0,y.length);
      computeDerivatives(eventT,y,yDot);
      resetOccurred=true;
      return eventT;
    }
    previousT=eventT;
    interpolator.setSoftPreviousTime(eventT);
    interpolator.setSoftCurrentTime(currentT);
    if (currentEvent.evaluateStep(interpolator)) {
      occuringEvents.add(currentEvent);
    }
  }
  interpolator.setInterpolatedTime(currentT);
  final double[] currentY=interpolator.getInterpolatedState();
  for (  final EventState state : eventsStates) {
    state.stepAccepted(currentT,currentY);
    isLastStep=isLastStep || state.stop();
  }
  isLastStep=isLastStep || Precision.equals(currentT,tEnd,1);
  for (  StepHandler handler : stepHandlers) {
    handler.handleStep(interpolator,isLastStep);
  }
  return currentT;
}","/** 
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an eventasks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception MathIllegalStateException if the value of one event state cannot be evaluated
 * @since 2.2
 */
protected double acceptStep(final AbstractStepInterpolator interpolator,final double[] y,final double[] yDot,final double tEnd) throws MathIllegalStateException {
  double previousT=interpolator.getGlobalPreviousTime();
  final double currentT=interpolator.getGlobalCurrentTime();
  if (!statesInitialized) {
    for (    EventState state : eventsStates) {
      state.reinitializeBegin(interpolator);
    }
    statesInitialized=true;
  }
  final int orderingSign=interpolator.isForward() ? +1 : -1;
  SortedSet<EventState> occuringEvents=new TreeSet<EventState>(new Comparator<EventState>(){
    /** 
 * {@inheritDoc} 
 */
    public int compare(    EventState es0,    EventState es1){
      return orderingSign * Double.compare(es0.getEventTime(),es1.getEventTime());
    }
  }
);
  for (  final EventState state : eventsStates) {
    if (state.evaluateStep(interpolator)) {
      occuringEvents.add(state);
    }
  }
  while (!occuringEvents.isEmpty()) {
    final Iterator<EventState> iterator=occuringEvents.iterator();
    final EventState currentEvent=iterator.next();
    iterator.remove();
    final double eventT=currentEvent.getEventTime();
    interpolator.setSoftPreviousTime(previousT);
    interpolator.setSoftCurrentTime(eventT);
    interpolator.setInterpolatedTime(eventT);
    final double[] eventY=interpolator.getInterpolatedState();
    currentEvent.stepAccepted(eventT,eventY);
    isLastStep=currentEvent.stop();
    for (    final StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,isLastStep);
    }
    if (isLastStep) {
      System.arraycopy(eventY,0,y,0,y.length);
      for (      final EventState remaining : occuringEvents) {
        remaining.stepAccepted(eventT,eventY);
      }
      return eventT;
    }
    if (currentEvent.reset(eventT,eventY)) {
      System.arraycopy(eventY,0,y,0,y.length);
      computeDerivatives(eventT,y,yDot);
      resetOccurred=true;
      for (      final EventState remaining : occuringEvents) {
        remaining.stepAccepted(eventT,eventY);
      }
      return eventT;
    }
    previousT=eventT;
    interpolator.setSoftPreviousTime(eventT);
    interpolator.setSoftCurrentTime(currentT);
    if (currentEvent.evaluateStep(interpolator)) {
      occuringEvents.add(currentEvent);
    }
  }
  interpolator.setInterpolatedTime(currentT);
  final double[] currentY=interpolator.getInterpolatedState();
  for (  final EventState state : eventsStates) {
    state.stepAccepted(currentT,currentY);
    isLastStep=isLastStep || state.stop();
  }
  isLastStep=isLastStep || Precision.equals(currentT,tEnd,1);
  for (  StepHandler handler : stepHandlers) {
    handler.handleStep(interpolator,isLastStep);
  }
  return currentT;
}"
57293,"/** 
 * Returns the transpose of the matrix Q of the decomposition. <p>Q is an orthogonal matrix</p>
 * @return the Q matrix
 */
public RealMatrix getQT(){
  if (cachedQT == null) {
    final int n=qr[0].length;
    final int m=qr.length;
    cachedQT=MatrixUtils.createRealMatrix(m,m);
    for (int minor=m - 1; minor >= rank; minor--) {
      cachedQT.setEntry(minor,minor,1.0);
    }
    for (int minor=rank - 1; minor >= 0; minor--) {
      final int p_minor=permutation[minor];
      cachedQT.setEntry(minor,minor,1.0);
      for (int col=minor; col < m; col++) {
        double alpha=0.0;
        for (int row=minor; row < m; row++) {
          alpha-=cachedQT.getEntry(col,row) * qr[row][p_minor];
        }
        alpha/=rDiag[p_minor] * qr[minor][p_minor];
        for (int row=minor; row < m; row++) {
          cachedQT.addToEntry(col,row,-alpha * qr[row][p_minor]);
        }
      }
    }
  }
  return cachedQT;
}","/** 
 * Returns the transpose of the matrix Q of the decomposition. <p>Q is an orthogonal matrix</p>
 * @return the Q matrix
 */
public RealMatrix getQT(){
  if (cachedQT == null) {
    final int m=qr.length;
    cachedQT=MatrixUtils.createRealMatrix(m,m);
    for (int minor=m - 1; minor >= rank; minor--) {
      cachedQT.setEntry(minor,minor,1.0);
    }
    for (int minor=rank - 1; minor >= 0; minor--) {
      final int p_minor=permutation[minor];
      cachedQT.setEntry(minor,minor,1.0);
      for (int col=minor; col < m; col++) {
        double alpha=0.0;
        for (int row=minor; row < m; row++) {
          alpha-=cachedQT.getEntry(col,row) * qr[row][p_minor];
        }
        alpha/=rDiag[p_minor] * qr[minor][p_minor];
        for (int row=minor; row < m; row++) {
          cachedQT.addToEntry(col,row,-alpha * qr[row][p_minor]);
        }
      }
    }
  }
  return cachedQT;
}"
57294,"/** 
 * Returns the runtime class of the FieldElement. 
 * @return The {@code Class} object that represents the runtimeclass of this object.
 */
Class<? extends FieldElement<T>> getRuntimeClass();","/** 
 * Returns the runtime class of the FieldElement.
 * @return The {@code Class} object that represents the runtimeclass of this object.
 */
Class<? extends FieldElement<T>> getRuntimeClass();"
57295,"/** 
 * Prepare for computation. Subclasses must call this method if they override any of the  {@code solve} methods.
 * @param maxEval Maximum number of evaluations.
 * @param f the integrand function
 * @param min the min bound for the interval
 * @param max the upper bound for the interval
 * @throws NullArgumentException if {@code f} is {@code null}.
 * @throws MathIllegalArgumentException if {@code min >= max}.
 */
protected void setup(final int maxEval,final UnivariateRealFunction f,final double min,final double max) throws NullArgumentException, MathIllegalArgumentException {
  MathUtils.checkNotNull(f);
  UnivariateRealSolverUtils.verifyInterval(min,max);
  this.min=min;
  this.max=max;
  function=f;
  evaluations.setMaximalCount(maxEval);
  evaluations.resetCount();
  iterations.resetCount();
}","/** 
 * Prepare for computation. Subclasses must call this method if they override any of the  {@code solve} methods.
 * @param maxEval Maximum number of evaluations.
 * @param f the integrand function
 * @param lower the min bound for the interval
 * @param upper the upper bound for the interval
 * @throws NullArgumentException if {@code f} is {@code null}.
 * @throws MathIllegalArgumentException if {@code min >= max}.
 */
protected void setup(final int maxEval,final UnivariateRealFunction f,final double lower,final double upper) throws NullArgumentException, MathIllegalArgumentException {
  MathUtils.checkNotNull(f);
  UnivariateRealSolverUtils.verifyInterval(lower,upper);
  this.min=lower;
  this.max=upper;
  function=f;
  evaluations.setMaximalCount(maxEval);
  evaluations.resetCount();
  iterations.resetCount();
}"
57296,"/** 
 * {@inheritDoc} 
 */
public double integrate(final int maxEval,final UnivariateRealFunction f,final double min,final double max) throws TooManyEvaluationsException, MaxCountExceededException, MathIllegalArgumentException, NullArgumentException {
  setup(maxEval,f,min,max);
  return doIntegrate();
}","/** 
 * {@inheritDoc} 
 */
public double integrate(final int maxEval,final UnivariateRealFunction f,final double lower,final double upper) throws TooManyEvaluationsException, MaxCountExceededException, MathIllegalArgumentException, NullArgumentException {
  setup(maxEval,f,lower,upper);
  return doIntegrate();
}"
57297,"/** 
 * Creates   {@code H} of size {@code m x m} as described in [1] (see above).
 * @param d statistic
 * @return H matrix
 * @throws NumberIsTooLargeException if fractional part is greater than 1
 * @throws FractionConversionException if algorithm fails to convert  {@code h} to a{@link org.apache.commons.math.fraction.BigFraction} inexpressing  {@code d} as {@code (k - h) / m} for integer{@code k, m} and {@code 0 <= h < 1}.
 */
private FieldMatrix<BigFraction> createH(double d) throws MathArithmeticException {
  int k=(int)Math.ceil(n * d);
  int m=2 * k - 1;
  double hDouble=k - n * d;
  if (hDouble >= 1) {
    throw new NumberIsTooLargeException(hDouble,1.0,false);
  }
  BigFraction h=null;
  try {
    h=new BigFraction(hDouble,1.0e-20,10000);
  }
 catch (  FractionConversionException e1) {
    try {
      h=new BigFraction(hDouble,1.0e-10,10000);
    }
 catch (    FractionConversionException e2) {
      h=new BigFraction(hDouble,1.0e-5,10000);
    }
  }
  final BigFraction[][] Hdata=new BigFraction[m][m];
  for (int i=0; i < m; ++i) {
    for (int j=0; j < m; ++j) {
      if (i - j + 1 < 0) {
        Hdata[i][j]=BigFraction.ZERO;
      }
 else {
        Hdata[i][j]=BigFraction.ONE;
      }
    }
  }
  final BigFraction[] hPowers=new BigFraction[m];
  hPowers[0]=h;
  for (int i=1; i < m; ++i) {
    hPowers[i]=h.multiply(hPowers[i - 1]);
  }
  for (int i=0; i < m; ++i) {
    Hdata[i][0]=Hdata[i][0].subtract(hPowers[i]);
    Hdata[m - 1][i]=Hdata[m - 1][i].subtract(hPowers[m - i - 1]);
  }
  if (h.compareTo(BigFraction.ONE_HALF) == 1) {
    Hdata[m - 1][0]=Hdata[m - 1][0].add(h.multiply(2).subtract(1).pow(m));
  }
  for (int i=0; i < m; ++i) {
    for (int j=0; j < i + 1; ++j) {
      if (i - j + 1 > 0) {
        for (int g=2; g <= i - j + 1; ++g) {
          Hdata[i][j]=Hdata[i][j].divide(g);
        }
      }
    }
  }
  return new Array2DRowFieldMatrix<BigFraction>(BigFractionField.getInstance(),Hdata);
}","/** 
 * Creates   {@code H} of size {@code m x m} as described in [1] (see above).
 * @param d statistic
 * @return H matrix
 * @throws NumberIsTooLargeException if fractional part is greater than 1
 * @throws FractionConversionException if algorithm fails to convert  {@code h} to a{@link org.apache.commons.math.fraction.BigFraction} inexpressing  {@code d} as {@code (k - h) / m} for integer{@code k, m} and {@code 0 <= h < 1}.
 */
private FieldMatrix<BigFraction> createH(double d) throws NumberIsTooLargeException, FractionConversionException {
  int k=(int)Math.ceil(n * d);
  int m=2 * k - 1;
  double hDouble=k - n * d;
  if (hDouble >= 1) {
    throw new NumberIsTooLargeException(hDouble,1.0,false);
  }
  BigFraction h=null;
  try {
    h=new BigFraction(hDouble,1.0e-20,10000);
  }
 catch (  FractionConversionException e1) {
    try {
      h=new BigFraction(hDouble,1.0e-10,10000);
    }
 catch (    FractionConversionException e2) {
      h=new BigFraction(hDouble,1.0e-5,10000);
    }
  }
  final BigFraction[][] Hdata=new BigFraction[m][m];
  for (int i=0; i < m; ++i) {
    for (int j=0; j < m; ++j) {
      if (i - j + 1 < 0) {
        Hdata[i][j]=BigFraction.ZERO;
      }
 else {
        Hdata[i][j]=BigFraction.ONE;
      }
    }
  }
  final BigFraction[] hPowers=new BigFraction[m];
  hPowers[0]=h;
  for (int i=1; i < m; ++i) {
    hPowers[i]=h.multiply(hPowers[i - 1]);
  }
  for (int i=0; i < m; ++i) {
    Hdata[i][0]=Hdata[i][0].subtract(hPowers[i]);
    Hdata[m - 1][i]=Hdata[m - 1][i].subtract(hPowers[m - i - 1]);
  }
  if (h.compareTo(BigFraction.ONE_HALF) == 1) {
    Hdata[m - 1][0]=Hdata[m - 1][0].add(h.multiply(2).subtract(1).pow(m));
  }
  for (int i=0; i < m; ++i) {
    for (int j=0; j < i + 1; ++j) {
      if (i - j + 1 > 0) {
        for (int g=2; g <= i - j + 1; ++g) {
          Hdata[i][j]=Hdata[i][j].divide(g);
        }
      }
    }
  }
  return new Array2DRowFieldMatrix<BigFraction>(BigFractionField.getInstance(),Hdata);
}"
57298,"/** 
 * Integrate a set of differential equations up to the given time. <p>This method solves an Initial Value Problem (IVP).</p> <p>The set of differential equations is composed of a main set, which can be extended by some sets of secondary equations. The set of equations must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object.</p> <p>Since this method stores some internal state variables made available in its public interface during integration (  {@link #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>
 * @param equations complete set of differential equations to integrate
 * @param t target time for the integration(can be set to a value smaller than <code>t0</code> for backward integration)
 * @throws MathIllegalStateException if the integrator cannot perform integration
 * @throws MathIllegalArgumentException if integration parameters are wrong (typicallytoo small integration span)
 */
public abstract void integrate(ExpandableStatefulODE equations,double t) throws MathIllegalStateException, MathIllegalArgumentException ;","/** 
 * Integrate a set of differential expandable up to the given time. <p>This method solves an Initial Value Problem (IVP).</p> <p>The set of differential expandable is composed of a main set, which can be extended by some sets of secondary expandable. The set of expandable must be already set up with initial time and partial states. At integration completion, the final time and partial states will be available in the same object.</p> <p>Since this method stores some internal state variables made available in its public interface during integration (  {@link #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>
 * @param equations complete set of differential expandable to integrate
 * @param t target time for the integration(can be set to a value smaller than <code>t0</code> for backward integration)
 * @throws MathIllegalStateException if the integrator cannot perform integration
 * @throws MathIllegalArgumentException if integration parameters are wrong (typicallytoo small integration span)
 */
public abstract void integrate(ExpandableStatefulODE equations,double t) throws MathIllegalStateException, MathIllegalArgumentException ;"
57299,"/** 
 * Compute the derivatives and check the number of evaluations.
 * @param t current value of the independent <I>time</I> variable
 * @param y array containing the current value of the state vector
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 */
public void computeDerivatives(final double t,final double[] y,final double[] yDot) throws MaxCountExceededException {
  evaluations.incrementCount();
  equations.computeDerivatives(t,y,yDot);
}","/** 
 * Compute the derivatives and check the number of evaluations.
 * @param t current value of the independent <I>time</I> variable
 * @param y array containing the current value of the state vector
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @exception MaxCountExceededException if the number of functions evaluations is exceeded
 */
public void computeDerivatives(final double t,final double[] y,final double[] yDot) throws MaxCountExceededException {
  evaluations.incrementCount();
  expandable.computeDerivatives(t,y,yDot);
}"
57300,"/** 
 * Check the integration span.
 * @param t target time for the integration
 * @exception NumberIsTooSmallException if integration span is too small
 */
protected void sanityChecks(final ExpandableStatefulODE equations,final double t) throws NumberIsTooSmallException {
  final double threshold=1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),FastMath.abs(t)));
  final double dt=FastMath.abs(equations.getTime() - t);
  if (dt <= threshold) {
    throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,dt,threshold,false);
  }
}","/** 
 * Check the integration span.
 * @param equations set of differential equations
 * @param t target time for the integration
 * @exception NumberIsTooSmallException if integration span is too small
 */
protected void sanityChecks(final ExpandableStatefulODE equations,final double t) throws NumberIsTooSmallException {
  final double threshold=1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),FastMath.abs(t)));
  final double dt=FastMath.abs(equations.getTime() - t);
  if (dt <= threshold) {
    throw new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,dt,threshold,false);
  }
}"
57301,"/** 
 * Set the equations.
 * @param equations equations to set
 */
protected void setEquations(final ExpandableStatefulODE equations){
  this.equations=equations;
}","/** 
 * Set the equations.
 * @param equations equations to set
 */
protected void setEquations(final ExpandableStatefulODE equations){
  this.expandable=equations;
}"
57302,"/** 
 * Simple constructor.
 * @param equation secondary differential equation
 * @param first index index to use for the first element in the complete arrays
 */
public SecondaryComponent(final SecondaryEquations equation,final int firstIndex){
  final int n=equation.getDimension();
  this.equation=equation;
  mapper=new EquationsMapper(firstIndex,n);
  state=new double[n];
  stateDot=new double[n];
}","/** 
 * Simple constructor.
 * @param equation secondary differential equation
 * @param firstIndex index to use for the first element in the complete arrays
 */
public SecondaryComponent(final SecondaryEquations equation,final int firstIndex){
  final int n=equation.getDimension();
  this.equation=equation;
  mapper=new EquationsMapper(firstIndex,n);
  state=new double[n];
  stateDot=new double[n];
}"
57303,"/** 
 * Add a parameter Jacobian provider.
 * @param pode the parameterized ODE to compute the parameter Jacobian matrix using finite differences 
 */
public void setParameterizedODE(final ParameterizedODE pode){
  this.pode=pode;
  dirtyParameter=true;
}","/** 
 * Add a parameter Jacobian provider.
 * @param parameterizedOde the parameterized ODE to compute the parameter Jacobian matrix using finite differences
 */
public void setParameterizedODE(final ParameterizedODE parameterizedOde){
  this.pode=parameterizedOde;
  dirtyParameter=true;
}"
57304,"/** 
 * Set the initial value of the Jacobian matrix with respect to state. <p> If this method is not called, the initial value of the Jacobian matrix with respect to state is set to identity. </p>
 * @param dYdY0 initial Jacobian matrix w.r.t. state
 * @exception IllegalArgumentException if matrix dimensions are incorrect
 */
public void setInitialMainStateJacobian(final double[][] dYdY0) throws MathIllegalArgumentException {
  checkDimension(stateDim,dYdY0);
  checkDimension(stateDim,dYdY0[0]);
  int i=0;
  for (  final double[] row : dYdY0) {
    System.arraycopy(row,0,matricesData,i,stateDim);
    i+=stateDim;
  }
  if (efode != null) {
    efode.setSecondaryState(index,matricesData);
  }
}","/** 
 * Set the initial value of the Jacobian matrix with respect to state. <p> If this method is not called, the initial value of the Jacobian matrix with respect to state is set to identity. </p>
 * @param dYdY0 initial Jacobian matrix w.r.t. state
 * @exception DimensionMismatchException if matrix dimensions are incorrect
 */
public void setInitialMainStateJacobian(final double[][] dYdY0) throws DimensionMismatchException {
  checkDimension(stateDim,dYdY0);
  checkDimension(stateDim,dYdY0[0]);
  int i=0;
  for (  final double[] row : dYdY0) {
    System.arraycopy(row,0,matricesData,i,stateDim);
    i+=stateDim;
  }
  if (efode != null) {
    efode.setSecondaryState(index,matricesData);
  }
}"
57305,"/** 
 * Register the variational equations for the Jacobians matrices to the expandable set.
 * @exception MathIllegalArgumentException if the primary set of the expandable set doesnot match the one used to build the instance
 * @see ExpandableStatefulODE#addSecondaryEquations(SecondaryEquations)
 */
public void registerVariationalEquations(final ExpandableStatefulODE expandable) throws MathIllegalArgumentException {
  final FirstOrderDifferentialEquations ode=(jode instanceof MainStateJacobianWrapper) ? ((MainStateJacobianWrapper)jode).ode : jode;
  if (expandable.getPrimary() != ode) {
    throw new MathIllegalArgumentException(LocalizedFormats.UNMATCHED_ODE_IN_EXPANDED_SET);
  }
  efode=expandable;
  index=efode.addSecondaryEquations(new JacobiansSecondaryEquations());
  efode.setSecondaryState(index,matricesData);
}","/** 
 * Register the variational equations for the Jacobians matrices to the expandable set.
 * @param expandable expandable set into which variational equations should be registered
 * @exception MathIllegalArgumentException if the primary set of the expandable set doesnot match the one used to build the instance
 * @see ExpandableStatefulODE#addSecondaryEquations(SecondaryEquations)
 */
public void registerVariationalEquations(final ExpandableStatefulODE expandable) throws MathIllegalArgumentException {
  final FirstOrderDifferentialEquations ode=(jode instanceof MainStateJacobianWrapper) ? ((MainStateJacobianWrapper)jode).ode : jode;
  if (expandable.getPrimary() != ode) {
    throw new MathIllegalArgumentException(LocalizedFormats.UNMATCHED_ODE_IN_EXPANDED_SET);
  }
  efode=expandable;
  index=efode.addSecondaryEquations(new JacobiansSecondaryEquations());
  efode.setSecondaryState(index,matricesData);
}"
57306,"/** 
 * Get the current value of the Jacobian matrix with respect to state.
 * @param dYdY0 current Jacobian matrix with respect to state.
 */
public void getCurrentMainSetJacobian(final double[][] dYdY0){
  double[] p=efode.getSecondaryState(index);
  int index=0;
  for (int i=0; i < stateDim; i++) {
    System.arraycopy(p,index,dYdY0[i],0,stateDim);
    index+=stateDim;
  }
}","/** 
 * Get the current value of the Jacobian matrix with respect to state.
 * @param dYdY0 current Jacobian matrix with respect to state.
 */
public void getCurrentMainSetJacobian(final double[][] dYdY0){
  double[] p=efode.getSecondaryState(index);
  int j=0;
  for (int i=0; i < stateDim; i++) {
    System.arraycopy(p,j,dYdY0[i],0,stateDim);
    j+=stateDim;
  }
}"
57307,"/** 
 * Get the current value of the Jacobian matrix with respect to one parameter.
 * @param pName name of the parameter for the computed Jacobian matrix 
 * @param dYdP current Jacobian matrix with respect to the named parameter
 */
public void getCurrentParameterJacobian(String pName,final double[] dYdP){
  double[] p=efode.getSecondaryState(index);
  int index=stateDim * stateDim;
  for (  ParameterConfiguration param : selectedParameters) {
    if (param.getParameterName().equals(pName)) {
      System.arraycopy(p,index,dYdP,0,stateDim);
      break;
    }
    index+=stateDim;
  }
}","/** 
 * Get the current value of the Jacobian matrix with respect to one parameter.
 * @param pName name of the parameter for the computed Jacobian matrix
 * @param dYdP current Jacobian matrix with respect to the named parameter
 */
public void getCurrentParameterJacobian(String pName,final double[] dYdP){
  double[] p=efode.getSecondaryState(index);
  int i=stateDim * stateDim;
  for (  ParameterConfiguration param : selectedParameters) {
    if (param.getParameterName().equals(pName)) {
      System.arraycopy(p,i,dYdP,0,stateDim);
      return;
    }
    i+=stateDim;
  }
}"
57308,"/** 
 * Filter the integration step.
 * @param h signed step
 * @param forward forward integration indicator
 * @param acceptSmall if true, steps smaller than the minimal valueare silently increased up to this value, if false such small steps generate an exception
 * @return a bounded integration step (h if no bound is reach, or a bounded value)
 * @exception NumberIsTooSmallException if the step is too small and acceptSmall is false
 */
protected double filterStep(final double h,final boolean forward,final boolean acceptSmall) throws MathIllegalArgumentException {
  double filteredH=h;
  if (FastMath.abs(h) < minStep) {
    if (acceptSmall) {
      filteredH=forward ? minStep : -minStep;
    }
 else {
      throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,minStep,FastMath.abs(h),true);
    }
  }
  if (filteredH > maxStep) {
    filteredH=maxStep;
  }
 else   if (filteredH < -maxStep) {
    filteredH=-maxStep;
  }
  return filteredH;
}","/** 
 * Filter the integration step.
 * @param h signed step
 * @param forward forward integration indicator
 * @param acceptSmall if true, steps smaller than the minimal valueare silently increased up to this value, if false such small steps generate an exception
 * @return a bounded integration step (h if no bound is reach, or a bounded value)
 * @exception NumberIsTooSmallException if the step is too small and acceptSmall is false
 */
protected double filterStep(final double h,final boolean forward,final boolean acceptSmall) throws NumberIsTooSmallException {
  double filteredH=h;
  if (FastMath.abs(h) < minStep) {
    if (acceptSmall) {
      filteredH=forward ? minStep : -minStep;
    }
 else {
      throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,minStep,FastMath.abs(h),true);
    }
  }
  if (filteredH > maxStep) {
    filteredH=maxStep;
  }
 else   if (filteredH < -maxStep) {
    filteredH=-maxStep;
  }
  return filteredH;
}"
57309,"/** 
 * {@inheritDoc} 
 */
@Override public void writeExternal(final ObjectOutput out) throws IOException {
  try {
    finalizeStep();
  }
 catch (  Exception e) {
    IOException ioe=new IOException(e.getLocalizedMessage());
    ioe.initCause(e);
    throw ioe;
  }
  final int dimension=(currentState == null) ? -1 : currentState.length;
  out.writeInt(dimension);
  for (int i=0; i < dimension; ++i) {
    out.writeDouble(yDotKLast[0][i]);
    out.writeDouble(yDotKLast[1][i]);
    out.writeDouble(yDotKLast[2][i]);
  }
  super.writeExternal(out);
}","/** 
 * {@inheritDoc} 
 */
@Override public void writeExternal(final ObjectOutput out) throws IOException {
  finalizeStep();
  final int dimension=(currentState == null) ? -1 : currentState.length;
  out.writeInt(dimension);
  for (int i=0; i < dimension; ++i) {
    out.writeDouble(yDotKLast[0][i]);
    out.writeDouble(yDotKLast[1][i]);
    out.writeDouble(yDotKLast[2][i]);
  }
  super.writeExternal(out);
}"
57310,"/** 
 * Returns the next pseudorandom, uniformly distributed   {@code long}value from this random number generator's sequence.  All 2<font size=""-1""><sup>64</sup></font> possible   {@code long} valuesshould be produced with (approximately) equal probability. <p> The default implementation returns <pre> <code>(long) (nextDouble() * Long.MAX_VALUE)</code> </pre></p>
 * @return  the next pseudorandom, uniformly distributed {@code long}value from this random number generator's sequence
 */
public long nextLong(){
  return (long)(nextDouble() * Long.MAX_VALUE);
}","/** 
 * Returns the next pseudorandom, uniformly distributed   {@code long}value from this random number generator's sequence.  All 2<font size=""-1""><sup>64</sup></font> possible   {@code long} valuesshould be produced with (approximately) equal probability. <p> The default implementation returns <pre> <code>(long) (nextDouble() * Long.MAX_VALUE)</code> </pre></p>
 * @return  the next pseudorandom, uniformly distributed {@code long}value from this random number generator's sequence
 */
public long nextLong(){
  return (long)((2d * nextDouble() - 1d) * Long.MAX_VALUE);
}"
57311,"/** 
 * Returns the <a href=""http://www.xycoon.com/standerrorb(1).htm"">standard error of the parameter estimate at index</a>, usually denoted s(b<sub>index</sub>).
 * @param index an integer index which must be in the range [0, numberOfParameters-1]
 * @return standard errors associated with parameters estimated at index
 * @throws IndexOutOfBoundsException thrown if the index >= numberOfParameters
 */
public double getStdErrorOfEstimate(int index) throws IndexOutOfBoundsException {
  if (parameters == null) {
    return Double.NaN;
  }
  if (index < 0 || index >= this.parameters.length) {
    throw new IndexOutOfBoundsException(""String_Node_Str"");
  }
  double var=this.getVcvElement(index,index);
  if (!Double.isNaN(var) && var > Double.MIN_VALUE) {
    return FastMath.sqrt(rank);
  }
  return Double.NaN;
}","/** 
 * Returns the <a href=""http://www.xycoon.com/standerrorb(1).htm"">standard error of the parameter estimate at index</a>, usually denoted s(b<sub>index</sub>).
 * @param index an integer index which must be in the range [0, numberOfParameters-1]
 * @return standard errors associated with parameters estimated at index
 * @throws IndexOutOfBoundsException thrown if the index >= numberOfParameters
 */
public double getStdErrorOfEstimate(int index) throws IndexOutOfBoundsException {
  if (parameters == null) {
    return Double.NaN;
  }
  if (index < 0 || index >= this.parameters.length) {
    throw new IndexOutOfBoundsException(""String_Node_Str"");
  }
  double var=this.getVcvElement(index,index);
  if (!Double.isNaN(var) && var > Double.MIN_VALUE) {
    return FastMath.sqrt(var);
  }
  return Double.NaN;
}"
57312,"/** 
 * <p>Returns the <a href=""http://www.xycoon.com/standerrorb(1).htm"">standard error of the parameter estimates</a>, usually denoted s(b<sub>i</sub>).</p> <p>If there are problems with an ill conditioned design matrix then the regressor which is redundant will be assigned <code>Double.NaN</code>. </p>
 * @return an array standard errors associated with parameters estimates,null if no estimation occurred
 */
public double[] getStdErrorOfEstimates(){
  if (parameters == null) {
    return null;
  }
  double[] se=new double[this.parameters.length];
  for (int i=0; i < this.parameters.length; i++) {
    double var=this.getVcvElement(i,i);
    if (!Double.isNaN(var) && var > Double.MIN_VALUE) {
      se[i]=FastMath.sqrt(rank);
      continue;
    }
    se[i]=Double.NaN;
  }
  return se;
}","/** 
 * <p>Returns the <a href=""http://www.xycoon.com/standerrorb(1).htm"">standard error of the parameter estimates</a>, usually denoted s(b<sub>i</sub>).</p> <p>If there are problems with an ill conditioned design matrix then the regressor which is redundant will be assigned <code>Double.NaN</code>. </p>
 * @return an array standard errors associated with parameters estimates,null if no estimation occurred
 */
public double[] getStdErrorOfEstimates(){
  if (parameters == null) {
    return null;
  }
  double[] se=new double[this.parameters.length];
  for (int i=0; i < this.parameters.length; i++) {
    double var=this.getVcvElement(i,i);
    if (!Double.isNaN(var) && var > Double.MIN_VALUE) {
      se[i]=FastMath.sqrt(var);
      continue;
    }
    se[i]=Double.NaN;
  }
  return se;
}"
57313,"/** 
 * Correct the current state estimate with an actual measurement.
 * @param z the measurement vector
 * @throws DimensionMismatchException if the dimension of the measurement vector does not fit
 * @throws org.apache.commons.math.linear.SingularMatrixException if the covariance matrix could not be inverted
 */
public void correct(final RealVector z){
  if (z != null && z.getDimension() != measurementMatrix.getRowDimension()) {
    throw new DimensionMismatchException(z.getDimension(),measurementMatrix.getRowDimension());
  }
  RealMatrix s=measurementMatrix.multiply(errorCovariance).multiply(measurementMatrixT).add(measurementModel.getMeasurementNoise());
  DecompositionSolver solver=new CholeskyDecompositionImpl(s).getSolver();
  RealMatrix invertedS=solver.getInverse();
  RealVector innovation=z.subtract(measurementMatrix.operate(stateEstimation));
  RealMatrix kalmanGain=errorCovariance.multiply(measurementMatrixT).multiply(invertedS);
  stateEstimation=stateEstimation.add(kalmanGain.operate(innovation));
  RealMatrix identity=MatrixUtils.createRealIdentityMatrix(kalmanGain.getRowDimension());
  errorCovariance=identity.subtract(kalmanGain.multiply(measurementMatrix)).multiply(errorCovariance);
}","/** 
 * Correct the current state estimate with an actual measurement.
 * @param z the measurement vector
 * @throws DimensionMismatchException if the dimension of the measurement vector does not fit
 * @throws org.apache.commons.math.linear.SingularMatrixException if the covariance matrix could not be inverted
 */
public void correct(final RealVector z){
  MathUtils.checkNotNull(z);
  if (z.getDimension() != measurementMatrix.getRowDimension()) {
    throw new DimensionMismatchException(z.getDimension(),measurementMatrix.getRowDimension());
  }
  RealMatrix s=measurementMatrix.multiply(errorCovariance).multiply(measurementMatrixT).add(measurementModel.getMeasurementNoise());
  DecompositionSolver solver=new CholeskyDecompositionImpl(s).getSolver();
  RealMatrix invertedS=solver.getInverse();
  RealVector innovation=z.subtract(measurementMatrix.operate(stateEstimation));
  RealMatrix kalmanGain=errorCovariance.multiply(measurementMatrixT).multiply(invertedS);
  stateEstimation=stateEstimation.add(kalmanGain.operate(innovation));
  RealMatrix identity=MatrixUtils.createRealIdentityMatrix(kalmanGain.getRowDimension());
  errorCovariance=identity.subtract(kalmanGain.multiply(measurementMatrix)).multiply(errorCovariance);
}"
57314,"/** 
 * Check all entries of the input array are >= 0.
 * @param in Array to be tested.
 * @exception NotPositiveException if one entry is negative.
 */
private void checkNonNegative(long[][] in){
  for (int i=0; i < in.length; i++) {
    for (int j=0; j < in[i].length; j++) {
      if (in[i][j] < 0) {
        throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_2D_INDEX,i,j,in[i][j]);
      }
    }
  }
}","/** 
 * Check all entries of the input array are >= 0.
 * @param in Array to be tested.
 * @exception MathIllegalArgumentException if one entry is negative.
 */
private void checkNonNegative(long[][] in){
  for (int i=0; i < in.length; i++) {
    for (int j=0; j < in[i].length; j++) {
      if (in[i][j] < 0) {
        throw new MathIllegalArgumentException(LocalizedFormats.NEGATIVE_ELEMENT_AT_2D_INDEX,i,j,in[i][j]);
      }
    }
  }
}"
57315,"/** 
 * Check all entries of the input array are strictly positive.
 * @param in Array to be tested.
 * @exception NotStrictlyPositiveException if one entry is not positive.
 */
private void checkPositive(double[] in){
  for (int i=0; i < in.length; i++) {
    if (in[i] <= 0) {
      throw new MathIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_ELEMENT_AT_INDEX,i,in[i]);
    }
  }
}","/** 
 * Check all entries of the input array are strictly positive.
 * @param in Array to be tested.
 * @exception MathIllegalArgumentException if one entry is not positive.
 */
private void checkPositive(double[] in){
  for (int i=0; i < in.length; i++) {
    if (in[i] <= 0) {
      throw new MathIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_ELEMENT_AT_INDEX,i,in[i]);
    }
  }
}"
57316,"/** 
 * For a random variable   {@code X} whose values are distributed accordingto this distribution, this method returns the largest  {@code x}, such that   {@code P(X < x) < p}.
 * @param p Desired probability.
 * @return the largest {@code x} such that {@code P(X < x) <= p}.
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.
 */
public int inverseCumulativeProbability(final double p) throws MathException {
  if (p < 0 || p > 1) {
    throw new OutOfRangeException(p,0,1);
  }
  int x0=getDomainLowerBound(p);
  int x1=getDomainUpperBound(p);
  double pm;
  while (x0 < x1) {
    int xm=x0 + (x1 - x0) / 2;
    pm=checkedCumulativeProbability(xm);
    if (pm > p) {
      if (xm == x1) {
        --x1;
      }
 else {
        x1=xm;
      }
    }
 else {
      if (xm == x0) {
        ++x0;
      }
 else {
        x0=xm;
      }
    }
  }
  pm=checkedCumulativeProbability(x0);
  while (pm > p) {
    --x0;
    pm=checkedCumulativeProbability(x0);
  }
  return x0;
}","/** 
 * For a random variable   {@code X} whose values are distributed accordingto this distribution, this method returns the largest  {@code x}, such that   {@code P(X <= x) <= p}.
 * @param p Desired probability.
 * @return the largest {@code x} such that {@code P(X < x) <= p}.
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.
 */
public int inverseCumulativeProbability(final double p) throws MathException {
  if (p < 0 || p > 1) {
    throw new OutOfRangeException(p,0,1);
  }
  int x0=getDomainLowerBound(p);
  int x1=getDomainUpperBound(p);
  double pm;
  while (x0 < x1) {
    int xm=x0 + (x1 - x0) / 2;
    pm=checkedCumulativeProbability(xm);
    if (pm > p) {
      if (xm == x1) {
        --x1;
      }
 else {
        x1=xm;
      }
    }
 else {
      if (xm == x0) {
        ++x0;
      }
 else {
        x0=xm;
      }
    }
  }
  pm=checkedCumulativeProbability(x0);
  while (pm > p) {
    --x0;
    pm=checkedCumulativeProbability(x0);
  }
  return x0;
}"
57317,"/** 
 * For this distribution,   {@code X}, this method returns   {@code P(X < x)}.
 * @param x Value at which the PDF is evaluated.
 * @return PDF for this distribution.
 * @throws MathException if the cumulative probability can not be computeddue to convergence or other numerical errors.
 */
@Override public double cumulativeProbability(int x) throws MathException {
  double ret;
  if (x < 0) {
    ret=0.0;
  }
 else   if (x >= numberOfTrials) {
    ret=1.0;
  }
 else {
    ret=1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),x + 1.0,numberOfTrials - x);
  }
  return ret;
}","/** 
 * For this distribution,   {@code X}, this method returns   {@code P(X <= x)}.
 * @param x Value at which the PDF is evaluated.
 * @return PDF for this distribution.
 * @throws MathException if the cumulative probability can not be computeddue to convergence or other numerical errors.
 */
@Override public double cumulativeProbability(int x) throws MathException {
  double ret;
  if (x < 0) {
    ret=0.0;
  }
 else   if (x >= numberOfTrials) {
    ret=1.0;
  }
 else {
    ret=1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),x + 1.0,numberOfTrials - x);
  }
  return ret;
}"
57318,"/** 
 * For this distribution,   {@code X}, this method returns   {@code P(X < x)}.
 * @param x Value at which the PDF is evaluated.
 * @return PDF for this distribution.
 */
@Override public double cumulativeProbability(int x){
  double ret;
  int[] domain=getDomain(populationSize,numberOfSuccesses,sampleSize);
  if (x < domain[0]) {
    ret=0.0;
  }
 else   if (x >= domain[1]) {
    ret=1.0;
  }
 else {
    ret=innerCumulativeProbability(domain[0],x,1,populationSize,numberOfSuccesses,sampleSize);
  }
  return ret;
}","/** 
 * For this distribution,   {@code X}, this method returns   {@code P(X <= x)}.
 * @param x Value at which the PDF is evaluated.
 * @return PDF for this distribution.
 */
@Override public double cumulativeProbability(int x){
  double ret;
  int[] domain=getDomain(populationSize,numberOfSuccesses,sampleSize);
  if (x < domain[0]) {
    ret=0.0;
  }
 else   if (x >= domain[1]) {
    ret=1.0;
  }
 else {
    ret=innerCumulativeProbability(domain[0],x,1,populationSize,numberOfSuccesses,sampleSize);
  }
  return ret;
}"
57319,"/** 
 * For this distribution,   {@code X}, this method returns  {@code P(x0 < X < x1)}.
 * @param x0 the inclusive, lower bound
 * @param x1 the inclusive, upper bound
 * @return the cumulative probability.
 * @throws MathException if the cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if {@code x0 > x1}.
 */
double cumulativeProbability(int x0,int x1) throws MathException ;","/** 
 * For this distribution,   {@code X}, this method returns  {@code P(x0 <= X <= x1)}.
 * @param x0 the inclusive, lower bound
 * @param x1 the inclusive, upper bound
 * @return the cumulative probability.
 * @throws MathException if the cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if {@code x0 > x1}.
 */
double cumulativeProbability(int x0,int x1) throws MathException ;"
57320,"/** 
 * For this distribution,   {@code X}, this method returns the largest  {@code x} such that {@code P(X < x) <= p}. <br/> Note that this definition implies: <ul> <li> If there is a minimum value,   {@code m}, with positive probability under (the density of)   {@code X}, then   {@code m - 1} isreturned by  {@code inverseCumulativeProbability(0).}  If there isno such value  {@code m},    {@code Integer.MIN_VALUE} is returned.</li> <li> If there is a maximum value,  {@code M}, such that  {@code P(X < M) = 1}, then   {@code M} is returned by{@code inverseCumulativeProbability(1)}. If there is no such value,   {@code M},   {@code Integer.MAX_VALUE} isreturned. </li> </ul>
 * @param p Cumulative probability.
 * @return the largest {@code x} such that {@code P(X < x) <= p}.
 * @throws MathException if the inverse cumulative probability cannot becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if {@code p} is not between 0 and 1(inclusive).
 */
int inverseCumulativeProbability(double p) throws MathException ;","/** 
 * For this distribution,   {@code X}, this method returns the largest  {@code x} such that {@code P(X <= x) <= p}. <br/> Note that this definition implies: <ul> <li> If there is a minimum value,   {@code m}, with positive probability under (the density of)   {@code X}, then   {@code m - 1} isreturned by  {@code inverseCumulativeProbability(0).}  If there isno such value  {@code m},    {@code Integer.MIN_VALUE} is returned.</li> <li> If there is a maximum value,  {@code M}, such that  {@code P(X <= M) = 1}, then   {@code M} is returned by{@code inverseCumulativeProbability(1)}. If there is no such value,   {@code M},   {@code Integer.MAX_VALUE} isreturned. </li> </ul>
 * @param p Cumulative probability.
 * @return the largest {@code x} such that {@code P(X < x) <= p}.
 * @throws MathException if the inverse cumulative probability cannot becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if {@code p} is not between 0 and 1(inclusive).
 */
int inverseCumulativeProbability(double p) throws MathException ;"
57321,"/** 
 * For this distribution,   {@code X}, this method returns   {@code P(X < x)}.
 * @param x Value at which the PDF is evaluated.
 * @return PDF for this distribution.
 * @throws MathException if the cumulative probability can not be computeddue to convergence or other numerical errors.
 */
@Override public double cumulativeProbability(int x) throws MathException {
  double ret;
  if (x < 0) {
    ret=0.0;
  }
 else {
    ret=Beta.regularizedBeta(probabilityOfSuccess,numberOfSuccesses,x + 1);
  }
  return ret;
}","/** 
 * For this distribution,   {@code X}, this method returns   {@code P(X <= x)}.
 * @param x Value at which the PDF is evaluated.
 * @return PDF for this distribution.
 * @throws MathException if the cumulative probability can not be computeddue to convergence or other numerical errors.
 */
@Override public double cumulativeProbability(int x) throws MathException {
  double ret;
  if (x < 0) {
    ret=0.0;
  }
 else {
    ret=Beta.regularizedBeta(probabilityOfSuccess,numberOfSuccesses,x + 1);
  }
  return ret;
}"
57322,"/** 
 * For this distribution,   {@code X}, this method returns the largest  {@code x}, such that   {@code P(X < x) p}. It will return -1 when p = 0 and   {@code Integer.MAX_VALUE} when p = 1.
 * @param p Desired probability.
 * @return the largest {@code x} such that {@code P(X < x) <= p}.
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.
 */
@Override public int inverseCumulativeProbability(final double p) throws MathException {
  int ret;
  if (p == 0) {
    ret=-1;
  }
 else   if (p == 1) {
    ret=Integer.MAX_VALUE;
  }
 else {
    ret=super.inverseCumulativeProbability(p);
  }
  return ret;
}","/** 
 * For this distribution,   {@code X}, this method returns the largest  {@code x}, such that   {@code P(X <= x) <= p}. It will return -1 when p = 0 and   {@code Integer.MAX_VALUE} when p = 1.
 * @param p Desired probability.
 * @return the largest {@code x} such that {@code P(X <= x) <= p}.
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}.
 */
@Override public int inverseCumulativeProbability(final double p) throws MathException {
  int ret;
  if (p == 0) {
    ret=-1;
  }
 else   if (p == 1) {
    ret=Integer.MAX_VALUE;
  }
 else {
    ret=super.inverseCumulativeProbability(p);
  }
  return ret;
}"
57323,"/** 
 * Convert the instance into a double.
 * @return a double approximating the instance
 * @see #toSplitDouble()
 */
public double toDouble(){
  if (isInfinite()) {
    if (lessThan(getZero())) {
      return Double.NEGATIVE_INFINITY;
    }
 else {
      return Double.POSITIVE_INFINITY;
    }
  }
  if (isNaN()) {
    return Double.NaN;
  }
  Dfp y=this;
  boolean negate=false;
  if (lessThan(getZero())) {
    y=negate();
    negate=true;
  }
  int exponent=(int)(y.log10() * 3.32);
  if (exponent < 0) {
    exponent--;
  }
  Dfp tempDfp=DfpMath.pow(getTwo(),exponent);
  while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
    tempDfp=tempDfp.multiply(2);
    exponent++;
  }
  exponent--;
  y=y.divide(DfpMath.pow(getTwo(),exponent));
  if (exponent > -1023) {
    y=y.subtract(getOne());
  }
  if (exponent < -1074) {
    return 0;
  }
  if (exponent > 1023) {
    return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
  }
  y=y.multiply(newInstance(4503599627370496l)).rint();
  String str=y.toString();
  str=str.substring(0,str.length() - 1);
  long mantissa=Long.parseLong(str);
  if (mantissa == 4503599627370496L) {
    mantissa=0;
    exponent++;
  }
  if (exponent <= -1023) {
    exponent--;
  }
  while (exponent < -1023) {
    exponent++;
    mantissa>>>=1;
  }
  long bits=mantissa | ((exponent + 1023L) << 52);
  double x=Double.longBitsToDouble(bits);
  if (negate) {
    x=-x;
  }
  return x;
}","/** 
 * Convert the instance into a double.
 * @return a double approximating the instance
 * @see #toSplitDouble()
 */
public double toDouble(){
  if (isInfinite()) {
    if (lessThan(getZero())) {
      return Double.NEGATIVE_INFINITY;
    }
 else {
      return Double.POSITIVE_INFINITY;
    }
  }
  if (isNaN()) {
    return Double.NaN;
  }
  Dfp y=this;
  boolean negate=false;
  int cmp0=compare(this,getZero());
  if (cmp0 == 0) {
    return sign < 0 ? -0.0 : +0.0;
  }
 else   if (cmp0 < 0) {
    y=negate();
    negate=true;
  }
  int exponent=(int)(y.log10() * 3.32);
  if (exponent < 0) {
    exponent--;
  }
  Dfp tempDfp=DfpMath.pow(getTwo(),exponent);
  while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
    tempDfp=tempDfp.multiply(2);
    exponent++;
  }
  exponent--;
  y=y.divide(DfpMath.pow(getTwo(),exponent));
  if (exponent > -1023) {
    y=y.subtract(getOne());
  }
  if (exponent < -1074) {
    return 0;
  }
  if (exponent > 1023) {
    return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
  }
  y=y.multiply(newInstance(4503599627370496l)).rint();
  String str=y.toString();
  str=str.substring(0,str.length() - 1);
  long mantissa=Long.parseLong(str);
  if (mantissa == 4503599627370496L) {
    mantissa=0;
    exponent++;
  }
  if (exponent <= -1023) {
    exponent--;
  }
  while (exponent < -1023) {
    exponent++;
    mantissa>>>=1;
  }
  long bits=mantissa | ((exponent + 1023L) << 52);
  double x=Double.longBitsToDouble(bits);
  if (negate) {
    x=-x;
  }
  return x;
}"
57324,"/** 
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between {@code -PI} and {@code PI}
 */
public static double atan2(double y,double x){
  if (x != x || y != y) {
    return Double.NaN;
  }
  if (y == 0.0) {
    double result=x * y;
    double invx=1.0 / x;
    double invy=1.0 / y;
    if (invx == 0.0) {
      if (x > 0) {
        return y;
      }
 else {
        return copySign(Math.PI,y);
      }
    }
    if (x < 0.0 || invx < 0.0) {
      if (y < 0.0 || invy < 0.0) {
        return -Math.PI;
      }
 else {
        return Math.PI;
      }
    }
 else {
      return result;
    }
  }
  if (y == Double.POSITIVE_INFINITY) {
    if (x == Double.POSITIVE_INFINITY) {
      return Math.PI / 4.0;
    }
    if (x == Double.NEGATIVE_INFINITY) {
      return Math.PI * 3.0 / 4.0;
    }
    return Math.PI / 2.0;
  }
  if (y == Double.NEGATIVE_INFINITY) {
    if (x == Double.POSITIVE_INFINITY) {
      return -Math.PI / 4.0;
    }
    if (x == Double.NEGATIVE_INFINITY) {
      return -Math.PI * 3.0 / 4.0;
    }
    return -Math.PI / 2.0;
  }
  if (x == Double.POSITIVE_INFINITY) {
    if (y > 0.0 || 1 / y > 0.0) {
      return 0.0;
    }
    if (y < 0.0 || 1 / y < 0.0) {
      return -0.0;
    }
  }
  if (x == Double.NEGATIVE_INFINITY) {
    if (y > 0.0 || 1 / y > 0.0) {
      return Math.PI;
    }
    if (y < 0.0 || 1 / y < 0.0) {
      return -Math.PI;
    }
  }
  if (x == 0) {
    if (y > 0.0 || 1 / y > 0.0) {
      return Math.PI / 2.0;
    }
    if (y < 0.0 || 1 / y < 0.0) {
      return -Math.PI / 2.0;
    }
  }
  final double r=y / x;
  if (Double.isInfinite(r)) {
    return atan(r,0,x < 0);
  }
  double ra=doubleHighPart(r);
  double rb=r - ra;
  final double xa=doubleHighPart(x);
  final double xb=x - xa;
  rb+=(y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
  double temp=ra + rb;
  rb=-(temp - ra - rb);
  ra=temp;
  if (ra == 0 && (y < 0)) {
    ra=-0.0;
  }
  double result=atan(ra,rb,x < 0);
  return result;
}","/** 
 * Two arguments arctangent function
 * @param y ordinate
 * @param x abscissa
 * @return phase angle of point (x,y) between {@code -PI} and {@code PI}
 */
public static double atan2(double y,double x){
  if (x != x || y != y) {
    return Double.NaN;
  }
  if (y == 0.0) {
    double result=x * y;
    double invx=1.0 / x;
    double invy=1.0 / y;
    if (invx == 0.0) {
      if (x > 0) {
        return y;
      }
 else {
        return copySign(Math.PI,y);
      }
    }
    if (x < 0.0 || invx < 0.0) {
      if (y < 0.0 || invy < 0.0) {
        return -Math.PI;
      }
 else {
        return Math.PI;
      }
    }
 else {
      return result;
    }
  }
  if (y == Double.POSITIVE_INFINITY) {
    if (x == Double.POSITIVE_INFINITY) {
      return Math.PI / 4.0;
    }
    if (x == Double.NEGATIVE_INFINITY) {
      return Math.PI * 3.0 / 4.0;
    }
    return Math.PI / 2.0;
  }
  if (y == Double.NEGATIVE_INFINITY) {
    if (x == Double.POSITIVE_INFINITY) {
      return -Math.PI / 4.0;
    }
    if (x == Double.NEGATIVE_INFINITY) {
      return -Math.PI * 3.0 / 4.0;
    }
    return -Math.PI / 2.0;
  }
  if (x == Double.POSITIVE_INFINITY) {
    if (y > 0.0 || 1 / y > 0.0) {
      return 0.0;
    }
    if (y < 0.0 || 1 / y < 0.0) {
      return -0.0;
    }
  }
  if (x == Double.NEGATIVE_INFINITY) {
    if (y > 0.0 || 1 / y > 0.0) {
      return Math.PI;
    }
    if (y < 0.0 || 1 / y < 0.0) {
      return -Math.PI;
    }
  }
  if (x == 0) {
    if (y > 0.0 || 1 / y > 0.0) {
      return Math.PI / 2.0;
    }
    if (y < 0.0 || 1 / y < 0.0) {
      return -Math.PI / 2.0;
    }
  }
  final double r=y / x;
  if (Double.isInfinite(r)) {
    return atan(r,0,x < 0);
  }
  double ra=doubleHighPart(r);
  double rb=r - ra;
  final double xa=doubleHighPart(x);
  final double xb=x - xa;
  rb+=(y - ra * xa - ra * xb - rb * xa - rb * xb) / x;
  double temp=ra + rb;
  rb=-(temp - ra - rb);
  ra=temp;
  if (ra == 0) {
    ra=copySign(0.0,y);
  }
  double result=atan(ra,rb,x < 0);
  return result;
}"
57325,"/** 
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an eventasks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception IntegratorException if the value of one event state cannot be evaluated
 */
protected double acceptStep(final AbstractStepInterpolator interpolator,final double[] y,final double[] yDot,final double tEnd) throws IntegratorException {
  try {
    double previousT=interpolator.getGlobalPreviousTime();
    final double currentT=interpolator.getGlobalCurrentTime();
    resetOccurred=false;
    if (!statesInitialized) {
      for (      EventState state : eventsStates) {
        state.reinitializeBegin(interpolator);
      }
      statesInitialized=true;
    }
    SortedSet<EventState> occuringEvents=new TreeSet<EventState>();
    for (    final EventState state : eventsStates) {
      if (state.evaluateStep(interpolator)) {
        occuringEvents.add(state);
      }
    }
    for (    final EventState state : occuringEvents) {
      final double eventT=state.getEventTime();
      interpolator.setSoftBounds(previousT,eventT);
      interpolator.setInterpolatedTime(eventT);
      final double[] eventY=interpolator.getInterpolatedState();
      state.stepAccepted(eventT,eventY);
      isLastStep=state.stop();
      for (      final StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator,isLastStep);
      }
      if (isLastStep) {
        System.arraycopy(eventY,0,y,0,y.length);
        return eventT;
      }
      if (state.reset(eventT,eventY)) {
        System.arraycopy(eventY,0,y,0,y.length);
        computeDerivatives(eventT,y,yDot);
        resetOccurred=true;
        return eventT;
      }
      previousT=eventT;
      interpolator.setSoftBounds(eventT,currentT);
    }
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY=interpolator.getInterpolatedState();
    for (    final EventState state : eventsStates) {
      state.stepAccepted(currentT,currentY);
      isLastStep=isLastStep || state.stop();
    }
    isLastStep=isLastStep || MathUtils.equals(currentT,tEnd,1);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,isLastStep);
    }
    return currentT;
  }
 catch (  EventException se) {
    final Throwable cause=se.getCause();
    if ((cause != null) && (cause instanceof MathUserException)) {
      throw (MathUserException)cause;
    }
    throw new IntegratorException(se);
  }
catch (  ConvergenceException ce) {
    throw new IntegratorException(ce);
  }
}","/** 
 * Accept a step, triggering events and step handlers.
 * @param interpolator step interpolator
 * @param y state vector at step end time, must be reset if an eventasks for resetting or if an events stops integration during the step
 * @param yDot placeholder array where to put the time derivative of the state vector
 * @param tEnd final integration time
 * @return time at end of step
 * @exception IntegratorException if the value of one event state cannot be evaluated
 */
protected double acceptStep(final AbstractStepInterpolator interpolator,final double[] y,final double[] yDot,final double tEnd) throws IntegratorException {
  try {
    double previousT=interpolator.getGlobalPreviousTime();
    final double currentT=interpolator.getGlobalCurrentTime();
    resetOccurred=false;
    if (!statesInitialized) {
      for (      EventState state : eventsStates) {
        state.reinitializeBegin(interpolator);
      }
      statesInitialized=true;
    }
    SortedSet<EventState> occuringEvents=new TreeSet<EventState>(new Comparator<EventState>(){
      /** 
 * {@inheritDoc} 
 */
      public int compare(      EventState es0,      EventState es1){
        return Double.compare(es0.getEventTime(),es1.getEventTime());
      }
    }
);
    for (    final EventState state : eventsStates) {
      if (state.evaluateStep(interpolator)) {
        occuringEvents.add(state);
      }
    }
    for (    final EventState state : occuringEvents) {
      final double eventT=state.getEventTime();
      interpolator.setSoftPreviousTime(previousT);
      interpolator.setSoftCurrentTime(eventT);
      interpolator.setInterpolatedTime(eventT);
      final double[] eventY=interpolator.getInterpolatedState();
      state.stepAccepted(eventT,eventY);
      isLastStep=state.stop();
      for (      final StepHandler handler : stepHandlers) {
        handler.handleStep(interpolator,isLastStep);
      }
      if (isLastStep) {
        System.arraycopy(eventY,0,y,0,y.length);
        return eventT;
      }
      if (state.reset(eventT,eventY)) {
        System.arraycopy(eventY,0,y,0,y.length);
        computeDerivatives(eventT,y,yDot);
        resetOccurred=true;
        return eventT;
      }
      previousT=eventT;
      interpolator.setSoftPreviousTime(eventT);
      interpolator.setSoftCurrentTime(currentT);
    }
    interpolator.setInterpolatedTime(currentT);
    final double[] currentY=interpolator.getInterpolatedState();
    for (    final EventState state : eventsStates) {
      state.stepAccepted(currentT,currentY);
      isLastStep=isLastStep || state.stop();
    }
    isLastStep=isLastStep || MathUtils.equals(currentT,tEnd,1);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,isLastStep);
    }
    return currentT;
  }
 catch (  EventException se) {
    final Throwable cause=se.getCause();
    if ((cause != null) && (cause instanceof MathUserException)) {
      throw (MathUserException)cause;
    }
    throw new IntegratorException(se);
  }
catch (  ConvergenceException ce) {
    throw new IntegratorException(ce);
  }
}"
57326,"/** 
 * Get the occurrence time of the event triggered in the current step.
 * @return occurrence time of the event triggered in the currentstep.
 */
public double getEventTime(){
  return pendingEventTime;
}","/** 
 * Get the occurrence time of the event triggered in the current step.
 * @return occurrence time of the event triggered in the currentstep or positive infinity if no events are triggered
 */
public double getEventTime(){
  return pendingEvent ? pendingEventTime : Double.POSITIVE_INFINITY;
}"
57327,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[n];
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  statesInitialized=false;
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  final int lastRow=nordsieck.getRowDimension() - 1;
  double hNew=stepSize;
  interpolator.rescale(hNew);
  isLastStep=false;
  do {
    double error=10;
    while (error >= 1.0) {
      stepSize=hNew;
      error=0;
      for (int i=0; i < mainSetDimension; ++i) {
        final double yScale=FastMath.abs(y[i]);
        final double tol=(vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
        final double ratio=nordsieck.getEntry(lastRow,i) / tol;
        error+=ratio * ratio;
      }
      error=FastMath.sqrt(error / mainSetDimension);
      if (error >= 1.0) {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double stepEnd=stepStart + stepSize;
    interpolator.shift();
    interpolator.setInterpolatedTime(stepEnd);
    System.arraycopy(interpolator.getInterpolatedState(),0,y,0,y0.length);
    computeDerivatives(stepEnd,y,yDot);
    final double[] predictedScaled=new double[y0.length];
    for (int j=0; j < y0.length; ++j) {
      predictedScaled[j]=stepSize * yDot[j];
    }
    final Array2DRowRealMatrix nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
    updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
    interpolator.reinitialize(stepEnd,stepSize,predictedScaled,nordsieckTmp);
    interpolator.storeTime(stepEnd);
    stepStart=acceptStep(interpolator,y,yDot,t);
    scaled=predictedScaled;
    nordsieck=nordsieckTmp;
    interpolator.reinitialize(stepEnd,stepSize,scaled,nordsieck);
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      if (resetOccurred) {
        start(stepStart,y,t);
        interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
      }
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      final double filteredNextT=stepStart + hNew;
      final boolean filteredNextIsLast=forward ? (filteredNextT >= t) : (filteredNextT <= t);
      if (filteredNextIsLast) {
        hNew=t - stepStart;
      }
      interpolator.rescale(hNew);
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[n];
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  setStateInitialized(false);
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  final int lastRow=nordsieck.getRowDimension() - 1;
  double hNew=stepSize;
  interpolator.rescale(hNew);
  isLastStep=false;
  do {
    double error=10;
    while (error >= 1.0) {
      stepSize=hNew;
      error=0;
      for (int i=0; i < mainSetDimension; ++i) {
        final double yScale=FastMath.abs(y[i]);
        final double tol=(vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
        final double ratio=nordsieck.getEntry(lastRow,i) / tol;
        error+=ratio * ratio;
      }
      error=FastMath.sqrt(error / mainSetDimension);
      if (error >= 1.0) {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double stepEnd=stepStart + stepSize;
    interpolator.shift();
    interpolator.setInterpolatedTime(stepEnd);
    System.arraycopy(interpolator.getInterpolatedState(),0,y,0,y0.length);
    computeDerivatives(stepEnd,y,yDot);
    final double[] predictedScaled=new double[y0.length];
    for (int j=0; j < y0.length; ++j) {
      predictedScaled[j]=stepSize * yDot[j];
    }
    final Array2DRowRealMatrix nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
    updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
    interpolator.reinitialize(stepEnd,stepSize,predictedScaled,nordsieckTmp);
    interpolator.storeTime(stepEnd);
    stepStart=acceptStep(interpolator,y,yDot,t);
    scaled=predictedScaled;
    nordsieck=nordsieckTmp;
    interpolator.reinitialize(stepEnd,stepSize,scaled,nordsieck);
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      if (resetOccurred) {
        start(stepStart,y,t);
        interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
      }
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      final double filteredNextT=stepStart + hNew;
      final boolean filteredNextIsLast=forward ? (filteredNextT >= t) : (filteredNextT <= t);
      if (filteredNextIsLast) {
        hNew=t - stepStart;
      }
      interpolator.rescale(hNew);
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}"
57328,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] predictedScaled=new double[y0.length];
  Array2DRowRealMatrix nordsieckTmp=null;
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  statesInitialized=false;
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  double hNew=stepSize;
  interpolator.rescale(hNew);
  isLastStep=false;
  do {
    double error=10;
    while (error >= 1.0) {
      stepSize=hNew;
      final double stepEnd=stepStart + stepSize;
      interpolator.setInterpolatedTime(stepEnd);
      System.arraycopy(interpolator.getInterpolatedState(),0,yTmp,0,y0.length);
      computeDerivatives(stepEnd,yTmp,yDot);
      for (int j=0; j < y0.length; ++j) {
        predictedScaled[j]=stepSize * yDot[j];
      }
      nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
      updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
      error=nordsieckTmp.walkInOptimizedOrder(new Corrector(y,predictedScaled,yTmp));
      if (error >= 1.0) {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double stepEnd=stepStart + stepSize;
    computeDerivatives(stepEnd,yTmp,yDot);
    final double[] correctedScaled=new double[y0.length];
    for (int j=0; j < y0.length; ++j) {
      correctedScaled[j]=stepSize * yDot[j];
    }
    updateHighOrderDerivativesPhase2(predictedScaled,correctedScaled,nordsieckTmp);
    System.arraycopy(yTmp,0,y,0,n);
    interpolator.reinitialize(stepEnd,stepSize,correctedScaled,nordsieckTmp);
    interpolator.storeTime(stepStart);
    interpolator.shift();
    interpolator.storeTime(stepEnd);
    stepStart=acceptStep(interpolator,y,yDot,t);
    scaled=correctedScaled;
    nordsieck=nordsieckTmp;
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      if (resetOccurred) {
        start(stepStart,y,t);
        interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
      }
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      final double filteredNextT=stepStart + hNew;
      final boolean filteredNextIsLast=forward ? (filteredNextT >= t) : (filteredNextT <= t);
      if (filteredNextIsLast) {
        hNew=t - stepStart;
      }
      interpolator.rescale(hNew);
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] predictedScaled=new double[y0.length];
  Array2DRowRealMatrix nordsieckTmp=null;
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  setStateInitialized(false);
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  double hNew=stepSize;
  interpolator.rescale(hNew);
  isLastStep=false;
  do {
    double error=10;
    while (error >= 1.0) {
      stepSize=hNew;
      final double stepEnd=stepStart + stepSize;
      interpolator.setInterpolatedTime(stepEnd);
      System.arraycopy(interpolator.getInterpolatedState(),0,yTmp,0,y0.length);
      computeDerivatives(stepEnd,yTmp,yDot);
      for (int j=0; j < y0.length; ++j) {
        predictedScaled[j]=stepSize * yDot[j];
      }
      nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
      updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
      error=nordsieckTmp.walkInOptimizedOrder(new Corrector(y,predictedScaled,yTmp));
      if (error >= 1.0) {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double stepEnd=stepStart + stepSize;
    computeDerivatives(stepEnd,yTmp,yDot);
    final double[] correctedScaled=new double[y0.length];
    for (int j=0; j < y0.length; ++j) {
      correctedScaled[j]=stepSize * yDot[j];
    }
    updateHighOrderDerivativesPhase2(predictedScaled,correctedScaled,nordsieckTmp);
    System.arraycopy(yTmp,0,y,0,n);
    interpolator.reinitialize(stepEnd,stepSize,correctedScaled,nordsieckTmp);
    interpolator.storeTime(stepStart);
    interpolator.shift();
    interpolator.storeTime(stepEnd);
    stepStart=acceptStep(interpolator,y,yDot,t);
    scaled=correctedScaled;
    nordsieck=nordsieckTmp;
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      if (resetOccurred) {
        start(stepStart,y,t);
        interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
      }
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      final double filteredNextT=stepStart + hNew;
      final boolean filteredNextIsLast=forward ? (filteredNextT >= t) : (filteredNextT <= t);
      if (filteredNextIsLast) {
        hNew=t - stepStart;
      }
      interpolator.rescale(hNew);
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}"
57329,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] yDotTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput()) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  statesInitialized=false;
  isLastStep=false;
  do {
    interpolator.shift();
    double error=10;
    while (error >= 1.0) {
      if (firstTime || !fsal) {
        computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale=new double[mainSetDimension];
        if (vecAbsoluteTolerance == null) {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
          }
        }
 else {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error >= 1.0) {
        final double factor=FastMath.min(maxGrowth,FastMath.max(minReduction,safety * FastMath.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    interpolator.storeTime(stepStart + stepSize);
    System.arraycopy(yTmp,0,y,0,y0.length);
    System.arraycopy(yDotK[stages - 1],0,yDotTmp,0,y0.length);
    stepStart=acceptStep(interpolator,y,yDotTmp,t);
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      if (fsal) {
        System.arraycopy(yDotTmp,0,yDotK[0],0,y0.length);
      }
      final double factor=FastMath.min(maxGrowth,FastMath.max(minReduction,safety * FastMath.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      final double filteredNextT=stepStart + hNew;
      final boolean filteredNextIsLast=forward ? (filteredNextT >= t) : (filteredNextT <= t);
      if (filteredNextIsLast) {
        hNew=t - stepStart;
      }
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] yDotTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput()) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  setStateInitialized(false);
  isLastStep=false;
  do {
    interpolator.shift();
    double error=10;
    while (error >= 1.0) {
      if (firstTime || !fsal) {
        computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale=new double[mainSetDimension];
        if (vecAbsoluteTolerance == null) {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
          }
        }
 else {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error >= 1.0) {
        final double factor=FastMath.min(maxGrowth,FastMath.max(minReduction,safety * FastMath.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    interpolator.storeTime(stepStart + stepSize);
    System.arraycopy(yTmp,0,y,0,y0.length);
    System.arraycopy(yDotK[stages - 1],0,yDotTmp,0,y0.length);
    stepStart=acceptStep(interpolator,y,yDotTmp,t);
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      if (fsal) {
        System.arraycopy(yDotTmp,0,yDotK[0],0,y0.length);
      }
      final double factor=FastMath.min(maxGrowth,FastMath.max(minReduction,safety * FastMath.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      final double filteredNextT=stepStart + hNew;
      final boolean filteredNextIsLast=forward ? (filteredNextT >= t) : (filteredNextT <= t);
      if (filteredNextIsLast) {
        hNew=t - stepStart;
      }
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}"
57330,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final double[] yDot0=new double[y0.length];
  final double[] y1=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] yTmpDot=new double[y0.length];
  final double[][] diagonal=new double[sequence.length - 1][];
  final double[][] y1Diag=new double[sequence.length - 1][];
  for (int k=0; k < sequence.length - 1; ++k) {
    diagonal[k]=new double[y0.length];
    y1Diag[k]=new double[y0.length];
  }
  final double[][][] fk=new double[sequence.length][][];
  for (int k=0; k < sequence.length; ++k) {
    fk[k]=new double[sequence[k] + 1][];
    fk[k][0]=yDot0;
    for (int l=0; l < sequence[k]; ++l) {
      fk[k][l + 1]=new double[y0.length];
    }
  }
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  double[] yDot1=new double[y0.length];
  double[][] yMidDots=null;
  final boolean denseOutput=requiresDenseOutput();
  if (denseOutput) {
    yMidDots=new double[1 + 2 * sequence.length][];
    for (int j=0; j < yMidDots.length; ++j) {
      yMidDots[j]=new double[y0.length];
    }
  }
 else {
    yMidDots=new double[1][];
    yMidDots[0]=new double[y0.length];
  }
  final double[] scale=new double[mainSetDimension];
  rescale(y,y,scale);
  final double tol=(vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
  final double log10R=FastMath.log10(FastMath.max(1.0e-10,tol));
  int targetIter=FastMath.max(1,FastMath.min(sequence.length - 2,(int)FastMath.floor(0.5 - 0.6 * log10R)));
  AbstractStepInterpolator interpolator=null;
  if (denseOutput) {
    interpolator=new GraggBulirschStoerStepInterpolator(y,yDot0,y1,yDot1,yMidDots,forward);
  }
 else {
    interpolator=new DummyStepInterpolator(y,yDot1,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  double maxError=Double.MAX_VALUE;
  boolean previousRejected=false;
  boolean firstTime=true;
  boolean newStep=true;
  boolean firstStepAlreadyComputed=false;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  statesInitialized=false;
  costPerTimeUnit[0]=0;
  isLastStep=false;
  do {
    double error;
    boolean reject=false;
    if (newStep) {
      interpolator.shift();
      if (!firstStepAlreadyComputed) {
        computeDerivatives(stepStart,y,yDot0);
      }
      if (firstTime) {
        hNew=initializeStep(equations,forward,2 * targetIter + 1,scale,stepStart,y,yDot0,yTmp,yTmpDot);
      }
      newStep=false;
    }
    stepSize=hNew;
    if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) {
      stepSize=t - stepStart;
    }
    final double nextT=stepStart + stepSize;
    isLastStep=forward ? (nextT >= t) : (nextT <= t);
    int k=-1;
    for (boolean loop=true; loop; ) {
      ++k;
      if (!tryStep(stepStart,y,stepSize,k,scale,fk[k],(k == 0) ? yMidDots[0] : diagonal[k - 1],(k == 0) ? y1 : y1Diag[k - 1],yTmp)) {
        hNew=FastMath.abs(filterStep(stepSize * stabilityReduction,forward,false));
        reject=true;
        loop=false;
      }
 else {
        if (k > 0) {
          extrapolate(0,k,y1Diag,y1);
          rescale(y,y1,scale);
          error=0;
          for (int j=0; j < mainSetDimension; ++j) {
            final double e=FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];
            error+=e * e;
          }
          error=FastMath.sqrt(error / mainSetDimension);
          if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
            hNew=FastMath.abs(filterStep(stepSize * stabilityReduction,forward,false));
            reject=true;
            loop=false;
          }
 else {
            maxError=FastMath.max(4 * error,1.0);
            final double exp=1.0 / (2 * k + 1);
            double fac=stepControl2 / FastMath.pow(error / stepControl1,exp);
            final double pow=FastMath.pow(stepControl3,exp);
            fac=FastMath.max(pow / stepControl4,FastMath.min(1 / pow,fac));
            optimalStep[k]=FastMath.abs(filterStep(stepSize * fac,forward,true));
            costPerTimeUnit[k]=costPerStep[k] / optimalStep[k];
switch (k - targetIter) {
case -1:
              if ((targetIter > 1) && !previousRejected) {
                if (error <= 1.0) {
                  loop=false;
                }
 else {
                  final double ratio=((double)sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]);
                  if (error > ratio * ratio) {
                    reject=true;
                    loop=false;
                    targetIter=k;
                    if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                      --targetIter;
                    }
                    hNew=optimalStep[targetIter];
                  }
                }
              }
            break;
case 0:
          if (error <= 1.0) {
            loop=false;
          }
 else {
            final double ratio=((double)sequence[k + 1]) / sequence[0];
            if (error > ratio * ratio) {
              reject=true;
              loop=false;
              if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                --targetIter;
              }
              hNew=optimalStep[targetIter];
            }
          }
        break;
case 1:
      if (error > 1.0) {
        reject=true;
        if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
          --targetIter;
        }
        hNew=optimalStep[targetIter];
      }
    loop=false;
  break;
default :
if ((firstTime || isLastStep) && (error <= 1.0)) {
  loop=false;
}
break;
}
}
}
}
}
if (!reject) {
computeDerivatives(stepStart + stepSize,y1,yDot1);
}
double hInt=getMaxStep();
if (denseOutput && !reject) {
for (int j=1; j <= k; ++j) {
extrapolate(0,j,diagonal,yMidDots[0]);
}
final int mu=2 * k - mudif + 3;
for (int l=0; l < mu; ++l) {
final int l2=l / 2;
double factor=FastMath.pow(0.5 * sequence[l2],l);
int middleIndex=fk[l2].length / 2;
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]=factor * fk[l2][middleIndex + l][i];
}
for (int j=1; j <= k - l2; ++j) {
factor=FastMath.pow(0.5 * sequence[j + l2],l);
middleIndex=fk[l2 + j].length / 2;
for (int i=0; i < y0.length; ++i) {
diagonal[j - 1][i]=factor * fk[l2 + j][middleIndex + l][i];
}
extrapolate(l2,j,diagonal,yMidDots[l + 1]);
}
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]*=stepSize;
}
for (int j=(l + 1) / 2; j <= k; ++j) {
for (int m=fk[j].length - 1; m >= 2 * (l + 1); --m) {
for (int i=0; i < y0.length; ++i) {
fk[j][m][i]-=fk[j][m - 2][i];
}
}
}
}
if (mu >= 0) {
final GraggBulirschStoerStepInterpolator gbsInterpolator=(GraggBulirschStoerStepInterpolator)interpolator;
gbsInterpolator.computeCoefficients(mu,stepSize);
if (useInterpolationError) {
final double interpError=gbsInterpolator.estimateError(scale);
hInt=FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError,1.0 / (mu + 4)),0.01));
if (interpError > 10.0) {
hNew=hInt;
reject=true;
}
}
}
}
if (!reject) {
interpolator.storeTime(stepStart + stepSize);
stepStart=acceptStep(interpolator,y1,yDot1,t);
interpolator.storeTime(stepStart);
System.arraycopy(y1,0,y,0,y0.length);
System.arraycopy(yDot1,0,yDot0,0,y0.length);
firstStepAlreadyComputed=true;
int optimalIter;
if (k == 1) {
optimalIter=2;
if (previousRejected) {
optimalIter=1;
}
}
 else if (k <= targetIter) {
optimalIter=k;
if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) {
optimalIter=k - 1;
}
 else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) {
optimalIter=FastMath.min(k + 1,sequence.length - 2);
}
}
 else {
optimalIter=k - 1;
if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) {
optimalIter=k - 2;
}
if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
optimalIter=FastMath.min(k,sequence.length - 2);
}
}
if (previousRejected) {
targetIter=FastMath.min(optimalIter,k);
hNew=FastMath.min(FastMath.abs(stepSize),optimalStep[targetIter]);
}
 else {
if (optimalIter <= k) {
hNew=optimalStep[optimalIter];
}
 else {
if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k],forward,false);
}
 else {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],forward,false);
}
}
targetIter=optimalIter;
}
newStep=true;
}
hNew=FastMath.min(hNew,hInt);
if (!forward) {
hNew=-hNew;
}
firstTime=false;
if (reject) {
isLastStep=false;
previousRejected=true;
}
 else {
previousRejected=false;
}
}
 while (!isLastStep);
final double stopTime=stepStart;
resetInternalState();
return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final double[] yDot0=new double[y0.length];
  final double[] y1=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] yTmpDot=new double[y0.length];
  final double[][] diagonal=new double[sequence.length - 1][];
  final double[][] y1Diag=new double[sequence.length - 1][];
  for (int k=0; k < sequence.length - 1; ++k) {
    diagonal[k]=new double[y0.length];
    y1Diag[k]=new double[y0.length];
  }
  final double[][][] fk=new double[sequence.length][][];
  for (int k=0; k < sequence.length; ++k) {
    fk[k]=new double[sequence[k] + 1][];
    fk[k][0]=yDot0;
    for (int l=0; l < sequence[k]; ++l) {
      fk[k][l + 1]=new double[y0.length];
    }
  }
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  double[] yDot1=new double[y0.length];
  double[][] yMidDots=null;
  final boolean denseOutput=requiresDenseOutput();
  if (denseOutput) {
    yMidDots=new double[1 + 2 * sequence.length][];
    for (int j=0; j < yMidDots.length; ++j) {
      yMidDots[j]=new double[y0.length];
    }
  }
 else {
    yMidDots=new double[1][];
    yMidDots[0]=new double[y0.length];
  }
  final double[] scale=new double[mainSetDimension];
  rescale(y,y,scale);
  final double tol=(vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
  final double log10R=FastMath.log10(FastMath.max(1.0e-10,tol));
  int targetIter=FastMath.max(1,FastMath.min(sequence.length - 2,(int)FastMath.floor(0.5 - 0.6 * log10R)));
  AbstractStepInterpolator interpolator=null;
  if (denseOutput) {
    interpolator=new GraggBulirschStoerStepInterpolator(y,yDot0,y1,yDot1,yMidDots,forward);
  }
 else {
    interpolator=new DummyStepInterpolator(y,yDot1,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  double maxError=Double.MAX_VALUE;
  boolean previousRejected=false;
  boolean firstTime=true;
  boolean newStep=true;
  boolean firstStepAlreadyComputed=false;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  setStateInitialized(false);
  costPerTimeUnit[0]=0;
  isLastStep=false;
  do {
    double error;
    boolean reject=false;
    if (newStep) {
      interpolator.shift();
      if (!firstStepAlreadyComputed) {
        computeDerivatives(stepStart,y,yDot0);
      }
      if (firstTime) {
        hNew=initializeStep(equations,forward,2 * targetIter + 1,scale,stepStart,y,yDot0,yTmp,yTmpDot);
      }
      newStep=false;
    }
    stepSize=hNew;
    if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) {
      stepSize=t - stepStart;
    }
    final double nextT=stepStart + stepSize;
    isLastStep=forward ? (nextT >= t) : (nextT <= t);
    int k=-1;
    for (boolean loop=true; loop; ) {
      ++k;
      if (!tryStep(stepStart,y,stepSize,k,scale,fk[k],(k == 0) ? yMidDots[0] : diagonal[k - 1],(k == 0) ? y1 : y1Diag[k - 1],yTmp)) {
        hNew=FastMath.abs(filterStep(stepSize * stabilityReduction,forward,false));
        reject=true;
        loop=false;
      }
 else {
        if (k > 0) {
          extrapolate(0,k,y1Diag,y1);
          rescale(y,y1,scale);
          error=0;
          for (int j=0; j < mainSetDimension; ++j) {
            final double e=FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j];
            error+=e * e;
          }
          error=FastMath.sqrt(error / mainSetDimension);
          if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
            hNew=FastMath.abs(filterStep(stepSize * stabilityReduction,forward,false));
            reject=true;
            loop=false;
          }
 else {
            maxError=FastMath.max(4 * error,1.0);
            final double exp=1.0 / (2 * k + 1);
            double fac=stepControl2 / FastMath.pow(error / stepControl1,exp);
            final double pow=FastMath.pow(stepControl3,exp);
            fac=FastMath.max(pow / stepControl4,FastMath.min(1 / pow,fac));
            optimalStep[k]=FastMath.abs(filterStep(stepSize * fac,forward,true));
            costPerTimeUnit[k]=costPerStep[k] / optimalStep[k];
switch (k - targetIter) {
case -1:
              if ((targetIter > 1) && !previousRejected) {
                if (error <= 1.0) {
                  loop=false;
                }
 else {
                  final double ratio=((double)sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]);
                  if (error > ratio * ratio) {
                    reject=true;
                    loop=false;
                    targetIter=k;
                    if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                      --targetIter;
                    }
                    hNew=optimalStep[targetIter];
                  }
                }
              }
            break;
case 0:
          if (error <= 1.0) {
            loop=false;
          }
 else {
            final double ratio=((double)sequence[k + 1]) / sequence[0];
            if (error > ratio * ratio) {
              reject=true;
              loop=false;
              if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                --targetIter;
              }
              hNew=optimalStep[targetIter];
            }
          }
        break;
case 1:
      if (error > 1.0) {
        reject=true;
        if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
          --targetIter;
        }
        hNew=optimalStep[targetIter];
      }
    loop=false;
  break;
default :
if ((firstTime || isLastStep) && (error <= 1.0)) {
  loop=false;
}
break;
}
}
}
}
}
if (!reject) {
computeDerivatives(stepStart + stepSize,y1,yDot1);
}
double hInt=getMaxStep();
if (denseOutput && !reject) {
for (int j=1; j <= k; ++j) {
extrapolate(0,j,diagonal,yMidDots[0]);
}
final int mu=2 * k - mudif + 3;
for (int l=0; l < mu; ++l) {
final int l2=l / 2;
double factor=FastMath.pow(0.5 * sequence[l2],l);
int middleIndex=fk[l2].length / 2;
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]=factor * fk[l2][middleIndex + l][i];
}
for (int j=1; j <= k - l2; ++j) {
factor=FastMath.pow(0.5 * sequence[j + l2],l);
middleIndex=fk[l2 + j].length / 2;
for (int i=0; i < y0.length; ++i) {
diagonal[j - 1][i]=factor * fk[l2 + j][middleIndex + l][i];
}
extrapolate(l2,j,diagonal,yMidDots[l + 1]);
}
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]*=stepSize;
}
for (int j=(l + 1) / 2; j <= k; ++j) {
for (int m=fk[j].length - 1; m >= 2 * (l + 1); --m) {
for (int i=0; i < y0.length; ++i) {
fk[j][m][i]-=fk[j][m - 2][i];
}
}
}
}
if (mu >= 0) {
final GraggBulirschStoerStepInterpolator gbsInterpolator=(GraggBulirschStoerStepInterpolator)interpolator;
gbsInterpolator.computeCoefficients(mu,stepSize);
if (useInterpolationError) {
final double interpError=gbsInterpolator.estimateError(scale);
hInt=FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError,1.0 / (mu + 4)),0.01));
if (interpError > 10.0) {
hNew=hInt;
reject=true;
}
}
}
}
if (!reject) {
interpolator.storeTime(stepStart + stepSize);
stepStart=acceptStep(interpolator,y1,yDot1,t);
interpolator.storeTime(stepStart);
System.arraycopy(y1,0,y,0,y0.length);
System.arraycopy(yDot1,0,yDot0,0,y0.length);
firstStepAlreadyComputed=true;
int optimalIter;
if (k == 1) {
optimalIter=2;
if (previousRejected) {
optimalIter=1;
}
}
 else if (k <= targetIter) {
optimalIter=k;
if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) {
optimalIter=k - 1;
}
 else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) {
optimalIter=FastMath.min(k + 1,sequence.length - 2);
}
}
 else {
optimalIter=k - 1;
if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) {
optimalIter=k - 2;
}
if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
optimalIter=FastMath.min(k,sequence.length - 2);
}
}
if (previousRejected) {
targetIter=FastMath.min(optimalIter,k);
hNew=FastMath.min(FastMath.abs(stepSize),optimalStep[targetIter]);
}
 else {
if (optimalIter <= k) {
hNew=optimalStep[optimalIter];
}
 else {
if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k],forward,false);
}
 else {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],forward,false);
}
}
targetIter=optimalIter;
}
newStep=true;
}
hNew=FastMath.min(hNew,hInt);
if (!forward) {
hNew=-hNew;
}
firstTime=false;
if (reject) {
isLastStep=false;
previousRejected=true;
}
 else {
previousRejected=false;
}
}
 while (!isLastStep);
final double stopTime=stepStart;
resetInternalState();
return stopTime;
}"
57331,"/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  final double[] yDotTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput()) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=forward ? step : -step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  statesInitialized=false;
  isLastStep=false;
  do {
    interpolator.shift();
    computeDerivatives(stepStart,y,yDotK[0]);
    for (int k=1; k < stages; ++k) {
      for (int j=0; j < y0.length; ++j) {
        double sum=a[k - 1][0] * yDotK[0][j];
        for (int l=1; l < k; ++l) {
          sum+=a[k - 1][l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
    }
    for (int j=0; j < y0.length; ++j) {
      double sum=b[0] * yDotK[0][j];
      for (int l=1; l < stages; ++l) {
        sum+=b[l] * yDotK[l][j];
      }
      yTmp[j]=y[j] + stepSize * sum;
    }
    interpolator.storeTime(stepStart + stepSize);
    System.arraycopy(yTmp,0,y,0,y0.length);
    System.arraycopy(yDotK[stages - 1],0,yDotTmp,0,y0.length);
    stepStart=acceptStep(interpolator,y,yDotTmp,t);
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      final double nextT=stepStart + stepSize;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      if (nextIsLast) {
        stepSize=t - stepStart;
      }
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws MathUserException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  final double[] yDotTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput()) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=forward ? step : -step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  setStateInitialized(false);
  isLastStep=false;
  do {
    interpolator.shift();
    computeDerivatives(stepStart,y,yDotK[0]);
    for (int k=1; k < stages; ++k) {
      for (int j=0; j < y0.length; ++j) {
        double sum=a[k - 1][0] * yDotK[0][j];
        for (int l=1; l < k; ++l) {
          sum+=a[k - 1][l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
    }
    for (int j=0; j < y0.length; ++j) {
      double sum=b[0] * yDotK[0][j];
      for (int l=1; l < stages; ++l) {
        sum+=b[l] * yDotK[l][j];
      }
      yTmp[j]=y[j] + stepSize * sum;
    }
    interpolator.storeTime(stepStart + stepSize);
    System.arraycopy(yTmp,0,y,0,y0.length);
    System.arraycopy(yDotK[stages - 1],0,yDotTmp,0,y0.length);
    stepStart=acceptStep(interpolator,y,yDotTmp,t);
    if (!isLastStep) {
      interpolator.storeTime(stepStart);
      final double nextT=stepStart + stepSize;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      if (nextIsLast) {
        stepSize=t - stepStart;
      }
    }
  }
 while (!isLastStep);
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}"
57332,"/** 
 * Get the previous soft grid point time.
 * @return previous soft grid point time
 * @see #setSoftBounds(double,double)
 */
public double getPreviousTime(){
  return softPreviousTime;
}","/** 
 * Get the previous soft grid point time.
 * @return previous soft grid point time
 * @see #setSoftPreviousTime(double)
 */
public double getPreviousTime(){
  return softPreviousTime;
}"
57333,"/** 
 * Get the current soft grid point time.
 * @return current soft grid point time
 * @see #setSoftBounds(double,double)
 */
public double getCurrentTime(){
  return softCurrentTime;
}","/** 
 * Get the current soft grid point time.
 * @return current soft grid point time
 * @see #setSoftCurrentTime(double)
 */
public double getCurrentTime(){
  return softCurrentTime;
}"
57334,"/** 
 * Internal helper method for natural logarithm function.
 * @param x original argument of the natural logarithm function
 * @param hiPrec extra bits of precision on output (To Be Confirmed)
 * @return log(x)
 */
private static double log(final double x,final double[] hiPrec){
  if (x == 0) {
    return Double.NEGATIVE_INFINITY;
  }
  long bits=Double.doubleToLongBits(x);
  if ((bits & 0x8000000000000000L) != 0 || x != x) {
    if (x != 0.0) {
      if (hiPrec != null) {
        hiPrec[0]=Double.NaN;
      }
      return Double.NaN;
    }
  }
  if (x == Double.POSITIVE_INFINITY) {
    if (hiPrec != null) {
      hiPrec[0]=Double.POSITIVE_INFINITY;
    }
    return Double.POSITIVE_INFINITY;
  }
  int exp=(int)(bits >> 52) - 1023;
  if ((bits & 0x7ff0000000000000L) == 0) {
    if (x == 0) {
      if (hiPrec != null) {
        hiPrec[0]=Double.NEGATIVE_INFINITY;
      }
      return Double.NEGATIVE_INFINITY;
    }
    bits<<=1;
    while ((bits & 0x0010000000000000L) == 0) {
      exp--;
      bits<<=1;
    }
  }
  if (exp == -1 || exp == 0) {
    if (x < 1.01 && x > 0.99 && hiPrec == null) {
      double xa=x - 1.0;
      double xb=xa - x + 1.0;
      double tmp=xa * HEX_40000000;
      double aa=xa + tmp - tmp;
      double ab=xa - aa;
      xa=aa;
      xb=ab;
      double ya=LN_QUICK_COEF[LN_QUICK_COEF.length - 1][0];
      double yb=LN_QUICK_COEF[LN_QUICK_COEF.length - 1][1];
      for (int i=LN_QUICK_COEF.length - 2; i >= 0; i--) {
        aa=ya * xa;
        ab=ya * xb + yb * xa + yb * xb;
        tmp=aa * HEX_40000000;
        ya=aa + tmp - tmp;
        yb=aa - ya + ab;
        aa=ya + LN_QUICK_COEF[i][0];
        ab=yb + LN_QUICK_COEF[i][1];
        tmp=aa * HEX_40000000;
        ya=aa + tmp - tmp;
        yb=aa - ya + ab;
      }
      aa=ya * xa;
      ab=ya * xb + yb * xa + yb * xb;
      tmp=aa * HEX_40000000;
      ya=aa + tmp - tmp;
      yb=aa - ya + ab;
      return ya + yb;
    }
  }
  double lnm[]=LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];
  double epsilon=(bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));
  double lnza=0.0;
  double lnzb=0.0;
  if (hiPrec != null) {
    double tmp=epsilon * HEX_40000000;
    double aa=epsilon + tmp - tmp;
    double ab=epsilon - aa;
    double xa=aa;
    double xb=ab;
    double numer=(bits & 0x3ffffffffffL);
    double denom=TWO_POWER_52 + (bits & 0x000ffc0000000000L);
    aa=numer - xa * denom - xb * denom;
    xb+=aa / denom;
    double ya=LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][0];
    double yb=LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][1];
    for (int i=LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
      aa=ya * xa;
      ab=ya * xb + yb * xa + yb * xb;
      tmp=aa * HEX_40000000;
      ya=aa + tmp - tmp;
      yb=aa - ya + ab;
      aa=ya + LN_HI_PREC_COEF[i][0];
      ab=yb + LN_HI_PREC_COEF[i][1];
      tmp=aa * HEX_40000000;
      ya=aa + tmp - tmp;
      yb=aa - ya + ab;
    }
    aa=ya * xa;
    ab=ya * xb + yb * xa + yb * xb;
    lnza=aa + ab;
    lnzb=-(lnza - aa - ab);
  }
 else {
    lnza=-0.16624882440418567;
    lnza=lnza * epsilon + 0.19999954120254515;
    lnza=lnza * epsilon + -0.2499999997677497;
    lnza=lnza * epsilon + 0.3333333333332802;
    lnza=lnza * epsilon + -0.5;
    lnza=lnza * epsilon + 1.0;
    lnza=lnza * epsilon;
  }
  double a=LN_2_A * exp;
  double b=0.0;
  double c=a + lnm[0];
  double d=-(c - a - lnm[0]);
  a=c;
  b=b + d;
  c=a + lnza;
  d=-(c - a - lnza);
  a=c;
  b=b + d;
  c=a + LN_2_B * exp;
  d=-(c - a - LN_2_B * exp);
  a=c;
  b=b + d;
  c=a + lnm[1];
  d=-(c - a - lnm[1]);
  a=c;
  b=b + d;
  c=a + lnzb;
  d=-(c - a - lnzb);
  a=c;
  b=b + d;
  if (hiPrec != null) {
    hiPrec[0]=a;
    hiPrec[1]=b;
  }
  return a + b;
}","/** 
 * Internal helper method for natural logarithm function.
 * @param x original argument of the natural logarithm function
 * @param hiPrec extra bits of precision on output (To Be Confirmed)
 * @return log(x)
 */
private static double log(final double x,final double[] hiPrec){
  if (x == 0) {
    return Double.NEGATIVE_INFINITY;
  }
  long bits=Double.doubleToLongBits(x);
  if ((bits & 0x8000000000000000L) != 0 || x != x) {
    if (x != 0.0) {
      if (hiPrec != null) {
        hiPrec[0]=Double.NaN;
      }
      return Double.NaN;
    }
  }
  if (x == Double.POSITIVE_INFINITY) {
    if (hiPrec != null) {
      hiPrec[0]=Double.POSITIVE_INFINITY;
    }
    return Double.POSITIVE_INFINITY;
  }
  int exp=(int)(bits >> 52) - 1023;
  if ((bits & 0x7ff0000000000000L) == 0) {
    if (x == 0) {
      if (hiPrec != null) {
        hiPrec[0]=Double.NEGATIVE_INFINITY;
      }
      return Double.NEGATIVE_INFINITY;
    }
    bits<<=1;
    while ((bits & 0x0010000000000000L) == 0) {
      exp--;
      bits<<=1;
    }
  }
  if (exp == -1 || exp == 0) {
    if (x < 1.01 && x > 0.99 && hiPrec == null) {
      double xa=x - 1.0;
      double xb=xa - x + 1.0;
      double tmp=xa * HEX_40000000;
      double aa=xa + tmp - tmp;
      double ab=xa - aa;
      xa=aa;
      xb=ab;
      double ya=LN_QUICK_COEF[LN_QUICK_COEF.length - 1][0];
      double yb=LN_QUICK_COEF[LN_QUICK_COEF.length - 1][1];
      for (int i=LN_QUICK_COEF.length - 2; i >= 0; i--) {
        aa=ya * xa;
        ab=ya * xb + yb * xa + yb * xb;
        tmp=aa * HEX_40000000;
        ya=aa + tmp - tmp;
        yb=aa - ya + ab;
        aa=ya + LN_QUICK_COEF[i][0];
        ab=yb + LN_QUICK_COEF[i][1];
        tmp=aa * HEX_40000000;
        ya=aa + tmp - tmp;
        yb=aa - ya + ab;
      }
      aa=ya * xa;
      ab=ya * xb + yb * xa + yb * xb;
      tmp=aa * HEX_40000000;
      ya=aa + tmp - tmp;
      yb=aa - ya + ab;
      return ya + yb;
    }
  }
  double lnm[]=LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];
  double epsilon=(bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));
  double lnza=0.0;
  double lnzb=0.0;
  if (hiPrec != null) {
    double tmp=epsilon * HEX_40000000;
    double aa=epsilon + tmp - tmp;
    double ab=epsilon - aa;
    double xa=aa;
    double xb=ab;
    double numer=bits & 0x3ffffffffffL;
    double denom=TWO_POWER_52 + (bits & 0x000ffc0000000000L);
    aa=numer - xa * denom - xb * denom;
    xb+=aa / denom;
    double ya=LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][0];
    double yb=LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1][1];
    for (int i=LN_HI_PREC_COEF.length - 2; i >= 0; i--) {
      aa=ya * xa;
      ab=ya * xb + yb * xa + yb * xb;
      tmp=aa * HEX_40000000;
      ya=aa + tmp - tmp;
      yb=aa - ya + ab;
      aa=ya + LN_HI_PREC_COEF[i][0];
      ab=yb + LN_HI_PREC_COEF[i][1];
      tmp=aa * HEX_40000000;
      ya=aa + tmp - tmp;
      yb=aa - ya + ab;
    }
    aa=ya * xa;
    ab=ya * xb + yb * xa + yb * xb;
    lnza=aa + ab;
    lnzb=-(lnza - aa - ab);
  }
 else {
    lnza=-0.16624882440418567;
    lnza=lnza * epsilon + 0.19999954120254515;
    lnza=lnza * epsilon + -0.2499999997677497;
    lnza=lnza * epsilon + 0.3333333333332802;
    lnza=lnza * epsilon + -0.5;
    lnza=lnza * epsilon + 1.0;
    lnza=lnza * epsilon;
  }
  double a=LN_2_A * exp;
  double b=0.0;
  double c=a + lnm[0];
  double d=-(c - a - lnm[0]);
  a=c;
  b=b + d;
  c=a + lnza;
  d=-(c - a - lnza);
  a=c;
  b=b + d;
  c=a + LN_2_B * exp;
  d=-(c - a - LN_2_B * exp);
  a=c;
  b=b + d;
  c=a + lnm[1];
  d=-(c - a - lnm[1]);
  a=c;
  b=b + d;
  c=a + lnzb;
  d=-(c - a - lnzb);
  a=c;
  b=b + d;
  if (hiPrec != null) {
    hiPrec[0]=a;
    hiPrec[1]=b;
  }
  return a + b;
}"
57335,"private static void reportError(String message){
  final boolean fatal=false;
  if (fatal) {
    Assert.fail(message);
  }
 else {
    System.out.println(message);
  }
}","private static void reportError(String message){
  final boolean fatal=true;
  if (fatal) {
    Assert.fail(message);
  }
 else {
    System.out.println(message);
  }
}"
57336,"/** 
 * Create a multi-start optimizer from a single-start optimizer.
 * @param optimizer Single-start optimizer to wrap.
 * @param starts Number of starts to perform (including thefirst one), multi-start is disabled if value is less than or equal to 1.
 * @param generator Random generator to use for restarts.
 */
public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer,final int starts,final RandomGenerator generator){
  this.optimizer=optimizer;
  this.starts=starts;
  this.generator=generator;
}","/** 
 * Create a multi-start optimizer from a single-start optimizer.
 * @param optimizer Single-start optimizer to wrap.
 * @param starts Number of starts to perform, must be >=1. Multi-start is disabled if  {@code starts == 1}.
 * @param generator Random generator to use for restarts.
 * @throws NullArgumentException if {@code optimizer} or {@code generator}is   {@code null}.
 * @throws NotStrictlyPositiveException if {@code starts < 1}.
 */
public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer,final int starts,final RandomGenerator generator){
  if (optimizer == null || generator == null) {
    throw new NullArgumentException();
  }
  if (starts < 1) {
    throw new NotStrictlyPositiveException(starts);
  }
  this.optimizer=optimizer;
  this.starts=starts;
  this.generator=generator;
}"
57337,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57338,"@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}"
57339,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57340,"/** 
 * {@inheritDoc}For first shape parameter <code>s1</code> and  second shape parameter <code>s2</code>,  the variance is <code>[ s1 * s2 ] / [ (s1 + s2)^2 * (s1 + s2 + 1) ]</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double alpha=getAlpha();
  final double beta=getBeta();
  final double alphabetasum=alpha + beta;
  return (alpha * beta) / ((alphabetasum * alphabetasum) * (alphabetasum + 1));
}","/** 
 * {@inheritDoc}For first shape parameter <code>s1</code> and  second shape parameter <code>s2</code>,  the variance is <code>[ s1 * s2 ] / [ (s1 + s2)^2 * (s1 + s2 + 1) ]</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double a=getAlpha();
  final double b=getBeta();
  final double alphabetasum=a + b;
  return (a * b) / ((alphabetasum * alphabetasum) * (alphabetasum + 1));
}"
57341,"/** 
 * {@inheritDoc}For first shape parameter <code>s1</code> and  second shape parameter <code>s2</code>, the mean is <code>s1 / (s1 + s2)</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalMean(){
  final double alpha=getAlpha();
  return alpha / (alpha + getBeta());
}","/** 
 * {@inheritDoc}For first shape parameter <code>s1</code> and  second shape parameter <code>s2</code>, the mean is <code>s1 / (s1 + s2)</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalMean(){
  final double a=getAlpha();
  return a / (a + getBeta());
}"
57342,"@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}"
57343,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57344,"/** 
 * {@inheritDoc}The variance is  <code>scale^2 * Gamma(1 + (2 / shape)) - mean^2</code>  where <code>Gamma(...)</code> is the Gamma-function
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double shape=getShape();
  final double scale=getScale();
  final double mean=getNumericalMean();
  return (scale * scale) * FastMath.exp(Gamma.logGamma(1 + (2 / shape))) - (mean * mean);
}","/** 
 * {@inheritDoc}The variance is  <code>scale^2 * Gamma(1 + (2 / shape)) - mean^2</code>  where <code>Gamma(...)</code> is the Gamma-function
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double sh=getShape();
  final double sc=getScale();
  final double mn=getNumericalMean();
  return (sc * sc) * FastMath.exp(Gamma.logGamma(1 + (2 / sh))) - (mn * mn);
}"
57345,"/** 
 * {@inheritDoc}The mean is <code>scale * Gamma(1 + (1 / shape))</code> where <code>Gamma(...)</code> is the Gamma-function
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalMean(){
  final double shape=getShape();
  final double scale=getScale();
  return scale * FastMath.exp(Gamma.logGamma(1 + (1 / shape)));
}","/** 
 * {@inheritDoc}The mean is <code>scale * Gamma(1 + (1 / shape))</code> where <code>Gamma(...)</code> is the Gamma-function
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalMean(){
  final double sh=getShape();
  final double sc=getScale();
  return sc * FastMath.exp(Gamma.logGamma(1 + (1 / sh)));
}"
57346,"@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}"
57347,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57348,"@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}"
57349,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57350,"@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}"
57351,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57352,"@Override public boolean isSupportUpperBoundInclusive(){
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return true;
}"
57353,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57354,"@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}"
57355,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57356,"/** 
 * {@inheritDoc}For mean parameter <code>k</code>, the variance is <code>k^2</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double mean=getMean();
  return mean * mean;
}","/** 
 * {@inheritDoc}For mean parameter <code>k</code>, the variance is <code>k^2</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double m=getMean();
  return m * m;
}"
57357,"@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}"
57358,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57359,"@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return false;
}"
57360,"@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportUpperBoundInclusive(){
  return false;
}"
57361,"/** 
 * {@inheritDoc}For shape parameter <code>alpha</code> and scale  parameter <code>beta</code>, the variance is <code>alpha * beta^2</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double beta=getBeta();
  return getAlpha() * beta * beta;
}","/** 
 * {@inheritDoc}For shape parameter <code>alpha</code> and scale  parameter <code>beta</code>, the variance is <code>alpha * beta^2</code>
 * @return {@inheritDoc}
 */
@Override protected double calculateNumericalVariance(){
  final double b=getBeta();
  return getAlpha() * b * b;
}"
57362,"@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isSupportLowerBoundInclusive(){
  return true;
}"
57363,"/** 
 * Create an   {@link java.lang.RuntimeException} for an internal error.
 * @param cause underlying cause
 * @return an {@link java.lang.RuntimeException} for an internal error
 */
public static RuntimeException createInternalError(final Throwable cause){
  final String argument=""String_Node_Str"";
  return new RuntimeException(){
    /** 
 * Serializable version identifier. 
 */
    private static final long serialVersionUID=-201865440834027016L;
    /** 
 * {@inheritDoc} 
 */
    @Override public String getMessage(){
      return buildMessage(Locale.US,LocalizedFormats.INTERNAL_ERROR,argument);
    }
    /** 
 * {@inheritDoc} 
 */
    @Override public String getLocalizedMessage(){
      return buildMessage(Locale.getDefault(),LocalizedFormats.INTERNAL_ERROR,argument);
    }
  }
;
}","/** 
 * Create an   {@link java.lang.RuntimeException} for an internal error.
 * @param cause underlying cause
 * @return an {@link java.lang.RuntimeException} for an internal error
 */
public static RuntimeException createInternalError(final Throwable cause){
  final String argument=""String_Node_Str"";
  return new RuntimeException(cause){
    /** 
 * Serializable version identifier. 
 */
    private static final long serialVersionUID=-201865440834027016L;
    /** 
 * {@inheritDoc} 
 */
    @Override public String getMessage(){
      return buildMessage(Locale.US,LocalizedFormats.INTERNAL_ERROR,argument);
    }
    /** 
 * {@inheritDoc} 
 */
    @Override public String getLocalizedMessage(){
      return buildMessage(Locale.getDefault(),LocalizedFormats.INTERNAL_ERROR,argument);
    }
  }
;
}"
57364,"/** 
 * Check if instance dimension is equal to some expected value.
 * @param n expected dimension.
 * @exception IllegalArgumentException if the dimension isinconsistent with vector size
 */
protected void checkVectorDimensions(int n) throws DimensionMismatchException {
  int d=getDimension();
  if (d != n) {
    throw new DimensionMismatchException(d,n);
  }
}","/** 
 * Check if instance dimension is equal to some expected value.
 * @param n expected dimension.
 * @throws DimensionMismatchException if the dimension isinconsistent with vector size
 */
protected void checkVectorDimensions(int n) throws DimensionMismatchException {
  int d=getDimension();
  if (d != n) {
    throw new DimensionMismatchException(d,n);
  }
}"
57365,"/** 
 * @param f Function to optimize.
 * @param goal Goal type ({@link GoalType#MINIMIZE} or{@link GoalType#MAXIMIZE}).
 * @param startPoint Start point.
 */
public RealPointValuePair optimize(final FUNC f,final GoalType goal,double[] startPoint) throws FunctionEvaluationException {
  optima=new RealPointValuePair[starts];
  for (int i=0; i < starts; ++i) {
    try {
      optima[i]=optimizer.optimize(f,goal,(i == 0 ? startPoint : generator.nextVector()));
    }
 catch (    FunctionEvaluationException fee) {
      optima[i]=null;
    }
catch (    ConvergenceException oe) {
      optima[i]=null;
    }
    final int usedEvaluations=optimizer.getEvaluations();
    optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
    totalEvaluations+=usedEvaluations;
  }
  sortPairs(goal);
  if (optima[0] == null) {
    throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,starts);
  }
  return optima[0];
}","/** 
 * {@inheritDoc}
 */
public RealPointValuePair optimize(final FUNC f,final GoalType goal,double[] startPoint) throws FunctionEvaluationException {
  optima=new RealPointValuePair[starts];
  for (int i=0; i < starts; ++i) {
    try {
      optima[i]=optimizer.optimize(f,goal,i == 0 ? startPoint : generator.nextVector());
    }
 catch (    FunctionEvaluationException fee) {
      optima[i]=null;
    }
catch (    ConvergenceException oe) {
      optima[i]=null;
    }
    final int usedEvaluations=optimizer.getEvaluations();
    optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
    totalEvaluations+=usedEvaluations;
  }
  sortPairs(goal);
  if (optima[0] == null) {
    throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,starts);
  }
  return optima[0];
}"
57366,"/** 
 * {@inheritDoc}
 */
public VectorialPointValuePair optimize(final FUNC f,double[] target,double[] weights,double[] startPoint) throws FunctionEvaluationException {
  optima=new VectorialPointValuePair[starts];
  for (int i=0; i < starts; ++i) {
    try {
      optima[i]=optimizer.optimize(f,target,weights,(i == 0 ? startPoint : generator.nextVector()));
    }
 catch (    FunctionEvaluationException fee) {
      optima[i]=null;
    }
catch (    ConvergenceException oe) {
      optima[i]=null;
    }
    final int usedEvaluations=optimizer.getEvaluations();
    optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
    totalEvaluations+=usedEvaluations;
  }
  sortPairs(target,weights);
  if (optima[0] == null) {
    throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,starts);
  }
  return optima[0];
}","/** 
 * {@inheritDoc}
 */
public VectorialPointValuePair optimize(final FUNC f,double[] target,double[] weights,double[] startPoint) throws FunctionEvaluationException {
  optima=new VectorialPointValuePair[starts];
  for (int i=0; i < starts; ++i) {
    try {
      optima[i]=optimizer.optimize(f,target,weights,i == 0 ? startPoint : generator.nextVector());
    }
 catch (    FunctionEvaluationException fee) {
      optima[i]=null;
    }
catch (    ConvergenceException oe) {
      optima[i]=null;
    }
    final int usedEvaluations=optimizer.getEvaluations();
    optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
    totalEvaluations+=usedEvaluations;
  }
  sortPairs(target,weights);
  if (optima[0] == null) {
    throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,starts);
  }
  return optima[0];
}"
57367,"/** 
 * Optimize an objective function.
 * @param f Objective function.
 * @param goalType Type of optimization goal: either{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.
 * @param startPoint Start point for optimization.
 * @return the point/value pair giving the optimal value for objectivefunction.
 * @throws FunctionEvaluationException if the objective function throws oneduring the search.
 * @throws DimensionMismatchException if the start point dimension is wrong.
 * @throws TooManyEvaluationsException if the maximal number of evaluations isexceeded.
 * @throws NullArgumentException if any argument is {@code null}.
 */
RealPointValuePair optimize(FUNC f,GoalType goalType,double[] startPoint) throws FunctionEvaluationException ;","/** 
 * Optimize an objective function.
 * @param f Objective function.
 * @param goalType Type of optimization goal: either{@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}.
 * @param startPoint Start point for optimization.
 * @return the point/value pair giving the optimal value for objectivefunction.
 * @throws org.apache.commons.math.FunctionEvaluationException if theobjective function throws one during the search.
 * @throws org.apache.commons.math.exception.DimensionMismatchException if the start point dimension is wrong.
 * @throws org.apache.commons.math.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.
 * @throws org.apache.commons.math.exception.NullArgumentException ifany argument is  {@code null}.
 */
RealPointValuePair optimize(FUNC f,GoalType goalType,double[] startPoint) throws FunctionEvaluationException ;"
57368,"/** 
 * Optimize an objective function. Optimization is considered to be a weighted least-squares minimization. The cost function to be minimized is <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>
 * @param f Objective function.
 * @param target Target value for the objective functions at optimum.
 * @param weight Weights for the least squares cost computation.
 * @param startPoint Start point for optimization.
 * @return the point/value pair giving the optimal value for objectivefunction.
 * @throws FunctionEvaluationException if the objective function throws oneduring the search.
 * @throws DimensionMismatchException if the start point dimension is wrong.
 * @throws TooManyEvaluationsException if the maximal number of evaluations isexceeded.
 * @throws NullArgumentException if any argument is {@code null}.
 */
VectorialPointValuePair optimize(FUNC f,double[] target,double[] weight,double[] startPoint) throws FunctionEvaluationException ;","/** 
 * Optimize an objective function. Optimization is considered to be a weighted least-squares minimization. The cost function to be minimized is <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>
 * @param f Objective function.
 * @param target Target value for the objective functions at optimum.
 * @param weight Weights for the least squares cost computation.
 * @param startPoint Start point for optimization.
 * @return the point/value pair giving the optimal value for objectivefunction.
 * @throws FunctionEvaluationException if the objective function throws oneduring the search.
 * @throws org.apache.commons.math.exception.DimensionMismatchException if the start point dimension is wrong.
 * @throws org.apache.commons.math.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.
 * @throws org.apache.commons.math.exception.NullArgumentException ifany argument is  {@code null}.
 */
VectorialPointValuePair optimize(FUNC f,double[] target,double[] weight,double[] startPoint) throws FunctionEvaluationException ;"
57369,"/** 
 * Check if the optimization algorithm has converged considering the last two points. This method may be called several time from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.
 * @param iteration Index of current iteration
 * @param previous Best point in the previous iteration.
 * @param current Best point in the current iteration.
 * @return {@code true} if the algorithm has converged.
 */
public boolean converged(final int iteration,final RealPointValuePair previous,final RealPointValuePair current){
  final double p=previous.getValue();
  final double c=current.getValue();
  final double difference=FastMath.abs(p - c);
  final double size=FastMath.max(FastMath.abs(p),FastMath.abs(c));
  return (difference <= size * getRelativeThreshold() || difference <= getAbsoluteThreshold());
}","/** 
 * Check if the optimization algorithm has converged considering the last two points. This method may be called several time from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.
 * @param iteration Index of current iteration
 * @param previous Best point in the previous iteration.
 * @param current Best point in the current iteration.
 * @return {@code true} if the algorithm has converged.
 */
public boolean converged(final int iteration,final RealPointValuePair previous,final RealPointValuePair current){
  final double p=previous.getValue();
  final double c=current.getValue();
  final double difference=FastMath.abs(p - c);
  final double size=FastMath.max(FastMath.abs(p),FastMath.abs(c));
  return difference <= size * getRelativeThreshold() || difference <= getAbsoluteThreshold();
}"
57370,"/** 
 * Evaluate all the non-evaluated points of the simplex.
 * @param comparator Comparator to use to sort simplex vertices from best to worst.
 * @throws FunctionEvaluationException if no value can be computed for the parameters.
 * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.
 */
protected void evaluateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException {
  for (int i=0; i < simplex.length; ++i) {
    final RealPointValuePair vertex=simplex[i];
    final double[] point=vertex.getPointRef();
    if (Double.isNaN(vertex.getValue())) {
      simplex[i]=new RealPointValuePair(point,computeObjectiveValue(point),false);
    }
  }
  Arrays.sort(simplex,comparator);
}","/** 
 * Evaluate all the non-evaluated points of the simplex.
 * @param comparator Comparator to use to sort simplex vertices from best to worst.
 * @throws FunctionEvaluationException if no value can be computed for the parameters.
 * @throws org.apache.commons.math.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.
 */
protected void evaluateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException {
  for (int i=0; i < simplex.length; ++i) {
    final RealPointValuePair vertex=simplex[i];
    final double[] point=vertex.getPointRef();
    if (Double.isNaN(vertex.getValue())) {
      simplex[i]=new RealPointValuePair(point,computeObjectiveValue(point),false);
    }
  }
  Arrays.sort(simplex,comparator);
}"
57371,"/** 
 * {@inheritDoc} 
 */
protected RealPointValuePair doOptimize() throws FunctionEvaluationException {
  final double[] startPoint=getStartPoint();
  if ((startConfiguration == null) || (startConfiguration.length != startPoint.length)) {
    final double[] unit=new double[startPoint.length];
    Arrays.fill(unit,1.0);
    setStartConfiguration(unit);
  }
  final boolean isMinim=(getGoalType() == GoalType.MINIMIZE);
  final Comparator<RealPointValuePair> comparator=new Comparator<RealPointValuePair>(){
    public int compare(    final RealPointValuePair o1,    final RealPointValuePair o2){
      final double v1=o1.getValue();
      final double v2=o2.getValue();
      return isMinim ? Double.compare(v1,v2) : Double.compare(v2,v1);
    }
  }
;
  buildSimplex(startPoint);
  evaluateSimplex(comparator);
  RealPointValuePair[] previous=new RealPointValuePair[simplex.length];
  int iteration=0;
  final ConvergenceChecker<RealPointValuePair> checker=getConvergenceChecker();
  while (true) {
    if (iteration > 0) {
      boolean converged=true;
      for (int i=0; i < simplex.length; ++i) {
        converged&=checker.converged(iteration,previous[i],simplex[i]);
      }
      if (converged) {
        return simplex[0];
      }
    }
    System.arraycopy(simplex,0,previous,0,simplex.length);
    iterateSimplex(comparator);
    ++iteration;
  }
}","/** 
 * {@inheritDoc} 
 */
protected RealPointValuePair doOptimize() throws FunctionEvaluationException {
  final double[] startPoint=getStartPoint();
  if ((startConfiguration == null) || (startConfiguration.length != startPoint.length)) {
    final double[] unit=new double[startPoint.length];
    Arrays.fill(unit,1.0);
    setStartConfiguration(unit);
  }
  final boolean isMinim=getGoalType() == GoalType.MINIMIZE;
  final Comparator<RealPointValuePair> comparator=new Comparator<RealPointValuePair>(){
    public int compare(    final RealPointValuePair o1,    final RealPointValuePair o2){
      final double v1=o1.getValue();
      final double v2=o2.getValue();
      return isMinim ? Double.compare(v1,v2) : Double.compare(v2,v1);
    }
  }
;
  buildSimplex(startPoint);
  evaluateSimplex(comparator);
  RealPointValuePair[] previous=new RealPointValuePair[simplex.length];
  int iteration=0;
  final ConvergenceChecker<RealPointValuePair> checker=getConvergenceChecker();
  while (true) {
    if (iteration > 0) {
      boolean converged=true;
      for (int i=0; i < simplex.length; ++i) {
        converged&=checker.converged(iteration,previous[i],simplex[i]);
      }
      if (converged) {
        return simplex[0];
      }
    }
    System.arraycopy(simplex,0,previous,0,simplex.length);
    iterateSimplex(comparator);
    ++iteration;
  }
}"
57372,"/** 
 * Compute the next simplex of the algorithm.
 * @param comparator Comparator to use to sort simplex vertices from best to worst.
 * @throws FunctionEvaluationException if the function cannot be evaluated atsome point.
 * @throws TooManyEvaluationsException if the algorithm fails to converge.
 * @throws DimensionMismatchException if the start point dimension is wrong.
 */
protected abstract void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException ;","/** 
 * Compute the next simplex of the algorithm.
 * @param comparator Comparator to use to sort simplex vertices from best to worst.
 * @throws FunctionEvaluationException if the function cannot be evaluated atsome point.
 * @throws org.apache.commons.math.exception.TooManyEvaluationsException ifthe algorithm fails to converge.
 * @throws org.apache.commons.math.exception.DimensionMismatchException ifthe start point dimension is wrong.
 */
protected abstract void iterateSimplex(final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException ;"
57373,"/** 
 * Compute and evaluate a new simplex.
 * @param original Original simplex (to be preserved).
 * @param coeff Linear coefficient.
 * @param comparator Comparator to use to sort simplex vertices from bestto poorest.
 * @return the best point in the transformed simplex.
 * @exception FunctionEvaluationException if the function cannot beevaluated at some point.
 * @exception TooManyEvaluationsException if the maximal number ofevaluations is exceeded.
 */
private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,final double coeff,final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException {
  final double[] xSmallest=original[0].getPointRef();
  final int n=xSmallest.length;
  simplex=new RealPointValuePair[n + 1];
  simplex[0]=original[0];
  for (int i=1; i <= n; ++i) {
    final double[] xOriginal=original[i].getPointRef();
    final double[] xTransformed=new double[n];
    for (int j=0; j < n; ++j) {
      xTransformed[j]=xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
    }
    simplex[i]=new RealPointValuePair(xTransformed,Double.NaN,false);
  }
  evaluateSimplex(comparator);
  return simplex[0];
}","/** 
 * Compute and evaluate a new simplex.
 * @param original Original simplex (to be preserved).
 * @param coeff Linear coefficient.
 * @param comparator Comparator to use to sort simplex vertices from bestto poorest.
 * @return the best point in the transformed simplex.
 * @throws FunctionEvaluationException if the function cannot beevaluated at some point.
 * @throws org.apache.commons.math.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded.
 */
private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,final double coeff,final Comparator<RealPointValuePair> comparator) throws FunctionEvaluationException {
  final double[] xSmallest=original[0].getPointRef();
  final int n=xSmallest.length;
  simplex=new RealPointValuePair[n + 1];
  simplex[0]=original[0];
  for (int i=1; i <= n; ++i) {
    final double[] xOriginal=original[i].getPointRef();
    final double[] xTransformed=new double[n];
    for (int j=0; j < n; ++j) {
      xTransformed[j]=xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);
    }
    simplex[i]=new RealPointValuePair(xTransformed,Double.NaN,false);
  }
  evaluateSimplex(comparator);
  return simplex[0];
}"
57374,"/** 
 * Fit a curve. <p>This method compute the coefficients of the curve that best fit the sample of observed points previously given through calls to the   {@link #addObservedPoint(WeightedObservedPoint) addObservedPoint} method.</p>
 * @param f parametric function to fit
 * @param initialGuess first guess of the function parameters
 * @return fitted parameters
 * @exception FunctionEvaluationException if the objective function throws one duringthe search
 * @exception ConvergenceException if the algorithm failed to converge
 * @exception IllegalArgumentException if the start point dimension is wrong.
 */
public double[] fit(final ParametricRealFunction f,final double[] initialGuess) throws FunctionEvaluationException {
  double[] target=new double[observations.size()];
  double[] weights=new double[observations.size()];
  int i=0;
  for (  WeightedObservedPoint point : observations) {
    target[i]=point.getY();
    weights[i]=point.getWeight();
    ++i;
  }
  VectorialPointValuePair optimum=optimizer.optimize(new TheoreticalValuesFunction(f),target,weights,initialGuess);
  return optimum.getPointRef();
}","/** 
 * Fit a curve. <p>This method compute the coefficients of the curve that best fit the sample of observed points previously given through calls to the   {@link #addObservedPoint(WeightedObservedPoint) addObservedPoint} method.</p>
 * @param f parametric function to fit
 * @param initialGuess first guess of the function parameters
 * @return fitted parameters
 * @exception FunctionEvaluationException if the objective function throws one duringthe search
 * @exception org.apache.commons.math.exception.ConvergenceException if the algorithm failed to converge.
 * @exception org.apache.commons.math.exception.DimensionMismatchException if the start point dimension is wrong.
 */
public double[] fit(final ParametricRealFunction f,final double[] initialGuess) throws FunctionEvaluationException {
  double[] target=new double[observations.size()];
  double[] weights=new double[observations.size()];
  int i=0;
  for (  WeightedObservedPoint point : observations) {
    target[i]=point.getY();
    weights[i]=point.getWeight();
    ++i;
  }
  VectorialPointValuePair optimum=optimizer.optimize(new TheoreticalValuesFunction(f),target,weights,initialGuess);
  return optimum.getPointRef();
}"
57375,"/** 
 * Get the polynomial fitting the weighted (x, y) points.
 * @return polynomial function best fitting the observed points
 * @exception ConvergenceException if the algorithm failed to converge
 */
public PolynomialFunction fit(){
  try {
    return new PolynomialFunction(fitter.fit(new ParametricPolynomial(),new double[degree + 1]));
  }
 catch (  FunctionEvaluationException fee) {
    throw MathRuntimeException.createInternalError(fee);
  }
}","/** 
 * Get the polynomial fitting the weighted (x, y) points.
 * @return polynomial function best fitting the observed points
 * @throws org.apache.commons.math.exception.ConvergenceException if the algorithm failed to converge.
 */
public PolynomialFunction fit(){
  try {
    return new PolynomialFunction(fitter.fit(new ParametricPolynomial(),new double[degree + 1]));
  }
 catch (  FunctionEvaluationException fee) {
    throw MathRuntimeException.createInternalError(fee);
  }
}"
57376,"/** 
 * Compute the gradient vector.
 * @param evaluationPoint Point at which the gradient must be evaluated.
 * @return the gradient at the specified point.
 * @throws FunctionEvaluationException if the function gradient cannot beevaluated.
 * @throws TooManyEvaluationsException if the allowed number of evaluationsis exceeded.
 */
protected double[] computeObjectiveGradient(final double[] evaluationPoint) throws FunctionEvaluationException {
  return gradient.value(evaluationPoint);
}","/** 
 * Compute the gradient vector.
 * @param evaluationPoint Point at which the gradient must be evaluated.
 * @return the gradient at the specified point.
 * @throws FunctionEvaluationException if the function gradient cannot beevaluated.
 * @throws org.apache.commons.math.exception.TooManyEvaluationsException if the allowed number of evaluations is exceeded.
 */
protected double[] computeObjectiveGradient(final double[] evaluationPoint) throws FunctionEvaluationException {
  return gradient.value(evaluationPoint);
}"
57377,"/** 
 * Compute this minus v.
 * @param v vector to be subtracted
 * @return this + v
 * @throws IllegalArgumentException if v is not the same size as this
 */
RealVector subtract(double[] v) throws IllegalArgumentException ;","/** 
 * Compute this minus v.
 * @param v vector to be subtracted
 * @return this - v
 * @throws IllegalArgumentException if v is not the same size as this
 */
RealVector subtract(double[] v) throws IllegalArgumentException ;"
57378,"/** 
 * {@inheritDoc} 
 */
public double optimize(final UnivariateRealFunction f,final GoalType goalType,final double min,final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
  clearResult();
  return localMin(f,goalType,min,max,relativeAccuracy,absoluteAccuracy);
}","/** 
 * {@inheritDoc} 
 */
public double optimize(final UnivariateRealFunction f,final GoalType goalType,final double min,final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
  return optimize(f,goalType,min,max,min + GOLDEN_SECTION * (max - min));
}"
57379,"/** 
 * Find the minimum of the function   {@code f} within the interval {@code (a, b)}. If the function   {@code f} is defined on the interval {@code (a, b)}, then this method finds an approximation   {@code x} to the point at which {@code f}attains its minimum.<br/>  {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and{@code f} is never evaluated at two points closer together than {@code tol}.  {@code eps} should be no smaller than <em>2 macheps</em> and preferable notmuch less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative machine precision.  {@code t} should be positive.
 * @param f the function to solve
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or   {@link GoalType#MINIMIZE}
 * @param a Lower bound of the interval
 * @param b Higher bound of the interval
 * @param eps Relative accuracy
 * @param t Absolute accuracy
 * @return the point at which the function is minimal.
 * @throws MaxIterationsExceededException if the maximum iteration countis exceeded.
 * @throws FunctionEvaluationException if an error occurs evaluatingthe function.
 */
private double localMin(final UnivariateRealFunction f,final GoalType goalType,double a,double b,final double eps,final double t) throws MaxIterationsExceededException, FunctionEvaluationException {
  double x=a + GOLDEN_SECTION * (b - a);
  double v=x;
  double w=x;
  double e=0;
  double fx=computeObjectiveValue(f,x);
  if (goalType == GoalType.MAXIMIZE) {
    fx=-fx;
  }
  double fv=fx;
  double fw=fx;
  int count=0;
  while (count < maximalIterationCount) {
    double m=0.5 * (a + b);
    double tol=eps * Math.abs(x) + t;
    double t2=2 * tol;
    if (Math.abs(x - m) > t2 - 0.5 * (b - a)) {
      double p=0;
      double q=0;
      double r=0;
      double d=0;
      double u=0;
      if (Math.abs(e) > tol) {
        r=(x - w) * (fx - fv);
        q=(x - v) * (fx - fw);
        p=(x - v) * q - (x - w) * r;
        q=2 * (q - r);
        if (q > 0) {
          p=-p;
        }
 else {
          q=-q;
        }
        r=e;
        e=d;
      }
      if (Math.abs(p) < Math.abs(0.5 * q * r) && (p < q * (a - x)) && (p < q * (b - x))) {
        d=p / q;
        u=x + d;
        if (((u - a) < t2) || ((b - u) < t2)) {
          d=(x < m) ? tol : -tol;
        }
      }
 else {
        e=((x < m) ? b : a) - x;
        d=GOLDEN_SECTION * e;
      }
      u=x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));
      double fu=computeObjectiveValue(f,u);
      if (goalType == GoalType.MAXIMIZE) {
        fu=-fu;
      }
      if (fu <= fx) {
        if (u < x) {
          b=x;
        }
 else {
          a=x;
        }
        v=w;
        fv=fw;
        w=x;
        fw=fx;
        x=u;
        fx=fu;
      }
 else {
        if (u < x) {
          a=u;
        }
 else {
          b=u;
        }
        if ((fu <= fw) || (w == x)) {
          v=w;
          fv=fw;
          w=u;
          fw=fu;
        }
 else         if ((fu <= fv) || (v == x) || (v == w)) {
          v=u;
          fv=fu;
        }
      }
    }
 else {
      setResult(x,(goalType == GoalType.MAXIMIZE) ? -fx : fx,count);
      return x;
    }
    ++count;
  }
  throw new MaxIterationsExceededException(maximalIterationCount);
}","/** 
 * Find the minimum of the function   {@code f} within the interval {@code (a, b)}. If the function   {@code f} is defined on the interval {@code (a, b)}, then this method finds an approximation   {@code x} to the point at which {@code f}attains its minimum.<br/>  {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and{@code f} is never evaluated at two points closer together than {@code tol}.  {@code eps} should be no smaller than <em>2 macheps</em> and preferable notmuch less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative machine precision.  {@code t} should be positive.
 * @param f the function to solve.
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or   {@link GoalType#MINIMIZE}.
 * @param lo Lower bound of the interval.
 * @param mid Point inside the interval {@code [lo, hi]}.
 * @param hi Higher bound of the interval.
 * @param eps Relative accuracy.
 * @param t Absolute accuracy.
 * @return the optimum point.
 * @throws MaxIterationsExceededException if the maximum iteration countis exceeded.
 * @throws FunctionEvaluationException if an error occurs evaluatingthe function.
 */
private double localMin(UnivariateRealFunction f,GoalType goalType,double lo,double mid,double hi,double eps,double t) throws MaxIterationsExceededException, FunctionEvaluationException {
  if (eps <= 0) {
    throw new NotStrictlyPositiveException(eps);
  }
  if (t <= 0) {
    throw new NotStrictlyPositiveException(t);
  }
  double a, b;
  if (lo < hi) {
    a=lo;
    b=hi;
  }
 else {
    a=hi;
    b=lo;
  }
  double x=mid;
  double v=x;
  double w=x;
  double e=0;
  double fx=computeObjectiveValue(f,x);
  if (goalType == GoalType.MAXIMIZE) {
    fx=-fx;
  }
  double fv=fx;
  double fw=fx;
  int count=0;
  while (count < maximalIterationCount) {
    double m=0.5 * (a + b);
    final double tol1=eps * Math.abs(x) + t;
    final double tol2=2 * tol1;
    if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
      double p=0;
      double q=0;
      double r=0;
      double d=0;
      double u=0;
      if (Math.abs(e) > tol1) {
        r=(x - w) * (fx - fv);
        q=(x - v) * (fx - fw);
        p=(x - v) * q - (x - w) * r;
        q=2 * (q - r);
        if (q > 0) {
          p=-p;
        }
 else {
          q=-q;
        }
        r=e;
        e=d;
        if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {
          d=p / q;
          u=x + d;
          if (u - a < tol2 || b - u < tol2) {
            if (x <= m) {
              d=tol1;
            }
 else {
              d=-tol1;
            }
          }
        }
 else {
          if (x < m) {
            e=b - x;
          }
 else {
            e=a - x;
          }
          d=GOLDEN_SECTION * e;
        }
      }
 else {
        if (x < m) {
          e=b - x;
        }
 else {
          e=a - x;
        }
        d=GOLDEN_SECTION * e;
      }
      if (Math.abs(d) < tol1) {
        if (d >= 0) {
          u=x + tol1;
        }
 else {
          u=x - tol1;
        }
      }
 else {
        u=x + d;
      }
      double fu=computeObjectiveValue(f,u);
      if (goalType == GoalType.MAXIMIZE) {
        fu=-fu;
      }
      if (fu <= fx) {
        if (u < x) {
          b=x;
        }
 else {
          a=x;
        }
        v=w;
        fv=fw;
        w=x;
        fw=fx;
        x=u;
        fx=fu;
      }
 else {
        if (u < x) {
          a=u;
        }
 else {
          b=u;
        }
        if (fu <= fw || w == x) {
          v=w;
          fv=fw;
          w=u;
          fw=fu;
        }
 else         if (fu <= fv || v == x || v == w) {
          v=u;
          fv=fu;
        }
      }
    }
 else {
      setResult(x,(goalType == GoalType.MAXIMIZE) ? -fx : fx,count);
      return x;
    }
    ++count;
  }
  throw new MaxIterationsExceededException(maximalIterationCount);
}"
57380,"/** 
 * Decompose a matrix A as A.P = Q.R using Householder transforms. <p>As suggested in the P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing the Householder transforms with u<sub>k</sub> unit vectors such that: <pre> H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup> </pre> we use <sub>k</sub> non-unit vectors such that: <pre> H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup> </pre> where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>. The beta<sub>k</sub> coefficients are provided upon exit as recomputing them from the v<sub>k</sub> vectors would be costly.</p> <p>This decomposition handles rank deficient cases since the tranformations are performed in non-increasing columns norms order thanks to columns pivoting. The diagonal elements of the R matrix are therefore also in non-increasing absolute values order.</p>
 * @exception OptimizationException if the decomposition cannot be performed
 */
private void qrDecomposition() throws OptimizationException {
  for (int k=0; k < cols; ++k) {
    permutation[k]=k;
    double norm2=0;
    for (int i=0; i < jacobian.length; ++i) {
      double akk=jacobian[i][k];
      norm2+=akk * akk;
    }
    jacNorm[k]=Math.sqrt(norm2);
  }
  for (int k=0; k < cols; ++k) {
    int nextColumn=-1;
    double ak2=Double.NEGATIVE_INFINITY;
    for (int i=k; i < cols; ++i) {
      double norm2=0;
      for (int j=k; j < jacobian.length; ++j) {
        double aki=jacobian[j][permutation[i]];
        norm2+=aki * aki;
      }
      if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {
        throw new OptimizationException(""String_Node_Str"",rows,cols);
      }
      if (norm2 > ak2) {
        nextColumn=i;
        ak2=norm2;
      }
    }
    if (ak2 == 0) {
      rank=k;
      return;
    }
    int pk=permutation[nextColumn];
    permutation[nextColumn]=permutation[k];
    permutation[k]=pk;
    double akk=jacobian[k][pk];
    double alpha=(akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);
    double betak=1.0 / (ak2 - akk * alpha);
    beta[pk]=betak;
    diagR[pk]=alpha;
    jacobian[k][pk]-=alpha;
    for (int dk=cols - 1 - k; dk > 0; --dk) {
      double gamma=0;
      for (int j=k; j < jacobian.length; ++j) {
        gamma+=jacobian[j][pk] * jacobian[j][permutation[k + dk]];
      }
      gamma*=betak;
      for (int j=k; j < jacobian.length; ++j) {
        jacobian[j][permutation[k + dk]]-=gamma * jacobian[j][pk];
      }
    }
  }
  rank=solvedCols;
}","/** 
 * Decompose a matrix A as A.P = Q.R using Householder transforms. <p>As suggested in the P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing the Householder transforms with u<sub>k</sub> unit vectors such that: <pre> H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup> </pre> we use <sub>k</sub> non-unit vectors such that: <pre> H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup> </pre> where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>. The beta<sub>k</sub> coefficients are provided upon exit as recomputing them from the v<sub>k</sub> vectors would be costly.</p> <p>This decomposition handles rank deficient cases since the tranformations are performed in non-increasing columns norms order thanks to columns pivoting. The diagonal elements of the R matrix are therefore also in non-increasing absolute values order.</p>
 * @exception OptimizationException if the decomposition cannot be performed
 */
private void qrDecomposition() throws OptimizationException {
  for (int k=0; k < cols; ++k) {
    permutation[k]=k;
    double norm2=0;
    for (int i=0; i < jacobian.length; ++i) {
      double akk=jacobian[i][k];
      norm2+=akk * akk;
    }
    jacNorm[k]=Math.sqrt(norm2);
  }
  for (int k=0; k < cols; ++k) {
    int nextColumn=-1;
    double ak2=Double.NEGATIVE_INFINITY;
    for (int i=k; i < cols; ++i) {
      double norm2=0;
      for (int j=k; j < jacobian.length; ++j) {
        double aki=jacobian[j][permutation[i]];
        norm2+=aki * aki;
      }
      if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {
        throw new OptimizationException(""String_Node_Str"",rows,cols);
      }
      if (norm2 > ak2) {
        nextColumn=i;
        ak2=norm2;
      }
    }
    if (ak2 < 1.0e-66) {
      rank=k;
      return;
    }
    int pk=permutation[nextColumn];
    permutation[nextColumn]=permutation[k];
    permutation[k]=pk;
    double akk=jacobian[k][pk];
    double alpha=(akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);
    double betak=1.0 / (ak2 - akk * alpha);
    beta[pk]=betak;
    diagR[pk]=alpha;
    jacobian[k][pk]-=alpha;
    for (int dk=cols - 1 - k; dk > 0; --dk) {
      double gamma=0;
      for (int j=k; j < jacobian.length; ++j) {
        gamma+=jacobian[j][pk] * jacobian[j][permutation[k + dk]];
      }
      gamma*=betak;
      for (int j=k; j < jacobian.length; ++j) {
        jacobian[j][permutation[k + dk]]-=gamma * jacobian[j][pk];
      }
    }
  }
  rank=solvedCols;
}"
57381,"/** 
 * For this distribution, X, this method returns P(X &lt; <code>x</code>).
 * @param x the value at which the CDF is evaluated.
 * @return CDF evaluted at <code>x</code>.
 * @throws MathException if the cumulative probability can not becomputed due to convergence or other numerical errors.
 */
public double cumulativeProbability(double x) throws MathException {
  double ret;
  if (x == 0.0) {
    ret=0.5;
  }
 else {
    double t=Beta.regularizedBeta(degreesOfFreedom / (degreesOfFreedom + (x * x)),0.5 * degreesOfFreedom,0.5);
    if (x < 0.0) {
      ret=0.5 * t;
    }
 else {
      ret=1.0 - 0.5 * t;
    }
  }
  return ret;
}","/** 
 * For this distribution, X, this method returns P(X &lt; <code>x</code>).
 * @param x the value at which the CDF is evaluated.
 * @return CDF evaluated at <code>x</code>.
 * @throws MathException if the cumulative probability can not becomputed due to convergence or other numerical errors.
 */
public double cumulativeProbability(double x) throws MathException {
  double ret;
  if (x == 0.0) {
    ret=0.5;
  }
 else {
    double t=Beta.regularizedBeta(degreesOfFreedom / (degreesOfFreedom + (x * x)),0.5 * degreesOfFreedom,0.5);
    if (x < 0.0) {
      ret=0.5 * t;
    }
 else {
      ret=1.0 - 0.5 * t;
    }
  }
  return ret;
}"
57382,"/** 
 * Returns a matrix of p-values associated with the (two-sided) null hypothesis that the corresponding correlation coefficient is zero. <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability that a random variable distributed as <code>t<sub>n-2</sub></code> takes a value with absolute value greater than or equal to <br> <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p> <p>The values in the matrix are sometimes referred to as the <i>significance</i> of the corresponding correlation coefficients.</p>
 * @return matrix of p-values
 * @throws MathException if an error occurs estimating probabilities
 */
public RealMatrix getCorrelationPValues() throws MathException {
  TDistribution tDistribution=new TDistributionImpl(nObs - 2);
  int nVars=correlationMatrix.getColumnDimension();
  double[][] out=new double[nVars][nVars];
  for (int i=0; i < nVars; i++) {
    for (int j=0; j < nVars; j++) {
      if (i == j) {
        out[i][j]=0d;
      }
 else {
        double r=correlationMatrix.getEntry(i,j);
        double t=Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
        out[i][j]=2 * (1 - tDistribution.cumulativeProbability(t));
      }
    }
  }
  return new BlockRealMatrix(out);
}","/** 
 * Returns a matrix of p-values associated with the (two-sided) null hypothesis that the corresponding correlation coefficient is zero. <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability that a random variable distributed as <code>t<sub>n-2</sub></code> takes a value with absolute value greater than or equal to <br> <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p> <p>The values in the matrix are sometimes referred to as the <i>significance</i> of the corresponding correlation coefficients.</p>
 * @return matrix of p-values
 * @throws MathException if an error occurs estimating probabilities
 */
public RealMatrix getCorrelationPValues() throws MathException {
  TDistribution tDistribution=new TDistributionImpl(nObs - 2);
  int nVars=correlationMatrix.getColumnDimension();
  double[][] out=new double[nVars][nVars];
  for (int i=0; i < nVars; i++) {
    for (int j=0; j < nVars; j++) {
      if (i == j) {
        out[i][j]=0d;
      }
 else {
        double r=correlationMatrix.getEntry(i,j);
        double t=Math.abs(r * Math.sqrt((nObs - 2) / (1 - r * r)));
        out[i][j]=2 * tDistribution.cumulativeProbability(-t);
      }
    }
  }
  return new BlockRealMatrix(out);
}"
57383,"/** 
 * Advance an entry up to the next non null one.
 * @param e entry to advance
 */
protected void advance(EntryImpl e){
  if (e == null) {
    return;
  }
  do {
    e.setIndex(e.getIndex() + 1);
  }
 while (e.getIndex() < dim && e.getValue() == 0);
  if (e.getIndex() >= dim) {
    e.setIndex(-1);
  }
}","/** 
 * Advance an entry up to the next nonzero one.
 * @param e entry to advance
 */
protected void advance(EntryImpl e){
  if (e == null) {
    return;
  }
  do {
    e.setIndex(e.getIndex() + 1);
  }
 while (e.getIndex() < dim && e.getValue() == 0);
  if (e.getIndex() >= dim) {
    e.setIndex(-1);
  }
}"
57384,"/** 
 * {@inheritDoc} 
 */
public boolean hasNext(){
  return current != null;
}","/** 
 * {@inheritDoc} 
 */
public boolean hasNext(){
  return next.getIndex() >= 0;
}"
57385,"/** 
 * Simple constructor. 
 */
protected SparseEntryIterator(){
  dim=getDimension();
  current=new EntryImpl();
  if (current.getValue() == 0) {
    advance(current);
  }
  if (current.getIndex() >= 0) {
    next=new EntryImpl();
    next.setIndex(current.getIndex());
    advance(next);
  }
 else {
    current=null;
  }
}","/** 
 * Simple constructor. 
 */
protected SparseEntryIterator(){
  dim=getDimension();
  current=new EntryImpl();
  next=new EntryImpl();
  if (next.getValue() == 0) {
    advance(next);
  }
}"
57386,"/** 
 * {@inheritDoc} 
 */
public Entry next(){
  tmp.setIndex(current.getIndex());
  if (next != null) {
    current.setIndex(next.getIndex());
    advance(next);
    if (next.getIndex() < 0) {
      next=null;
    }
  }
 else {
    current=null;
  }
  return tmp;
}","/** 
 * {@inheritDoc} 
 */
public Entry next(){
  int index=next.getIndex();
  if (index < 0) {
    throw new NoSuchElementException();
  }
  current.setIndex(index);
  advance(next);
  return current;
}"
57387,"/** 
 * Returns true iff <code>object</code> is a <code>SummaryStatistics</code> instance and all statistics have the same values as this.
 * @param object the object to test equality against.
 * @return true if object equals this
 */
@Override public boolean equals(Object object){
  if (object == this) {
    return true;
  }
  if (object instanceof MultivariateSummaryStatistics == false) {
    return false;
  }
  MultivariateSummaryStatistics stat=(MultivariateSummaryStatistics)object;
  return MathUtils.equals(stat.getGeometricMean(),getGeometricMean()) && MathUtils.equals(stat.getMax(),getMax()) && MathUtils.equals(stat.getMean(),getMean())&& MathUtils.equals(stat.getMin(),getMin())&& MathUtils.equals(stat.getN(),getN())&& MathUtils.equals(stat.getSum(),getSum())&& MathUtils.equals(stat.getSumSq(),getSumSq())&& MathUtils.equals(stat.getSumLog(),getSumLog())&& stat.getCovariance().equals(getCovariance());
}","/** 
 * Returns true iff <code>object</code> is a <code>MultivariateSummaryStatistics</code> instance and all statistics have the same values as this.
 * @param object the object to test equality against.
 * @return true if object equals this
 */
@Override public boolean equals(Object object){
  if (object == this) {
    return true;
  }
  if (object instanceof MultivariateSummaryStatistics == false) {
    return false;
  }
  MultivariateSummaryStatistics stat=(MultivariateSummaryStatistics)object;
  return MathUtils.equals(stat.getGeometricMean(),getGeometricMean()) && MathUtils.equals(stat.getMax(),getMax()) && MathUtils.equals(stat.getMean(),getMean())&& MathUtils.equals(stat.getMin(),getMin())&& MathUtils.equals(stat.getN(),getN())&& MathUtils.equals(stat.getSum(),getSum())&& MathUtils.equals(stat.getSumSq(),getSumSq())&& MathUtils.equals(stat.getSumLog(),getSumLog())&& stat.getCovariance().equals(getCovariance());
}"
57388,"/** 
 * Create a binomial distribution with the given number of trials and probability of success.
 * @param r the number of successes
 * @param p the probability of success
 */
public PascalDistributionImpl(int r,double p){
  super();
  setNumberOfSuccessesInternal(r);
  setProbabilityOfSuccessInternal(p);
}","/** 
 * Create a Pascal distribution with the given number of trials and probability of success.
 * @param r the number of successes
 * @param p the probability of success
 */
public PascalDistributionImpl(int r,double p){
  super();
  setNumberOfSuccessesInternal(r);
  setProbabilityOfSuccessInternal(p);
}"
57389,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[n];
  final double[] yTmp=new double[y0.length];
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  final NordsieckStepInterpolator interpolatorTmp=new NordsieckStepInterpolator();
  interpolatorTmp.reinitialize(yTmp,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  final int lastRow=nordsieck.getRowDimension() - 1;
  double hNew=stepSize;
  interpolator.rescale(hNew);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      stepSize=hNew;
      error=0;
      for (int i=0; i < y0.length; ++i) {
        final double yScale=Math.abs(y[i]);
        final double tol=(vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
        final double ratio=nordsieck.getEntry(lastRow,i) / tol;
        error+=ratio * ratio;
      }
      error=Math.sqrt(error / y0.length);
      if (error <= 1.0) {
        final double stepEnd=stepStart + stepSize;
        interpolator.setInterpolatedTime(stepEnd);
        System.arraycopy(interpolator.getInterpolatedState(),0,yTmp,0,y0.length);
        computeDerivatives(stepEnd,yTmp,yDot);
        final double[] predictedScaled=new double[y0.length];
        for (int j=0; j < y0.length; ++j) {
          predictedScaled[j]=stepSize * yDot[j];
        }
        final Array2DRowRealMatrix nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
        updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
        interpolatorTmp.reinitialize(stepEnd,stepSize,predictedScaled,nordsieckTmp);
        interpolatorTmp.storeTime(stepStart);
        interpolatorTmp.shift();
        interpolatorTmp.storeTime(stepEnd);
        if (manager.evaluateStep(interpolatorTmp)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            loop=false;
          }
 else {
            hNew=dt;
            interpolator.rescale(hNew);
          }
        }
 else {
          scaled=predictedScaled;
          nordsieck=nordsieckTmp;
          interpolator.reinitialize(stepEnd,stepSize,scaled,nordsieck);
          loop=false;
        }
      }
 else {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,n);
    interpolator.storeTime(nextStep);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    for (    StepHandler handler : stepHandlers) {
      interpolator.setInterpolatedTime(nextStep);
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (!lastStep && manager.reset(stepStart,y)) {
      start(stepStart,y,t);
      interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      interpolator.rescale(hNew);
    }
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[n];
  final double[] yTmp=new double[y0.length];
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  final NordsieckStepInterpolator interpolatorTmp=new NordsieckStepInterpolator();
  interpolatorTmp.reinitialize(yTmp,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  final int lastRow=nordsieck.getRowDimension() - 1;
  double hNew=stepSize;
  interpolator.rescale(hNew);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      stepSize=hNew;
      error=0;
      for (int i=0; i < y0.length; ++i) {
        final double yScale=Math.abs(y[i]);
        final double tol=(vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);
        final double ratio=nordsieck.getEntry(lastRow,i) / tol;
        error+=ratio * ratio;
      }
      error=Math.sqrt(error / y0.length);
      if (error <= 1.0) {
        final double stepEnd=stepStart + stepSize;
        interpolator.setInterpolatedTime(stepEnd);
        System.arraycopy(interpolator.getInterpolatedState(),0,yTmp,0,y0.length);
        computeDerivatives(stepEnd,yTmp,yDot);
        final double[] predictedScaled=new double[y0.length];
        for (int j=0; j < y0.length; ++j) {
          predictedScaled[j]=stepSize * yDot[j];
        }
        final Array2DRowRealMatrix nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
        updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
        interpolatorTmp.reinitialize(stepEnd,stepSize,predictedScaled,nordsieckTmp);
        interpolatorTmp.storeTime(stepStart);
        interpolatorTmp.shift();
        interpolatorTmp.storeTime(stepEnd);
        if (manager.evaluateStep(interpolatorTmp)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            interpolator.storeTime(stepStart);
            System.arraycopy(y,0,yTmp,0,y0.length);
            hNew=0;
            stepSize=0;
            loop=false;
          }
 else {
            hNew=dt;
            interpolator.rescale(hNew);
          }
        }
 else {
          scaled=predictedScaled;
          nordsieck=nordsieckTmp;
          interpolator.reinitialize(stepEnd,stepSize,scaled,nordsieck);
          loop=false;
        }
      }
 else {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,n);
    interpolator.storeTime(nextStep);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    for (    StepHandler handler : stepHandlers) {
      interpolator.setInterpolatedTime(nextStep);
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (!lastStep && manager.reset(stepStart,y)) {
      start(stepStart,y,t);
      interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      interpolator.rescale(hNew);
    }
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}"
57390,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  final NordsieckStepInterpolator interpolatorTmp=new NordsieckStepInterpolator();
  interpolatorTmp.reinitialize(yTmp,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  double hNew=stepSize;
  interpolator.rescale(hNew);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      stepSize=hNew;
      final double stepEnd=stepStart + stepSize;
      interpolator.setInterpolatedTime(stepEnd);
      System.arraycopy(interpolator.getInterpolatedState(),0,yTmp,0,y0.length);
      computeDerivatives(stepEnd,yTmp,yDot);
      final double[] predictedScaled=new double[y0.length];
      for (int j=0; j < y0.length; ++j) {
        predictedScaled[j]=stepSize * yDot[j];
      }
      final Array2DRowRealMatrix nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
      updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
      error=nordsieckTmp.walkInOptimizedOrder(new Corrector(y,predictedScaled,yTmp));
      if (error <= 1.0) {
        computeDerivatives(stepEnd,yTmp,yDot);
        final double[] correctedScaled=new double[y0.length];
        for (int j=0; j < y0.length; ++j) {
          correctedScaled[j]=stepSize * yDot[j];
        }
        updateHighOrderDerivativesPhase2(predictedScaled,correctedScaled,nordsieckTmp);
        interpolatorTmp.reinitialize(stepEnd,stepSize,correctedScaled,nordsieckTmp);
        interpolatorTmp.storeTime(stepStart);
        interpolatorTmp.shift();
        interpolatorTmp.storeTime(stepEnd);
        if (manager.evaluateStep(interpolatorTmp)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            loop=false;
          }
 else {
            hNew=dt;
            interpolator.rescale(hNew);
          }
        }
 else {
          scaled=correctedScaled;
          nordsieck=nordsieckTmp;
          interpolator.reinitialize(stepEnd,stepSize,scaled,nordsieck);
          loop=false;
        }
      }
 else {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,n);
    interpolator.storeTime(nextStep);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    for (    StepHandler handler : stepHandlers) {
      interpolator.setInterpolatedTime(nextStep);
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (!lastStep && manager.reset(stepStart,y)) {
      start(stepStart,y,t);
      interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      interpolator.rescale(hNew);
    }
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  final int n=y0.length;
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,n);
  }
  final double[] yDot=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final NordsieckStepInterpolator interpolator=new NordsieckStepInterpolator();
  interpolator.reinitialize(y,forward);
  final NordsieckStepInterpolator interpolatorTmp=new NordsieckStepInterpolator();
  interpolatorTmp.reinitialize(yTmp,forward);
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  start(t0,y,t);
  interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
  interpolator.storeTime(stepStart);
  double hNew=stepSize;
  interpolator.rescale(hNew);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      stepSize=hNew;
      final double stepEnd=stepStart + stepSize;
      interpolator.setInterpolatedTime(stepEnd);
      System.arraycopy(interpolator.getInterpolatedState(),0,yTmp,0,y0.length);
      computeDerivatives(stepEnd,yTmp,yDot);
      final double[] predictedScaled=new double[y0.length];
      for (int j=0; j < y0.length; ++j) {
        predictedScaled[j]=stepSize * yDot[j];
      }
      final Array2DRowRealMatrix nordsieckTmp=updateHighOrderDerivativesPhase1(nordsieck);
      updateHighOrderDerivativesPhase2(scaled,predictedScaled,nordsieckTmp);
      error=nordsieckTmp.walkInOptimizedOrder(new Corrector(y,predictedScaled,yTmp));
      if (error <= 1.0) {
        computeDerivatives(stepEnd,yTmp,yDot);
        final double[] correctedScaled=new double[y0.length];
        for (int j=0; j < y0.length; ++j) {
          correctedScaled[j]=stepSize * yDot[j];
        }
        updateHighOrderDerivativesPhase2(predictedScaled,correctedScaled,nordsieckTmp);
        interpolatorTmp.reinitialize(stepEnd,stepSize,correctedScaled,nordsieckTmp);
        interpolatorTmp.storeTime(stepStart);
        interpolatorTmp.shift();
        interpolatorTmp.storeTime(stepEnd);
        if (manager.evaluateStep(interpolatorTmp)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            interpolator.storeTime(stepStart);
            System.arraycopy(y,0,yTmp,0,y0.length);
            hNew=0;
            stepSize=0;
            loop=false;
          }
 else {
            hNew=dt;
            interpolator.rescale(hNew);
          }
        }
 else {
          scaled=correctedScaled;
          nordsieck=nordsieckTmp;
          interpolator.reinitialize(stepEnd,stepSize,scaled,nordsieck);
          loop=false;
        }
      }
 else {
        final double factor=computeStepGrowShrinkFactor(error);
        hNew=filterStep(stepSize * factor,forward,false);
        interpolator.rescale(hNew);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,n);
    interpolator.storeTime(nextStep);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    for (    StepHandler handler : stepHandlers) {
      interpolator.setInterpolatedTime(nextStep);
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (!lastStep && manager.reset(stepStart,y)) {
      start(stepStart,y,t);
      interpolator.reinitialize(stepStart,stepSize,scaled,nordsieck);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=computeStepGrowShrinkFactor(error);
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
      interpolator.rescale(hNew);
    }
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}"
57391,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][y0.length];
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      if (firstTime || !fsal) {
        computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale=new double[y0.length];
        if (vecAbsoluteTolerance == null) {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
          }
        }
 else {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error <= 1.0) {
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            loop=false;
          }
 else {
            hNew=dt;
          }
        }
 else {
          loop=false;
        }
      }
 else {
        final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (fsal) {
      System.arraycopy(yDotK[stages - 1],0,yDotK[0],0,y0.length);
    }
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
    }
  }
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][y0.length];
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      if (firstTime || !fsal) {
        computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale=new double[y0.length];
        if (vecAbsoluteTolerance == null) {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
          }
        }
 else {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error <= 1.0) {
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            interpolator.storeTime(stepStart);
            System.arraycopy(y,0,yTmp,0,y0.length);
            hNew=0;
            stepSize=0;
            loop=false;
          }
 else {
            hNew=dt;
          }
        }
 else {
          loop=false;
        }
      }
 else {
        final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (fsal) {
      System.arraycopy(yDotK[stages - 1],0,yDotK[0],0,y0.length);
    }
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
    }
  }
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}"
57392,"/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=forward ? step : -step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    for (boolean loop=true; loop; ) {
      computeDerivatives(stepStart,y,yDotK[0]);
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      interpolator.storeTime(stepStart + stepSize);
      if (manager.evaluateStep(interpolator)) {
        final double dt=manager.getEventTime() - stepStart;
        if (Math.abs(dt) <= Math.ulp(stepStart)) {
          loop=false;
        }
 else {
          stepSize=dt;
        }
      }
 else {
        loop=false;
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    stepSize=forward ? step : -step;
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=forward ? step : -step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    for (boolean loop=true; loop; ) {
      computeDerivatives(stepStart,y,yDotK[0]);
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      interpolator.storeTime(stepStart + stepSize);
      if (manager.evaluateStep(interpolator)) {
        final double dt=manager.getEventTime() - stepStart;
        if (Math.abs(dt) <= Math.ulp(stepStart)) {
          interpolator.storeTime(stepStart);
          System.arraycopy(y,0,yTmp,0,y0.length);
          stepSize=0;
          loop=false;
        }
 else {
          stepSize=dt;
        }
      }
 else {
        loop=false;
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    stepSize=forward ? step : -step;
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}"
57393,"/** 
 * Construct a solver.
 */
public BrentSolver(){
  super(100,1E-6);
}","/** 
 * Contstruct a solver with the given maximum iterations and absolute accuracy.
 * @param maximumIterations maximum number of iterations
 * @param absoluteAccuracy lower bound for absolute accuracy of solutions returned by the solver
 */
public BrentSolver(int maximumIterations,double absoluteAccuracy){
  super(maximumIterations,absoluteAccuracy);
}"
57394,"/** 
 * For this distribution, X, this method returns the critical point x, such that P(X &lt; x) = <code>p</code>.
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a validprobability.
 */
public double inverseCumulativeProbability(final double p) throws MathException {
  if (p < 0.0 || p > 1.0) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",p,0.0,1.0);
  }
  UnivariateRealFunction rootFindingFunction=new UnivariateRealFunction(){
    public double value(    double x) throws FunctionEvaluationException {
      try {
        return cumulativeProbability(x) - p;
      }
 catch (      MathException ex) {
        throw new FunctionEvaluationException(ex,x,ex.getPattern(),ex.getArguments());
      }
    }
  }
;
  double lowerBound=getDomainLowerBound(p);
  double upperBound=getDomainUpperBound(p);
  double[] bracket=null;
  try {
    bracket=UnivariateRealSolverUtils.bracket(rootFindingFunction,getInitialDomain(p),lowerBound,upperBound);
  }
 catch (  ConvergenceException ex) {
    if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {
      return lowerBound;
    }
    if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {
      return upperBound;
    }
    throw new MathException(ex);
  }
  double root=UnivariateRealSolverUtils.solve(rootFindingFunction,bracket[0],bracket[1]);
  return root;
}","/** 
 * For this distribution, X, this method returns the critical point x, such that P(X &lt; x) = <code>p</code>.
 * @param p the desired probability
 * @return x, such that P(X &lt; x) = <code>p</code>
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if <code>p</code> is not a validprobability.
 */
public double inverseCumulativeProbability(final double p) throws MathException {
  if (p < 0.0 || p > 1.0) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",p,0.0,1.0);
  }
  UnivariateRealFunction rootFindingFunction=new UnivariateRealFunction(){
    public double value(    double x) throws FunctionEvaluationException {
      double ret=Double.NaN;
      try {
        ret=cumulativeProbability(x) - p;
      }
 catch (      MathException ex) {
        throw new FunctionEvaluationException(ex,x,ex.getPattern(),ex.getArguments());
      }
      if (Double.isNaN(ret)) {
        throw new FunctionEvaluationException(x,""String_Node_Str"",x,p);
      }
      return ret;
    }
  }
;
  double lowerBound=getDomainLowerBound(p);
  double upperBound=getDomainUpperBound(p);
  double[] bracket=null;
  try {
    bracket=UnivariateRealSolverUtils.bracket(rootFindingFunction,getInitialDomain(p),lowerBound,upperBound);
  }
 catch (  ConvergenceException ex) {
    if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {
      return lowerBound;
    }
    if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {
      return upperBound;
    }
    throw new MathException(ex);
  }
  double root=UnivariateRealSolverUtils.solve(rootFindingFunction,bracket[0],bracket[1],getSolverAbsoluteAccuracy());
  return root;
}"
57395,"public double value(double x) throws FunctionEvaluationException {
  try {
    return cumulativeProbability(x) - p;
  }
 catch (  MathException ex) {
    throw new FunctionEvaluationException(ex,x,ex.getPattern(),ex.getArguments());
  }
}","public double value(double x) throws FunctionEvaluationException {
  double ret=Double.NaN;
  try {
    ret=cumulativeProbability(x) - p;
  }
 catch (  MathException ex) {
    throw new FunctionEvaluationException(ex,x,ex.getPattern(),ex.getArguments());
  }
  if (Double.isNaN(ret)) {
    throw new FunctionEvaluationException(x,""String_Node_Str"",x,p);
  }
  return ret;
}"
57396,"/** 
 * For a random variable X whose values are distributed according to this distribution, this method returns the largest x, such that P(X &le; x) &le; <code>p</code>.
 * @param p the desired probability
 * @return the largest x such that P(X &le; x) <= p
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if p < 0 or p > 1
 */
public int inverseCumulativeProbability(final double p) throws MathException {
  if (p < 0.0 || p > 1.0) {
    throw MathRuntimeException.createIllegalArgumentException(OUT_OF_RANGE_POINT,p,0.0,1.0);
  }
  int x0=getDomainLowerBound(p);
  int x1=getDomainUpperBound(p);
  double pm;
  while (x0 < x1) {
    int xm=x0 + (x1 - x0) / 2;
    pm=cumulativeProbability(xm);
    if (pm > p) {
      if (xm == x1) {
        --x1;
      }
 else {
        x1=xm;
      }
    }
 else {
      if (xm == x0) {
        ++x0;
      }
 else {
        x0=xm;
      }
    }
  }
  pm=cumulativeProbability(x0);
  while (pm > p) {
    --x0;
    pm=cumulativeProbability(x0);
  }
  return x0;
}","/** 
 * For a random variable X whose values are distributed according to this distribution, this method returns the largest x, such that P(X &le; x) &le; <code>p</code>.
 * @param p the desired probability
 * @return the largest x such that P(X &le; x) <= p
 * @throws MathException if the inverse cumulative probability can not becomputed due to convergence or other numerical errors.
 * @throws IllegalArgumentException if p < 0 or p > 1
 */
public int inverseCumulativeProbability(final double p) throws MathException {
  if (p < 0.0 || p > 1.0) {
    throw MathRuntimeException.createIllegalArgumentException(OUT_OF_RANGE_POINT,p,0.0,1.0);
  }
  int x0=getDomainLowerBound(p);
  int x1=getDomainUpperBound(p);
  double pm;
  while (x0 < x1) {
    int xm=x0 + (x1 - x0) / 2;
    pm=checkedCumulativeProbability(xm);
    if (pm > p) {
      if (xm == x1) {
        --x1;
      }
 else {
        x1=xm;
      }
    }
 else {
      if (xm == x0) {
        ++x0;
      }
 else {
        x0=xm;
      }
    }
  }
  pm=checkedCumulativeProbability(x0);
  while (pm > p) {
    --x0;
    pm=checkedCumulativeProbability(x0);
  }
  return x0;
}"
57397,"/** 
 * The probability distribution function P(X <= x) for a Poisson distribution.
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computeddue to convergence or other numerical errors.
 */
@Override public double cumulativeProbability(int x) throws MathException {
  if (x < 0) {
    return 0;
  }
  if (x == Integer.MAX_VALUE) {
    return 1;
  }
  return Gamma.regularizedGammaQ((double)x + 1,mean,1E-12,Integer.MAX_VALUE);
}","/** 
 * The probability distribution function P(X <= x) for a Poisson distribution.
 * @param x the value at which the PDF is evaluated.
 * @return Poisson distribution function evaluated at x
 * @throws MathException if the cumulative probability can not be computeddue to convergence or other numerical errors.
 */
@Override public double cumulativeProbability(int x) throws MathException {
  if (x < 0) {
    return 0;
  }
  if (x == Integer.MAX_VALUE) {
    return 1;
  }
  return Gamma.regularizedGammaQ((double)x + 1,mean,epsilon,maxIterations);
}"
57398,"/** 
 * Build an enhanced integrator using ODE builtin jacobian computation features.
 * @param integrator underlying integrator to solve the compound problem
 * @param ode original problem, which can compute the jacobians by itself
 * @see #EnhancedFirstOrderIntegrator(FirstOrderIntegrator,ParameterizedODE,double[],double[],double[])
 */
public FirstOrderIntegratorWithJacobians(final FirstOrderIntegrator integrator,final ParameterizedODEWithJacobians ode){
  this.integrator=integrator;
  this.ode=ode;
  setMaxEvaluations(-1);
}","/** 
 * Build an enhanced integrator using ODE builtin jacobian computation features.
 * @param integrator underlying integrator to solve the compound problem
 * @param ode original problem, which can compute the jacobians by itself
 * @see #FirstOrderIntegratorWithJacobians(FirstOrderIntegrator,ParameterizedODE,double[],double[],double[])
 */
public FirstOrderIntegratorWithJacobians(final FirstOrderIntegrator integrator,final ParameterizedODEWithJacobians ode){
  this.integrator=integrator;
  this.ode=ode;
  setMaxEvaluations(-1);
}"
57399,"/** 
 * Integrate the differential equations and the variational equations up to the given time. <p>This method solves an Initial Value Problem (IVP) and also computes the derivatives of the solution with respect to initial state and parameters. This can be used as a basis to solve Boundary Value Problems (BVP).</p> <p>Since this method stores some internal state variables made available in its public interface during integration (  {@link #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>
 * @param equations differential equations to integrate
 * @param t0 initial time
 * @param y0 initial value of the state vector at t0
 * @param dY0dP initial value of the state vector derivative with respect to theparameters at t0
 * @param t target time for the integration(can be set to a value smaller than <code>t0</code> for backward integration)
 * @param y placeholder where to put the state vector at each successfulstep (and hence at the end of integration), can be the same object as y0
 * @param dYdY0 placeholder where to put the state vector derivative with respectto the initial state (dy[i]/dy0[j] is in element array dYdY0[i][j]) at each successful step (and hence at the end of integration)
 * @param dYdP placeholder where to put the state vector derivative with respectto the parameters (dy[i]/dp[j] is in element array dYdP[i][j]) at each successful step (and hence at the end of integration)
 * @return stop time, will be the same as target time if integration reached itstarget, but may be different if some event handler stops it at some point.
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
public double integrate(final double t0,final double[] y0,final double[][] dY0dP,final double t,final double[] y,final double[][] dYdY0,final double[][] dYdP) throws DerivativeException, IntegratorException {
  final int n=ode.getDimension();
  final int k=ode.getParametersDimension();
  checkDimension(n,y0);
  checkDimension(n,y);
  checkDimension(n,dYdY0);
  checkDimension(n,dYdY0[0]);
  if (k != 0) {
    checkDimension(n,dY0dP);
    checkDimension(k,dY0dP[0]);
    checkDimension(n,dYdP);
    checkDimension(k,dYdP[0]);
  }
  final double[] z=new double[n * (1 + n + k)];
  System.arraycopy(y0,0,z,0,n);
  for (int i=0; i < n; ++i) {
    z[i * (1 + n) + n]=1.0;
    System.arraycopy(dY0dP[i],0,z,n * (n + 1) + i * k,k);
  }
  evaluations=0;
  final double stopTime=integrator.integrate(new MappingWrapper(),t0,z,t,z);
  dispatchCompoundState(z,y,dYdY0,dYdP);
  return stopTime;
}","/** 
 * Integrate the differential equations and the variational equations up to the given time. <p>This method solves an Initial Value Problem (IVP) and also computes the derivatives of the solution with respect to initial state and parameters. This can be used as a basis to solve Boundary Value Problems (BVP).</p> <p>Since this method stores some internal state variables made available in its public interface during integration (  {@link #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>
 * @param t0 initial time
 * @param y0 initial value of the state vector at t0
 * @param dY0dP initial value of the state vector derivative with respect to theparameters at t0
 * @param t target time for the integration(can be set to a value smaller than <code>t0</code> for backward integration)
 * @param y placeholder where to put the state vector at each successfulstep (and hence at the end of integration), can be the same object as y0
 * @param dYdY0 placeholder where to put the state vector derivative with respectto the initial state (dy[i]/dy0[j] is in element array dYdY0[i][j]) at each successful step (and hence at the end of integration)
 * @param dYdP placeholder where to put the state vector derivative with respectto the parameters (dy[i]/dp[j] is in element array dYdP[i][j]) at each successful step (and hence at the end of integration)
 * @return stop time, will be the same as target time if integration reached itstarget, but may be different if some event handler stops it at some point.
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
public double integrate(final double t0,final double[] y0,final double[][] dY0dP,final double t,final double[] y,final double[][] dYdY0,final double[][] dYdP) throws DerivativeException, IntegratorException {
  final int n=ode.getDimension();
  final int k=ode.getParametersDimension();
  checkDimension(n,y0);
  checkDimension(n,y);
  checkDimension(n,dYdY0);
  checkDimension(n,dYdY0[0]);
  if (k != 0) {
    checkDimension(n,dY0dP);
    checkDimension(k,dY0dP[0]);
    checkDimension(n,dYdP);
    checkDimension(k,dYdP[0]);
  }
  final double[] z=new double[n * (1 + n + k)];
  System.arraycopy(y0,0,z,0,n);
  for (int i=0; i < n; ++i) {
    z[i * (1 + n) + n]=1.0;
    System.arraycopy(dY0dP[i],0,z,n * (n + 1) + i * k,k);
  }
  evaluations=0;
  final double stopTime=integrator.integrate(new MappingWrapper(),t0,z,t,z);
  dispatchCompoundState(z,y,dYdY0,dYdP);
  return stopTime;
}"
57400,"/** 
 * Determines whether this handler needs dense output. <p>This method allows the integrator to avoid performing extra computation if the handler does not need dense output. If this method returns false, the integrator will call the   {@link #handleStep} method with a {@link DummyStepInterpolator} ratherthan a custom interpolator.</p>
 * @return true if the handler needs dense output
 */
boolean requiresDenseOutput();","/** 
 * Determines whether this handler needs dense output. <p>This method allows the integrator to avoid performing extra computation if the handler does not need dense output.</p>
 * @return true if the handler needs dense output
 */
boolean requiresDenseOutput();"
57401,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][y0.length];
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      if (firstTime || !fsal) {
        computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale=new double[y0.length];
        if (vecAbsoluteTolerance == null) {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
          }
        }
 else {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error <= 1.0) {
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            loop=false;
          }
 else {
            hNew=dt;
          }
        }
 else {
          loop=false;
        }
      }
 else {
        final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (fsal) {
      System.arraycopy(yDotK[stages - 1],0,yDotK[0],0,y0.length);
    }
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
    }
  }
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][y0.length];
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      if (firstTime || !fsal) {
        computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale=new double[y0.length];
        if (vecAbsoluteTolerance == null) {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
          }
        }
 else {
          for (int i=0; i < scale.length; ++i) {
            scale[i]=vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error <= 1.0) {
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
          final double dt=manager.getEventTime() - stepStart;
          if (Math.abs(dt) <= Math.ulp(stepStart)) {
            loop=false;
          }
 else {
            hNew=dt;
          }
        }
 else {
          loop=false;
        }
      }
 else {
        final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (fsal) {
      System.arraycopy(yDotK[stages - 1],0,yDotK[0],0,y0.length);
    }
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
    }
  }
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}"
57402,"/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final double[] yDot0=new double[y0.length];
  final double[] y1=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] yTmpDot=new double[y0.length];
  final double[][] diagonal=new double[sequence.length - 1][];
  final double[][] y1Diag=new double[sequence.length - 1][];
  for (int k=0; k < sequence.length - 1; ++k) {
    diagonal[k]=new double[y0.length];
    y1Diag[k]=new double[y0.length];
  }
  final double[][][] fk=new double[sequence.length][][];
  for (int k=0; k < sequence.length; ++k) {
    fk[k]=new double[sequence[k] + 1][];
    fk[k][0]=yDot0;
    for (int l=0; l < sequence[k]; ++l) {
      fk[k][l + 1]=new double[y0.length];
    }
  }
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  double[] yDot1=null;
  double[][] yMidDots=null;
  if (denseOutput) {
    yDot1=new double[y0.length];
    yMidDots=new double[1 + 2 * sequence.length][];
    for (int j=0; j < yMidDots.length; ++j) {
      yMidDots[j]=new double[y0.length];
    }
  }
 else {
    yMidDots=new double[1][];
    yMidDots[0]=new double[y0.length];
  }
  final double[] scale=new double[y0.length];
  rescale(y,y,scale);
  final double tol=(vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
  final double log10R=Math.log(Math.max(1.0e-10,tol)) / Math.log(10.0);
  int targetIter=Math.max(1,Math.min(sequence.length - 2,(int)Math.floor(0.5 - 0.6 * log10R)));
  AbstractStepInterpolator interpolator=null;
  if (denseOutput || (!eventsHandlersManager.isEmpty())) {
    interpolator=new GraggBulirschStoerStepInterpolator(y,yDot0,y1,yDot1,yMidDots,forward);
  }
 else {
    interpolator=new DummyStepInterpolator(y,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  double maxError=Double.MAX_VALUE;
  boolean previousRejected=false;
  boolean firstTime=true;
  boolean newStep=true;
  boolean lastStep=false;
  boolean firstStepAlreadyComputed=false;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  costPerTimeUnit[0]=0;
  while (!lastStep) {
    double error;
    boolean reject=false;
    if (newStep) {
      interpolator.shift();
      if (!firstStepAlreadyComputed) {
        computeDerivatives(stepStart,y,yDot0);
      }
      if (firstTime) {
        hNew=initializeStep(equations,forward,2 * targetIter + 1,scale,stepStart,y,yDot0,yTmp,yTmpDot);
        if (!forward) {
          hNew=-hNew;
        }
      }
      newStep=false;
    }
    stepSize=hNew;
    if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) {
      stepSize=t - stepStart;
    }
    final double nextT=stepStart + stepSize;
    lastStep=forward ? (nextT >= t) : (nextT <= t);
    int k=-1;
    for (boolean loop=true; loop; ) {
      ++k;
      if (!tryStep(stepStart,y,stepSize,k,scale,fk[k],(k == 0) ? yMidDots[0] : diagonal[k - 1],(k == 0) ? y1 : y1Diag[k - 1],yTmp)) {
        hNew=Math.abs(filterStep(stepSize * stabilityReduction,forward,false));
        reject=true;
        loop=false;
      }
 else {
        if (k > 0) {
          extrapolate(0,k,y1Diag,y1);
          rescale(y,y1,scale);
          error=0;
          for (int j=0; j < y0.length; ++j) {
            final double e=Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
            error+=e * e;
          }
          error=Math.sqrt(error / y0.length);
          if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
            hNew=Math.abs(filterStep(stepSize * stabilityReduction,forward,false));
            reject=true;
            loop=false;
          }
 else {
            maxError=Math.max(4 * error,1.0);
            final double exp=1.0 / (2 * k + 1);
            double fac=stepControl2 / Math.pow(error / stepControl1,exp);
            final double pow=Math.pow(stepControl3,exp);
            fac=Math.max(pow / stepControl4,Math.min(1 / pow,fac));
            optimalStep[k]=Math.abs(filterStep(stepSize * fac,forward,true));
            costPerTimeUnit[k]=costPerStep[k] / optimalStep[k];
switch (k - targetIter) {
case -1:
              if ((targetIter > 1) && !previousRejected) {
                if (error <= 1.0) {
                  loop=false;
                }
 else {
                  final double ratio=((double)sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]);
                  if (error > ratio * ratio) {
                    reject=true;
                    loop=false;
                    targetIter=k;
                    if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                      --targetIter;
                    }
                    hNew=optimalStep[targetIter];
                  }
                }
              }
            break;
case 0:
          if (error <= 1.0) {
            loop=false;
          }
 else {
            final double ratio=((double)sequence[k + 1]) / sequence[0];
            if (error > ratio * ratio) {
              reject=true;
              loop=false;
              if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                --targetIter;
              }
              hNew=optimalStep[targetIter];
            }
          }
        break;
case 1:
      if (error > 1.0) {
        reject=true;
        if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
          --targetIter;
        }
        hNew=optimalStep[targetIter];
      }
    loop=false;
  break;
default :
if ((firstTime || lastStep) && (error <= 1.0)) {
  loop=false;
}
break;
}
}
}
}
}
double hInt=getMaxStep();
if (denseOutput && !reject) {
for (int j=1; j <= k; ++j) {
extrapolate(0,j,diagonal,yMidDots[0]);
}
computeDerivatives(stepStart + stepSize,y1,yDot1);
final int mu=2 * k - mudif + 3;
for (int l=0; l < mu; ++l) {
final int l2=l / 2;
double factor=Math.pow(0.5 * sequence[l2],l);
int middleIndex=fk[l2].length / 2;
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]=factor * fk[l2][middleIndex + l][i];
}
for (int j=1; j <= k - l2; ++j) {
factor=Math.pow(0.5 * sequence[j + l2],l);
middleIndex=fk[l2 + j].length / 2;
for (int i=0; i < y0.length; ++i) {
diagonal[j - 1][i]=factor * fk[l2 + j][middleIndex + l][i];
}
extrapolate(l2,j,diagonal,yMidDots[l + 1]);
}
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]*=stepSize;
}
for (int j=(l + 1) / 2; j <= k; ++j) {
for (int m=fk[j].length - 1; m >= 2 * (l + 1); --m) {
for (int i=0; i < y0.length; ++i) {
fk[j][m][i]-=fk[j][m - 2][i];
}
}
}
}
if (mu >= 0) {
final GraggBulirschStoerStepInterpolator gbsInterpolator=(GraggBulirschStoerStepInterpolator)interpolator;
gbsInterpolator.computeCoefficients(mu,stepSize);
if (useInterpolationError) {
final double interpError=gbsInterpolator.estimateError(scale);
hInt=Math.abs(stepSize / Math.max(Math.pow(interpError,1.0 / (mu + 4)),0.01));
if (interpError > 10.0) {
hNew=hInt;
reject=true;
}
}
if (!reject) {
interpolator.storeTime(stepStart + stepSize);
if (eventsHandlersManager.evaluateStep(interpolator)) {
final double dt=eventsHandlersManager.getEventTime() - stepStart;
if (Math.abs(dt) > Math.ulp(stepStart)) {
hNew=Math.abs(dt);
reject=true;
}
}
}
}
if (!reject) {
firstStepAlreadyComputed=true;
System.arraycopy(yDot1,0,yDot0,0,y0.length);
}
}
if (!reject) {
final double nextStep=stepStart + stepSize;
System.arraycopy(y1,0,y,0,y0.length);
eventsHandlersManager.stepAccepted(nextStep,y);
if (eventsHandlersManager.stop()) {
lastStep=true;
}
interpolator.storeTime(nextStep);
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator,lastStep);
}
stepStart=nextStep;
if (eventsHandlersManager.reset(stepStart,y) && !lastStep) {
firstStepAlreadyComputed=false;
}
int optimalIter;
if (k == 1) {
optimalIter=2;
if (previousRejected) {
optimalIter=1;
}
}
 else if (k <= targetIter) {
optimalIter=k;
if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) {
optimalIter=k - 1;
}
 else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) {
optimalIter=Math.min(k + 1,sequence.length - 2);
}
}
 else {
optimalIter=k - 1;
if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) {
optimalIter=k - 2;
}
if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
optimalIter=Math.min(k,sequence.length - 2);
}
}
if (previousRejected) {
targetIter=Math.min(optimalIter,k);
hNew=Math.min(Math.abs(stepSize),optimalStep[targetIter]);
}
 else {
if (optimalIter <= k) {
hNew=optimalStep[optimalIter];
}
 else {
if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k],forward,false);
}
 else {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],forward,false);
}
}
targetIter=optimalIter;
}
newStep=true;
}
hNew=Math.min(hNew,hInt);
if (!forward) {
hNew=-hNew;
}
firstTime=false;
if (reject) {
lastStep=false;
previousRejected=true;
}
 else {
previousRejected=false;
}
}
return stepStart;
}","/** 
 * {@inheritDoc} 
 */
@Override public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final double[] yDot0=new double[y0.length];
  final double[] y1=new double[y0.length];
  final double[] yTmp=new double[y0.length];
  final double[] yTmpDot=new double[y0.length];
  final double[][] diagonal=new double[sequence.length - 1][];
  final double[][] y1Diag=new double[sequence.length - 1][];
  for (int k=0; k < sequence.length - 1; ++k) {
    diagonal[k]=new double[y0.length];
    y1Diag[k]=new double[y0.length];
  }
  final double[][][] fk=new double[sequence.length][][];
  for (int k=0; k < sequence.length; ++k) {
    fk[k]=new double[sequence[k] + 1][];
    fk[k][0]=yDot0;
    for (int l=0; l < sequence[k]; ++l) {
      fk[k][l + 1]=new double[y0.length];
    }
  }
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  double[] yDot1=null;
  double[][] yMidDots=null;
  if (denseOutput) {
    yDot1=new double[y0.length];
    yMidDots=new double[1 + 2 * sequence.length][];
    for (int j=0; j < yMidDots.length; ++j) {
      yMidDots[j]=new double[y0.length];
    }
  }
 else {
    yMidDots=new double[1][];
    yMidDots[0]=new double[y0.length];
  }
  final double[] scale=new double[y0.length];
  rescale(y,y,scale);
  final double tol=(vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];
  final double log10R=Math.log(Math.max(1.0e-10,tol)) / Math.log(10.0);
  int targetIter=Math.max(1,Math.min(sequence.length - 2,(int)Math.floor(0.5 - 0.6 * log10R)));
  AbstractStepInterpolator interpolator=null;
  if (denseOutput || (!eventsHandlersManager.isEmpty())) {
    interpolator=new GraggBulirschStoerStepInterpolator(y,yDot0,y1,yDot1,yMidDots,forward);
  }
 else {
    interpolator=new DummyStepInterpolator(y,yDot1,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  double maxError=Double.MAX_VALUE;
  boolean previousRejected=false;
  boolean firstTime=true;
  boolean newStep=true;
  boolean lastStep=false;
  boolean firstStepAlreadyComputed=false;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  costPerTimeUnit[0]=0;
  while (!lastStep) {
    double error;
    boolean reject=false;
    if (newStep) {
      interpolator.shift();
      if (!firstStepAlreadyComputed) {
        computeDerivatives(stepStart,y,yDot0);
      }
      if (firstTime) {
        hNew=initializeStep(equations,forward,2 * targetIter + 1,scale,stepStart,y,yDot0,yTmp,yTmpDot);
        if (!forward) {
          hNew=-hNew;
        }
      }
      newStep=false;
    }
    stepSize=hNew;
    if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) {
      stepSize=t - stepStart;
    }
    final double nextT=stepStart + stepSize;
    lastStep=forward ? (nextT >= t) : (nextT <= t);
    int k=-1;
    for (boolean loop=true; loop; ) {
      ++k;
      if (!tryStep(stepStart,y,stepSize,k,scale,fk[k],(k == 0) ? yMidDots[0] : diagonal[k - 1],(k == 0) ? y1 : y1Diag[k - 1],yTmp)) {
        hNew=Math.abs(filterStep(stepSize * stabilityReduction,forward,false));
        reject=true;
        loop=false;
      }
 else {
        if (k > 0) {
          extrapolate(0,k,y1Diag,y1);
          rescale(y,y1,scale);
          error=0;
          for (int j=0; j < y0.length; ++j) {
            final double e=Math.abs(y1[j] - y1Diag[0][j]) / scale[j];
            error+=e * e;
          }
          error=Math.sqrt(error / y0.length);
          if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {
            hNew=Math.abs(filterStep(stepSize * stabilityReduction,forward,false));
            reject=true;
            loop=false;
          }
 else {
            maxError=Math.max(4 * error,1.0);
            final double exp=1.0 / (2 * k + 1);
            double fac=stepControl2 / Math.pow(error / stepControl1,exp);
            final double pow=Math.pow(stepControl3,exp);
            fac=Math.max(pow / stepControl4,Math.min(1 / pow,fac));
            optimalStep[k]=Math.abs(filterStep(stepSize * fac,forward,true));
            costPerTimeUnit[k]=costPerStep[k] / optimalStep[k];
switch (k - targetIter) {
case -1:
              if ((targetIter > 1) && !previousRejected) {
                if (error <= 1.0) {
                  loop=false;
                }
 else {
                  final double ratio=((double)sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]);
                  if (error > ratio * ratio) {
                    reject=true;
                    loop=false;
                    targetIter=k;
                    if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                      --targetIter;
                    }
                    hNew=optimalStep[targetIter];
                  }
                }
              }
            break;
case 0:
          if (error <= 1.0) {
            loop=false;
          }
 else {
            final double ratio=((double)sequence[k + 1]) / sequence[0];
            if (error > ratio * ratio) {
              reject=true;
              loop=false;
              if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
                --targetIter;
              }
              hNew=optimalStep[targetIter];
            }
          }
        break;
case 1:
      if (error > 1.0) {
        reject=true;
        if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) {
          --targetIter;
        }
        hNew=optimalStep[targetIter];
      }
    loop=false;
  break;
default :
if ((firstTime || lastStep) && (error <= 1.0)) {
  loop=false;
}
break;
}
}
}
}
}
double hInt=getMaxStep();
if (denseOutput && !reject) {
for (int j=1; j <= k; ++j) {
extrapolate(0,j,diagonal,yMidDots[0]);
}
computeDerivatives(stepStart + stepSize,y1,yDot1);
final int mu=2 * k - mudif + 3;
for (int l=0; l < mu; ++l) {
final int l2=l / 2;
double factor=Math.pow(0.5 * sequence[l2],l);
int middleIndex=fk[l2].length / 2;
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]=factor * fk[l2][middleIndex + l][i];
}
for (int j=1; j <= k - l2; ++j) {
factor=Math.pow(0.5 * sequence[j + l2],l);
middleIndex=fk[l2 + j].length / 2;
for (int i=0; i < y0.length; ++i) {
diagonal[j - 1][i]=factor * fk[l2 + j][middleIndex + l][i];
}
extrapolate(l2,j,diagonal,yMidDots[l + 1]);
}
for (int i=0; i < y0.length; ++i) {
yMidDots[l + 1][i]*=stepSize;
}
for (int j=(l + 1) / 2; j <= k; ++j) {
for (int m=fk[j].length - 1; m >= 2 * (l + 1); --m) {
for (int i=0; i < y0.length; ++i) {
fk[j][m][i]-=fk[j][m - 2][i];
}
}
}
}
if (mu >= 0) {
final GraggBulirschStoerStepInterpolator gbsInterpolator=(GraggBulirschStoerStepInterpolator)interpolator;
gbsInterpolator.computeCoefficients(mu,stepSize);
if (useInterpolationError) {
final double interpError=gbsInterpolator.estimateError(scale);
hInt=Math.abs(stepSize / Math.max(Math.pow(interpError,1.0 / (mu + 4)),0.01));
if (interpError > 10.0) {
hNew=hInt;
reject=true;
}
}
if (!reject) {
interpolator.storeTime(stepStart + stepSize);
if (eventsHandlersManager.evaluateStep(interpolator)) {
final double dt=eventsHandlersManager.getEventTime() - stepStart;
if (Math.abs(dt) > Math.ulp(stepStart)) {
hNew=Math.abs(dt);
reject=true;
}
}
}
}
if (!reject) {
firstStepAlreadyComputed=true;
System.arraycopy(yDot1,0,yDot0,0,y0.length);
}
}
if (!reject) {
final double nextStep=stepStart + stepSize;
System.arraycopy(y1,0,y,0,y0.length);
eventsHandlersManager.stepAccepted(nextStep,y);
if (eventsHandlersManager.stop()) {
lastStep=true;
}
interpolator.storeTime(nextStep);
for (StepHandler handler : stepHandlers) {
handler.handleStep(interpolator,lastStep);
}
stepStart=nextStep;
if (eventsHandlersManager.reset(stepStart,y) && !lastStep) {
firstStepAlreadyComputed=false;
}
int optimalIter;
if (k == 1) {
optimalIter=2;
if (previousRejected) {
optimalIter=1;
}
}
 else if (k <= targetIter) {
optimalIter=k;
if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) {
optimalIter=k - 1;
}
 else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) {
optimalIter=Math.min(k + 1,sequence.length - 2);
}
}
 else {
optimalIter=k - 1;
if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) {
optimalIter=k - 2;
}
if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {
optimalIter=Math.min(k,sequence.length - 2);
}
}
if (previousRejected) {
targetIter=Math.min(optimalIter,k);
hNew=Math.min(Math.abs(stepSize),optimalStep[targetIter]);
}
 else {
if (optimalIter <= k) {
hNew=optimalStep[optimalIter];
}
 else {
if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k],forward,false);
}
 else {
hNew=filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],forward,false);
}
}
targetIter=optimalIter;
}
newStep=true;
}
hNew=Math.min(hNew,hInt);
if (!forward) {
hNew=-hNew;
}
firstTime=false;
if (reject) {
lastStep=false;
previousRejected=true;
}
 else {
previousRejected=false;
}
}
return stepStart;
}"
57403,"/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=forward ? step : -step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    for (boolean loop=true; loop; ) {
      computeDerivatives(stepStart,y,yDotK[0]);
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      interpolator.storeTime(stepStart + stepSize);
      if (manager.evaluateStep(interpolator)) {
        final double dt=manager.getEventTime() - stepStart;
        if (Math.abs(dt) <= Math.ulp(stepStart)) {
          loop=false;
        }
 else {
          stepSize=dt;
        }
      }
 else {
        loop=false;
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    stepSize=forward ? step : -step;
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  setEquations(equations);
  resetEvaluations();
  final boolean forward=t > t0;
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(this,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,yDotK[stages - 1],forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=forward ? step : -step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    for (boolean loop=true; loop; ) {
      computeDerivatives(stepStart,y,yDotK[0]);
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      interpolator.storeTime(stepStart + stepSize);
      if (manager.evaluateStep(interpolator)) {
        final double dt=manager.getEventTime() - stepStart;
        if (Math.abs(dt) <= Math.ulp(stepStart)) {
          loop=false;
        }
 else {
          stepSize=dt;
        }
      }
 else {
        loop=false;
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (manager.reset(stepStart,y) && !lastStep) {
      computeDerivatives(stepStart,y,yDotK[0]);
    }
    stepSize=forward ? step : -step;
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}"
57404,"/** 
 * Write the instance to an output channel.
 * @param out output channel
 * @exception IOException if the instance cannot be written
 */
@Override public void writeExternal(final ObjectOutput out) throws IOException {
  writeBaseExternal(out);
}","/** 
 * Write the instance to an output channel.
 * @param out output channel
 * @exception IOException if the instance cannot be written
 */
@Override public void writeExternal(final ObjectOutput out) throws IOException {
  writeBaseExternal(out);
  if (currentDerivative != null) {
    for (int i=0; i < currentDerivative.length; ++i) {
      out.writeDouble(currentDerivative[i]);
    }
  }
}"
57405,"/** 
 * Copy constructor.
 * @param interpolator interpolator to copy from. The copy is a deepcopy: its arrays are separated from the original arrays of the instance
 */
public DummyStepInterpolator(final DummyStepInterpolator interpolator){
  super(interpolator);
}","/** 
 * Copy constructor.
 * @param interpolator interpolator to copy from. The copy is a deepcopy: its arrays are separated from the original arrays of the instance
 */
public DummyStepInterpolator(final DummyStepInterpolator interpolator){
  super(interpolator);
  currentDerivative=interpolator.currentDerivative.clone();
}"
57406,"/** 
 * Read the instance from an input channel.
 * @param in input channel
 * @exception IOException if the instance cannot be read
 */
@Override public void readExternal(final ObjectInput in) throws IOException {
  final double t=readBaseExternal(in);
  setInterpolatedTime(t);
}","/** 
 * Read the instance from an input channel.
 * @param in input channel
 * @exception IOException if the instance cannot be read
 */
@Override public void readExternal(final ObjectInput in) throws IOException {
  final double t=readBaseExternal(in);
  if (currentState == null) {
    currentDerivative=null;
  }
 else {
    currentDerivative=new double[currentState.length];
    for (int i=0; i < currentDerivative.length; ++i) {
      currentDerivative[i]=in.readDouble();
    }
  }
  setInterpolatedTime(t);
}"
57407,"/** 
 * Compute the state at the interpolated time. In this class, this method does nothing: the interpolated state is always the state at the end of the current step.
 * @param theta normalized interpolation abscissa within the step(theta is zero at the previous time step and one at the current time step)
 * @param oneMinusThetaH time gap between the interpolated time andthe current time
 * @throws DerivativeException this exception is propagated to the caller if theunderlying user function triggers one
 */
@Override protected void computeInterpolatedStateAndDerivatives(final double theta,final double oneMinusThetaH) throws DerivativeException {
  System.arraycopy(currentState,0,interpolatedState,0,currentState.length);
}","/** 
 * Compute the state at the interpolated time. In this class, this method does nothing: the interpolated state is always the state at the end of the current step.
 * @param theta normalized interpolation abscissa within the step(theta is zero at the previous time step and one at the current time step)
 * @param oneMinusThetaH time gap between the interpolated time andthe current time
 * @throws DerivativeException this exception is propagated to the caller if theunderlying user function triggers one
 */
@Override protected void computeInterpolatedStateAndDerivatives(final double theta,final double oneMinusThetaH) throws DerivativeException {
  System.arraycopy(currentState,0,interpolatedState,0,currentState.length);
  System.arraycopy(currentDerivative,0,interpolatedDerivatives,0,currentDerivative.length);
}"
57408,"/** 
 * {@inheritDoc} 
 */
public StepInterpolatorWithJacobians copy() throws DerivativeException {
  return new StepInterpolatorWrapper(interpolator.copy(),y.length,dydy0[0].length);
}","/** 
 * {@inheritDoc} 
 */
public StepInterpolatorWithJacobians copy() throws DerivativeException {
  final int n=y.length;
  final int k=dydp[0].length;
  StepInterpolatorWrapper copied=new StepInterpolatorWrapper(interpolator.copy(),n,k);
  System.arraycopy(y,0,copied.y,0,n);
  System.arraycopy(yDot,0,copied.yDot,0,n);
  for (int i=0; i < n; ++i) {
    System.arraycopy(dydy0[i],0,copied.dydy0[i],0,n);
  }
  for (int i=0; i < n; ++i) {
    System.arraycopy(dydp[i],0,copied.dydp[i],0,k);
  }
  return copied;
}"
57409,"/** 
 * Integrate the differential equations and the variational equations up to the given time. <p>This method solves an Initial Value Problem (IVP) and also computes the derivatives of the solution with respect to initial state and parameters. This can be used as a basis to solve Boundary Value Problems (BVP).</p> <p>Since this method stores some internal state variables made available in its public interface during integration (  {@link #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>
 * @param equations differential equations to integrate
 * @param t0 initial time
 * @param y0 initial value of the state vector at t0
 * @param dY0dP initial value of the state vector derivative with respect to theparameters at t0
 * @param t target time for the integration(can be set to a value smaller than <code>t0</code> for backward integration)
 * @param y placeholder where to put the state vector at each successfulstep (and hence at the end of integration), can be the same object as y0
 * @param dYdY0 placeholder where to put the state vector derivative with respectto the initial state (dy[i]/dy0[j] is in element array dYdY0[i][j]) at each successful step (and hence at the end of integration)
 * @param dYdP placeholder where to put the state vector derivative with respectto the parameters (dy[i]/dp[j] is in element array dYdP[i][j]) at each successful step (and hence at the end of integration)
 * @return stop time, will be the same as target time if integration reached itstarget, but may be different if some event handler stops it at some point.
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
public double integrate(final double t0,final double[] y0,final double[][] dY0dP,final double t,final double[] y,final double[][] dYdY0,final double[][] dYdP) throws DerivativeException, IntegratorException {
  final int n=ode.getDimension();
  final int k=ode.getParametersDimension();
  checkDimension(n,y0);
  checkDimension(n,y);
  checkDimension(n,dYdY0);
  checkDimension(n,dYdY0[0]);
  if (k != 0) {
    checkDimension(n,dY0dP);
    checkDimension(k,dY0dP[0]);
    checkDimension(n,dYdP);
    checkDimension(k,dYdP[0]);
  }
  final int q=n * (1 + n + k);
  final double[] z=new double[q];
  System.arraycopy(y0,0,z,0,n);
  for (int i=0; i < n; ++i) {
    z[i * (1 + n) + n]=1.0;
    System.arraycopy(dY0dP[i],0,z,n * (n + 1) + i * k,k);
  }
  final double stopTime=integrator.integrate(new FirstOrderDifferentialEquations(){
    /** 
 * Current state. 
 */
    private final double[] y=new double[n];
    /** 
 * Time derivative of the current state. 
 */
    private final double[] yDot=new double[n];
    /** 
 * Derivatives of yDot with respect to state. 
 */
    private final double[][] dFdY=new double[n][n];
    /** 
 * Derivatives of yDot with respect to parameters. 
 */
    private final double[][] dFdP=new double[n][k];
    /** 
 * {@inheritDoc} 
 */
    public int getDimension(){
      return q;
    }
    /** 
 * {@inheritDoc} 
 */
    public void computeDerivatives(    final double t,    final double[] z,    final double[] zDot) throws DerivativeException {
      System.arraycopy(z,0,y,0,n);
      ode.computeDerivatives(t,y,yDot);
      ode.computeJacobians(t,y,yDot,dFdY,dFdP);
      System.arraycopy(yDot,0,zDot,0,n);
      for (int i=0; i < n; ++i) {
        final double[] dFdYi=dFdY[i];
        for (int j=0; j < n; ++j) {
          double s=0;
          int zIndex=n + j;
          for (int l=0; l < n; ++l) {
            s+=dFdYi[l] * z[zIndex];
            zIndex+=l;
          }
          zDot[n + i * n + j]=s;
        }
      }
      for (int i=0; i < n; ++i) {
        final double[] dFdYi=dFdY[i];
        final double[] dFdPi=dFdP[i];
        for (int j=0; j < k; ++j) {
          double s=dFdPi[j];
          int zIndex=n * (n + 1) + j;
          for (int l=0; l < n; ++l) {
            s+=dFdYi[l] * z[zIndex];
            zIndex+=k;
          }
          zDot[n * (n + 1) + i * k + j]=s;
        }
      }
    }
  }
,t0,z,t,z);
  System.arraycopy(z,0,y,0,n);
  for (int i=0; i < n; ++i) {
    System.arraycopy(z,n * (i + 1),dYdY0[i],0,n);
  }
  for (int i=0; i < n; ++i) {
    System.arraycopy(z,n * (n + 1) + i * k,dYdP[i],0,k);
  }
  return stopTime;
}","/** 
 * Integrate the differential equations and the variational equations up to the given time. <p>This method solves an Initial Value Problem (IVP) and also computes the derivatives of the solution with respect to initial state and parameters. This can be used as a basis to solve Boundary Value Problems (BVP).</p> <p>Since this method stores some internal state variables made available in its public interface during integration (  {@link #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>
 * @param equations differential equations to integrate
 * @param t0 initial time
 * @param y0 initial value of the state vector at t0
 * @param dY0dP initial value of the state vector derivative with respect to theparameters at t0
 * @param t target time for the integration(can be set to a value smaller than <code>t0</code> for backward integration)
 * @param y placeholder where to put the state vector at each successfulstep (and hence at the end of integration), can be the same object as y0
 * @param dYdY0 placeholder where to put the state vector derivative with respectto the initial state (dy[i]/dy0[j] is in element array dYdY0[i][j]) at each successful step (and hence at the end of integration)
 * @param dYdP placeholder where to put the state vector derivative with respectto the parameters (dy[i]/dp[j] is in element array dYdP[i][j]) at each successful step (and hence at the end of integration)
 * @return stop time, will be the same as target time if integration reached itstarget, but may be different if some event handler stops it at some point.
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
public double integrate(final double t0,final double[] y0,final double[][] dY0dP,final double t,final double[] y,final double[][] dYdY0,final double[][] dYdP) throws DerivativeException, IntegratorException {
  final int n=ode.getDimension();
  final int k=ode.getParametersDimension();
  checkDimension(n,y0);
  checkDimension(n,y);
  checkDimension(n,dYdY0);
  checkDimension(n,dYdY0[0]);
  if (k != 0) {
    checkDimension(n,dY0dP);
    checkDimension(k,dY0dP[0]);
    checkDimension(n,dYdP);
    checkDimension(k,dYdP[0]);
  }
  final int q=n * (1 + n + k);
  final double[] z=new double[q];
  System.arraycopy(y0,0,z,0,n);
  for (int i=0; i < n; ++i) {
    z[i * (1 + n) + n]=1.0;
    System.arraycopy(dY0dP[i],0,z,n * (n + 1) + i * k,k);
  }
  final double stopTime=integrator.integrate(new FirstOrderDifferentialEquations(){
    /** 
 * Current state. 
 */
    private final double[] y=new double[n];
    /** 
 * Time derivative of the current state. 
 */
    private final double[] yDot=new double[n];
    /** 
 * Derivatives of yDot with respect to state. 
 */
    private final double[][] dFdY=new double[n][n];
    /** 
 * Derivatives of yDot with respect to parameters. 
 */
    private final double[][] dFdP=new double[n][k];
    /** 
 * {@inheritDoc} 
 */
    public int getDimension(){
      return q;
    }
    /** 
 * {@inheritDoc} 
 */
    public void computeDerivatives(    final double t,    final double[] z,    final double[] zDot) throws DerivativeException {
      System.arraycopy(z,0,y,0,n);
      ode.computeDerivatives(t,y,yDot);
      ode.computeJacobians(t,y,yDot,dFdY,dFdP);
      System.arraycopy(yDot,0,zDot,0,n);
      for (int i=0; i < n; ++i) {
        final double[] dFdYi=dFdY[i];
        for (int j=0; j < n; ++j) {
          double s=0;
          final int startIndex=n + j;
          int zIndex=startIndex;
          for (int l=0; l < n; ++l) {
            s+=dFdYi[l] * z[zIndex];
            zIndex+=n;
          }
          zDot[startIndex + i * n]=s;
        }
      }
      for (int i=0; i < n; ++i) {
        final double[] dFdYi=dFdY[i];
        final double[] dFdPi=dFdP[i];
        for (int j=0; j < k; ++j) {
          double s=dFdPi[j];
          final int startIndex=n * (n + 1) + j;
          int zIndex=startIndex;
          for (int l=0; l < n; ++l) {
            s+=dFdYi[l] * z[zIndex];
            zIndex+=k;
          }
          zDot[startIndex + i * k]=s;
        }
      }
    }
  }
,t0,z,t,z);
  System.arraycopy(z,0,y,0,n);
  for (int i=0; i < n; ++i) {
    System.arraycopy(z,n * (i + 1),dYdY0[i],0,n);
  }
  for (int i=0; i < n; ++i) {
    System.arraycopy(z,n * (n + 1) + i * k,dYdP[i],0,k);
  }
  return stopTime;
}"
57410,"public double dYdP0(){
  return -1087.8787631970476 + (1050.4387741821572 + (-338.90621620263096 + 36.51793006801084 * b) * b) * b;
}","public double dYdP0(){
  return -1088.232716447743 + (1050.775747149553 + (-339.012934631828 + 36.52917025056327 * b) * b) * b;
}"
57411,"@Test public void testInternalDifferentiation() throws IntegratorException, DerivativeException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-4,1.0e-4);
  double hP=1.0e-12;
  SummaryStatistics residuals0=new SummaryStatistics();
  SummaryStatistics residuals1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    brusselator.setParameter(0,b);
    double[] z={1.3,b};
    double[][] dZdZ0=new double[2][2];
    double[][] dZdP=new double[2][1];
    double hY=1.0e-12;
    FirstOrderIntegratorWithJacobians extInt=new FirstOrderIntegratorWithJacobians(integ,brusselator,new double[]{b},new double[]{hY,hY},new double[]{hP});
    extInt.integrate(0,z,new double[][]{{0.0},{1.0}},20.0,z,dZdZ0,dZdP);
    residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());
    residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());
  }
  Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.006);
  Assert.assertTrue(residuals0.getStandardDeviation() < 0.0009);
  Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.006);
  Assert.assertTrue(residuals1.getStandardDeviation() < 0.0012);
}","@Test public void testInternalDifferentiation() throws IntegratorException, DerivativeException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-4,1.0e-4);
  double hP=1.0e-12;
  SummaryStatistics residualsP0=new SummaryStatistics();
  SummaryStatistics residualsP1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    brusselator.setParameter(0,b);
    double[] z={1.3,b};
    double[][] dZdZ0=new double[2][2];
    double[][] dZdP=new double[2][1];
    double hY=1.0e-12;
    FirstOrderIntegratorWithJacobians extInt=new FirstOrderIntegratorWithJacobians(integ,brusselator,new double[]{b},new double[]{hY,hY},new double[]{hP});
    extInt.integrate(0,z,new double[][]{{0.0},{1.0}},20.0,z,dZdZ0,dZdP);
    residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());
    residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());
  }
  Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.006);
  Assert.assertTrue(residualsP0.getStandardDeviation() < 0.0009);
  Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.009);
  Assert.assertTrue(residualsP1.getStandardDeviation() < 0.0014);
}"
57412,"@Test public void testLowAccuracyExternalDifferentiation() throws IntegratorException, DerivativeException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-4,1.0e-4);
  double hP=1.0e-12;
  SummaryStatistics residuals0=new SummaryStatistics();
  SummaryStatistics residuals1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    double[] y={1.3,b};
    integ.integrate(brusselator,0,y,20.0,y);
    double[] yP={1.3,b + hP};
    brusselator.setParameter(0,b + hP);
    integ.integrate(brusselator,0,yP,20.0,yP);
    residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());
    residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());
  }
  Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 600);
  Assert.assertTrue(residuals0.getStandardDeviation() > 30);
  Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 800);
  Assert.assertTrue(residuals1.getStandardDeviation() > 50);
}","@Test public void testLowAccuracyExternalDifferentiation() throws IntegratorException, DerivativeException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-4,1.0e-4);
  double hP=1.0e-12;
  SummaryStatistics residualsP0=new SummaryStatistics();
  SummaryStatistics residualsP1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    double[] y={1.3,b};
    integ.integrate(brusselator,0,y,20.0,y);
    double[] yP={1.3,b + hP};
    brusselator.setParameter(0,b + hP);
    integ.integrate(brusselator,0,yP,20.0,yP);
    residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());
    residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());
  }
  Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 600);
  Assert.assertTrue(residualsP0.getStandardDeviation() > 30);
  Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 800);
  Assert.assertTrue(residualsP1.getStandardDeviation() > 50);
}"
57413,"@Test public void testHighAccuracyExternalDifferentiation() throws IntegratorException, DerivativeException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-10,1.0e-10);
  double hP=1.0e-12;
  SummaryStatistics residuals0=new SummaryStatistics();
  SummaryStatistics residuals1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    double[] y={1.3,b};
    integ.integrate(brusselator,0,y,20.0,y);
    double[] yP={1.3,b + hP};
    brusselator.setParameter(0,b + hP);
    integ.integrate(brusselator,0,yP,20.0,yP);
    residuals0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());
    residuals1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());
  }
  Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) > 0.02);
  Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.03);
  Assert.assertTrue(residuals0.getStandardDeviation() > 0.003);
  Assert.assertTrue(residuals0.getStandardDeviation() < 0.004);
  Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) > 0.04);
  Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.05);
  Assert.assertTrue(residuals1.getStandardDeviation() > 0.006);
  Assert.assertTrue(residuals1.getStandardDeviation() < 0.007);
}","@Test public void testHighAccuracyExternalDifferentiation() throws IntegratorException, DerivativeException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-10,1.0e-10);
  double hP=1.0e-12;
  SummaryStatistics residualsP0=new SummaryStatistics();
  SummaryStatistics residualsP1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    double[] y={1.3,b};
    integ.integrate(brusselator,0,y,20.0,y);
    double[] yP={1.3,b + hP};
    brusselator.setParameter(0,b + hP);
    integ.integrate(brusselator,0,yP,20.0,yP);
    residualsP0.addValue((yP[0] - y[0]) / hP - brusselator.dYdP0());
    residualsP1.addValue((yP[1] - y[1]) / hP - brusselator.dYdP1());
  }
  Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) > 0.02);
  Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.03);
  Assert.assertTrue(residualsP0.getStandardDeviation() > 0.003);
  Assert.assertTrue(residualsP0.getStandardDeviation() < 0.004);
  Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) > 0.04);
  Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.05);
  Assert.assertTrue(residualsP1.getStandardDeviation() > 0.006);
  Assert.assertTrue(residualsP1.getStandardDeviation() < 0.007);
}"
57414,"@Test public void testAnalyticalDifferentiation() throws IntegratorException, DerivativeException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-4,1.0e-4);
  SummaryStatistics residuals0=new SummaryStatistics();
  SummaryStatistics residuals1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    brusselator.setParameter(0,b);
    double[] z={1.3,b};
    double[][] dZdZ0=new double[2][2];
    double[][] dZdP=new double[2][1];
    FirstOrderIntegratorWithJacobians extInt=new FirstOrderIntegratorWithJacobians(integ,brusselator);
    extInt.integrate(0,z,new double[][]{{0.0},{1.0}},20.0,z,dZdZ0,dZdP);
    residuals0.addValue(dZdP[0][0] - brusselator.dYdP0());
    residuals1.addValue(dZdP[1][0] - brusselator.dYdP1());
  }
  Assert.assertTrue((residuals0.getMax() - residuals0.getMin()) < 0.004);
  Assert.assertTrue(residuals0.getStandardDeviation() < 0.001);
  Assert.assertTrue((residuals1.getMax() - residuals1.getMin()) < 0.005);
  Assert.assertTrue(residuals1.getStandardDeviation() < 0.001);
}","@Test public void testAnalyticalDifferentiation() throws IntegratorException, DerivativeException, OptimizationException {
  FirstOrderIntegrator integ=new DormandPrince54Integrator(1.0e-8,100.0,1.0e-10,1.0e-10);
  SummaryStatistics residualsP0=new SummaryStatistics();
  SummaryStatistics residualsP1=new SummaryStatistics();
  for (double b=2.88; b < 3.08; b+=0.001) {
    Brusselator brusselator=new Brusselator(b);
    brusselator.setParameter(0,b);
    double[] z={1.3,b};
    double[][] dZdZ0=new double[2][2];
    double[][] dZdP=new double[2][1];
    FirstOrderIntegratorWithJacobians extInt=new FirstOrderIntegratorWithJacobians(integ,brusselator);
    extInt.integrate(0,z,new double[][]{{0.0},{1.0}},20.0,z,dZdZ0,dZdP);
    residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());
    residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());
  }
  Assert.assertTrue((residualsP0.getMax() - residualsP0.getMin()) < 0.004);
  Assert.assertTrue(residualsP0.getStandardDeviation() < 0.0008);
  Assert.assertTrue((residualsP1.getMax() - residualsP1.getMin()) < 0.005);
  Assert.assertTrue(residualsP1.getStandardDeviation() < 0.0010);
}"
57415,"public double dYdP1(){
  return 1499.0904666097015 + (-1434.9574631810726 + (459.71079478756945 - 49.29949940968588 * b) * b) * b;
}","public double dYdP1(){
  return 1502.824469929139 + (-1438.6974831849952 + (460.959476642384 - 49.43847385647082 * b) * b) * b;
}"
57416,"/** 
 * <p> Multiplies the value of this fraction by another, returning the result in reduced form. </p>
 * @param fraction the fraction to multiply by, must not be <code>null</code>.
 * @return a {@link BigFraction} instance with the resulting values.
 * @throws NullPointerException if the fraction is <code>null</code>.
 */
public BigFraction multiply(final BigFraction fraction){
  BigFraction ret=ZERO;
  if (getNumeratorAsInt() != 0 && fraction.getNumeratorAsInt() != 0) {
    ret=new BigFraction(numerator.multiply(fraction.numerator),denominator.multiply(fraction.denominator));
  }
  return ret;
}","/** 
 * <p> Multiplies the value of this fraction by another, returning the result in reduced form. </p>
 * @param fraction the fraction to multiply by, must not be <code>null</code>.
 * @return a {@link BigFraction} instance with the resulting values.
 * @throws NullPointerException if the fraction is <code>null</code>.
 */
public BigFraction multiply(final BigFraction fraction){
  if (numerator.equals(BigInteger.ZERO) || fraction.numerator.equals(BigInteger.ZERO)) {
    return ZERO;
  }
  return new BigFraction(numerator.multiply(fraction.numerator),denominator.multiply(fraction.denominator));
}"
57417,"protected OpenMapSparseIterator(){
  iter=entries.iterator();
  current=new OpenMapEntry(iter);
}","/** 
 * Simple constructor. 
 */
protected OpenMapSparseIterator(){
  iter=entries.iterator();
  current=new OpenMapEntry(iter);
}"
57418,"/** 
 * {@InheritDoc} 
 */
public boolean hasNext(){
  return iter.hasNext();
}","/** 
 * {@inheritDoc} 
 */
public boolean hasNext(){
  return iter.hasNext();
}"
57419,"protected OpenMapEntry(Iterator iter){
  this.iter=iter;
}","/** 
 * Build an entry from an iterator point to an element.
 * @param iter iterator pointing to the entry
 */
protected OpenMapEntry(Iterator iter){
  this.iter=iter;
}"
57420,"/** 
 * {@InheritDoc} 
 */
@Override public int getIndex(){
  return iter.key();
}","/** 
 * {@inheritDoc} 
 */
@Override public int getIndex(){
  return iter.key();
}"
57421,"/** 
 * {@InheritDoc} 
 */
public Entry next(){
  iter.advance();
  return current;
}","/** 
 * {@inheritDoc} 
 */
public Entry next(){
  iter.advance();
  return current;
}"
57422,"/** 
 * @{InheritDoc } 
 */
public java.util.Iterator<Entry> sparseIterator(){
  return new OpenMapSparseIterator();
}","/** 
 * {@inheritDoc} 
 */
public java.util.Iterator<Entry> sparseIterator(){
  return new OpenMapSparseIterator();
}"
57423,"public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","/** 
 * {@inheritDoc} 
 */
public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
57424,"/** 
 * {@InheritDoc} 
 */
@Override public double getValue(){
  return iter.value();
}","/** 
 * {@inheritDoc} 
 */
@Override public double getValue(){
  return iter.value();
}"
57425,"/** 
 * {@InheritDoc} 
 */
@Override public void setValue(double value){
  entries.put(iter.key(),value);
}","/** 
 * {@inheritDoc} 
 */
@Override public void setValue(double value){
  entries.put(iter.key(),value);
}"
57426,"/** 
 * Evaluate the impact of the proposed step on the event handler.
 * @param interpolator step interpolator for the proposed step
 * @return true if the event handler triggers an event beforethe end of the proposed step (this implies the step should be rejected)
 * @exception DerivativeException if the interpolator fails tocompute the switching function somewhere within the step
 * @exception EventException if the switching functioncannot be evaluated
 * @exception ConvergenceException if an event cannot be located
 */
public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {
  try {
    forward=interpolator.isForward();
    final double t1=interpolator.getCurrentTime();
    final int n=Math.max(1,(int)Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
    final double h=(t1 - t0) / n;
    double ta=t0;
    double ga=g0;
    double tb=t0 + (interpolator.isForward() ? convergence : -convergence);
    for (int i=0; i < n; ++i) {
      tb+=h;
      interpolator.setInterpolatedTime(tb);
      final double gb=handler.g(tb,interpolator.getInterpolatedState());
      if (g0Positive ^ (gb >= 0)) {
        increasing=gb >= ga;
        final UnivariateRealFunction f=new UnivariateRealFunction(){
          public double value(          final double t) throws FunctionEvaluationException {
            try {
              interpolator.setInterpolatedTime(t);
              return handler.g(t,interpolator.getInterpolatedState());
            }
 catch (            DerivativeException e) {
              throw new FunctionEvaluationException(e,t);
            }
catch (            EventException e) {
              throw new FunctionEvaluationException(e,t);
            }
          }
        }
;
        final BrentSolver solver=new BrentSolver();
        solver.setAbsoluteAccuracy(convergence);
        solver.setMaximalIterationCount(maxIterationCount);
        double root;
        try {
          root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);
        }
 catch (        IllegalArgumentException iae) {
          root=Double.NaN;
        }
        if (Double.isNaN(root) || ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence))) {
          ta=tb;
          ga=gb;
        }
 else         if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
          pendingEventTime=root;
          if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
            return false;
          }
          pendingEvent=true;
          return true;
        }
      }
 else {
        ta=tb;
        ga=gb;
      }
    }
    pendingEvent=false;
    pendingEventTime=Double.NaN;
    return false;
  }
 catch (  FunctionEvaluationException e) {
    final Throwable cause=e.getCause();
    if ((cause != null) && (cause instanceof DerivativeException)) {
      throw (DerivativeException)cause;
    }
 else     if ((cause != null) && (cause instanceof EventException)) {
      throw (EventException)cause;
    }
    throw new EventException(e);
  }
}","/** 
 * Evaluate the impact of the proposed step on the event handler.
 * @param interpolator step interpolator for the proposed step
 * @return true if the event handler triggers an event beforethe end of the proposed step (this implies the step should be rejected)
 * @exception DerivativeException if the interpolator fails tocompute the switching function somewhere within the step
 * @exception EventException if the switching functioncannot be evaluated
 * @exception ConvergenceException if an event cannot be located
 */
public boolean evaluateStep(final StepInterpolator interpolator) throws DerivativeException, EventException, ConvergenceException {
  try {
    forward=interpolator.isForward();
    final double t1=interpolator.getCurrentTime();
    final int n=Math.max(1,(int)Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
    final double h=(t1 - t0) / n;
    double ta=t0;
    double ga=g0;
    double tb=t0 + (interpolator.isForward() ? convergence : -convergence);
    for (int i=0; i < n; ++i) {
      tb+=h;
      interpolator.setInterpolatedTime(tb);
      final double gb=handler.g(tb,interpolator.getInterpolatedState());
      if (g0Positive ^ (gb >= 0)) {
        if (ga * gb > 0) {
          final double epsilon=(forward ? 0.25 : -0.25) * convergence;
          for (int k=0; (k < 4) && (ga * gb > 0); ++k) {
            ta+=epsilon;
            interpolator.setInterpolatedTime(ta);
            ga=handler.g(ta,interpolator.getInterpolatedState());
          }
          if (ga * gb > 0) {
            throw MathRuntimeException.createInternalError(null);
          }
        }
        increasing=gb >= ga;
        final UnivariateRealFunction f=new UnivariateRealFunction(){
          public double value(          final double t) throws FunctionEvaluationException {
            try {
              interpolator.setInterpolatedTime(t);
              return handler.g(t,interpolator.getInterpolatedState());
            }
 catch (            DerivativeException e) {
              throw new FunctionEvaluationException(e,t);
            }
catch (            EventException e) {
              throw new FunctionEvaluationException(e,t);
            }
          }
        }
;
        final BrentSolver solver=new BrentSolver();
        solver.setAbsoluteAccuracy(convergence);
        solver.setMaximalIterationCount(maxIterationCount);
        final double root=(ta <= tb) ? solver.solve(f,ta,tb) : solver.solve(f,tb,ta);
        if ((Math.abs(root - ta) <= convergence) && (Math.abs(root - previousEventTime) <= convergence)) {
          ta=tb;
          ga=gb;
        }
 else         if (Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - root) > convergence)) {
          pendingEventTime=root;
          if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
            return false;
          }
          pendingEvent=true;
          return true;
        }
      }
 else {
        ta=tb;
        ga=gb;
      }
    }
    pendingEvent=false;
    pendingEventTime=Double.NaN;
    return false;
  }
 catch (  FunctionEvaluationException e) {
    final Throwable cause=e.getCause();
    if ((cause != null) && (cause instanceof DerivativeException)) {
      throw (DerivativeException)cause;
    }
 else     if ((cause != null) && (cause instanceof EventException)) {
      throw (EventException)cause;
    }
    throw new EventException(e);
  }
}"
57427,"/** 
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */
public static double distance(int[] p1,int[] p2){
  int sum=0;
  for (int i=0; i < p1.length; i++) {
    final int dp=p1[i] - p2[i];
    sum+=dp * dp;
  }
  return Math.sqrt(sum);
}","/** 
 * Calculates the L<sub>2</sub> (Euclidean) distance between two points.
 * @param p1 the first point
 * @param p2 the second point
 * @return the L<sub>2</sub> distance between the two points
 */
public static double distance(int[] p1,int[] p2){
  double sum=0;
  for (int i=0; i < p1.length; i++) {
    final double dp=p1[i] - p2[i];
    sum+=dp * dp;
  }
  return Math.sqrt(sum);
}"
57428,"/** 
 * Find realEigenvalues using dqd/dqds algorithms. <p>This implementation is based on Beresford N. Parlett and Osni A. Marques paper <a href=""http://www.netlib.org/lapack/lawnspdf/lawn155.pdf"">An Implementation of the dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routine DLASQ2.</p>
 * @param n number of rows of the block
 * @exception InvalidMatrixException if block cannot be diagonalizedafter 30 * n iterations
 */
private void processGeneralBlock(final int n) throws InvalidMatrixException {
  double sumOffDiag=0;
  for (int i=0; i < n - 1; ++i) {
    final int fourI=4 * i;
    final double ei=work[fourI + 2];
    sumOffDiag+=ei;
  }
  if (sumOffDiag == 0) {
    return;
  }
  flipIfWarranted(n,2);
  initialSplits(n);
  tType=0;
  dMin1=0;
  dMin2=0;
  dN=0;
  dN1=0;
  dN2=0;
  tau=0;
  int i0=0;
  int n0=n;
  while (n0 > 0) {
    sigma=(n0 == n) ? 0 : -work[4 * n0 - 2];
    sigmaLow=0;
    double offDiagMin=(i0 == n0) ? 0 : work[4 * n0 - 6];
    double offDiagMax=0;
    double diagMax=work[4 * n0 - 4];
    double diagMin=diagMax;
    i0=0;
    for (int i=4 * (n0 - 2); i >= 0; i-=4) {
      if (work[i + 2] <= 0) {
        i0=1 + i / 4;
        break;
      }
      if (diagMin >= 4 * offDiagMax) {
        diagMin=Math.min(diagMin,work[i + 4]);
        offDiagMax=Math.max(offDiagMax,work[i + 2]);
      }
      diagMax=Math.max(diagMax,work[i] + work[i + 2]);
      offDiagMin=Math.min(offDiagMin,work[i + 2]);
    }
    work[4 * n0 - 2]=offDiagMin;
    dMin=-Math.max(0,diagMin - 2 * Math.sqrt(diagMin * offDiagMax));
    pingPong=0;
    int maxIter=30 * (n0 - i0);
    for (int k=0; i0 < n0; ++k) {
      if (k >= maxIter) {
        throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
      }
      n0=goodStep(i0,n0);
      pingPong=1 - pingPong;
      if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax)&& (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
        int split=i0 - 1;
        diagMax=work[4 * i0];
        offDiagMin=work[4 * i0 + 2];
        double previousEMin=work[4 * i0 + 3];
        for (int i=4 * i0; i < 4 * n0 - 16; i+=4) {
          if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) {
            work[i + 2]=-sigma;
            split=i / 4;
            diagMax=0;
            offDiagMin=work[i + 6];
            previousEMin=work[i + 7];
          }
 else {
            diagMax=Math.max(diagMax,work[i + 4]);
            offDiagMin=Math.min(offDiagMin,work[i + 2]);
            previousEMin=Math.min(previousEMin,work[i + 3]);
          }
        }
        work[4 * n0 - 2]=offDiagMin;
        work[4 * n0 - 1]=previousEMin;
        i0=split + 1;
      }
    }
  }
}","/** 
 * Find realEigenvalues using dqd/dqds algorithms. <p>This implementation is based on Beresford N. Parlett and Osni A. Marques paper <a href=""http://www.netlib.org/lapack/lawnspdf/lawn155.pdf"">An Implementation of the dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routine DLASQ2.</p>
 * @param n number of rows of the block
 * @exception InvalidMatrixException if block cannot be diagonalizedafter 30 * n iterations
 */
private void processGeneralBlock(final int n) throws InvalidMatrixException {
  double sumOffDiag=0;
  for (int i=0; i < n - 1; ++i) {
    final int fourI=4 * i;
    final double ei=work[fourI + 2];
    sumOffDiag+=ei;
  }
  if (sumOffDiag == 0) {
    return;
  }
  flipEveryOtherIfWarranted(n);
  initialSplits(n);
  tType=0;
  dMin1=0;
  dMin2=0;
  dN=0;
  dN1=0;
  dN2=0;
  tau=0;
  int i0=0;
  int n0=n;
  while (n0 > 0) {
    sigma=(n0 == n) ? 0 : -work[4 * n0 - 2];
    sigmaLow=0;
    double offDiagMin=(i0 == n0) ? 0 : work[4 * n0 - 6];
    double offDiagMax=0;
    double diagMax=work[4 * n0 - 4];
    double diagMin=diagMax;
    i0=0;
    for (int i=4 * (n0 - 2); i >= 0; i-=4) {
      if (work[i + 2] <= 0) {
        i0=1 + i / 4;
        break;
      }
      if (diagMin >= 4 * offDiagMax) {
        diagMin=Math.min(diagMin,work[i + 4]);
        offDiagMax=Math.max(offDiagMax,work[i + 2]);
      }
      diagMax=Math.max(diagMax,work[i] + work[i + 2]);
      offDiagMin=Math.min(offDiagMin,work[i + 2]);
    }
    work[4 * n0 - 2]=offDiagMin;
    dMin=-Math.max(0,diagMin - 2 * Math.sqrt(diagMin * offDiagMax));
    pingPong=0;
    int maxIter=30 * (n0 - i0);
    for (int k=0; i0 < n0; ++k) {
      if (k >= maxIter) {
        throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
      }
      n0=goodStep(i0,n0);
      pingPong=1 - pingPong;
      if ((pingPong == 0) && (n0 - i0 > 3) && (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax)&& (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
        int split=i0 - 1;
        diagMax=work[4 * i0];
        offDiagMin=work[4 * i0 + 2];
        double previousEMin=work[4 * i0 + 3];
        for (int i=4 * i0; i < 4 * n0 - 16; i+=4) {
          if ((work[i + 3] <= TOLERANCE_2 * work[i]) || (work[i + 2] <= TOLERANCE_2 * sigma)) {
            work[i + 2]=-sigma;
            split=i / 4;
            diagMax=0;
            offDiagMin=work[i + 6];
            previousEMin=work[i + 7];
          }
 else {
            diagMax=Math.max(diagMax,work[i + 4]);
            offDiagMin=Math.min(offDiagMin,work[i + 2]);
            previousEMin=Math.min(previousEMin,work[i + 3]);
          }
        }
        work[4 * n0 - 2]=offDiagMin;
        work[4 * n0 - 1]=previousEMin;
        i0=split + 1;
      }
    }
  }
}"
57429,"/** 
 * Perform one ""good"" dqd/dqds step. <p>This implementation is based on Beresford N. Parlett and Osni A. Marques paper <a href=""http://www.netlib.org/lapack/lawnspdf/lawn155.pdf"">An Implementation of the dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routine DLAZQ3.</p>
 * @param start start index
 * @param end end index
 * @return new end (maybe deflated)
 */
private int goodStep(final int start,final int end){
  g=0.0;
  int deflatedEnd=end;
  for (boolean deflating=true; deflating; ) {
    if (start >= deflatedEnd) {
      return deflatedEnd;
    }
    final int k=4 * deflatedEnd + pingPong - 1;
    if ((start == deflatedEnd - 1) || ((start != deflatedEnd - 2) && ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) || (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {
      work[4 * deflatedEnd - 4]=sigma + work[4 * deflatedEnd - 4 + pingPong];
      deflatedEnd-=1;
    }
 else     if ((start == deflatedEnd - 2) || (work[k - 9] <= TOLERANCE_2 * sigma) || (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {
      if (work[k - 3] > work[k - 7]) {
        final double tmp=work[k - 3];
        work[k - 3]=work[k - 7];
        work[k - 7]=tmp;
      }
      if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
        double t=0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
        double s=work[k - 3] * (work[k - 5] / t);
        if (s <= t) {
          s=work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
        }
 else {
          s=work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
        }
        t=work[k - 7] + (s + work[k - 5]);
        work[k - 3]*=work[k - 7] / t;
        work[k - 7]=t;
      }
      work[4 * deflatedEnd - 8]=sigma + work[k - 7];
      work[4 * deflatedEnd - 4]=sigma + work[k - 3];
      deflatedEnd-=2;
    }
 else {
      deflating=false;
    }
  }
  final int l=4 * deflatedEnd + pingPong - 1;
  if ((dMin <= 0) || (deflatedEnd < end)) {
    if (flipIfWarranted(deflatedEnd,1)) {
      dMin2=Math.min(dMin2,work[l - 1]);
      work[l - 1]=Math.min(work[l - 1],Math.min(work[3 + pingPong],work[7 + pingPong]));
      work[l - 2 * pingPong]=Math.min(work[l - 2 * pingPong],Math.min(work[6 + pingPong],work[6 + pingPong]));
      qMax=Math.max(qMax,Math.max(work[3 + pingPong],work[7 + pingPong]));
      dMin=-0.0;
    }
  }
  if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],Math.min(work[l - 9],dMin2 + work[l - 2 * pingPong])))) {
    computeShiftIncrement(start,deflatedEnd,end - deflatedEnd);
    for (boolean loop=true; loop; ) {
      dqds(start,deflatedEnd);
      if ((dMin >= 0) && (dMin1 > 0)) {
        updateSigma(tau);
        return deflatedEnd;
      }
 else       if ((dMin < 0.0) && (dMin1 > 0.0) && (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1))&& (Math.abs(dN) < TOLERANCE * sigma)) {
        work[4 * deflatedEnd - 3 - pingPong]=0.0;
        dMin=0.0;
        updateSigma(tau);
        return deflatedEnd;
      }
 else       if (dMin < 0.0) {
        if (tType < -22) {
          tau=0.0;
        }
 else         if (dMin1 > 0.0) {
          tau=(tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);
          tType-=11;
        }
 else {
          tau*=0.25;
          tType-=12;
        }
      }
 else       if (Double.isNaN(dMin)) {
        tau=0.0;
      }
 else {
        loop=false;
      }
    }
  }
  dqd(start,deflatedEnd);
  return deflatedEnd;
}","/** 
 * Perform one ""good"" dqd/dqds step. <p>This implementation is based on Beresford N. Parlett and Osni A. Marques paper <a href=""http://www.netlib.org/lapack/lawnspdf/lawn155.pdf"">An Implementation of the dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routine DLAZQ3.</p>
 * @param start start index
 * @param end end index
 * @return new end (maybe deflated)
 */
private int goodStep(final int start,final int end){
  g=0.0;
  int deflatedEnd=end;
  for (boolean deflating=true; deflating; ) {
    if (start >= deflatedEnd) {
      return deflatedEnd;
    }
    final int k=4 * deflatedEnd + pingPong - 1;
    if ((start == deflatedEnd - 1) || ((start != deflatedEnd - 2) && ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) || (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {
      work[4 * deflatedEnd - 4]=sigma + work[4 * deflatedEnd - 4 + pingPong];
      deflatedEnd-=1;
    }
 else     if ((start == deflatedEnd - 2) || (work[k - 9] <= TOLERANCE_2 * sigma) || (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {
      if (work[k - 3] > work[k - 7]) {
        final double tmp=work[k - 3];
        work[k - 3]=work[k - 7];
        work[k - 7]=tmp;
      }
      if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
        double t=0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
        double s=work[k - 3] * (work[k - 5] / t);
        if (s <= t) {
          s=work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
        }
 else {
          s=work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
        }
        t=work[k - 7] + (s + work[k - 5]);
        work[k - 3]*=work[k - 7] / t;
        work[k - 7]=t;
      }
      work[4 * deflatedEnd - 8]=sigma + work[k - 7];
      work[4 * deflatedEnd - 4]=sigma + work[k - 3];
      deflatedEnd-=2;
    }
 else {
      deflating=false;
    }
  }
  final int l=4 * deflatedEnd + pingPong - 1;
  if ((dMin <= 0) || (deflatedEnd < end)) {
    if (flipAllIfWarranted(deflatedEnd)) {
      dMin2=Math.min(dMin2,work[l - 1]);
      work[l - 1]=Math.min(work[l - 1],Math.min(work[3 + pingPong],work[7 + pingPong]));
      work[l - 2 * pingPong]=Math.min(work[l - 2 * pingPong],Math.min(work[6 + pingPong],work[6 + pingPong]));
      qMax=Math.max(qMax,Math.max(work[3 + pingPong],work[7 + pingPong]));
      dMin=-0.0;
    }
  }
  if ((dMin < 0) || (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],Math.min(work[l - 9],dMin2 + work[l - 2 * pingPong])))) {
    computeShiftIncrement(start,deflatedEnd,end - deflatedEnd);
    for (boolean loop=true; loop; ) {
      dqds(start,deflatedEnd);
      if ((dMin >= 0) && (dMin1 > 0)) {
        updateSigma(tau);
        return deflatedEnd;
      }
 else       if ((dMin < 0.0) && (dMin1 > 0.0) && (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1))&& (Math.abs(dN) < TOLERANCE * sigma)) {
        work[4 * deflatedEnd - 3 - pingPong]=0.0;
        dMin=0.0;
        updateSigma(tau);
        return deflatedEnd;
      }
 else       if (dMin < 0.0) {
        if (tType < -22) {
          tau=0.0;
        }
 else         if (dMin1 > 0.0) {
          tau=(tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);
          tType-=11;
        }
 else {
          tau*=0.25;
          tType-=12;
        }
      }
 else       if (Double.isNaN(dMin)) {
        tau=0.0;
      }
 else {
        loop=false;
      }
    }
  }
  dqd(start,deflatedEnd);
  return deflatedEnd;
}"
57430,"/** 
 * Flip qd array if warranted.
 * @param n number of rows in the block
 * @param step within the array (1 for flipping all elements, 2 for flippingonly every other element)
 * @return true if qd array was flipped
 */
private boolean flipIfWarranted(final int n,final int step){
  if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
    int j=4 * n - 1;
    for (int i=0; i < j; i+=4) {
      for (int k=0; k < 4; k+=step) {
        final double tmp=work[i + k];
        work[i + k]=work[j - k];
        work[j - k]=tmp;
      }
      j-=4;
    }
    return true;
  }
  return false;
}","/** 
 * Flip qd array if warranted.
 * @param n number of rows in the block
 * @param step within the array (1 for flipping all elements, 2 for flippingonly every other element)
 * @return true if qd array was flipped
 */
private boolean flipIfWarranted(final int n,final int step){
  if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
    int j=4 * (n - 1);
    for (int i=0; i < j; i+=4) {
      for (int k=0; k < 4; k+=step) {
        final double tmp=work[i + k];
        work[i + k]=work[j - k];
        work[j - k]=tmp;
      }
      j-=4;
    }
    return true;
  }
  return false;
}"
57431,"/** 
 * Constructor
 * @param dfbg degrees of freedom in numerator (between groups)
 * @param dfwg degrees of freedom in denominator (within groups)
 * @param F statistic
 */
AnovaStats(int dfbg,int dfwg,double F){
  this.dfbg=dfbg;
  this.dfwg=dfwg;
  this.F=F;
}","/** 
 * Constructor
 * @param dfbg degrees of freedom in numerator (between groups)
 * @param dfwg degrees of freedom in denominator (within groups)
 * @param F statistic
 */
public AnovaStats(int dfbg,int dfwg,double F){
  this.dfbg=dfbg;
  this.dfwg=dfwg;
  this.F=F;
}"
57432,"/** 
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(final int col,final SimplexTableau tableau){
  double minRatio=Double.MAX_VALUE;
  Integer minRatioPos=null;
  for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
    double rhs=tableau.getEntry(i,tableau.getWidth() - 1);
    if (MathUtils.compareTo(tableau.getEntry(i,col),0,epsilon) >= 0) {
      double ratio=rhs / tableau.getEntry(i,col);
      if (ratio < minRatio) {
        minRatio=ratio;
        minRatioPos=i;
      }
    }
  }
  return minRatioPos;
}","/** 
 * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).
 * @param tableau simple tableau for the problem
 * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}
 * @return row with the minimum ratio
 */
private Integer getPivotRow(final int col,final SimplexTableau tableau){
  double minRatio=Double.MAX_VALUE;
  Integer minRatioPos=null;
  for (int i=tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
    final double rhs=tableau.getEntry(i,tableau.getWidth() - 1);
    final double entry=tableau.getEntry(i,col);
    if (MathUtils.compareTo(entry,0,epsilon) > 0) {
      final double ratio=rhs / entry;
      if (ratio < minRatio) {
        minRatio=ratio;
        minRatioPos=i;
      }
    }
  }
  return minRatioPos;
}"
57433,"/** 
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
protected double[][] createTableau(final boolean maximize){
  List<LinearConstraint> constraints=getNormalizedConstraints();
  int width=numDecisionVariables + numSlackVariables + numArtificialVariables+ getNumObjectiveFunctions()+ 1;
  int height=constraints.size() + getNumObjectiveFunctions();
  double[][] matrix=new double[height][width];
  if (getNumObjectiveFunctions() == 2) {
    matrix[0][0]=-1;
  }
  int zIndex=(getNumObjectiveFunctions() == 1) ? 0 : 1;
  matrix[zIndex][zIndex]=maximize ? 1 : -1;
  RealVector objectiveCoefficients=maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
  copyArray(objectiveCoefficients.getData(),matrix[zIndex],getNumObjectiveFunctions());
  matrix[zIndex][width - 1]=maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
  if (!restrictToNonNegative) {
    matrix[zIndex][getSlackVariableOffset() - 1]=getInvertedCoeffiecientSum(objectiveCoefficients);
  }
  int slackVar=0;
  int artificialVar=0;
  for (int i=0; i < constraints.size(); i++) {
    LinearConstraint constraint=constraints.get(i);
    int row=getNumObjectiveFunctions() + i;
    copyArray(constraint.getCoefficients().getData(),matrix[row],1);
    if (!restrictToNonNegative) {
      matrix[row][getSlackVariableOffset() - 1]=getInvertedCoeffiecientSum(constraint.getCoefficients());
    }
    matrix[row][width - 1]=constraint.getValue();
    if (constraint.getRelationship() == Relationship.LEQ) {
      matrix[row][getSlackVariableOffset() + slackVar++]=1;
    }
 else     if (constraint.getRelationship() == Relationship.GEQ) {
      matrix[row][getSlackVariableOffset() + slackVar++]=-1;
    }
    if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
      matrix[0][getArtificialVariableOffset() + artificialVar]=1;
      matrix[row][getArtificialVariableOffset() + artificialVar++]=1;
    }
  }
  return matrix;
}","/** 
 * Create the tableau by itself.
 * @param maximize if true, goal is to maximize the objective function
 * @return created tableau
 */
protected double[][] createTableau(final boolean maximize){
  int width=numDecisionVariables + numSlackVariables + numArtificialVariables+ getNumObjectiveFunctions()+ 1;
  int height=constraints.size() + getNumObjectiveFunctions();
  double[][] matrix=new double[height][width];
  if (getNumObjectiveFunctions() == 2) {
    matrix[0][0]=-1;
  }
  int zIndex=(getNumObjectiveFunctions() == 1) ? 0 : 1;
  matrix[zIndex][zIndex]=maximize ? 1 : -1;
  RealVector objectiveCoefficients=maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
  copyArray(objectiveCoefficients.getData(),matrix[zIndex],getNumObjectiveFunctions());
  matrix[zIndex][width - 1]=maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();
  if (!restrictToNonNegative) {
    matrix[zIndex][getSlackVariableOffset() - 1]=getInvertedCoeffiecientSum(objectiveCoefficients);
  }
  int slackVar=0;
  int artificialVar=0;
  for (int i=0; i < constraints.size(); i++) {
    LinearConstraint constraint=constraints.get(i);
    int row=getNumObjectiveFunctions() + i;
    copyArray(constraint.getCoefficients().getData(),matrix[row],1);
    if (!restrictToNonNegative) {
      matrix[row][getSlackVariableOffset() - 1]=getInvertedCoeffiecientSum(constraint.getCoefficients());
    }
    matrix[row][width - 1]=constraint.getValue();
    if (constraint.getRelationship() == Relationship.LEQ) {
      matrix[row][getSlackVariableOffset() + slackVar++]=1;
    }
 else     if (constraint.getRelationship() == Relationship.GEQ) {
      matrix[row][getSlackVariableOffset() + slackVar++]=-1;
    }
    if ((constraint.getRelationship() == Relationship.EQ) || (constraint.getRelationship() == Relationship.GEQ)) {
      matrix[0][getArtificialVariableOffset() + artificialVar]=1;
      matrix[row][getArtificialVariableOffset() + artificialVar++]=1;
    }
  }
  return matrix;
}"
57434,"/** 
 * Build a tableau for a linear problem.
 * @param f linear objective function
 * @param constraints linear constraints
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or   {@link GoalType#MINIMIZE}
 * @param restrictToNonNegative whether to restrict the variables to non-negative values
 * @param epsilon amount of error to accept in floating point comparisons
 */
SimplexTableau(final LinearObjectiveFunction f,final Collection<LinearConstraint> constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon){
  this.f=f;
  this.constraints=constraints;
  this.restrictToNonNegative=restrictToNonNegative;
  this.epsilon=epsilon;
  this.numDecisionVariables=getNumVariables() + (restrictToNonNegative ? 0 : 1);
  this.numSlackVariables=getConstraintTypeCounts(Relationship.LEQ) + getConstraintTypeCounts(Relationship.GEQ);
  this.numArtificialVariables=getConstraintTypeCounts(Relationship.EQ) + getConstraintTypeCounts(Relationship.GEQ);
  this.tableau=new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));
  initialize();
}","/** 
 * Build a tableau for a linear problem.
 * @param f linear objective function
 * @param constraints linear constraints
 * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}or   {@link GoalType#MINIMIZE}
 * @param restrictToNonNegative whether to restrict the variables to non-negative values
 * @param epsilon amount of error to accept in floating point comparisons
 */
SimplexTableau(final LinearObjectiveFunction f,final Collection<LinearConstraint> constraints,final GoalType goalType,final boolean restrictToNonNegative,final double epsilon){
  this.f=f;
  this.constraints=normalizeConstraints(constraints);
  this.restrictToNonNegative=restrictToNonNegative;
  this.epsilon=epsilon;
  this.numDecisionVariables=getNumVariables() + (restrictToNonNegative ? 0 : 1);
  this.numSlackVariables=getConstraintTypeCounts(Relationship.LEQ) + getConstraintTypeCounts(Relationship.GEQ);
  this.numArtificialVariables=getConstraintTypeCounts(Relationship.EQ) + getConstraintTypeCounts(Relationship.GEQ);
  this.tableau=new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));
  initialize();
}"
57435,"/** 
 * Get the current solution.
 * @return current solution
 */
protected RealPointValuePair getSolution(){
  double[] coefficients=new double[getOriginalNumDecisionVariables()];
  Integer basicRow=getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
  double mostNegative=basicRow == null ? 0 : getEntry(basicRow,getRhsOffset());
  Set<Integer> basicRows=new HashSet<Integer>();
  for (int i=0; i < coefficients.length; i++) {
    basicRow=getBasicRow(getNumObjectiveFunctions() + i);
    if (basicRows.contains(basicRow)) {
      coefficients[i]=0;
    }
 else {
      basicRows.add(basicRow);
      coefficients[i]=(basicRow == null ? 0 : getEntry(basicRow,getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
    }
  }
  return new RealPointValuePair(coefficients,f.getValue(coefficients));
}","/** 
 * Get the current solution.
 * @return current solution
 */
protected RealPointValuePair getSolution(){
  double[] coefficients=new double[getOriginalNumDecisionVariables()];
  Integer negativeVarBasicRow=getBasicRowForSolution(getNegativeDecisionVariableOffset());
  double mostNegative=negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow,getRhsOffset());
  Set<Integer> basicRows=new HashSet<Integer>();
  for (int i=0; i < coefficients.length; i++) {
    Integer basicRow=getBasicRowForSolution(getNumObjectiveFunctions() + i);
    if (basicRows.contains(basicRow)) {
      coefficients[i]=0;
    }
 else {
      basicRows.add(basicRow);
      coefficients[i]=(basicRow == null ? 0 : getEntry(basicRow,getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
    }
  }
  return new RealPointValuePair(coefficients,f.getValue(coefficients));
}"
57436,"/** 
 * Checks whether the given column is basic.
 * @param col index of the column to check
 * @return the row that the variable is basic in.  null if the column is not basic
 */
private Integer getBasicRow(final int col){
  Integer row=null;
  for (int i=getNumObjectiveFunctions(); i < getHeight(); i++) {
    if (MathUtils.equals(getEntry(i,col),1.0,epsilon) && (row == null)) {
      row=i;
    }
 else     if (!MathUtils.equals(getEntry(i,col),0.0,epsilon)) {
      return null;
    }
  }
  return row;
}","/** 
 * Checks whether the given column is basic.
 * @param col index of the column to check
 * @return the row that the variable is basic in.  null if the column is not basic
 */
private Integer getBasicRow(final int col,boolean ignoreObjectiveRows){
  Integer row=null;
  int start=ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
  for (int i=start; i < getHeight(); i++) {
    if (MathUtils.equals(getEntry(i,col),1.0,epsilon) && (row == null)) {
      row=i;
    }
 else     if (!MathUtils.equals(getEntry(i,col),0.0,epsilon)) {
      return null;
    }
  }
  return row;
}"
57437,"/** 
 * Get all the optima found during the last call to   {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize}. <p>The optimizer stores all the optima found during a set of restarts. The   {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize} method returns the best point only. Thismethod returns all the points found at the end of each starts, including the best one already returned by the  {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize}method. </p> <p> The returned array as one element for each start as specified in the constructor. It is ordered with the results from the runs that did converge first, sorted from best to worst objective value (i.e in ascending order if minimizing and in descending order if maximizing), followed by and null elements corresponding to the runs that did not converge. This means all elements will be null if the   {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize} method did throw a {@link ConvergenceException ConvergenceException}). This also means that if the first element is non null, it is the best point found across all starts.</p>
 * @return array containing the optima
 * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize} has not been called
 */
public double[] getOptima() throws IllegalStateException {
  if (optima == null) {
    throw MathRuntimeException.createIllegalStateException(""String_Node_Str"");
  }
  return optima.clone();
}","/** 
 * Get all the optima found during the last call to   {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize}. <p>The optimizer stores all the optima found during a set of restarts. The   {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize} method returns the best point only. Thismethod returns all the points found at the end of each starts, including the best one already returned by the  {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize}method. </p> <p> The returned array as one element for each start as specified in the constructor. It is ordered with the results from the runs that did converge first, sorted from best to worst objective value (i.e in ascending order if minimizing and in descending order if maximizing), followed by Double.NaN elements corresponding to the runs that did not converge. This means all elements will be NaN if the   {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize} method did throw a {@link ConvergenceException ConvergenceException}). This also means that if the first element is not NaN, it is the best point found across all starts.</p>
 * @return array containing the optima
 * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,GoalType,double,double) optimize} has not been called
 * @see #getOptimaValues()
 */
public double[] getOptima() throws IllegalStateException {
  if (optima == null) {
    throw MathRuntimeException.createIllegalStateException(""String_Node_Str"");
  }
  return optima.clone();
}"
57438,"/** 
 * Clear the array, reset the size to the initialCapacity and the number  of elements to zero.
 */
public synchronized void clear(){
  numElements=0;
  internalArray=new double[initialCapacity];
}","/** 
 * Clear the array, reset the size to the initialCapacity and the number  of elements to zero.
 */
public synchronized void clear(){
  numElements=0;
  startIndex=0;
  internalArray=new double[initialCapacity];
}"
57439,"/** 
 * Build an integrator with the given stepsize bounds. The default step handler does nothing.
 * @param name name of the method
 * @param minStep minimal step (must be positive even for backwardintegration), the last step can be smaller than this
 * @param maxStep maximal step (must be positive even for backwardintegration)
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */
public AdaptiveStepsizeIntegrator(final String name,final double minStep,final double maxStep,final double[] vecAbsoluteTolerance,final double[] vecRelativeTolerance){
  super(name);
  this.minStep=minStep;
  this.maxStep=maxStep;
  this.initialStep=-1.0;
  this.scalAbsoluteTolerance=0;
  this.scalRelativeTolerance=0;
  this.vecAbsoluteTolerance=vecAbsoluteTolerance;
  this.vecRelativeTolerance=vecRelativeTolerance;
  resetInternalState();
}","/** 
 * Build an integrator with the given stepsize bounds. The default step handler does nothing.
 * @param name name of the method
 * @param minStep minimal step (must be positive even for backwardintegration), the last step can be smaller than this
 * @param maxStep maximal step (must be positive even for backwardintegration)
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 */
public AdaptiveStepsizeIntegrator(final String name,final double minStep,final double maxStep,final double[] vecAbsoluteTolerance,final double[] vecRelativeTolerance){
  super(name);
  this.minStep=minStep;
  this.maxStep=maxStep;
  this.initialStep=-1.0;
  this.scalAbsoluteTolerance=0;
  this.scalRelativeTolerance=0;
  this.vecAbsoluteTolerance=vecAbsoluteTolerance.clone();
  this.vecRelativeTolerance=vecRelativeTolerance.clone();
  resetInternalState();
}"
57440,"@Test public void testRandomPermutation(){
  for (int i=0; i < 10; i++) {
    @SuppressWarnings(""String_Node_Str"") DummyRandomKey drk=new DummyRandomKey(RandomKey.randomPermutation(20));
  }
}","@Test public void testRandomPermutation(){
  for (int i=0; i < 10; i++) {
    DummyRandomKey drk=new DummyRandomKey(RandomKey.randomPermutation(20));
    assertNotNull(drk);
  }
}"
57441,"/** 
 * test trace 
 */
public void testTrace(){
  BigMatrix m=new BigMatrixImpl(id);
  assertEquals(""String_Node_Str"",3d,m.getTrace().doubleValue(),entryTolerance);
  m=new BigMatrixImpl(testData2);
  try {
    m.getTrace().doubleValue();
    fail(""String_Node_Str"");
  }
 catch (  NonSquareMatrixException ex) {
  }
}","/** 
 * test trace 
 */
public void testTrace(){
  BigMatrix m=new BigMatrixImpl(id);
  assertEquals(""String_Node_Str"",3d,m.getTrace().doubleValue(),entryTolerance);
  m=new BigMatrixImpl(testData2);
  try {
    double t=m.getTrace().doubleValue();
    fail(""String_Node_Str"" + t);
  }
 catch (  NonSquareMatrixException ex) {
  }
}"
57442,"/** 
 * test determinant 
 */
public void testDeterminant(){
  BigMatrix m=new BigMatrixImpl(bigSingular);
  assertEquals(""String_Node_Str"",0,m.getDeterminant().doubleValue(),0);
  m=new BigMatrixImpl(detData);
  assertEquals(""String_Node_Str"",-3d,m.getDeterminant().doubleValue(),normTolerance);
  m=new BigMatrixImpl(detData2);
  assertEquals(""String_Node_Str"",-2d,m.getDeterminant().doubleValue(),normTolerance);
  m=new BigMatrixImpl(testData);
  assertEquals(""String_Node_Str"",-1d,m.getDeterminant().doubleValue(),normTolerance);
  try {
    new BigMatrixImpl(testData2).getDeterminant().doubleValue();
    fail(""String_Node_Str"");
  }
 catch (  InvalidMatrixException ex) {
  }
}","/** 
 * test determinant 
 */
public void testDeterminant(){
  BigMatrix m=new BigMatrixImpl(bigSingular);
  assertEquals(""String_Node_Str"",0,m.getDeterminant().doubleValue(),0);
  m=new BigMatrixImpl(detData);
  assertEquals(""String_Node_Str"",-3d,m.getDeterminant().doubleValue(),normTolerance);
  m=new BigMatrixImpl(detData2);
  assertEquals(""String_Node_Str"",-2d,m.getDeterminant().doubleValue(),normTolerance);
  m=new BigMatrixImpl(testData);
  assertEquals(""String_Node_Str"",-1d,m.getDeterminant().doubleValue(),normTolerance);
  try {
    double d=new BigMatrixImpl(testData2).getDeterminant().doubleValue();
    fail(""String_Node_Str"" + d);
  }
 catch (  InvalidMatrixException ex) {
  }
}"
57443,"/** 
 * This method attempts to find two values a and b satisfying <ul> <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li> <li> <code> f(a) * f(b) < 0 </code> </li> </ul> If f is continuous on <code>[a,b],</code> this means that <code>a</code> and <code>b</code> bracket a root of f. <p> The algorithm starts by setting  <code>a := initial -1; b := initial +1,</code> examines the value of the function at <code>a</code> and <code>b</code> and keeps moving the endpoints out by one unit each time through a loop that terminates  when one of the following happens: <ul> <li> <code> f(a) * f(b) < 0 </code> --  success!</li> <li> <code> a = lower </code> and <code> b = upper</code>  -- ConvergenceException </li> <li> <code> maximumIterations</code> iterations elapse  -- ConvergenceException </li></ul></p>
 * @param function the function
 * @param initial initial midpoint of interval being expanded tobracket a root
 * @param lowerBound lower bound (a is never lower than this value)
 * @param upperBound upper bound (b never is greater than thisvalue)
 * @param maximumIterations maximum number of iterations to perform
 * @return a two element array holding {a, b}.
 * @throws ConvergenceException if the algorithm fails to find a and bsatisfying the desired conditions
 * @throws FunctionEvaluationException if an error occurs evaluating the function
 * @throws IllegalArgumentException if function is null, maximumIterationsis not positive, or initial is not between lowerBound and upperBound
 */
public static double[] bracket(UnivariateRealFunction function,double initial,double lowerBound,double upperBound,int maximumIterations) throws ConvergenceException, FunctionEvaluationException {
  if (function == null) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"");
  }
  if (maximumIterations <= 0) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",maximumIterations);
  }
  if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",lowerBound,initial,upperBound);
  }
  double a=initial;
  double b=initial;
  double fa;
  double fb;
  int numIterations=0;
  do {
    a=Math.max(a - 1.0,lowerBound);
    b=Math.min(b + 1.0,upperBound);
    fa=function.value(a);
    fb=function.value(b);
    numIterations++;
  }
 while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));
  if (fa * fb >= 0.0) {
    throw new ConvergenceException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);
  }
  return new double[]{a,b};
}","/** 
 * This method attempts to find two values a and b satisfying <ul> <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li> <li> <code> f(a) * f(b) <= 0 </code> </li> </ul> If f is continuous on <code>[a,b],</code> this means that <code>a</code> and <code>b</code> bracket a root of f. <p> The algorithm starts by setting  <code>a := initial -1; b := initial +1,</code> examines the value of the function at <code>a</code> and <code>b</code> and keeps moving the endpoints out by one unit each time through a loop that terminates  when one of the following happens: <ul> <li> <code> f(a) * f(b) <= 0 </code> --  success!</li> <li> <code> a = lower </code> and <code> b = upper</code>  -- ConvergenceException </li> <li> <code> maximumIterations</code> iterations elapse  -- ConvergenceException </li></ul></p>
 * @param function the function
 * @param initial initial midpoint of interval being expanded tobracket a root
 * @param lowerBound lower bound (a is never lower than this value)
 * @param upperBound upper bound (b never is greater than thisvalue)
 * @param maximumIterations maximum number of iterations to perform
 * @return a two element array holding {a, b}.
 * @throws ConvergenceException if the algorithm fails to find a and bsatisfying the desired conditions
 * @throws FunctionEvaluationException if an error occurs evaluating the function
 * @throws IllegalArgumentException if function is null, maximumIterationsis not positive, or initial is not between lowerBound and upperBound
 */
public static double[] bracket(UnivariateRealFunction function,double initial,double lowerBound,double upperBound,int maximumIterations) throws ConvergenceException, FunctionEvaluationException {
  if (function == null) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"");
  }
  if (maximumIterations <= 0) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",maximumIterations);
  }
  if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",lowerBound,initial,upperBound);
  }
  double a=initial;
  double b=initial;
  double fa;
  double fb;
  int numIterations=0;
  do {
    a=Math.max(a - 1.0,lowerBound);
    b=Math.min(b + 1.0,upperBound);
    fa=function.value(a);
    fb=function.value(b);
    numIterations++;
  }
 while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound)));
  if (fa * fb > 0.0) {
    throw new ConvergenceException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);
  }
  return new double[]{a,b};
}"
57444,"/** 
 * {@inheritDoc} 
 */
public abstract void readExternal(ObjectInput in) throws IOException ;","/** 
 * {@inheritDoc} 
 */
public abstract void readExternal(ObjectInput in) throws IOException, ClassNotFoundException ;"
57445,"/** 
 * {@inheritDoc} 
 */
@Override public void writeExternal(final ObjectOutput out) throws IOException {
  writeBaseExternal(out);
}","/** 
 * {@inheritDoc} 
 */
@Override public void writeExternal(final ObjectOutput out) throws IOException {
  writeBaseExternal(out);
  out.writeDouble(scalingH);
  out.writeDouble(referenceTime);
  final int n=(currentState == null) ? -1 : currentState.length;
  if (scaled == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    for (int j=0; j < n; ++j) {
      out.writeDouble(scaled[j]);
    }
  }
  if (nordsieck == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeObject(nordsieck);
  }
}"
57446,"/** 
 * {@inheritDoc} 
 */
@Override public void readExternal(final ObjectInput in) throws IOException {
  final double t=readBaseExternal(in);
  if ((scaled != null) && (nordsieck != null)) {
    setInterpolatedTime(t);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {
  final double t=readBaseExternal(in);
  scalingH=in.readDouble();
  referenceTime=in.readDouble();
  final int n=(currentState == null) ? -1 : currentState.length;
  final boolean hasScaled=in.readBoolean();
  if (hasScaled) {
    scaled=new double[n];
    for (int j=0; j < n; ++j) {
      scaled[j]=in.readDouble();
    }
  }
 else {
    scaled=null;
  }
  final boolean hasNordsieck=in.readBoolean();
  if (hasNordsieck) {
    nordsieck=(Array2DRowRealMatrix)in.readObject();
  }
 else {
    nordsieck=null;
  }
  if (hasScaled && hasNordsieck) {
    setInterpolatedTime(t);
  }
}"
57447,"@Test public void serialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException {
  TestProblem1 pb=new TestProblem1();
  AdamsBashforthIntegrator integ=new AdamsBashforthIntegrator(4,0.0,1.0,1.0e-10,1.0e-10);
  integ.addStepHandler(new ContinuousOutputModel());
  integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(bos);
  for (  StepHandler handler : integ.getStepHandlers()) {
    oos.writeObject(handler);
  }
  assertTrue(bos.size() > 16000);
  assertTrue(bos.size() < 17000);
  ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());
  ObjectInputStream ois=new ObjectInputStream(bis);
  ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();
  Random random=new Random(347588535632l);
  double maxError=0.0;
  for (int i=0; i < 1000; ++i) {
    double r=random.nextDouble();
    double time=r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
    cm.setInterpolatedTime(time);
    double[] interpolatedY=cm.getInterpolatedState();
    double[] theoreticalY=pb.computeTheoreticalState(time);
    double dx=interpolatedY[0] - theoreticalY[0];
    double dy=interpolatedY[1] - theoreticalY[1];
    double error=dx * dx + dy * dy;
    if (error > maxError) {
      maxError=error;
    }
  }
  assertTrue(maxError < 1.0e-6);
}","@Test public void serialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException {
  TestProblem1 pb=new TestProblem1();
  AdamsBashforthIntegrator integ=new AdamsBashforthIntegrator(4,0.0,1.0,1.0e-10,1.0e-10);
  integ.addStepHandler(new ContinuousOutputModel());
  integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  ObjectOutputStream oos=new ObjectOutputStream(bos);
  for (  StepHandler handler : integ.getStepHandlers()) {
    oos.writeObject(handler);
  }
  assertTrue(bos.size() > 20000);
  assertTrue(bos.size() < 25000);
  ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());
  ObjectInputStream ois=new ObjectInputStream(bis);
  ContinuousOutputModel cm=(ContinuousOutputModel)ois.readObject();
  Random random=new Random(347588535632l);
  double maxError=0.0;
  for (int i=0; i < 1000; ++i) {
    double r=random.nextDouble();
    double time=r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();
    cm.setInterpolatedTime(time);
    double[] interpolatedY=cm.getInterpolatedState();
    double[] theoreticalY=pb.computeTheoreticalState(time);
    double dx=interpolatedY[0] - theoreticalY[0];
    double dy=interpolatedY[1] - theoreticalY[1];
    double error=dx * dx + dy * dy;
    if (error > maxError) {
      maxError=error;
    }
  }
  assertTrue(maxError < 1.0e-6);
}"
57448,"protected AbstractIntegrator(){
  this(null);
}","/** 
 * Build an instance with a null name.
 */
protected AbstractIntegrator(){
  this(null);
}"
57449,"/** 
 * Compute the objective function value.
 * @param point point at which the objective function must be evaluated
 * @return objective function value at specified point
 * @exception FunctionEvaluationException if the function cannot be evaluatedor the maximal number of iterations is exceeded
 */
protected double computeObjectiveValue(final UnivariateRealFunction f,final double point) throws FunctionEvaluationException {
  if (++evaluations > maxEvaluations) {
    throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),point);
  }
  return f.value(point);
}","/** 
 * Compute the objective function value.
 * @param f objective function
 * @param point point at which the objective function must be evaluated
 * @return objective function value at specified point
 * @exception FunctionEvaluationException if the function cannot be evaluatedor the maximal number of iterations is exceeded
 */
protected double computeObjectiveValue(final UnivariateRealFunction f,final double point) throws FunctionEvaluationException {
  if (++evaluations > maxEvaluations) {
    throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),point);
  }
  return f.value(point);
}"
57450,"/** 
 * Build an Adams-Bashforth with the given order and step size.
 * @param nSteps number of steps of the method excluding the one being computed
 * @param minStep minimal step (must be positive even for backwardintegration), the last step can be smaller than this
 * @param maxStep maximal step (must be positive even for backwardintegration)
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 * @exception IllegalArgumentException if order is 1 or less
 */
public AdamsBashforthIntegrator(final int nSteps,final double minStep,final double maxStep,final double[] vecAbsoluteTolerance,final double[] vecRelativeTolerance) throws IllegalArgumentException {
  super(""String_Node_Str"",nSteps,nSteps + 1,minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);
}","/** 
 * Build an Adams-Bashforth with the given order and step size.
 * @param nSteps number of steps of the method excluding the one being computed
 * @param minStep minimal step (must be positive even for backwardintegration), the last step can be smaller than this
 * @param maxStep maximal step (must be positive even for backwardintegration)
 * @param vecAbsoluteTolerance allowed absolute error
 * @param vecRelativeTolerance allowed relative error
 * @exception IllegalArgumentException if order is 1 or less
 */
public AdamsBashforthIntegrator(final int nSteps,final double minStep,final double maxStep,final double[] vecAbsoluteTolerance,final double[] vecRelativeTolerance) throws IllegalArgumentException {
  super(""String_Node_Str"",nSteps,nSteps,minStep,maxStep,vecAbsoluteTolerance,vecRelativeTolerance);
}"
57451,"@Test public void testIncreasingTolerance() throws DerivativeException, IntegratorException {
  int previousCalls=Integer.MAX_VALUE;
  for (int i=-12; i < -2; ++i) {
    TestProblem1 pb=new TestProblem1();
    double minStep=0;
    double maxStep=pb.getFinalTime() - pb.getInitialTime();
    double scalAbsoluteTolerance=Math.pow(10.0,i);
    double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;
    FirstOrderIntegrator integ=new AdamsBashforthIntegrator(4,minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);
    TestProblemHandler handler=new TestProblemHandler(pb,integ);
    integ.addStepHandler(handler);
    integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);
    assertTrue(handler.getMaximalValueError() > (28.0 * scalAbsoluteTolerance));
    assertTrue(handler.getMaximalValueError() < (42.0 * scalAbsoluteTolerance));
    assertEquals(0,handler.getMaximalTimeError(),1.0e-16);
    int calls=pb.getCalls();
    assertEquals(integ.getEvaluations(),calls);
    assertTrue(calls <= previousCalls);
    previousCalls=calls;
  }
}","@Test public void testIncreasingTolerance() throws DerivativeException, IntegratorException {
  int previousCalls=Integer.MAX_VALUE;
  for (int i=-12; i < -2; ++i) {
    TestProblem1 pb=new TestProblem1();
    double minStep=0;
    double maxStep=pb.getFinalTime() - pb.getInitialTime();
    double scalAbsoluteTolerance=Math.pow(10.0,i);
    double scalRelativeTolerance=0.01 * scalAbsoluteTolerance;
    FirstOrderIntegrator integ=new AdamsBashforthIntegrator(4,minStep,maxStep,scalAbsoluteTolerance,scalRelativeTolerance);
    TestProblemHandler handler=new TestProblemHandler(pb,integ);
    integ.addStepHandler(handler);
    integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);
    assertTrue(handler.getMaximalValueError() > (33.0 * scalAbsoluteTolerance));
    assertTrue(handler.getMaximalValueError() < (45.0 * scalAbsoluteTolerance));
    assertEquals(0,handler.getMaximalTimeError(),1.0e-16);
    int calls=pb.getCalls();
    assertEquals(integ.getEvaluations(),calls);
    assertTrue(calls <= previousCalls);
    previousCalls=calls;
  }
}"
57452,"/** 
 * <p>Evolve the given population into the next generation.</p> <p><ol> <li>Get nextGeneration population to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled:</li> <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each of the offspring</li><li>Add offspring individually to nextGeneration, space permitting</li> </ul> <li>Return nextGeneration</li> </ol> </p>
 * @param current the current population.
 * @return the population for the next generation.
 */
public Population nextGeneration(Population current){
  Population nextGeneration=current.nextGeneration();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (randomGenerator.nextDouble() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (randomGenerator.nextDouble() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}","/** 
 * <p>Evolve the given population into the next generation.</p> <p><ol> <li>Get nextGeneration population to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled:</li> <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each of the offspring</li><li>Add offspring individually to nextGeneration, space permitting</li> </ul> <li>Return nextGeneration</li> </ol> </p>
 * @param current the current population.
 * @return the population for the next generation.
 */
public Population nextGeneration(Population current){
  Population nextGeneration=current.nextGeneration();
  RandomGenerator randGen=getRandomGenerator();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (randGen.nextDouble() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (randGen.nextDouble() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}"
57453,"/** 
 * @param crossoverPolicy The {@link CrossoverPolicy}
 * @param crossoverRate The crossover rate as a percentage (0-1 inclusive)
 * @param mutationPolicy The {@link MutationPolicy}
 * @param mutationRate The mutation rate as a percentage (0-1 inclusive)
 * @param selectionPolicy The {@link selectionPolicy}
 */
public GeneticAlgorithm(CrossoverPolicy crossoverPolicy,double crossoverRate,MutationPolicy mutationPolicy,double mutationRate,SelectionPolicy selectionPolicy){
  if (crossoverRate < 0 || crossoverRate > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mutationRate < 0 || mutationRate > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.crossoverPolicy=crossoverPolicy;
  this.crossoverRate=crossoverRate;
  this.mutationPolicy=mutationPolicy;
  this.mutationRate=mutationRate;
  this.selectionPolicy=selectionPolicy;
}","/** 
 * @param crossoverPolicy The {@link CrossoverPolicy}
 * @param crossoverRate The crossover rate as a percentage (0-1 inclusive)
 * @param mutationPolicy The {@link MutationPolicy}
 * @param mutationRate The mutation rate as a percentage (0-1 inclusive)
 * @param selectionPolicy The {@link SelectionPolicy}
 */
public GeneticAlgorithm(CrossoverPolicy crossoverPolicy,double crossoverRate,MutationPolicy mutationPolicy,double mutationRate,SelectionPolicy selectionPolicy){
  if (crossoverRate < 0 || crossoverRate > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mutationRate < 0 || mutationRate > 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.crossoverPolicy=crossoverPolicy;
  this.crossoverRate=crossoverRate;
  this.mutationPolicy=mutationPolicy;
  this.mutationRate=mutationRate;
  this.selectionPolicy=selectionPolicy;
}"
57454,"/** 
 * {@inheritDoc} 
 */
public int eventOccurred(double t,double[] y,boolean increasing) throws EventException {
  final int action=handler.eventOccurred(t,y,increasing);
  if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {
    resetTime=t;
    return STOP;
  }
  return action;
}","/** 
 * {@inheritDoc} 
 */
public int eventOccurred(double t,double[] y,boolean increasing) throws EventException {
  final int action=handler.eventOccurred(t,y,increasing);
  if (Math.abs(t - rangeStart) < 1.0e-10 * rangeSize) {
    return action;
  }
  if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {
    resetTime=t;
    return STOP;
  }
  return action;
}"
57455,"/** 
 * Start the integration. <p>This method computes the first few steps of the multistep method, using the underlying starter integrator, ensuring the returned steps all belong to the same smooth range.</p> <p>In order to ensure smoothness, the start phase is automatically restarted when a state or derivative reset is triggered by the registered events handlers before this start phase is completed. As an example, consider integrating a differential equation from t=0 to t=100 with a 4 steps method and step size equal to 0.2. If an event resets the state at t=0.5, the start phase will not end at t=0.6 with steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps at [0.5, 0.7, 0.9, 1.1].</p> <p>A side effect of the need for smoothness is that an ODE triggering short period regular resets will remain in the start phase throughout the integration range if the step size or the number of steps to store are too large.</p> <p>If the start phase ends prematurely (because of some triggered event for example), then the time of latest previous steps will be set to <code>Double.NaN</code>.</p>
 * @param n number of steps to store
 * @param h signed step size to use for the first steps
 * @param manager discrete events manager to use
 * @param equations differential equations to integrate
 * @param t0 initial time
 * @param y state vector: contains the initial value of the state vector at t0,will be used to put the state vector at each successful step and hence contains the final value at the end of the start phase
 * @return time of the end of the start phase
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
protected double start(final int n,final double h,final CombinedEventsManager manager,final FirstOrderDifferentialEquations equations,final double t0,final double[] y) throws DerivativeException, IntegratorException {
  Arrays.fill(previousT,Double.NaN);
  Arrays.fill(previousF,null);
  starter.clearEventHandlers();
  for (  EventState state : manager.getEventsStates()) {
    starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),state.getMaxCheckInterval(),state.getConvergence(),state.getMaxIterationCount());
  }
  starter.clearStepHandlers();
  for (  final StepHandler handler : stepHandlers) {
    starter.addStepHandler(new FilteringWrapper(handler));
  }
  final StoringStepHandler store=new StoringStepHandler(n);
  starter.addStepHandler(new StepNormalizer(h,store));
  double t=t0;
  double stopTime=Double.NaN;
  do {
    resetTime=Double.NaN;
    store.restart();
    stopTime=starter.integrate(equations,t,y,t + (n - 0.9999) * h,y);
    if (!Double.isNaN(resetTime)) {
      t=resetTime;
    }
  }
 while (!Double.isNaN(resetTime));
  starter.clearEventHandlers();
  starter.clearStepHandlers();
  if (store.getFinalState() != null) {
    System.arraycopy(store.getFinalState(),0,y,0,y.length);
  }
  return stopTime;
}","/** 
 * Start the integration. <p>This method computes the first few steps of the multistep method, using the underlying starter integrator, ensuring the returned steps all belong to the same smooth range.</p> <p>In order to ensure smoothness, the start phase is automatically restarted when a state or derivative reset is triggered by the registered events handlers before this start phase is completed. As an example, consider integrating a differential equation from t=0 to t=100 with a 4 steps method and step size equal to 0.2. If an event resets the state at t=0.5, the start phase will not end at t=0.6 with steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps at [0.5, 0.7, 0.9, 1.1].</p> <p>A side effect of the need for smoothness is that an ODE triggering short period regular resets will remain in the start phase throughout the integration range if the step size or the number of steps to store are too large.</p> <p>If the start phase ends prematurely (because of some triggered event for example), then the time of latest previous steps will be set to <code>Double.NaN</code>.</p>
 * @param n number of steps to store
 * @param h signed step size to use for the first steps
 * @param manager discrete events manager to use
 * @param equations differential equations to integrate
 * @param t0 initial time
 * @param y state vector: contains the initial value of the state vector at t0,will be used to put the state vector at each successful step and hence contains the final value at the end of the start phase
 * @return time of the end of the start phase
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
protected double start(final int n,final double h,final CombinedEventsManager manager,final FirstOrderDifferentialEquations equations,final double t0,final double[] y) throws DerivativeException, IntegratorException {
  Arrays.fill(previousT,Double.NaN);
  Arrays.fill(previousF,null);
  starter.clearEventHandlers();
  for (  EventState state : manager.getEventsStates()) {
    starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),state.getMaxCheckInterval(),state.getConvergence(),state.getMaxIterationCount());
  }
  starter.clearStepHandlers();
  for (  final StepHandler handler : stepHandlers) {
    starter.addStepHandler(new FilteringWrapper(handler));
  }
  final StoringStepHandler store=new StoringStepHandler(n);
  starter.addStepHandler(new StepNormalizer(h,store));
  double t=t0;
  double stopTime=Double.NaN;
  do {
    resetTime=Double.NaN;
    final double dt=(n - 0.9999) * h;
    for (    EventHandler handler : starter.getEventHandlers()) {
      ((ResetCheckingWrapper)handler).setRange(t,Math.abs(dt));
    }
    store.restart();
    stopTime=starter.integrate(equations,t,y,t + dt,y);
    if (!Double.isNaN(resetTime)) {
      t=resetTime;
    }
  }
 while (!Double.isNaN(resetTime));
  starter.clearEventHandlers();
  starter.clearStepHandlers();
  if (store.getFinalState() != null) {
    System.arraycopy(store.getFinalState(),0,y,0,y.length);
  }
  return stopTime;
}"
57456,"/** 
 * Get the current solution. <p>  {@link #solve} should be called first for this to be the optimal solution.</p>
 * @return current solution
 */
protected RealPointValuePair getSolution(){
  double[] coefficients=new double[getOriginalNumDecisionVariables()];
  double mostNegative=getDecisionVariableValue(getOriginalNumDecisionVariables());
  for (int i=0; i < coefficients.length; i++) {
    coefficients[i]=getDecisionVariableValue(i) - (restrictToNonNegative ? 0 : mostNegative);
  }
  return new RealPointValuePair(coefficients,f.getValue(coefficients));
}","/** 
 * Get the current solution. <p>  {@link #solve} should be called first for this to be the optimal solution.</p>
 * @return current solution
 */
protected RealPointValuePair getSolution(){
  double[] coefficients=new double[getOriginalNumDecisionVariables()];
  Integer basicRow=getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
  double mostNegative=basicRow == null ? 0 : getEntry(basicRow,getRhsOffset());
  Set<Integer> basicRows=new HashSet<Integer>();
  for (int i=0; i < coefficients.length; i++) {
    basicRow=getBasicRow(getNumObjectiveFunctions() + i);
    if (basicRows.contains(basicRow)) {
      coefficients[i]=0;
    }
 else {
      basicRows.add(basicRow);
      coefficients[i]=(basicRow == null ? 0 : getEntry(basicRow,getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
    }
  }
  return new RealPointValuePair(coefficients,f.getValue(coefficients));
}"
57457,"/** 
 * Set the differential equations.
 * @see #computeDerivatives(double,double[],double[])
 */
protected void setEquations(final FirstOrderDifferentialEquations equations){
  this.equations=equations;
}","/** 
 * Set the differential equations.
 * @param equations differential equations to integrate
 * @see #computeDerivatives(double,double[],double[])
 */
protected void setEquations(final FirstOrderDifferentialEquations equations){
  this.equations=equations;
}"
57458,"/** 
 * Start the integration. <p>This method computes the first few steps of the multistep method, using the underlying starter integrator, ensuring the returned steps all belong to the same smooth range.</p> <p>In order to ensure smoothness, the start phase is automatically restarted when a state or derivative reset is triggered by the registered events handlers before this start phase is completed. As an example, consider integrating a differential equation from t=0 to t=100 with a 4 steps method and step size equal to 0.2. If an event resets the state at t=0.5, the start phase will not end at t=0.6 with steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps at [0.5, 0.7, 0.9, 1.1].</p> <p>A side effect of the need for smoothness is that an ODE triggering short period regular resets will remain in the start phase throughout the integration range if the step size or the number of steps to store are too large.</p> <p>If the start phase ends prematurely (because of some triggered event for example), then the time of latest previous steps will be set to <code>Double.NaN</code>.</p>
 * @param n number of steps to store
 * @param h signed step size to use for the first steps
 * @param manager discrete events manager to use
 * @param equations differential equations to integrate
 * @param t0 initial time
 * @param y state vector: contains the initial value of the state vector at t0,will be used to put the state vector at each successful step and hence contains the final value at the end of the start phase
 * @return time of the end of the start phase
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
protected double start(final int n,final double h,final CombinedEventsManager manager,final double t0,final double[] y) throws DerivativeException, IntegratorException {
  Arrays.fill(previousT,Double.NaN);
  Arrays.fill(previousF,null);
  starter.clearEventHandlers();
  for (  EventState state : manager.getEventsStates()) {
    starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),state.getMaxCheckInterval(),state.getConvergence(),state.getMaxIterationCount());
  }
  starter.clearStepHandlers();
  for (  final StepHandler handler : stepHandlers) {
    starter.addStepHandler(new FilteringWrapper(handler));
  }
  final StoringStepHandler store=new StoringStepHandler(n);
  starter.addStepHandler(new StepNormalizer(h,store));
  double t=t0;
  double stopTime=Double.NaN;
  FirstOrderDifferentialEquations equations=new CountingDifferentialEquations(y.length);
  do {
    resetTime=Double.NaN;
    final double dt=(n - 0.9999) * h;
    for (    EventHandler handler : starter.getEventHandlers()) {
      ((ResetCheckingWrapper)handler).setRange(t,Math.abs(dt));
    }
    store.restart();
    stopTime=starter.integrate(equations,t,y,t + dt,y);
    if (!Double.isNaN(resetTime)) {
      t=resetTime;
    }
  }
 while (!Double.isNaN(resetTime));
  starter.clearEventHandlers();
  starter.clearStepHandlers();
  if (store.getFinalState() != null) {
    System.arraycopy(store.getFinalState(),0,y,0,y.length);
  }
  return stopTime;
}","/** 
 * Start the integration. <p>This method computes the first few steps of the multistep method, using the underlying starter integrator, ensuring the returned steps all belong to the same smooth range.</p> <p>In order to ensure smoothness, the start phase is automatically restarted when a state or derivative reset is triggered by the registered events handlers before this start phase is completed. As an example, consider integrating a differential equation from t=0 to t=100 with a 4 steps method and step size equal to 0.2. If an event resets the state at t=0.5, the start phase will not end at t=0.6 with steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps at [0.5, 0.7, 0.9, 1.1].</p> <p>A side effect of the need for smoothness is that an ODE triggering short period regular resets will remain in the start phase throughout the integration range if the step size or the number of steps to store are too large.</p> <p>If the start phase ends prematurely (because of some triggered event for example), then the time of latest previous steps will be set to <code>Double.NaN</code>.</p>
 * @param n number of steps to store
 * @param h signed step size to use for the first steps
 * @param manager discrete events manager to use
 * @param t0 initial time
 * @param y state vector: contains the initial value of the state vector at t0,will be used to put the state vector at each successful step and hence contains the final value at the end of the start phase
 * @return time of the end of the start phase
 * @throws IntegratorException if the integrator cannot perform integration
 * @throws DerivativeException this exception is propagated to the caller ifthe underlying user function triggers one
 */
protected double start(final int n,final double h,final CombinedEventsManager manager,final double t0,final double[] y) throws DerivativeException, IntegratorException {
  Arrays.fill(previousT,Double.NaN);
  Arrays.fill(previousF,null);
  starter.clearEventHandlers();
  for (  EventState state : manager.getEventsStates()) {
    starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),state.getMaxCheckInterval(),state.getConvergence(),state.getMaxIterationCount());
  }
  starter.clearStepHandlers();
  for (  final StepHandler handler : stepHandlers) {
    starter.addStepHandler(new FilteringWrapper(handler));
  }
  final StoringStepHandler store=new StoringStepHandler(n);
  starter.addStepHandler(new StepNormalizer(h,store));
  double t=t0;
  double stopTime=Double.NaN;
  FirstOrderDifferentialEquations equations=new CountingDifferentialEquations(y.length);
  do {
    resetTime=Double.NaN;
    final double dt=(n - 0.9999) * h;
    for (    EventHandler handler : starter.getEventHandlers()) {
      ((ResetCheckingWrapper)handler).setRange(t,Math.abs(dt));
    }
    store.restart();
    stopTime=starter.integrate(equations,t,y,t + dt,y);
    if (!Double.isNaN(resetTime)) {
      t=resetTime;
    }
  }
 while (!Double.isNaN(resetTime));
  starter.clearEventHandlers();
  starter.clearStepHandlers();
  if (store.getFinalState() != null) {
    System.arraycopy(store.getFinalState(),0,y,0,y.length);
  }
  return stopTime;
}"
57459,"/** 
 * Test for the equality of two real vectors. <p> If all coordinates of two real vectors are exactly the same, and none are <code>Double.NaN</code>, the two real vectors are considered to be equal. </p> <p> <code>NaN</code> coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the real vector are equal to <code>Double.NaN</code>, the real vector is equal to a vector with all <code>Double.NaN</code> coordinates. </p>
 * @param other Object to test for equality to this
 * @return true if two 3D vector objects are equal, false ifobject is null, not an instance of Vector3D, or not equal to this Vector3D instance
 */
@Override public boolean equals(Object other){
  if (this == other) {
    return true;
  }
  if (other == null) {
    return false;
  }
  try {
    RealVector rhs=(RealVector)other;
    if (data.length != rhs.getDimension()) {
      return false;
    }
    if (rhs.isNaN()) {
      return this.isNaN();
    }
    for (int i=0; i < data.length; ++i) {
      if (data[i] != rhs.getEntry(i)) {
        return false;
      }
    }
    return true;
  }
 catch (  ClassCastException ex) {
    return false;
  }
}","/** 
 * Test for the equality of two real vectors. <p> If all coordinates of two real vectors are exactly the same, and none are <code>Double.NaN</code>, the two real vectors are considered to be equal. </p> <p> <code>NaN</code> coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the real vector are equal to <code>Double.NaN</code>, the real vector is equal to a vector with all <code>Double.NaN</code> coordinates. </p>
 * @param other Object to test for equality to this
 * @return true if two vector objects are equal, false ifobject is null, not an instance of RealVector, or not equal to this RealVector instance
 */
@Override public boolean equals(Object other){
  if (this == other) {
    return true;
  }
  if (other == null) {
    return false;
  }
  try {
    RealVector rhs=(RealVector)other;
    if (data.length != rhs.getDimension()) {
      return false;
    }
    if (rhs.isNaN()) {
      return this.isNaN();
    }
    for (int i=0; i < data.length; ++i) {
      if (data[i] != rhs.getEntry(i)) {
        return false;
      }
    }
    return true;
  }
 catch (  ClassCastException ex) {
    return false;
  }
}"
57460,"/** 
 * Compute the gamma star coefficients.
 * @param order order of the integration method
 * @return gamma star coefficients array
 */
static Fraction[] computeGammaStarArray(final int order){
  Fraction[] gammaStarArray=new Fraction[order + 1];
  gammaStarArray[0]=Fraction.ONE;
  for (int i=1; i <= order; ++i) {
    Fraction gammaStar=Fraction.ZERO;
    for (int j=1; j <= i; ++j) {
      gammaStar=gammaStar.subtract(gammaStarArray[i - j].multiply(new Fraction(1,j + 1)));
    }
    gammaStarArray[i]=gammaStar;
  }
  return gammaStarArray;
}","/** 
 * Compute the gamma star coefficients.
 * @param order order of the integration method
 * @return gamma star coefficients array
 */
public static Fraction[] computeGammaStarArray(final int order){
  Fraction[] gammaStarArray=new Fraction[order + 1];
  gammaStarArray[0]=Fraction.ONE;
  for (int i=1; i <= order; ++i) {
    Fraction gammaStar=Fraction.ZERO;
    for (int j=1; j <= i; ++j) {
      gammaStar=gammaStar.subtract(gammaStarArray[i - j].multiply(new Fraction(1,j + 1)));
    }
    gammaStarArray[i]=gammaStar;
  }
  return gammaStarArray;
}"
57461,"/** 
 * Build an Adams-Moulton integrator with the given order and step size.
 * @param order order of the method (must be strictly positive)
 * @param step integration step size
 */
public AdamsMoultonIntegrator(final int order,final double step){
  super(METHOD_NAME,order + 1,new AdamsMoultonStepInterpolator());
  int[][] bdArray=AdamsBashforthIntegrator.computeBackwardDifferencesArray(order + 1);
  Fraction[] gamma=AdamsBashforthIntegrator.computeGammaArray(order);
  predictorCoeffs=new double[order];
  for (int i=0; i < order; ++i) {
    Fraction fPredictor=Fraction.ZERO;
    for (int j=i; j < order; ++j) {
      Fraction f=new Fraction(bdArray[j][i],1);
      fPredictor=fPredictor.add(gamma[j].multiply(f));
    }
    predictorCoeffs[i]=fPredictor.doubleValue();
  }
  Fraction[] gammaStar=computeGammaStarArray(order);
  correctorCoeffs=new double[order + 1];
  for (int i=0; i <= order; ++i) {
    Fraction fCorrector=Fraction.ZERO;
    for (int j=i; j <= order; ++j) {
      Fraction f=new Fraction(bdArray[j][i],1);
      fCorrector=fCorrector.add(gammaStar[j].multiply(f));
    }
    correctorCoeffs[i]=fCorrector.doubleValue();
  }
  this.step=Math.abs(step);
}","/** 
 * Build an Adams-Moulton integrator with the given order and step size.
 * @param order order of the method (must be strictly positive)
 * @param step integration step size
 */
public AdamsMoultonIntegrator(final int order,final double step){
  super(METHOD_NAME,order + 1,new AdamsMoultonStepInterpolator());
  int[][] bdArray=AdamsBashforthIntegrator.computeBackwardDifferencesArray(order);
  Fraction[] gamma=AdamsBashforthIntegrator.computeGammaArray(order);
  predictorCoeffs=new double[order];
  for (int i=0; i < order; ++i) {
    Fraction fPredictor=Fraction.ZERO;
    for (int j=i; j < order; ++j) {
      Fraction f=new Fraction(bdArray[j][i],1);
      fPredictor=fPredictor.add(gamma[j].multiply(f));
    }
    predictorCoeffs[i]=fPredictor.doubleValue();
  }
  Fraction[] gammaStar=computeGammaStarArray(order);
  correctorCoeffs=new double[order];
  for (int i=0; i < order; ++i) {
    Fraction fCorrector=Fraction.ZERO;
    for (int j=i; j < order; ++j) {
      Fraction f=new Fraction(bdArray[j][i],1);
      fCorrector=fCorrector.add(gammaStar[j].multiply(f));
    }
    correctorCoeffs[i]=fCorrector.doubleValue();
  }
  this.step=Math.abs(step);
}"
57462,"public void testCorrectorCoefficients(){
  double[] coeffs1=new AdamsMoultonIntegrator(1,0.01).getCorrectorCoeffs();
  assertEquals(2,coeffs1.length);
  assertEquals(1.0 / 2.0,coeffs1[0],1.0e-16);
  assertEquals(1.0 / 2.0,coeffs1[1],1.0e-16);
  double[] coeffs2=new AdamsMoultonIntegrator(2,0.01).getCorrectorCoeffs();
  assertEquals(3,coeffs2.length);
  assertEquals(5.0 / 12.0,coeffs2[0],1.0e-16);
  assertEquals(8.0 / 12.0,coeffs2[1],1.0e-16);
  assertEquals(-1.0 / 12.0,coeffs2[2],1.0e-16);
  double[] coeffs3=new AdamsMoultonIntegrator(3,0.01).getCorrectorCoeffs();
  assertEquals(4,coeffs3.length);
  assertEquals(9.0 / 24.0,coeffs3[0],1.0e-16);
  assertEquals(19.0 / 24.0,coeffs3[1],1.0e-16);
  assertEquals(-5.0 / 24.0,coeffs3[2],1.0e-16);
  assertEquals(1.0 / 24.0,coeffs3[3],1.0e-16);
  double[] coeffs4=new AdamsMoultonIntegrator(4,0.01).getCorrectorCoeffs();
  assertEquals(5,coeffs4.length);
  assertEquals(251.0 / 720.0,coeffs4[0],1.0e-16);
  assertEquals(646.0 / 720.0,coeffs4[1],1.0e-16);
  assertEquals(-264.0 / 720.0,coeffs4[2],1.0e-16);
  assertEquals(106.0 / 720.0,coeffs4[3],1.0e-16);
  assertEquals(-19.0 / 720.0,coeffs4[4],1.0e-16);
  double[] coeffs5=new AdamsMoultonIntegrator(5,0.01).getCorrectorCoeffs();
  assertEquals(6,coeffs5.length);
  assertEquals(475.0 / 1440.0,coeffs5[0],1.0e-16);
  assertEquals(1427.0 / 1440.0,coeffs5[1],1.0e-16);
  assertEquals(-798.0 / 1440.0,coeffs5[2],1.0e-16);
  assertEquals(482.0 / 1440.0,coeffs5[3],1.0e-16);
  assertEquals(-173.0 / 1440.0,coeffs5[4],1.0e-16);
  assertEquals(27.0 / 1440.0,coeffs5[5],1.0e-16);
  double[] coeffs6=new AdamsMoultonIntegrator(6,0.01).getCorrectorCoeffs();
  assertEquals(7,coeffs6.length);
  assertEquals(19087.0 / 60480.0,coeffs6[0],1.0e-16);
  assertEquals(65112.0 / 60480.0,coeffs6[1],1.0e-16);
  assertEquals(-46461.0 / 60480.0,coeffs6[2],1.0e-16);
  assertEquals(37504.0 / 60480.0,coeffs6[3],1.0e-16);
  assertEquals(-20211.0 / 60480.0,coeffs6[4],1.0e-16);
  assertEquals(6312.0 / 60480.0,coeffs6[5],1.0e-16);
  assertEquals(-863.0 / 60480.0,coeffs6[6],1.0e-16);
  double[] coeffs7=new AdamsMoultonIntegrator(7,0.01).getCorrectorCoeffs();
  assertEquals(8,coeffs7.length);
  assertEquals(36799.0 / 120960.0,coeffs7[0],1.0e-16);
  assertEquals(139849.0 / 120960.0,coeffs7[1],1.0e-16);
  assertEquals(-121797.0 / 120960.0,coeffs7[2],1.0e-16);
  assertEquals(123133.0 / 120960.0,coeffs7[3],1.0e-16);
  assertEquals(-88547.0 / 120960.0,coeffs7[4],1.0e-16);
  assertEquals(41499.0 / 120960.0,coeffs7[5],1.0e-16);
  assertEquals(-11351.0 / 120960.0,coeffs7[6],1.0e-16);
  assertEquals(1375.0 / 120960.0,coeffs7[7],1.0e-16);
  double[] coeffs8=new AdamsMoultonIntegrator(8,0.01).getCorrectorCoeffs();
  assertEquals(9,coeffs8.length);
  assertEquals(1070017.0 / 3628800.0,coeffs8[0],1.0e-16);
  assertEquals(4467094.0 / 3628800.0,coeffs8[1],1.0e-16);
  assertEquals(-4604594.0 / 3628800.0,coeffs8[2],1.0e-16);
  assertEquals(5595358.0 / 3628800.0,coeffs8[3],1.0e-16);
  assertEquals(-5033120.0 / 3628800.0,coeffs8[4],1.0e-16);
  assertEquals(3146338.0 / 3628800.0,coeffs8[5],1.0e-16);
  assertEquals(-1291214.0 / 3628800.0,coeffs8[6],1.0e-16);
  assertEquals(312874.0 / 3628800.0,coeffs8[7],1.0e-16);
  assertEquals(-33953.0 / 3628800.0,coeffs8[8],1.0e-16);
}","public void testCorrectorCoefficients(){
  double[] coeffs1=new AdamsMoultonIntegrator(2,0.01).getCorrectorCoeffs();
  assertEquals(2,coeffs1.length);
  assertEquals(1.0 / 2.0,coeffs1[0],1.0e-16);
  assertEquals(1.0 / 2.0,coeffs1[1],1.0e-16);
  double[] coeffs2=new AdamsMoultonIntegrator(3,0.01).getCorrectorCoeffs();
  assertEquals(3,coeffs2.length);
  assertEquals(5.0 / 12.0,coeffs2[0],1.0e-16);
  assertEquals(8.0 / 12.0,coeffs2[1],1.0e-16);
  assertEquals(-1.0 / 12.0,coeffs2[2],1.0e-16);
  double[] coeffs3=new AdamsMoultonIntegrator(4,0.01).getCorrectorCoeffs();
  assertEquals(4,coeffs3.length);
  assertEquals(9.0 / 24.0,coeffs3[0],1.0e-16);
  assertEquals(19.0 / 24.0,coeffs3[1],1.0e-16);
  assertEquals(-5.0 / 24.0,coeffs3[2],1.0e-16);
  assertEquals(1.0 / 24.0,coeffs3[3],1.0e-16);
  double[] coeffs4=new AdamsMoultonIntegrator(5,0.01).getCorrectorCoeffs();
  assertEquals(5,coeffs4.length);
  assertEquals(251.0 / 720.0,coeffs4[0],1.0e-16);
  assertEquals(646.0 / 720.0,coeffs4[1],1.0e-16);
  assertEquals(-264.0 / 720.0,coeffs4[2],1.0e-16);
  assertEquals(106.0 / 720.0,coeffs4[3],1.0e-16);
  assertEquals(-19.0 / 720.0,coeffs4[4],1.0e-16);
  double[] coeffs5=new AdamsMoultonIntegrator(6,0.01).getCorrectorCoeffs();
  assertEquals(6,coeffs5.length);
  assertEquals(475.0 / 1440.0,coeffs5[0],1.0e-16);
  assertEquals(1427.0 / 1440.0,coeffs5[1],1.0e-16);
  assertEquals(-798.0 / 1440.0,coeffs5[2],1.0e-16);
  assertEquals(482.0 / 1440.0,coeffs5[3],1.0e-16);
  assertEquals(-173.0 / 1440.0,coeffs5[4],1.0e-16);
  assertEquals(27.0 / 1440.0,coeffs5[5],1.0e-16);
  double[] coeffs6=new AdamsMoultonIntegrator(7,0.01).getCorrectorCoeffs();
  assertEquals(7,coeffs6.length);
  assertEquals(19087.0 / 60480.0,coeffs6[0],1.0e-16);
  assertEquals(65112.0 / 60480.0,coeffs6[1],1.0e-16);
  assertEquals(-46461.0 / 60480.0,coeffs6[2],1.0e-16);
  assertEquals(37504.0 / 60480.0,coeffs6[3],1.0e-16);
  assertEquals(-20211.0 / 60480.0,coeffs6[4],1.0e-16);
  assertEquals(6312.0 / 60480.0,coeffs6[5],1.0e-16);
  assertEquals(-863.0 / 60480.0,coeffs6[6],1.0e-16);
  double[] coeffs7=new AdamsMoultonIntegrator(8,0.01).getCorrectorCoeffs();
  assertEquals(8,coeffs7.length);
  assertEquals(36799.0 / 120960.0,coeffs7[0],1.0e-16);
  assertEquals(139849.0 / 120960.0,coeffs7[1],1.0e-16);
  assertEquals(-121797.0 / 120960.0,coeffs7[2],1.0e-16);
  assertEquals(123133.0 / 120960.0,coeffs7[3],1.0e-16);
  assertEquals(-88547.0 / 120960.0,coeffs7[4],1.0e-16);
  assertEquals(41499.0 / 120960.0,coeffs7[5],1.0e-16);
  assertEquals(-11351.0 / 120960.0,coeffs7[6],1.0e-16);
  assertEquals(1375.0 / 120960.0,coeffs7[7],1.0e-16);
  double[] coeffs8=new AdamsMoultonIntegrator(9,0.01).getCorrectorCoeffs();
  assertEquals(9,coeffs8.length);
  assertEquals(1070017.0 / 3628800.0,coeffs8[0],1.0e-16);
  assertEquals(4467094.0 / 3628800.0,coeffs8[1],1.0e-16);
  assertEquals(-4604594.0 / 3628800.0,coeffs8[2],1.0e-16);
  assertEquals(5595358.0 / 3628800.0,coeffs8[3],1.0e-16);
  assertEquals(-5033120.0 / 3628800.0,coeffs8[4],1.0e-16);
  assertEquals(3146338.0 / 3628800.0,coeffs8[5],1.0e-16);
  assertEquals(-1291214.0 / 3628800.0,coeffs8[6],1.0e-16);
  assertEquals(312874.0 / 3628800.0,coeffs8[7],1.0e-16);
  assertEquals(-33953.0 / 3628800.0,coeffs8[8],1.0e-16);
}"
57463,"public void testSmallStep() throws DerivativeException, IntegratorException {
  TestProblem1 pb=new TestProblem1();
  double step=(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
  FirstOrderIntegrator integ=new AdamsMoultonIntegrator(3,step);
  TestProblemHandler handler=new TestProblemHandler(pb,integ);
  integ.addStepHandler(handler);
  integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);
  assertTrue(handler.getLastError() < 7.0e-12);
  assertTrue(handler.getMaximalValueError() < 4.0e-11);
  assertEquals(0,handler.getMaximalTimeError(),1.0e-14);
  assertEquals(""String_Node_Str"",integ.getName());
}","public void testSmallStep() throws DerivativeException, IntegratorException {
  TestProblem1 pb=new TestProblem1();
  double step=(pb.getFinalTime() - pb.getInitialTime()) * 0.001;
  FirstOrderIntegrator integ=new AdamsMoultonIntegrator(3,step);
  TestProblemHandler handler=new TestProblemHandler(pb,integ);
  integ.addStepHandler(handler);
  integ.integrate(pb,pb.getInitialTime(),pb.getInitialState(),pb.getFinalTime(),new double[pb.getDimension()]);
  assertTrue(handler.getLastError() < 3.0e-10);
  assertTrue(handler.getMaximalValueError() < 2.0e-9);
  assertEquals(0,handler.getMaximalTimeError(),1.0e-15);
  assertEquals(""String_Node_Str"",integ.getName());
}"
57464,"/** 
 * {@inheritDoc} 
 */
public boolean isInfinite(){
  Iterator iter=entries.iterator();
  while (iter.hasNext()) {
    iter.advance();
    if (Double.isInfinite(iter.value())) {
      return true;
    }
  }
  return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean isInfinite(){
  boolean infiniteFound=false;
  boolean nanFound=false;
  Iterator iter=entries.iterator();
  while (iter.hasNext()) {
    iter.advance();
    final double value=iter.value();
    if (Double.isNaN(value)) {
      nanFound=true;
    }
    if (Double.isInfinite(value)) {
      infiniteFound=true;
    }
  }
  return infiniteFound && (!nanFound);
}"
57465,"/** 
 * {@inheritDoc} 
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  long temp;
  temp=Double.doubleToLongBits(epsilon);
  result=prime * result + (int)(temp ^ (temp >>> 32));
  result=prime * result + virtualSize;
  return result;
}","/** 
 * {@inheritDoc} 
 */
@Override public int hashCode(){
  final int prime=31;
  int result=1;
  long temp;
  temp=Double.doubleToLongBits(epsilon);
  result=prime * result + (int)(temp ^ (temp >>> 32));
  result=prime * result + virtualSize;
  Iterator iter=entries.iterator();
  while (iter.hasNext()) {
    iter.advance();
    temp=Double.doubleToLongBits(iter.value());
    result=prime * result + (int)(temp ^ (temp >>> 32));
  }
  return result;
}"
57466,"public void testPredicates(){
  SparseRealVector v=new SparseRealVector(new double[]{0,1,2});
  assertFalse(v.isNaN());
  v.setEntry(1,Double.NaN);
  assertTrue(v.isNaN());
  assertFalse(v.isInfinite());
  v.setEntry(0,Double.POSITIVE_INFINITY);
  assertFalse(v.isInfinite());
  v.setEntry(1,1);
  assertTrue(v.isInfinite());
  v.setEntry(0,0);
  assertEquals(v,new SparseRealVector(new double[]{0,1,2}));
  assertNotSame(v,new SparseRealVector(new double[]{0,1,2 + Math.ulp(2)}));
  assertNotSame(v,new SparseRealVector(new double[]{0,1,2,3}));
  assertEquals(new SparseRealVector(new double[]{Double.NaN,1,2}).hashCode(),new SparseRealVector(new double[]{0,Double.NaN,2}).hashCode());
  assertTrue(new SparseRealVector(new double[]{Double.NaN,1,2}).hashCode() != new SparseRealVector(new double[]{0,1,2}).hashCode());
}","public void testPredicates(){
  SparseRealVector v=new SparseRealVector(new double[]{0,1,2});
  assertFalse(v.isNaN());
  v.setEntry(1,Double.NaN);
  assertTrue(v.isNaN());
  assertFalse(v.isInfinite());
  v.setEntry(0,Double.POSITIVE_INFINITY);
  assertFalse(v.isInfinite());
  v.setEntry(1,1);
  assertTrue(v.isInfinite());
  v.setEntry(0,0);
  assertEquals(v,new SparseRealVector(new double[]{0,1,2}));
  assertNotSame(v,new SparseRealVector(new double[]{0,1,2 + Math.ulp(2)}));
  assertNotSame(v,new SparseRealVector(new double[]{0,1,2,3}));
  assertTrue(new SparseRealVector(new double[]{Double.NaN,1,2}).hashCode() != new SparseRealVector(new double[]{0,Double.NaN,2}).hashCode());
  assertTrue(new SparseRealVector(new double[]{Double.NaN,1,2}).hashCode() != new SparseRealVector(new double[]{0,1,2}).hashCode());
}"
57467,"/** 
 * Translate a string to a given locale.
 * @param s string to translate
 * @param locale locale into which to translate the string
 * @return translated string or original stringfor unsupported locales or unknown strings
 */
private static String translate(String s,Locale locale){
  try {
    if ((cachedResources == null) || (!cachedResources.getLocale().equals(locale))) {
      cachedResources=ResourceBundle.getBundle(""String_Node_Str"",locale);
    }
    if (cachedResources.getLocale().getLanguage().equals(locale.getLanguage())) {
      return cachedResources.getString(s);
    }
  }
 catch (  MissingResourceException mre) {
  }
  return s;
}","/** 
 * Translate a string to a given locale.
 * @param s string to translate
 * @param locale locale into which to translate the string
 * @return translated string or original stringfor unsupported locales or unknown strings
 */
private static String translate(String s,Locale locale){
  try {
    ResourceBundle bundle=ResourceBundle.getBundle(""String_Node_Str"",locale);
    if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {
      return bundle.getString(s);
    }
  }
 catch (  MissingResourceException mre) {
  }
  return s;
}"
57468,"/** 
 * Translate a string to a given locale.
 * @param s string to translate
 * @param locale locale into which to translate the string
 * @return translated string or original stringfor unsupported locales or unknown strings
 */
private static String translate(final String s,final Locale locale){
  try {
    if ((cachedResources == null) || (!cachedResources.getLocale().equals(locale))) {
      cachedResources=ResourceBundle.getBundle(""String_Node_Str"",locale);
    }
    if (cachedResources.getLocale().getLanguage().equals(locale.getLanguage())) {
      return cachedResources.getString(s);
    }
  }
 catch (  MissingResourceException mre) {
  }
  return s;
}","/** 
 * Translate a string to a given locale.
 * @param s string to translate
 * @param locale locale into which to translate the string
 * @return translated string or original stringfor unsupported locales or unknown strings
 */
private static String translate(final String s,final Locale locale){
  try {
    ResourceBundle bundle=ResourceBundle.getBundle(""String_Node_Str"",locale);
    if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {
      return bundle.getString(s);
    }
  }
 catch (  MissingResourceException mre) {
  }
  return s;
}"
57469,"/** 
 * Convenience method to find a zero of a univariate real function.  A default solver is used. 
 * @param f the function
 * @param x0 the lower bound for the interval
 * @param x1 the upper bound for the interval
 * @param absoluteAccuracy the accuracy to be used by the solver
 * @return a value where the function is zero
 * @throws ConvergenceException if the iteration count is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating thefunction
 * @throws IllegalArgumentException if f is null, the endpoints do not specify a valid interval, or the absoluteAccuracy is not valid for the default solver
 */
public static double solve(UnivariateRealFunction f,double x0,double x1,double absoluteAccuracy) throws ConvergenceException, FunctionEvaluationException {
  setup(f);
  UnivariateRealSolver solver=factory.newDefaultSolver();
  solver.setAbsoluteAccuracy(absoluteAccuracy);
  return solver.solve(f,x0,x1);
}","/** 
 * Convenience method to find a zero of a univariate real function.  A default solver is used. 
 * @param f the function
 * @param x0 the lower bound for the interval
 * @param x1 the upper bound for the interval
 * @param absoluteAccuracy the accuracy to be used by the solver
 * @return a value where the function is zero
 * @throws ConvergenceException if the iteration count is exceeded
 * @throws FunctionEvaluationException if an error occurs evaluating thefunction
 * @throws IllegalArgumentException if f is null, the endpoints do not specify a valid interval, or the absoluteAccuracy is not valid for the default solver
 */
public static double solve(UnivariateRealFunction f,double x0,double x1,double absoluteAccuracy) throws ConvergenceException, FunctionEvaluationException {
  setup(f);
  UnivariateRealSolver solver=LazyHolder.FACTORY.newDefaultSolver();
  solver.setAbsoluteAccuracy(absoluteAccuracy);
  return solver.solve(f,x0,x1);
}"
57470,"/** 
 * Checks to see if f is null, throwing IllegalArgumentException if so. Also initializes factory if factory is null.
 * @param f  input function
 * @throws IllegalArgumentException if f is null
 */
private static void setup(UnivariateRealFunction f){
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (factory == null) {
    factory=UnivariateRealSolverFactory.newInstance();
  }
}","/** 
 * Checks to see if f is null, throwing IllegalArgumentException if so.
 * @param f  input function
 * @throws IllegalArgumentException if f is null
 */
private static void setup(UnivariateRealFunction f){
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}"
57471,"/** 
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greaterthan <tt>object</tt>, 0 if they are equal.
 */
public int compareTo(Fraction object){
  int ret=0;
  if (this != object) {
    double first=doubleValue();
    double second=object.doubleValue();
    if (first < second) {
      ret=-1;
    }
 else     if (first > second) {
      ret=1;
    }
  }
  return ret;
}","/** 
 * Compares this object to another based on size.
 * @param object the object to compare to
 * @return -1 if this is less than <tt>object</tt>, +1 if this is greaterthan <tt>object</tt>, 0 if they are equal.
 */
public int compareTo(Fraction object){
  long nOd=((long)numerator) * object.denominator;
  long dOn=((long)denominator) * object.numerator;
  return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}"
57472,"/** 
 * Get the value of the given decision variable.  This is not the actual value as it is guaranteed to be >= 0 and thus must be corrected before being returned to the user.
 * @param decisionVariable The index of the decision variable
 * @return The value of the given decision variable.
 */
protected double getDecisionVariableValue(final int decisionVariable){
  Integer basicRow=getBasicRow(getNumObjectiveFunctions() + decisionVariable);
  return basicRow == null ? 0 : getEntry(basicRow,getRhsOffset());
}","/** 
 * Get the value of the given decision variable.  This is not the actual value as it is guaranteed to be >= 0 and thus must be corrected before being returned to the user.
 * @param decisionVariable The index of the decision variable
 * @return The value of the given decision variable.
 */
protected double getDecisionVariableValue(final int decisionVariable){
  int col=getNumObjectiveFunctions() + decisionVariable;
  Integer basicRow=getBasicRow(col);
  if (basicRow == null) {
    return 0;
  }
  for (int i=getNumObjectiveFunctions(); i < col; i++) {
    if (tableau.getEntry(basicRow,i) == 1) {
      return 0;
    }
  }
  return getEntry(basicRow,getRhsOffset());
}"
57473,"public void testLargeModel() throws OptimizationException {
  double[] objective=new double[]{1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
  LinearObjectiveFunction f=new LinearObjectiveFunction(objective,0);
  Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  SimplexSolver solver=new SimplexSolver();
  RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,true);
  assertEquals(13366.0,solution.getValue(),.0000001);
}","public void testLargeModel() throws OptimizationException {
  double[] objective=new double[]{1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
  LinearObjectiveFunction f=new LinearObjectiveFunction(objective,0);
  Collection<LinearConstraint> constraints=new ArrayList<LinearConstraint>();
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  constraints.add(equationFromString(objective.length,""String_Node_Str""));
  SimplexSolver solver=new SimplexSolver();
  RealPointValuePair solution=solver.optimize(f,constraints,GoalType.MINIMIZE,true);
  assertEquals(7518.0,solution.getValue(),.0000001);
}"
57474,"/** 
 * Set an entry of the tableau.
 * @param row row index
 * @param column column indexparam value for the entry
 */
protected final void setEntry(final int row,final int column,final double value){
  tableau.setEntry(row,column,value);
}","/** 
 * Set an entry of the tableau.
 * @param row row index
 * @param column column index
 * @param value for the entry
 */
protected final void setEntry(final int row,final int column,final double value){
  tableau.setEntry(row,column,value);
}"
57475,"public void testInterpolateLinearDegenerateTwoSegment() throws Exception {
  double x[]={0.0,0.5,1.0};
  double y[]={0.0,0.5,1.0};
  UnivariateRealInterpolator i=new SplineInterpolator();
  UnivariateRealFunction f=i.interpolate(x,y);
  verifyInterpolation(f,x,y);
  verifyConsistency((PolynomialSplineFunction)f,x);
  PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();
  double target[]={y[0],1d,0d,0d};
  TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);
  target=new double[]{y[1],1d,0d,0d};
  TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);
  assertEquals(0.0,f.value(0.0),interpolationTolerance);
  assertEquals(0.4,f.value(0.4),interpolationTolerance);
  assertEquals(1.0,f.value(1.0),interpolationTolerance);
}","public void testInterpolateLinearDegenerateTwoSegment() throws Exception {
  double x[]={0.0,0.5,1.0};
  double y[]={0.0,0.5,1.0};
  UnivariateRealInterpolator i=new SplineInterpolator();
  UnivariateRealFunction f=i.interpolate(x,y);
  verifyInterpolation(f,x,y);
  verifyConsistency((PolynomialSplineFunction)f,x);
  PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();
  double target[]={y[0],1d};
  TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);
  target=new double[]{y[1],1d};
  TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);
  assertEquals(0.0,f.value(0.0),interpolationTolerance);
  assertEquals(0.4,f.value(0.4),interpolationTolerance);
  assertEquals(1.0,f.value(1.0),interpolationTolerance);
}"
57476,"public void testInterpolateLinearDegenerateThreeSegment() throws Exception {
  double x[]={0.0,0.5,1.0,1.5};
  double y[]={0.0,0.5,1.0,1.5};
  UnivariateRealInterpolator i=new SplineInterpolator();
  UnivariateRealFunction f=i.interpolate(x,y);
  verifyInterpolation(f,x,y);
  PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();
  double target[]={y[0],1d,0d,0d};
  TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);
  target=new double[]{y[1],1d,0d,0d};
  TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);
  target=new double[]{y[2],1d,0d,0d};
  TestUtils.assertEquals(polynomials[2].getCoefficients(),target,coefficientTolerance);
  assertEquals(0,f.value(0),interpolationTolerance);
  assertEquals(1.4,f.value(1.4),interpolationTolerance);
  assertEquals(1.5,f.value(1.5),interpolationTolerance);
}","public void testInterpolateLinearDegenerateThreeSegment() throws Exception {
  double x[]={0.0,0.5,1.0,1.5};
  double y[]={0.0,0.5,1.0,1.5};
  UnivariateRealInterpolator i=new SplineInterpolator();
  UnivariateRealFunction f=i.interpolate(x,y);
  verifyInterpolation(f,x,y);
  PolynomialFunction polynomials[]=((PolynomialSplineFunction)f).getPolynomials();
  double target[]={y[0],1d};
  TestUtils.assertEquals(polynomials[0].getCoefficients(),target,coefficientTolerance);
  target=new double[]{y[1],1d};
  TestUtils.assertEquals(polynomials[1].getCoefficients(),target,coefficientTolerance);
  target=new double[]{y[2],1d};
  TestUtils.assertEquals(polynomials[2].getCoefficients(),target,coefficientTolerance);
  assertEquals(0,f.value(0),interpolationTolerance);
  assertEquals(1.4,f.value(1.4),interpolationTolerance);
  assertEquals(1.5,f.value(1.5),interpolationTolerance);
}"
57477,"/** 
 * Returns the natural <code>log</code> of the <a href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial Coefficient</a>, ""<code>n choose k</code>"", the number of <code>k</code>-element subsets that can be selected from an <code>n</code>-element set. <p> <Strong>Preconditions</strong>: <ul> <li> <code>0 <= k <= n </code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> </ul></p>
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double binomialCoefficientLog(final int n,final int k){
  if (n < k) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((n == k) || (k == 0)) {
    return 0;
  }
  if ((k == 1) || (k == n - 1)) {
    return Math.log((double)n);
  }
  double logSum=0;
  for (int i=k + 1; i <= n; i++) {
    logSum+=Math.log((double)i);
  }
  for (int i=2; i <= n - k; i++) {
    logSum-=Math.log((double)i);
  }
  return logSum;
}","/** 
 * Returns the natural <code>log</code> of the <a href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial Coefficient</a>, ""<code>n choose k</code>"", the number of <code>k</code>-element subsets that can be selected from an <code>n</code>-element set. <p> <Strong>Preconditions</strong>: <ul> <li> <code>0 <= k <= n </code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> </ul></p>
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double binomialCoefficientLog(final int n,final int k){
  if (n < k) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((n == k) || (k == 0)) {
    return 0;
  }
  if ((k == 1) || (k == n - 1)) {
    return Math.log((double)n);
  }
  if (n < 67) {
    return Math.log(binomialCoefficient(n,k));
  }
  if (n < 1030) {
    return Math.log(binomialCoefficientDouble(n,k));
  }
  double logSum=0;
  for (int i=k + 1; i <= n; i++) {
    logSum+=Math.log((double)i);
  }
  for (int i=2; i <= n - k; i++) {
    logSum-=Math.log((double)i);
  }
  return logSum;
}"
57478,"/** 
 * Returns a <code>double</code> representation of the <a href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial Coefficient</a>, ""<code>n choose k</code>"", the number of <code>k</code>-element subsets that can be selected from an <code>n</code>-element set. <p> <Strong>Preconditions</strong>: <ul> <li> <code>0 <= k <= n </code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>double</code>. The largest value of <code>n</code> for which all coefficients are < Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li> </ul></p>
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double binomialCoefficientDouble(final int n,final int k){
  return Math.floor(Math.exp(binomialCoefficientLog(n,k)) + 0.5);
}","/** 
 * Returns a <code>double</code> representation of the <a href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial Coefficient</a>, ""<code>n choose k</code>"", the number of <code>k</code>-element subsets that can be selected from an <code>n</code>-element set. <p> <Strong>Preconditions</strong>: <ul> <li> <code>0 <= k <= n </code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>double</code>. The largest value of <code>n</code> for which all coefficients are < Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li> </ul></p>
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double binomialCoefficientDouble(final int n,final int k){
  if (n < k) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((n == k) || (k == 0)) {
    return 1d;
  }
  if ((k == 1) || (k == n - 1)) {
    return n;
  }
  if (k > n / 2) {
    return binomialCoefficientDouble(n,n - k);
  }
  if (n < 67) {
    return binomialCoefficient(n,k);
  }
  double result=1d;
  for (int i=1; i <= k; i++) {
    result*=(double)(n - k + i) / (double)i;
  }
  return Math.floor(result + 0.5);
}"
57479,"/** 
 * Returns an exact representation of the <a href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial Coefficient</a>, ""<code>n choose k</code>"", the number of <code>k</code>-element subsets that can be selected from an <code>n</code>-element set. <p> <Strong>Preconditions</strong>: <ul> <li> <code>0 <= k <= n </code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>long</code>. The largest value of <code>n</code> for which all coefficients are <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is thrown.</li> </ul></p>
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be representedby a long integer.
 */
public static long binomialCoefficient(final int n,final int k){
  if (n < k) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((n == k) || (k == 0)) {
    return 1;
  }
  if ((k == 1) || (k == n - 1)) {
    return n;
  }
  long result=Math.round(binomialCoefficientDouble(n,k));
  if (result == Long.MAX_VALUE) {
    throw new ArithmeticException(""String_Node_Str"");
  }
  return result;
}","/** 
 * Returns an exact representation of the <a href=""http://mathworld.wolfram.com/BinomialCoefficient.html""> Binomial Coefficient</a>, ""<code>n choose k</code>"", the number of <code>k</code>-element subsets that can be selected from an <code>n</code>-element set. <p> <Strong>Preconditions</strong>: <ul> <li> <code>0 <= k <= n </code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>long</code>. The largest value of <code>n</code> for which all coefficients are <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is thrown.</li> </ul></p>
 * @param n the size of the set
 * @param k the size of the subsets to be counted
 * @return <code>n choose k</code>
 * @throws IllegalArgumentException if preconditions are not met.
 * @throws ArithmeticException if the result is too large to be representedby a long integer.
 */
public static long binomialCoefficient(final int n,final int k){
  if (n < k) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if ((n == k) || (k == 0)) {
    return 1;
  }
  if ((k == 1) || (k == n - 1)) {
    return n;
  }
  if (k > n / 2)   return binomialCoefficient(n,n - k);
  long result=1;
  if (n <= 61) {
    for (int j=1, i=n - k + 1; j <= k; i++, j++) {
      result=result * i / j;
    }
  }
 else   if (n <= 66) {
    for (int j=1, i=n - k + 1; j <= k; i++, j++) {
      long d=gcd(i,j);
      result=(result / (j / d)) * (i / d);
    }
  }
 else {
    for (int j=1, i=n - k + 1; j <= k; i++, j++) {
      long d=gcd(i,j);
      result=mulAndCheck((result / (j / d)),(i / d));
    }
  }
  return result;
}"
57480,"/** 
 * Returns n!. Shorthand for <code>n</code> <a href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the product of the numbers <code>1,...,n</code>. <p> <Strong>Preconditions</strong>: <ul> <li> <code>n >= 0</code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>long</code>. The largest value of <code>n</code> for which <code>n!</code> < Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException </code> is thrown.</li> </ul> </p>
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be representedby a long integer.
 * @throws IllegalArgumentException if n < 0
 */
public static long factorial(final int n){
  long result=Math.round(factorialDouble(n));
  if (result == Long.MAX_VALUE) {
    throw new ArithmeticException(""String_Node_Str"");
  }
  return result;
}","/** 
 * Returns n!. Shorthand for <code>n</code> <a href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the product of the numbers <code>1,...,n</code>. <p> <Strong>Preconditions</strong>: <ul> <li> <code>n >= 0</code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>long</code>. The largest value of <code>n</code> for which <code>n!</code> < Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException </code> is thrown.</li> </ul> </p>
 * @param n argument
 * @return <code>n!</code>
 * @throws ArithmeticException if the result is too large to be representedby a long integer.
 * @throws IllegalArgumentException if n < 0
 */
public static long factorial(final int n){
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n > 20) {
    throw new ArithmeticException(""String_Node_Str"");
  }
  return factorials[n];
}"
57481,"/** 
 * Returns n!. Shorthand for <code>n</code> <a href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the product of the numbers <code>1,...,n</code> as a <code>double</code>. <p> <Strong>Preconditions</strong>: <ul> <li> <code>n >= 0</code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>double</code>. The largest value of <code>n</code> for which <code>n!</code> < Double.MAX_VALUE</code> is 170. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li> </ul> </p>
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */
public static double factorialDouble(final int n){
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}","/** 
 * Returns n!. Shorthand for <code>n</code> <a href=""http://mathworld.wolfram.com/Factorial.html""> Factorial</a>, the product of the numbers <code>1,...,n</code> as a <code>double</code>. <p> <Strong>Preconditions</strong>: <ul> <li> <code>n >= 0</code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> <li> The result is small enough to fit into a <code>double</code>. The largest value of <code>n</code> for which <code>n!</code> < Double.MAX_VALUE</code> is 170. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li> </ul> </p>
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if n < 0
 */
public static double factorialDouble(final int n){
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n < 21) {
    return factorial(n);
  }
  return Math.floor(Math.exp(factorialLog(n)) + 0.5);
}"
57482,"/** 
 * Returns the natural logarithm of n!. <p> <Strong>Preconditions</strong>: <ul> <li> <code>n >= 0</code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> </ul></p>
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double factorialLog(final int n){
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  double logSum=0;
  for (int i=2; i <= n; i++) {
    logSum+=Math.log((double)i);
  }
  return logSum;
}","/** 
 * Returns the natural logarithm of n!. <p> <Strong>Preconditions</strong>: <ul> <li> <code>n >= 0</code> (otherwise <code>IllegalArgumentException</code> is thrown)</li> </ul></p>
 * @param n argument
 * @return <code>n!</code>
 * @throws IllegalArgumentException if preconditions are not met.
 */
public static double factorialLog(final int n){
  if (n < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (n < 21) {
    return Math.log(factorial(n));
  }
  double logSum=0;
  for (int i=2; i <= n; i++) {
    logSum+=Math.log((double)i);
  }
  return logSum;
}"
57483,"/** 
 * <p> Gets the greatest common divisor of the absolute value of two numbers, using the ""binary gcd"" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). </p>
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */
public static int gcd(int u,int v){
  if (u * v == 0) {
    return (Math.abs(u) + Math.abs(v));
  }
  if (u > 0) {
    u=-u;
  }
  if (v > 0) {
    v=-v;
  }
  int k=0;
  while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
    u/=2;
    v/=2;
    k++;
  }
  if (k == 31) {
    throw new ArithmeticException(""String_Node_Str"");
  }
  int t=((u & 1) == 1) ? v : -(u / 2);
  do {
    while ((t & 1) == 0) {
      t/=2;
    }
    if (t > 0) {
      u=-t;
    }
 else {
      v=t;
    }
    t=(v - u) / 2;
  }
 while (t != 0);
  return -u * (1 << k);
}","/** 
 * <p> Gets the greatest common divisor of the absolute value of two numbers, using the ""binary gcd"" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). </p>
 * @param u a non-zero number
 * @param v a non-zero number
 * @return the greatest common divisor, never zero
 * @since 1.1
 */
public static int gcd(int u,int v){
  if ((u == 0) || (v == 0)) {
    return (Math.abs(u) + Math.abs(v));
  }
  if (u > 0) {
    u=-u;
  }
  if (v > 0) {
    v=-v;
  }
  int k=0;
  while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {
    u/=2;
    v/=2;
    k++;
  }
  if (k == 31) {
    throw new ArithmeticException(""String_Node_Str"");
  }
  int t=((u & 1) == 1) ? v : -(u / 2);
  do {
    while ((t & 1) == 0) {
      t/=2;
    }
    if (t > 0) {
      u=-t;
    }
 else {
      v=t;
    }
    t=(v - u) / 2;
  }
 while (t != 0);
  return -u * (1 << k);
}"
57484,"/** 
 * {@inheritDoc} 
 */
public RealMatrix getQT() throws IllegalStateException {
  if (cachedQT == null) {
    final int n=qrt.length;
    final int m=qrt[0].length;
    cachedQT=MatrixUtils.createRealMatrix(m,m);
    for (int minor=m - 1; minor >= Math.min(m,n); minor--) {
      cachedQT.setEntry(minor,minor,1.0);
    }
    for (int minor=Math.min(m,n) - 1; minor >= 0; minor--) {
      final double[] qrtMinor=qrt[minor];
      cachedQT.setEntry(minor,minor,1.0);
      if (qrtMinor[minor] != 0.0) {
        for (int col=minor; col < m; col++) {
          double alpha=0;
          for (int row=minor; row < m; row++) {
            alpha-=cachedQT.getEntry(col,row) * qrtMinor[row];
          }
          alpha/=rDiag[minor] * qrtMinor[minor];
          for (int row=minor; row < m; row++) {
            cachedQT.addToEntry(col,row,-alpha * qrtMinor[row]);
          }
        }
      }
    }
  }
  return cachedQT;
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix getQT(){
  if (cachedQT == null) {
    final int n=qrt.length;
    final int m=qrt[0].length;
    cachedQT=MatrixUtils.createRealMatrix(m,m);
    for (int minor=m - 1; minor >= Math.min(m,n); minor--) {
      cachedQT.setEntry(minor,minor,1.0);
    }
    for (int minor=Math.min(m,n) - 1; minor >= 0; minor--) {
      final double[] qrtMinor=qrt[minor];
      cachedQT.setEntry(minor,minor,1.0);
      if (qrtMinor[minor] != 0.0) {
        for (int col=minor; col < m; col++) {
          double alpha=0;
          for (int row=minor; row < m; row++) {
            alpha-=cachedQT.getEntry(col,row) * qrtMinor[row];
          }
          alpha/=rDiag[minor] * qrtMinor[minor];
          for (int row=minor; row < m; row++) {
            cachedQT.addToEntry(col,row,-alpha * qrtMinor[row]);
          }
        }
      }
    }
  }
  return cachedQT;
}"
57485,"/** 
 * {@inheritDoc} 
 */
public RealMatrix getH() throws IllegalStateException {
  if (cachedH == null) {
    final int n=qrt.length;
    final int m=qrt[0].length;
    cachedH=MatrixUtils.createRealMatrix(m,n);
    for (int i=0; i < m; ++i) {
      for (int j=0; j < Math.min(i + 1,n); ++j) {
        cachedH.setEntry(i,j,qrt[j][i] / -rDiag[j]);
      }
    }
  }
  return cachedH;
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix getH(){
  if (cachedH == null) {
    final int n=qrt.length;
    final int m=qrt[0].length;
    cachedH=MatrixUtils.createRealMatrix(m,n);
    for (int i=0; i < m; ++i) {
      for (int j=0; j < Math.min(i + 1,n); ++j) {
        cachedH.setEntry(i,j,qrt[j][i] / -rDiag[j]);
      }
    }
  }
  return cachedH;
}"
57486,"/** 
 * {@inheritDoc} 
 */
public RealMatrix getInverse() throws IllegalStateException, InvalidMatrixException {
  return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix getInverse() throws InvalidMatrixException {
  return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));
}"
57487,"/** 
 * Calculates the QR-decomposition of the given matrix.  <p>Calling this constructor is equivalent to first call the no-arguments constructor and then call   {@link #decompose(RealMatrix)}.</p>
 * @param matrix The matrix to decompose.
 */
public QRDecompositionImpl(RealMatrix matrix){
  final int m=matrix.getRowDimension();
  final int n=matrix.getColumnDimension();
  qrt=matrix.transpose().getData();
  rDiag=new double[n];
  cachedQ=null;
  cachedQT=null;
  cachedR=null;
  cachedH=null;
  for (int minor=0; minor < Math.min(m,n); minor++) {
    final double[] qrtMinor=qrt[minor];
    double xNormSqr=0;
    for (int row=minor; row < m; row++) {
      final double c=qrtMinor[row];
      xNormSqr+=c * c;
    }
    final double a=(qrtMinor[minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
    rDiag[minor]=a;
    if (a != 0.0) {
      qrtMinor[minor]-=a;
      for (int col=minor + 1; col < n; col++) {
        final double[] qrtCol=qrt[col];
        double alpha=0;
        for (int row=minor; row < m; row++) {
          alpha-=qrtCol[row] * qrtMinor[row];
        }
        alpha/=a * qrtMinor[minor];
        for (int row=minor; row < m; row++) {
          qrtCol[row]-=alpha * qrtMinor[row];
        }
      }
    }
  }
}","/** 
 * Calculates the QR-decomposition of the given matrix.  <p>Calling this constructor is equivalent to first call the no-arguments constructor and then call   {@link #decompose(RealMatrix)}.</p>
 * @param matrix The matrix to decompose.
 */
public QRDecompositionImpl(RealMatrix matrix){
  final int m=matrix.getRowDimension();
  final int n=matrix.getColumnDimension();
  qrt=matrix.transpose().getData();
  rDiag=new double[Math.min(m,n)];
  cachedQ=null;
  cachedQT=null;
  cachedR=null;
  cachedH=null;
  for (int minor=0; minor < Math.min(m,n); minor++) {
    final double[] qrtMinor=qrt[minor];
    double xNormSqr=0;
    for (int row=minor; row < m; row++) {
      final double c=qrtMinor[row];
      xNormSqr+=c * c;
    }
    final double a=(qrtMinor[minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);
    rDiag[minor]=a;
    if (a != 0.0) {
      qrtMinor[minor]-=a;
      for (int col=minor + 1; col < n; col++) {
        final double[] qrtCol=qrt[col];
        double alpha=0;
        for (int row=minor; row < m; row++) {
          alpha-=qrtCol[row] * qrtMinor[row];
        }
        alpha/=a * qrtMinor[minor];
        for (int row=minor; row < m; row++) {
          qrtCol[row]-=alpha * qrtMinor[row];
        }
      }
    }
  }
}"
57488,"/** 
 * {@inheritDoc} 
 */
public RealMatrix solve(RealMatrix b) throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {
  final int n=qrt.length;
  final int m=qrt[0].length;
  if (b.getRowDimension() != m) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!isNonSingular()) {
    throw new SingularMatrixException();
  }
  final int cols=b.getColumnDimension();
  final double[][] xData=new double[n][cols];
  final double[] y=new double[b.getRowDimension()];
  for (int k=0; k < cols; ++k) {
    for (int j=0; j < y.length; ++j) {
      y[j]=b.getEntry(j,k);
    }
    for (int minor=0; minor < Math.min(m,n); minor++) {
      final double[] qrtMinor=qrt[minor];
      double dotProduct=0;
      for (int row=minor; row < m; row++) {
        dotProduct+=y[row] * qrtMinor[row];
      }
      dotProduct/=rDiag[minor] * qrtMinor[minor];
      for (int row=minor; row < m; row++) {
        y[row]+=dotProduct * qrtMinor[row];
      }
    }
    for (int row=n - 1; row >= 0; --row) {
      y[row]/=rDiag[row];
      final double yRow=y[row];
      final double[] qrtRow=qrt[row];
      xData[row][k]=yRow;
      for (int i=0; i < row; i++) {
        y[i]-=yRow * qrtRow[i];
      }
    }
  }
  return new RealMatrixImpl(xData,false);
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException {
  final int n=qrt.length;
  final int m=qrt[0].length;
  if (b.getRowDimension() != m) {
    throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",new Object[]{b.getRowDimension(),b.getColumnDimension(),m,""String_Node_Str""});
  }
  if (!isNonSingular()) {
    throw new SingularMatrixException();
  }
  final int columns=b.getColumnDimension();
  final int blockSize=DenseRealMatrix.BLOCK_SIZE;
  final int cBlocks=(columns + blockSize - 1) / blockSize;
  final double[][] xBlocks=DenseRealMatrix.createBlocksLayout(n,columns);
  final double[][] y=new double[b.getRowDimension()][blockSize];
  final double[] alpha=new double[blockSize];
  for (int kBlock=0; kBlock < cBlocks; ++kBlock) {
    final int kStart=kBlock * blockSize;
    final int kEnd=Math.min(kStart + blockSize,columns);
    final int kWidth=kEnd - kStart;
    b.copySubMatrix(0,m - 1,kStart,kEnd - 1,y);
    for (int minor=0; minor < Math.min(m,n); minor++) {
      final double[] qrtMinor=qrt[minor];
      final double factor=1.0 / (rDiag[minor] * qrtMinor[minor]);
      Arrays.fill(alpha,0,kWidth,0.0);
      for (int row=minor; row < m; ++row) {
        final double d=qrtMinor[row];
        final double[] yRow=y[row];
        for (int k=0; k < kWidth; ++k) {
          alpha[k]+=d * yRow[k];
        }
      }
      for (int k=0; k < kWidth; ++k) {
        alpha[k]*=factor;
      }
      for (int row=minor; row < m; ++row) {
        final double d=qrtMinor[row];
        final double[] yRow=y[row];
        for (int k=0; k < kWidth; ++k) {
          yRow[k]+=alpha[k] * d;
        }
      }
    }
    for (int j=rDiag.length - 1; j >= 0; --j) {
      final int jBlock=j / blockSize;
      final int jStart=jBlock * blockSize;
      final double factor=1.0 / rDiag[j];
      final double[] yJ=y[j];
      final double[] xBlock=xBlocks[jBlock * cBlocks + kBlock];
      for (int k=0, index=(j - jStart) * kWidth; k < kWidth; ++k, ++index) {
        yJ[k]*=factor;
        xBlock[index]=yJ[k];
      }
      final double[] qrtJ=qrt[j];
      for (int i=0; i < j; ++i) {
        final double rIJ=qrtJ[i];
        final double[] yI=y[i];
        for (int k=0; k < kWidth; ++k) {
          yI[k]-=yJ[k] * rIJ;
        }
      }
    }
  }
  return new DenseRealMatrix(n,columns,xBlocks,false);
}"
57489,"/** 
 * {@inheritDoc} 
 */
public boolean isNonSingular() throws IllegalStateException {
  for (  double diag : rDiag) {
    if (diag == 0) {
      return false;
    }
  }
  return true;
}","/** 
 * {@inheritDoc} 
 */
public boolean isNonSingular(){
  for (  double diag : rDiag) {
    if (diag == 0) {
      return false;
    }
  }
  return true;
}"
57490,"/** 
 * {@inheritDoc} 
 */
public RealMatrix getQ() throws IllegalStateException {
  if (cachedQ == null) {
    cachedQ=getQT().transpose();
  }
  return cachedQ;
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix getQ(){
  if (cachedQ == null) {
    cachedQ=getQT().transpose();
  }
  return cachedQ;
}"
57491,"/** 
 * {@inheritDoc} 
 */
public RealMatrix getSubMatrix(final int startRow,final int endRow,final int startColumn,final int endColumn) throws MatrixIndexException {
  checkSubMatrixIndex(startRow,endRow,startColumn,endColumn);
  final DenseRealMatrix out=new DenseRealMatrix(endRow - startRow + 1,endColumn - startColumn + 1);
  final int blockStartRow=startRow / BLOCK_SIZE;
  final int rowsShift=startRow % BLOCK_SIZE;
  final int blockStartColumn=startColumn / BLOCK_SIZE;
  final int columnsShift=startColumn % BLOCK_SIZE;
  for (int iBlock=0, pBlock=blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {
    final int iHeight=out.blockHeight(iBlock);
    for (int jBlock=0, qBlock=blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {
      final int jWidth=out.blockWidth(jBlock);
      final int outIndex=iBlock * out.blockColumns + jBlock;
      final double[] outBlock=out.blocks[outIndex];
      final int index=pBlock * blockColumns + qBlock;
      final int width=blockWidth(index);
      final int heightExcess=iHeight + rowsShift - BLOCK_SIZE;
      final int widthExcess=jWidth + columnsShift - BLOCK_SIZE;
      if (heightExcess > 0) {
        if (widthExcess > 0) {
          final int width2=blockWidth(index + 1);
          copyBlockPart(blocks[index],width,rowsShift,BLOCK_SIZE,columnsShift,BLOCK_SIZE,outBlock,jWidth,0,0);
          copyBlockPart(blocks[index + 1],width2,rowsShift,BLOCK_SIZE,0,widthExcess,outBlock,jWidth,0,jWidth - widthExcess);
          copyBlockPart(blocks[index + blockColumns],width,0,heightExcess,columnsShift,BLOCK_SIZE,outBlock,jWidth,iHeight - heightExcess,0);
          copyBlockPart(blocks[index + blockColumns + 1],width2,0,heightExcess,0,widthExcess,outBlock,jWidth,iHeight - heightExcess,jWidth - widthExcess);
        }
 else {
          copyBlockPart(blocks[index],width,rowsShift,BLOCK_SIZE,columnsShift,jWidth + columnsShift,outBlock,jWidth,0,0);
          copyBlockPart(blocks[index + blockColumns],width,0,heightExcess,columnsShift,jWidth + columnsShift,outBlock,jWidth,iHeight - heightExcess,0);
        }
      }
 else {
        if (widthExcess > 0) {
          final int width2=blockWidth(index + 1);
          copyBlockPart(blocks[index],width,rowsShift,iHeight + rowsShift,columnsShift,BLOCK_SIZE,outBlock,jWidth,0,0);
          copyBlockPart(blocks[index + 1],width2,rowsShift,iHeight + rowsShift,0,widthExcess,outBlock,jWidth,0,jWidth - widthExcess);
        }
 else {
          copyBlockPart(blocks[index],width,rowsShift,iHeight + rowsShift,columnsShift,jWidth + columnsShift,outBlock,jWidth,0,0);
        }
      }
    }
  }
  return out;
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix getSubMatrix(final int startRow,final int endRow,final int startColumn,final int endColumn) throws MatrixIndexException {
  checkSubMatrixIndex(startRow,endRow,startColumn,endColumn);
  final DenseRealMatrix out=new DenseRealMatrix(endRow - startRow + 1,endColumn - startColumn + 1);
  final int blockStartRow=startRow / BLOCK_SIZE;
  final int rowsShift=startRow % BLOCK_SIZE;
  final int blockStartColumn=startColumn / BLOCK_SIZE;
  final int columnsShift=startColumn % BLOCK_SIZE;
  for (int iBlock=0, pBlock=blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {
    final int iHeight=out.blockHeight(iBlock);
    for (int jBlock=0, qBlock=blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {
      final int jWidth=out.blockWidth(jBlock);
      final int outIndex=iBlock * out.blockColumns + jBlock;
      final double[] outBlock=out.blocks[outIndex];
      final int index=pBlock * blockColumns + qBlock;
      final int width=blockWidth(qBlock);
      final int heightExcess=iHeight + rowsShift - BLOCK_SIZE;
      final int widthExcess=jWidth + columnsShift - BLOCK_SIZE;
      if (heightExcess > 0) {
        if (widthExcess > 0) {
          final int width2=blockWidth(qBlock + 1);
          copyBlockPart(blocks[index],width,rowsShift,BLOCK_SIZE,columnsShift,BLOCK_SIZE,outBlock,jWidth,0,0);
          copyBlockPart(blocks[index + 1],width2,rowsShift,BLOCK_SIZE,0,widthExcess,outBlock,jWidth,0,jWidth - widthExcess);
          copyBlockPart(blocks[index + blockColumns],width,0,heightExcess,columnsShift,BLOCK_SIZE,outBlock,jWidth,iHeight - heightExcess,0);
          copyBlockPart(blocks[index + blockColumns + 1],width2,0,heightExcess,0,widthExcess,outBlock,jWidth,iHeight - heightExcess,jWidth - widthExcess);
        }
 else {
          copyBlockPart(blocks[index],width,rowsShift,BLOCK_SIZE,columnsShift,jWidth + columnsShift,outBlock,jWidth,0,0);
          copyBlockPart(blocks[index + blockColumns],width,0,heightExcess,columnsShift,jWidth + columnsShift,outBlock,jWidth,iHeight - heightExcess,0);
        }
      }
 else {
        if (widthExcess > 0) {
          final int width2=blockWidth(qBlock + 1);
          copyBlockPart(blocks[index],width,rowsShift,iHeight + rowsShift,columnsShift,BLOCK_SIZE,outBlock,jWidth,0,0);
          copyBlockPart(blocks[index + 1],width2,rowsShift,iHeight + rowsShift,0,widthExcess,outBlock,jWidth,0,jWidth - widthExcess);
        }
 else {
          copyBlockPart(blocks[index],width,rowsShift,iHeight + rowsShift,columnsShift,jWidth + columnsShift,outBlock,jWidth,0,0);
        }
      }
    }
  }
  return out;
}"
57492,"public static RealMatrix createOrthogonalMatrix(final Random r,final int size){
  final double[][] data=new double[size][size];
  for (int i=0; i < size; ++i) {
    final double[] dataI=data[i];
    double norm2=0;
    do {
      for (int j=0; j < size; ++j) {
        dataI[j]=2 * r.nextDouble() - 1;
      }
      for (int k=0; k < i; ++k) {
        final double[] dataK=data[k];
        double dotProduct=0;
        for (int j=0; j < size; ++j) {
          dotProduct+=dataI[j] * dataK[j];
        }
        for (int j=0; j < size; ++j) {
          dataI[j]-=dotProduct * dataK[j];
        }
      }
      norm2=0;
      for (      final double dataIJ : dataI) {
        norm2+=dataIJ * dataIJ;
      }
      final double inv=1.0 / Math.sqrt(norm2);
      for (int j=0; j < size; ++j) {
        dataI[j]*=inv;
      }
    }
 while (norm2 * size < 0.01);
  }
  return new RealMatrixImpl(data,false);
}","public static RealMatrix createOrthogonalMatrix(final Random r,final int size){
  final double[][] data=new double[size][size];
  for (int i=0; i < size; ++i) {
    final double[] dataI=data[i];
    double norm2=0;
    do {
      for (int j=0; j < size; ++j) {
        dataI[j]=2 * r.nextDouble() - 1;
      }
      for (int k=0; k < i; ++k) {
        final double[] dataK=data[k];
        double dotProduct=0;
        for (int j=0; j < size; ++j) {
          dotProduct+=dataI[j] * dataK[j];
        }
        for (int j=0; j < size; ++j) {
          dataI[j]-=dotProduct * dataK[j];
        }
      }
      norm2=0;
      for (      final double dataIJ : dataI) {
        norm2+=dataIJ * dataIJ;
      }
      final double inv=1.0 / Math.sqrt(norm2);
      for (int j=0; j < size; ++j) {
        dataI[j]*=inv;
      }
    }
 while (norm2 * size < 0.01);
  }
  return MatrixUtils.createRealMatrix(data);
}"
57493,"/** 
 * test eigenvectors 
 */
public void testEigenvectors(){
  EigenDecomposition ed=new EigenDecompositionImpl(matrix,MathUtils.SAFE_MIN);
  for (int i=0; i < matrix.getRowDimension(); ++i) {
    double lambda=ed.getEigenvalue(i);
    RealVector v=ed.getEigenvector(i);
    RealVector mV=matrix.operate(v);
    assertEquals(0,mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(),1.0e-13);
  }
}","/** 
 * test eigenvectors 
 */
public void testEigenvectors(){
  EigenDecomposition ed=new EigenDecompositionImpl(matrix,MathUtils.SAFE_MIN);
  for (int i=0; i < matrix.getRowDimension(); ++i) {
    double lambda=ed.getEigenvalue(i);
    RealVector v=ed.getEigenvector(i);
    RealVector mV=matrix.operate(v);
    System.out.println(lambda + ""String_Node_Str"" + v+ ""String_Node_Str""+ mV);
    assertEquals(0,mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(),1.0e-13);
  }
}"
57494,"/** 
 * {@inheritDoc} 
 */
public void setSubMatrix(final double[][] subMatrix,final int row,final int column) throws MatrixIndexException {
  if (data == null) {
    if (row > 0) {
      throw MathRuntimeException.createIllegalStateException(""String_Node_Str"",new Object[]{row});
    }
    if (column > 0) {
      throw MathRuntimeException.createIllegalStateException(""String_Node_Str"",new Object[]{column});
    }
    data=new double[subMatrix.length][subMatrix[0].length];
    for (int i=0; i < data.length; ++i) {
      System.arraycopy(subMatrix[i],0,data[i],0,subMatrix[i].length);
    }
  }
 else {
    super.setSubMatrix(subMatrix,row,column);
  }
}","/** 
 * {@inheritDoc} 
 */
public void setSubMatrix(final double[][] subMatrix,final int row,final int column) throws MatrixIndexException {
  if (data == null) {
    if (row > 0) {
      throw MathRuntimeException.createIllegalStateException(""String_Node_Str"",new Object[]{row});
    }
    if (column > 0) {
      throw MathRuntimeException.createIllegalStateException(""String_Node_Str"",new Object[]{column});
    }
    final int nRows=subMatrix.length;
    if (nRows == 0) {
      throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",null);
    }
    final int nCols=subMatrix[0].length;
    if (nCols == 0) {
      throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",null);
    }
    data=new double[subMatrix.length][nCols];
    for (int i=0; i < data.length; ++i) {
      if (subMatrix[i].length != nCols) {
        throw MathRuntimeException.createIllegalArgumentException(""String_Node_Str"",new Object[]{nCols,subMatrix[i].length});
      }
      System.arraycopy(subMatrix[i],0,data[i + row],column,nCols);
    }
  }
 else {
    super.setSubMatrix(subMatrix,row,column);
  }
}"
57495,"/** 
 * {@inheritDoc} 
 */
public RealMatrix getQT() throws IllegalStateException {
  if (cachedQ == null) {
    checkDecomposed();
    final int n=qrt.length;
    final int m=qrt[0].length;
    double[][] qT=new double[m][m];
    for (int minor=m - 1; minor >= Math.min(m,n); minor--) {
      qT[minor][minor]=1;
    }
    for (int minor=Math.min(m,n) - 1; minor >= 0; minor--) {
      final double[] qrtMinor=qrt[minor];
      qT[minor][minor]=1;
      if (qrtMinor[minor] != 0.0) {
        for (int col=minor; col < m; col++) {
          final double[] qTCol=qT[col];
          double alpha=0;
          for (int row=minor; row < m; row++) {
            alpha-=qTCol[row] * qrtMinor[row];
          }
          alpha/=rDiag[minor] * qrtMinor[minor];
          for (int row=minor; row < m; row++) {
            qTCol[row]-=alpha * qrtMinor[row];
          }
        }
      }
    }
    cachedQT=new RealMatrixImpl(qT,false);
  }
  return cachedQT;
}","/** 
 * {@inheritDoc} 
 */
public RealMatrix getQT() throws IllegalStateException {
  if (cachedQT == null) {
    checkDecomposed();
    final int n=qrt.length;
    final int m=qrt[0].length;
    double[][] qT=new double[m][m];
    for (int minor=m - 1; minor >= Math.min(m,n); minor--) {
      qT[minor][minor]=1;
    }
    for (int minor=Math.min(m,n) - 1; minor >= 0; minor--) {
      final double[] qrtMinor=qrt[minor];
      qT[minor][minor]=1;
      if (qrtMinor[minor] != 0.0) {
        for (int col=minor; col < m; col++) {
          final double[] qTCol=qT[col];
          double alpha=0;
          for (int row=minor; row < m; row++) {
            alpha-=qTCol[row] * qrtMinor[row];
          }
          alpha/=rDiag[minor] * qrtMinor[minor];
          for (int row=minor; row < m; row++) {
            qTCol[row]-=alpha * qrtMinor[row];
          }
        }
      }
    }
    cachedQT=new RealMatrixImpl(qT,false);
  }
  return cachedQT;
}"
57496,"/** 
 * Constructs a VectorialMean.
 * @param dimension vectors dimension
 * @param isBiasCorrected if true, computed the unbiased sample covariance,otherwise computes the biased population covariance
 */
public VectorialCovariance(int dimension,boolean isBiasCorrected){
  sums=new double[dimension];
  productsSums=new double[dimension * (dimension + 1) / 2];
  n=0;
  this.isBiasCorrected=isBiasCorrected;
}","/** 
 * Constructs a VectorialCovariance.
 * @param dimension vectors dimension
 * @param isBiasCorrected if true, computed the unbiased sample covariance,otherwise computes the biased population covariance
 */
public VectorialCovariance(int dimension,boolean isBiasCorrected){
  sums=new double[dimension];
  productsSums=new double[dimension * (dimension + 1) / 2];
  n=0;
  this.isBiasCorrected=isBiasCorrected;
}"
57497,"/** 
 * <p>Evolve the given population into the next generation.</p> <p><ol> <li>Get nextGeneration polulation to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled:</li> <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each parent</li><li>Add resulting chromosomes individually to nextGeneration, space permitting</li> </ul> <li>Return nextGeneration</li> </ol> </p>
 * @param current the current population.
 * @return the population for the next generation.
 */
private Population nextGeneration(Population current){
  Population nextGeneration=current.nextGeneration();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (Math.random() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (Math.random() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}","/** 
 * <p>Evolve the given population into the next generation.</p> <p><ol> <li>Get nextGeneration polulation to fill from <code>current</code> generation, using its nextGeneration method</li> <li>Loop until new generation is filled:</li> <ul><li>Apply configured SelectionPolicy to select a pair of parents from <code>current</code></li> <li>With probability =   {@link #getCrossoverRate()}, apply configured   {@link CrossoverPolicy} to parents</li><li>With probability =  {@link #getMutationRate()}, apply configured   {@link MutationPolicy} to each of the offspring</li><li>Add offspring individually to nextGeneration, space permitting</li> </ul> <li>Return nextGeneration</li> </ol> </p>
 * @param current the current population.
 * @return the population for the next generation.
 */
private Population nextGeneration(Population current){
  Population nextGeneration=current.nextGeneration();
  while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
    ChromosomePair pair=getSelectionPolicy().select(current);
    if (Math.random() < getCrossoverRate()) {
      pair=getCrossoverPolicy().crossover(pair.getFirst(),pair.getSecond());
    }
    if (Math.random() < getMutationRate()) {
      pair=new ChromosomePair(getMutationPolicy().mutate(pair.getFirst()),getMutationPolicy().mutate(pair.getSecond()));
    }
    nextGeneration.addChromosome(pair.getFirst());
    if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {
      nextGeneration.addChromosome(pair.getSecond());
    }
  }
  return nextGeneration;
}"
57498,"/** 
 * Decompose the original square matrix. <p>The decomposition is based on a Choleski decomposition where additional transforms are performed: <ul> <li>the rows of the decomposed matrix are permuted</li> <li>columns with the too small diagonal element are discarded</li> <li>the matrix is permuted</li> </ul> This means that rather than computing M = U<sup>T</sup>.U where U is an upper triangular matrix, this method computed M=B.B<sup>T</sup> where B is a rectangular matrix.
 * @param covariance covariance matrix
 * @param small diagonal elements threshold under which  column areconsidered to be dependent on previous ones and are discarded
 * @exception NotPositiveDefiniteMatrixException if thecovariance matrix is not strictly positive definite
 */
private void decompose(RealMatrix covariance,double small) throws NotPositiveDefiniteMatrixException {
  int order=covariance.getRowDimension();
  double[][] c=covariance.getData();
  double[][] b=new double[order][order];
  int[] swap=new int[order];
  int[] index=new int[order];
  for (int i=0; i < order; ++i) {
    index[i]=i;
  }
  rank=0;
  for (boolean loop=true; loop; ) {
    swap[rank]=rank;
    for (int i=rank + 1; i < order; ++i) {
      int ii=index[i];
      int isi=index[swap[i]];
      if (c[ii][ii] > c[isi][isi]) {
        swap[rank]=i;
      }
    }
    if (swap[rank] != rank) {
      int tmp=index[rank];
      index[rank]=index[swap[rank]];
      index[swap[rank]]=tmp;
    }
    int ir=index[rank];
    if (c[ir][ir] < small) {
      if (rank == 0) {
        throw new NotPositiveDefiniteMatrixException();
      }
      for (int i=rank; i < order; ++i) {
        if (c[index[i]][index[i]] < -small) {
          throw new NotPositiveDefiniteMatrixException();
        }
      }
      ++rank;
      loop=false;
    }
 else {
      double sqrt=Math.sqrt(c[ir][ir]);
      b[rank][rank]=sqrt;
      double inverse=1 / sqrt;
      for (int i=rank + 1; i < order; ++i) {
        int ii=index[i];
        double e=inverse * c[ii][ir];
        b[i][rank]=e;
        c[ii][ii]-=e * e;
        for (int j=rank + 1; j < i; ++j) {
          int ij=index[j];
          double f=c[ii][ij] - e * b[j][rank];
          c[ii][ij]=f;
          c[ij][ii]=f;
        }
      }
      loop=++rank < order;
    }
  }
  root=new RealMatrixImpl(order,rank);
  for (int i=0; i < order; ++i) {
    System.arraycopy(b[i],0,root.getDataRef()[swap[i]],0,rank);
  }
}","/** 
 * Decompose the original square matrix. <p>The decomposition is based on a Choleski decomposition where additional transforms are performed: <ul> <li>the rows of the decomposed matrix are permuted</li> <li>columns with the too small diagonal element are discarded</li> <li>the matrix is permuted</li> </ul> This means that rather than computing M = U<sup>T</sup>.U where U is an upper triangular matrix, this method computed M=B.B<sup>T</sup> where B is a rectangular matrix.
 * @param covariance covariance matrix
 * @param small diagonal elements threshold under which  column areconsidered to be dependent on previous ones and are discarded
 * @exception NotPositiveDefiniteMatrixException if thecovariance matrix is not strictly positive definite
 */
private void decompose(RealMatrix covariance,double small) throws NotPositiveDefiniteMatrixException {
  int order=covariance.getRowDimension();
  double[][] c=covariance.getData();
  double[][] b=new double[order][order];
  int[] swap=new int[order];
  int[] index=new int[order];
  for (int i=0; i < order; ++i) {
    index[i]=i;
  }
  rank=0;
  for (boolean loop=true; loop; ) {
    swap[rank]=rank;
    for (int i=rank + 1; i < order; ++i) {
      int ii=index[i];
      int isi=index[swap[i]];
      if (c[ii][ii] > c[isi][isi]) {
        swap[rank]=i;
      }
    }
    if (swap[rank] != rank) {
      int tmp=index[rank];
      index[rank]=index[swap[rank]];
      index[swap[rank]]=tmp;
    }
    int ir=index[rank];
    if (c[ir][ir] < small) {
      if (rank == 0) {
        throw new NotPositiveDefiniteMatrixException();
      }
      for (int i=rank; i < order; ++i) {
        if (c[index[i]][index[i]] < -small) {
          throw new NotPositiveDefiniteMatrixException();
        }
      }
      ++rank;
      loop=false;
    }
 else {
      double sqrt=Math.sqrt(c[ir][ir]);
      b[rank][rank]=sqrt;
      double inverse=1 / sqrt;
      for (int i=rank + 1; i < order; ++i) {
        int ii=index[i];
        double e=inverse * c[ii][ir];
        b[i][rank]=e;
        c[ii][ii]-=e * e;
        for (int j=rank + 1; j < i; ++j) {
          int ij=index[j];
          double f=c[ii][ij] - e * b[j][rank];
          c[ii][ij]=f;
          c[ij][ii]=f;
        }
      }
      loop=++rank < order;
    }
  }
  root=new RealMatrixImpl(order,rank);
  for (int i=0; i < order; ++i) {
    System.arraycopy(b[i],0,root.getDataRef()[index[i]],0,rank);
  }
}"
57499,"/** 
 * {@inheritDoc} 
 */
public void setInterpolatedTime(final double time) throws DerivativeException {
  interpolatedTime=time;
  final double oneMinusThetaH=currentTime - interpolatedTime;
  computeInterpolatedState((h - oneMinusThetaH) / h,oneMinusThetaH);
}","/** 
 * {@inheritDoc} 
 */
public void setInterpolatedTime(final double time) throws DerivativeException {
  interpolatedTime=time;
  final double oneMinusThetaH=currentTime - interpolatedTime;
  final double theta=(h == 0) ? 0 : (h - oneMinusThetaH) / h;
  computeInterpolatedState(theta,oneMinusThetaH);
}"
57500,"/** 
 * Add an event handler for end time checking. <p>This method can be used to simplify handling of integration end time. It leverages the nominal stop condition with the exceptional stop conditions.</p>
 * @param endTime desired end time
 * @param manager manager containing the user-defined handlers
 * @return a new manager containing all the user-defined handlers plus adedicated manager triggering a stop event at entTime
 */
protected CombinedEventsManager addEndTimeChecker(final double endTime,final CombinedEventsManager manager){
  CombinedEventsManager newManager=new CombinedEventsManager();
  for (  final EventState state : manager.getEventsStates()) {
    newManager.addEventHandler(state.getEventHandler(),state.getMaxCheckInterval(),state.getConvergence(),state.getMaxIterationCount());
  }
  newManager.addEventHandler(new EndTimeChecker(endTime),Double.POSITIVE_INFINITY,Math.ulp(endTime),10);
  return newManager;
}","/** 
 * Add an event handler for end time checking. <p>This method can be used to simplify handling of integration end time. It leverages the nominal stop condition with the exceptional stop conditions.</p>
 * @param startTime integration start time
 * @param endTime desired end time
 * @param manager manager containing the user-defined handlers
 * @return a new manager containing all the user-defined handlers plus adedicated manager triggering a stop event at entTime
 */
protected CombinedEventsManager addEndTimeChecker(final double startTime,final double endTime,final CombinedEventsManager manager){
  CombinedEventsManager newManager=new CombinedEventsManager();
  for (  final EventState state : manager.getEventsStates()) {
    newManager.addEventHandler(state.getEventHandler(),state.getMaxCheckInterval(),state.getConvergence(),state.getMaxIterationCount());
  }
  newManager.addEventHandler(new EndTimeChecker(endTime),Double.POSITIVE_INFINITY,Math.ulp(Math.max(Math.abs(startTime),Math.abs(endTime))),100);
  return newManager;
}"
57501,"/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  final boolean forward=(t > t0);
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(equations,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      if (firstTime || !fsal) {
        equations.computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale;
        if (vecAbsoluteTolerance != null) {
          scale=vecAbsoluteTolerance;
        }
 else {
          scale=new double[y0.length];
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance;
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        equations.computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error <= 1.0) {
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
          hNew=manager.getEventTime() - stepStart;
        }
 else {
          loop=false;
        }
      }
 else {
        final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (fsal) {
      System.arraycopy(yDotK[stages - 1],0,yDotK[0],0,y0.length);
    }
    if (manager.reset(stepStart,y) && !lastStep) {
      equations.computeDerivatives(stepStart,y,yDotK[0]);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
    }
  }
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  final boolean forward=(t > t0);
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(equations,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  double hNew=0;
  boolean firstTime=true;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    double error=0;
    for (boolean loop=true; loop; ) {
      if (firstTime || !fsal) {
        equations.computeDerivatives(stepStart,y,yDotK[0]);
      }
      if (firstTime) {
        final double[] scale;
        if (vecAbsoluteTolerance != null) {
          scale=vecAbsoluteTolerance;
        }
 else {
          scale=new double[y0.length];
          for (int i=0; i < scale.length; ++i) {
            scale[i]=scalAbsoluteTolerance;
          }
        }
        hNew=initializeStep(equations,forward,getOrder(),scale,stepStart,y,yDotK[0],yTmp,yDotK[1]);
        firstTime=false;
      }
      stepSize=hNew;
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        equations.computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      error=estimateError(yDotK,y,yTmp,stepSize);
      if (error <= 1.0) {
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
          hNew=manager.getEventTime() - stepStart;
        }
 else {
          loop=false;
        }
      }
 else {
        final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
        hNew=filterStep(stepSize * factor,forward,false);
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (fsal) {
      System.arraycopy(yDotK[stages - 1],0,yDotK[0],0,y0.length);
    }
    if (manager.reset(stepStart,y) && !lastStep) {
      equations.computeDerivatives(stepStart,y,yDotK[0]);
    }
    if (!lastStep) {
      stepSize=filterStep(stepSize,forward,true);
      final double factor=Math.min(maxGrowth,Math.max(minReduction,safety * Math.pow(error,exp)));
      final double scaledH=stepSize * factor;
      final double nextT=stepStart + scaledH;
      final boolean nextIsLast=forward ? (nextT >= t) : (nextT <= t);
      hNew=filterStep(scaledH,forward,nextIsLast);
    }
  }
  final double stopTime=stepStart;
  resetInternalState();
  return stopTime;
}"
57502,"/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  final boolean forward=(t > t0);
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(equations,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    for (boolean loop=true; loop; ) {
      equations.computeDerivatives(stepStart,y,yDotK[0]);
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        equations.computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      interpolator.storeTime(stepStart + stepSize);
      if (manager.evaluateStep(interpolator)) {
        stepSize=manager.getEventTime() - stepStart;
      }
 else {
        loop=false;
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (manager.reset(stepStart,y) && !lastStep) {
      equations.computeDerivatives(stepStart,y,yDotK[0]);
    }
    stepSize=step;
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}","/** 
 * {@inheritDoc} 
 */
public double integrate(final FirstOrderDifferentialEquations equations,final double t0,final double[] y0,final double t,final double[] y) throws DerivativeException, IntegratorException {
  sanityChecks(equations,t0,y0,t,y);
  final boolean forward=(t > t0);
  final int stages=c.length + 1;
  if (y != y0) {
    System.arraycopy(y0,0,y,0,y0.length);
  }
  final double[][] yDotK=new double[stages][];
  for (int i=0; i < stages; ++i) {
    yDotK[i]=new double[y0.length];
  }
  final double[] yTmp=new double[y0.length];
  AbstractStepInterpolator interpolator;
  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {
    final RungeKuttaStepInterpolator rki=(RungeKuttaStepInterpolator)prototype.copy();
    rki.reinitialize(equations,yTmp,yDotK,forward);
    interpolator=rki;
  }
 else {
    interpolator=new DummyStepInterpolator(yTmp,forward);
  }
  interpolator.storeTime(t0);
  stepStart=t0;
  stepSize=step;
  for (  StepHandler handler : stepHandlers) {
    handler.reset();
  }
  CombinedEventsManager manager=addEndTimeChecker(t0,t,eventsHandlersManager);
  boolean lastStep=false;
  while (!lastStep) {
    interpolator.shift();
    for (boolean loop=true; loop; ) {
      equations.computeDerivatives(stepStart,y,yDotK[0]);
      for (int k=1; k < stages; ++k) {
        for (int j=0; j < y0.length; ++j) {
          double sum=a[k - 1][0] * yDotK[0][j];
          for (int l=1; l < k; ++l) {
            sum+=a[k - 1][l] * yDotK[l][j];
          }
          yTmp[j]=y[j] + stepSize * sum;
        }
        equations.computeDerivatives(stepStart + c[k - 1] * stepSize,yTmp,yDotK[k]);
      }
      for (int j=0; j < y0.length; ++j) {
        double sum=b[0] * yDotK[0][j];
        for (int l=1; l < stages; ++l) {
          sum+=b[l] * yDotK[l][j];
        }
        yTmp[j]=y[j] + stepSize * sum;
      }
      interpolator.storeTime(stepStart + stepSize);
      if (manager.evaluateStep(interpolator)) {
        stepSize=manager.getEventTime() - stepStart;
      }
 else {
        loop=false;
      }
    }
    final double nextStep=stepStart + stepSize;
    System.arraycopy(yTmp,0,y,0,y0.length);
    manager.stepAccepted(nextStep,y);
    lastStep=manager.stop();
    interpolator.storeTime(nextStep);
    for (    StepHandler handler : stepHandlers) {
      handler.handleStep(interpolator,lastStep);
    }
    stepStart=nextStep;
    if (manager.reset(stepStart,y) && !lastStep) {
      equations.computeDerivatives(stepStart,y,yDotK[0]);
    }
    stepSize=step;
  }
  final double stopTime=stepStart;
  stepStart=Double.NaN;
  stepSize=Double.NaN;
  return stopTime;
}"
57503,"/** 
 * Compute the backward differences coefficients array. <p>This is quite similar to the Pascal triangle, except for a (-1)<sup>i</sup> sign. We use a straightforward approach here, since we don't expect this to be run too many times with too high k. It is based on the recurrence relations:</p> <pre> &nabla;<sup>0</sup> f<sub>n</sub> = f<sub>n</sub> &nabla;<sup>i+1</sup> f<sub>n</sub> = &nabla;<sup>i</sup>f<sub>n</sub> - &nabla;<sup>i</sup>f<sub>n-1</sub> </pre>
 * @param order order of the integration method
 */
static int[][] computeBackwardDifferencesArray(final int order){
  int[][] bdArray=new int[order][];
  bdArray[0]=new int[]{1};
  for (int i=1; i < order; ++i) {
    bdArray[i]=new int[i + 1];
    bdArray[i][0]=1;
    for (int j=0; j < i - 1; ++j) {
      bdArray[i][j + 1]=bdArray[i - 1][j + 1] - bdArray[i - 1][j];
    }
    bdArray[i][i]=-bdArray[i - 1][i - 1];
  }
  return bdArray;
}","/** 
 * Compute the backward differences coefficients array. <p>This is quite similar to the Pascal triangle containing the binomial coefficiens, except for an additional (-1)<sup>i</sup> sign. We use a straightforward approach here, since we don't expect this to be run too many times with too high k. It is based on the recurrence relations:</p> <pre> &nabla;<sup>0</sup> f<sub>n</sub> = f<sub>n</sub> &nabla;<sup>i+1</sup> f<sub>n</sub> = &nabla;<sup>i</sup>f<sub>n</sub> - &nabla;<sup>i</sup>f<sub>n-1</sub> </pre>
 * @param order order of the integration method
 * @return the coefficients array for backward differences
 */
static int[][] computeBackwardDifferencesArray(final int order){
  int[][] bdArray=new int[order][];
  bdArray[0]=new int[]{1};
  for (int i=1; i < order; ++i) {
    bdArray[i]=new int[i + 1];
    bdArray[i][0]=1;
    for (int j=0; j < i - 1; ++j) {
      bdArray[i][j + 1]=bdArray[i - 1][j + 1] - bdArray[i - 1][j];
    }
    bdArray[i][i]=-bdArray[i - 1][i - 1];
  }
  return bdArray;
}"
57504,"/** 
 * Truncate a step. <p>Truncating a step is necessary when an event is triggered before the nominal end of the step.</p>
 */
void truncateStep(final double truncatedEndTime){
  currentTime=truncatedEndTime;
  h=currentTime - previousTime;
}","/** 
 * Truncate a step. <p>Truncating a step is necessary when an event is triggered before the nominal end of the step.</p>
 * @param truncatedEndTime end time of truncated step
 */
void truncateStep(final double truncatedEndTime){
  currentTime=truncatedEndTime;
  h=currentTime - previousTime;
}"
57505,"/** 
 * Truncate a step. <p>Truncating a step is necessary when an event is triggered before the nominal end of the step.</p>
 */
void truncateStep(final double truncatedEndTime){
  currentTime=truncatedEndTime;
  h=currentTime - previousTime;
}","/** 
 * Truncate a step. <p>Truncating a step is necessary when an event is triggered before the nominal end of the step.</p>
 * @param truncatedEndTime end time of truncated step
 */
void truncateStep(final double truncatedEndTime){
  currentTime=truncatedEndTime;
  h=currentTime - previousTime;
}"
57506,"/** 
 * Build a new instance.
 * @param number of steps to store
 */
public StoringStepHandler(final int n){
  this.n=n;
  restart();
}","/** 
 * Build a new instance.
 * @param n number of steps to store
 */
public StoringStepHandler(final int n){
  this.n=n;
  restart();
}"
57507,"/** 
 * @param v vector to operate on
 * @throws IllegalArgumentException if columnDimension != v.length
 * @return resulting vector
 */
public double[] operate(double[] v) throws IllegalArgumentException {
  final int nRows=this.getRowDimension();
  final int nCols=this.getColumnDimension();
  if (v.length != nCols) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final double[] out=new double[v.length];
  for (int row=0; row < nRows; row++) {
    final double[] dataRow=data[row];
    double sum=0;
    for (int i=0; i < nCols; i++) {
      sum+=dataRow[i] * v[i];
    }
    out[row]=sum;
  }
  return out;
}","/** 
 * @param v vector to operate on
 * @throws IllegalArgumentException if columnDimension != v.length
 * @return resulting vector
 */
public double[] operate(double[] v) throws IllegalArgumentException {
  final int nRows=this.getRowDimension();
  final int nCols=this.getColumnDimension();
  if (v.length != nCols) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final double[] out=new double[nRows];
  for (int row=0; row < nRows; row++) {
    final double[] dataRow=data[row];
    double sum=0;
    for (int i=0; i < nCols; i++) {
      sum+=dataRow[i] * v[i];
    }
    out[row]=sum;
  }
  return out;
}"
57508,"/** 
 * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()
 */
public abstract double getResult();","/** 
 * {@inheritDoc}
 */
public abstract double getResult();"
57509,"/** 
 * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()
 */
public abstract void clear();","/** 
 * {@inheritDoc}
 */
public abstract void clear();"
57510,"/** 
 * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)
 */
public abstract void increment(final double d);","/** 
 * {@inheritDoc}
 */
public abstract void increment(final double d);"
57511,"/** 
 * This default implementation calls   {@link #clear}, then invokes   {@link #increment} in a loop over the specified portion of the input array, and then uses  {@link #getResult} to compute the return value.  <p> Note that this implementation changes the internal state of the statistic.  Its side effects are the same as invoking  {@link #clear} andthen  {@link #incrementAll(double[],int,int)}.</p> <p> Implementations may override this method with a more efficient and possibly more accurate implementation that works directly with the input array.</p> <p> If the array is null or the index parameters are not valid, an  IllegalArgumentException is thrown.</p>
 * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[],int,int)
 */
public double evaluate(final double[] values,final int begin,final int length){
  if (test(values,begin,length)) {
    clear();
    incrementAll(values,begin,length);
  }
  return getResult();
}","/** 
 * This default implementation calls   {@link #clear}, then invokes   {@link #increment} in a loop over the specified portion of the input array, and then uses  {@link #getResult} to compute the return value.  <p> Note that this implementation changes the internal state of the statistic.  Its side effects are the same as invoking  {@link #clear} andthen  {@link #incrementAll(double[],int,int)}.</p> <p> Implementations may override this method with a more efficient and possibly more accurate implementation that works directly with the input array.</p> <p> If the array is null or the index parameters are not valid, an  IllegalArgumentException is thrown.</p>
 * @param values the input array
 * @param begin the index of the first element to include
 * @param length the number of elements to include
 * @return the value of the statistic applied to the included array entries
 * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[],int,int)
 */
public double evaluate(final double[] values,final int begin,final int length){
  if (test(values,begin,length)) {
    clear();
    incrementAll(values,begin,length);
  }
  return getResult();
}"
57512,"/** 
 * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[],int,int)
 */
public abstract double evaluate(final double[] values,final int begin,final int length);","/** 
 * {@inheritDoc}
 */
public abstract double evaluate(final double[] values,final int begin,final int length);"
57513,"/** 
 * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getValues()
 */
public synchronized double[] getValues(){
  return super.getValues();
}","/** 
 * {@inheritDoc}
 */
public synchronized double[] getValues(){
  return super.getValues();
}"
57514,"/** 
 * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getElement(int)
 */
public synchronized double getElement(int index){
  return super.getElement(index);
}","/** 
 * {@inheritDoc}
 */
public synchronized double getElement(int index){
  return super.getElement(index);
}"
57515,"/** 
 * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#clear()
 */
public synchronized void clear(){
  super.clear();
}","/** 
 * {@inheritDoc}
 */
public synchronized void clear(){
  super.clear();
}"
57516,"/** 
 * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getN()
 */
public synchronized long getN(){
  return super.getN();
}","/** 
 * {@inheritDoc}
 */
public synchronized long getN(){
  return super.getN();
}"
57517,"/** 
 * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#setWindowSize(int)
 */
public synchronized void setWindowSize(int windowSize){
  super.setWindowSize(windowSize);
}","/** 
 * {@inheritDoc}
 */
public synchronized void setWindowSize(int windowSize){
  super.setWindowSize(windowSize);
}"
57518,"/** 
 * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)
 */
public synchronized void addValue(double v){
  super.addValue(v);
}","/** 
 * {@inheritDoc}
 */
public synchronized void addValue(double v){
  super.addValue(v);
}"
57519,"/** 
 * Computes p-value for 2-sided, 2-sample t-test, under the assumption of equal subpopulation variances. <p> The sum of the sample sizes minus 2 is used as degrees of freedom.</p>
 * @param m1 first sample mean
 * @param m2 second sample mean
 * @param v1 first sample variance
 * @param v2 second sample variance
 * @param n1 first sample n
 * @param n2 second sample n
 * @return p-value
 * @throws MathException if an error occurs computing the p-value
 */
protected double homoscedasticTTest(double m1,double m2,double v1,double v2,double n1,double n2) throws MathException {
  double t=Math.abs(homoscedasticT(m1,m2,v1,v2,n1,n2));
  double degreesOfFreedom=(double)(n1 + n2 - 2);
  distribution.setDegreesOfFreedom(degreesOfFreedom);
  return 1.0 - distribution.cumulativeProbability(-t,t);
}","/** 
 * Computes p-value for 2-sided, 2-sample t-test, under the assumption of equal subpopulation variances. <p> The sum of the sample sizes minus 2 is used as degrees of freedom.</p>
 * @param m1 first sample mean
 * @param m2 second sample mean
 * @param v1 first sample variance
 * @param v2 second sample variance
 * @param n1 first sample n
 * @param n2 second sample n
 * @return p-value
 * @throws MathException if an error occurs computing the p-value
 */
protected double homoscedasticTTest(double m1,double m2,double v1,double v2,double n1,double n2) throws MathException {
  double t=Math.abs(homoscedasticT(m1,m2,v1,v2,n1,n2));
  double degreesOfFreedom=(double)(n1 + n2 - 2);
  distribution.setDegreesOfFreedom(degreesOfFreedom);
  return 2.0 * distribution.cumulativeProbability(-t);
}"
57520,"/** 
 * Computes p-value for 2-sided, 2-sample t-test. <p> Does not assume subpopulation variances are equal. Degrees of freedom are estimated from the data.</p>
 * @param m1 first sample mean
 * @param m2 second sample mean
 * @param v1 first sample variance
 * @param v2 second sample variance
 * @param n1 first sample n
 * @param n2 second sample n
 * @return p-value
 * @throws MathException if an error occurs computing the p-value
 */
protected double tTest(double m1,double m2,double v1,double v2,double n1,double n2) throws MathException {
  double t=Math.abs(t(m1,m2,v1,v2,n1,n2));
  double degreesOfFreedom=0;
  degreesOfFreedom=df(v1,v2,n1,n2);
  distribution.setDegreesOfFreedom(degreesOfFreedom);
  return 1.0 - distribution.cumulativeProbability(-t,t);
}","/** 
 * Computes p-value for 2-sided, 2-sample t-test. <p> Does not assume subpopulation variances are equal. Degrees of freedom are estimated from the data.</p>
 * @param m1 first sample mean
 * @param m2 second sample mean
 * @param v1 first sample variance
 * @param v2 second sample variance
 * @param n1 first sample n
 * @param n2 second sample n
 * @return p-value
 * @throws MathException if an error occurs computing the p-value
 */
protected double tTest(double m1,double m2,double v1,double v2,double n1,double n2) throws MathException {
  double t=Math.abs(t(m1,m2,v1,v2,n1,n2));
  double degreesOfFreedom=0;
  degreesOfFreedom=df(v1,v2,n1,n2);
  distribution.setDegreesOfFreedom(degreesOfFreedom);
  return 2.0 * distribution.cumulativeProbability(-t);
}"
57521,"public void testEqualsAndHashCode(){
  SummaryStatistics u=createSummaryStatistics();
  SummaryStatistics t=null;
  int emptyHash=u.hashCode();
  assertTrue(""String_Node_Str"",u.equals(u));
  assertFalse(""String_Node_Str"",u.equals(t));
  assertFalse(""String_Node_Str"",u.equals(new Double(0)));
  t=createSummaryStatistics();
  assertTrue(""String_Node_Str"",t.equals(u));
  assertTrue(""String_Node_Str"",u.equals(t));
  assertEquals(""String_Node_Str"",emptyHash,t.hashCode());
  u.addValue(2d);
  u.addValue(1d);
  u.addValue(3d);
  u.addValue(4d);
  assertFalse(""String_Node_Str"",t.equals(u));
  assertFalse(""String_Node_Str"",u.equals(t));
  assertTrue(""String_Node_Str"",u.hashCode() != t.hashCode());
  t.addValue(2d);
  t.addValue(3d);
  t.addValue(1d);
  t.addValue(4d);
  assertTrue(""String_Node_Str"",t.equals(u));
  assertTrue(""String_Node_Str"",u.equals(t));
  assertEquals(""String_Node_Str"",u.hashCode(),t.hashCode());
  u.clear();
  t.clear();
  assertTrue(""String_Node_Str"",t.equals(u));
  assertTrue(""String_Node_Str"",u.equals(t));
  assertEquals(""String_Node_Str"",emptyHash,t.hashCode());
  assertEquals(""String_Node_Str"",emptyHash,u.hashCode());
}","public void testEqualsAndHashCode(){
  SummaryStatistics u=createSummaryStatistics();
  SummaryStatistics t=null;
  int emptyHash=u.hashCode();
  assertTrue(""String_Node_Str"",u.equals(u));
  assertFalse(""String_Node_Str"",u.equals(t));
  assertFalse(""String_Node_Str"",u.equals(new Double(0)));
  t=createSummaryStatistics();
  assertTrue(""String_Node_Str"",t.equals(u));
  assertTrue(""String_Node_Str"",u.equals(t));
  assertEquals(""String_Node_Str"",emptyHash,t.hashCode());
  u.addValue(2d);
  u.addValue(1d);
  u.addValue(3d);
  u.addValue(4d);
  assertFalse(""String_Node_Str"",t.equals(u));
  assertFalse(""String_Node_Str"",u.equals(t));
  assertTrue(""String_Node_Str"",u.hashCode() != t.hashCode());
  t.addValue(2d);
  t.addValue(1d);
  t.addValue(3d);
  t.addValue(4d);
  assertTrue(""String_Node_Str"",t.equals(u));
  assertTrue(""String_Node_Str"",u.equals(t));
  assertEquals(""String_Node_Str"",u.hashCode(),t.hashCode());
  u.clear();
  t.clear();
  assertTrue(""String_Node_Str"",t.equals(u));
  assertTrue(""String_Node_Str"",u.equals(t));
  assertEquals(""String_Node_Str"",emptyHash,t.hashCode());
  assertEquals(""String_Node_Str"",emptyHash,u.hashCode());
}"
57522,"/** 
 * Update the residuals array and cost function value.
 * @exception EstimationException if the number of cost evaluationsexceeds the maximum allowed
 */
protected void updateResidualsAndCost() throws EstimationException {
  if (++costEvaluations > maxCostEval) {
    throw new EstimationException(""String_Node_Str"",new String[]{Integer.toString(maxCostEval)});
  }
  cost=0;
  for (int i=0, index=0; i < rows; i++, index+=cols) {
    WeightedMeasurement wm=measurements[i];
    double residual=wm.getResidual();
    residuals[i]=Math.sqrt(wm.getWeight()) * residual;
    cost+=wm.getWeight() * residual * residual;
  }
  cost=Math.sqrt(cost);
}","/** 
 * Update the residuals array and cost function value.
 * @exception EstimationException if the number of cost evaluationsexceeds the maximum allowed
 */
protected void updateResidualsAndCost() throws EstimationException {
  if (++costEvaluations > maxCostEval) {
    throw new EstimationException(""String_Node_Str"",new Object[]{new Integer(maxCostEval)});
  }
  cost=0;
  for (int i=0, index=0; i < rows; i++, index+=cols) {
    WeightedMeasurement wm=measurements[i];
    double residual=wm.getResidual();
    residuals[i]=Math.sqrt(wm.getWeight()) * residual;
    cost+=wm.getWeight() * residual * residual;
  }
  cost=Math.sqrt(cost);
}"
57523,"/** 
 * Copy constructor. <p>The copied interpolator should have been finalized before the copy, otherwise the copy will not be able to perform correctly any interpolation and will throw a   {@link NullPointerException}later. Since we don't want this constructor to throw the exceptions finalization may involve and since we don't want this method to modify the state of the copied interpolator, finalization is <strong>not</strong> done automatically, it remains under user control.</p> <p>The copy is a deep copy: its arrays are separated from the original arrays of the instance.</p>
 * @param interpolator interpolator to copy from.
 */
protected DummyStepInterpolator(DummyStepInterpolator interpolator){
  super(interpolator);
}","/** 
 * Simple constructor.
 * @param y reference to the integrator array holding the state atthe end of the step
 * @param forward integration direction indicator
 */
protected DummyStepInterpolator(double[] y,boolean forward){
  super(y,forward);
}"
57524,"/** 
 * Compute the state at the interpolated time. In this class, this method does nothing: the interpolated state is always the state at the end of the current step.
 * @param theta normalized interpolation abscissa within the step(theta is zero at the previous time step and one at the current time step)
 * @param oneMinusThetaH time gap between the interpolated time andthe current time
 * @throws DerivativeException this exception is propagated to the caller if theunderlying user function triggers one
 */
protected void computeInterpolatedState(double theta,double oneMinusThetaH) throws DerivativeException {
}","/** 
 * Compute the state at the interpolated time. In this class, this method does nothing: the interpolated state is always the state at the end of the current step.
 * @param theta normalized interpolation abscissa within the step(theta is zero at the previous time step and one at the current time step)
 * @param oneMinusThetaH time gap between the interpolated time andthe current time
 * @throws DerivativeException this exception is propagated to the caller if theunderlying user function triggers one
 */
protected void computeInterpolatedState(double theta,double oneMinusThetaH) throws DerivativeException {
  System.arraycopy(currentState,0,interpolatedState,0,currentState.length);
}"
57525,"/** 
 * Create an UnknownDistributionChiSquareTest instance.
 * @return a new UnknownDistributionChiSquareTest instance
 */
public abstract ChiSquareTest createChiSquareTest();","/** 
 * Create a ChiSquareTest instance.
 * @return a new ChiSquareTest instance
 */
public abstract ChiSquareTest createChiSquareTest();"
57526,"/** 
 * Create an UnknownDistributionChiSquareTest instance.
 * @return a new UnknownDistributionChiSquareTest instance
 */
public ChiSquareTest createChiSquareTest(){
  return new ChiSquareTestImpl();
}","/** 
 * Create a ChiSquareTest instance.
 * @return a new ChiSquareTest instance
 */
public ChiSquareTest createChiSquareTest(){
  return new ChiSquareTestImpl();
}"
57527,"public void setUp(){
  testStatistic=TestUtils.getChiSquareTest();
}","public void setUp(){
  super.setUp();
  testStatistic=TestUtils.getChiSquareTest();
}"
57528,"public void setUp(){
  testStatistic=TestUtils.getTTest();
}","public void setUp(){
  super.setUp();
  testStatistic=TestUtils.getTTest();
}"
57529,"/** 
 * Returns true if the internal storage array has too many unused  storage positions.  
 * @return true if array satisfies the contraction criteria
 */
private synchronized boolean shouldContract(){
  if (expansionMode == MULTIPLICATIVE_MODE) {
    return (internalArray.length / numElements) > contractionCriteria;
  }
 else {
    return (internalArray.length - numElements) > contractionCriteria;
  }
}","/** 
 * Returns true if the internal storage array has too many unused  storage positions.  
 * @return true if array satisfies the contraction criteria
 */
private synchronized boolean shouldContract(){
  if (expansionMode == MULTIPLICATIVE_MODE) {
    return (internalArray.length / ((float)numElements)) > contractionCriteria;
  }
 else {
    return (internalArray.length - numElements) > contractionCriteria;
  }
}"
57530,"/** 
 * Constructs an exception with specified formatted detail message. Message formatting is delegated to   {@link java.text.MessageFormat}.
 * @param argument  the failing function argument 
 * @param pattern format specifier
 * @param arguments format arguments
 */
public MaxIterationsExceededException(int maxIterations,String pattern,Object[] arguments){
  super(pattern,arguments);
  this.maxIterations=maxIterations;
}","/** 
 * Constructs an exception with specified formatted detail message. Message formatting is delegated to   {@link java.text.MessageFormat}.
 * @param maxIterations the exceeded maximal number of iterations
 * @param pattern format specifier
 * @param arguments format arguments
 */
public MaxIterationsExceededException(int maxIterations,String pattern,Object[] arguments){
  super(pattern,arguments);
  this.maxIterations=maxIterations;
}"
57531,"/** 
 * Performs a paired t-test evaluating the null hypothesis that the  mean of the paired differences between <code>sample1</code> and <code>sample2</code> is 0 in favor of the two-sided alternative that the  mean paired difference is not equal to 0, with significance level  <code>alpha</code>. <p> Returns <code>true</code> iff the null hypothesis can be rejected with  confidence <code>1 - alpha</code>.  To perform a 1-sided test, use  <code>alpha / 2</code> <p> <strong>Usage Note:</strong><br> The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  <a href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a> <p> <strong>Preconditions</strong>: <ul> <li>The input array lengths must be the same and their common length  must be at least 2. </li> <li> <code> 0 < alpha < 0.5 </code> </li></ul>
 * @param sample1 array of sample data values
 * @param sample2 array of sample data values
 * @param alpha significance level of the test
 * @return true if the null hypothesis can be rejected with confidence 1 - alpha
 * @throws IllegalArgumentException if the preconditions are not met
 * @throws MathException if an error occurs performing the test
 */
public abstract boolean pairedTTest(double[] sample1,double[] sample2,double alpha) throws IllegalArgumentException, MathException ;","/** 
 * Performs a paired t-test evaluating the null hypothesis that the  mean of the paired differences between <code>sample1</code> and <code>sample2</code> is 0 in favor of the two-sided alternative that the  mean paired difference is not equal to 0, with significance level  <code>alpha</code>. <p> Returns <code>true</code> iff the null hypothesis can be rejected with  confidence <code>1 - alpha</code>.  To perform a 1-sided test, use  <code>alpha * 2</code> <p> <strong>Usage Note:</strong><br> The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  <a href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a> <p> <strong>Preconditions</strong>: <ul> <li>The input array lengths must be the same and their common length  must be at least 2. </li> <li> <code> 0 < alpha < 0.5 </code> </li></ul>
 * @param sample1 array of sample data values
 * @param sample2 array of sample data values
 * @param alpha significance level of the test
 * @return true if the null hypothesis can be rejected with confidence 1 - alpha
 * @throws IllegalArgumentException if the preconditions are not met
 * @throws MathException if an error occurs performing the test
 */
public abstract boolean pairedTTest(double[] sample1,double[] sample2,double alpha) throws IllegalArgumentException, MathException ;"
57532,"/** 
 * Performs a  <a href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm""> two-sided t-test</a> evaluating the null hypothesis that  <code>sampleStats1</code> and <code>sampleStats2</code> describe datasets drawn from populations with the same mean, with significance level <code>alpha</code>.   This test does not assume that the subpopulation variances are equal.  To perform the test under the equal variances assumption, use  {@link #homoscedasticTTest(StatisticalSummary,StatisticalSummary)}. <p> Returns <code>true</code> iff the null hypothesis that the means are equal can be rejected with confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use <code>alpha / 2</code> <p> See   {@link #t(double[],double[])} for the formula used to compute thet-statistic.  Degrees of freedom are approximated using the <a href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm""> Welch-Satterthwaite approximation.</a> <p> <strong>Examples:</strong><br><ol> <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at the 95%, use  <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code> </li> <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code> at the 99% level,  first verify that the measured mean of   <code>sample 1</code> is less than  the mean of <code>sample 2</code> and then use  <br><code>tTest(sampleStats1, sampleStats2, 0.005) </code> </li></ol> <p> <strong>Usage Note:</strong><br> The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  <a href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a> <p> <strong>Preconditions</strong>: <ul> <li>The datasets described by the two Univariates must each contain at least 2 observations. </li> <li> <code> 0 < alpha < 0.5 </code> </li></ul>
 * @param sampleStats1 StatisticalSummary describing sample data values
 * @param sampleStats2 StatisticalSummary describing sample data values
 * @param alpha significance level of the test
 * @return true if the null hypothesis can be rejected with confidence 1 - alpha
 * @throws IllegalArgumentException if the preconditions are not met
 * @throws MathException if an error occurs performing the test
 */
public abstract boolean tTest(StatisticalSummary sampleStats1,StatisticalSummary sampleStats2,double alpha) throws IllegalArgumentException, MathException ;","/** 
 * Performs a  <a href=""http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm""> two-sided t-test</a> evaluating the null hypothesis that  <code>sampleStats1</code> and <code>sampleStats2</code> describe datasets drawn from populations with the same mean, with significance level <code>alpha</code>.   This test does not assume that the subpopulation variances are equal.  To perform the test under the equal variances assumption, use  {@link #homoscedasticTTest(StatisticalSummary,StatisticalSummary)}. <p> Returns <code>true</code> iff the null hypothesis that the means are equal can be rejected with confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use <code>alpha * 2</code> <p> See   {@link #t(double[],double[])} for the formula used to compute thet-statistic.  Degrees of freedom are approximated using the <a href=""http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm""> Welch-Satterthwaite approximation.</a> <p> <strong>Examples:</strong><br><ol> <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at the 95%, use  <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code> </li> <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code> at the 99% level,  first verify that the measured mean of   <code>sample 1</code> is less than  the mean of <code>sample 2</code> and then use  <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code> </li></ol> <p> <strong>Usage Note:</strong><br> The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  <a href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a> <p> <strong>Preconditions</strong>: <ul> <li>The datasets described by the two Univariates must each contain at least 2 observations. </li> <li> <code> 0 < alpha < 0.5 </code> </li></ul>
 * @param sampleStats1 StatisticalSummary describing sample data values
 * @param sampleStats2 StatisticalSummary describing sample data values
 * @param alpha significance level of the test
 * @return true if the null hypothesis can be rejected with confidence 1 - alpha
 * @throws IllegalArgumentException if the preconditions are not met
 * @throws MathException if an error occurs performing the test
 */
public abstract boolean tTest(StatisticalSummary sampleStats1,StatisticalSummary sampleStats2,double alpha) throws IllegalArgumentException, MathException ;"
57533,"/** 
 * Performs a paired t-test evaluating the null hypothesis that the  mean of the paired differences between <code>sample1</code> and <code>sample2</code> is 0 in favor of the two-sided alternative that the  mean paired difference is not equal to 0, with significance level  <code>alpha</code>. <p> Returns <code>true</code> iff the null hypothesis can be rejected with  confidence <code>1 - alpha</code>.  To perform a 1-sided test, use  <code>alpha / 2</code> <p> <strong>Usage Note:</strong><br> The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  <a href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a> <p> <strong>Preconditions</strong>: <ul> <li>The input array lengths must be the same and their common length  must be at least 2. </li> <li> <code> 0 < alpha < 0.5 </code> </li></ul>
 * @param sample1 array of sample data values
 * @param sample2 array of sample data values
 * @param alpha significance level of the test
 * @return true if the null hypothesis can be rejected with confidence 1 - alpha
 * @throws IllegalArgumentException if the preconditions are not met
 * @throws MathException if an error occurs performing the test
 */
public boolean pairedTTest(double[] sample1,double[] sample2,double alpha) throws IllegalArgumentException, MathException {
  if ((alpha <= 0) || (alpha > 0.5)) {
    throw new IllegalArgumentException(""String_Node_Str"" + alpha);
  }
  return (pairedTTest(sample1,sample2) < alpha);
}","/** 
 * Performs a paired t-test evaluating the null hypothesis that the  mean of the paired differences between <code>sample1</code> and <code>sample2</code> is 0 in favor of the two-sided alternative that the  mean paired difference is not equal to 0, with significance level  <code>alpha</code>. <p> Returns <code>true</code> iff the null hypothesis can be rejected with  confidence <code>1 - alpha</code>.  To perform a 1-sided test, use  <code>alpha * 2</code> <p> <strong>Usage Note:</strong><br> The validity of the test depends on the assumptions of the parametric t-test procedure, as discussed  <a href=""http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html""> here</a> <p> <strong>Preconditions</strong>: <ul> <li>The input array lengths must be the same and their common length  must be at least 2. </li> <li> <code> 0 < alpha < 0.5 </code> </li></ul>
 * @param sample1 array of sample data values
 * @param sample2 array of sample data values
 * @param alpha significance level of the test
 * @return true if the null hypothesis can be rejected with confidence 1 - alpha
 * @throws IllegalArgumentException if the preconditions are not met
 * @throws MathException if an error occurs performing the test
 */
public boolean pairedTTest(double[] sample1,double[] sample2,double alpha) throws IllegalArgumentException, MathException {
  if ((alpha <= 0) || (alpha > 0.5)) {
    throw new IllegalArgumentException(""String_Node_Str"" + alpha);
  }
  return (pairedTTest(sample1,sample2) < alpha);
}"
57534,"/** 
 * Constructor for ChiSquareDistributionTest.
 * @param name
 */
public ExponentialDistributionTest(String name){
  super(name);
}","/** 
 * Constructor for ExponentialDistributionTest.
 * @param name
 */
public ExponentialDistributionTest(String name){
  super(name);
}"
57535,"/** 
 * Returns true iff all entries of (all subarrays of) the input array are >= 0. Returns true if the array is non-null, but empty
 * @param in array to be tested
 * @return true if all entries of the array are non-negative
 * @throws NullPointerException if input array is null
 */
private boolean isNonNegative(long[][] in){
  for (int i=0; i < in.length; i++) {
    for (int j=0; j < in[i].length; j++) {
      if (in[i][j] <= 0) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * Returns true iff all entries of (all subarrays of) the input array are >= 0. Returns true if the array is non-null, but empty
 * @param in array to be tested
 * @return true if all entries of the array are non-negative
 * @throws NullPointerException if input array is null
 */
private boolean isNonNegative(long[][] in){
  for (int i=0; i < in.length; i++) {
    for (int j=0; j < in[i].length; j++) {
      if (in[i][j] < 0) {
        return false;
      }
    }
  }
  return true;
}"
57536,"/** 
 * Returns the significance level of the slope (equiv) correlation.  <p> Specifically, the returned value is the smallest <code>alpha</code> such that the slope confidence interval with significance level equal to <code>alpha</code> does not include <code>0</code>. On regression output, this is often denoted <code>Prob(|t| > 0)</code> <p> <strong>Usage Note</strong>:<br> The validity of this statistic depends on the assumption that the  observations included in the model are drawn from a <a href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a>. <p> If there are fewer that <strong>three</strong> observations in the  model, or if there is no variation in x, this returns  <code>Double.NaN</code>.
 * @return significance level for slope/correlation
 * @throws MathException if the significance level can not be computed.
 */
public double getSignificance() throws MathException {
  return (1.0 - getTDistribution().cumulativeProbability(Math.abs(getSlope()) / getSlopeStdErr()));
}","/** 
 * Returns the significance level of the slope (equiv) correlation.  <p> Specifically, the returned value is the smallest <code>alpha</code> such that the slope confidence interval with significance level equal to <code>alpha</code> does not include <code>0</code>. On regression output, this is often denoted <code>Prob(|t| > 0)</code> <p> <strong>Usage Note</strong>:<br> The validity of this statistic depends on the assumption that the  observations included in the model are drawn from a <a href=""http://mathworld.wolfram.com/BivariateNormalDistribution.html""> Bivariate Normal Distribution</a>. <p> If there are fewer that <strong>three</strong> observations in the  model, or if there is no variation in x, this returns  <code>Double.NaN</code>.
 * @return significance level for slope/correlation
 * @throws MathException if the significance level can not be computed.
 */
public double getSignificance() throws MathException {
  return 2d * (1.0 - getTDistribution().cumulativeProbability(Math.abs(getSlope()) / getSlopeStdErr()));
}"
57537,"public void testInference() throws Exception {
  SimpleRegression regression=new SimpleRegression();
  regression.addData(infData);
  assertEquals(""String_Node_Str"",0.0271,regression.getSlopeConfidenceInterval(),0.0001);
  assertEquals(""String_Node_Str"",0.01146,regression.getSlopeStdErr(),0.0001);
  regression=new SimpleRegression();
  regression.addData(infData2);
  assertEquals(""String_Node_Str"",0.023331,regression.getSignificance(),0.0001);
  assertTrue(""String_Node_Str"",regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));
  try {
    double x=regression.getSlopeConfidenceInterval(1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
    ;
  }
}","public void testInference() throws Exception {
  regression=new SimpleRegression();
  regression.addData(infData);
  assertEquals(""String_Node_Str"",0.011448491,regression.getSlopeStdErr(),1E-10);
  assertEquals(""String_Node_Str"",0.286036932,regression.getInterceptStdErr(),1E-8);
  assertEquals(""String_Node_Str"",4.596e-07,regression.getSignificance(),1E-8);
  assertEquals(""String_Node_Str"",0.0270713794287,regression.getSlopeConfidenceInterval(),1E-8);
  regression=new SimpleRegression();
  regression.addData(infData2);
  assertEquals(""String_Node_Str"",1.07260253,regression.getSlopeStdErr(),1E-8);
  assertEquals(""String_Node_Str"",4.17718672,regression.getInterceptStdErr(),1E-8);
  assertEquals(""String_Node_Str"",0.26183,regression.getSignificance(),1E-5);
  assertEquals(""String_Node_Str"",2.97802204827,regression.getSlopeConfidenceInterval(),1E-8);
  assertTrue(""String_Node_Str"",regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));
  try {
    double x=regression.getSlopeConfidenceInterval(1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
    ;
  }
}"
57538,"public void testInference() throws Exception {
  regression=new SimpleRegression();
  regression.addData(infData);
  assertEquals(""String_Node_Str"",0.011448491,regression.getSlopeStdErr(),1E-10);
  assertEquals(""String_Node_Str"",0.286036932,regression.getInterceptStdErr(),1E-8);
  assertEquals(""String_Node_Str"",4.596e-07,regression.getSignificance(),1E-8);
  assertEquals(""String_Node_Str"",0.0270713794287,regression.getSlopeConfidenceInterval(),1E-8);
  regression=new SimpleRegression();
  regression.addData(infData2);
  assertEquals(""String_Node_Str"",1.07260253,regression.getSlopeStdErr(),1E-8);
  assertEquals(""String_Node_Str"",4.17718672,regression.getInterceptStdErr(),1E-8);
  assertEquals(""String_Node_Str"",0.26183,regression.getSignificance(),1E-5);
  assertEquals(""String_Node_Str"",2.97802204827,regression.getSlopeConfidenceInterval(),1E-8);
  assertTrue(""String_Node_Str"",regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));
  try {
    double x=regression.getSlopeConfidenceInterval(1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
    ;
  }
}","public void testInference() throws Exception {
  SimpleRegression regression=new SimpleRegression();
  regression.addData(infData);
  assertEquals(""String_Node_Str"",0.011448491,regression.getSlopeStdErr(),1E-10);
  assertEquals(""String_Node_Str"",0.286036932,regression.getInterceptStdErr(),1E-8);
  assertEquals(""String_Node_Str"",4.596e-07,regression.getSignificance(),1E-8);
  assertEquals(""String_Node_Str"",0.0270713794287,regression.getSlopeConfidenceInterval(),1E-8);
  regression=new SimpleRegression();
  regression.addData(infData2);
  assertEquals(""String_Node_Str"",1.07260253,regression.getSlopeStdErr(),1E-8);
  assertEquals(""String_Node_Str"",4.17718672,regression.getInterceptStdErr(),1E-8);
  assertEquals(""String_Node_Str"",0.26183,regression.getSignificance(),1E-5);
  assertEquals(""String_Node_Str"",2.97802204827,regression.getSlopeConfidenceInterval(),1E-8);
  assertTrue(""String_Node_Str"",regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));
  try {
    double x=regression.getSlopeConfidenceInterval(1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
    ;
  }
}"
57539,"/** 
 * Returns an Iterator over the set of values that have been added.
 * @return values Iterator
 */
public Iterator valuesIterator(){
  return freqTable.keySet().iterator();
}","/** 
 * Returns an Iterator over the set of values that have been added. <p> If added values are itegral (i.e., integers, longs, Integers, or Longs),  they are converted to Longs when they are added, so the objects returned by the Iterator will in this case be Longs.
 * @return values Iterator
 */
public Iterator valuesIterator(){
  return freqTable.keySet().iterator();
}"
57540,"/** 
 * test pcts 
 */
public void testPcts(){
  f.addValue(oneL);
  f.addValue(twoL);
  f.addValue(oneI);
  f.addValue(twoI);
  f.addValue(threeL);
  f.addValue(threeL);
  f.addValue(3);
  f.addValue(threeI);
  assertEquals(""String_Node_Str"",0.25,f.getPct(1),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getPct(new Long(2)),tolerance);
  assertEquals(""String_Node_Str"",0.5,f.getPct(threeL),tolerance);
  assertEquals(""String_Node_Str"",0,f.getPct(5),tolerance);
  assertEquals(""String_Node_Str"",0,f.getPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getCumPct(1),tolerance);
  assertEquals(""String_Node_Str"",0.50,f.getCumPct(new Long(2)),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(threeL),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(5),tolerance);
  assertEquals(""String_Node_Str"",0.0,f.getCumPct(0),tolerance);
  assertEquals(""String_Node_Str"",0,f.getCumPct(""String_Node_Str""),tolerance);
}","/** 
 * test pcts 
 */
public void testPcts(){
  f.addValue(oneL);
  f.addValue(twoL);
  f.addValue(oneI);
  f.addValue(twoI);
  f.addValue(threeL);
  f.addValue(threeL);
  f.addValue(3);
  f.addValue(threeI);
  assertEquals(""String_Node_Str"",0.25,f.getPct(1),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getPct(new Long(2)),tolerance);
  assertEquals(""String_Node_Str"",0.5,f.getPct(threeL),tolerance);
  assertEquals(""String_Node_Str"",0,f.getPct(5),tolerance);
  assertEquals(""String_Node_Str"",0,f.getPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getCumPct(1),tolerance);
  assertEquals(""String_Node_Str"",0.50,f.getCumPct(new Long(2)),tolerance);
  assertEquals(""String_Node_Str"",0.50,f.getCumPct(new Integer(2)),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(threeL),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(5),tolerance);
  assertEquals(""String_Node_Str"",0.0,f.getCumPct(0),tolerance);
  assertEquals(""String_Node_Str"",0,f.getCumPct(""String_Node_Str""),tolerance);
}"
57541,"/** 
 * test freq counts 
 */
public void testCounts(){
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(oneL);
  f.addValue(twoL);
  f.addValue(1);
  f.addValue(oneI);
  assertEquals(""String_Node_Str"",3,f.getCount(1));
  assertEquals(""String_Node_Str"",1,f.getCount(2));
  assertEquals(""String_Node_Str"",0,f.getCount(3));
  assertEquals(""String_Node_Str"",4,f.getSumFreq());
  assertEquals(""String_Node_Str"",0,f.getCumFreq(0));
  assertEquals(""String_Node_Str"",3,f.getCumFreq(1));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(2));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(5));
  assertEquals(""String_Node_Str"",0,f.getCumFreq(""String_Node_Str""));
  f.clear();
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",1,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",0.5,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getCumPct(""String_Node_Str""),tolerance);
  f.clear();
  f=null;
  Frequency f=new Frequency();
  f.addValue(1);
  f.addValue(new Integer(1));
  f.addValue(new Long(1));
  f.addValue(2);
  f.addValue(new Integer(-1));
  assertEquals(""String_Node_Str"",3,f.getCount(1));
  assertEquals(""String_Node_Str"",3,f.getCount(new Integer(1)));
  assertEquals(""String_Node_Str"",0.2,f.getCumPct(0),tolerance);
  assertEquals(""String_Node_Str"",0.6,f.getPct(new Integer(1)),tolerance);
  assertEquals(""String_Node_Str"",0,f.getCumPct(-2),tolerance);
  assertEquals(""String_Node_Str"",1,f.getCumPct(10),tolerance);
  f=null;
  f=new Frequency(String.CASE_INSENSITIVE_ORDER);
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",3,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
}","/** 
 * test freq counts 
 */
public void testCounts(){
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(oneL);
  f.addValue(twoL);
  f.addValue(1);
  f.addValue(oneI);
  assertEquals(""String_Node_Str"",3,f.getCount(1));
  assertEquals(""String_Node_Str"",1,f.getCount(2));
  assertEquals(""String_Node_Str"",0,f.getCount(3));
  assertEquals(""String_Node_Str"",4,f.getSumFreq());
  assertEquals(""String_Node_Str"",0,f.getCumFreq(0));
  assertEquals(""String_Node_Str"",3,f.getCumFreq(1));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(2));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(new Integer(2)));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(5));
  assertEquals(""String_Node_Str"",0,f.getCumFreq(""String_Node_Str""));
  f.clear();
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",1,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",0.5,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getCumPct(""String_Node_Str""),tolerance);
  f.clear();
  f=null;
  Frequency f=new Frequency();
  f.addValue(1);
  f.addValue(new Integer(1));
  f.addValue(new Long(1));
  f.addValue(2);
  f.addValue(new Integer(-1));
  assertEquals(""String_Node_Str"",3,f.getCount(1));
  assertEquals(""String_Node_Str"",3,f.getCount(new Integer(1)));
  assertEquals(""String_Node_Str"",0.2,f.getCumPct(0),tolerance);
  assertEquals(""String_Node_Str"",0.6,f.getPct(new Integer(1)),tolerance);
  assertEquals(""String_Node_Str"",0,f.getCumPct(-2),tolerance);
  assertEquals(""String_Node_Str"",1,f.getCumPct(10),tolerance);
  f=null;
  f=new Frequency(String.CASE_INSENSITIVE_ORDER);
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",3,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
}"
57542,"/** 
 * test freq counts 
 */
public void testCounts(){
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(oneL);
  f.addValue(twoL);
  f.addValue(1);
  f.addValue(oneI);
  assertEquals(""String_Node_Str"",3,f.getCount(1));
  assertEquals(""String_Node_Str"",1,f.getCount(2));
  assertEquals(""String_Node_Str"",0,f.getCount(3));
  assertEquals(""String_Node_Str"",4,f.getSumFreq());
  assertEquals(""String_Node_Str"",0,f.getCumFreq(0));
  assertEquals(""String_Node_Str"",3,f.getCumFreq(1));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(2));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(5));
  assertEquals(""String_Node_Str"",0,f.getCumFreq(""String_Node_Str""));
  f.clear();
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",1,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",0.5,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getCumPct(""String_Node_Str""),tolerance);
  f.clear();
  f=null;
  f=new Frequency(String.CASE_INSENSITIVE_ORDER);
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",3,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
}","/** 
 * test freq counts 
 */
public void testCounts(){
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(oneL);
  f.addValue(twoL);
  f.addValue(1);
  f.addValue(oneI);
  assertEquals(""String_Node_Str"",3,f.getCount(1));
  assertEquals(""String_Node_Str"",1,f.getCount(2));
  assertEquals(""String_Node_Str"",0,f.getCount(3));
  assertEquals(""String_Node_Str"",4,f.getSumFreq());
  assertEquals(""String_Node_Str"",0,f.getCumFreq(0));
  assertEquals(""String_Node_Str"",3,f.getCumFreq(1));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(2));
  assertEquals(""String_Node_Str"",4,f.getCumFreq(5));
  assertEquals(""String_Node_Str"",0,f.getCumFreq(""String_Node_Str""));
  f.clear();
  assertEquals(""String_Node_Str"",0,f.getSumFreq());
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",1,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",0.5,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1.0,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",0.25,f.getCumPct(""String_Node_Str""),tolerance);
  f.clear();
  f=null;
  Frequency f=new Frequency();
  f.addValue(1);
  f.addValue(new Integer(1));
  f.addValue(new Long(1));
  f.addValue(2);
  f.addValue(new Integer(-1));
  assertEquals(""String_Node_Str"",3,f.getCount(1));
  assertEquals(""String_Node_Str"",3,f.getCount(new Integer(1)));
  assertEquals(""String_Node_Str"",0.2,f.getCumPct(0),tolerance);
  assertEquals(""String_Node_Str"",0.6,f.getPct(new Integer(1)),tolerance);
  assertEquals(""String_Node_Str"",0,f.getCumPct(-2),tolerance);
  assertEquals(""String_Node_Str"",1,f.getCumPct(10),tolerance);
  f=null;
  f=new Frequency(String.CASE_INSENSITIVE_ORDER);
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  f.addValue(""String_Node_Str"");
  assertEquals(""String_Node_Str"",3,f.getCount(""String_Node_Str""));
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
  assertEquals(""String_Node_Str"",1,f.getCumPct(""String_Node_Str""),tolerance);
}"
57543,"/** 
 * Create an AbstractDescriptiveStatistics with a specific Window
 * @param window WindowSIze for stat calculation
 */
public AbstractDescriptiveStatistics(int window){
  setWindowSize(window);
}","/** 
 * Create an AbstractDescriptiveStatistics
 */
protected AbstractDescriptiveStatistics(){
  super();
}"
57544,"/** 
 * Create an instance of a <code>DescriptiveStatistics</code>
 * @return a new factory. 
 */
public static DescriptiveStatistics newInstance(){
  DescriptiveStatistics factory=null;
  try {
    DiscoverClass dc=new DiscoverClass();
    factory=(DescriptiveStatistics)dc.newInstance(DescriptiveStatistics.class,""String_Node_Str"");
  }
 catch (  Exception ex) {
  }
  return factory;
}","/** 
 * Create an instance of a <code>DescriptiveStatistics</code>
 * @return a new factory. 
 */
public static DescriptiveStatistics newInstance(){
  DescriptiveStatistics factory=null;
  try {
    DiscoverClass dc=new DiscoverClass();
    factory=(DescriptiveStatistics)dc.newInstance(DescriptiveStatistics.class,""String_Node_Str"");
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  return factory;
}"
57545,"/** 
 * Apply the given statistic to this univariate collection.
 * @param stat the statistic to apply
 * @return the computed value of the statistic.
 */
public double apply(UnivariateStatistic stat){
  if (eDA != null) {
    return stat.evaluate(eDA.getValues(),eDA.start(),eDA.getNumElements());
  }
  return Double.NaN;
}","/** 
 * Apply the given statistic to this univariate collection.
 * @param stat the statistic to apply
 * @return the computed value of the statistic.
 */
public double apply(UnivariateStatistic stat){
  return stat.evaluate(eDA.getValues(),eDA.start(),eDA.getNumElements());
}"
57546,"/** 
 * @see org.apache.commons.math.stat.univariate.DescriptiveStatistics#clear()
 */
public synchronized void clear(){
  eDA.clear();
}","/** 
 * @see org.apache.commons.math.stat.univariate.DescriptiveStatistics#clear()
 */
public void clear(){
  eDA.clear();
}"
57547,"/** 
 * @see org.apache.commons.math.stat.univariate.DescriptiveStatistics#setWindowSize(int)
 */
public synchronized void setWindowSize(int windowSize){
  this.windowSize=windowSize;
  if (windowSize < eDA.getNumElements()) {
    eDA.discardFrontElements(eDA.getNumElements() - windowSize);
  }
}","/** 
 * @see org.apache.commons.math.stat.univariate.DescriptiveStatistics#setWindowSize(int)
 */
public void setWindowSize(int windowSize){
  if (windowSize < 1) {
    if (windowSize != INFINITE_WINDOW) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  this.windowSize=windowSize;
  if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {
    eDA.discardFrontElements(eDA.getNumElements() - windowSize);
  }
}"
57548,"/** 
 * Construct a DescriptiveStatisticsImpl with finite window
 * @param window the finite window size.
 */
public DescriptiveStatisticsImpl(int window){
  super(window);
  eDA=new ContractableDoubleArray();
}","/** 
 * Construct a DescriptiveStatisticsImpl with finite window
 * @param window the finite window size.
 */
public DescriptiveStatisticsImpl(int window){
  super();
  eDA=new ContractableDoubleArray();
  setWindowSize(window);
}"
57549,"/** 
 * @see org.apache.commons.math.stat.univariate.DescriptiveStatistics#addValue(double)
 */
public synchronized void addValue(double v){
  if (windowSize != INFINITE_WINDOW) {
    if (getN() == windowSize) {
      eDA.addElementRolling(v);
    }
 else     if (getN() < windowSize) {
      eDA.addElement(v);
    }
 else {
      String msg=""String_Node_Str"" + ""String_Node_Str"";
      throw new RuntimeException(msg);
    }
  }
 else {
    eDA.addElement(v);
  }
}","/** 
 * @see org.apache.commons.math.stat.univariate.DescriptiveStatistics#addValue(double)
 */
public void addValue(double v){
  if (windowSize != INFINITE_WINDOW) {
    if (getN() == windowSize) {
      eDA.addElementRolling(v);
    }
 else     if (getN() < windowSize) {
      eDA.addElement(v);
    }
  }
 else {
    eDA.addElement(v);
  }
}"
57550,"public void testTestPositive(){
  for (int j=0; j < 5; j++) {
    for (int i=1; i < (7 - j); i++) {
      assertTrue(testStatistic.test(testArray,0,i));
    }
  }
  assertTrue(testStatistic.test(singletonArray,0,1));
}","public void testTestPositive(){
  for (int j=0; j < 6; j++) {
    for (int i=1; i < (7 - j); i++) {
      assertTrue(testStatistic.test(testArray,0,i));
    }
  }
  assertTrue(testStatistic.test(singletonArray,0,1));
}"
57551,"public void testTestNegative(){
  assertFalse(testStatistic.test(singletonArray,0,0));
  assertFalse(testStatistic.test(testArray,0,0));
  try {
    testStatistic.test(singletonArray,2,1);
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(testArray,0,7);
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(testArray,-1,1);
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(testArray,0,-1);
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(nullArray,0,1);
  }
 catch (  IllegalArgumentException ex) {
  }
}","public void testTestNegative(){
  assertFalse(testStatistic.test(singletonArray,0,0));
  assertFalse(testStatistic.test(testArray,0,0));
  try {
    testStatistic.test(singletonArray,2,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(testArray,0,7);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(testArray,-1,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(testArray,0,-1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
  }
  try {
    testStatistic.test(nullArray,0,1);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException ex) {
  }
}"
57552,"/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected abstract double getDomainUpperBound(double p);","/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected abstract double getDomainUpperBound(double p);"
57553,"/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected abstract double getDomainLowerBound(double p);","/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected abstract double getDomainLowerBound(double p);"
57554,"/** 
 * Access the initial domain value, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return initial domain value
 */
protected abstract double getInitialDomain(double p);","/** 
 * Access the initial domain value, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return initial domain value
 */
protected abstract double getInitialDomain(double p);"
57555,"public double value(double x) throws MathException {
  return cummulativeProbability(x) - p;
}","public double value(double x) throws MathException {
  return cumulativeProbability(x) - p;
}"
57556,"/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a PDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected abstract int getDomainUpperBound(double p);","/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a PDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected abstract int getDomainUpperBound(double p);"
57557,"/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a PDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected abstract int getDomainLowerBound(double p);","/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a PDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected abstract int getDomainLowerBound(double p);"
57558,"/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected double getDomainUpperBound(double p){
  double ret;
  if (p < .5) {
    ret=getDegreesOfFreedom();
  }
 else {
    ret=Double.MAX_VALUE;
  }
  return ret;
}","/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected double getDomainUpperBound(double p){
  double ret;
  if (p < .5) {
    ret=getDegreesOfFreedom();
  }
 else {
    ret=Double.MAX_VALUE;
  }
  return ret;
}"
57559,"/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected double getDomainLowerBound(double p){
  return Double.MIN_VALUE * getGamma().getBeta();
}","/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected double getDomainLowerBound(double p){
  return Double.MIN_VALUE * getGamma().getBeta();
}"
57560,"/** 
 * Access the initial domain value, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return initial domain value
 */
protected double getInitialDomain(double p){
  double ret;
  if (p < .5) {
    ret=getDegreesOfFreedom() * .5;
  }
 else {
    ret=getDegreesOfFreedom();
  }
  return ret;
}","/** 
 * Access the initial domain value, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return initial domain value
 */
protected double getInitialDomain(double p){
  double ret;
  if (p < .5) {
    ret=getDegreesOfFreedom() * .5;
  }
 else {
    ret=getDegreesOfFreedom();
  }
  return ret;
}"
57561,"/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected double getDomainUpperBound(double p){
  return Double.MAX_VALUE;
}","/** 
 * Access the domain value upper bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value upper bound, i.e.P(X &lt; <i>upper bound</i>) &gt; <code>p</code> 
 */
protected double getDomainUpperBound(double p){
  return Double.MAX_VALUE;
}"
57562,"/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected double getDomainLowerBound(double p){
  return 0.0;
}","/** 
 * Access the domain value lower bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return domain value lower bound, i.e.P(X &lt; <i>lower bound</i>) &lt; <code>p</code> 
 */
protected double getDomainLowerBound(double p){
  return 0.0;
}"
57563,"/** 
 * Access the initial domain value, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCummulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return initial domain value
 */
protected double getInitialDomain(double p){
  return getDenominatorDegreesOfFreedom() / (getDenominatorDegreesOfFreedom() - 2.0);
}","/** 
 * Access the initial domain value, based on <code>p</code>, used to bracket a CDF root.  This method is used by  {@link #inverseCumulativeProbability(double)} to find critical values.
 * @param p the desired probability for the critical value
 * @return initial domain value
 */
protected double getInitialDomain(double p){
  return getDenominatorDegreesOfFreedom() / (getDenominatorDegreesOfFreedom() - 2.0);
}"
57564,"/** 
 */
public static Complex tan(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  double a2=2.0 * z.getReal();
  double b2=2.0 * z.getImaginary();
  double d=Math.cos(a2) + MathUtils.cosh(b2);
  return new Complex(Math.sin(a2) / d,MathUtils.sinh(b2) / 2);
}","/** 
 */
public static Complex tan(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  double a2=2.0 * z.getReal();
  double b2=2.0 * z.getImaginary();
  double d=Math.cos(a2) + MathUtils.cosh(b2);
  return new Complex(Math.sin(a2) / d,MathUtils.sinh(b2) / d);
}"
57565,"/** 
 */
public static Complex atan(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  return Complex.I.multiply(log(Complex.I.add(z).divide(Complex.I.subtract(z)))).multiply(new Complex(2.0,0.0));
}","/** 
 */
public static Complex atan(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  return Complex.I.multiply(log(Complex.I.add(z).divide(Complex.I.subtract(z)))).divide(new Complex(2.0,0.0));
}"
57566,"/** 
 */
public static Complex tanh(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  double a2=2.0 * z.getReal();
  double b2=2.0 * z.getImaginary();
  double d=MathUtils.cosh(a2) + Math.cos(b2);
  return new Complex(MathUtils.sinh(a2) / d,Math.sin(b2) / 2);
}","/** 
 */
public static Complex tanh(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  double a2=2.0 * z.getReal();
  double b2=2.0 * z.getImaginary();
  double d=MathUtils.cosh(a2) + Math.cos(b2);
  return new Complex(MathUtils.sinh(a2) / d,Math.sin(b2) / d);
}"
57567,"/** 
 */
public static Complex sqrt(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  double a=z.getReal();
  double b=z.getImaginary();
  double t=Math.sqrt((Math.abs(a) + z.abs()) / 2.0);
  if (a >= 0.0) {
    return new Complex(t,b / (2.0 * t));
  }
 else {
    double s=(b > 0.0 ? 1.0 : (b < 0.0 ? -1.0 : 0.0));
    return new Complex(Math.abs(z.getImaginary()) / (2.0 * t),s * t);
  }
}","/** 
 */
public static Complex sqrt(Complex z){
  if (z.isNaN()) {
    return Complex.NaN;
  }
  double a=z.getReal();
  double b=z.getImaginary();
  double t=Math.sqrt((Math.abs(a) + z.abs()) / 2.0);
  if (a >= 0.0) {
    return new Complex(t,b / (2.0 * t));
  }
 else {
    return new Complex(Math.abs(z.getImaginary()) / (2.0 * t),MathUtils.sign(b) * t);
  }
}"
57568,"public static void assertEquals(double expected,double actual,double delta){
  if (Double.isNaN(expected)) {
    Assert.assertTrue(Double.isNaN(actual));
  }
 else {
    Assert.assertEquals(expected,actual,delta);
  }
}","/** 
 */
public static void assertEquals(Complex expected,Complex actual,double delta){
  assertEquals(expected.getReal(),actual.getReal(),delta);
  assertEquals(expected.getImaginary(),actual.getImaginary(),delta);
}"
57569,"/** 
 * Returns the regularized beta function I(x, a, b). The implementation of this method is based on: <ul> <li> <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html""> Regularized Beta Function</a>.</li> <li> <a href=""http://functions.wolfram.com/06.21.10.0001.01""> Regularized Beta Function</a>.</li> </ul>
 * @param x ???
 * @param a ???
 * @param b ???
 * @param epsilon When the absolute value of the nth item in theseries is less than epsilon the approximation ceases to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete. 
 * @return the regularized beta function I(x, a, b)
 * @throws MathException if the algorithm fails to converge.
 */
public static double regularizedBeta(double x,final double a,final double b,double epsilon,int maxIterations) throws MathException {
  double ret;
  if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b)|| (x < 0)|| (x > 1)|| (a <= 0.0)|| (b <= 0.0)) {
    ret=Double.NaN;
  }
 else {
    ContinuedFraction fraction=new ContinuedFraction(){
      protected double getB(      int n,      double x){
        double ret;
        double m;
switch (n) {
case 1:
          ret=1.0;
        break;
default :
      if (n % 2 == 0) {
        m=(n - 2.0) / 2.0;
        ret=-((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
      }
 else {
        m=(n - 1.0) / 2.0;
        ret=(m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
      }
    break;
}
return ret;
}
protected double getA(int n,double x){
double ret;
switch (n) {
case 0:
  ret=0.0;
break;
default :
ret=1.0;
break;
}
return ret;
}
}
;
ret=Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) - Math.log(a) - logBeta(a,b,epsilon,maxIterations)) * fraction.evaluate(x,epsilon,maxIterations);
}
return ret;
}","/** 
 * Returns the regularized beta function I(x, a, b). The implementation of this method is based on: <ul> <li> <a href=""http://mathworld.wolfram.com/RegularizedBetaFunction.html""> Regularized Beta Function</a>.</li> <li> <a href=""http://functions.wolfram.com/06.21.10.0001.01""> Regularized Beta Function</a>.</li> </ul>
 * @param x ???
 * @param a ???
 * @param b ???
 * @param epsilon When the absolute value of the nth item in theseries is less than epsilon the approximation ceases to calculate further elements in the series.
 * @param maxIterations Maximum number of ""iterations"" to complete. 
 * @return the regularized beta function I(x, a, b)
 * @throws MathException if the algorithm fails to converge.
 */
public static double regularizedBeta(double x,final double a,final double b,double epsilon,int maxIterations) throws MathException {
  double ret;
  if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b)|| (x < 0)|| (x > 1)|| (a <= 0.0)|| (b <= 0.0)) {
    ret=Double.NaN;
  }
 else   if (x > (a + 1.0) / (a + b + 1.0)) {
    ret=1.0 - regularizedBeta(1.0 - x,b,a,epsilon,maxIterations);
  }
 else {
    ContinuedFraction fraction=new ContinuedFraction(){
      protected double getB(      int n,      double x){
        double ret;
        double m;
switch (n) {
case 1:
          ret=1.0;
        break;
default :
      if (n % 2 == 0) {
        m=(n - 2.0) / 2.0;
        ret=-((a + m) * (a + b + m) * x) / ((a + (2 * m)) * (a + (2 * m) + 1.0));
      }
 else {
        m=(n - 1.0) / 2.0;
        ret=(m * (b - m) * x) / ((a + (2 * m) - 1) * (a + (2 * m)));
      }
    break;
}
return ret;
}
protected double getA(int n,double x){
double ret;
switch (n) {
case 0:
  ret=0.0;
break;
default :
ret=1.0;
break;
}
return ret;
}
}
;
ret=Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) - Math.log(a) - logBeta(a,b,epsilon,maxIterations)) * fraction.evaluate(x,epsilon,maxIterations);
}
return ret;
}"
57570,"/** 
 * TEST NORMAL OPERATIONS - calling super class test and then checking internal storage 
 */
public void testAddElementRolling(){
  ra=new FixedDoubleArray(6);
  super.testAddElementRolling();
  assertEquals(""String_Node_Str"",6,((FixedDoubleArray)ra).internalArray.length);
}","/** 
 * TEST NORMAL OPERATIONS - calling super class test and then checking internal storage 
 */
public void testAddElementRolling(){
  ra=new FixedDoubleArray(6);
  super.testAddElementRolling();
  assertEquals(""String_Node_Str"",6,((FixedDoubleArray)ra).getValues().length);
}"
57571,"public void processImages() throws IOException {
  DefaultCaret caret=(DefaultCaret)OutputTxtArea.getCaret();
  caret.setUpdatePolicy(ALWAYS_UPDATE);
  if (CopyXXHDPIChk.isSelected()) {
    xxhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xxhdpiDirectory.exists()) {
      xxhdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth());
        float scaleY=(float)(img.getHeight());
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xxhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkLDPI.isSelected()) {
    GenerateProgressBar.setString(""String_Node_Str"");
    ldpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!ldpiDirectory.exists()) {
      ldpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 4);
        float scaleY=(float)(img.getHeight() / 4);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(ldpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkMDPI.isSelected()) {
    mdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!mdpiDirectory.exists()) {
      mdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 3);
        float scaleY=(float)(img.getHeight() / 3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(mdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkTVDPI.isSelected()) {
    tvdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!tvdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      tvdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2.3);
        float scaleY=(float)(img.getHeight() / 2.3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(tvdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkHDPI.isSelected()) {
    hdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!hdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      hdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2);
        float scaleY=(float)(img.getHeight() / 2);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(hdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkXHDPI.isSelected()) {
    xhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xhdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      xhdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 1.5);
        float scaleY=(float)(img.getHeight() / 1.5);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  OutputTxtArea.append(""String_Node_Str"");
  GenerateButton.setEnabled(true);
  chkHDPI.setEnabled(true);
  chkXHDPI.setEnabled(true);
  chkLDPI.setEnabled(true);
  chkMDPI.setEnabled(true);
  BrowseButton.setEnabled(true);
  PrefixCheckbox.setEnabled(true);
  FileField.setEnabled(true);
  if (PrefixCheckbox.isSelected()) {
    PrefixText.setEnabled(true);
    CopyXXHDPIChk.setEnabled(true);
  }
}","public void processImages() throws IOException {
  DefaultCaret caret=(DefaultCaret)OutputTxtArea.getCaret();
  caret.setUpdatePolicy(ALWAYS_UPDATE);
  if (CopyXXHDPIChk.isSelected()) {
    xxhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xxhdpiDirectory.exists()) {
      xxhdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth());
        float scaleY=(float)(img.getHeight());
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage;
        if (img.getColorModel().toString().contains(""String_Node_Str"")) {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_RGB);
        }
 else {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        }
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xxhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkLDPI.isSelected()) {
    GenerateProgressBar.setString(""String_Node_Str"");
    ldpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!ldpiDirectory.exists()) {
      ldpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 4);
        float scaleY=(float)(img.getHeight() / 4);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage;
        if (img.getColorModel().toString().contains(""String_Node_Str"")) {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_RGB);
        }
 else {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        }
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(ldpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkMDPI.isSelected()) {
    mdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!mdpiDirectory.exists()) {
      mdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 3);
        float scaleY=(float)(img.getHeight() / 3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage;
        if (img.getColorModel().toString().contains(""String_Node_Str"")) {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_RGB);
        }
 else {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        }
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(mdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkTVDPI.isSelected()) {
    tvdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!tvdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      tvdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2.3);
        float scaleY=(float)(img.getHeight() / 2.3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage;
        if (img.getColorModel().toString().contains(""String_Node_Str"")) {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_RGB);
        }
 else {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        }
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(tvdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkHDPI.isSelected()) {
    hdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!hdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      hdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2);
        float scaleY=(float)(img.getHeight() / 2);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage;
        if (img.getColorModel().toString().contains(""String_Node_Str"")) {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_RGB);
        }
 else {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        }
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(hdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkXHDPI.isSelected()) {
    xhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xhdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      xhdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 1.5);
        float scaleY=(float)(img.getHeight() / 1.5);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage;
        if (img.getColorModel().toString().contains(""String_Node_Str"")) {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_RGB);
        }
 else {
          bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        }
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  OutputTxtArea.append(""String_Node_Str"");
  GenerateButton.setEnabled(true);
  chkHDPI.setEnabled(true);
  chkXHDPI.setEnabled(true);
  chkLDPI.setEnabled(true);
  chkMDPI.setEnabled(true);
  BrowseButton.setEnabled(true);
  PrefixCheckbox.setEnabled(true);
  FileField.setEnabled(true);
  if (PrefixCheckbox.isSelected()) {
    PrefixText.setEnabled(true);
    CopyXXHDPIChk.setEnabled(true);
  }
}"
57572,"/** 
 * Creates new form NewJFrame
 */
public AResizerFrame(){
  initComponents();
  try {
    java.net.URL url=ClassLoader.getSystemResource(""String_Node_Str"");
    Toolkit kit=Toolkit.getDefaultToolkit();
    Image img=kit.createImage(url);
    this.setIconImage(img);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  OutputTxtArea.append(""String_Node_Str"");
  try {
    BufferedReader reader=new BufferedReader(new FileReader(""String_Node_Str""));
    FileField.setText(reader.readLine());
    reader.close();
  }
 catch (  IOException ex) {
    Logger.getLogger(AResizerFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
}","/** 
 * Creates new form NewJFrame
 */
public AResizerFrame(){
  initComponents();
  try {
    java.net.URL url=ClassLoader.getSystemResource(""String_Node_Str"");
    Toolkit kit=Toolkit.getDefaultToolkit();
    Image img=kit.createImage(url);
    this.setIconImage(img);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
  OutputTxtArea.append(""String_Node_Str"");
  try {
    BufferedReader reader=new BufferedReader(new FileReader(""String_Node_Str""));
    FileField.setText(reader.readLine());
    reader.close();
  }
 catch (  IOException ex) {
    Logger.getLogger(AResizerFrame.class.getName()).log(Level.SEVERE,null,ex);
  }
  if (FileField.getText() != null) {
    File tempDirectory=new File(FileField.getText());
    originalDirectory=tempDirectory;
  }
}"
57573,"public void processImages() throws IOException {
  DefaultCaret caret=(DefaultCaret)OutputTxtArea.getCaret();
  caret.setUpdatePolicy(ALWAYS_UPDATE);
  if (CopyXXHDPIChk.isSelected()) {
    xxhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xxhdpiDirectory.exists()) {
      xxhdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 4);
        float scaleY=(float)(img.getHeight() / 4);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xxhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkLDPI.isSelected()) {
    GenerateProgressBar.setString(""String_Node_Str"");
    ldpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!ldpiDirectory.exists()) {
      ldpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 4);
        float scaleY=(float)(img.getHeight() / 4);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(ldpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkMDPI.isSelected()) {
    mdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!mdpiDirectory.exists()) {
      mdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 3);
        float scaleY=(float)(img.getHeight() / 3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(mdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkTVDPI.isSelected()) {
    tvdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!tvdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      tvdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2.3);
        float scaleY=(float)(img.getHeight() / 2.3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(tvdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkHDPI.isSelected()) {
    hdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!hdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      hdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2);
        float scaleY=(float)(img.getHeight() / 2);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(hdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkXHDPI.isSelected()) {
    xhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xhdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      xhdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 1.5);
        float scaleY=(float)(img.getHeight() / 1.5);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  OutputTxtArea.append(""String_Node_Str"");
  GenerateButton.setEnabled(true);
  chkHDPI.setEnabled(true);
  chkXHDPI.setEnabled(true);
  chkLDPI.setEnabled(true);
  chkMDPI.setEnabled(true);
  BrowseButton.setEnabled(true);
  PrefixCheckbox.setEnabled(true);
  FileField.setEnabled(true);
  if (PrefixCheckbox.isSelected()) {
    PrefixText.setEnabled(true);
    CopyXXHDPIChk.setEnabled(true);
  }
}","public void processImages() throws IOException {
  DefaultCaret caret=(DefaultCaret)OutputTxtArea.getCaret();
  caret.setUpdatePolicy(ALWAYS_UPDATE);
  if (CopyXXHDPIChk.isSelected()) {
    xxhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xxhdpiDirectory.exists()) {
      xxhdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth());
        float scaleY=(float)(img.getHeight());
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xxhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkLDPI.isSelected()) {
    GenerateProgressBar.setString(""String_Node_Str"");
    ldpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!ldpiDirectory.exists()) {
      ldpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      System.out.println(fileList[i].getName());
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 4);
        float scaleY=(float)(img.getHeight() / 4);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        if (finalScaleX == 0) {
          finalScaleX=1;
        }
        if (finalScaleY == 0) {
          finalScaleY=1;
        }
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(ldpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkMDPI.isSelected()) {
    mdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!mdpiDirectory.exists()) {
      mdpiDirectory.mkdir();
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 3);
        float scaleY=(float)(img.getHeight() / 3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(mdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkTVDPI.isSelected()) {
    tvdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!tvdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      tvdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2.3);
        float scaleY=(float)(img.getHeight() / 2.3);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(tvdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkHDPI.isSelected()) {
    hdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!hdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      hdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 2);
        float scaleY=(float)(img.getHeight() / 2);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(hdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  if (chkXHDPI.isSelected()) {
    xhdpiDirectory=new File(originalDirectory.getParent() + ""String_Node_Str"" + PrefixText.getText()+ ""String_Node_Str"");
    if (!xhdpiDirectory.exists()) {
      OutputTxtArea.append(""String_Node_Str"" + PrefixText.getText() + ""String_Node_Str"");
      xhdpiDirectory.mkdir();
    }
 else {
      OutputTxtArea.append(PrefixText.getText() + ""String_Node_Str"");
    }
    int i;
    GenerateProgressBar.setMaximum(fileList.length);
    for (i=0; i < fileList.length; i++) {
      GenerateProgressBar.setValue(i);
      OutputTxtArea.append(""String_Node_Str"" + i + ""String_Node_Str""+ fileList.length+ ""String_Node_Str"");
      System.out.println(fileList[i].getName());
      String fileName=fileList[i].getName();
      if (fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"") || fileName.contains(""String_Node_Str"")) {
        ext=fileName.substring(fileName.length() - 3);
        System.out.println(ext);
        BufferedImage img=ImageIO.read(fileList[i]);
        float scaleX=(float)(img.getWidth() / 1.5);
        float scaleY=(float)(img.getHeight() / 1.5);
        int finalScaleX=(int)scaleX;
        int finalScaleY=(int)scaleY;
        System.out.println(""String_Node_Str"" + fileName + ""String_Node_Str""+ finalScaleY+ ""String_Node_Str""+ finalScaleX);
        Image newImg=img.getScaledInstance(finalScaleX,finalScaleY,Image.SCALE_SMOOTH);
        BufferedImage bImage=new BufferedImage(newImg.getWidth(null),newImg.getHeight(null),BufferedImage.TYPE_INT_ARGB);
        Graphics2D bImageGraphics=bImage.createGraphics();
        bImageGraphics.drawImage(newImg,null,null);
        RenderedImage rImage=(RenderedImage)bImage;
        File outputfile=new File(xhdpiDirectory + ""String_Node_Str"" + fileName);
        ImageIO.write(rImage,ext,outputfile);
      }
    }
    GenerateProgressBar.setValue(0);
    OutputTxtArea.append(""String_Node_Str"");
  }
  OutputTxtArea.append(""String_Node_Str"");
  GenerateButton.setEnabled(true);
  chkHDPI.setEnabled(true);
  chkXHDPI.setEnabled(true);
  chkLDPI.setEnabled(true);
  chkMDPI.setEnabled(true);
  BrowseButton.setEnabled(true);
  PrefixCheckbox.setEnabled(true);
  FileField.setEnabled(true);
  if (PrefixCheckbox.isSelected()) {
    PrefixText.setEnabled(true);
    CopyXXHDPIChk.setEnabled(true);
  }
}"
57574,"private boolean doRead(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  if (connector != null) {
    try {
      RpcNioBuffer connectorReadBuf=connector.getRpcNioReadBuffer();
      ByteBuffer channelReadBuf=connector.getChannelReadBuffer();
      while (!stop) {
        int read=0;
        while ((read=client.read(channelReadBuf)) > 0) {
          channelReadBuf.flip();
          byte[] readBytes=new byte[read];
          channelReadBuf.get(readBytes);
          connectorReadBuf.write(readBytes);
          channelReadBuf.clear();
          while (connectorReadBuf.hasRpcObject()) {
            RpcObject rpc=connectorReadBuf.readRpcObject();
            System.out.println(""String_Node_Str"" + rpc);
            this.fireRpc(connector,rpc);
          }
        }
        if (read < 1) {
          if (read < 0) {
            this.handSelectionKeyException(selectionKey,new RpcException());
          }
          break;
        }
      }
    }
 catch (    Exception e) {
      this.handSelectionKeyException(selectionKey,e);
    }
  }
  return result;
}","private boolean doRead(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  if (connector != null) {
    try {
      RpcNioBuffer connectorReadBuf=connector.getRpcNioReadBuffer();
      ByteBuffer channelReadBuf=connector.getChannelReadBuffer();
      while (!stop) {
        int read=0;
        while ((read=client.read(channelReadBuf)) > 0) {
          channelReadBuf.flip();
          byte[] readBytes=new byte[read];
          channelReadBuf.get(readBytes);
          connectorReadBuf.write(readBytes);
          channelReadBuf.clear();
          while (connectorReadBuf.hasRpcObject()) {
            RpcObject rpc=connectorReadBuf.readRpcObject();
            this.fireRpc(connector,rpc);
          }
        }
        if (read < 1) {
          if (read < 0) {
            this.handSelectionKeyException(selectionKey,new RpcException());
          }
          break;
        }
      }
    }
 catch (    Exception e) {
      this.handSelectionKeyException(selectionKey,e);
    }
  }
  return result;
}"
57575,"private boolean doWrite(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel channel=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(channel);
  if (connector.isNeedToSend()) {
    try {
      RpcNioBuffer connectorWriteBuf=connector.getRpcNioWriteBuffer();
      ByteBuffer channelWriteBuf=connector.getChannelWriteBuffer();
      while (connector.isNeedToSend()) {
        RpcObject rpc=connector.getToSend();
        System.out.println(""String_Node_Str"" + rpc);
        connectorWriteBuf.writeRpcObject(rpc);
        channelWriteBuf.put(connectorWriteBuf.readBytes());
        channelWriteBuf.flip();
        int wantWrite=channelWriteBuf.limit() - channelWriteBuf.position();
        int write=0;
        while (write < wantWrite) {
          write+=channel.write(channelWriteBuf);
        }
        channelWriteBuf.clear();
        result=true;
      }
      if (!connector.isNeedToSend()) {
        selectionKey.interestOps(READ_OP);
      }
    }
 catch (    Exception e) {
      this.handSelectionKeyException(selectionKey,e);
    }
  }
  return result;
}","private boolean doWrite(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel channel=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(channel);
  if (connector.isNeedToSend()) {
    try {
      RpcNioBuffer connectorWriteBuf=connector.getRpcNioWriteBuffer();
      ByteBuffer channelWriteBuf=connector.getChannelWriteBuffer();
      while (connector.isNeedToSend()) {
        RpcObject rpc=connector.getToSend();
        connectorWriteBuf.writeRpcObject(rpc);
        channelWriteBuf.put(connectorWriteBuf.readBytes());
        channelWriteBuf.flip();
        int wantWrite=channelWriteBuf.limit() - channelWriteBuf.position();
        int write=0;
        while (write < wantWrite) {
          write+=channel.write(channelWriteBuf);
        }
        channelWriteBuf.clear();
        result=true;
      }
      if (!connector.isNeedToSend()) {
        selectionKey.interestOps(READ_OP);
      }
    }
 catch (    Exception e) {
      this.handSelectionKeyException(selectionKey,e);
    }
  }
  return result;
}"
57576,"protected void fireCall(final RpcObject rpc){
  executor.execute(new Runnable(){
    @Override public void run(){
      try {
        fireCallListeners(rpc,AbstractRpcConnector.this);
      }
 catch (      Exception e) {
        e.printStackTrace();
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}","public void fireCall(final RpcObject rpc){
  executor.execute(new Runnable(){
    @Override public void run(){
      try {
        fireCallListeners(rpc,AbstractRpcConnector.this);
      }
 catch (      Exception e) {
        e.printStackTrace();
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}"
57577,"protected void startListeners(){
  for (  RpcCallListener listener : callListeners) {
    if (listener instanceof Service) {
      Service service=(Service)listener;
      service.startService();
    }
  }
}","public void startListeners(){
  for (  RpcCallListener listener : callListeners) {
    if (listener instanceof Service) {
      Service service=(Service)listener;
      service.startService();
    }
  }
}"
57578,"protected void stopListeners(){
  for (  RpcCallListener listener : callListeners) {
    if (listener instanceof Service) {
      Service service=(Service)listener;
      service.stopService();
    }
  }
}","public void stopListeners(){
  for (  RpcCallListener listener : callListeners) {
    if (listener instanceof Service) {
      Service service=(Service)listener;
      service.stopService();
    }
  }
}"
57579,"protected void addConnectorListeners(AbstractRpcConnector connector){
  for (  RpcCallListener listener : callListeners) {
    connector.addRpcCallListener(listener);
  }
}","public void addConnectorListeners(AbstractRpcConnector connector){
  for (  RpcCallListener listener : callListeners) {
    connector.addRpcCallListener(listener);
  }
}"
57580,"public RpcNioAcceptor(){
  try {
    serverSocketChannel=ServerSocketChannel.open();
    serverSocketChannel.configureBlocking(false);
    selection=new RpcNioSelection();
  }
 catch (  IOException e) {
    throw new RpcException(e);
  }
}","public RpcNioAcceptor(){
  try {
    serverSocketChannel=ServerSocketChannel.open();
    serverSocketChannel.configureBlocking(false);
    selection=new RpcNioSelection(this);
  }
 catch (  IOException e) {
    throw new RpcException(e);
  }
}"
57581,"public RpcNioConnector(){
  selection=new RpcNioSelection();
}","public RpcNioConnector(){
  selection=new RpcNioSelection(null);
}"
57582,"public RpcNioSelection(){
  try {
    selector=Selector.open();
    connectorCache=new ConcurrentHashMap<SocketChannel,RpcNioConnector>();
  }
 catch (  IOException e) {
    throw new RpcException(e);
  }
}","public RpcNioSelection(RpcNioAcceptor acceptor){
  try {
    selector=Selector.open();
    connectorCache=new ConcurrentHashMap<SocketChannel,RpcNioConnector>();
    this.acceptor=acceptor;
  }
 catch (  IOException e) {
    throw new RpcException(e);
  }
}"
57583,"private void initNewSocketChannel(SocketChannel channel,RpcNioConnector connector){
  connectorCache.put(channel,connector);
}","private void initNewSocketChannel(SocketChannel channel,RpcNioConnector connector){
  if (acceptor != null) {
    acceptor.addConnectorListeners(connector);
  }
  connectorCache.put(channel,connector);
}"
57584,"private void doDispatchSelectionKey(SelectionKey selectionKey){
  try {
    if (selectionKey.isAcceptable()) {
      doAccept(selectionKey);
    }
    if (selectionKey.isWritable()) {
      doWrite(selectionKey);
    }
    if (selectionKey.isReadable()) {
      doRead(selectionKey);
    }
  }
 catch (  IOException e) {
  }
}","private boolean doDispatchSelectionKey(SelectionKey selectionKey){
  boolean result=false;
  try {
    if (selectionKey.isAcceptable()) {
      result=doAccept(selectionKey);
    }
    if (selectionKey.isWritable()) {
      result=doWrite(selectionKey);
    }
    if (selectionKey.isReadable()) {
      result=doRead(selectionKey);
    }
  }
 catch (  IOException e) {
  }
  return result;
}"
57585,"private void doAccept(SelectionKey selectionKey) throws IOException {
  ServerSocketChannel server=(ServerSocketChannel)selectionKey.channel();
  SocketChannel client=server.accept();
  if (client != null) {
    client.configureBlocking(false);
    this.register(client,SelectionKey.OP_READ | SelectionKey.OP_WRITE,ByteBuffer.allocate(RpcUtils.MEM_2M));
  }
}","private boolean doAccept(SelectionKey selectionKey) throws IOException {
  ServerSocketChannel server=(ServerSocketChannel)selectionKey.channel();
  SocketChannel client=server.accept();
  if (client != null) {
    client.configureBlocking(false);
    this.register(client,SelectionKey.OP_READ | SelectionKey.OP_WRITE,ByteBuffer.allocate(RpcUtils.MEM_2M));
    return true;
  }
  return false;
}"
57586,"private void doRead(SelectionKey selectionKey) throws IOException {
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  if (connector != null) {
    ByteBuffer buffer=(ByteBuffer)selectionKey.attachment();
    int read=client.read(buffer);
    if (read > 0) {
      buffer.flip();
      RpcObject rpc=RpcUtils.readBuffer(buffer);
      rpc.setHost(connector.getRemoteHost());
      rpc.setPort(connector.getRemotePort());
      rpc.setRpcContext(connector.getRpcContext());
      this.fireCallListeners(rpc,connector);
    }
    buffer.clear();
  }
}","private boolean doRead(SelectionKey selectionKey) throws IOException {
  boolean result=false;
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  if (connector != null) {
    ByteBuffer buffer=(ByteBuffer)selectionKey.attachment();
    int read=client.read(buffer);
    if (read > 0) {
      buffer.flip();
      RpcObject rpc=RpcUtils.readBuffer(buffer);
      rpc.setHost(connector.getRemoteHost());
      rpc.setPort(connector.getRemotePort());
      rpc.setRpcContext(connector.getRpcContext());
      connector.fireCall(rpc);
      result=true;
    }
    buffer.clear();
  }
  return result;
}"
57587,"@Override public void run(){
  logger.info(""String_Node_Str"");
  while (!stop) {
    try {
      selector.select();
      Set<SelectionKey> selectionKeys=selector.selectedKeys();
      for (      SelectionKey selectionKey : selectionKeys) {
        doDispatchSelectionKey(selectionKey);
      }
    }
 catch (    IOException e) {
      throw new RpcException(e);
    }
  }
}","@Override public void run(){
  logger.info(""String_Node_Str"");
  boolean hasTodo=false;
  while (!stop) {
    try {
      selector.select();
      Set<SelectionKey> selectionKeys=selector.selectedKeys();
      for (      SelectionKey selectionKey : selectionKeys) {
        hasTodo|=doDispatchSelectionKey(selectionKey);
      }
      if (!hasTodo) {
        Thread.currentThread().sleep(5L);
      }
    }
 catch (    IOException e) {
      throw new RpcException(e);
    }
catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}"
57588,"private void doWrite(SelectionKey selectionKey) throws IOException {
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  while (connector.needSend()) {
    ByteBuffer buffer=(ByteBuffer)selectionKey.attachment();
    RpcUtils.writeBuffer(buffer,connector.pop());
    buffer.flip();
    client.write(buffer);
    buffer.clear();
  }
}","private boolean doWrite(SelectionKey selectionKey) throws IOException {
  boolean result=false;
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  ByteBuffer buffer=(ByteBuffer)selectionKey.attachment();
  while (connector.needSend()) {
    RpcUtils.writeBuffer(buffer,connector.pop());
    buffer.flip();
    client.write(buffer);
    result=true;
  }
  buffer.clear();
  return result;
}"
57589,"public static void main(String[] args){
  String host=""String_Node_Str"";
  int port=4332;
  AbstractRpcConnector connector=new RpcNioConnector();
  connector.setHost(host);
  connector.setPort(port);
  SimpleClientRemoteExecutor executor=new SimpleClientRemoteExecutor(connector);
  SimpleClientRemoteProxy proxy=new SimpleClientRemoteProxy();
  proxy.setRemoteExecutor(executor);
  proxy.startService();
  LoginRpcService loginService=proxy.registerRemote(LoginRpcService.class);
  HelloRpcService helloRpcService=proxy.registerRemote(HelloRpcService.class);
  HelloRpcTestService testService=proxy.registerRemote(HelloRpcTestService.class);
  logger.info(""String_Node_Str"");
  helloRpcService.sayHello(""String_Node_Str"",564);
  loginService.login(""String_Node_Str"",""String_Node_Str"");
  testService.index(43,""String_Node_Str"");
  String hello=helloRpcService.getHello();
  int ex=helloRpcService.callException(false);
  logger.info(""String_Node_Str"" + hello);
  logger.info(""String_Node_Str"" + ex);
}","public static void main(String[] args){
  String host=""String_Node_Str"";
  int port=4332;
  AbstractRpcConnector connector=new RpcNioConnector();
  connector.setHost(host);
  connector.setPort(port);
  SimpleClientRemoteExecutor executor=new SimpleClientRemoteExecutor(connector);
  SimpleClientRemoteProxy proxy=new SimpleClientRemoteProxy();
  proxy.setRemoteExecutor(executor);
  proxy.startService();
  LoginRpcService loginService=proxy.registerRemote(LoginRpcService.class);
  HelloRpcService helloRpcService=proxy.registerRemote(HelloRpcService.class);
  HelloRpcTestService testService=proxy.registerRemote(HelloRpcTestService.class);
  logger.info(""String_Node_Str"");
  loginService.login(""String_Node_Str"",""String_Node_Str"");
  testService.index(43,""String_Node_Str"");
  String hello=helloRpcService.getHello();
  int ex=helloRpcService.callException(false);
  logger.info(""String_Node_Str"" + hello);
  logger.info(""String_Node_Str"" + ex);
}"
57590,"@Override public void run(){
  String prefix=""String_Node_Str"";
  int index=1;
  while (true) {
    RpcObject rpc=createRpc(prefix + index);
    logger.info(""String_Node_Str"" + rpc);
    connector.sendRpcObject(rpc,10000);
    index++;
    try {
      Thread.currentThread().sleep(3000L);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","@Override public void run(){
  String prefix=""String_Node_Str"";
  int index=1;
  while (true) {
    RpcObject rpc=createRpc(prefix + index);
    logger.info(""String_Node_Str"" + rpc);
    connector.sendRpcObject(rpc,10000);
    index++;
    try {
      Thread.currentThread().sleep(10000L);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}"
57591,"public RpcObject getToSend(){
  return sendQueueCache.pop();
}","public RpcObject getToSend(){
  return sendQueueCache.poll();
}"
57592,"private void initBuf(){
  writeBuf=ByteBuffer.allocate(RpcUtils.MEM_2M);
  readBuf=ByteBuffer.allocate(RpcUtils.MEM_2M);
}","private void initBuf(){
  channelWriteBuffer=ByteBuffer.allocate(RpcUtils.MEM_2M);
  channelReadBuffer=ByteBuffer.allocate(RpcUtils.MEM_2M);
  rpcNioReadBuffer=new RpcNioBuffer(RpcUtils.MEM_2M);
  rpcNioWriteBuffer=new RpcNioBuffer(RpcUtils.MEM_2M);
}"
57593,"private boolean doAccept(SelectionKey selectionKey){
  ServerSocketChannel server=(ServerSocketChannel)selectionKey.channel();
  RpcNioAcceptor acceptor=acceptorCache.get(server);
  try {
    SocketChannel client=server.accept();
    if (client != null) {
      client.configureBlocking(false);
      RpcNioConnector connector=new RpcNioConnector(client,this);
      connector.setAcceptor(acceptor);
      this.register(connector);
      connector.startService();
      return true;
    }
  }
 catch (  Exception e) {
    acceptor.handleNetException(e);
  }
  return false;
}","private boolean doAccept(SelectionKey selectionKey){
  ServerSocketChannel server=(ServerSocketChannel)selectionKey.channel();
  RpcNioAcceptor acceptor=acceptorCache.get(server);
  try {
    SocketChannel client=server.accept();
    if (client != null) {
      client.configureBlocking(false);
      RpcNioConnector connector=new RpcNioConnector(client,this);
      connector.setAcceptor(acceptor);
      this.register(connector);
      connector.startService();
      return true;
    }
  }
 catch (  Exception e) {
    this.handSelectionKeyException(selectionKey,e);
  }
  return false;
}"
57594,"private boolean doRead(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  if (connector != null) {
    try {
      RpcNioBuffer connectorReadBuf=connector.getRpcNioReadBuffer();
      ByteBuffer channelReadBuf=connector.getChannelReadBuffer();
      while (!stop) {
        int read=0;
        while ((read=client.read(channelReadBuf)) > 0) {
          channelReadBuf.flip();
          byte[] readBytes=new byte[read];
          channelReadBuf.get(readBytes);
          connectorReadBuf.write(readBytes);
          channelReadBuf.clear();
          while (connectorReadBuf.hasRpcObject()) {
            RpcObject rpc=connectorReadBuf.readRpcObject();
            this.fireRpc(connector,rpc);
          }
        }
        if (read < 1) {
          break;
        }
      }
    }
 catch (    Exception e) {
      connector.handleNetException(e);
    }
  }
  return result;
}","private boolean doRead(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel client=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(client);
  if (connector != null) {
    try {
      RpcNioBuffer connectorReadBuf=connector.getRpcNioReadBuffer();
      ByteBuffer channelReadBuf=connector.getChannelReadBuffer();
      while (!stop) {
        int read=0;
        while ((read=client.read(channelReadBuf)) > 0) {
          channelReadBuf.flip();
          byte[] readBytes=new byte[read];
          channelReadBuf.get(readBytes);
          connectorReadBuf.write(readBytes);
          channelReadBuf.clear();
          while (connectorReadBuf.hasRpcObject()) {
            RpcObject rpc=connectorReadBuf.readRpcObject();
            this.fireRpc(connector,rpc);
          }
        }
        if (read < 1) {
          if (read < 0) {
            logger.info(""String_Node_Str"");
            this.handSelectionKeyException(selectionKey,new RpcException());
          }
          break;
        }
      }
    }
 catch (    Exception e) {
      this.handSelectionKeyException(selectionKey,e);
    }
  }
  return result;
}"
57595,"@Override public void run(){
  logger.info(""String_Node_Str"");
  while (!stop) {
    boolean needSend=checkSend();
    try {
      inSelect.set(true);
      if (needSend) {
        selector.selectNow();
      }
 else {
        selector.select();
      }
    }
 catch (    IOException e) {
      RpcNioSelection.this.handleNetException(e);
    }
    inSelect.set(false);
    Set<SelectionKey> selectionKeys=selector.selectedKeys();
    for (    SelectionKey selectionKey : selectionKeys) {
      doDispatchSelectionKey(selectionKey);
    }
  }
}","@Override public void run(){
  logger.info(""String_Node_Str"");
  while (!stop) {
    if (RpcNioSelection.this.hasTask()) {
      RpcNioSelection.this.runSelectTasks();
    }
    boolean needSend=checkSend();
    try {
      inSelect.set(true);
      if (needSend) {
        selector.selectNow();
      }
 else {
        selector.select();
      }
    }
 catch (    IOException e) {
      RpcNioSelection.this.handleNetException(e);
    }
    inSelect.set(false);
    Set<SelectionKey> selectionKeys=selector.selectedKeys();
    for (    SelectionKey selectionKey : selectionKeys) {
      doDispatchSelectionKey(selectionKey);
    }
  }
}"
57596,"private boolean doWrite(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel channel=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(channel);
  if (connector.isNeedToSend()) {
    try {
      RpcNioBuffer connectorWriteBuf=connector.getRpcNioWriteBuffer();
      ByteBuffer channelWriteBuf=connector.getChannelWriteBuffer();
      while (connector.isNeedToSend()) {
        RpcObject rpc=connector.getToSend();
        connectorWriteBuf.writeRpcObject(rpc);
        channelWriteBuf.put(connectorWriteBuf.readBytes());
        channelWriteBuf.flip();
        int wantWrite=channelWriteBuf.limit() - channelWriteBuf.position();
        int write=0;
        while (write < wantWrite) {
          write+=channel.write(channelWriteBuf);
        }
        channelWriteBuf.clear();
        result=true;
      }
      if (!connector.isNeedToSend()) {
        selectionKey.interestOps(READ_OP);
      }
    }
 catch (    Exception e) {
      connector.handleNetException(e);
    }
  }
  return result;
}","private boolean doWrite(SelectionKey selectionKey){
  boolean result=false;
  SocketChannel channel=(SocketChannel)selectionKey.channel();
  RpcNioConnector connector=connectorCache.get(channel);
  if (connector.isNeedToSend()) {
    try {
      RpcNioBuffer connectorWriteBuf=connector.getRpcNioWriteBuffer();
      ByteBuffer channelWriteBuf=connector.getChannelWriteBuffer();
      while (connector.isNeedToSend()) {
        RpcObject rpc=connector.getToSend();
        connectorWriteBuf.writeRpcObject(rpc);
        channelWriteBuf.put(connectorWriteBuf.readBytes());
        channelWriteBuf.flip();
        int wantWrite=channelWriteBuf.limit() - channelWriteBuf.position();
        int write=0;
        while (write < wantWrite) {
          write+=channel.write(channelWriteBuf);
        }
        channelWriteBuf.clear();
        result=true;
      }
      if (!connector.isNeedToSend()) {
        selectionKey.interestOps(READ_OP);
      }
    }
 catch (    Exception e) {
      this.handSelectionKeyException(selectionKey,e);
    }
  }
  return result;
}"
57597,"private void handSelectionKeyException(SelectionKey selectionKey,Exception e){
  selectionKey.interestOps(0);
  SelectableChannel channel=selectionKey.channel();
  if (channel instanceof ServerSocketChannel) {
    RpcNioAcceptor acceptor=acceptorCache.get(channel);
    if (acceptor != null) {
      logger.error(""String_Node_Str"" + acceptor.getHost() + ""String_Node_Str""+ acceptor.getPort()+ ""String_Node_Str""+ e.getClass()+ ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
      acceptor.stopService();
    }
  }
 else {
    RpcNioConnector connector=connectorCache.get(channel);
    if (connector != null) {
      logger.error(""String_Node_Str"" + connector.getHost() + ""String_Node_Str""+ connector.getPort()+ ""String_Node_Str""+ e.getClass()+ ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
      connector.stopService();
    }
  }
  this.logState();
}","private void handSelectionKeyException(final SelectionKey selectionKey,Exception e){
  SelectableChannel channel=selectionKey.channel();
  if (channel instanceof ServerSocketChannel) {
    RpcNioAcceptor acceptor=acceptorCache.get(channel);
    if (acceptor != null) {
      logger.error(""String_Node_Str"" + acceptor.getHost() + ""String_Node_Str""+ acceptor.getPort()+ ""String_Node_Str""+ e.getClass()+ ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
      acceptor.stopService();
    }
  }
 else {
    RpcNioConnector connector=connectorCache.get(channel);
    if (connector != null) {
      logger.error(""String_Node_Str"" + connector.getHost() + ""String_Node_Str""+ connector.getPort()+ ""String_Node_Str""+ e.getClass()+ ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
      connector.stopService();
    }
  }
  this.logState();
}"
57598,"@Override public void handleNetException(Exception e){
}","@Override public void handleNetException(Exception e){
  logger.info(""String_Node_Str"");
}"
57599,"public static void main(String[] args){
  String host=""String_Node_Str"";
  int port=4332;
  long sleep=10;
  long time=10000L;
  int threadCount=5;
  if (args != null) {
    for (    String arg : args) {
      if (arg.startsWith(""String_Node_Str"")) {
        host=arg.substring(2);
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        port=Integer.parseInt(arg.substring(2));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        sleep=Long.parseLong(arg.substring(2));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        threadCount=Integer.parseInt(arg.substring(3));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        time=Long.parseLong(arg.substring(2));
      }
    }
  }
  logger.info(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str""+ sleep+ ""String_Node_Str""+ threadCount+ ""String_Node_Str""+ time);
  RpcClientTest test=new RpcClientTest();
  test.host=host;
  test.port=port;
  test.sleep=sleep;
  test.threadCount=threadCount;
  test.time=time;
  long myTime=test.time + 10000;
  test.start();
  try {
    Thread.currentThread().sleep(myTime);
  }
 catch (  InterruptedException e) {
  }
  long call=test.callAll.get();
  long timeAll=(test.timeAll.get() / 1000);
  long exTime=timeAll / threadCount;
  double tps=call / exTime;
  double threadTps=call / timeAll;
  long myExeTime=test.time / 1000;
  logger.info(""String_Node_Str"" + call + ""String_Node_Str""+ threadCount+ ""String_Node_Str""+ timeAll+ ""String_Node_Str""+ myExeTime+ ""String_Node_Str""+ tps+ ""String_Node_Str""+ threadTps);
  test.shutdown();
  System.exit(0);
}","public static void main(String[] args){
  String host=""String_Node_Str"";
  int port=4332;
  long sleep=10;
  long time=10000L;
  int threadCount=5;
  if (args != null) {
    for (    String arg : args) {
      if (arg.startsWith(""String_Node_Str"")) {
        host=arg.substring(2);
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        port=Integer.parseInt(arg.substring(2));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        sleep=Long.parseLong(arg.substring(2));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        threadCount=Integer.parseInt(arg.substring(3));
      }
 else       if (arg.startsWith(""String_Node_Str"")) {
        time=Long.parseLong(arg.substring(2));
      }
    }
  }
  logger.info(""String_Node_Str"" + host + ""String_Node_Str""+ port+ ""String_Node_Str""+ sleep+ ""String_Node_Str""+ threadCount+ ""String_Node_Str""+ time);
  RpcClientTest test=new RpcClientTest();
  test.host=host;
  test.port=port;
  test.sleep=sleep;
  test.threadCount=threadCount;
  test.time=time;
  long myTime=test.time + 3000;
  test.start();
  try {
    Thread.currentThread().sleep(myTime);
  }
 catch (  InterruptedException e) {
  }
  long call=test.callAll.get();
  long timeAll=(test.timeAll.get() / 1000);
  long exTime=timeAll / threadCount;
  double tps=call / exTime;
  double threadTps=call / timeAll;
  long myExeTime=test.time / 1000;
  logger.info(""String_Node_Str"" + call + ""String_Node_Str""+ threadCount+ ""String_Node_Str""+ timeAll+ ""String_Node_Str""+ myExeTime+ ""String_Node_Str""+ tps+ ""String_Node_Str""+ threadTps);
  test.shutdown();
  System.exit(0);
}"
57600,"@Override public void run(){
  while (iterable.hasNext()) {
    runningTasks.incrementAndGet();
    final List<Long> addressesSublist=iterable.next();
    primerThreads.submit(new FutureTask<List<Either<Exception,P2<K,V>>>>(new RecordLookupTask(addressesSublist)){
      @Override protected void done(){
        try {
          completionQueue.put(get());
        }
 catch (        InterruptedException e) {
          log.error(""String_Node_Str"",e);
          throw new RuntimeException(e);
        }
catch (        ExecutionException e) {
          log.error(""String_Node_Str"",e);
          throw new RuntimeException(e);
        }
      }
    }
);
  }
  taskSubmitterRunning.set(false);
}","@Override public void run(){
  while (iterable.hasNext()) {
    runningTasks.incrementAndGet();
    final List<Long> addressesSublist=iterable.next();
    primerThreads.submit(new FutureTask<List<Either<Exception,P2<K,V>>>>(new RecordLookupTask(addressesSublist)){
      @Override protected void done(){
        try {
          final List<Either<Exception,P2<K,V>>> results=get();
          if (progress != null) {
            progress.addAndGet(results.size());
          }
          completionQueue.put(results);
        }
 catch (        InterruptedException e) {
          log.error(""String_Node_Str"",e);
          throw new RuntimeException(e);
        }
catch (        ExecutionException e) {
          log.error(""String_Node_Str"",e);
          throw new RuntimeException(e);
        }
      }
    }
);
  }
  taskSubmitterRunning.set(false);
}"
57601,"@Override protected void done(){
  try {
    completionQueue.put(get());
  }
 catch (  InterruptedException e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
catch (  ExecutionException e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
}","@Override protected void done(){
  try {
    final List<Either<Exception,P2<K,V>>> results=get();
    if (progress != null) {
      progress.addAndGet(results.size());
    }
    completionQueue.put(results);
  }
 catch (  InterruptedException e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
catch (  ExecutionException e) {
    log.error(""String_Node_Str"",e);
    throw new RuntimeException(e);
  }
}"
57602,"/** 
 * Performs lookup for multiple keys and returns a streaming iterator to results. Each element in the iterator is one of (1) an exception associated with a single lookup (2) a key value tuple
 * @param keys      lookup keys
 * @param progress  (optional) an AtomicInteger for tracking progress
 * @param skipped   (optional) an AtomicInteger for tracking missing keys
 * @return          iterator of lookup results
 */
public Iterator<Either<Exception,P2<K,V>>> getStreaming(final @Nonnull Iterator<K> keys,final @Nullable AtomicInteger progress,final @Nullable AtomicInteger skipped){
  log.info(""String_Node_Str"");
  LongArrayList addressList=new LongArrayList();
  int notFound=0;
  while (keys.hasNext()) {
    final K key=keys.next();
    final Long address;
    try {
      address=index.get(key);
    }
 catch (    IOException e) {
      log.error(""String_Node_Str"",e);
      return Iterators.singletonIterator(Left.<Exception,P2<K,V>>of(new IndexReadException(e)));
    }
    if (address != null) {
      addressList.add(address);
    }
 else {
      notFound++;
    }
  }
  if (progress != null)   progress.addAndGet(notFound);
  if (skipped != null)   skipped.addAndGet(notFound);
  log.info(""String_Node_Str"");
  final long[] addresses=addressList.elements();
  Arrays.sort(addresses,0,addressList.size());
  log.info(""String_Node_Str"");
  final BlockingQueue<Runnable> taskQueue=new ArrayBlockingQueue<Runnable>(100);
  final Iterator<List<Long>> iterable=Iterators.partition(addressList.iterator(),1000);
  final ExecutorService primerThreads=new ThreadPoolExecutor(10,10,0L,TimeUnit.MILLISECONDS,taskQueue,new NamedThreadFactory(""String_Node_Str"",true,log),new RejectedExecutionHandler(){
    @Override public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      try {
        taskQueue.put(r);
      }
 catch (      InterruptedException e) {
        log.error(""String_Node_Str"",e);
        throw new RuntimeException(e);
      }
    }
  }
);
  final BlockingQueue<List<Either<Exception,P2<K,V>>>> completionQueue=new ArrayBlockingQueue<List<Either<Exception,P2<K,V>>>>(10);
  final AtomicLong runningTasks=new AtomicLong(0);
  final AtomicBoolean taskSubmitterRunning=new AtomicBoolean(true);
  new Thread(new Runnable(){
    @Override public void run(){
      while (iterable.hasNext()) {
        runningTasks.incrementAndGet();
        final List<Long> addressesSublist=iterable.next();
        primerThreads.submit(new FutureTask<List<Either<Exception,P2<K,V>>>>(new RecordLookupTask(addressesSublist)){
          @Override protected void done(){
            try {
              completionQueue.put(get());
            }
 catch (            InterruptedException e) {
              log.error(""String_Node_Str"",e);
              throw new RuntimeException(e);
            }
catch (            ExecutionException e) {
              log.error(""String_Node_Str"",e);
              throw new RuntimeException(e);
            }
          }
        }
);
      }
      taskSubmitterRunning.set(false);
    }
  }
,""String_Node_Str"").start();
  return new Iterator<Either<Exception,P2<K,V>>>(){
    Iterator<Either<Exception,P2<K,V>>> currentIterator;
    @Override public boolean hasNext(){
      if (currentIterator != null && currentIterator.hasNext())       return true;
      while (taskSubmitterRunning.get() || runningTasks.get() > 0) {
        try {
          final List<Either<Exception,P2<K,V>>> list=completionQueue.poll(1,TimeUnit.SECONDS);
          if (list != null) {
            log.debug(""String_Node_Str"" + runningTasks.decrementAndGet());
            currentIterator=list.iterator();
            if (currentIterator.hasNext())             return true;
          }
        }
 catch (        InterruptedException e) {
          log.error(""String_Node_Str"",e);
          throw new RuntimeException(e);
        }
      }
      primerThreads.shutdown();
      return false;
    }
    @Override public Either<Exception,P2<K,V>> next(){
      return currentIterator.next();
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","/** 
 * Performs lookup for multiple keys and returns a streaming iterator to results. Each element in the iterator is one of (1) an exception associated with a single lookup (2) a key value tuple
 * @param keys      lookup keys
 * @param progress  (optional) an AtomicInteger for tracking progress
 * @param skipped   (optional) an AtomicInteger for tracking missing keys
 * @return          iterator of lookup results
 */
public Iterator<Either<Exception,P2<K,V>>> getStreaming(final @Nonnull Iterator<K> keys,final @Nullable AtomicInteger progress,final @Nullable AtomicInteger skipped){
  log.info(""String_Node_Str"");
  LongArrayList addressList=new LongArrayList();
  int notFound=0;
  while (keys.hasNext()) {
    final K key=keys.next();
    final Long address;
    try {
      address=index.get(key);
    }
 catch (    IOException e) {
      log.error(""String_Node_Str"",e);
      return Iterators.singletonIterator(Left.<Exception,P2<K,V>>of(new IndexReadException(e)));
    }
    if (address != null) {
      addressList.add(address);
    }
 else {
      notFound++;
    }
  }
  if (progress != null)   progress.addAndGet(notFound);
  if (skipped != null)   skipped.addAndGet(notFound);
  log.info(""String_Node_Str"");
  final long[] addresses=addressList.elements();
  Arrays.sort(addresses,0,addressList.size());
  log.info(""String_Node_Str"");
  final BlockingQueue<Runnable> taskQueue=new ArrayBlockingQueue<Runnable>(100);
  final Iterator<List<Long>> iterable=Iterators.partition(addressList.iterator(),1000);
  final ExecutorService primerThreads=new ThreadPoolExecutor(10,10,0L,TimeUnit.MILLISECONDS,taskQueue,new NamedThreadFactory(""String_Node_Str"",true,log),new RejectedExecutionHandler(){
    @Override public void rejectedExecution(    Runnable r,    ThreadPoolExecutor executor){
      try {
        taskQueue.put(r);
      }
 catch (      InterruptedException e) {
        log.error(""String_Node_Str"",e);
        throw new RuntimeException(e);
      }
    }
  }
);
  final BlockingQueue<List<Either<Exception,P2<K,V>>>> completionQueue=new ArrayBlockingQueue<List<Either<Exception,P2<K,V>>>>(10);
  final AtomicLong runningTasks=new AtomicLong(0);
  final AtomicBoolean taskSubmitterRunning=new AtomicBoolean(true);
  new Thread(new Runnable(){
    @Override public void run(){
      while (iterable.hasNext()) {
        runningTasks.incrementAndGet();
        final List<Long> addressesSublist=iterable.next();
        primerThreads.submit(new FutureTask<List<Either<Exception,P2<K,V>>>>(new RecordLookupTask(addressesSublist)){
          @Override protected void done(){
            try {
              final List<Either<Exception,P2<K,V>>> results=get();
              if (progress != null) {
                progress.addAndGet(results.size());
              }
              completionQueue.put(results);
            }
 catch (            InterruptedException e) {
              log.error(""String_Node_Str"",e);
              throw new RuntimeException(e);
            }
catch (            ExecutionException e) {
              log.error(""String_Node_Str"",e);
              throw new RuntimeException(e);
            }
          }
        }
);
      }
      taskSubmitterRunning.set(false);
    }
  }
,""String_Node_Str"").start();
  return new Iterator<Either<Exception,P2<K,V>>>(){
    Iterator<Either<Exception,P2<K,V>>> currentIterator;
    @Override public boolean hasNext(){
      if (currentIterator != null && currentIterator.hasNext())       return true;
      while (taskSubmitterRunning.get() || runningTasks.get() > 0) {
        try {
          final List<Either<Exception,P2<K,V>>> list=completionQueue.poll(1,TimeUnit.SECONDS);
          if (list != null) {
            log.debug(""String_Node_Str"" + runningTasks.decrementAndGet());
            currentIterator=list.iterator();
            if (currentIterator.hasNext())             return true;
          }
        }
 catch (        InterruptedException e) {
          log.error(""String_Node_Str"",e);
          throw new RuntimeException(e);
        }
      }
      primerThreads.shutdown();
      return false;
    }
    @Override public Either<Exception,P2<K,V>> next(){
      return currentIterator.next();
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}"
57603,"public float getRowHeight(){
  return rowHeight;
}","public Float getRowHeight(){
  return rowHeight;
}"
57604,"public void setRowHeight(float rowHeight){
  this.rowHeight=rowHeight;
}","public void setRowHeight(Float rowHeight){
  this.rowHeight=rowHeight;
}"
57605,"/** 
 * 初始化单元格
 */
private void ini(){
  log.debug(""String_Node_Str"",tableBean.getRowCount(),tableBean.getColumnCount());
  for (int r=0; r < tableBean.getRowCount(); r++) {
    Row row=sheet.createRow(r);
    if (tableBean.getRowHeight() > 0) {
      row.setHeight((short)tableBean.getRowHeight());
    }
    for (int c=0; c < tableBean.getColumnCount(); c++) {
      row.createCell(c);
    }
  }
}","/** 
 * 初始化单元格
 */
private void ini(){
  log.debug(""String_Node_Str"",tableBean.getRowCount(),tableBean.getColumnCount());
  for (int r=0; r < tableBean.getRowCount(); r++) {
    Row row=sheet.createRow(r);
    if (tableBean.getRowHeight() != null) {
      row.setHeight(tableBean.getRowHeight().shortValue());
    }
    for (int c=0; c < tableBean.getColumnCount(); c++) {
      row.createCell(c);
    }
  }
}"
57606,Object read(CellBean cellBean);,"/** 
 * 整个读取
 * @param tableBean
 * @return
 */
Object read(TableBean tableBean);"
57607,"public CellBean getCellBean(int row,int column){
  return cellBeanArea[row][column];
}","public CellBean getCellBean(int row,int column){
  if (cellBeanArea.length <= row || cellBeanArea[0].length <= column) {
    return null;
  }
 else {
    return cellBeanArea[row][column];
  }
}"
57608,"/** 
 * 初始化单元格
 */
private void ini(){
  log.debug(""String_Node_Str"",tableBean.getRowCount(),tableBean.getColumnCount());
  for (int r=0; r < tableBean.getRowCount(); r++) {
    Row row=sheet.createRow(r);
    if (tableBean.getRowHeight() != null) {
      row.setHeight(tableBean.getRowHeight().shortValue());
    }
    for (int c=0; c < tableBean.getColumnCount(); c++) {
      row.createCell(c);
    }
  }
}","/** 
 * 初始化单元格
 */
private void ini(){
  log.debug(""String_Node_Str"",tableBean.getRowCount(),tableBean.getColumnCount());
  for (int r=0; r < tableBean.getRowCount(); r++) {
    Row row=sheet.createRow(r);
    if (tableBean.getRowHeight() != null) {
      row.setHeightInPoints(tableBean.getRowHeight());
    }
    for (int c=0; c < tableBean.getColumnCount(); c++) {
      row.createCell(c);
    }
  }
}"
57609,"public void doExport(){
  Collection<CellBean> cellBeans=tableBean.getCellBeans();
  if (ObjectHelper.isNotEmpty(cellBeans)) {
    for (    CellBean cellBean : cellBeans) {
      if (cellBean.getXSize() > 1 || cellBean.getYSize() > 1) {
        log.debug(""String_Node_Str"",JsonUtil.toJSON(cellBean));
        CellRangeAddress range=new CellRangeAddress(cellBean.getRowIndex(),cellBean.getRowIndex() + cellBean.getYSize() - 1,cellBean.getColumnIndex(),cellBean.getColumnIndex() + cellBean.getXSize() - 1);
        sheet.addMergedRegion(range);
      }
      log.debug(""String_Node_Str"",cellBean.getRowIndex(),cellBean.getColumnIndex(),cellBean.getContent());
      Row row=sheet.getRow(cellBean.getRowIndex());
      if (row == null) {
        row=sheet.createRow(cellBean.getRowIndex());
      }
      Cell cell=row.getCell(cellBean.getColumnIndex());
      if (cell == null) {
        cell=row.createCell(cellBean.getColumnIndex());
      }
      cell.setCellValue(cellBean.getContent());
      CellStyle cellStyle=cell.getCellStyle();
      if (cellStyle == null) {
        cellStyle=sheet.getWorkbook().createCellStyle();
      }
      if (cellBean.isAlignCenter()) {
        cellStyle.setAlignment(CellStyle.ALIGN_CENTER);
      }
      if (cellBean.isVerticalCenter()) {
        cellStyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
      }
      cellStyle.setWrapText(cellBean.isWrapText());
      cell.setCellStyle(cellStyle);
    }
  }
}","public void doExport(){
  Collection<CellBean> cellBeans=tableBean.getCellBeans();
  if (ObjectHelper.isNotEmpty(cellBeans)) {
    for (    CellBean cellBean : cellBeans) {
      if (cellBean.getXSize() > 1 || cellBean.getYSize() > 1) {
        log.debug(""String_Node_Str"",JsonUtil.toJSON(cellBean));
        CellRangeAddress range=new CellRangeAddress(cellBean.getRowIndex(),cellBean.getRowIndex() + cellBean.getYSize() - 1,cellBean.getColumnIndex(),cellBean.getColumnIndex() + cellBean.getXSize() - 1);
        sheet.addMergedRegion(range);
      }
      log.debug(""String_Node_Str"",cellBean.getRowIndex(),cellBean.getColumnIndex(),cellBean.getContent());
      Cell cell=sheet.getRow(cellBean.getRowIndex()).getCell(cellBean.getColumnIndex());
      cell.setCellValue(cellBean.getContent());
      CellStyle cellStyle=cell.getCellStyle();
      if (cellStyle == null) {
        cellStyle=sheet.getWorkbook().createCellStyle();
      }
      if (cellBean.isAlignCenter()) {
        cellStyle.setAlignment(CellStyle.ALIGN_CENTER);
      }
      if (cellBean.isVerticalCenter()) {
        cellStyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
      }
      cellStyle.setWrapText(cellBean.isWrapText());
      cell.setCellStyle(cellStyle);
    }
  }
}"
57610,"/** 
 * 批量设置读取器,该读取器将应用到所有单元格.
 * @param cellReaderAdapter
 */
public void setDefaultReader(ICellReaderAdapter cellReaderAdapter){
  Arrays.fill(iCellReaderAdapters,cellReaderAdapter);
}","/** 
 * 批量设置读取器,该读取器将应用到所有单元格.
 * @param cellReaderAdapter
 */
public void setDefaultReader(ICellReaderAdapter cellReaderAdapter){
  this.defaultCellReaderAdapter=defaultCellReaderAdapter;
}"
57611,"public TableBean getTableBean(){
  return tableBean;
}","public TableBean getTableBean(){
  if (tableBean == null) {
    doImport();
  }
  return tableBean;
}"
57612,"public ImportTableService(Sheet sheet){
  this.sheet=sheet;
}","public ImportTableService(Sheet sheet,ICellReaderAdapter defaultCellReaderAdapter){
  this.sheet=sheet;
  this.defaultCellReaderAdapter=defaultCellReaderAdapter;
}"
57613,"/** 
 * 读取复杂对象的值
 * @param fieldBean
 * @param excelVo
 * @param rowData
 * @param row
 * @param index
 * @param dataBean
 * @param group
 * @throws AdapterException
 * @throws ColumnErrorException
 */
protected void getColumnGroupField(FieldBean fieldBean,BaseExcelVo excelVo,Row rowData,int row,int index,DataBean dataBean,GroupConfig group) throws AdapterException, ColumnErrorException {
  DataBean childDataBean=dataBean.getChildDataBean(fieldBean.getField().getName());
  List<BaseExcelVo> childVo=(List<BaseExcelVo>)dataBean.getFieldValue(fieldBean.getField().getName(),excelVo);
  if (childVo == null) {
    return;
  }
  int size=group.getFieldNames().size();
  if (ObjectHelper.isNotEmpty(childVo)) {
    for (int r=0; r < childVo.size(); r++) {
      BaseExcelVo baseExcelVo=childVo.get(r);
      if (baseExcelVo != null) {
        for (int i=0; i < size; i++) {
          FieldBean childFieldBean=childDataBean.getFiledBeanList().get(i);
          if (childFieldBean.getFieldType() == FieldType.BASIC) {
            getSimpleField(childFieldBean,baseExcelVo,rowData,row,index + r * size,childDataBean);
          }
 else           if (childFieldBean.getFieldType() == FieldType.BAS_ARRAY) {
            GroupConfig childGroup=groupConfig.get(childFieldBean.getField().getName());
            getBasArrayField(childFieldBean,baseExcelVo,rowData,row,index + r * size,childDataBean,childGroup);
          }
 else           if (childFieldBean.getFieldType() == FieldType.ColumnGroup_ARRAY) {
            GroupConfig childGroup=groupConfig.get(childFieldBean.getField().getName());
            getColumnGroupField(childFieldBean,baseExcelVo,rowData,row,index + r * size,childDataBean,childGroup);
          }
        }
      }
    }
  }
}","/** 
 * 读取复杂对象的值
 * @param fieldBean
 * @param excelVo
 * @param rowData
 * @param row
 * @param index
 * @param dataBean
 * @param group
 * @throws AdapterException
 * @throws ColumnErrorException
 */
protected void getColumnGroupField(FieldBean fieldBean,BaseExcelVo excelVo,Row rowData,int row,int index,DataBean dataBean,GroupConfig group) throws AdapterException, ColumnErrorException {
  DataBean childDataBean=dataBean.getChildDataBean(fieldBean.getField().getName());
  List<BaseExcelVo> childVo=(List<BaseExcelVo>)dataBean.getFieldValue(fieldBean.getField().getName(),excelVo);
  if (childVo == null) {
    return;
  }
  int size=group.getFieldNames().size();
  if (ObjectHelper.isNotEmpty(childVo)) {
    for (int r=0; r < childVo.size(); r++) {
      BaseExcelVo baseExcelVo=childVo.get(r);
      if (baseExcelVo != null) {
        for (int i=0; i < size; i++) {
          FieldBean childFieldBean=childDataBean.getFiledBeanList().get(i);
          if (childFieldBean.getFieldType() == FieldType.BASIC) {
            getSimpleField(childFieldBean,baseExcelVo,rowData,row,index + r * size + i,childDataBean);
          }
 else           if (childFieldBean.getFieldType() == FieldType.BAS_ARRAY) {
            GroupConfig childGroup=groupConfig.get(childFieldBean.getField().getName());
            getBasArrayField(childFieldBean,baseExcelVo,rowData,row,index + r * size + i,childDataBean,childGroup);
          }
 else           if (childFieldBean.getFieldType() == FieldType.ColumnGroup_ARRAY) {
            GroupConfig childGroup=groupConfig.get(childFieldBean.getField().getName());
            getColumnGroupField(childFieldBean,baseExcelVo,rowData,row,index + r * size + i,childDataBean,childGroup);
          }
        }
      }
    }
  }
}"
57614,"/** 
 * 从List中导出
 * @throws Exception
 */
@Test public void testSimpleMapExport() throws Exception {
  Sheet sheet=workbook.createSheet(""String_Node_Str"");
  SimpleExportService service=new SimpleExportService(sheet,getMapList(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
  service.setDic(""String_Node_Str"",""String_Node_Str"").addDic(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addDic(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  service.doExport();
}","/** 
 * 从List中导出
 * @throws Exception
 */
@Test public void testSimpleMapExport() throws Exception {
  Sheet sheet=workbook.createSheet(""String_Node_Str"");
  SimpleExportService service=new SimpleExportService(sheet,getMapList(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"");
  service.setLanguage(new ILanguage(){
    @Override public String translate(    Object key,    Object... args){
      if (""String_Node_Str"".equals(key)) {
        return ""String_Node_Str"";
      }
 else       if (""String_Node_Str"".equals(key)) {
        return ""String_Node_Str"";
      }
 else       if (""String_Node_Str"".equals(key)) {
        return ""String_Node_Str"";
      }
      return key + ""String_Node_Str"";
    }
  }
);
  service.setDic(""String_Node_Str"",""String_Node_Str"").addDic(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").addDic(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  service.doExport();
}"
57615,"@Override public Feed getItem(int position){
  mCursor.moveToPosition(position);
  return Feed.fromCursor(mCursor);
}","@Override public Feed getItem(int position){
  if (mCursor == null || mCursor.getCount() <= position) {
    return null;
  }
  mCursor.moveToPosition(position);
  return Feed.fromCursor(mCursor);
}"
57616,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  int actualPosition=position - mListView.getHeaderViewsCount();
  if (actualPosition < 0) {
    return;
  }
  ActivityOptionsCompat options=ActivityOptionsCompat.makeSceneTransitionAnimation(getActivity());
  Intent intent=new Intent(getActivity(),ImageViewActivity.class);
  Feed feed=mAdapter.getItem(position - mListView.getHeaderViewsCount());
  intent.putExtra(ImageViewActivity.IMAGE_NAME,feed.getName());
  intent.putStringArrayListExtra(ImageViewActivity.IMAGE_URL,feed.getImgs());
  intent.putExtra(ImageViewActivity.IMAGE_ID,feed.getId());
  ActivityCompat.startActivity(getActivity(),intent,options.toBundle());
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  int actualPosition=position - mListView.getHeaderViewsCount();
  if (actualPosition < 0) {
    return;
  }
  ActivityOptionsCompat options=ActivityOptionsCompat.makeSceneTransitionAnimation(getActivity());
  Intent intent=new Intent(getActivity(),ImageViewActivity.class);
  Feed feed=mAdapter.getItem(position - mListView.getHeaderViewsCount());
  if (feed == null) {
    return;
  }
  intent.putExtra(ImageViewActivity.IMAGE_NAME,feed.getName());
  intent.putStringArrayListExtra(ImageViewActivity.IMAGE_URL,feed.getImgs());
  intent.putExtra(ImageViewActivity.IMAGE_ID,feed.getId());
  ActivityCompat.startActivity(getActivity(),intent,options.toBundle());
}"
57617,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View contentView=inflater.inflate(R.layout.fragment_feed,container,false);
  mListView=(PageListView)contentView.findViewById(R.id.listView);
  mSwipeLayout=(SwipeRefreshLayout)contentView.findViewById(R.id.swipe_container);
  mSwipeLayout.setSize(SwipeRefreshLayout.LARGE);
  mDataHelper=new FeedsDataHelper(App.getContext());
  getLoaderManager().initLoader(0,null,this);
  mAdapter=new FeedsAdapter(getActivity(),mListView);
  View header=new View(getActivity());
  mListView.addHeaderView(header);
  AnimationAdapter animationAdapter=new CardsAnimationAdapter(mAdapter);
  animationAdapter.setAbsListView(mListView);
  mListView.setAdapter(animationAdapter);
  mListView.setLoadNextListener(new PageListView.OnLoadNextListener(){
    @Override public void onLoadNext(){
      loadNextData();
    }
  }
);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      int actualPosition=position - mListView.getHeaderViewsCount();
      if (actualPosition < 0) {
        return;
      }
      ActivityOptionsCompat options=ActivityOptionsCompat.makeSceneTransitionAnimation(getActivity());
      Intent intent=new Intent(getActivity(),ImageViewActivity.class);
      Feed feed=mAdapter.getItem(position - mListView.getHeaderViewsCount());
      intent.putExtra(ImageViewActivity.IMAGE_NAME,feed.getName());
      intent.putStringArrayListExtra(ImageViewActivity.IMAGE_URL,feed.getImgs());
      intent.putExtra(ImageViewActivity.IMAGE_ID,feed.getId());
      ActivityCompat.startActivity(getActivity(),intent,options.toBundle());
    }
  }
);
  initActionBar();
  mSwipeLayout.setOnRefreshListener(this);
  mSwipeLayout.setColorSchemeResources(R.color.material_700,R.color.material_500);
  return contentView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View contentView=inflater.inflate(R.layout.fragment_feed,container,false);
  mListView=(PageListView)contentView.findViewById(R.id.listView);
  mSwipeLayout=(SwipeRefreshLayout)contentView.findViewById(R.id.swipe_container);
  mSwipeLayout.setSize(SwipeRefreshLayout.LARGE);
  mDataHelper=new FeedsDataHelper(App.getContext());
  getLoaderManager().initLoader(0,null,this);
  mAdapter=new FeedsAdapter(getActivity(),mListView);
  View header=new View(getActivity());
  mListView.addHeaderView(header);
  AnimationAdapter animationAdapter=new CardsAnimationAdapter(mAdapter);
  animationAdapter.setAbsListView(mListView);
  mListView.setAdapter(animationAdapter);
  mListView.setLoadNextListener(new PageListView.OnLoadNextListener(){
    @Override public void onLoadNext(){
      loadNextData();
    }
  }
);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      int actualPosition=position - mListView.getHeaderViewsCount();
      if (actualPosition < 0) {
        return;
      }
      ActivityOptionsCompat options=ActivityOptionsCompat.makeSceneTransitionAnimation(getActivity());
      Intent intent=new Intent(getActivity(),ImageViewActivity.class);
      Feed feed=mAdapter.getItem(position - mListView.getHeaderViewsCount());
      if (feed == null) {
        return;
      }
      intent.putExtra(ImageViewActivity.IMAGE_NAME,feed.getName());
      intent.putStringArrayListExtra(ImageViewActivity.IMAGE_URL,feed.getImgs());
      intent.putExtra(ImageViewActivity.IMAGE_ID,feed.getId());
      ActivityCompat.startActivity(getActivity(),intent,options.toBundle());
    }
  }
);
  initActionBar();
  mSwipeLayout.setOnRefreshListener(this);
  mSwipeLayout.setColorSchemeResources(R.color.material_700,R.color.material_500);
  return contentView;
}"
57618,"@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setLocale(""String_Node_Str"");
  setContentView(R.layout.activity_main);
  mEnd=(Button)findViewById(R.id.endDate);
  mStart=(Button)findViewById(R.id.startDate);
  mDark=(CheckBox)findViewById(R.id.darkTheme);
  mFeature=(CheckBox)findViewById(R.id.future);
  mEndDate=new Date();
  mStartDate=new Date();
  mEnd.setOnClickListener(this);
  mStart.setOnClickListener(this);
}","@Override protected void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setLocale(""String_Node_Str"");
  setContentView(R.layout.activity_main);
  mEnd=(Button)findViewById(R.id.endDate);
  mStart=(Button)findViewById(R.id.startDate);
  mDark=(CheckBox)findViewById(R.id.darkTheme);
  mFuture=(CheckBox)findViewById(R.id.future);
  mEndDate=new Date();
  mStartDate=new Date();
  mEnd.setOnClickListener(this);
  mStart.setOnClickListener(this);
}"
57619,"@Override public void onClick(View v){
  int id=v.getId() == R.id.startDate ? 1 : 2;
  @StyleRes int theme=mDark.isChecked() ? R.style.DarkDialogTheme : R.style.DialogTheme;
  DatePicker.Builder builder=new DatePicker.Builder().id(id).theme(theme).feature(mFeature.isChecked());
  if (v.getId() == R.id.startDate)   builder.date(mStartDate.getDay(),mStartDate.getMonth(),mStartDate.getYear());
 else   builder.date(mEndDate.getCalendar());
  builder.build(MainActivity.this).show(getSupportFragmentManager(),""String_Node_Str"");
}","@Override public void onClick(View v){
  int id=v.getId() == R.id.startDate ? 1 : 2;
  @StyleRes int theme=mDark.isChecked() ? R.style.DarkDialogTheme : R.style.DialogTheme;
  DatePicker.Builder builder=new DatePicker.Builder().id(id).theme(theme).future(mFuture.isChecked());
  if (v.getId() == R.id.startDate)   builder.date(mStartDate.getDay(),mStartDate.getMonth(),mStartDate.getYear());
 else   builder.date(mEndDate.getCalendar());
  builder.build(MainActivity.this).show(getSupportFragmentManager(),""String_Node_Str"");
}"
57620,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  checkFeature();
  mDate.performClick();
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  checkFuture();
  mDate.performClick();
}"
57621,"public Calendar getCalendar(){
  JDF jdf=new JDF();
  jdf.setIranianDate(year,month,day);
  Calendar calendar=Calendar.getInstance();
  calendar.set(jdf.getGregorianYear(),jdf.getGregorianMonth(),jdf.getGregorianDay());
  return calendar;
}","public Calendar getCalendar(){
  JDF jdf=new JDF();
  jdf.setIranianDate(year,month,day);
  Calendar calendar=Calendar.getInstance();
  calendar.set(jdf.getGregorianYear(),jdf.getGregorianMonth() - 1,jdf.getGregorianDay());
  return calendar;
}"
57622,"@Override public void onClick(View v){
  int id=v.getId() == R.id.startDate ? 1 : 2;
  @StyleRes int theme=mDark.isChecked() ? R.style.DarkDialogTheme : R.style.DialogTheme;
  DatePicker.Builder builder=new DatePicker.Builder().id(id).theme(theme).future(mFuture.isChecked());
  if (v.getId() == R.id.startDate)   builder.date(mStartDate.getDay(),mStartDate.getMonth(),mStartDate.getYear());
 else   builder.date(mEndDate.getCalendar());
  builder.build(MainActivity.this).show(getSupportFragmentManager(),""String_Node_Str"");
}","@Override public void onClick(View v){
  int id=v.getId() == R.id.startDate ? 1 : 2;
  @StyleRes int theme=mDark.isChecked() ? R.style.DarkDialogTheme : R.style.DialogTheme;
  DatePicker.Builder builder=new DatePicker.Builder().id(id).theme(theme).future(false).future(mFuture.isChecked());
  if (v.getId() == R.id.startDate)   builder.date(mStartDate.getDay(),mStartDate.getMonth(),mStartDate.getYear());
 else   builder.date(mEndDate.getCalendar());
  builder.build(MainActivity.this).show(getSupportFragmentManager(),""String_Node_Str"");
}"
57623,"/** 
 * @param day   Iranian day
 * @param month Iranian month
 */
@Override public void setDay(int day,int month){
  mDateItem.setDay(day);
  mDateItem.setMonth(month);
  updateDisplay();
}","/** 
 * @param day   Iranian day
 * @param month Iranian month
 * @param year   Iranian year
 */
@Override public void setDay(int day,int month,int year){
  mDateItem.setDay(day);
  mDateItem.setMonth(month);
  mDateItem.setYear(year);
  updateDisplay();
}"
57624,"/** 
 * @param year Iranian year
 */
@Override public void setYear(int year){
  mDateItem.setYear(year);
  updateDisplay();
}","/** 
 * @param year Iranian year
 */
@Override public void setYear(int year){
  mDateItem.setYear(year);
  if (!JDF.isLeapYear(year) && mDateItem.getMonth() == 12 && mDateItem.getDay() == 30) {
    mDateItem.setDay(29);
  }
  updateDisplay();
  if (mDateItem.shouldCloseYearAutomatically())   showMonths();
}"
57625,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  checkFuture();
  mDate.performClick();
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  checkFuture();
  if (mDateItem.shouldShowYearFirst())   mYear.performClick();
 else   mDate.performClick();
}"
57626,"@Override public void onClick(View view){
  int position=getDayIndex(getLayoutPosition());
  if (mCallback != null && position >= 0) {
    int oldMonth=mCallback.getMonth();
    mCallback.setDay(position + 1,mMonth + 1);
    if (oldMonth != mMonth + 1) {
      mOnClickListener.onClick(view);
    }
 else {
      notifyDataSetChanged();
    }
  }
}","@Override public void onClick(View view){
  int position=getDayIndex(getLayoutPosition());
  if (mCallback != null && position >= 0) {
    int oldMonth=mCallback.getMonth();
    mCallback.setDay(position + 1,mMonth + 1,mYear);
    if (oldMonth != mMonth + 1) {
      mOnClickListener.onClick(view);
    }
 else {
      notifyDataSetChanged();
    }
  }
}"
57627,"public MonthAdapter(DateInterface callback,View.OnClickListener onClickListener,int currentMonth,int maxMonth){
  mMaxMonth=maxMonth;
  mCallback=callback;
  mMonth=currentMonth;
  mOnClickListener=onClickListener;
  mToday=new JDF();
  try {
    mStartDay=new JDF().getIranianDay(mCallback.getYear(),mMonth + 1,1);
  }
 catch (  ParseException ignored) {
  }
}","public MonthAdapter(DateInterface callback,View.OnClickListener onClickListener,int currentMonth,int maxMonth,int chosenYear){
  mMaxMonth=maxMonth;
  mCallback=callback;
  mYear=chosenYear;
  mMonth=currentMonth;
  mOnClickListener=onClickListener;
  mToday=new JDF();
  try {
    mStartDay=new JDF().getIranianDay(mYear,mMonth + 1,1);
    mCurrentYear=mToday.getIranianYear();
  }
 catch (  ParseException ignored) {
  }
}"
57628,"@Override public int getItemCount(){
  int days=30;
  if (mMonth < 6)   days=31;
  if (mMonth == 11 && !JDF.isLeapYear(mCallback.getYear()))   days=29;
  if (mMaxMonth == mMonth + 1)   days=mToday.getIranianDay();
  return days + 7 + mStartDay;
}","@Override public int getItemCount(){
  int days=30;
  if (mMonth < 6)   days=31;
  if (mMonth == 11 && !JDF.isLeapYear(mYear))   days=29;
  if (mMaxMonth == mMonth + 1 && mYear == mCurrentYear)   days=mToday.getIranianDay();
  return days + 7 + mStartDay;
}"
57629,"private boolean isSelected(int day){
  return mCallback.getMonth() == mMonth + 1 && mCallback.getDay() == day + 1;
}","private boolean isSelected(int day){
  return mCallback.getMonth() == mMonth + 1 && mCallback.getDay() == day + 1 && mCallback.getYear() == mYear;
}"
57630,"private boolean isToday(int day){
  return (mMonth + 1 == mToday.getIranianMonth() && day + 1 == mToday.getIranianDay() && mCallback.getYear() == mToday.getIranianYear());
}","private boolean isToday(int day){
  return (mMonth + 1 == mToday.getIranianMonth() && day + 1 == mToday.getIranianDay() && mYear == mToday.getIranianYear());
}"
57631,"public Calendar getCalendar(){
  JDF jdf=new JDF();
  jdf.setIranianDate(year,month,day);
  Calendar calendar=Calendar.getInstance();
  calendar.set(jdf.getGregorianYear(),jdf.getGregorianMonth() - 1,jdf.getGregorianDay());
  return calendar;
}","public Calendar getCalendar(){
  JDF jdf=new JDF();
  jdf.setIranianDate(year,month,day);
  Calendar calendar=Calendar.getInstance();
  calendar.set(jdf.getGregorianYear(),jdf.getGregorianMonth(),jdf.getGregorianDay());
  return calendar;
}"
57632,"@Override public void onPageSelected(int month){
  super.onPageSelected(month);
  mTitle.setText(String.format(""String_Node_Str"",mAdapter.getPageTitle(month),mCallback.getYear()));
}","@Override public void onPageSelected(int month){
  super.onPageSelected(month);
  mTitle.setText(String.format(""String_Node_Str"",mAdapter.getPageTitle(month),year));
}"
57633,"@Override public Object instantiateItem(ViewGroup container,int month){
  View view=LayoutInflater.from(container.getContext()).inflate(R.layout.layout_recycler_view,container,false);
  RecyclerView recyclerView=(RecyclerView)view;
  MonthAdapter adapter=new MonthAdapter(mCallback,this,month,mMaxMonth);
  recyclerView.setLayoutManager(new GridLayoutManager(getContext(),7));
  recyclerView.setHasFixedSize(true);
  recyclerView.setAdapter(adapter);
  container.addView(view);
  return view;
}","@Override public Object instantiateItem(ViewGroup container,int month){
  View view=LayoutInflater.from(container.getContext()).inflate(R.layout.layout_recycler_view,container,false);
  RecyclerView recyclerView=(RecyclerView)view;
  MonthAdapter adapter=new MonthAdapter(mCallback,this,month,mMaxMonth,mCurrentYear);
  recyclerView.setLayoutManager(new GridLayoutManager(getContext(),7));
  recyclerView.setHasFixedSize(true);
  recyclerView.setAdapter(adapter);
  container.addView(view);
  return view;
}"
57634,"public PagerAdapter(){
  mCurrentYear=new JDF().getIranianYear();
}","public PagerAdapter(int year){
  mCurrentYear=year;
}"
57635,"@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mPager=(ViewPager)view.findViewById(R.id.pager);
  mTitle=(TextView)view.findViewById(R.id.title);
  mAdapter=new PagerAdapter();
  mPager.setAdapter(mAdapter);
  view.findViewById(R.id.next).setOnClickListener(this);
  view.findViewById(R.id.before).setOnClickListener(this);
  mPager.addOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener(){
    @Override public void onPageSelected(    int month){
      super.onPageSelected(month);
      mTitle.setText(String.format(""String_Node_Str"",mAdapter.getPageTitle(month),mCallback.getYear()));
    }
  }
);
  mPager.setCurrentItem(mCallback.getMonth() - 1);
}","@Override public void onViewCreated(View view,Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mPager=(ViewPager)view.findViewById(R.id.pager);
  mTitle=(TextView)view.findViewById(R.id.title);
  view.findViewById(R.id.next).setOnClickListener(this);
  view.findViewById(R.id.before).setOnClickListener(this);
  initPager(mCallback.getYear(),mCallback.getMonth() - 1);
}"
57636,"void setDay(int day,int month);","void setDay(int day,int month,int year);"
57637,"@Override public int getCount(){
  if (mMaxMonth > 0 && mCurrentYear == mCallback.getYear())   return mMaxMonth;
 else   return mCallback.getMonths().length;
}","@Override public int getCount(){
  if (mMaxMonth > 0 && mCurrentYear == mCallback.getCurrentYear())   return mMaxMonth;
 else   return mCallback.getMonths().length;
}"
57638,"public Calendar getCalendar(){
  JDF jdf=new JDF();
  jdf.setIranianDate(year,month,day);
  Calendar calendar=Calendar.getInstance();
  calendar.set(jdf.getGregorianYear(),jdf.getGregorianMonth(),jdf.getGregorianDay());
  return calendar;
}","public Calendar getCalendar(){
  JDF jdf=new JDF();
  jdf.setIranianDate(year,month,day);
  Calendar calendar=Calendar.getInstance();
  calendar.set(jdf.getGregorianYear(),jdf.getGregorianMonth() - 1,jdf.getGregorianDay());
  return calendar;
}"
57639,"private boolean isUpgradeRequest(FullHttpRequest request){
  return request.getDecoderResult().isSuccess() && request.headers().contains(HttpHeaders.Names.CONNECTION,HttpHeaders.Values.UPGRADE,true) && request.headers().contains(HttpHeaders.Names.UPGRADE,HttpHeaders.Values.WEBSOCKET,true)&& request.getUri().equals(websocketPath);
}","private boolean isUpgradeRequest(FullHttpRequest request){
  if (!request.getDecoderResult().isSuccess()) {
    return false;
  }
  String connectionHeaderValue=request.headers().get(HttpHeaders.Names.CONNECTION);
  if (connectionHeaderValue == null || !connectionHeaderValue.toLowerCase().contains(HttpHeaders.Values.UPGRADE.toLowerCase())) {
    return false;
  }
  if (!request.headers().contains(HttpHeaders.Names.UPGRADE,HttpHeaders.Values.WEBSOCKET,true)) {
    return false;
  }
  return request.getUri().equals(websocketPath);
}"
57640,"private void onMessageFromRegisteredChannel(WampRouterHandler handler,WampMessage msg){
  if (msg instanceof HelloMessage || msg instanceof WelcomeMessage) {
    closeActiveChannel(handler,new GoodbyeMessage(null,ApplicationError.INVALID_ARGUMENT));
  }
 else   if (msg instanceof AbortMessage || msg instanceof GoodbyeMessage) {
    handler.realm.removeChannel(handler,true);
    idleChannels.add(handler.ctx.channel());
    if (msg instanceof GoodbyeMessage) {
      GoodbyeMessage reply=new GoodbyeMessage(null,ApplicationError.GOODBYE_AND_OUT);
      handler.ctx.writeAndFlush(reply);
    }
  }
 else   if (msg instanceof CallMessage) {
    CallMessage call=(CallMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(call.procedure)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(call.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Procedure proc=null;
    if (err == null) {
      proc=handler.realm.procedures.get(call.procedure);
      if (proc == null)       err=ApplicationError.NO_SUCH_PROCEDURE;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(CallMessage.ID,call.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    Invocation invoc=new Invocation();
    invoc.callRequestId=call.requestId;
    invoc.caller=handler;
    invoc.procedure=proc;
    invoc.invocationRequestId=IdGenerator.newLinearId(proc.provider.lastUsedId,proc.provider.pendingInvocations);
    proc.provider.lastUsedId=invoc.invocationRequestId;
    proc.provider.pendingInvocations.put(invoc.invocationRequestId,invoc);
    InvocationMessage imsg=new InvocationMessage(invoc.invocationRequestId,proc.registrationId,null,call.arguments,call.argumentsKw);
    proc.provider.ctx.writeAndFlush(imsg);
  }
 else   if (msg instanceof YieldMessage) {
    YieldMessage yield=(YieldMessage)msg;
    if (!(IdValidator.isValidId(yield.requestId)))     return;
    Invocation invoc=handler.pendingInvocations.get(yield.requestId);
    if (invoc == null)     return;
    handler.pendingInvocations.remove(yield.requestId);
    invoc.procedure.pendingCalls.remove(invoc);
    ResultMessage result=new ResultMessage(invoc.callRequestId,null,yield.arguments,yield.argumentsKw);
    invoc.caller.ctx.writeAndFlush(result);
  }
 else   if (msg instanceof ErrorMessage) {
    ErrorMessage err=(ErrorMessage)msg;
    if (!(IdValidator.isValidId(err.requestId))) {
      return;
    }
    if (err.requestType == InvocationMessage.ID) {
      if (!UriValidator.tryValidate(err.error)) {
        closeActiveChannel(handler,new GoodbyeMessage(null,ApplicationError.INVALID_ARGUMENT));
        return;
      }
      Invocation invoc=handler.pendingInvocations.get(err.requestId);
      if (invoc == null)       return;
      handler.pendingInvocations.remove(err.requestId);
      invoc.procedure.pendingCalls.remove(invoc);
      ErrorMessage fwdError=new ErrorMessage(CallMessage.ID,invoc.callRequestId,null,err.error,err.arguments,err.argumentsKw);
      invoc.caller.ctx.writeAndFlush(fwdError);
    }
  }
 else   if (msg instanceof RegisterMessage) {
    RegisterMessage reg=(RegisterMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(reg.procedure)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(reg.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Procedure proc=null;
    if (err == null) {
      proc=handler.realm.procedures.get(reg.procedure);
      if (proc != null)       err=ApplicationError.PROCEDURE_ALREADY_EXISTS;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(RegisterMessage.ID,reg.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    long registrationId=IdGenerator.newLinearId(handler.lastUsedId,handler.providedProcedures);
    handler.lastUsedId=registrationId;
    Procedure procInfo=new Procedure(reg.procedure,handler,registrationId);
    handler.realm.procedures.put(reg.procedure,procInfo);
    if (handler.providedProcedures == null) {
      handler.providedProcedures=new HashMap<Long,WampRouter.Procedure>();
      handler.pendingInvocations=new HashMap<Long,WampRouter.Invocation>();
    }
    handler.providedProcedures.put(procInfo.registrationId,procInfo);
    RegisteredMessage response=new RegisteredMessage(reg.requestId,procInfo.registrationId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof UnregisterMessage) {
    UnregisterMessage unreg=(UnregisterMessage)msg;
    String err=null;
    if (!(IdValidator.isValidId(unreg.requestId)) || !(IdValidator.isValidId(unreg.registrationId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Procedure proc=null;
    if (err != null) {
      proc=handler.providedProcedures.get(unreg.registrationId);
      if (proc == null) {
        err=ApplicationError.NO_SUCH_REGISTRATION;
      }
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(UnregisterMessage.ID,unreg.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    for (    Invocation invoc : proc.pendingCalls) {
      handler.pendingInvocations.remove(invoc.invocationRequestId);
      if (invoc.caller.state == RouterHandlerState.Open) {
        ErrorMessage errMsg=new ErrorMessage(CallMessage.ID,invoc.callRequestId,null,ApplicationError.NO_SUCH_PROCEDURE,null,null);
        invoc.caller.ctx.writeAndFlush(errMsg);
      }
    }
    proc.pendingCalls.clear();
    handler.realm.procedures.remove(proc.procName);
    handler.providedProcedures.remove(proc.registrationId);
    if (handler.providedProcedures.size() == 0) {
      handler.providedProcedures=null;
      handler.pendingInvocations=null;
    }
    UnregisteredMessage response=new UnregisteredMessage(unreg.requestId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof SubscribeMessage) {
    SubscribeMessage sub=(SubscribeMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(sub.topic)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(sub.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(SubscribeMessage.ID,sub.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    long subscriptionId=IdGenerator.newLinearId(handler.lastUsedId,handler.subscriptions);
    handler.lastUsedId=subscriptionId;
    Subscription s=new Subscription(sub.topic,subscriptionId,handler);
    Set<Subscription> subscriptionSet=handler.realm.subscriptions.get(sub.topic);
    if (subscriptionSet == null) {
      subscriptionSet=new HashSet<Subscription>();
      handler.realm.subscriptions.put(sub.topic,subscriptionSet);
    }
    subscriptionSet.add(s);
    if (handler.subscriptions == null) {
      handler.subscriptions=new HashMap<Long,WampRouter.Subscription>();
    }
    handler.subscriptions.put(subscriptionId,s);
    SubscribedMessage response=new SubscribedMessage(sub.requestId,subscriptionId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof UnsubscribeMessage) {
    UnsubscribeMessage unsub=(UnsubscribeMessage)msg;
    String err=null;
    if (!(IdValidator.isValidId(unsub.requestId)) || !(IdValidator.isValidId(unsub.subscriptionId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Subscription s=null;
    if (err == null) {
      if (handler.subscriptions != null) {
        s=handler.subscriptions.get(unsub.subscriptionId);
      }
      if (s == null) {
        err=ApplicationError.NO_SUCH_SUBSCRIPTION;
      }
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(UnsubscribeMessage.ID,unsub.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    Set<Subscription> subscriptionSet=handler.realm.subscriptions.get(s.topic);
    subscriptionSet.remove(s);
    if (subscriptionSet.isEmpty()) {
      handler.realm.subscriptions.remove(s.topic);
    }
    handler.subscriptions.remove(unsub.subscriptionId);
    if (handler.subscriptions.isEmpty()) {
      handler.subscriptions=null;
    }
    UnsubscribedMessage response=new UnsubscribedMessage(unsub.requestId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof PublishMessage) {
    PublishMessage pub=(PublishMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(pub.topic)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(pub.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(PublishMessage.ID,pub.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    long publicationId=IdGenerator.newRandomId(null);
    Set<Subscription> subscriptionSet=handler.realm.subscriptions.get(pub.topic);
    if (subscriptionSet != null) {
      for (      Subscription subscriber : subscriptionSet) {
        if (subscriber.subscriber == handler)         continue;
        EventMessage ev=new EventMessage(subscriber.subscriptionId,publicationId,null,pub.arguments,pub.argumentsKw);
        subscriber.subscriber.ctx.writeAndFlush(ev);
      }
    }
    PublishedMessage response=new PublishedMessage(pub.requestId,publicationId);
    handler.ctx.writeAndFlush(response);
  }
}","private void onMessageFromRegisteredChannel(WampRouterHandler handler,WampMessage msg){
  if (msg instanceof HelloMessage || msg instanceof WelcomeMessage) {
    closeActiveChannel(handler,new GoodbyeMessage(null,ApplicationError.INVALID_ARGUMENT));
  }
 else   if (msg instanceof AbortMessage || msg instanceof GoodbyeMessage) {
    handler.realm.removeChannel(handler,true);
    idleChannels.add(handler.ctx.channel());
    if (msg instanceof GoodbyeMessage) {
      GoodbyeMessage reply=new GoodbyeMessage(null,ApplicationError.GOODBYE_AND_OUT);
      handler.ctx.writeAndFlush(reply);
    }
  }
 else   if (msg instanceof CallMessage) {
    CallMessage call=(CallMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(call.procedure)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(call.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Procedure proc=null;
    if (err == null) {
      proc=handler.realm.procedures.get(call.procedure);
      if (proc == null)       err=ApplicationError.NO_SUCH_PROCEDURE;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(CallMessage.ID,call.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    Invocation invoc=new Invocation();
    invoc.callRequestId=call.requestId;
    invoc.caller=handler;
    invoc.procedure=proc;
    invoc.invocationRequestId=IdGenerator.newLinearId(proc.provider.lastUsedId,proc.provider.pendingInvocations);
    proc.provider.lastUsedId=invoc.invocationRequestId;
    proc.provider.pendingInvocations.put(invoc.invocationRequestId,invoc);
    proc.pendingCalls.add(invoc);
    InvocationMessage imsg=new InvocationMessage(invoc.invocationRequestId,proc.registrationId,null,call.arguments,call.argumentsKw);
    proc.provider.ctx.writeAndFlush(imsg);
  }
 else   if (msg instanceof YieldMessage) {
    YieldMessage yield=(YieldMessage)msg;
    if (!(IdValidator.isValidId(yield.requestId)))     return;
    if (handler.pendingInvocations == null)     return;
    Invocation invoc=handler.pendingInvocations.get(yield.requestId);
    if (invoc == null)     return;
    handler.pendingInvocations.remove(yield.requestId);
    invoc.procedure.pendingCalls.remove(invoc);
    ResultMessage result=new ResultMessage(invoc.callRequestId,null,yield.arguments,yield.argumentsKw);
    invoc.caller.ctx.writeAndFlush(result);
  }
 else   if (msg instanceof ErrorMessage) {
    ErrorMessage err=(ErrorMessage)msg;
    if (!(IdValidator.isValidId(err.requestId))) {
      return;
    }
    if (err.requestType == InvocationMessage.ID) {
      if (!UriValidator.tryValidate(err.error)) {
        closeActiveChannel(handler,new GoodbyeMessage(null,ApplicationError.INVALID_ARGUMENT));
        return;
      }
      if (handler.pendingInvocations == null)       return;
      Invocation invoc=handler.pendingInvocations.get(err.requestId);
      if (invoc == null)       return;
      handler.pendingInvocations.remove(err.requestId);
      invoc.procedure.pendingCalls.remove(invoc);
      ErrorMessage fwdError=new ErrorMessage(CallMessage.ID,invoc.callRequestId,null,err.error,err.arguments,err.argumentsKw);
      invoc.caller.ctx.writeAndFlush(fwdError);
    }
  }
 else   if (msg instanceof RegisterMessage) {
    RegisterMessage reg=(RegisterMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(reg.procedure)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(reg.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Procedure proc=null;
    if (err == null) {
      proc=handler.realm.procedures.get(reg.procedure);
      if (proc != null)       err=ApplicationError.PROCEDURE_ALREADY_EXISTS;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(RegisterMessage.ID,reg.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    long registrationId=IdGenerator.newLinearId(handler.lastUsedId,handler.providedProcedures);
    handler.lastUsedId=registrationId;
    Procedure procInfo=new Procedure(reg.procedure,handler,registrationId);
    handler.realm.procedures.put(reg.procedure,procInfo);
    if (handler.providedProcedures == null) {
      handler.providedProcedures=new HashMap<Long,WampRouter.Procedure>();
      handler.pendingInvocations=new HashMap<Long,WampRouter.Invocation>();
    }
    handler.providedProcedures.put(procInfo.registrationId,procInfo);
    RegisteredMessage response=new RegisteredMessage(reg.requestId,procInfo.registrationId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof UnregisterMessage) {
    UnregisterMessage unreg=(UnregisterMessage)msg;
    String err=null;
    if (!(IdValidator.isValidId(unreg.requestId)) || !(IdValidator.isValidId(unreg.registrationId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Procedure proc=null;
    if (err == null) {
      if (handler.providedProcedures != null) {
        proc=handler.providedProcedures.get(unreg.registrationId);
      }
      if (proc == null) {
        err=ApplicationError.NO_SUCH_REGISTRATION;
      }
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(UnregisterMessage.ID,unreg.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    for (    Invocation invoc : proc.pendingCalls) {
      handler.pendingInvocations.remove(invoc.invocationRequestId);
      if (invoc.caller.state == RouterHandlerState.Open) {
        ErrorMessage errMsg=new ErrorMessage(CallMessage.ID,invoc.callRequestId,null,ApplicationError.NO_SUCH_PROCEDURE,null,null);
        invoc.caller.ctx.writeAndFlush(errMsg);
      }
    }
    proc.pendingCalls.clear();
    handler.realm.procedures.remove(proc.procName);
    handler.providedProcedures.remove(proc.registrationId);
    if (handler.providedProcedures.size() == 0) {
      handler.providedProcedures=null;
      handler.pendingInvocations=null;
    }
    UnregisteredMessage response=new UnregisteredMessage(unreg.requestId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof SubscribeMessage) {
    SubscribeMessage sub=(SubscribeMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(sub.topic)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(sub.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(SubscribeMessage.ID,sub.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    long subscriptionId=IdGenerator.newLinearId(handler.lastUsedId,handler.subscriptions);
    handler.lastUsedId=subscriptionId;
    Subscription s=new Subscription(sub.topic,subscriptionId,handler);
    Set<Subscription> subscriptionSet=handler.realm.subscriptions.get(sub.topic);
    if (subscriptionSet == null) {
      subscriptionSet=new HashSet<Subscription>();
      handler.realm.subscriptions.put(sub.topic,subscriptionSet);
    }
    subscriptionSet.add(s);
    if (handler.subscriptions == null) {
      handler.subscriptions=new HashMap<Long,WampRouter.Subscription>();
    }
    handler.subscriptions.put(subscriptionId,s);
    SubscribedMessage response=new SubscribedMessage(sub.requestId,subscriptionId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof UnsubscribeMessage) {
    UnsubscribeMessage unsub=(UnsubscribeMessage)msg;
    String err=null;
    if (!(IdValidator.isValidId(unsub.requestId)) || !(IdValidator.isValidId(unsub.subscriptionId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    Subscription s=null;
    if (err == null) {
      if (handler.subscriptions != null) {
        s=handler.subscriptions.get(unsub.subscriptionId);
      }
      if (s == null) {
        err=ApplicationError.NO_SUCH_SUBSCRIPTION;
      }
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(UnsubscribeMessage.ID,unsub.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    Set<Subscription> subscriptionSet=handler.realm.subscriptions.get(s.topic);
    subscriptionSet.remove(s);
    if (subscriptionSet.isEmpty()) {
      handler.realm.subscriptions.remove(s.topic);
    }
    handler.subscriptions.remove(unsub.subscriptionId);
    if (handler.subscriptions.isEmpty()) {
      handler.subscriptions=null;
    }
    UnsubscribedMessage response=new UnsubscribedMessage(unsub.requestId);
    handler.ctx.writeAndFlush(response);
  }
 else   if (msg instanceof PublishMessage) {
    PublishMessage pub=(PublishMessage)msg;
    String err=null;
    if (!UriValidator.tryValidate(pub.topic)) {
      err=ApplicationError.INVALID_URI;
    }
    if (err == null && !(IdValidator.isValidId(pub.requestId))) {
      err=ApplicationError.INVALID_ARGUMENT;
    }
    if (err != null) {
      ErrorMessage errMsg=new ErrorMessage(PublishMessage.ID,pub.requestId,null,err,null,null);
      handler.ctx.writeAndFlush(errMsg);
      return;
    }
    long publicationId=IdGenerator.newRandomId(null);
    Set<Subscription> subscriptionSet=handler.realm.subscriptions.get(pub.topic);
    if (subscriptionSet != null) {
      for (      Subscription subscriber : subscriptionSet) {
        if (subscriber.subscriber == handler)         continue;
        EventMessage ev=new EventMessage(subscriber.subscriptionId,publicationId,null,pub.arguments,pub.argumentsKw);
        subscriber.subscriber.ctx.writeAndFlush(ev);
      }
    }
    PublishedMessage response=new PublishedMessage(pub.requestId,publicationId);
    handler.ctx.writeAndFlush(response);
  }
}"
57641,"@Override public void onClick(View v){
  boolean on;
switch (v.getId()) {
case R.id.btnSwitchCloneMode:
    on=((Switch)v).isChecked();
  if (on) {
    try {
      mSinkManager=new SinkManager(mSinkManagerQueue);
      mNfcManager.setSinkManager(mSinkManager,mSinkManagerQueue);
      mNfcManager.getSinkManager().addSink(SinkManager.SinkType.DISPLAY_TEXTVIEW,mCurrUID,true);
      mNfcManager.start();
    }
 catch (    SinkInitException e) {
    }
    mCloneModeEnabled=true;
    mPinUID.setClickable(true);
  }
 else {
    mNfcManager.unsetSinkManager();
    mNfcManager.shutdown();
    mCloneModeEnabled=false;
    mPinUID.setChecked(false);
    mPinUID.setClickable(false);
  }
break;
case R.id.btnSwitchPinUID:
on=((Switch)v).isChecked();
if (on) {
Log.i(TAG,""String_Node_Str"");
DaemonConfiguration.getInstance().disablePolling();
}
 else {
Log.i(TAG,""String_Node_Str"");
DaemonConfiguration.getInstance().enablePolling();
}
}
}","@Override public void onClick(View v){
  boolean on;
switch (v.getId()) {
case R.id.btnSwitchCloneMode:
    on=((Switch)v).isChecked();
  if (on) {
    try {
      mSinkManager=new SinkManager(mSinkManagerQueue);
      mNfcManager.setSinkManager(mSinkManager,mSinkManagerQueue);
      mNfcManager.getSinkManager().addSink(SinkManager.SinkType.DISPLAY_TEXTVIEW,mCurrUID,true);
      mNfcManager.start();
    }
 catch (    SinkInitException e) {
    }
    mCloneModeEnabled=true;
    mPinUID.setClickable(true);
  }
 else {
    mNfcManager.unsetSinkManager();
    mNfcManager.shutdown();
    mCloneModeEnabled=false;
    DaemonConfiguration.getInstance().enablePolling();
    mPinUID.setChecked(false);
    mPinUID.setClickable(false);
  }
break;
case R.id.btnSwitchPinUID:
on=((Switch)v).isChecked();
if (on) {
Log.i(TAG,""String_Node_Str"");
DaemonConfiguration.getInstance().disablePolling();
}
 else {
Log.i(TAG,""String_Node_Str"");
DaemonConfiguration.getInstance().enablePolling();
}
}
}"
57642,"@Override public void onClick(View v){
switch (v.getId()) {
case R.id.btnSwitchCloneMode:
    boolean on=((Switch)v).isChecked();
  if (on) {
    mCloneModeEnabled=true;
  }
 else {
    mCloneModeEnabled=false;
  }
break;
}
}","@Override public void onClick(View v){
switch (v.getId()) {
case R.id.btnSwitchCloneMode:
    boolean on=((Switch)v).isChecked();
  if (on) {
    try {
      mSinkManager=new SinkManager(mSinkManagerQueue);
      mNfcManager.setSinkManager(mSinkManager,mSinkManagerQueue);
      mNfcManager.getSinkManager().addSink(SinkManager.SinkType.DISPLAY_TEXTVIEW,mCurrUID,true);
      mNfcManager.start();
    }
 catch (    SinkInitException e) {
    }
    mCloneModeEnabled=true;
  }
 else {
    mNfcManager.unsetSinkManager();
    mNfcManager.shutdown();
    mCloneModeEnabled=false;
  }
break;
}
}"
57643,"@Override public View onCreateView(final LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  mContext=inflater.getContext();
  final View v=inflater.inflate(R.layout.fragment_clone,container,false);
  mCurrUID=(TextView)v.findViewById(R.id.cloned_uid);
  mToggleCloneMode=(Switch)v.findViewById(R.id.btnSwitchCloneMode);
  mToggleCloneMode.setOnClickListener(this);
  try {
    if (mNfcManager.getSinkManager() == null) {
      mSinkManager=new SinkManager(mSinkManagerQueue);
      mNfcManager.setSinkManager(mSinkManager,mSinkManagerQueue);
    }
    mNfcManager.getSinkManager().addSink(SinkManager.SinkType.DISPLAY_TEXTVIEW,mCurrUID,true);
    mNfcManager.start();
  }
 catch (  SinkInitException e) {
    e.printStackTrace();
  }
  mListView=(ListView)v.findViewById(R.id.savedList);
  mSaveButton=(Button)v.findViewById(R.id.saveButton);
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      mSaveButton.setVisibility(View.INVISIBLE);
      final EditText input=new EditText(mContext);
      new AlertDialog.Builder(mContext).setTitle(""String_Node_Str"").setView(input).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          Editable value=input.getText();
          CloneListStorage storage=new CloneListStorage(mContext);
          storage.add(new CloneListItem(RelayFragment.getInstance().mNfcManager.getAnticolData(),value.toString()));
          refreshList();
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
        }
      }
).show();
    }
  }
);
  refreshList();
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> adapterView,    View view,    int pos,    long id){
      CloneListItem item=(CloneListItem)mListView.getAdapter().getItem(pos);
      RelayFragment.getInstance().mNfcManager.setAnticolData(item.getAnticolData());
      Toast.makeText(mContext,""String_Node_Str"" + item.toString(),Toast.LENGTH_LONG).show();
    }
  }
);
  mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener(){
    public boolean onItemLongClick(    AdapterView parent,    View view,    final int pos,    long id){
      final CharSequence[] items={""String_Node_Str""};
      AlertDialog.Builder builder=new AlertDialog.Builder(mContext);
      builder.setItems(items,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int _p){
          CloneListStorage storage=new CloneListStorage(mContext);
          CloneListItem item=(CloneListItem)mListView.getAdapter().getItem(pos);
          storage.delete(item);
          refreshList();
        }
      }
);
      AlertDialog alert=builder.create();
      alert.show();
      return true;
    }
  }
);
  return v;
}","@Override public View onCreateView(final LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  mContext=inflater.getContext();
  final View v=inflater.inflate(R.layout.fragment_clone,container,false);
  mCurrUID=(TextView)v.findViewById(R.id.cloned_uid);
  mToggleCloneMode=(Switch)v.findViewById(R.id.btnSwitchCloneMode);
  mToggleCloneMode.setOnClickListener(this);
  mListView=(ListView)v.findViewById(R.id.savedList);
  mSaveButton=(Button)v.findViewById(R.id.saveButton);
  mSaveButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View view){
      mSaveButton.setVisibility(View.INVISIBLE);
      final EditText input=new EditText(mContext);
      new AlertDialog.Builder(mContext).setTitle(""String_Node_Str"").setView(input).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          Editable value=input.getText();
          CloneListStorage storage=new CloneListStorage(mContext);
          storage.add(new CloneListItem(RelayFragment.getInstance().mNfcManager.getAnticolData(),value.toString()));
          refreshList();
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
        }
      }
).show();
    }
  }
);
  refreshList();
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> adapterView,    View view,    int pos,    long id){
      CloneListItem item=(CloneListItem)mListView.getAdapter().getItem(pos);
      RelayFragment.getInstance().mNfcManager.setAnticolData(item.getAnticolData());
      Toast.makeText(mContext,""String_Node_Str"" + item.toString(),Toast.LENGTH_LONG).show();
    }
  }
);
  mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener(){
    public boolean onItemLongClick(    AdapterView parent,    View view,    final int pos,    long id){
      final CharSequence[] items={""String_Node_Str""};
      AlertDialog.Builder builder=new AlertDialog.Builder(mContext);
      builder.setItems(items,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int _p){
          CloneListStorage storage=new CloneListStorage(mContext);
          CloneListItem item=(CloneListItem)mListView.getAdapter().getItem(pos);
          storage.delete(item);
          refreshList();
        }
      }
);
      AlertDialog alert=builder.create();
      alert.show();
      return true;
    }
  }
);
  return v;
}"
57644,"@Override public void onResume(){
  super.onResume();
  new AsyncSessionLoader().execute();
}","@Override public void onResume(){
  super.onResume();
  mSessions.clear();
  mListAdapter.clear();
  new AsyncSessionLoader().execute();
}"
57645,"@Override public void onClick(View v){
  TextView tempToken=(TextView)view.findViewById(R.id.token);
  String token=tempToken.getText().toString();
  SharedPreferences preferences=getActivity().getSharedPreferences(PREF_FILE_NAME,Context.MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putString(""String_Node_Str"",token);
  editor.commit();
  mListener.onTokenDialogPositiveClick();
  dismiss();
}","@Override public void onClick(View v){
  TextView tempToken=(TextView)view.findViewById(R.id.token);
  String token=tempToken.getText().toString();
  SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(getView().getContext());
  SharedPreferences.Editor editor=preferences.edit();
  editor.putString(""String_Node_Str"",token);
  editor.commit();
  mListener.onTokenDialogPositiveClick();
  dismiss();
}"
57646,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().setTitle(R.string.title_dialog_token);
  final View view=getActivity().getLayoutInflater().inflate(R.layout.dialog_token,null);
  final Button dismissBtn=(Button)view.findViewById(R.id.token_cancel_btn);
  dismissBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mListener.onTokenDialogNegativeClick();
      dismiss();
    }
  }
);
  Button goSettingsBtn=(Button)view.findViewById(R.id.token_submit_btn);
  goSettingsBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      TextView tempToken=(TextView)view.findViewById(R.id.token);
      String token=tempToken.getText().toString();
      SharedPreferences preferences=getActivity().getSharedPreferences(PREF_FILE_NAME,Context.MODE_PRIVATE);
      SharedPreferences.Editor editor=preferences.edit();
      editor.putString(""String_Node_Str"",token);
      editor.commit();
      mListener.onTokenDialogPositiveClick();
      dismiss();
    }
  }
);
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().setTitle(R.string.title_dialog_token);
  final View view=getActivity().getLayoutInflater().inflate(R.layout.dialog_token,null);
  final Button dismissBtn=(Button)view.findViewById(R.id.token_cancel_btn);
  dismissBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mListener.onTokenDialogNegativeClick();
      dismiss();
    }
  }
);
  Button goSettingsBtn=(Button)view.findViewById(R.id.token_submit_btn);
  goSettingsBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      TextView tempToken=(TextView)view.findViewById(R.id.token);
      String token=tempToken.getText().toString();
      SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(getView().getContext());
      SharedPreferences.Editor editor=preferences.edit();
      editor.putString(""String_Node_Str"",token);
      editor.commit();
      mListener.onTokenDialogPositiveClick();
      dismiss();
    }
  }
);
  return view;
}"
57647,"@Override public void onWorkaroundPositiveClick(){
  final SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  final View checkboxView=getLayoutInflater().inflate(R.layout.dialog_workaroundwarning,null);
  CheckBox dontShowAgain=(CheckBox)checkboxView.findViewById(R.id.neverAgain);
  if (dontShowAgain.isChecked()) {
    Log.i(TAG,""String_Node_Str"");
    SharedPreferences.Editor editor=preferences.edit();
    editor.putBoolean(""String_Node_Str"",true);
    editor.apply();
  }
  startActivity(new Intent(MainActivity.this,AboutWorkaroundActivity.class));
}","@Override public void onWorkaroundPositiveClick(View v){
  final SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  CheckBox dontShowAgain=(CheckBox)v.findViewById(R.id.neverAgain);
  if (dontShowAgain.isChecked()) {
    Log.i(TAG,""String_Node_Str"");
    SharedPreferences.Editor editor=preferences.edit();
    editor.putBoolean(""String_Node_Str"",true);
    editor.apply();
  }
  startActivity(new Intent(MainActivity.this,AboutWorkaroundActivity.class));
}"
57648,"@Override public void onWorkaroundNegativeClick(){
  final SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  final View checkboxView=getLayoutInflater().inflate(R.layout.dialog_workaroundwarning,null);
  CheckBox dontShowAgain=(CheckBox)checkboxView.findViewById(R.id.neverAgain);
  if (dontShowAgain.isChecked()) {
    Log.i(TAG,""String_Node_Str"");
    SharedPreferences.Editor editor=preferences.edit();
    editor.putBoolean(""String_Node_Str"",true);
    editor.apply();
  }
}","@Override public void onWorkaroundNegativeClick(View v){
  final SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  CheckBox dontShowAgain=(CheckBox)v.findViewById(R.id.neverAgain);
  if (dontShowAgain.isChecked()) {
    Log.i(TAG,""String_Node_Str"");
    SharedPreferences.Editor editor=preferences.edit();
    editor.putBoolean(""String_Node_Str"",true);
    editor.apply();
  }
}"
57649,"@Override public void onClick(View v){
  mListener.onWorkaroundPositiveClick();
  dismiss();
}","@Override public void onClick(View v){
  mListener.onWorkaroundPositiveClick(pushDialogView);
  dismiss();
}"
57650,public void onWorkaroundPositiveClick();,public void onWorkaroundPositiveClick(View v);
57651,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().setTitle(R.string.BCMWarnHeader);
  View pushDialogView=getActivity().getLayoutInflater().inflate(R.layout.dialog_workaroundwarning,null);
  final Button dismissBtn=(Button)pushDialogView.findViewById(R.id.btnWorkaroundNo);
  dismissBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mListener.onWorkaroundNegativeClick();
      dismiss();
    }
  }
);
  Button goSettingsBtn=(Button)pushDialogView.findViewById(R.id.btnWorkaroundYes);
  goSettingsBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mListener.onWorkaroundPositiveClick();
      dismiss();
    }
  }
);
  return pushDialogView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  getDialog().setTitle(R.string.BCMWarnHeader);
  final View pushDialogView=getActivity().getLayoutInflater().inflate(R.layout.dialog_workaroundwarning,null);
  final Button dismissBtn=(Button)pushDialogView.findViewById(R.id.btnWorkaroundNo);
  dismissBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mListener.onWorkaroundNegativeClick(pushDialogView);
      dismiss();
    }
  }
);
  Button goSettingsBtn=(Button)pushDialogView.findViewById(R.id.btnWorkaroundYes);
  goSettingsBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      mListener.onWorkaroundPositiveClick(pushDialogView);
      dismiss();
    }
  }
);
  return pushDialogView;
}"
57652,public void onWorkaroundNegativeClick();,public void onWorkaroundNegativeClick(View v);
57653,"protected void onListItemClick(View v,int pos,long id){
}","protected void onListItemClick(View v,int pos,long id){
  if (mlistAdapter.getItem(0) == ""String_Node_Str"" && pos == 0) {
    String[] temp=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    this.setmItems(temp);
    mlistAdapter.clear();
    mlistAdapter.addAll(this.getmItems());
    mlistAdapter.notifyDataSetChanged();
  }
 else {
    this.setmItems(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    mlistAdapter.clear();
    mlistAdapter.addAll(this.getmItems());
    mlistAdapter.notifyDataSetChanged();
  }
}"
57654,"protected boolean onLongListItemClick(View v,int pos,long id){
  return true;
}","protected boolean onLongListItemClick(View v,int pos,long id){
  String selectedItem=mlistAdapter.getItem(pos);
  mlistAdapter.remove(selectedItem);
  mlistAdapter.notifyDataSetChanged();
  Toast.makeText(getActivity(),""String_Node_Str"" + pos + ""String_Node_Str"",Toast.LENGTH_LONG).show();
  return true;
}"
57655,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.fragment_logging_list,container,false);
  mListView=(ListView)v.findViewById(R.id.sessionList);
  mSessionItems=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ArrayList<String> mSessionItemsList=new ArrayList<String>();
  mSessionItemsList.addAll(Arrays.asList(mSessionItems));
  mlistAdapterSession=new ArrayAdapter<String>(v.getContext(),R.layout.fragment_logging_row,mSessionItemsList);
  mListView.setAdapter(mlistAdapterSession);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> arg0,    View v,    int pos,    long id){
      onListItemClick(v,pos,id);
    }
  }
);
  mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener(){
    @Override public boolean onItemLongClick(    AdapterView<?> av,    View v,    int pos,    long id){
      return onLongListItemClick(v,pos,id);
    }
  }
);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View v=inflater.inflate(R.layout.fragment_logging_list,container,false);
  mListView=(ListView)v.findViewById(R.id.sessionList);
  ArrayList<String> mSessionItemsList=new ArrayList<String>();
  mSessionItemsList.addAll(Arrays.asList(mItems));
  mlistAdapter=new ArrayAdapter<String>(v.getContext(),R.layout.fragment_logging_row,mSessionItemsList);
  mListView.setAdapter(mlistAdapter);
  mListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> arg0,    View v,    int pos,    long id){
      onListItemClick(v,pos,id);
    }
  }
);
  mListView.setOnItemLongClickListener(new AdapterView.OnItemLongClickListener(){
    @Override public boolean onItemLongClick(    AdapterView<?> av,    View v,    int pos,    long id){
      return onLongListItemClick(v,pos,id);
    }
  }
);
  return v;
}"
57656,"public void showEnableNFCDialog(){
  DialogFragment dialog=new enablenfc_dialog();
  dialog.show(getActivity().getFragmentManager(),""String_Node_Str"");
}","public void showEnableNFCDialog(){
  DialogFragment dialog=new enablenfc_dialog();
  dialog.show(getFragmentManager(),""String_Node_Str"");
}"
57657,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  builder.setView(inflater.inflate(R.layout.enablenfc,null)).setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      mListener.onNFCDialogPositiveClick(enablenfc_dialog.this);
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      mListener.onNFCDialogNegativeClick(enablenfc_dialog.this);
    }
  }
);
  return builder.create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
  LayoutInflater inflater=getActivity().getLayoutInflater();
  builder.setView(inflater.inflate(R.layout.enablenfc,null)).setTitle(""String_Node_Str"").setMessage(""String_Node_Str"").setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
      Intent intent=new Intent(Settings.ACTION_NFC_SETTINGS);
      startActivity(intent);
    }
  }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int which){
    }
  }
).setIcon(android.R.drawable.ic_dialog_alert);
  return builder.create();
}"
57658,"public void onClick(DialogInterface dialog,int id){
  mListener.onNFCDialogNegativeClick(enablenfc_dialog.this);
}","public void onClick(DialogInterface dialog,int which){
}"
57659,"@Override public void onAttach(Activity activity){
  super.onAttach(activity);
  try {
    mListener=(NFCNoticeDialogListener)activity;
  }
 catch (  ClassCastException e) {
    throw new ClassCastException(activity.toString() + ""String_Node_Str"");
  }
}","@Override public void onAttach(Activity activity){
  super.onAttach(activity);
  try {
    mListener=(NFCNoticeDialogListener)activity;
  }
 catch (  ClassCastException e) {
  }
}"
57660,"/** 
 * Called on nfc tag intent
 * @param tag nfc tag
 * @return true if a supported tag is found
 */
public boolean setTag(Tag tag){
  boolean found_supported_tag=false;
  for (  String type : tag.getTechList()) {
    Log.i(TAG,""String_Node_Str"" + type);
    if (""String_Node_Str"".equals(type)) {
      found_supported_tag=true;
      mReader=new IsoDepReader(tag);
      Log.d(TAG,""String_Node_Str"");
    }
 else     if (""String_Node_Str"".equals(type)) {
      found_supported_tag=true;
      mReader=new NfcAReader(tag);
      Log.d(TAG,""String_Node_Str"");
    }
  }
  if (found_supported_tag) {
    LowLevelTCPHandler.getInstance().setCallback(this);
    byte[] uid=mReader.getUID();
    byte[] atqa=mReader.getAtqa();
    byte sak=mReader.getSak();
    byte[] hist=mReader.getHistoricalBytes();
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(uid));
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(atqa));
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(sak));
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(hist));
    Handler.sendAnticol(atqa,sak,hist,uid);
  }
  File bcmdevice=new File(""String_Node_Str"");
  if (bcmdevice.exists()) {
    Log.i(TAG,""String_Node_Str"");
    mBroadcomWorkaroundRunnable=new BroadcomWorkaround(tag);
    mBroadcomWorkaroundThread=new Thread(mBroadcomWorkaroundRunnable);
    mBroadcomWorkaroundThread.start();
    Handler.notifyCardWorkaroundConnected();
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return found_supported_tag;
}","/** 
 * Called on nfc tag intent
 * @param tag nfc tag
 * @return true if a supported tag is found
 */
public boolean setTag(Tag tag){
  boolean found_supported_tag=false;
  for (  String type : tag.getTechList()) {
    Log.i(TAG,""String_Node_Str"" + type);
    if (""String_Node_Str"".equals(type)) {
      found_supported_tag=true;
      mReader=new IsoDepReader(tag);
      Log.d(TAG,""String_Node_Str"");
      break;
    }
 else     if (""String_Node_Str"".equals(type)) {
      found_supported_tag=true;
      mReader=new NfcAReader(tag);
      Log.d(TAG,""String_Node_Str"");
      break;
    }
  }
  if (found_supported_tag) {
    Log.d(TAG,""String_Node_Str"");
    LowLevelTCPHandler.getInstance().setCallback(this);
    byte[] uid=mReader.getUID();
    byte[] atqa=mReader.getAtqa();
    byte sak=mReader.getSak();
    byte[] hist=mReader.getHistoricalBytes();
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(uid));
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(atqa));
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(sak));
    Log.d(TAG,""String_Node_Str"" + Utils.bytesToHex(hist));
    Handler.sendAnticol(atqa,sak,hist,uid);
  }
  File bcmdevice=new File(""String_Node_Str"");
  if (bcmdevice.exists()) {
    Log.i(TAG,""String_Node_Str"");
    mBroadcomWorkaroundRunnable=new BroadcomWorkaround(tag);
    mBroadcomWorkaroundThread=new Thread(mBroadcomWorkaroundRunnable);
    mBroadcomWorkaroundThread.start();
    Handler.notifyCardWorkaroundConnected();
  }
 else {
    Log.i(TAG,""String_Node_Str"");
  }
  return found_supported_tag;
}"
57661,"@Override public void onResume(){
  super.onResume();
  Log.i(""String_Node_Str"",""String_Node_Str"" + getIntent().getAction());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  if (mAdapter != null && mAdapter.isEnabled()) {
    mAdapter.enableForegroundDispatch(this,mPendingIntent,mFilters,mTechLists);
    if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(getIntent().getAction())) {
      Log.i(""String_Node_Str"",""String_Node_Str"");
      onNewIntent(getIntent());
    }
  }
  boolean chgsett;
  if (preferences.getBoolean(""String_Node_Str"",false)) {
    SharedPreferences.Editor editor=preferences.edit();
    ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
    port=preferences.getInt(""String_Node_Str"",5566);
    globalPort=preferences.getInt(""String_Node_Str"",5566);
    mIP.setText(ip);
    mPort.setText(String.valueOf(port));
    boolean lReaderMode=preferences.getBoolean(""String_Node_Str"",false);
    if (lReaderMode) {
      mAdapter.enableReaderMode(this,this,NfcAdapter.FLAG_READER_NFC_A | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK,null);
    }
 else {
      mAdapter.disableReaderMode(this);
    }
    chgsett=false;
    editor.putBoolean(""String_Node_Str"",chgsett);
    editor.commit();
  }
  mConnecttoSession.requestFocus();
}","@Override public void onResume(){
  super.onResume();
  Log.i(""String_Node_Str"",""String_Node_Str"" + getIntent().getAction());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  if (mAdapter != null && mAdapter.isEnabled()) {
    mAdapter.enableForegroundDispatch(this,mPendingIntent,mFilters,mTechLists);
    if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(getIntent().getAction())) {
      Log.i(""String_Node_Str"",""String_Node_Str"");
      onNewIntent(getIntent());
    }
  }
  boolean chgsett;
  if (preferences.getBoolean(""String_Node_Str"",false)) {
    SharedPreferences.Editor editor=preferences.edit();
    ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
    port=preferences.getInt(""String_Node_Str"",5566);
    globalPort=preferences.getInt(""String_Node_Str"",5566);
    mIP.setText(ip);
    mPort.setText(String.valueOf(port));
    boolean isReaderModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
    if (isReaderModeEnabled) {
      mAdapter.enableReaderMode(this,this,NfcAdapter.FLAG_READER_NFC_A | NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK,null);
    }
 else {
      mAdapter.disableReaderMode(this);
    }
    chgsett=false;
    editor.putBoolean(""String_Node_Str"",chgsett);
    editor.commit();
  }
  mConnecttoSession.requestFocus();
}"
57662,"public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.settings);
  mDevMode=(CheckBox)findViewById(R.id.checkBoxDevMode);
  mReaderMode=(CheckBox)findViewById(R.id.checkReaderMode);
  mIP=(TextView)findViewById(R.id.editIP);
  mPort=(TextView)findViewById(R.id.editPort);
  supportedFeatures=(TextView)findViewById(R.id.textViewSupportedFeatures);
  mbtnSaveSettings=(Button)findViewById(R.id.btnSaveSettings);
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  mDevModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  mReaderModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
  port=preferences.getInt(""String_Node_Str"",5566);
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  mDevMode.setChecked(mDevModeEnabled);
  mReaderMode.setChecked(mReaderModeEnabled);
  nfcisActive=false;
  hce=getPackageManager().hasSystemFeature(""String_Node_Str"");
  mAdapter=NfcAdapter.getDefaultAdapter(this);
  if (mAdapter != null && mAdapter.isEnabled()) {
    nfcisActive=true;
  }
  String values=""String_Node_Str"";
  if (nfcisActive) {
    values=values + ""String_Node_Str"";
  }
 else {
    values=values + ""String_Node_Str"";
  }
  values=values + ""String_Node_Str"";
  if (hce) {
    values=values + ""String_Node_Str"";
  }
 else {
    values=values + ""String_Node_Str"";
  }
  supportedFeatures.setText(""String_Node_Str"" + values);
}","public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.settings);
  mDevMode=(CheckBox)findViewById(R.id.checkBoxDevMode);
  mReaderMode=(CheckBox)findViewById(R.id.checkReaderMode);
  mIP=(TextView)findViewById(R.id.editIP);
  mPort=(TextView)findViewById(R.id.editPort);
  supportedFeatures=(TextView)findViewById(R.id.textViewSupportedFeatures);
  mbtnSaveSettings=(Button)findViewById(R.id.btnSaveSettings);
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  mDevModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  mReaderModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
  port=preferences.getInt(""String_Node_Str"",5566);
  globalPort=port;
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  mDevMode.setChecked(mDevModeEnabled);
  mReaderMode.setChecked(mReaderModeEnabled);
  nfcisActive=false;
  hce=getPackageManager().hasSystemFeature(""String_Node_Str"");
  mAdapter=NfcAdapter.getDefaultAdapter(this);
  if (mAdapter != null && mAdapter.isEnabled()) {
    nfcisActive=true;
  }
  String values=""String_Node_Str"";
  if (nfcisActive) {
    values=values + ""String_Node_Str"";
  }
 else {
    values=values + ""String_Node_Str"";
  }
  values=values + ""String_Node_Str"";
  if (hce) {
    values=values + ""String_Node_Str"";
  }
 else {
    values=values + ""String_Node_Str"";
  }
  supportedFeatures.setText(""String_Node_Str"" + values);
}"
57663,"public void btnSaveSettingsClicked(View view){
  ip=mIP.getText().toString();
  try {
    port=Integer.parseInt(mPort.getText().toString().trim());
  }
 catch (  NumberFormatException e) {
  }
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  mReaderModeEnabled=(((CheckBox)findViewById(R.id.checkReaderMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putBoolean(""String_Node_Str"",mReaderModeEnabled);
  editor.putString(""String_Node_Str"",ip);
  editor.putInt(""String_Node_Str"",port);
  boolean chgsett=true;
  editor.putBoolean(""String_Node_Str"",chgsett);
  editor.commit();
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
  finish();
}","public void btnSaveSettingsClicked(View view){
  if (!checkIpPort(mIP.getText().toString(),mPort.getText().toString())) {
    Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_LONG).show();
    return;
  }
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  mReaderModeEnabled=(((CheckBox)findViewById(R.id.checkReaderMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putBoolean(""String_Node_Str"",mReaderModeEnabled);
  editor.putString(""String_Node_Str"",mIP.getText().toString());
  editor.putInt(""String_Node_Str"",globalPort);
  boolean chgsett=true;
  editor.putBoolean(""String_Node_Str"",chgsett);
  editor.commit();
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
  finish();
}"
57664,"public void DevCheckboxClicked(View view){
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.commit();
}","public void DevCheckboxClicked(View view){
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  boolean chgsett=true;
  editor.putBoolean(""String_Node_Str"",chgsett);
  editor.commit();
}"
57665,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.action_settings:
    startActivity(new Intent(MainActivity.this,SettingsActivity.class));
  return true;
case R.id.action_about:
startActivity(new Intent(MainActivity.this,AboutActivity.class));
return true;
default :
return super.onOptionsItemSelected(item);
}
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.action_settings:
    startActivityForResult(new Intent(MainActivity.this,SettingsActivity.class),0);
  return true;
case R.id.action_about:
startActivity(new Intent(MainActivity.this,AboutActivity.class));
return true;
default :
return super.onOptionsItemSelected(item);
}
}"
57666,"/** 
 * Called when the user touches the button 'btnSaveSettingsClicked'  -- Code by Tom 
 */
public void btnSaveSettingsClicked(View view){
  ip=mIP.getText().toString();
  try {
    port=Integer.parseInt(mPort.getText().toString().trim());
  }
 catch (  NumberFormatException e) {
  }
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  mReaderModeEnabled=(((CheckBox)findViewById(R.id.checkReaderMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putBoolean(""String_Node_Str"",mReaderModeEnabled);
  editor.putString(""String_Node_Str"",ip);
  editor.putInt(""String_Node_Str"",port);
  boolean chgsett=true;
  editor.putBoolean(""String_Node_Str"",chgsett);
  editor.commit();
}","/** 
 * Called when the user touches the button 'btnSaveSettingsClicked'  -- Code by Tom 
 */
public void btnSaveSettingsClicked(View view){
  ip=mIP.getText().toString();
  try {
    port=Integer.parseInt(mPort.getText().toString().trim());
  }
 catch (  NumberFormatException e) {
  }
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  mReaderModeEnabled=(((CheckBox)findViewById(R.id.checkReaderMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putBoolean(""String_Node_Str"",mReaderModeEnabled);
  editor.putString(""String_Node_Str"",ip);
  editor.putInt(""String_Node_Str"",port);
  boolean chgsett=true;
  editor.putBoolean(""String_Node_Str"",chgsett);
  editor.commit();
  Toast.makeText(this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
  finish();
}"
57667,"/** 
 * called first, next: onStart()
 * @param savedInstanceState saved instance state
 */
@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mAdapter=NfcAdapter.getDefaultAdapter(this);
  mIntentFilter.addAction(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  mPendingIntent=PendingIntent.getActivity(this,0,new Intent(this,getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP),0);
  IntentFilter tech=new IntentFilter();
  tech.addAction(NfcAdapter.ACTION_TECH_DISCOVERED);
  mFilters=new IntentFilter[]{tech};
  mTechLists=new String[][]{new String[]{NfcA.class.getName()},new String[]{Ndef.class.getName()},new String[]{IsoDep.class.getName()}};
  mManager=(WifiP2pManager)getSystemService(Context.WIFI_P2P_SERVICE);
  mChannel=mManager.initialize(this,getMainLooper(),null);
  mReset=(Button)findViewById(R.id.resetstatus);
  mConnect=(Button)findViewById(R.id.connectbutton);
  mAbort=(Button)findViewById(R.id.abortbutton);
  mOwnID=(TextView)findViewById(R.id.editTextOwnID);
  mInfo=(TextView)findViewById(R.id.DisplayMsg);
  mDebuginfo=(TextView)findViewById(R.id.editTextDevModeEnabledDebugging);
  mIP=(TextView)findViewById(R.id.editIP);
  mPort=(TextView)findViewById(R.id.editPort);
  mConnect.requestFocus();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mAdapter=NfcAdapter.getDefaultAdapter(this);
  mIntentFilter.addAction(NfcAdapter.ACTION_ADAPTER_STATE_CHANGED);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
  mPendingIntent=PendingIntent.getActivity(this,0,new Intent(this,getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP),0);
  IntentFilter tech=new IntentFilter();
  tech.addAction(NfcAdapter.ACTION_TECH_DISCOVERED);
  mFilters=new IntentFilter[]{tech};
  mTechLists=new String[][]{new String[]{NfcA.class.getName()},new String[]{Ndef.class.getName()},new String[]{IsoDep.class.getName()}};
  mManager=(WifiP2pManager)getSystemService(Context.WIFI_P2P_SERVICE);
  mChannel=mManager.initialize(this,getMainLooper(),null);
  mReset=(Button)findViewById(R.id.resetstatus);
  mConnect=(Button)findViewById(R.id.connectbutton);
  mAbort=(Button)findViewById(R.id.abortbutton);
  mOwnID=(TextView)findViewById(R.id.editTextOwnID);
  mInfo=(TextView)findViewById(R.id.DisplayMsg);
  mDebuginfo=(TextView)findViewById(R.id.editTextDevModeEnabledDebugging);
  mIP=(TextView)findViewById(R.id.editIP);
  mPort=(TextView)findViewById(R.id.editPort);
  mConnect.requestFocus();
}"
57668,"/** 
 * called when app is already open and intent is fired
 * @param intent intent
 */
@Override public void onNewIntent(Intent intent){
  Log.i(""String_Node_Str"",""String_Node_Str"");
  if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction())) {
    Log.i(""String_Node_Str"",""String_Node_Str"" + intent);
    Tag tag=intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
    String tagId=""String_Node_Str"";
    mNetCallback.setTag(tag);
    mNetCallback.setUpdateButton(mDebuginfo);
    mOwnID.setText(""String_Node_Str"" + tagId);
    Toast.makeText(this,""String_Node_Str"" + tagId,Toast.LENGTH_SHORT).show();
  }
}","@Override public void onNewIntent(Intent intent){
  Log.i(""String_Node_Str"",""String_Node_Str"");
  if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(intent.getAction())) {
    Log.i(""String_Node_Str"",""String_Node_Str"" + intent);
    Tag tag=intent.getParcelableExtra(NfcAdapter.EXTRA_TAG);
    String tagId=""String_Node_Str"";
    mNetCallback.setTag(tag);
    mNetCallback.setUpdateButton(mDebuginfo);
    mOwnID.setText(""String_Node_Str"" + tagId);
    Toast.makeText(this,""String_Node_Str"" + tagId,Toast.LENGTH_SHORT).show();
  }
}"
57669,"/** 
 * Called when activity is paused
 */
@Override public void onPause(){
  super.onPause();
  unregisterReceiver(mReceiver);
}","@Override public void onPause(){
  super.onPause();
  unregisterReceiver(mReceiver);
}"
57670,"public void ButtonResetClicked(View view){
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",false);
  editor.putString(""String_Node_Str"",""String_Node_Str"");
  editor.putInt(""String_Node_Str"",5566);
  editor.commit();
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  mDevModeEnabled=false;
  mOwnID.setText(""String_Node_Str"");
  mInfo.setText(""String_Node_Str"");
  mDebuginfo.setText(""String_Node_Str"");
  this.setTitle(""String_Node_Str"");
  onResume();
}","/** 
 * Called when the user touches the button 'ButtonResetClicked application'  -- Code by Tom 
 */
public void ButtonResetClicked(View view){
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",false);
  editor.putString(""String_Node_Str"",""String_Node_Str"");
  editor.putInt(""String_Node_Str"",5566);
  editor.commit();
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  mDevModeEnabled=false;
  mOwnID.setText(""String_Node_Str"");
  mInfo.setText(""String_Node_Str"");
  mDebuginfo.setText(""String_Node_Str"");
  this.setTitle(""String_Node_Str"");
  onResume();
}"
57671,"public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.settings);
  mDevMode=(CheckBox)findViewById(R.id.checkBoxDevMode);
  mIP=(TextView)findViewById(R.id.editIP);
  mPort=(TextView)findViewById(R.id.editPort);
  mbtnSaveSettings=(Button)findViewById(R.id.btnSaveSettings);
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  mDevModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
  port=preferences.getInt(""String_Node_Str"",5566);
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  mDevMode.setChecked(mDevModeEnabled);
}","public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.settings);
  mDevMode=(CheckBox)findViewById(R.id.checkBoxDevMode);
  mIP=(TextView)findViewById(R.id.editIP);
  mPort=(TextView)findViewById(R.id.editPort);
  supportedFeatures=(TextView)findViewById(R.id.textViewSupportedFeatures);
  mbtnSaveSettings=(Button)findViewById(R.id.btnSaveSettings);
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  mDevModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
  port=preferences.getInt(""String_Node_Str"",5566);
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  mDevMode.setChecked(mDevModeEnabled);
  nfcisActive=false;
  hce=getPackageManager().hasSystemFeature(""String_Node_Str"");
  mAdapter=NfcAdapter.getDefaultAdapter(this);
  if (mAdapter != null && mAdapter.isEnabled()) {
    nfcisActive=true;
  }
  String values=""String_Node_Str"";
  if (nfcisActive) {
    values=values + ""String_Node_Str"";
  }
 else {
    values=values + ""String_Node_Str"";
  }
  values=values + ""String_Node_Str"";
  if (hce) {
    values=values + ""String_Node_Str"";
  }
 else {
    values=values + ""String_Node_Str"";
  }
  supportedFeatures.setText(""String_Node_Str"" + values);
}"
57672,"/** 
 * Called when the user touches the button 'btnSaveSettingsClicked'  -- Code by Tom 
 */
public void btnSaveSettingsClicked(View view){
  ip=mIP.getText().toString();
  try {
    port=Integer.parseInt(mPort.getText().toString().trim());
  }
 catch (  NumberFormatException e) {
  }
  boolean checked=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  if (checked) {
    this.mDevModeEnabled=true;
  }
 else {
    this.mDevModeEnabled=false;
  }
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putString(""String_Node_Str"",ip);
  editor.putInt(""String_Node_Str"",port);
  editor.commit();
}","/** 
 * Called when the user touches the button 'btnSaveSettingsClicked'  -- Code by Tom 
 */
public void btnSaveSettingsClicked(View view){
  ip=mIP.getText().toString();
  try {
    port=Integer.parseInt(mPort.getText().toString().trim());
  }
 catch (  NumberFormatException e) {
  }
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putString(""String_Node_Str"",ip);
  editor.putInt(""String_Node_Str"",port);
  editor.commit();
}"
57673,"public void DevCheckboxClicked(View view){
  boolean checked=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  if (checked) {
    this.mDevModeEnabled=true;
  }
 else {
    this.mDevModeEnabled=false;
  }
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.commit();
}","public void DevCheckboxClicked(View view){
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.commit();
}"
57674,"/** 
 * Called when the user touches the button 'Abort'  -- Code by Tom 
 */
public void ButtonAbortClicked(View view){
  boolean isHceSupported=getPackageManager().hasSystemFeature(""String_Node_Str"");
  Toast.makeText(this,""String_Node_Str"" + (isHceSupported ? ""String_Node_Str"" : ""String_Node_Str""),Toast.LENGTH_SHORT).show();
  this.setTitle(""String_Node_Str"");
}","/** 
 * Called when the user touches the button 'Abort'  -- Code by Tom 
 */
public void ButtonAbortClicked(View view){
  this.setTitle(""String_Node_Str"");
}"
57675,"@Override public void onResume(){
  super.onResume();
  Log.i(""String_Node_Str"",""String_Node_Str"" + getIntent().getAction());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  mDevModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  mDebuginfo=(TextView)findViewById(R.id.editTextDevModeEnabledDebugging);
  if (mDevModeEnabled) {
    mDebuginfo.setVisibility(View.VISIBLE);
  }
 else {
    mDebuginfo.setVisibility(View.INVISIBLE);
  }
  ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
  port=preferences.getInt(""String_Node_Str"",5566);
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  if (mAdapter != null && mAdapter.isEnabled()) {
    mAdapter.enableForegroundDispatch(this,mPendingIntent,mFilters,mTechLists);
    if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(getIntent().getAction())) {
      Log.i(""String_Node_Str"",""String_Node_Str"");
      onNewIntent(getIntent());
    }
  }
  mReceiver=new WiFiDirectBroadcastReceiver(mManager,mChannel,this);
  registerReceiver(mReceiver,mIntentFilter);
  mConnect.requestFocus();
}","@Override public void onResume(){
  super.onResume();
  Log.i(""String_Node_Str"",""String_Node_Str"" + getIntent().getAction());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  if (mAdapter != null && mAdapter.isEnabled()) {
    mAdapter.enableForegroundDispatch(this,mPendingIntent,mFilters,mTechLists);
    if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(getIntent().getAction())) {
      Log.i(""String_Node_Str"",""String_Node_Str"");
      onNewIntent(getIntent());
    }
  }
  boolean chgsett;
  if (preferences.getBoolean(""String_Node_Str"",false)) {
    SharedPreferences.Editor editor=preferences.edit();
    ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
    port=preferences.getInt(""String_Node_Str"",5566);
    mIP.setText(ip);
    mPort.setText(String.valueOf(port));
    chgsett=false;
    editor.putBoolean(""String_Node_Str"",chgsett);
    editor.commit();
  }
  mReceiver=new WiFiDirectBroadcastReceiver(mManager,mChannel,this);
  registerReceiver(mReceiver,mIntentFilter);
  mConnect.requestFocus();
}"
57676,"/** 
 * Called when the user touches the button 'ButtonResetClicked application'  -- Code by Tom 
 */
public void ButtonResetClicked(View view){
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",false);
  editor.putString(""String_Node_Str"",""String_Node_Str"");
  editor.putInt(""String_Node_Str"",5566);
  editor.commit();
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
  mDevModeEnabled=false;
  mOwnID.setText(""String_Node_Str"");
  mInfo.setText(""String_Node_Str"");
  mDebuginfo.setText(""String_Node_Str"");
  this.setTitle(""String_Node_Str"");
  onResume();
}","/** 
 * Called when the user touches the button 'ButtonResetClicked application'  -- Code by Tom 
 */
public void ButtonResetClicked(View view){
  mOwnID.setText(""String_Node_Str"");
  mInfo.setText(""String_Node_Str"");
  mDebuginfo.setText(""String_Node_Str"");
  this.setTitle(""String_Node_Str"");
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  mDevModeEnabled=preferences.getBoolean(""String_Node_Str"",false);
  mDebuginfo=(TextView)findViewById(R.id.editTextDevModeEnabledDebugging);
  if (mDevModeEnabled) {
    mDebuginfo.setVisibility(View.VISIBLE);
    mDebuginfo.requestFocus();
  }
 else {
    mDebuginfo.setVisibility(View.GONE);
  }
  ip=preferences.getString(""String_Node_Str"",""String_Node_Str"");
  port=preferences.getInt(""String_Node_Str"",5566);
  mIP.setText(ip);
  mPort.setText(String.valueOf(port));
}"
57677,"/** 
 * Called when the user touches the button 'btnSaveSettingsClicked'  -- Code by Tom 
 */
public void btnSaveSettingsClicked(View view){
  ip=mIP.getText().toString();
  try {
    port=Integer.parseInt(mPort.getText().toString().trim());
  }
 catch (  NumberFormatException e) {
  }
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putString(""String_Node_Str"",ip);
  editor.putInt(""String_Node_Str"",port);
  editor.commit();
}","/** 
 * Called when the user touches the button 'btnSaveSettingsClicked'  -- Code by Tom 
 */
public void btnSaveSettingsClicked(View view){
  ip=mIP.getText().toString();
  try {
    port=Integer.parseInt(mPort.getText().toString().trim());
  }
 catch (  NumberFormatException e) {
  }
  mDevModeEnabled=(((CheckBox)findViewById(R.id.checkBoxDevMode)).isChecked());
  SharedPreferences preferences=getSharedPreferences(PREF_FILE_NAME,MODE_PRIVATE);
  SharedPreferences.Editor editor=preferences.edit();
  editor.putBoolean(""String_Node_Str"",mDevModeEnabled);
  editor.putString(""String_Node_Str"",ip);
  editor.putInt(""String_Node_Str"",port);
  boolean chgsett=true;
  editor.putBoolean(""String_Node_Str"",chgsett);
  editor.commit();
}"
57678,"/** 
 * called after onStart()
 */
@Override public void onResume(){
  super.onResume();
  Log.i(""String_Node_Str"",""String_Node_Str"" + getIntent().getAction());
  mReceiver=new WiFiDirectBroadcastReceiver(mManager,mChannel,this);
  registerReceiver(mReceiver,mIntentFilter);
}","/** 
 * called after onStart()
 */
@Override public void onResume(){
  super.onResume();
  Log.i(""String_Node_Str"",""String_Node_Str"" + getIntent().getAction());
  mAdapter.enableForegroundDispatch(this,mPendingIntent,mFilters,mTechLists);
  if (NfcAdapter.ACTION_TECH_DISCOVERED.equals(getIntent().getAction())) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    onNewIntent(getIntent());
  }
  mReceiver=new WiFiDirectBroadcastReceiver(mManager,mChannel,this);
  registerReceiver(mReceiver,mIntentFilter);
}"
57679,"/** 
 * 获取某竞赛中某个用户各试题的提交记录.
 * @param contestId - 竞赛的唯一标识符
 * @param contestant - 参赛者
 * @return 包含用户提交记录的Map对象, 按试题ID索引
 */
public Map<Long,ContestSubmission> getSubmissionsOfContestantOfContest(long contestId,User contestant){
  if (contestant == null) {
    return null;
  }
  Map<Long,ContestSubmission> submissionsGroupByProblems=new HashMap<>();
  List<ContestSubmission> submissions=contestSubmissionMapper.getSubmissionOfContestOfContest(contestId,contestant.getUid());
  for (  ContestSubmission cs : submissions) {
    long problemId=cs.getSubmission().getProblem().getProblemId();
    if (submissionsGroupByProblems.containsKey(problemId)) {
      ContestSubmission prevSubmission=submissionsGroupByProblems.get(problemId);
      if (prevSubmission.getSubmission().getJudgeResult().equals(""String_Node_Str"") && !cs.getSubmission().getJudgeResult().equals(""String_Node_Str"")) {
        continue;
      }
    }
    submissionsGroupByProblems.put(problemId,cs);
  }
  return submissionsGroupByProblems;
}","/** 
 * 获取某竞赛中某个用户各试题的提交记录.
 * @param contestId - 竞赛的唯一标识符
 * @param contestant - 参赛者
 * @return 包含用户提交记录的Map对象, 按试题ID索引
 */
public Map<Long,ContestSubmission> getSubmissionsOfContestantOfContest(long contestId,User contestant){
  if (contestant == null) {
    return null;
  }
  Map<Long,ContestSubmission> submissionsGroupByProblems=new HashMap<>();
  List<ContestSubmission> submissions=contestSubmissionMapper.getSubmissionOfContestOfContest(contestId,contestant.getUid());
  for (  ContestSubmission cs : submissions) {
    long problemId=cs.getSubmission().getProblem().getProblemId();
    if (submissionsGroupByProblems.containsKey(problemId)) {
      ContestSubmission prevSubmission=submissionsGroupByProblems.get(problemId);
      if (prevSubmission.getSubmission().getJudgeResult().getJudgeResultSlug().equals(""String_Node_Str"") && !cs.getSubmission().getJudgeResult().getJudgeResultSlug().equals(""String_Node_Str"")) {
        continue;
      }
    }
    submissionsGroupByProblems.put(problemId,cs);
  }
  return submissionsGroupByProblems;
}"
57680,"public int compareTo(Object o){
  if (!(o instanceof ContestContestant)) {
    throw new ClassCastException(""String_Node_Str"");
  }
  ContestContestant occ=(ContestContestant)o;
  if (occ.getScore() == this.score) {
    return this.time > occ.getTime() ? 1 : -1;
  }
  return this.score - occ.getScore();
}","public int compareTo(Object o){
  if (!(o instanceof ContestContestant)) {
    throw new ClassCastException(""String_Node_Str"");
  }
  ContestContestant occ=(ContestContestant)o;
  if (occ.getScore() == this.score) {
    return this.time < occ.getTime() ? -1 : 1;
  }
  return occ.getScore() - this.score;
}"
57681,"/** 
 * 获取ACM赛制的排行榜.
 * @param contestId - 竞赛的唯一标识符
 * @return 包含参赛者和提交记录信息的Map对象
 */
public Map<String,Object> getLeaderBoardForAcm(long contestId){
  Contest contest=contestMapper.getContest(contestId);
  Map<String,Object> result=new HashMap<>(3,1);
  List<ContestContestant> contestants=contestContestantMapper.getContestantsOfContestForAcm(contestId,0,Integer.MAX_VALUE);
  Map<Long,Map<Long,Submission>> submissions=getSubmissionsGroupByContestant(contestSubmissionMapper.getAcceptedSubmissionsOfContest(contestId),false);
  Collections.sort(contestants);
  for (  ContestContestant cc : contestants) {
    long numberOfRejected=cc.getTime();
    long penalty=numberOfRejected * 1200;
    if (submissions.containsKey(cc.getContestant().getUid())) {
      Map<Long,Submission> submissionsOfContestant=submissions.get(cc.getContestant().getUid());
      for (      Map.Entry<Long,Submission> e : submissionsOfContestant.entrySet()) {
        Submission s=e.getValue();
        long usedTimeInMilliseconds=s.getSubmitTime().getTime() - contest.getStartTime().getTime();
        s.setUsedTime(usedTimeInMilliseconds / 1000);
        penalty+=s.getUsedTime();
      }
      cc.setTime(penalty);
    }
  }
  rankingContestants(contestants);
  result.put(""String_Node_Str"",contestants);
  result.put(""String_Node_Str"",submissions);
  return result;
}","/** 
 * 获取ACM赛制的排行榜.
 * @param contestId - 竞赛的唯一标识符
 * @return 包含参赛者和提交记录信息的Map对象
 */
public Map<String,Object> getLeaderBoardForAcm(long contestId){
  Contest contest=contestMapper.getContest(contestId);
  Map<String,Object> result=new HashMap<>(3,1);
  List<ContestContestant> contestants=contestContestantMapper.getContestantsOfContestForAcm(contestId,0,Integer.MAX_VALUE);
  Map<Long,Map<Long,Submission>> submissions=getSubmissionsGroupByContestant(contestSubmissionMapper.getAcceptedSubmissionsOfContest(contestId),false);
  for (  ContestContestant cc : contestants) {
    long numberOfRejected=cc.getTime();
    long penalty=numberOfRejected * 1200;
    if (submissions.containsKey(cc.getContestant().getUid())) {
      Map<Long,Submission> submissionsOfContestant=submissions.get(cc.getContestant().getUid());
      for (      Map.Entry<Long,Submission> e : submissionsOfContestant.entrySet()) {
        Submission s=e.getValue();
        long usedTimeInMilliseconds=s.getSubmitTime().getTime() - contest.getStartTime().getTime();
        s.setUsedTime(usedTimeInMilliseconds / 1000);
        penalty+=s.getUsedTime();
      }
      cc.setTime(penalty);
    }
  }
  Collections.sort(contestants);
  rankingContestants(contestants);
  result.put(""String_Node_Str"",contestants);
  result.put(""String_Node_Str"",submissions);
  return result;
}"
57682,"/** 
 * 获得具有层次关系的讨论话题列表.
 * @return 包含讨论话题及其继承关系的Map对象
 */
public Map<DiscussionTopic,List<DiscussionTopic>> getDiscussionTopicsWithHierarchy(){
  List<DiscussionTopic> DiscussionTopics=getDiscussionTopics();
  Map<Integer,List<DiscussionTopic>> DiscussionTopicsIndexer=new HashMap<Integer,List<DiscussionTopic>>();
  Map<DiscussionTopic,List<DiscussionTopic>> DiscussionTopicsHierarchy=new HashMap<DiscussionTopic,List<DiscussionTopic>>();
  for (  DiscussionTopic dt : DiscussionTopics) {
    if (dt.getParentDiscussionTopicId() == 0) {
      List<DiscussionTopic> subDiscussionTopics=new ArrayList<>();
      DiscussionTopicsHierarchy.put(dt,subDiscussionTopics);
      DiscussionTopicsIndexer.put(dt.getDiscussionTopicId(),subDiscussionTopics);
    }
  }
  for (  DiscussionTopic dt : DiscussionTopics) {
    int parentDiscussionTopicId=dt.getParentDiscussionTopicId();
    if (parentDiscussionTopicId != 0) {
      List<DiscussionTopic> subDiscussionTopics=DiscussionTopicsIndexer.get(parentDiscussionTopicId);
      if (subDiscussionTopics != null) {
        subDiscussionTopics.add(dt);
      }
    }
  }
  return DiscussionTopicsHierarchy;
}","/** 
 * 获得具有层次关系的讨论话题列表.
 * @return 包含讨论话题及其继承关系的Map对象
 */
public Map<DiscussionTopic,List<DiscussionTopic>> getDiscussionTopicsWithHierarchy(){
  List<DiscussionTopic> DiscussionTopics=getDiscussionTopics();
  Map<Integer,List<DiscussionTopic>> DiscussionTopicsIndexer=new HashMap<>();
  Map<DiscussionTopic,List<DiscussionTopic>> DiscussionTopicsHierarchy=new LinkedHashMap<>();
  for (  DiscussionTopic dt : DiscussionTopics) {
    if (dt.getParentDiscussionTopicId() == 0) {
      List<DiscussionTopic> subDiscussionTopics=new ArrayList<>();
      DiscussionTopicsHierarchy.put(dt,subDiscussionTopics);
      DiscussionTopicsIndexer.put(dt.getDiscussionTopicId(),subDiscussionTopics);
    }
  }
  for (  DiscussionTopic dt : DiscussionTopics) {
    int parentDiscussionTopicId=dt.getParentDiscussionTopicId();
    if (parentDiscussionTopicId != 0) {
      List<DiscussionTopic> subDiscussionTopics=DiscussionTopicsIndexer.get(parentDiscussionTopicId);
      if (subDiscussionTopics != null) {
        subDiscussionTopics.add(dt);
      }
    }
  }
  return DiscussionTopicsHierarchy;
}"
57683,"/** 
 * 测试用例: 测试getDiscussionTopics()方法 测试数据: N/a 预期结果: 返回一个包含两个DiscussionTopic的列表
 */
@Test public void testGetDiscussionTopics(){
  List<DiscussionTopic> topics=discussionTopicMapper.getDiscussionTopics();
  Assert.assertEquals(2,topics.size());
  DiscussionTopic firstTopic=topics.get(0);
  Assert.assertEquals(""String_Node_Str"",firstTopic.getDiscussionTopicSlug());
}","/** 
 * 测试用例: 测试getDiscussionTopics()方法 测试数据: N/a 预期结果: 返回一个包含两个DiscussionTopic的列表
 */
@Test public void testGetDiscussionTopics(){
  List<DiscussionTopic> topics=discussionTopicMapper.getDiscussionTopics();
  Assert.assertEquals(4,topics.size());
  DiscussionTopic firstTopic=topics.get(0);
  Assert.assertEquals(""String_Node_Str"",firstTopic.getDiscussionTopicSlug());
}"
57684,"/** 
 * 更新网站常规选项.
 * @param websiteName - 网站名称
 * @param websiteDescription - 网站描述
 * @param copyright - 网站版权信息
 * @param allowUserRegister - 是否允许用户注册
 * @param icpNumber - 网站备案号
 * @param googleAnalyticsCode - Google Analytics代码
 * @param offensiveWords - 敏感词列表
 * @param request - HttpServletRequest对象
 * @return 网站常规选项的更新结果
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> updateGeneralSettingsAction(@RequestParam(value=""String_Node_Str"",required=true) String websiteName,@RequestParam(value=""String_Node_Str"",required=true) String websiteDescription,@RequestParam(value=""String_Node_Str"",required=true) String copyright,@RequestParam(value=""String_Node_Str"",required=true) boolean allowUserRegister,@RequestParam(value=""String_Node_Str"",required=true) String icpNumber,@RequestParam(value=""String_Node_Str"",required=true) String googleAnalyticsCode,@RequestParam(value=""String_Node_Str"",required=true) String offensiveWords,HttpServletRequest request){
  Map<String,Boolean> result=optionService.updateOptions(websiteName,websiteDescription,copyright,allowUserRegister,icpNumber,googleAnalyticsCode,offensiveWords);
  return result;
}","/** 
 * 更新网站常规选项.
 * @param websiteName - 网站名称
 * @param websiteDescription - 网站描述
 * @param copyright - 网站版权信息
 * @param allowUserRegister - 是否允许用户注册
 * @param icpNumber - 网站备案号
 * @param policeIcpNumber - 公安备案号
 * @param googleAnalyticsCode - Google Analytics代码
 * @param offensiveWords - 敏感词列表
 * @param request - HttpServletRequest对象
 * @return 网站常规选项的更新结果
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> updateGeneralSettingsAction(@RequestParam(value=""String_Node_Str"",required=true) String websiteName,@RequestParam(value=""String_Node_Str"",required=true) String websiteDescription,@RequestParam(value=""String_Node_Str"",required=true) String copyright,@RequestParam(value=""String_Node_Str"",required=true) boolean allowUserRegister,@RequestParam(value=""String_Node_Str"",required=true) String icpNumber,@RequestParam(value=""String_Node_Str"",required=true) String policeIcpNumber,@RequestParam(value=""String_Node_Str"",required=true) String googleAnalyticsCode,@RequestParam(value=""String_Node_Str"",required=true) String offensiveWords,HttpServletRequest request){
  Map<String,Boolean> result=optionService.updateOptions(websiteName,websiteDescription,copyright,allowUserRegister,icpNumber,policeIcpNumber,googleAnalyticsCode,offensiveWords);
  return result;
}"
57685,"/** 
 * 获取某个用户通过(Accpeted)提交记录的数量.
 * @param uid - 用户的唯一标识符
 * @return 某个用户通过(Accpeted)提交记录的数量
 */
public long getAcceptedSubmissionUsingUserId(@Param(""String_Node_Str"") long uid);","/** 
 * 获取某个用户通过(Accepted)提交记录的数量.
 * @param uid - 用户的唯一标识符
 * @return 某个用户通过(Accepted)提交记录的数量
 */
public long getAcceptedSubmissionUsingUserId(@Param(""String_Node_Str"") long uid);"
57686,"/** 
 * 根据试题分类的唯一英文缩写获取试题分类的唯一标识符.
 * @param problemCategorySlug - 试题分类的唯一英文缩写
 * @return 试题分类的唯一标识符
 */
private int getProblemCategoryIdUsingSlug(String problemCategorySlug){
  int problemCategoryId=0;
  if (!problemCategorySlug.isEmpty()) {
    ProblemCategory problemCategory=problemCategoryMapper.getProblemCategoryUsingCategorySlug(problemCategorySlug);
    if (problemCategory != null) {
      problemCategoryId=problemCategory.getParentProblemCategoryId();
    }
  }
  return problemCategoryId;
}","/** 
 * 根据试题分类的唯一英文缩写获取试题分类的唯一标识符.
 * @param problemCategorySlug - 试题分类的唯一英文缩写
 * @return 试题分类的唯一标识符
 */
private int getProblemCategoryIdUsingSlug(String problemCategorySlug){
  int problemCategoryId=0;
  if (!problemCategorySlug.isEmpty()) {
    ProblemCategory problemCategory=problemCategoryMapper.getProblemCategoryUsingCategorySlug(problemCategorySlug);
    if (problemCategory != null) {
      problemCategoryId=problemCategory.getProblemCategoryId();
    }
  }
  return problemCategoryId;
}"
57687,"/** 
 * 处理用户修改密码的请求.
 * @param user - 待修改密码的用户对象
 * @param oldPassword - 旧密码
 * @param newPassword - 新密码
 * @param confirmPassword - 确认新密码
 * @param request - HttpServletRequest对象
 * @return 一个包含密码验证结果的Map<String, Boolean>对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> changePasswordInDashboardAction(@RequestParam(value=""String_Node_Str"",required=true) String oldPassword,@RequestParam(value=""String_Node_Str"",required=true) String newPassword,@RequestParam(value=""String_Node_Str"",required=true) String confirmPassword,HttpServletRequest request){
  User currentUser=HttpSessionParser.getCurrentUser(request.getSession());
  String ipAddress=HttpRequestParser.getRemoteAddr(request);
  Map<String,Boolean> result=userService.changePassword(currentUser,oldPassword,newPassword,confirmPassword);
  if (result.get(""String_Node_Str"")) {
    LOGGER.info(String.format(""String_Node_Str"",new Object[]{currentUser,ipAddress}));
  }
  return result;
}","/** 
 * 处理用户修改密码的请求.
 * @param oldPassword - 旧密码
 * @param newPassword - 新密码
 * @param confirmPassword - 确认新密码
 * @param request - HttpServletRequest对象
 * @return 一个包含密码验证结果的Map<String, Boolean>对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> changePasswordInDashboardAction(@RequestParam(value=""String_Node_Str"",required=true) String oldPassword,@RequestParam(value=""String_Node_Str"",required=true) String newPassword,@RequestParam(value=""String_Node_Str"",required=true) String confirmPassword,HttpServletRequest request){
  User currentUser=HttpSessionParser.getCurrentUser(request.getSession());
  String ipAddress=HttpRequestParser.getRemoteAddr(request);
  Map<String,Boolean> result=userService.changePassword(currentUser,oldPassword,newPassword,confirmPassword);
  if (result.get(""String_Node_Str"")) {
    LOGGER.info(String.format(""String_Node_Str"",new Object[]{currentUser,ipAddress}));
  }
  return result;
}"
57688,"/** 
 * 显示用户的登录页面.
 * @param isLogout - 是否处于登出状态
 * @param fowardUrl - 登录后跳转的地址(相对路径)
 * @param request - HttpServletRequest对象
 * @param response - HttpResponse对象
 * @return 包含登录页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView loginView(@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") boolean isLogout,@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") String forwardUrl,HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  if (isLogout) {
    destroySession(request,session);
  }
  ModelAndView view=null;
  if (isLoggedIn(session)) {
    view=new ModelAndView(""String_Node_Str"");
  }
 else {
    view=new ModelAndView(""String_Node_Str"");
    view.addObject(""String_Node_Str"",isLogout);
    view.addObject(""String_Node_Str"",forwardUrl);
  }
  return view;
}","/** 
 * 显示用户的登录页面.
 * @param isLogout - 是否处于登出状态
 * @param forwardUrl - 登录后跳转的地址(相对路径)
 * @param request - HttpServletRequest对象
 * @param response - HttpResponse对象
 * @return 包含登录页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView loginView(@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") boolean isLogout,@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") String forwardUrl,HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  if (isLogout) {
    destroySession(request,session);
  }
  ModelAndView view=null;
  if (isLoggedIn(session)) {
    view=new ModelAndView(""String_Node_Str"");
  }
 else {
    view=new ModelAndView(""String_Node_Str"");
    view.addObject(""String_Node_Str"",isLogout);
    view.addObject(""String_Node_Str"",forwardUrl);
  }
  return view;
}"
57689,"/** 
 * 加载重置密码页面.
 * @param email - 用户的电子邮件地址
 * @param hashCode - 用于重置密码的随机字符串
 * @param request - HttpServletRequest对象
 * @param response - HttpResponse对象
 * @return 包含密码重置页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView resetPasswordView(@RequestParam(value=""String_Node_Str"",required=false) String email,@RequestParam(value=""String_Node_Str"",required=false) String token,HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  ModelAndView view=null;
  if (isLoggedIn(session)) {
    view=new ModelAndView(""String_Node_Str"");
  }
 else {
    boolean isTokenValid=false;
    if (token != null && !token.isEmpty()) {
      isTokenValid=userService.isEmailValidationValid(email,token);
    }
    view=new ModelAndView(""String_Node_Str"");
    view.addObject(""String_Node_Str"",email);
    view.addObject(""String_Node_Str"",token);
    view.addObject(""String_Node_Str"",isTokenValid);
    view.addObject(""String_Node_Str"",CsrfProtector.getCsrfToken(session));
  }
  return view;
}","/** 
 * 加载重置密码页面.
 * @param email - 用户的电子邮件地址
 * @param token - 用于重置密码的随机字符串
 * @param request - HttpServletRequest对象
 * @param response - HttpResponse对象
 * @return 包含密码重置页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView resetPasswordView(@RequestParam(value=""String_Node_Str"",required=false) String email,@RequestParam(value=""String_Node_Str"",required=false) String token,HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  ModelAndView view=null;
  if (isLoggedIn(session)) {
    view=new ModelAndView(""String_Node_Str"");
  }
 else {
    boolean isTokenValid=false;
    if (token != null && !token.isEmpty()) {
      isTokenValid=userService.isEmailValidationValid(email,token);
    }
    view=new ModelAndView(""String_Node_Str"");
    view.addObject(""String_Node_Str"",email);
    view.addObject(""String_Node_Str"",token);
    view.addObject(""String_Node_Str"",isTokenValid);
    view.addObject(""String_Node_Str"",CsrfProtector.getCsrfToken(session));
  }
  return view;
}"
57690,"/** 
 * 更新网站常规选项.
 * @param websiteName - 网站名称
 * @param websiteDescription - 网站描述
 * @param copyright - 网站版权信息
 * @param allowUserRegister - 是否允许用户注册
 * @param icpNumber - 网站备案号
 * @param googleAnalyticsCode - Google Analytics代码
 * @param sensitiveWords - 敏感词列表
 * @param request - HttpServletRequest对象
 * @return 网站常规选项的更新结果
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> updateGeneralSettingsAction(@RequestParam(value=""String_Node_Str"",required=true) String websiteName,@RequestParam(value=""String_Node_Str"",required=true) String websiteDescription,@RequestParam(value=""String_Node_Str"",required=true) String copyright,@RequestParam(value=""String_Node_Str"",required=true) boolean allowUserRegister,@RequestParam(value=""String_Node_Str"",required=true) String icpNumber,@RequestParam(value=""String_Node_Str"",required=true) String googleAnalyticsCode,@RequestParam(value=""String_Node_Str"",required=true) String offensiveWords,HttpServletRequest request){
  Map<String,Boolean> result=optionService.updateOptions(websiteName,websiteDescription,copyright,allowUserRegister,icpNumber,googleAnalyticsCode,offensiveWords);
  return result;
}","/** 
 * 更新网站常规选项.
 * @param websiteName - 网站名称
 * @param websiteDescription - 网站描述
 * @param copyright - 网站版权信息
 * @param allowUserRegister - 是否允许用户注册
 * @param icpNumber - 网站备案号
 * @param googleAnalyticsCode - Google Analytics代码
 * @param offensiveWords - 敏感词列表
 * @param request - HttpServletRequest对象
 * @return 网站常规选项的更新结果
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> updateGeneralSettingsAction(@RequestParam(value=""String_Node_Str"",required=true) String websiteName,@RequestParam(value=""String_Node_Str"",required=true) String websiteDescription,@RequestParam(value=""String_Node_Str"",required=true) String copyright,@RequestParam(value=""String_Node_Str"",required=true) boolean allowUserRegister,@RequestParam(value=""String_Node_Str"",required=true) String icpNumber,@RequestParam(value=""String_Node_Str"",required=true) String googleAnalyticsCode,@RequestParam(value=""String_Node_Str"",required=true) String offensiveWords,HttpServletRequest request){
  Map<String,Boolean> result=optionService.updateOptions(websiteName,websiteDescription,copyright,allowUserRegister,icpNumber,googleAnalyticsCode,offensiveWords);
  return result;
}"
57691,"/** 
 * 删除选定的提交记录.
 * @param submissions - 提交记录ID的集合, 以逗号(, )分隔
 * @param request - HttpServletRequest对象
 * @return 提交记录的删除结果
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> deleteUsersAction(@RequestParam(value=""String_Node_Str"",required=true) String users,HttpServletRequest request){
  Map<String,Boolean> result=new HashMap<String,Boolean>(2,1);
  List<Long> userList=JSON.parseArray(users,Long.class);
  for (  Long userId : userList) {
    userService.deleteUser(userId);
  }
  result.put(""String_Node_Str"",true);
  return result;
}","/** 
 * 删除选定的用户.
 * @param users - 用户ID的集合, 以逗号(, )分隔
 * @param request - HttpServletRequest对象
 * @return 提交记录的删除结果
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST) public @ResponseBody Map<String,Boolean> deleteUsersAction(@RequestParam(value=""String_Node_Str"",required=true) String users,HttpServletRequest request){
  Map<String,Boolean> result=new HashMap<String,Boolean>(2,1);
  List<Long> userList=JSON.parseArray(users,Long.class);
  for (  Long userId : userList) {
    userService.deleteUser(userId);
  }
  result.put(""String_Node_Str"",true);
  return result;
}"
57692,"/** 
 * 加载试题的详细信息.
 * @param problemID - 试题的唯一标识符
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 包含试题详细信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView problemView(@PathVariable(""String_Node_Str"") long problemId,HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  boolean isLoggedIn=isLoggedIn(session);
  Problem problem=problemService.getProblem(problemId);
  if (problem == null) {
    throw new ResourceNotFoundException();
  }
 else   if (!problem.isPublic()) {
    boolean isAllowToAccess=false;
    if (isLoggedIn) {
      User currentUser=HttpSessionParser.getCurrentUser(session);
      if (currentUser.getUserGroup().getUserGroupSlug().equals(""String_Node_Str"")) {
        isAllowToAccess=true;
      }
    }
    if (!isAllowToAccess) {
      throw new ResourceNotFoundException();
    }
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",problem);
  if (isLoggedIn) {
    long userId=(Long)session.getAttribute(""String_Node_Str"");
    Map<Long,Submission> submissionOfProblems=submissionService.getSubmissionOfProblems(userId,problemId,problemId + 1);
    List<Submission> submissions=submissionService.getSubmissionUsingProblemIdAndUserId(problemId,userId,NUMBER_OF_SUBMISSIONS_PER_PROBLEM);
    List<Language> languages=languageService.getAllLanguages();
    view.addObject(""String_Node_Str"",submissionOfProblems);
    view.addObject(""String_Node_Str"",submissions);
    view.addObject(""String_Node_Str"",languages);
    view.addObject(""String_Node_Str"",CsrfProtector.getCsrfToken(session));
  }
  return view;
}","/** 
 * 加载试题的详细信息.
 * @param problemId - 试题的唯一标识符
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 包含试题详细信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView problemView(@PathVariable(""String_Node_Str"") long problemId,HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  boolean isLoggedIn=isLoggedIn(session);
  Problem problem=problemService.getProblem(problemId);
  if (problem == null) {
    throw new ResourceNotFoundException();
  }
 else   if (!problem.isPublic()) {
    boolean isAllowToAccess=false;
    if (isLoggedIn) {
      User currentUser=HttpSessionParser.getCurrentUser(session);
      if (currentUser.getUserGroup().getUserGroupSlug().equals(""String_Node_Str"")) {
        isAllowToAccess=true;
      }
    }
    if (!isAllowToAccess) {
      throw new ResourceNotFoundException();
    }
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",problem);
  if (isLoggedIn) {
    long userId=(Long)session.getAttribute(""String_Node_Str"");
    Map<Long,Submission> submissionOfProblems=submissionService.getSubmissionOfProblems(userId,problemId,problemId + 1);
    List<Submission> submissions=submissionService.getSubmissionUsingProblemIdAndUserId(problemId,userId,NUMBER_OF_SUBMISSIONS_PER_PROBLEM);
    List<Language> languages=languageService.getAllLanguages();
    view.addObject(""String_Node_Str"",submissionOfProblems);
    view.addObject(""String_Node_Str"",submissions);
    view.addObject(""String_Node_Str"",languages);
    view.addObject(""String_Node_Str"",CsrfProtector.getCsrfToken(session));
  }
  return view;
}"
57693,"/** 
 * 通过试题的唯一标识符获取试题标签对象的列表.
 * @param problemTagId - 试题的唯一标识符
 * @return 预期的试题标签对象列表
 */
public List<ProblemTag> getProblemTagUsingProblemId(long problemId);","/** 
 * 通过试题的唯一标识符获取试题标签对象的列表.
 * @param problemId - 试题的唯一标识符
 * @return 预期的试题标签对象列表
 */
public List<ProblemTag> getProblemTagUsingProblemId(long problemId);"
57694,"/** 
 * 通过评测记录唯一标识符获取试题对象.
 * @param submissionID - 评测记录的唯一标识符
 * @return 一个评测记录对象
 */
public Submission getSubmission(@Param(""String_Node_Str"") long submissionId);","/** 
 * 通过评测记录唯一标识符获取试题对象.
 * @param submissionId - 评测记录的唯一标识符
 * @return 一个评测记录对象
 */
public Submission getSubmission(@Param(""String_Node_Str"") long submissionId);"
57695,"/** 
 * 通过电子邮件地址获取用户对象.
 * @param username - 用户名
 * @return 预期的用户对象或空引用
 */
public User getUserUsingEmail(@Param(""String_Node_Str"") String email);","/** 
 * 通过电子邮件地址获取用户对象.
 * @param email - 电子邮件地址
 * @return 预期的用户对象或空引用
 */
public User getUserUsingEmail(@Param(""String_Node_Str"") String email);"
57696,"/** 
 * 检查编程语言设置的正确性.
 * @param languages - 包含编程语言设置的数组
 * @return 编程语言设置的验证结果
 */
private Map<String,Object> getUpdateLanguageSettingsResult(List<Language> previousLanguages,List<Language> newLanguages){
  boolean isSuccessful=true;
  Map<String,Object> result=new HashMap<String,Object>();
  for (  Language language : previousLanguages) {
    Map<String,Boolean> languageResult=new HashMap<String,Boolean>(4,1);
    languageResult.put(""String_Node_Str"",isLanguageDeleted(newLanguages,language));
    languageResult.put(""String_Node_Str"",isLanguageInUse(language));
    boolean isLanguageSuccessful=!languageResult.get(""String_Node_Str"") || !languageResult.get(""String_Node_Str"");
    languageResult.put(""String_Node_Str"",isLanguageSuccessful);
    result.put(language.getLanguageName(),languageResult);
    isSuccessful&=isLanguageSuccessful;
  }
  for (  Language language : newLanguages) {
    Map<String,Boolean> languageResult=new HashMap<String,Boolean>(10,1);
    languageResult.put(""String_Node_Str"",language.getLanguageSlug().isEmpty());
    languageResult.put(""String_Node_Str"",isLanguageSlugLegal(language.getLanguageSlug()));
    languageResult.put(""String_Node_Str"",isLanguageSlugExists(language.getLanguageSlug(),language.getLanguageId()));
    languageResult.put(""String_Node_Str"",language.getLanguageName().isEmpty());
    languageResult.put(""String_Node_Str"",isLanguageNameLegal(language.getLanguageName()));
    languageResult.put(""String_Node_Str"",language.getCompileCommand().isEmpty());
    languageResult.put(""String_Node_Str"",isCompileCommandLegal(language.getCompileCommand()));
    languageResult.put(""String_Node_Str"",language.getRunCommand().isEmpty());
    languageResult.put(""String_Node_Str"",isRunCommandLegal(language.getRunCommand()));
    boolean isLanguageSuccessful=!languageResult.get(""String_Node_Str"") && languageResult.get(""String_Node_Str"") && !languageResult.get(""String_Node_Str"")&& !languageResult.get(""String_Node_Str"")&& languageResult.get(""String_Node_Str"")&& !languageResult.get(""String_Node_Str"")&& languageResult.get(""String_Node_Str"")&& !languageResult.get(""String_Node_Str"")&& languageResult.get(""String_Node_Str"");
    languageResult.put(""String_Node_Str"",isLanguageSuccessful);
    result.put(language.getLanguageName(),languageResult);
    isSuccessful&=isLanguageSuccessful;
  }
  result.put(""String_Node_Str"",isSuccessful);
  return result;
}","/** 
 * 检查编程语言设置的正确性.
 * @param previousLanguages - 更新前的语言设置列表
 * @param newLanguages - 更新后的语言设置列表
 * @return 编程语言设置的验证结果
 */
private Map<String,Object> getUpdateLanguageSettingsResult(List<Language> previousLanguages,List<Language> newLanguages){
  boolean isSuccessful=true;
  Map<String,Object> result=new HashMap<String,Object>();
  for (  Language language : previousLanguages) {
    Map<String,Boolean> languageResult=new HashMap<String,Boolean>(4,1);
    languageResult.put(""String_Node_Str"",isLanguageDeleted(newLanguages,language));
    languageResult.put(""String_Node_Str"",isLanguageInUse(language));
    boolean isLanguageSuccessful=!languageResult.get(""String_Node_Str"") || !languageResult.get(""String_Node_Str"");
    languageResult.put(""String_Node_Str"",isLanguageSuccessful);
    result.put(language.getLanguageName(),languageResult);
    isSuccessful&=isLanguageSuccessful;
  }
  for (  Language language : newLanguages) {
    Map<String,Boolean> languageResult=new HashMap<String,Boolean>(10,1);
    languageResult.put(""String_Node_Str"",language.getLanguageSlug().isEmpty());
    languageResult.put(""String_Node_Str"",isLanguageSlugLegal(language.getLanguageSlug()));
    languageResult.put(""String_Node_Str"",isLanguageSlugExists(language.getLanguageSlug(),language.getLanguageId()));
    languageResult.put(""String_Node_Str"",language.getLanguageName().isEmpty());
    languageResult.put(""String_Node_Str"",isLanguageNameLegal(language.getLanguageName()));
    languageResult.put(""String_Node_Str"",language.getCompileCommand().isEmpty());
    languageResult.put(""String_Node_Str"",isCompileCommandLegal(language.getCompileCommand()));
    languageResult.put(""String_Node_Str"",language.getRunCommand().isEmpty());
    languageResult.put(""String_Node_Str"",isRunCommandLegal(language.getRunCommand()));
    boolean isLanguageSuccessful=!languageResult.get(""String_Node_Str"") && languageResult.get(""String_Node_Str"") && !languageResult.get(""String_Node_Str"")&& !languageResult.get(""String_Node_Str"")&& languageResult.get(""String_Node_Str"")&& !languageResult.get(""String_Node_Str"")&& languageResult.get(""String_Node_Str"")&& !languageResult.get(""String_Node_Str"")&& languageResult.get(""String_Node_Str"");
    languageResult.put(""String_Node_Str"",isLanguageSuccessful);
    result.put(language.getLanguageName(),languageResult);
    isSuccessful&=isLanguageSuccessful;
  }
  result.put(""String_Node_Str"",isSuccessful);
  return result;
}"
57697,"/** 
 * 创建评测任务, 将提交的信息提交至消息队列.
 * @param submission - 提交记录对象
 */
public void createSubmissionTask(long submissionId){
  Map<String,Object> mapMessage=new HashMap<String,Object>();
  mapMessage.put(""String_Node_Str"",""String_Node_Str"");
  mapMessage.put(""String_Node_Str"",submissionId);
  messageSender.sendMessage(mapMessage);
}","/** 
 * 创建评测任务, 将提交的信息提交至消息队列.
 * @param submissionId - 提交记录的唯一标识符
 */
public void createSubmissionTask(long submissionId){
  Map<String,Object> mapMessage=new HashMap<String,Object>();
  mapMessage.put(""String_Node_Str"",""String_Node_Str"");
  mapMessage.put(""String_Node_Str"",submissionId);
  messageSender.sendMessage(mapMessage);
}"
57698,"/** 
 * 过滤包含HTML字符串.
 * @param str - 待过滤的字符串
 * @return 过滤后的字符串.
 */
public static String filter(String text){
  if (text == null) {
    return text;
  }
  Document document=Jsoup.parse(text);
  document.outputSettings(new Document.OutputSettings().prettyPrint(false));
  document.select(""String_Node_Str"").append(""String_Node_Str"");
  document.select(""String_Node_Str"").prepend(""String_Node_Str"");
  String s=document.html().replaceAll(""String_Node_Str"",""String_Node_Str"");
  return Jsoup.clean(s,""String_Node_Str"",Whitelist.none(),new Document.OutputSettings().prettyPrint(false));
}","/** 
 * 过滤包含HTML字符串.
 * @param text - 待过滤的字符串
 * @return 过滤后的字符串.
 */
public static String filter(String text){
  if (text == null) {
    return text;
  }
  Document document=Jsoup.parse(text);
  document.outputSettings(new Document.OutputSettings().prettyPrint(false));
  document.select(""String_Node_Str"").append(""String_Node_Str"");
  document.select(""String_Node_Str"").prepend(""String_Node_Str"");
  String s=document.html().replaceAll(""String_Node_Str"",""String_Node_Str"");
  return Jsoup.clean(s,""String_Node_Str"",Whitelist.none(),new Document.OutputSettings().prettyPrint(false));
}"
57699,"/** 
 * 提供敏感词过滤的功能.
 * @param txt 带过滤字符串
 * @param matchType 匹配规则, 1 为极小匹配, 2 为极大匹配
 * @return 过滤后的字符串
 */
private String filter(String text,int matchType,String replaceChar){
  List<Position> offensiveWordsPosition=getOffensiveWordsPosition(text,matchType);
  StringBuilder resultStringBuilder=new StringBuilder(text);
  Iterator<Position> iterator=offensiveWordsPosition.iterator();
  while (iterator.hasNext()) {
    Position now=iterator.next();
    resultStringBuilder.replace(now.start,now.start + now.length,getReplaceChars(replaceChar,now.length));
  }
  return resultStringBuilder.toString();
}","/** 
 * 提供敏感词过滤的功能.
 * @param text - 待过滤字符串
 * @param matchType - 匹配规则, 1 为极小匹配, 2 为极大匹配
 * @return 过滤后的字符串
 */
private String filter(String text,int matchType,String replaceChar){
  List<Position> offensiveWordsPosition=getOffensiveWordsPosition(text,matchType);
  StringBuilder resultStringBuilder=new StringBuilder(text);
  Iterator<Position> iterator=offensiveWordsPosition.iterator();
  while (iterator.hasNext()) {
    Position now=iterator.next();
    resultStringBuilder.replace(now.start,now.start + now.length,getReplaceChars(replaceChar,now.length));
  }
  return resultStringBuilder.toString();
}"
57700,"/** 
 * 获取敏感词的位置.
 * @param text - 待过滤字符串
 * @param matchType - 匹配规则 1 为极小匹配,  2 为极大匹配
 * @return 敏感词的位置
 */
private List<Position> getOffensiveWordsPosition(String txt,int matchType){
  List<Position> offensiveWordsPosition=new ArrayList<Position>();
  for (int i=0; i < txt.length(); ++i) {
    int length=checkOffensiveWord(txt,i,matchType);
    if (length > 0) {
      Position position=new Position(i,length);
      offensiveWordsPosition.add(position);
      i=i + length - 1;
    }
  }
  return offensiveWordsPosition;
}","/** 
 * 获取敏感词的位置.
 * @param text - 待过滤字符串
 * @param matchType - 匹配规则 1 为极小匹配,  2 为极大匹配
 * @return 敏感词的位置
 */
private List<Position> getOffensiveWordsPosition(String text,int matchType){
  List<Position> offensiveWordsPosition=new ArrayList<Position>();
  for (int i=0; i < text.length(); ++i) {
    int length=checkOffensiveWord(text,i,matchType);
    if (length > 0) {
      Position position=new Position(i,length);
      offensiveWordsPosition.add(position);
      i=i + length - 1;
    }
  }
  return offensiveWordsPosition;
}"
57701,"/** 
 * 获取实时的评测结果.
 * @param submissionId - 提交记录的唯一标识符
 * @return 包含评测结果信息的StreamingResponseBody对象
 * @throws IOException 
 */
@RequestMapping(""String_Node_Str"") public SseEmitter getRealTimeJudgeResultAction(@RequestParam(value=""String_Node_Str"",required=true) long submissionId,@RequestParam(value=""String_Node_Str"",required=true) String csrfToken,HttpServletRequest request) throws IOException {
  User currentUser=HttpSessionParser.getCurrentUser(request.getSession());
  boolean isCsrfTokenValid=CsrfProtector.isCsrfTokenValid(csrfToken,request.getSession());
  Submission submission=submissionService.getSubmission(submissionId);
  if (!isCsrfTokenValid || submission == null || !submission.getUser().equals(currentUser) || !submission.getJudgeResult().getJudgeResultSlug().equals(""String_Node_Str"")) {
    throw new ResourceNotFoundException();
  }
  SseEmitter sseEmitter=new SseEmitter();
  submissionEventListener.addSseEmitters(submissionId,sseEmitter);
  sseEmitter.send(""String_Node_Str"");
  return sseEmitter;
}","/** 
 * 获取实时的评测结果.
 * @param submissionId - 提交记录的唯一标识符
 * @return 包含评测结果信息的StreamingResponseBody对象
 * @throws IOException 
 */
@RequestMapping(""String_Node_Str"") public SseEmitter getRealTimeJudgeResultAction(@RequestParam(value=""String_Node_Str"",required=true) long submissionId,@RequestParam(value=""String_Node_Str"",required=true) String csrfToken,HttpServletRequest request,HttpServletResponse response) throws IOException {
  User currentUser=HttpSessionParser.getCurrentUser(request.getSession());
  boolean isCsrfTokenValid=CsrfProtector.isCsrfTokenValid(csrfToken,request.getSession());
  Submission submission=submissionService.getSubmission(submissionId);
  if (!isCsrfTokenValid || submission == null || !submission.getUser().equals(currentUser) || !submission.getJudgeResult().getJudgeResultSlug().equals(""String_Node_Str"")) {
    throw new ResourceNotFoundException();
  }
  response.addHeader(""String_Node_Str"",""String_Node_Str"");
  SseEmitter sseEmitter=new SseEmitter();
  submissionEventListener.addSseEmitters(submissionId,sseEmitter);
  sseEmitter.send(""String_Node_Str"");
  return sseEmitter;
}"
57702,"/** 
 * 收到消息队列的新的评测请求时的回调函数.
 * @param submissionId - 评测记录的唯一标识符
 */
public void onSubmissionCreated(long submissionId){
  try {
    judgerDispatcher.createNewTask(submissionId);
  }
 catch (  IllgealSubmissionException ex) {
    logger.catching(ex);
  }
}","/** 
 * 收到消息队列的新的评测请求时的回调函数.
 * @param submissionId - 评测记录的唯一标识符
 */
public void onSubmissionCreated(long submissionId){
  System.out.println(1);
  try {
    judgerDispatcher.createNewTask(submissionId);
  }
 catch (  IllgealSubmissionException ex) {
    logger.catching(ex);
  }
}"
57703,"/** 
 * 获取当前用户的显示语言.
 * @param request - HttpRequest对象
 * @param session - HttpSession对象
 * @return 当前用户显示语言的唯一英文缩写
 */
private String getUserLanguage(HttpServletRequest request,HttpSession session){
  Object languageAttribute=session.getAttribute(""String_Node_Str"");
  if (languageAttribute == null) {
    String preferNaturalLanguage=getPreferNaturalLanguage(request);
    session.setAttribute(""String_Node_Str"",preferNaturalLanguage);
    return preferNaturalLanguage;
  }
  return (String)languageAttribute;
}","/** 
 * 获取当前用户的显示语言.
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 当前用户显示语言的唯一英文缩写
 */
private String getUserLanguage(HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  Object languageAttribute=session.getAttribute(""String_Node_Str"");
  if (languageAttribute == null) {
    String preferNaturalLanguage=getPreferNaturalLanguage(request,response);
    LocaleUtils.setLocale(request,response,preferNaturalLanguage);
    return preferNaturalLanguage;
  }
  return (String)languageAttribute;
}"
57704,"/** 
 * 加载已登录用户的个人信息及答题情况.
 * @param proceedingJoinPoint - ProceedingJoinPoint对象
 * @param request - HttpRequest对象
 * @return 一个包含预期视图的ModelAndView对象
 * @throws Throwable - ResourceNotFound异常
 */
@Around(value=""String_Node_Str"") public ModelAndView getUserProfile(ProceedingJoinPoint proceedingJoinPoint,HttpServletRequest request) throws Throwable {
  ModelAndView view=null;
  HttpSession session=request.getSession();
  view=(ModelAndView)proceedingJoinPoint.proceed();
  view.addObject(""String_Node_Str"",getUserLanguage(request,session));
  boolean isLoggedIn=isLoggedIn(session);
  if (isLoggedIn) {
    long uid=(Long)session.getAttribute(""String_Node_Str"");
    User user=userService.getUserUsingUid(uid);
    view.addObject(""String_Node_Str"",isLoggedIn).addObject(""String_Node_Str"",user).addObject(""String_Node_Str"",submissionService.getUserSubmissionStats(user.getUid()));
  }
  return view;
}","/** 
 * 加载已登录用户的个人信息及答题情况.
 * @param proceedingJoinPoint - ProceedingJoinPoint对象
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 一个包含预期视图的ModelAndView对象
 * @throws Throwable - ResourceNotFound异常
 */
@Around(value=""String_Node_Str"") public ModelAndView getUserProfile(ProceedingJoinPoint proceedingJoinPoint,HttpServletRequest request,HttpServletResponse response) throws Throwable {
  ModelAndView view=null;
  HttpSession session=request.getSession();
  view=(ModelAndView)proceedingJoinPoint.proceed();
  view.addObject(""String_Node_Str"",getUserLanguage(request,response));
  boolean isLoggedIn=isLoggedIn(session);
  if (isLoggedIn) {
    long uid=(Long)session.getAttribute(""String_Node_Str"");
    User user=userService.getUserUsingUid(uid);
    view.addObject(""String_Node_Str"",isLoggedIn).addObject(""String_Node_Str"",user).addObject(""String_Node_Str"",submissionService.getUserSubmissionStats(user.getUid()));
  }
  return view;
}"
57705,"/** 
 * 根据用户浏览器语言和系统支持的语言推荐默认语言.
 * @param request - HttpRequest对象
 * @return 推荐语言的代码(例如zh_CN)
 */
private String getPreferNaturalLanguage(HttpServletRequest request){
  final String DEFAULT_LANGUAGE=""String_Node_Str"";
  final String[] supportedLanguages={""String_Node_Str"",""String_Node_Str""};
  Locale browserLocale=getBrowserLocale(request);
  for (  String supportedLanguage : supportedLanguages) {
    Locale supportLanguageLocale=getLocaleOfSupportedLanguage(supportedLanguage);
    if (supportLanguageLocale.getLanguage().equals(browserLocale.getLanguage())) {
      return supportedLanguage;
    }
  }
  return DEFAULT_LANGUAGE;
}","/** 
 * 根据用户浏览器语言和系统支持的语言推荐默认语言.
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 推荐语言的代码(例如zh_CN)
 */
private String getPreferNaturalLanguage(HttpServletRequest request,HttpServletResponse response){
  final String DEFAULT_LANGUAGE=""String_Node_Str"";
  final String[] supportedLanguages={""String_Node_Str"",""String_Node_Str""};
  Locale browserLocale=getBrowserLocale(request);
  for (  String supportedLanguage : supportedLanguages) {
    Locale supportLanguageLocale=LocaleUtils.getLocaleOfLanguage(supportedLanguage);
    if (supportLanguageLocale.getLanguage().equals(browserLocale.getLanguage())) {
      return supportedLanguage;
    }
  }
  return DEFAULT_LANGUAGE;
}"
57706,"/** 
 * 显示用户的登录页面.
 * @param isLogout - 是否处于登出状态
 * @param request - Http Servlet Request对象
 * @return 包含登录页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView loginView(@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") boolean isLogout,HttpServletRequest request){
  HttpSession session=request.getSession();
  if (isLogout) {
    destroySession(request,session);
  }
  ModelAndView view=null;
  if (isLoggedIn(session)) {
    view=new ModelAndView(""String_Node_Str"");
  }
 else {
    view=new ModelAndView(""String_Node_Str"");
    view.addObject(""String_Node_Str"",isLogout);
  }
  return view;
}","/** 
 * 显示用户的登录页面.
 * @param isLogout - 是否处于登出状态
 * @param request - Http Servlet Request对象
 * @param response - HttpResponse对象
 * @return 包含登录页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView loginView(@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") boolean isLogout,HttpServletRequest request,HttpServletResponse response){
  HttpSession session=request.getSession();
  if (isLogout) {
    destroySession(request,session);
  }
  ModelAndView view=null;
  if (isLoggedIn(session)) {
    view=new ModelAndView(""String_Node_Str"");
  }
 else {
    view=new ModelAndView(""String_Node_Str"");
    view.addObject(""String_Node_Str"",isLogout);
  }
  return view;
}"
57707,"/** 
 * 显示升级浏览器页面.
 * @param request - HttpRequest对象
 * @return 一个包含升级浏览器页面内容的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView notSupportedView(HttpServletRequest request){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}","/** 
 * 显示升级浏览器页面.
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 一个包含升级浏览器页面内容的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView notSupportedView(HttpServletRequest request,HttpServletResponse response){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}"
57708,"/** 
 * 显示应用程序的首页.
 * @param request - HttpRequest对象
 * @return 一个包含首页内容的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView indexView(HttpServletRequest request){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}","/** 
 * 显示应用程序的首页.
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 一个包含首页内容的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView indexView(HttpServletRequest request,HttpServletResponse response){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}"
57709,"/** 
 * 处理通用Exception异常的方法.
 * @param request - HttpRequest对象
 * @return 返回一个包含异常信息的ModelAndView对象
 */
@ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) public ModelAndView InternelServerErrorView(HttpServletRequest request,Exception ex){
  logger.catching(ex);
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}","/** 
 * 处理通用Exception异常的方法.
 * @param ex - 抛出的异常对象
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 返回一个包含异常信息的ModelAndView对象
 */
@ResponseStatus(value=HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) public ModelAndView InternelServerErrorView(Exception ex,HttpServletRequest request,HttpServletResponse response){
  logger.catching(ex);
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}"
57710,"/** 
 * 处理ResourceNotFoundException异常的方法.
 * @param request - HttpRequest对象
 * @return 返回一个包含异常信息的ModelAndView对象
 */
@ResponseStatus(value=HttpStatus.NOT_FOUND) @ExceptionHandler(ResourceNotFoundException.class) public ModelAndView ResourceNotFoundView(HttpServletRequest request){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}","/** 
 * 处理ResourceNotFoundException异常的方法.
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 返回一个包含异常信息的ModelAndView对象
 */
@ResponseStatus(value=HttpStatus.NOT_FOUND) @ExceptionHandler(ResourceNotFoundException.class) public ModelAndView ResourceNotFoundView(HttpServletRequest request,HttpServletResponse response){
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  return view;
}"
57711,"/** 
 * 加载试题的详细信息.
 * @param problemID - 试题的唯一标识符
 * @param request - Http Servlet Request对象
 * @param session - Http Session对象
 * @return 包含试题详细信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView problemView(@PathVariable(""String_Node_Str"") int problemId,HttpServletRequest request){
  Problem problem=problemService.getProblem(problemId);
  if (problem == null || !problem.isPublic()) {
    throw new ResourceNotFoundException();
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",problem);
  HttpSession session=request.getSession();
  if (isLoggedIn(session)) {
    long userId=(Long)session.getAttribute(""String_Node_Str"");
    Map<Long,Submission> submissionOfProblems=submissionService.getSubmissionOfProblems(userId,problemId,problemId + 1);
    List<Submission> submissions=submissionService.getSubmissionUsingProblemIdAndUserId(problemId,userId,NUMBER_OF_SUBMISSIONS_PER_PROBLEM);
    view.addObject(""String_Node_Str"",submissionOfProblems);
    view.addObject(""String_Node_Str"",submissions);
  }
  return view;
}","/** 
 * 加载试题的详细信息.
 * @param problemID - 试题的唯一标识符
 * @param request - Http Servlet Request对象
 * @param response - HttpResponse对象
 * @return 包含试题详细信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView problemView(@PathVariable(""String_Node_Str"") int problemId,HttpServletRequest request,HttpServletResponse response){
  Problem problem=problemService.getProblem(problemId);
  if (problem == null || !problem.isPublic()) {
    throw new ResourceNotFoundException();
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",problem);
  HttpSession session=request.getSession();
  if (isLoggedIn(session)) {
    long userId=(Long)session.getAttribute(""String_Node_Str"");
    Map<Long,Submission> submissionOfProblems=submissionService.getSubmissionOfProblems(userId,problemId,problemId + 1);
    List<Submission> submissions=submissionService.getSubmissionUsingProblemIdAndUserId(problemId,userId,NUMBER_OF_SUBMISSIONS_PER_PROBLEM);
    view.addObject(""String_Node_Str"",submissionOfProblems);
    view.addObject(""String_Node_Str"",submissions);
  }
  return view;
}"
57712,"/** 
 * 显示试题库中的全部试题.
 * @param startIndex - 试题的起始下标
 * @param request - Http Servlet Request对象
 * @param session - Http Session对象
 * @return 包含试题库页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView problemsView(@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") int startIndex,HttpServletRequest request){
  if (startIndex < START_INDEX_OF_PROBLEMS) {
    startIndex=START_INDEX_OF_PROBLEMS;
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",problemService.getProblems(startIndex,NUMBER_OF_PROBLEMS_PER_PAGE)).addObject(""String_Node_Str"",START_INDEX_OF_PROBLEMS).addObject(""String_Node_Str"",NUMBER_OF_PROBLEMS_PER_PAGE).addObject(""String_Node_Str"",problemService.getNumberOfProblems());
  HttpSession session=request.getSession();
  if (isLoggedIn(session)) {
    long userId=(Long)session.getAttribute(""String_Node_Str"");
    Map<Long,Submission> submissionOfProblems=submissionService.getSubmissionOfProblems(userId,startIndex,startIndex + NUMBER_OF_PROBLEMS_PER_PAGE);
    view.addObject(""String_Node_Str"",submissionOfProblems);
  }
  return view;
}","/** 
 * 显示试题库中的全部试题.
 * @param startIndex - 试题的起始下标
 * @param request - Http Servlet Request对象
 * @param response - HttpResponse对象
 * @return 包含试题库页面信息的ModelAndView对象
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView problemsView(@RequestParam(value=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") int startIndex,HttpServletRequest request,HttpServletResponse response){
  if (startIndex < START_INDEX_OF_PROBLEMS) {
    startIndex=START_INDEX_OF_PROBLEMS;
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",problemService.getProblems(startIndex,NUMBER_OF_PROBLEMS_PER_PAGE)).addObject(""String_Node_Str"",START_INDEX_OF_PROBLEMS).addObject(""String_Node_Str"",NUMBER_OF_PROBLEMS_PER_PAGE).addObject(""String_Node_Str"",problemService.getNumberOfProblems());
  HttpSession session=request.getSession();
  if (isLoggedIn(session)) {
    long userId=(Long)session.getAttribute(""String_Node_Str"");
    Map<Long,Submission> submissionOfProblems=submissionService.getSubmissionOfProblems(userId,startIndex,startIndex + NUMBER_OF_PROBLEMS_PER_PAGE);
    view.addObject(""String_Node_Str"",submissionOfProblems);
  }
  return view;
}"
57713,"/** 
 * 显示提交列表的页面.
 * @param request - HttpRequest对象
 * @return 包含提交列表的ModelAndView对象 
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView submissionsView(HttpServletRequest request){
  List<Submission> submissions=submissionService.getSubmissions(NUMBER_OF_SUBMISSION_PER_PAGE);
  return new ModelAndView(""String_Node_Str"").addObject(""String_Node_Str"",submissions);
}","/** 
 * 显示提交列表的页面.
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 包含提交列表的ModelAndView对象 
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView submissionsView(HttpServletRequest request,HttpServletResponse response){
  List<Submission> submissions=submissionService.getSubmissions(NUMBER_OF_SUBMISSION_PER_PAGE);
  return new ModelAndView(""String_Node_Str"").addObject(""String_Node_Str"",submissions);
}"
57714,"/** 
 * 显示提交详细信息的页面.
 * @param submissionId - 提交的唯一标识符
 * @param request - HttpRequest对象
 * @return 包含提交详细信息的ModelAndView对象 
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView submissionView(@PathVariable(""String_Node_Str"") int submissionId,HttpServletRequest request){
  Submission submission=submissionService.getSubmission(submissionId);
  if (submission == null) {
    throw new ResourceNotFoundException();
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",submission);
  return view;
}","/** 
 * 显示提交详细信息的页面.
 * @param submissionId - 提交的唯一标识符
 * @param request - HttpRequest对象
 * @param response - HttpResponse对象
 * @return 包含提交详细信息的ModelAndView对象 
 */
@RequestMapping(value=""String_Node_Str"") public ModelAndView submissionView(@PathVariable(""String_Node_Str"") int submissionId,HttpServletRequest request,HttpServletResponse response){
  Submission submission=submissionService.getSubmission(submissionId);
  if (submission == null) {
    throw new ResourceNotFoundException();
  }
  ModelAndView view=new ModelAndView(""String_Node_Str"");
  view.addObject(""String_Node_Str"",submission);
  return view;
}"
57715,"/** 
 * 测试用例: 测试getProblems(long, int)方法 测试数据: 获取ID从1000起始的10道试题 预期结果: 返回预期的试题列表(共2题)
 */
@Test public void testGetProblemsFrom1000WithLimit10(){
  List<Problem> problems=problemMapper.getProblems(1000,10);
  Assert.assertEquals(2,problems.size());
  Problem firstProblem=problems.get(0);
  long problemId=firstProblem.getProblemID();
  Assert.assertEquals(1000,problemId);
  String problemName=firstProblem.getProblemName();
  Assert.assertEquals(""String_Node_Str"",problemName);
  long acceptedSubmission=firstProblem.getAcceptedSubmission();
  Assert.assertEquals(2,acceptedSubmission);
}","/** 
 * 测试用例: 测试getProblems(long, int)方法 测试数据: 获取ID从1000起始的10道试题 预期结果: 返回预期的试题列表(共2题)
 */
@Test public void testGetProblemsFrom1000WithLimit10(){
  List<Problem> problems=problemMapper.getProblems(1000,10);
  Assert.assertEquals(2,problems.size());
  Problem firstProblem=problems.get(0);
  long problemId=firstProblem.getProblemId();
  Assert.assertEquals(1000,problemId);
  String problemName=firstProblem.getProblemName();
  Assert.assertEquals(""String_Node_Str"",problemName);
  long acceptedSubmission=firstProblem.getAcceptedSubmission();
  Assert.assertEquals(2,acceptedSubmission);
}"
57716,"/** 
 * 测试用例: 测试getProblems(long, int)方法 测试数据: 获取ID从1001起始的1道试题 预期结果: 返回预期的试题列表(共1题)
 */
@Test public void testGetProblemsFrom1001WithLimit1(){
  List<Problem> problems=problemMapper.getProblems(1001,1);
  Assert.assertEquals(1,problems.size());
  Problem firstProblem=problems.get(0);
  long problemId=firstProblem.getProblemID();
  Assert.assertEquals(1001,problemId);
  long acceptedSubmission=firstProblem.getAcceptedSubmission();
  Assert.assertEquals(1,acceptedSubmission);
}","/** 
 * 测试用例: 测试getProblems(long, int)方法 测试数据: 获取ID从1001起始的1道试题 预期结果: 返回预期的试题列表(共1题)
 */
@Test public void testGetProblemsFrom1001WithLimit1(){
  List<Problem> problems=problemMapper.getProblems(1001,1);
  Assert.assertEquals(1,problems.size());
  Problem firstProblem=problems.get(0);
  long problemId=firstProblem.getProblemId();
  Assert.assertEquals(1001,problemId);
  long acceptedSubmission=firstProblem.getAcceptedSubmission();
  Assert.assertEquals(1,acceptedSubmission);
}"
57717,"/** 
 * 测试用例: 测试getProblems(long, int)方法 测试数据: 获取ID从1000起始的10道试题 预期结果: 返回预期的试题列表(共2题)
 */
@Test public void testGetProblemsFrom1000WithLimit10(){
  List<Problem> problems=problemMapper.getProblems(1000,10);
  Assert.assertEquals(2,problems.size());
  Problem firstProblem=problems.get(0);
  long problemId=firstProblem.getProblemId();
  Assert.assertEquals(1000,problemId);
  String problemName=firstProblem.getProblemName();
  Assert.assertEquals(""String_Node_Str"",problemName);
  long acceptedSubmission=firstProblem.getAcceptedSubmission();
  Assert.assertEquals(2,acceptedSubmission);
}","/** 
 * 测试用例: 测试getProblems(long, int)方法 测试数据: 获取ID从1000起始的10道试题 预期结果: 返回预期的试题列表(共2题)
 */
@Test public void testGetProblemsFrom1000WithLimit10(){
  List<Problem> problems=problemMapper.getProblems(1000,10);
  Assert.assertEquals(2,problems.size());
  Problem firstProblem=problems.get(0);
  long problemId=firstProblem.getProblemId();
  Assert.assertEquals(1000,problemId);
  String problemName=firstProblem.getProblemName();
  Assert.assertEquals(""String_Node_Str"",problemName);
  long acceptedSubmission=firstProblem.getAcceptedSubmission();
  Assert.assertEquals(1,acceptedSubmission);
}"
57718,"/** 
 * 测试用例: 测试getProblem()方法 测试数据: 使用A+B Problem的试题唯一标识符 预期结果: 返回预期的试题对象
 */
@Test public void testGetProblemExists(){
  Problem problem=problemMapper.getProblem(1000);
  Assert.assertNotNull(problem);
  String problemName=problem.getProblemName();
  Assert.assertEquals(""String_Node_Str"",problemName);
  long acceptedSubmission=problem.getAcceptedSubmission();
  Assert.assertEquals(2,acceptedSubmission);
}","/** 
 * 测试用例: 测试getProblem()方法 测试数据: 使用A+B Problem的试题唯一标识符 预期结果: 返回预期的试题对象
 */
@Test public void testGetProblemExists(){
  Problem problem=problemMapper.getProblem(1000);
  Assert.assertNotNull(problem);
  String problemName=problem.getProblemName();
  Assert.assertEquals(""String_Node_Str"",problemName);
  long acceptedSubmission=problem.getAcceptedSubmission();
  Assert.assertEquals(1,acceptedSubmission);
}"
57719,"/** 
 * 测试用例: 测试deleteLanguage(int)方法 测试数据: 不存在的编程语言唯一标识符 预期结果: 方法正常执行, 未影响数据表中的数据
 */
@Test public void testDeleteLanguageNotExists(){
  Language language=languageMapper.getLanguageUsingId(6);
  Assert.assertNull(language);
  languageMapper.deleteLanguage(0);
}","/** 
 * 测试用例: 测试deleteLanguage(int)方法 测试数据: 不存在的编程语言唯一标识符 预期结果: 方法正常执行, 未影响数据表中的数据
 */
@Test public void testDeleteLanguageNotExists(){
  Language language=languageMapper.getLanguageUsingId(0);
  Assert.assertNull(language);
  languageMapper.deleteLanguage(0);
}"
57720,"/** 
 * Enables or Disables the Antenna Port Power of the HackRF. Note: This function interacts with the USB Hardware and should not be called from a GUI Thread!
 * @param enable		true for enable or false for disable
 * @return 	true on success
 * @throws HackrfUsbException
 */
public boolean setAntennaPower(boolean enable) throws HackrfUsbException {
  if (this.sendUsbRequest(UsbConstants.USB_DIR_OUT,HACKRF_VENDOR_REQUEST_ANTENNA_ENABLE,(enable ? 1 : 0),0,null) != 0) {
    Log.e(logTag,""String_Node_Str"");
    throw (new HackrfUsbException(""String_Node_Str""));
  }
  return true;
}","/** 
 * Enables or Disables the Antenna Port Power of the HackRF. Note: This function interacts with the USB Hardware and should not be called from a GUI Thread!
 * @param enable		true for enable or false for disable
 * @return 	true on success
 * @throws HackrfUsbException
 */
public boolean setAntennaPower(boolean enable) throws HackrfUsbException {
  if (this.getBoardID() == 1) {
    Log.w(logTag,""String_Node_Str"");
    return false;
  }
  if (this.sendUsbRequest(UsbConstants.USB_DIR_OUT,HACKRF_VENDOR_REQUEST_ANTENNA_ENABLE,(enable ? 1 : 0),0,null) != 0) {
    Log.e(logTag,""String_Node_Str"");
    throw (new HackrfUsbException(""String_Node_Str""));
  }
  return true;
}"
57721,"/** 
 * Initializing the Hackrf Instance with a USB Device. Note: The application must have reclaimed permissions to access the USB Device BEFOR calling this constructor.
 * @param usbManager	Instance of the USB Manager (System Service)
 * @param usbDevice		Instance of an USB Device representing the HackRF
 * @param queueSize		Size of the receive/transmit queue in bytes
 * @throws HackrfUsbException
 */
private Hackrf(UsbManager usbManager,UsbDevice usbDevice,int queueSize) throws HackrfUsbException {
  this.usbManager=usbManager;
  this.usbDevice=usbDevice;
  this.usbInterface=usbDevice.getInterface(0);
  this.usbEndpointIN=usbInterface.getEndpoint(0);
  this.usbEndpointOUT=usbInterface.getEndpoint(1);
  this.usbConnection=usbManager.openDevice(usbDevice);
  this.queue=new ArrayBlockingQueue<byte[]>(queueSize / getPacketSize());
  this.bufferPool=new ArrayBlockingQueue<byte[]>(queueSize / getPacketSize());
  if (this.usbConnection == null) {
    Log.e(logTag,""String_Node_Str"");
    throw (new HackrfUsbException(""String_Node_Str""));
  }
}","/** 
 * Initializing the Hackrf Instance with a USB Device. Note: The application must have reclaimed permissions to access the USB Device BEFOR calling this constructor.
 * @param usbManager	Instance of the USB Manager (System Service)
 * @param usbDevice		Instance of an USB Device representing the HackRF
 * @param queueSize		Size of the receive/transmit queue in bytes
 * @throws HackrfUsbException
 */
private Hackrf(UsbManager usbManager,UsbDevice usbDevice,int queueSize) throws HackrfUsbException {
  this.usbManager=usbManager;
  this.usbDevice=usbDevice;
  Log.i(logTag,""String_Node_Str"" + usbDevice.getDeviceName() + ""String_Node_Str""+ usbDevice.getVendorId()+ ""String_Node_Str""+ usbDevice.getProductId());
  Log.i(logTag,""String_Node_Str"" + usbDevice.getDeviceProtocol());
  Log.i(logTag,""String_Node_Str"" + usbDevice.getDeviceClass() + ""String_Node_Str""+ usbDevice.getDeviceSubclass());
  Log.i(logTag,""String_Node_Str"" + usbDevice.getInterfaceCount());
  try {
    this.usbInterface=usbDevice.getInterface(0);
    Log.i(logTag,""String_Node_Str"" + usbInterface.getInterfaceProtocol() + ""String_Node_Str""+ usbInterface.getInterfaceSubclass());
    Log.i(logTag,""String_Node_Str"" + usbInterface.getInterfaceClass());
    Log.i(logTag,""String_Node_Str"" + usbInterface.getEndpointCount());
    this.usbEndpointIN=usbInterface.getEndpoint(0);
    this.usbEndpointOUT=usbInterface.getEndpoint(1);
    Log.i(logTag,""String_Node_Str"" + usbEndpointIN.getAddress() + ""String_Node_Str""+ usbEndpointIN.getAttributes()+ ""String_Node_Str""+ usbEndpointIN.getDirection()+ ""String_Node_Str""+ usbEndpointIN.getMaxPacketSize());
    Log.i(logTag,""String_Node_Str"" + usbEndpointOUT.getAddress() + ""String_Node_Str""+ usbEndpointOUT.getAttributes()+ ""String_Node_Str""+ usbEndpointOUT.getDirection()+ ""String_Node_Str""+ usbEndpointOUT.getMaxPacketSize());
    this.usbConnection=usbManager.openDevice(usbDevice);
  }
 catch (  Exception e) {
    Log.e(logTag,""String_Node_Str"" + e.getMessage());
    throw (new HackrfUsbException(""String_Node_Str""));
  }
  this.queue=new ArrayBlockingQueue<byte[]>(queueSize / getPacketSize());
  this.bufferPool=new ArrayBlockingQueue<byte[]>(queueSize / getPacketSize());
}"
57722,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  handler=new Handler();
  bt_info=((Button)this.findViewById(R.id.bt_info));
  bt_rx=((Button)this.findViewById(R.id.bt_rx));
  bt_tx=((Button)this.findViewById(R.id.bt_tx));
  bt_stop=((Button)this.findViewById(R.id.bt_stop));
  bt_openHackRF=((Button)this.findViewById(R.id.bt_openHackRF));
  et_sampRate=(EditText)this.findViewById(R.id.et_sampRate);
  et_freq=(EditText)this.findViewById(R.id.et_freq);
  et_filename=(EditText)this.findViewById(R.id.et_filename);
  sb_vgaGain=(SeekBar)this.findViewById(R.id.sb_vgaGain);
  sb_lnaGain=(SeekBar)this.findViewById(R.id.sb_lnaGain);
  cb_amp=(CheckBox)this.findViewById(R.id.cb_amp);
  cb_antenna=(CheckBox)this.findViewById(R.id.cb_antenna);
  tv_output=(TextView)findViewById(R.id.tv_output);
  tv_output.setMovementMethod(new ScrollingMovementMethod());
  this.toggleButtonsEnabledIfHackrfReady(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  handler=new Handler();
  bt_info=((Button)this.findViewById(R.id.bt_info));
  bt_rx=((Button)this.findViewById(R.id.bt_rx));
  bt_tx=((Button)this.findViewById(R.id.bt_tx));
  bt_stop=((Button)this.findViewById(R.id.bt_stop));
  bt_openHackRF=((Button)this.findViewById(R.id.bt_openHackRF));
  et_sampRate=(EditText)this.findViewById(R.id.et_sampRate);
  et_freq=(EditText)this.findViewById(R.id.et_freq);
  et_filename=(EditText)this.findViewById(R.id.et_filename);
  sb_vgaGain=(SeekBar)this.findViewById(R.id.sb_vgaGain);
  sb_lnaGain=(SeekBar)this.findViewById(R.id.sb_lnaGain);
  cb_amp=(CheckBox)this.findViewById(R.id.cb_amp);
  cb_antenna=(CheckBox)this.findViewById(R.id.cb_antenna);
  tv_output=(TextView)findViewById(R.id.tv_output);
  tv_output.setMovementMethod(new ScrollingMovementMethod());
  this.toggleButtonsEnabledIfHackrfReady(false);
  String version=""String_Node_Str"";
  try {
    version=getPackageManager().getPackageInfo(getPackageName(),0).versionName;
  }
 catch (  NameNotFoundException e) {
  }
  this.tv_output.setText(""String_Node_Str"" + version + ""String_Node_Str"");
}"
57723,"/** 
 * Will read the values from the GUI elements into the corresponding variables
 */
public void readGuiElements(){
  sampRate=Integer.valueOf(et_sampRate.getText().toString());
  frequency=Long.valueOf(et_freq.getText().toString());
  filename=et_filename.getText().toString();
  vgaGain=sb_vgaGain.getProgress();
  lnaGain=sb_vgaGain.getProgress();
  amp=cb_amp.isChecked();
  antennaPower=cb_antenna.isChecked();
}","/** 
 * Will read the values from the GUI elements into the corresponding variables
 */
public void readGuiElements(){
  sampRate=Integer.valueOf(et_sampRate.getText().toString());
  frequency=Long.valueOf(et_freq.getText().toString());
  filename=et_filename.getText().toString();
  vgaGain=sb_vgaGain.getProgress();
  lnaGain=sb_lnaGain.getProgress();
  amp=cb_amp.isChecked();
  antennaPower=cb_antenna.isChecked();
}"
57724,"/** 
 * @param items List that contains the items to show
 * @param builder Builder that create the Renderers
 */
public RendererAdapter(List<Renderable> items,RendererBuilder builder){
  this.items=items;
  if (items == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.builder=builder;
  if (builder == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","/** 
 * @param items List that contains the items to show
 * @param builder Builder that create the Renderers
 */
public RendererAdapter(List<? extends Renderable> items,RendererBuilder builder){
  this.items=(List<Renderable>)items;
  if (items == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.builder=builder;
  if (builder == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}"
57725,"private Solution solve(float initial,float velocity){
  float cmk=c * c - 4 * m * k;
  if (cmk >= 0) {
    final float r1=(-c - (float)Math.sqrt(cmk)) / (2 * m);
    final float r2=(-c + (float)Math.sqrt(cmk)) / (2 * m);
    final float c2=(velocity - r1 * initial) / (r2 - r1);
    final float c1=initial - c2;
    return new Solution(){
      @Override public float x(      float t){
        return (float)(c1 * Math.pow(Math.E,r1 * t) + c2 * Math.pow(Math.E,r2 * t));
      }
      @Override public float dx(      float t){
        return (float)(c1 * r1 * Math.pow(Math.E,r1 * t) + c2 * r2 * Math.pow(Math.E,r2 * t));
      }
    }
;
  }
 else {
    final float w=(float)Math.sqrt(4 * m * k - c * c) / (2 * m);
    final float r=-(c / 2 * m);
    final float c1=initial;
    final float c2=(velocity - r * initial) / w;
    return new Solution(){
      @Override public float x(      float t){
        return (float)(Math.pow(Math.E,r * t) * (c1 * Math.cos(w * t) + c2 * Math.sin(w * t)));
      }
      @Override public float dx(      float t){
        float power=(float)Math.pow(Math.E,r * t);
        float cos=(float)Math.cos(w * t);
        float sin=(float)Math.sin(w * t);
        return power * (c2 * w * cos - c1 * w * sin) + r * power * (c2 * sin + c1 * cos);
      }
    }
;
  }
}","private Solution solve(float initial,float velocity){
  float cmk=c * c - 4 * m * k;
  if (cmk == 0) {
    final float r=-c / (2 * m);
    final float c1=initial;
    final float c2=velocity / (r * initial);
    return new Solution(){
      @Override public float x(      float t){
        return (float)((c1 + c2 * t) * Math.pow(Math.E,r * t));
      }
      @Override public float dx(      float t){
        float power=(float)Math.pow(Math.E,r * t);
        return (float)(r * (c1 + c2 * t) * power + c2 * power);
      }
    }
;
  }
 else   if (cmk > 0) {
    final float r1=(-c - (float)Math.sqrt(cmk)) / (2 * m);
    final float r2=(-c + (float)Math.sqrt(cmk)) / (2 * m);
    final float c2=(velocity - r1 * initial) / (r2 - r1);
    final float c1=initial - c2;
    return new Solution(){
      @Override public float x(      float t){
        return (float)(c1 * Math.pow(Math.E,r1 * t) + c2 * Math.pow(Math.E,r2 * t));
      }
      @Override public float dx(      float t){
        return (float)(c1 * r1 * Math.pow(Math.E,r1 * t) + c2 * r2 * Math.pow(Math.E,r2 * t));
      }
    }
;
  }
 else {
    final float w=(float)Math.sqrt(4 * m * k - c * c) / (2 * m);
    final float r=-(c / 2 * m);
    final float c1=initial;
    final float c2=(velocity - r * initial) / w;
    return new Solution(){
      @Override public float x(      float t){
        return (float)(Math.pow(Math.E,r * t) * (c1 * Math.cos(w * t) + c2 * Math.sin(w * t)));
      }
      @Override public float dx(      float t){
        float power=(float)Math.pow(Math.E,r * t);
        float cos=(float)Math.cos(w * t);
        float sin=(float)Math.sin(w * t);
        return power * (c2 * w * cos - c1 * w * sin) + r * power * (c2 * sin + c1 * cos);
      }
    }
;
  }
}"
57726,"public static void info(String header,Object... msg){
  ArrayList<Object> list=new ArrayList<Object>();
  for (  Object object : msg) {
    if (object.getClass() == ArrayList.class) {
      ArrayList<Object> subList=(ArrayList<Object>)object;
      for (      Object subObject : subList) {
        list.add(subObject);
      }
    }
 else {
      list.add(object);
    }
  }
  msg=list.toArray();
  if (debugging == true) {
    String dText=""String_Node_Str"";
    if (header != null && header != ""String_Node_Str"") {
      dText+=""String_Node_Str"" + header.toUpperCase() + ""String_Node_Str"";
    }
    for (int i=0; i < msg.length; i++) {
      if (i != msg.length - 1) {
        dText+=msg[i] + ""String_Node_Str"";
      }
 else {
        dText+=msg[i];
        if (header != null && header != ""String_Node_Str"") {
          dText+=""String_Node_Str"";
        }
      }
    }
    System.out.println(dText);
  }
  if (logging == true) {
    String lText=""String_Node_Str"";
    if (header != null && header != ""String_Node_Str"") {
      lText+=header.toUpperCase();
    }
    for (int i=0; i < msg.length; i++) {
      if (i != msg.length - 1) {
        lText+=""String_Node_Str"" + msg[i];
      }
 else {
        lText+=""String_Node_Str"" + msg[i] + ""String_Node_Str"";
      }
    }
    logger.log(Level.INFO,lText);
  }
}","public static void info(String header,Object... msg){
  ArrayList<Object> list=new ArrayList<Object>();
  for (  Object object : msg) {
    if (object.getClass() == ArrayList.class) {
      ArrayList<Object> subList=(ArrayList<Object>)object;
      for (      Object subObject : subList) {
        list.add(subObject);
      }
    }
 else {
      list.add(object);
    }
  }
  msg=list.toArray();
  if (debugging == true) {
    String dText=""String_Node_Str"";
    if (header != null && header != ""String_Node_Str"") {
      dText+=""String_Node_Str"" + header.toUpperCase() + ""String_Node_Str"";
      if (msg.length == 0) {
        dText+=""String_Node_Str"";
      }
    }
    for (int i=0; i < msg.length; i++) {
      if (i != msg.length - 1) {
        dText+=msg[i] + ""String_Node_Str"";
      }
 else {
        dText+=msg[i];
        if (header != null && header != ""String_Node_Str"") {
          dText+=""String_Node_Str"";
        }
      }
    }
    System.out.println(dText);
  }
  if (logging == true) {
    String lText=""String_Node_Str"";
    if (header != null && header != ""String_Node_Str"") {
      lText+=header.toUpperCase();
      if (msg.length == 0) {
        lText+=""String_Node_Str"";
      }
    }
    for (int i=0; i < msg.length; i++) {
      if (i != msg.length - 1) {
        lText+=""String_Node_Str"" + msg[i];
      }
 else {
        lText+=""String_Node_Str"" + msg[i] + ""String_Node_Str"";
      }
    }
    logger.log(Level.INFO,lText);
  }
}"
57727,"public void startImmersiveProcess() throws Exception {
  Main.ui.button_Off.setEnabled(false);
  Main.ui.button_On.setEnabled(false);
  Main.ui.button_Stop.setEnabled(true);
  Main.ui.button_Start.setEnabled(false);
  Main.ui.button_Once.setEnabled(false);
  for (  HLight light : HBridge.lights) {
    light.storeLightColor();
  }
  captureLoop=new Timer();
  TimerTask task=new TimerTask(){
    public void run(){
      try {
        ImmersiveProcess.execute();
      }
 catch (      Exception e) {
        Debug.exception(e);
      }
    }
  }
;
  captureLoop.scheduleAtFixedRate(task,0,300);
}","public void startImmersiveProcess() throws Exception {
  Main.ui.button_Off.setEnabled(false);
  Main.ui.button_On.setEnabled(false);
  Main.ui.button_Stop.setEnabled(true);
  Main.ui.button_Start.setEnabled(false);
  Main.ui.button_Once.setEnabled(false);
  immersiveProcessIsActive=true;
  for (  HLight light : HBridge.lights) {
    light.storeLightColor();
  }
  captureLoop=new Timer();
  TimerTask task=new TimerTask(){
    public void run(){
      try {
        ImmersiveProcess.execute();
      }
 catch (      Exception e) {
        Debug.exception(e);
      }
    }
  }
;
  captureLoop.scheduleAtFixedRate(task,0,300);
}"
57728,"public void stopImmersiveProcess() throws Exception {
  captureLoop.cancel();
  captureLoop.purge();
  Main.ui.setupOnOffButton();
  Main.ui.button_Stop.setEnabled(false);
  Main.ui.button_Start.setEnabled(true);
  Main.ui.button_Once.setEnabled(true);
  Thread.sleep(250);
  ImmersiveProcess.setStandbyOutput();
  if (Settings.getBoolean(""String_Node_Str"")) {
    Thread.sleep(750);
    for (    HLight light : HBridge.lights) {
      light.restoreLightColor();
    }
  }
}","public void stopImmersiveProcess() throws Exception {
  captureLoop.cancel();
  captureLoop.purge();
  immersiveProcessIsActive=false;
  Main.ui.setupOnOffButton();
  Main.ui.button_Stop.setEnabled(false);
  Main.ui.button_Start.setEnabled(true);
  Main.ui.button_Once.setEnabled(true);
  Thread.sleep(250);
  ImmersiveProcess.setStandbyOutput();
  if (Settings.getBoolean(""String_Node_Str"")) {
    Thread.sleep(750);
    for (    HLight light : HBridge.lights) {
      light.restoreLightColor();
    }
  }
}"
57729,"public void setupOnOffButton() throws Exception {
  boolean lightOn=false;
  boolean lightOff=false;
  for (  HLight light : HBridge.lights) {
    if (light.isOn() && Settings.Light.getActive(light.uniqueid)) {
      lightOn=true;
    }
 else     if (!light.isOn() && Settings.Light.getActive(light.uniqueid)) {
      lightOff=true;
    }
  }
  if (lightOn && lightOff) {
    button_On.setEnabled(true);
    button_Off.setEnabled(true);
  }
 else   if (lightOn) {
    button_On.setEnabled(false);
    button_Off.setEnabled(true);
  }
 else   if (lightOff) {
    button_On.setEnabled(true);
    button_Off.setEnabled(false);
  }
}","public void setupOnOffButton() throws Exception {
  if (!Main.hueControl.immersiveProcessIsActive) {
    boolean lightOn=false;
    boolean lightOff=false;
    for (    HLight light : HBridge.lights) {
      if (light.isOn() && Settings.Light.getActive(light.uniqueid)) {
        lightOn=true;
      }
 else       if (!light.isOn() && Settings.Light.getActive(light.uniqueid)) {
        lightOff=true;
      }
    }
    if (lightOn && lightOff) {
      button_On.setEnabled(true);
      button_Off.setEnabled(true);
    }
 else     if (lightOn) {
      button_On.setEnabled(false);
      button_Off.setEnabled(true);
    }
 else     if (lightOff) {
      button_On.setEnabled(true);
      button_Off.setEnabled(false);
    }
  }
}"
57730,"private static void fastConnect() throws Exception {
  Debug.info(null,""String_Node_Str"");
  JsonObject response=HRequest.GET(""String_Node_Str"" + internalipaddress + ""String_Node_Str""+ username+ ""String_Node_Str"");
  if (HRequest.responseCheck(response) == ""String_Node_Str"") {
    Debug.info(null,""String_Node_Str"");
    debug();
    getLights();
    Main.ui.loadMainInterface();
  }
 else {
    Debug.info(null,""String_Node_Str"");
    newConnect();
  }
}","private static void fastConnect() throws Exception {
  Debug.info(null,""String_Node_Str"");
  JsonObject response=HRequest.GET(""String_Node_Str"" + internalipaddress + ""String_Node_Str""+ username);
  if (HRequest.responseCheck(response) == ""String_Node_Str"") {
    Debug.info(null,""String_Node_Str"");
    debug();
    getLights();
    Main.ui.loadMainInterface();
  }
 else {
    Debug.info(null,""String_Node_Str"");
    newConnect();
  }
}"
57731,"public static void debug() throws Exception {
  JsonObject response=HRequest.GET(""String_Node_Str"" + internalipaddress + ""String_Node_Str""+ username+ ""String_Node_Str"");
  Debug.info(""String_Node_Str"",""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + response.get(""String_Node_Str"").getAsString());
}","public static void debug() throws Exception {
  JsonObject response=HRequest.GET(""String_Node_Str"" + internalipaddress + ""String_Node_Str""+ username+ ""String_Node_Str"");
  Debug.info(""String_Node_Str"",""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + response.get(""String_Node_Str"").getAsString(),""String_Node_Str"" + response.get(""String_Node_Str"").getAsString());
}"
57732,"private static void fastConnect() throws Exception {
  Debug.info(null,""String_Node_Str"");
  JsonObject response=HRequest.GET(""String_Node_Str"" + internalipaddress + ""String_Node_Str""+ username+ ""String_Node_Str"");
  if (HRequest.responseCheck(response) == ""String_Node_Str"") {
    name=response.get(""String_Node_Str"").getAsString();
    macaddress=response.get(""String_Node_Str"").getAsString();
    Debug.info(null,""String_Node_Str"");
    debug();
    getLights();
    Main.ui.loadMainInterface();
  }
 else {
    newConnect();
  }
}","private static void fastConnect() throws Exception {
  Debug.info(null,""String_Node_Str"");
  JsonObject response=HRequest.GET(""String_Node_Str"" + internalipaddress + ""String_Node_Str""+ username+ ""String_Node_Str"");
  if (HRequest.responseCheck(response) == ""String_Node_Str"") {
    Debug.info(null,""String_Node_Str"");
    debug();
    getLights();
    Main.ui.loadMainInterface();
  }
 else {
    newConnect();
  }
}"
57733,"private static void newConnect() throws Exception {
  Debug.info(null,""String_Node_Str"");
  Main.ui.loadConnectionInterface();
  Main.ui.setConnectState(1);
  final Timer timer=new Timer();
  TimerTask addUserLoop=new TimerTask(){
    int tries=0;
    public void run(){
      try {
        JsonObject response=HRequest.GET(""String_Node_Str"");
        if (response != null) {
          timer.cancel();
          timer.purge();
          name=response.get(""String_Node_Str"").getAsString();
          internalipaddress=response.get(""String_Node_Str"").getAsString();
          macaddress=response.get(""String_Node_Str"").getAsString();
          Settings.Bridge.setInternalipaddress(internalipaddress);
          login();
        }
      }
 catch (      Exception e) {
        Debug.exception(e);
      }
      if (tries > 6) {
        try {
          timer.cancel();
          timer.purge();
          Main.ui.setConnectState(4);
          Debug.info(null,""String_Node_Str"");
        }
 catch (        Exception e) {
          Debug.exception(e);
        }
      }
      tries++;
    }
  }
;
  timer.scheduleAtFixedRate(addUserLoop,0,1500);
}","private static void newConnect() throws Exception {
  Debug.info(null,""String_Node_Str"");
  Main.ui.loadConnectionInterface();
  Main.ui.setConnectState(1);
  final Timer timer=new Timer();
  TimerTask addUserLoop=new TimerTask(){
    int tries=0;
    public void run(){
      try {
        JsonObject response=HRequest.GET(""String_Node_Str"");
        if (response != null) {
          timer.cancel();
          timer.purge();
          internalipaddress=response.get(""String_Node_Str"").getAsString();
          Settings.Bridge.setInternalipaddress(internalipaddress);
          login();
        }
      }
 catch (      Exception e) {
        Debug.exception(e);
      }
      if (tries > 6) {
        try {
          timer.cancel();
          timer.purge();
          Main.ui.setConnectState(4);
          Debug.info(null,""String_Node_Str"");
        }
 catch (        Exception e) {
          Debug.exception(e);
        }
      }
      tries++;
    }
  }
;
  timer.scheduleAtFixedRate(addUserLoop,0,1500);
}"
57734,"@Override public void onClick(View view){
  if (view == buttonJiami) {
    String mingwen=editMing.getText().toString();
    if (mingwen == null) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] mingData=mingwen.getBytes();
    String miwen=""String_Node_Str"";
    try {
      miwen=base64.encryptBASE64(mingData);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    editMi.setText(miwen);
  }
 else   if (view == buttonJiemi) {
    String miwen=editMi.getText().toString();
    if (miwen == null) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] mingData=null;
    try {
      mingData=base64.decryptBASE64(miwen);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    String mingwen=new String(mingData);
    editMing.setText(mingwen);
  }
}","@Override public void onClick(View view){
  if (view == buttonJiami) {
    String mingwen=editMing.getText().toString();
    if (mingwen.equals(""String_Node_Str"")) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] mingData=mingwen.getBytes();
    String miwen=""String_Node_Str"";
    try {
      miwen=base64.encryptBASE64(mingData);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    editMi.setText(miwen);
  }
 else   if (view == buttonJiemi) {
    String miwen=editMi.getText().toString();
    if (miwen.equals(""String_Node_Str"")) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] mingData=null;
    try {
      mingData=base64.decryptBASE64(miwen);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    String mingwen=new String(mingData);
    editMing.setText(mingwen);
  }
}"
57735,"@Override public void onClick(View view){
  if (view == jiamiButton) {
    String inputStr=mingEdit.getText().toString();
    if (inputStr == null) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    String inputKey=miyaoEdit.getText().toString();
    if (inputKey == null) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] inputData=inputStr.getBytes();
    byte[] outputData=new byte[0];
    try {
      outputData=hmac.encryptHMAC(inputData,inputKey,HmacMthod);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    BigInteger hmacData=new BigInteger(1,outputData);
    miEdit.setText(hmacData.toString(16));
  }
}","@Override public void onClick(View view){
  if (view == jiamiButton) {
    String inputStr=mingEdit.getText().toString();
    if (inputStr.equals(""String_Node_Str"")) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    String inputKey=miyaoEdit.getText().toString();
    if (inputKey.equals(""String_Node_Str"")) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] inputData=inputStr.getBytes();
    byte[] outputData=new byte[0];
    try {
      outputData=hmac.encryptHMAC(inputData,inputKey,HmacMthod);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    BigInteger hmacData=new BigInteger(1,outputData);
    miEdit.setText(hmacData.toString(16));
  }
}"
57736,"@Override public void onClick(View view){
  if (view == encryptButton) {
    String mingwen=mingEdit.getText().toString();
    if (mingwen == null) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] mingData=mingwen.getBytes();
    BigInteger md5Data=null;
    try {
      md5Data=new BigInteger(1,md5.encryptMD5(mingData));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    String md5Str=md5Data.toString(16);
    if (md5Str.length() < 32) {
      md5Str=0 + md5Str;
    }
    miEdit.setText(md5Str);
  }
}","@Override public void onClick(View view){
  if (view == encryptButton) {
    String mingwen=mingEdit.getText().toString();
    if (mingwen.equals(""String_Node_Str"")) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] mingData=mingwen.getBytes();
    BigInteger md5Data=null;
    try {
      md5Data=new BigInteger(1,md5.encryptMD5(mingData));
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    String md5Str=md5Data.toString(16);
    if (md5Str.length() < 32) {
      md5Str=0 + md5Str;
    }
    miEdit.setText(md5Str);
  }
}"
57737,"/** 
 * 实现接口申明的方法。
 * @param position :the position of item in drawer
 */
@Override public void onNavigationDrawerItemSelected(int position){
  FragmentManager fragmentManager=getFragmentManager();
switch (position) {
case 0:
    fragmentManager.beginTransaction().replace(R.id.container,Base64Fragment.newInstance(position + 1)).commit();
  break;
case 1:
fragmentManager.beginTransaction().replace(R.id.container,MD5Fragment.newInstance(position + 1)).commit();
break;
case 2:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 3:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 4:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 5:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 6:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 7:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 8:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 9:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 10:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
default :
fragmentManager.beginTransaction().replace(R.id.container,PlaceholderFragment.newInstance(position + 1)).commit();
break;
}
}","/** 
 * 实现接口申明的方法。
 * @param position :the position of item in drawer
 */
@Override public void onNavigationDrawerItemSelected(int position){
  FragmentManager fragmentManager=getFragmentManager();
switch (position) {
case 0:
    fragmentManager.beginTransaction().replace(R.id.container,Base64Fragment.newInstance(position + 1)).commit();
  break;
case 1:
fragmentManager.beginTransaction().replace(R.id.container,MD5Fragment.newInstance(position + 1)).commit();
break;
case 2:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 3:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 4:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 5:
fragmentManager.beginTransaction().replace(R.id.container,SHAFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 6:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 7:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 8:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 9:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 10:
fragmentManager.beginTransaction().replace(R.id.container,HmacFragment.newInstance(position + 1,""String_Node_Str"")).commit();
break;
case 11:
fragmentManager.beginTransaction().replace(R.id.container,DESFragment.newInstance(position + 1)).commit();
break;
default :
fragmentManager.beginTransaction().replace(R.id.container,PlaceholderFragment.newInstance(position + 1)).commit();
break;
}
}"
57738,"public void onSectionAttached(int number){
switch (number) {
case 1:
    mTitle=getString(R.string.title_section1);
  break;
case 2:
mTitle=getString(R.string.title_section2);
break;
case 3:
mTitle=getString(R.string.title_section3);
break;
case 4:
mTitle=getString(R.string.title_section5);
break;
case 5:
mTitle=getString(R.string.title_section6);
break;
case 6:
mTitle=getString(R.string.title_section7);
break;
case 7:
mTitle=getString(R.string.title_section8);
break;
case 8:
mTitle=getString(R.string.title_section9);
break;
case 9:
mTitle=getString(R.string.title_section11);
break;
case 10:
mTitle=getString(R.string.title_section12);
break;
case 11:
mTitle=getString(R.string.title_section13);
break;
}
}","public void onSectionAttached(int number){
switch (number) {
case 1:
    mTitle=getString(R.string.title_section1);
  break;
case 2:
mTitle=getString(R.string.title_section2);
break;
case 3:
mTitle=getString(R.string.title_section3);
break;
case 4:
mTitle=getString(R.string.title_section5);
break;
case 5:
mTitle=getString(R.string.title_section6);
break;
case 6:
mTitle=getString(R.string.title_section7);
break;
case 7:
mTitle=getString(R.string.title_section8);
break;
case 8:
mTitle=getString(R.string.title_section9);
break;
case 9:
mTitle=getString(R.string.title_section11);
break;
case 10:
mTitle=getString(R.string.title_section12);
break;
case 11:
mTitle=getString(R.string.title_section13);
break;
case 12:
mTitle=""String_Node_Str"";
break;
}
}"
57739,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  mDrawerListView=(ListView)inflater.inflate(R.layout.fragment_navigation_drawer,container,false);
  mDrawerListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      selectItem(position);
    }
  }
);
  mDrawerListView.setAdapter(new ArrayAdapter<String>(getActionBar().getThemedContext(),android.R.layout.simple_list_item_activated_1,android.R.id.text1,new String[]{getString(R.string.title_section1),getString(R.string.title_section2),getString(R.string.title_section3),getString(R.string.title_section5),getString(R.string.title_section6),getString(R.string.title_section7),getString(R.string.title_section8),getString(R.string.title_section9),getString(R.string.title_section11),getString(R.string.title_section12),getString(R.string.title_section13)}));
  mDrawerListView.setItemChecked(mCurrentSelectedPosition,true);
  return mDrawerListView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  mDrawerListView=(ListView)inflater.inflate(R.layout.fragment_navigation_drawer,container,false);
  mDrawerListView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      selectItem(position);
    }
  }
);
  mDrawerListView.setAdapter(new ArrayAdapter<String>(getActionBar().getThemedContext(),android.R.layout.simple_list_item_activated_1,android.R.id.text1,new String[]{getString(R.string.title_section1),getString(R.string.title_section2),getString(R.string.title_section3),getString(R.string.title_section5),getString(R.string.title_section6),getString(R.string.title_section7),getString(R.string.title_section8),getString(R.string.title_section9),getString(R.string.title_section11),getString(R.string.title_section12),getString(R.string.title_section13),""String_Node_Str""}));
  mDrawerListView.setItemChecked(mCurrentSelectedPosition,true);
  return mDrawerListView;
}"
57740,"@Override public void onClick(View view){
  if (view == encryptButton) {
    String inputStr=mingEdit.getText().toString();
    if (inputStr == null) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] inputData=inputStr.getBytes();
    byte[] outputData=new byte[0];
    try {
      outputData=sha.encryptSHA(inputData,shaNumber);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    BigInteger shaData=new BigInteger(1,outputData);
    miEdit.setText(shaData.toString(16));
  }
}","@Override public void onClick(View view){
  if (view == encryptButton) {
    String inputStr=mingEdit.getText().toString();
    if (inputStr.equals(""String_Node_Str"")) {
      Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      return;
    }
    byte[] inputData=inputStr.getBytes();
    byte[] outputData=new byte[0];
    try {
      outputData=sha.encryptSHA(inputData,shaNumber);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    BigInteger shaData=new BigInteger(1,outputData);
    miEdit.setText(shaData.toString(16));
  }
}"
57741,"/** 
 * Add a custom configured serialiser
 * @param serialiser
 * @return
 */
public CsvDataExtractor withSerialiser(CsvSerializer serialiser){
  super.serialiser=serialiser;
  return this;
}","/** 
 * Add a custom configured serialiser
 * @param serialiser
 * @return
 */
public CsvDataExtractor withSerialiser(CsvSerializer serialiser){
  this.serialiser=serialiser;
  super.serialiser=serialiser;
  return this;
}"
57742,"public CsvDataExtractor(List<Integer> labelIndicies,String labelAttributeAlias,int dateValueIndex,String dateAttributeAlias,String fieldDelimiter,CsvSerializer serialiser){
  super.labelIndicies=labelIndicies;
  super.labelAttributeAlias=labelAttributeAlias;
  super.dateValueIndex=dateValueIndex;
  super.dateAttributeAlias=dateAttributeAlias;
  this.serialiser=serialiser;
}","public CsvDataExtractor(List<Integer> labelIndicies,String labelAttributeAlias,int dateValueIndex,String dateAttributeAlias,String fieldDelimiter,CsvSerializer serialiser){
  super.labelIndicies=labelIndicies;
  super.labelAttributeAlias=labelAttributeAlias;
  super.dateValueIndex=dateValueIndex;
  super.dateAttributeAlias=dateAttributeAlias;
  this.serialiser=serialiser;
  super.serialiser=serialiser;
}"
57743,"public String expandRoll(MapToolVariableResolver resolver,Token tokenInContext,String roll) throws ParserException {
  try {
    Result result=parseExpression(resolver,tokenInContext,roll);
    StringBuilder sb=new StringBuilder();
    if (result.getDetailExpression().equals(result.getValue().toString())) {
      sb.append(result.getDetailExpression());
    }
 else {
      sb.append(result.getDetailExpression()).append(""String_Node_Str"").append(result.getValue());
    }
    return sb.toString();
  }
 catch (  AbortFunctionException ae) {
    throw ae;
  }
catch (  AssertFunctionException afe) {
    throw afe;
  }
catch (  ParserException e) {
    return I18N.getText(""String_Node_Str"",roll);
  }
}","public String expandRoll(MapToolVariableResolver resolver,Token tokenInContext,String roll) throws ParserException {
  try {
    Result result=parseExpression(resolver,tokenInContext,roll);
    StringBuilder sb=new StringBuilder();
    if (result.getDetailExpression().equals(result.getValue().toString())) {
      sb.append(result.getDetailExpression());
    }
 else {
      sb.append(result.getDetailExpression()).append(""String_Node_Str"").append(result.getValue());
    }
    return sb.toString();
  }
 catch (  AbortFunctionException ae) {
    throw ae;
  }
catch (  AssertFunctionException afe) {
    throw afe;
  }
catch (  ParserException e) {
    throw e;
  }
catch (  Exception e) {
    return I18N.getText(""String_Node_Str"",roll);
  }
}"
57744,"private MathFunctions(){
  super(1,UNLIMITED_PARAMETERS,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","private MathFunctions(){
  super(0,UNLIMITED_PARAMETERS,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
57745,"private List<BigDecimal> getNumericParams(List<Object> param,int minParams,int maxParams,String functionName) throws ParserException {
  if (minParams == minParams) {
    if (param.size() != minParams) {
      throw new ParserException(I18N.getText(""String_Node_Str"",functionName,minParams,param.size()));
    }
  }
 else   if (param.size() < minParams) {
    throw new ParserException(I18N.getText(""String_Node_Str"",functionName,minParams,param.size()));
  }
 else   if (maxParams != UNLIMITED_PARAMETERS && param.size() > maxParams) {
    throw new ParserException(I18N.getText(""String_Node_Str"",functionName,maxParams,param.size()));
  }
  int i=0;
  List<BigDecimal> outVals=new ArrayList<>();
  for (  Object o : param) {
    if (o instanceof BigDecimal) {
      outVals.add((BigDecimal)o);
    }
 else {
      throw new ParserException(I18N.getText(""String_Node_Str"",functionName,i,o.toString()));
    }
  }
  return outVals;
}","private List<BigDecimal> getNumericParams(List<Object> param,int minParams,int maxParams,String functionName) throws ParserException {
  if (minParams == maxParams) {
    if (param.size() != minParams) {
      throw new ParserException(I18N.getText(""String_Node_Str"",functionName,minParams,param.size()));
    }
  }
 else   if (param.size() < minParams) {
    throw new ParserException(I18N.getText(""String_Node_Str"",functionName,minParams,param.size()));
  }
 else   if (maxParams != UNLIMITED_PARAMETERS && param.size() > maxParams) {
    throw new ParserException(I18N.getText(""String_Node_Str"",functionName,maxParams,param.size()));
  }
  int i=0;
  List<BigDecimal> outVals=new ArrayList<>();
  for (  Object o : param) {
    if (o instanceof BigDecimal) {
      outVals.add((BigDecimal)o);
    }
 else {
      throw new ParserException(I18N.getText(""String_Node_Str"",functionName,i,o.toString()));
    }
  }
  return outVals;
}"
57746,"@Override public Object childEvaluate(Parser parser,String function,List<Object> params) throws ParserException {
  if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkNumberOfParameters(""String_Node_Str"",params,0,1);
    String delim=""String_Node_Str"";
    if (params.size() > 0) {
      delim=params.get(0).toString();
    }
    if (""String_Node_Str"".equalsIgnoreCase(delim))     return JSONArray.fromObject(getTableList(MapTool.getPlayer().isGM()));
    return StringUtils.join(getTableList(MapTool.getPlayer().isGM()),delim);
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getVisible() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String visible=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setVisible(AbstractTokenAccessorFunction.getBooleanValue(visible));
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return lookupTable.getVisible() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getAllowLookup() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String access=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setAllowLookup(AbstractTokenAccessorFunction.getBooleanValue(access));
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return lookupTable.getAllowLookup() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getRoll();
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String roll=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setRoll(roll);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return lookupTable.getRoll();
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.clearEntries();
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,4,5);
    String name=params.get(0).toString();
    String min=params.get(1).toString();
    String max=params.get(2).toString();
    String value=params.get(3).toString();
    MD5Key asset=null;
    if (params.size() > 4) {
      asset=new MD5Key(params.get(4).toString());
    }
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.addEntry(Integer.valueOf(min),Integer.valueOf(max),value,asset);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String roll=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    LookupEntry entry=lookupTable.getLookup(roll);
    if (entry != null) {
      List<LookupEntry> oldlist=new ArrayList<LookupEntry>(lookupTable.getEntryList());
      lookupTable.clearEntries();
      for (      LookupEntry e : oldlist)       if (e != entry)       lookupTable.addEntry(e.getMin(),e.getMax(),e.getValue(),e.getImageId());
    }
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,3,4);
    String name=params.get(0).toString();
    String visible=params.get(1).toString();
    String lookups=params.get(2).toString();
    MD5Key asset=null;
    if (params.size() > 3) {
      asset=new MD5Key(params.get(3).toString());
    }
    LookupTable lookupTable=new LookupTable();
    lookupTable.setName(name);
    lookupTable.setVisible(AbstractTokenAccessorFunction.getBooleanValue(visible));
    lookupTable.setAllowLookup(AbstractTokenAccessorFunction.getBooleanValue(lookups));
    if (asset != null)     lookupTable.setTableImage(asset);
    MapTool.getCampaign().getLookupTableMap().put(name,lookupTable);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    if (lookupTable != null) {
      MapTool.getCampaign().getLookupTableMap().remove(name);
      MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    }
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getTableImage();
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    MD5Key asset=new MD5Key(params.get(1).toString());
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setTableImage(asset);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String oldName=params.get(0).toString();
    String newName=params.get(1).toString();
    LookupTable oldTable=getMaptoolTable(oldName,function);
    if (oldTable != null) {
      LookupTable newTable=new LookupTable(oldTable);
      newTable.setName(newName);
      MapTool.getCampaign().getLookupTableMap().put(newName,newTable);
      MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    }
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,3,3);
    String name=params.get(0).toString();
    String roll=params.get(1).toString();
    String result=params.get(2).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    LookupEntry entry=lookupTable.getLookup(roll);
    if (entry == null)     return 0;
    int rollInt=Integer.valueOf(roll);
    if (rollInt < entry.getMin() || rollInt > entry.getMax())     return 0;
    List<LookupEntry> oldlist=new ArrayList<LookupEntry>(lookupTable.getEntryList());
    lookupTable.clearEntries();
    for (    LookupEntry e : oldlist)     if (e != entry)     lookupTable.addEntry(e.getMin(),e.getMax(),e.getValue(),e.getImageId());
 else     lookupTable.addEntry(e.getMin(),e.getMax(),result,e.getImageId());
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return 1;
  }
 else {
    checkNumberOfParameters(function,params,1,2);
    String name=params.get(0).toString();
    String roll=null;
    if (params.size() > 1) {
      roll=params.get(1).toString().length() == 0 ? null : params.get(1).toString();
    }
    LookupTable lookupTable=MapTool.getCampaign().getLookupTableMap().get(name);
    if (!MapTool.getPlayer().isGM() && !lookupTable.getAllowLookup()) {
      if (lookupTable.getVisible()) {
        throw new ParserException(function + ""String_Node_Str"" + I18N.getText(""String_Node_Str"")+ name);
      }
 else {
        throw new ParserException(function + ""String_Node_Str"" + I18N.getText(""String_Node_Str"")+ ""String_Node_Str""+ name);
      }
    }
    if (lookupTable == null) {
      throw new ParserException(I18N.getText(""String_Node_Str"",function,name));
    }
    LookupEntry result=lookupTable.getLookup(roll);
    if (function.equals(""String_Node_Str"") || function.equals(""String_Node_Str"")) {
      String val=result.getValue();
      try {
        BigDecimal bival=new BigDecimal(val);
        return bival;
      }
 catch (      NumberFormatException nfe) {
        return val;
      }
    }
 else {
      if (result.getImageId() == null) {
        throw new ParserException(I18N.getText(""String_Node_Str"",function,name));
      }
      BigDecimal size=null;
      if (params.size() > 2) {
        if (params.get(2) instanceof BigDecimal) {
          size=(BigDecimal)params.get(2);
        }
 else {
          throw new ParserException(I18N.getText(""String_Node_Str"",function));
        }
      }
      StringBuilder assetId=new StringBuilder(""String_Node_Str"");
      assetId.append(result.getImageId().toString());
      if (size != null) {
        int i=Math.max(size.intValue(),1);
        assetId.append(""String_Node_Str"");
        assetId.append(i);
      }
      return assetId.toString();
    }
  }
}","@Override public Object childEvaluate(Parser parser,String function,List<Object> params) throws ParserException {
  if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkNumberOfParameters(""String_Node_Str"",params,0,1);
    String delim=""String_Node_Str"";
    if (params.size() > 0) {
      delim=params.get(0).toString();
    }
    if (""String_Node_Str"".equalsIgnoreCase(delim))     return JSONArray.fromObject(getTableList(MapTool.getPlayer().isGM()));
    return StringUtils.join(getTableList(MapTool.getPlayer().isGM()),delim);
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getVisible() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String visible=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setVisible(AbstractTokenAccessorFunction.getBooleanValue(visible));
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return lookupTable.getVisible() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getAllowLookup() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String access=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setAllowLookup(AbstractTokenAccessorFunction.getBooleanValue(access));
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return lookupTable.getAllowLookup() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getRoll();
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String roll=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setRoll(roll);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return lookupTable.getRoll();
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.clearEntries();
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,4,5);
    String name=params.get(0).toString();
    String min=params.get(1).toString();
    String max=params.get(2).toString();
    String value=params.get(3).toString();
    MD5Key asset=null;
    if (params.size() > 4) {
      asset=new MD5Key(params.get(4).toString());
    }
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.addEntry(Integer.valueOf(min),Integer.valueOf(max),value,asset);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    String roll=params.get(1).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    LookupEntry entry=lookupTable.getLookup(roll);
    if (entry != null) {
      List<LookupEntry> oldlist=new ArrayList<LookupEntry>(lookupTable.getEntryList());
      lookupTable.clearEntries();
      for (      LookupEntry e : oldlist)       if (e != entry)       lookupTable.addEntry(e.getMin(),e.getMax(),e.getValue(),e.getImageId());
    }
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,3,4);
    String name=params.get(0).toString();
    String visible=params.get(1).toString();
    String lookups=params.get(2).toString();
    MD5Key asset=null;
    if (params.size() > 3) {
      asset=new MD5Key(params.get(3).toString());
    }
    LookupTable lookupTable=new LookupTable();
    lookupTable.setName(name);
    lookupTable.setVisible(AbstractTokenAccessorFunction.getBooleanValue(visible));
    lookupTable.setAllowLookup(AbstractTokenAccessorFunction.getBooleanValue(lookups));
    if (asset != null)     lookupTable.setTableImage(asset);
    MapTool.getCampaign().getLookupTableMap().put(name,lookupTable);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    if (lookupTable != null) {
      MapTool.getCampaign().getLookupTableMap().remove(name);
      MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    }
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,1,1);
    String name=params.get(0).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    return lookupTable.getTableImage();
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String name=params.get(0).toString();
    MD5Key asset=new MD5Key(params.get(1).toString());
    LookupTable lookupTable=getMaptoolTable(name,function);
    lookupTable.setTableImage(asset);
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,2,2);
    String oldName=params.get(0).toString();
    String newName=params.get(1).toString();
    LookupTable oldTable=getMaptoolTable(oldName,function);
    if (oldTable != null) {
      LookupTable newTable=new LookupTable(oldTable);
      newTable.setName(newName);
      MapTool.getCampaign().getLookupTableMap().put(newName,newTable);
      MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    }
    return ""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equalsIgnoreCase(function)) {
    checkTrusted(function);
    checkNumberOfParameters(""String_Node_Str"",params,3,3);
    String name=params.get(0).toString();
    String roll=params.get(1).toString();
    String result=params.get(2).toString();
    LookupTable lookupTable=getMaptoolTable(name,function);
    LookupEntry entry=lookupTable.getLookup(roll);
    if (entry == null)     return 0;
    int rollInt=Integer.valueOf(roll);
    if (rollInt < entry.getMin() || rollInt > entry.getMax())     return 0;
    List<LookupEntry> oldlist=new ArrayList<LookupEntry>(lookupTable.getEntryList());
    lookupTable.clearEntries();
    for (    LookupEntry e : oldlist)     if (e != entry)     lookupTable.addEntry(e.getMin(),e.getMax(),e.getValue(),e.getImageId());
 else     lookupTable.addEntry(e.getMin(),e.getMax(),result,e.getImageId());
    MapTool.serverCommand().updateCampaign(MapTool.getCampaign().getCampaignProperties());
    return 1;
  }
 else {
    checkNumberOfParameters(function,params,1,3);
    String name=params.get(0).toString();
    String roll=null;
    if (params.size() > 1) {
      roll=params.get(1).toString().length() == 0 ? null : params.get(1).toString();
    }
    LookupTable lookupTable=MapTool.getCampaign().getLookupTableMap().get(name);
    if (!MapTool.getPlayer().isGM() && !lookupTable.getAllowLookup()) {
      if (lookupTable.getVisible()) {
        throw new ParserException(function + ""String_Node_Str"" + I18N.getText(""String_Node_Str"")+ name);
      }
 else {
        throw new ParserException(function + ""String_Node_Str"" + I18N.getText(""String_Node_Str"")+ ""String_Node_Str""+ name);
      }
    }
    if (lookupTable == null) {
      throw new ParserException(I18N.getText(""String_Node_Str"",function,name));
    }
    LookupEntry result=lookupTable.getLookup(roll);
    if (function.equals(""String_Node_Str"") || function.equals(""String_Node_Str"")) {
      String val=result.getValue();
      try {
        BigDecimal bival=new BigDecimal(val);
        return bival;
      }
 catch (      NumberFormatException nfe) {
        return val;
      }
    }
 else {
      if (result.getImageId() == null) {
        throw new ParserException(I18N.getText(""String_Node_Str"",function,name));
      }
      BigDecimal size=null;
      if (params.size() > 2) {
        if (params.get(2) instanceof BigDecimal) {
          size=(BigDecimal)params.get(2);
        }
 else {
          throw new ParserException(I18N.getText(""String_Node_Str"",function));
        }
      }
      StringBuilder assetId=new StringBuilder(""String_Node_Str"");
      assetId.append(result.getImageId().toString());
      if (size != null) {
        int i=Math.max(size.intValue(),1);
        assetId.append(""String_Node_Str"");
        assetId.append(i);
      }
      return assetId.toString();
    }
  }
}"
57747,"public void showDialog(){
  EventQueue.invokeLater(new Runnable(){
    public void run(){
      dialog=new GenericDialog(""String_Node_Str"",MapTool.getFrame(),NewTokenDialog.this){
        @Override protected void positionInitialView(){
          Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
          Dimension size=getSize();
          int x=centerX - size.width / 2;
          int y=centerY - size.height / 2;
          if (x < 0) {
            x=0;
          }
          if (y < 0) {
            y=0;
          }
          if (x + size.width > screenSize.width) {
            x=screenSize.width - size.width;
          }
          if (y + size.height > screenSize.height) {
            y=screenSize.height - size.height;
          }
          setLocation(x,y);
        }
      }
;
      bind(token);
      getRootPane().setDefaultButton(getOKButton());
      dialog.showDialog();
    }
  }
);
}","public void showDialog(){
  dialog=new GenericDialog(""String_Node_Str"",MapTool.getFrame(),this){
    @Override protected void positionInitialView(){
      Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
      Dimension size=getSize();
      int x=centerX - size.width / 2;
      int y=centerY - size.height / 2;
      if (x < 0) {
        x=0;
      }
      if (y < 0) {
        y=0;
      }
      if (x + size.width > screenSize.width) {
        x=screenSize.width - size.width;
      }
      if (y + size.height > screenSize.height) {
        y=screenSize.height - size.height;
      }
      setLocation(x,y);
    }
  }
;
  bind(token);
  getRootPane().setDefaultButton(getOKButton());
  dialog.showDialog();
}"
57748,"public void showDialog(){
  dialog=new GenericDialog(""String_Node_Str"",MapTool.getFrame(),this){
    @Override protected void positionInitialView(){
      Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
      Dimension size=getSize();
      int x=centerX - size.width / 2;
      int y=centerY - size.height / 2;
      if (x < 0) {
        x=0;
      }
      if (y < 0) {
        y=0;
      }
      if (x + size.width > screenSize.width) {
        x=screenSize.width - size.width;
      }
      if (y + size.height > screenSize.height) {
        y=screenSize.height - size.height;
      }
      setLocation(x,y);
    }
  }
;
  bind(token);
  getRootPane().setDefaultButton(getOKButton());
  dialog.showDialog();
}","public void showDialog(){
  EventQueue.invokeLater(new Runnable(){
    public void run(){
      dialog=new GenericDialog(""String_Node_Str"",MapTool.getFrame(),NewTokenDialog.this){
        @Override protected void positionInitialView(){
          Dimension screenSize=Toolkit.getDefaultToolkit().getScreenSize();
          Dimension size=getSize();
          int x=centerX - size.width / 2;
          int y=centerY - size.height / 2;
          if (x < 0) {
            x=0;
          }
          if (y < 0) {
            y=0;
          }
          if (x + size.width > screenSize.width) {
            x=screenSize.width - size.width;
          }
          if (y + size.height > screenSize.height) {
            y=screenSize.height - size.height;
          }
          setLocation(x,y);
        }
      }
;
      bind(token);
      getRootPane().setDefaultButton(getOKButton());
      dialog.showDialog();
    }
  }
);
}"
57749,"/** 
 * Returns a checkbox that indicates whether the filter field applies to <i>all</i> images in all libraries or just the currently selected image directory. Currently not implemented.
 * @return the checkbox component
 */
public JCheckBox getGlobalSearchField(){
  if (globalSearchField == null) {
    globalSearchField=new JCheckBox(""String_Node_Str"",false);
    globalSearchField.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent ev){
        updateFilter();
      }
    }
);
  }
  return globalSearchField;
}","/** 
 * Returns a checkbox that indicates whether the filter field applies to <i>all</i> images in all libraries or just the currently selected image directory. Currently not implemented.
 * @return the checkbox component
 */
private JCheckBox getGlobalSearchField(){
  if (globalSearchField == null) {
    globalSearchField=new JCheckBox(I18N.getText(""String_Node_Str""),false);
    globalSearchField.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent ev){
        updateFilter();
      }
    }
);
  }
  return globalSearchField;
}"
57750,"private synchronized void updateFilter(){
  if (updateFilterTimer == null) {
    updateFilterTimer=new Timer(500,new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        ImageFileImagePanelModel model=(ImageFileImagePanelModel)imagePanel.getModel();
        if (model == null) {
          return;
        }
        model.setFilter(getFilterTextField().getText());
        imagePanel.revalidate();
        imagePanel.repaint();
        updateFilterTimer.stop();
        updateFilterTimer=null;
      }
    }
);
    updateFilterTimer.start();
  }
 else {
    updateFilterTimer.restart();
  }
}","private synchronized void updateFilter(){
  if (updateFilterTimer == null) {
    updateFilterTimer=new Timer(500,new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        ImageFileImagePanelModel model=(ImageFileImagePanelModel)imagePanel.getModel();
        if (model == null) {
          return;
        }
        model.setGlobalSearch(getGlobalSearchField().isSelected());
        model.setFilter(getFilterTextField().getText());
        imagePanel.revalidate();
        imagePanel.repaint();
        updateFilterTimer.stop();
        updateFilterTimer=null;
      }
    }
);
    updateFilterTimer.start();
  }
 else {
    updateFilterTimer.restart();
  }
}"
57751,"public void actionPerformed(ActionEvent e){
  ImageFileImagePanelModel model=(ImageFileImagePanelModel)imagePanel.getModel();
  if (model == null) {
    return;
  }
  model.setFilter(getFilterTextField().getText());
  imagePanel.revalidate();
  imagePanel.repaint();
  updateFilterTimer.stop();
  updateFilterTimer=null;
}","public void actionPerformed(ActionEvent e){
  ImageFileImagePanelModel model=(ImageFileImagePanelModel)imagePanel.getModel();
  if (model == null) {
    return;
  }
  model.setGlobalSearch(getGlobalSearchField().isSelected());
  model.setFilter(getFilterTextField().getText());
  imagePanel.revalidate();
  imagePanel.repaint();
  updateFilterTimer.stop();
  updateFilterTimer=null;
}"
57752,"/** 
 * Creates the GUI for the bottom half of the splitpane that allows for finding assets within any of the repository locations (such as local directories).
 * @return
 */
private JPanel createFilterPanel(){
  JPanel panel=new JPanel(new BorderLayout());
  panel.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
  JPanel top=new JPanel(new BorderLayout());
  top.add(BorderLayout.WEST,new JLabel(""String_Node_Str"",FILTER_IMAGE,JLabel.LEFT));
  top.add(BorderLayout.CENTER,getFilterTextField());
  panel.add(BorderLayout.NORTH,top);
  return panel;
}","/** 
 * Creates the GUI for the bottom half of the splitpane that allows for finding assets within any of the repository locations (such as local directories).
 * @return
 */
private JPanel createFilterPanel(){
  JPanel panel=new JPanel(new BorderLayout());
  panel.setBorder(BorderFactory.createEmptyBorder(3,3,3,3));
  JPanel top=new JPanel(new BorderLayout());
  top.add(BorderLayout.WEST,new JLabel(""String_Node_Str"",FILTER_IMAGE,JLabel.LEFT));
  top.add(BorderLayout.CENTER,getFilterTextField());
  panel.add(BorderLayout.NORTH,top);
  panel.add(BorderLayout.SOUTH,getGlobalSearchField());
  return panel;
}"
57753,"private JSONObject getInitiativeDetails(){
  JSONObject json=new JSONObject();
  InitiativeList initiativeList=MapTool.getFrame().getCurrentZoneRenderer().getZone().getInitiativeList();
  List<net.rptools.maptool.model.InitiativeList.TokenInitiative> tokenInitList=initiativeList.getTokens();
  JSONArray tokArray=new JSONArray();
  int index=0;
  for (  InitiativeList.TokenInitiative token : tokenInitList) {
    if (InitiativeListModel.isTokenVisible(token.getToken(),initiativeList.isHideNPC())) {
      JSONObject tokJSon=new JSONObject();
      tokJSon.put(""String_Node_Str"",token.getToken().getId().toString());
      tokJSon.put(""String_Node_Str"",token.getToken().getName());
      tokJSon.put(""String_Node_Str"",token.isHolding());
      tokJSon.put(""String_Node_Str"",token.getState());
      tokJSon.put(""String_Node_Str"",index);
      tokJSon.put(""String_Node_Str"",AppUtil.playerOwns(token.getToken()));
      tokJSon.put(""String_Node_Str"",""String_Node_Str"");
      tokArray.add(tokJSon);
    }
    index++;
  }
  json.put(""String_Node_Str"",tokArray);
  json.put(""String_Node_Str"",initiativeList.getCurrent());
  json.put(""String_Node_Str"",initiativeList.getRound());
  json.put(""String_Node_Str"",canAdvanceInitiative());
  return json;
}","private JSONObject getInitiativeDetails(){
  JSONObject json=new JSONObject();
  InitiativeList initiativeList=MapTool.getFrame().getCurrentZoneRenderer().getZone().getInitiativeList();
  List<net.rptools.maptool.model.InitiativeList.TokenInitiative> tokenInitList=initiativeList.getTokens();
  JSONArray tokArray=new JSONArray();
  int index=0;
  for (  InitiativeList.TokenInitiative token : tokenInitList) {
    if (InitiativeListModel.isTokenVisible(token.getToken(),initiativeList.isHideNPC())) {
      JSONObject tokJSon=new JSONObject();
      tokJSon.put(""String_Node_Str"",token.getToken().getId().toString());
      tokJSon.put(""String_Node_Str"",token.getToken().getName());
      tokJSon.put(""String_Node_Str"",token.isHolding());
      tokJSon.put(""String_Node_Str"",token.getState());
      tokJSon.put(""String_Node_Str"",index);
      tokJSon.put(""String_Node_Str"",AppUtil.playerOwns(token.getToken()));
      tokArray.add(tokJSon);
    }
    index++;
  }
  json.put(""String_Node_Str"",tokArray);
  json.put(""String_Node_Str"",initiativeList.getCurrent());
  json.put(""String_Node_Str"",initiativeList.getRound());
  json.put(""String_Node_Str"",canAdvanceInitiative());
  return json;
}"
57754,"public Token findTokenFromId(String tokenId){
  final GUID id=new GUID(tokenId);
  final List<Token> tokenList=new ArrayList<>();
  List<ZoneRenderer> zrenderers=MapTool.getFrame().getZoneRenderers();
  for (  ZoneRenderer zr : zrenderers) {
    tokenList.addAll(zr.getZone().getTokensFiltered(new Zone.Filter(){
      public boolean matchToken(      Token t){
        return t.getId().equals(id);
      }
    }
));
    if (tokenList.size() > 0) {
      break;
    }
  }
  if (tokenList.size() > 0) {
    return tokenList.get(0);
  }
 else {
    return null;
  }
}","public Token findTokenFromId(String tokenId){
  System.out.println(""String_Node_Str"" + tokenId);
  final GUID id=new GUID(tokenId);
  final List<Token> tokenList=new ArrayList<>();
  List<ZoneRenderer> zrenderers=MapTool.getFrame().getZoneRenderers();
  for (  ZoneRenderer zr : zrenderers) {
    tokenList.addAll(zr.getZone().getTokensFiltered(new Zone.Filter(){
      public boolean matchToken(      Token t){
        return t.getId().equals(id);
      }
    }
));
    if (tokenList.size() > 0) {
      break;
    }
  }
  if (tokenList.size() > 0) {
    return tokenList.get(0);
  }
 else {
    return null;
  }
}"
57755,"public int doSuccessSolution(String md5){
  File permDir=new File(mContext.getFilesDir().getAbsoluteFile(),""String_Node_Str"");
  if (permDir.exists() == true) {
    File outFile=new File(permDir,md5);
    if (outFile.exists() == true) {
      System.load(outFile.getAbsolutePath());
      int nRet=jmain(0);
      junmain(getClass());
      return nRet;
    }
  }
  return Constants.ROOT_FAILED_SOLUTION_FILE_NOT_EXISTS;
}","public int doSuccessSolution(String md5){
  NativeHelper.copyNativeLib(mContext,""String_Node_Str"");
  String filePath=mContext.getFilesDir().getAbsoluteFile() + ""String_Node_Str"" + md5;
  File outFile=new File(filePath);
  if (outFile.exists() == true) {
    System.load(filePath);
    int nRet=jmain(0);
    junmain(getClass());
    return nRet;
  }
  return Constants.ROOT_FAILED_SOLUTION_FILE_NOT_EXISTS;
}"
57756,"public int doSolutionOnline(MainActivity activity){
  String str1=SystemProperties.get(""String_Node_Str"");
  if (TextUtils.isEmpty(str1))   str1=""String_Node_Str"";
  String str2=Build.MODEL;
  if (TextUtils.isEmpty(str2))   str2=""String_Node_Str"";
  String str3=""String_Node_Str"";
  if ((!TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""))) || (!TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""))))   str3=""String_Node_Str"";
  String str4=com.qihoo.permmgr.util.k.a(mContext);
  String str5=com.qihoo.permmgr.util.f.a(str4);
  if (TextUtils.isEmpty(str4))   str5=""String_Node_Str"";
  File localFile=new File(""String_Node_Str"");
  String[] arrayOfString=new String[2];
  arrayOfString[0]=""String_Node_Str"";
  arrayOfString[1]=""String_Node_Str"";
  String str6=com.qihoo.permmgr.util.b.a(localFile,arrayOfString);
  String str7=str6.split(""String_Node_Str"")[2];
  String str8=""String_Node_Str"" + URLEncoder.encode(str2) + ""String_Node_Str""+ URLEncoder.encode(str7)+ ""String_Node_Str""+ URLEncoder.encode(str1)+ ""String_Node_Str""+ URLEncoder.encode(str3);
  String url=""String_Node_Str"" + str8 + ""String_Node_Str""+ a.e+ ""String_Node_Str""+ URLEncoder.encode(str5)+ ""String_Node_Str""+ 1+ ""String_Node_Str"";
  try {
    HttpGet localHttpGet2=new HttpGet(url);
    HttpResponse localHttpResponse=new DefaultHttpClient().execute(localHttpGet2);
    int statusCode=localHttpResponse.getStatusLine().getStatusCode();
    String jsonData=AESUtils.b(EntityUtils.toString(localHttpResponse.getEntity()));
    JSONArray arr=new JSONArray(jsonData);
    byte[] bs=new byte[1024];
    int len;
    for (int i=0; i < arr.length(); i++) {
      JSONObject temp=(JSONObject)arr.get(i);
      String md5=temp.getString(""String_Node_Str"");
      String solution=temp.getString(""String_Node_Str"");
      activity.setStatus(""String_Node_Str"" + solution);
      URL sUrl=new URL(solution);
      URLConnection con=sUrl.openConnection();
      InputStream is=con.getInputStream();
      String md5FilePath=mContext.getFilesDir().getAbsoluteFile() + ""String_Node_Str"" + md5;
      OutputStream os=new FileOutputStream(md5FilePath);
      while ((len=is.read(bs)) != -1) {
        os.write(bs,0,len);
      }
      os.close();
      is.close();
      if (RootMan.getInstance(mContext).doRoot(md5FilePath) == Constants.ROOT_SUCCESS) {
        return Constants.ROOT_SUCCESS;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return Constants.NOTSUPPORT;
}","public int doSolutionOnline(MainActivity activity){
  String str1=SystemProperties.get(""String_Node_Str"");
  if (TextUtils.isEmpty(str1))   str1=""String_Node_Str"";
  String str2=Build.MODEL;
  if (TextUtils.isEmpty(str2))   str2=""String_Node_Str"";
  String str3=""String_Node_Str"";
  if ((!TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""))) || (!TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""))))   str3=""String_Node_Str"";
  String str4=com.qihoo.permmgr.util.k.a(mContext);
  String str5=com.qihoo.permmgr.util.f.a(str4);
  if (TextUtils.isEmpty(str4))   str5=""String_Node_Str"";
  File localFile=new File(""String_Node_Str"");
  String[] arrayOfString=new String[2];
  arrayOfString[0]=""String_Node_Str"";
  arrayOfString[1]=""String_Node_Str"";
  String str6=com.qihoo.permmgr.util.b.a(localFile,arrayOfString);
  String str7=str6.split(""String_Node_Str"")[2];
  String str8=""String_Node_Str"" + URLEncoder.encode(str2) + ""String_Node_Str""+ URLEncoder.encode(str7)+ ""String_Node_Str""+ URLEncoder.encode(str1)+ ""String_Node_Str""+ URLEncoder.encode(str3);
  String url=""String_Node_Str"" + str8 + ""String_Node_Str""+ a.e+ ""String_Node_Str""+ URLEncoder.encode(str5)+ ""String_Node_Str""+ 1+ ""String_Node_Str"";
  Log.d(TAG,""String_Node_Str"" + url);
  try {
    HttpGet localHttpGet2=new HttpGet(url);
    HttpResponse localHttpResponse=new DefaultHttpClient().execute(localHttpGet2);
    int statusCode=localHttpResponse.getStatusLine().getStatusCode();
    String jsonData=AESUtils.b(EntityUtils.toString(localHttpResponse.getEntity()));
    JSONArray arr=new JSONArray(jsonData);
    byte[] bs=new byte[1024];
    int len;
    for (int i=0; i < arr.length(); i++) {
      JSONObject temp=(JSONObject)arr.get(i);
      String md5=temp.getString(""String_Node_Str"");
      String solution=temp.getString(""String_Node_Str"");
      activity.setStatus(""String_Node_Str"" + solution + ""String_Node_Str"");
      URL sUrl=new URL(solution);
      URLConnection con=sUrl.openConnection();
      InputStream is=con.getInputStream();
      String md5FilePath=mContext.getFilesDir().getAbsoluteFile() + ""String_Node_Str"" + md5;
      OutputStream os=new FileOutputStream(md5FilePath);
      while ((len=is.read(bs)) != -1) {
        os.write(bs,0,len);
      }
      os.close();
      is.close();
      activity.setStatus(""String_Node_Str"" + md5 + ""String_Node_Str"");
      if (RootMan.getInstance(mContext).doRoot(md5FilePath) == Constants.ROOT_SUCCESS) {
        SharedStore store=new SharedStore(mContext,Constants.SOLUTION_FILE);
        store.putString(Constants.KEY_SOLUTION_MD5,md5);
        return Constants.ROOT_SUCCESS;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return Constants.NOTSUPPORT;
}"
57757,"public void handleMessage(Message msg){
  String text=String.valueOf(msg.obj);
  mStatusText.setText(text);
  super.handleMessage(msg);
}","public void handleMessage(Message msg){
  String text=String.valueOf(msg.obj);
  mStatusText.append(text);
  super.handleMessage(msg);
}"
57758,"/** 
 * 设置监听器
 */
private void setListener(){
  mHandler=new Handler(){
    public void handleMessage(    Message msg){
      String text=String.valueOf(msg.obj);
      mStatusText.setText(text);
      super.handleMessage(msg);
    }
  }
;
  mBrowerApkFileBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      IRootService rtService=getRTService();
      if (rtService != null) {
        showFileChooser();
      }
 else {
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
  }
);
}","/** 
 * 设置监听器
 */
private void setListener(){
  mHandler=new Handler(){
    public void handleMessage(    Message msg){
      String text=String.valueOf(msg.obj);
      mStatusText.append(text);
      super.handleMessage(msg);
    }
  }
;
  mBrowerApkFileBtn.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      IRootService rtService=getRTService();
      if (rtService != null) {
        showFileChooser();
      }
 else {
        Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
  }
);
}"
57759,"private List<List<String>> splitList(List<String> input,int maxSize){
  List<List<String>> result=new ArrayList<List<String>>();
  List<String> currentList=new ArrayList<String>();
  for (  String item : input) {
    currentList.add(item);
    if (currentList.size() >= maxSize) {
      result.add(currentList);
      currentList=new ArrayList<String>();
    }
  }
  return result;
}","private List<List<String>> splitList(List<String> input,int maxSize){
  List<List<String>> result=new ArrayList<List<String>>();
  List<String> currentList=new ArrayList<String>();
  for (  String item : input) {
    currentList.add(item);
    if (currentList.size() >= maxSize) {
      result.add(currentList);
      currentList=new ArrayList<String>();
    }
  }
  if (currentList.size() > 0) {
    result.add(currentList);
  }
  return result;
}"
57760,"@Override public void updatedTransactions(SKPaymentQueue queue,NSArray<SKPaymentTransaction> transactions){
  for (  final SKPaymentTransaction transaction : transactions) {
    SKPaymentTransactionState state=transaction.getTransactionState();
switch (state) {
case Purchased:
      final Transaction t=transaction(transaction);
    if (t == null) {
      break;
    }
  if (t.getTransactionDataSignature() == null) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    if (receipt == null) {
      log(LOGTYPELOG,""String_Node_Str"");
      final SKReceiptRefreshRequest request=new SKReceiptRefreshRequest();
      request.setDelegate(new SKRequestDelegateAdapter(){
        @Override public void didFinish(        SKRequest r){
          if (r.equals(request)) {
            NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
            NSData receipt=NSData.read(receiptURL);
            String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
            log(LOGTYPELOG,""String_Node_Str"");
          }
 else {
            log(LOGTYPEERROR,""String_Node_Str"");
          }
          log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
        @Override public void didFail(        SKRequest request,        NSError error){
          log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
          log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
      }
);
      request.start();
    }
 else {
      String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
      log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
      observer.handlePurchase(t);
      SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
    }
  }
 else {
    log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
    observer.handlePurchase(t);
    SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
  }
break;
case Failed:
NSError error=transaction.getError();
if (error == null) {
log(LOGTYPEERROR,""String_Node_Str"" + transaction);
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + transaction));
}
 else if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
log(LOGTYPEERROR,""String_Node_Str"");
observer.handlePurchaseCanceled();
}
 else {
log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + error.toString()));
}
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
break;
case Restored:
Transaction ta=transaction(transaction);
if (ta == null) break;
restoredTransactions.add(ta);
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
break;
default :
break;
}
}
}","@Override public void updatedTransactions(SKPaymentQueue queue,NSArray<SKPaymentTransaction> transactions){
  for (  final SKPaymentTransaction transaction : transactions) {
    SKPaymentTransactionState state=transaction.getTransactionState();
switch (state) {
case Purchased:
      final Transaction t=transaction(transaction);
    if (t == null) {
      break;
    }
  if (t.getTransactionDataSignature() == null) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    if (receipt == null) {
      log(LOGTYPELOG,""String_Node_Str"");
      final SKReceiptRefreshRequest request=new SKReceiptRefreshRequest();
      request.setDelegate(new SKRequestDelegateAdapter(){
        @Override public void didFinish(        SKRequest r){
          if (r.equals(request)) {
            NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
            NSData receipt=NSData.read(receiptURL);
            String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
            log(LOGTYPELOG,""String_Node_Str"");
          }
 else {
            log(LOGTYPEERROR,""String_Node_Str"");
          }
          log(LOGTYPELOG,""String_Node_Str"" + getOriginalTxID(transaction));
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
        @Override public void didFail(        SKRequest request,        NSError error){
          log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
          log(LOGTYPELOG,""String_Node_Str"" + getOriginalTxID(transaction));
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
      }
);
      request.start();
    }
 else {
      String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
      log(LOGTYPELOG,""String_Node_Str"" + getOriginalTxID(transaction));
      observer.handlePurchase(t);
      SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
    }
  }
 else {
    log(LOGTYPELOG,""String_Node_Str"" + getOriginalTxID(transaction));
    observer.handlePurchase(t);
    SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
  }
break;
case Failed:
NSError error=transaction.getError();
if (error == null) {
log(LOGTYPEERROR,""String_Node_Str"" + transaction);
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + transaction));
}
 else if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
log(LOGTYPEERROR,""String_Node_Str"");
observer.handlePurchaseCanceled();
}
 else {
log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + error.toString()));
}
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
break;
case Restored:
Transaction ta=transaction(transaction);
if (ta == null) break;
restoredTransactions.add(ta);
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
log(LOGTYPELOG,""String_Node_Str"" + getOriginalTxID(transaction));
break;
default :
break;
}
}
}"
57761,"@Override public void didFail(SKRequest request,NSError error){
  log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
  log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}","@Override public void didFail(SKRequest request,NSError error){
  log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
  log(LOGTYPELOG,""String_Node_Str"" + getOriginalTxID(transaction));
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}"
57762,"@Override public void didFinish(SKRequest r){
  if (r.equals(request)) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
    log(LOGTYPELOG,""String_Node_Str"");
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
  }
  log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}","@Override public void didFinish(SKRequest r){
  if (r.equals(request)) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
    log(LOGTYPELOG,""String_Node_Str"");
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
  }
  log(LOGTYPELOG,""String_Node_Str"" + getOriginalTxID(transaction));
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}"
57763,"/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  String productIdentifier=payment.getProductIdentifier();
  SKProduct product=getProductByStoreIdentifier(productIdentifier);
  if (product == null) {
    System.err.println(""String_Node_Str"" + productIdentifier);
    return null;
  }
  Transaction transaction=new Transaction();
  transaction.setIdentifier(config.getOfferForStore(PurchaseManagerConfig.STORE_NAME_IOS_APPLE,payment.getProductIdentifier()).getIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(t.getTransactionIdentifier());
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
  transaction.setPurchaseCost((int)Math.round(product.getPrice().doubleValue() * 100));
  transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  transaction.setReversalTime(null);
  transaction.setReversalText(null);
  if (payment.getRequestData() != null) {
    final String transactionData;
    if (Foundation.getMajorSystemVersion() >= 7) {
      transactionData=payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None);
    }
 else {
      transactionData=Base64.encode(payment.getRequestData().getBytes());
    }
    transaction.setTransactionData(transactionData);
  }
 else {
    transaction.setTransactionData(null);
  }
  String transactionDataSignature;
  try {
    NSData transactionReceipt=t.getTransactionReceipt();
    transactionDataSignature=transactionReceipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
  }
 catch (  Throwable e) {
    log(LOGTYPELOG,""String_Node_Str"",e);
    transactionDataSignature=null;
  }
  transaction.setTransactionDataSignature(transactionDataSignature);
  return transaction;
}","/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  String productIdentifier=payment.getProductIdentifier();
  SKProduct product=getProductByStoreIdentifier(productIdentifier);
  if (product == null) {
    System.err.println(""String_Node_Str"" + productIdentifier);
  }
  Transaction transaction=new Transaction();
  transaction.setIdentifier(config.getOfferForStore(PurchaseManagerConfig.STORE_NAME_IOS_APPLE,productIdentifier).getIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(getOriginalTxID(t));
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  if (product != null) {
    transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
    transaction.setPurchaseCost((int)Math.round(product.getPrice().doubleValue() * 100));
    transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  }
 else {
    transaction.setPurchaseText(""String_Node_Str"" + productIdentifier);
    transaction.setPurchaseCost(0);
    transaction.setPurchaseCostCurrency(null);
  }
  transaction.setReversalTime(null);
  transaction.setReversalText(null);
  if (payment.getRequestData() != null) {
    final String transactionData;
    if (Foundation.getMajorSystemVersion() >= 7) {
      transactionData=payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None);
    }
 else {
      transactionData=Base64.encode(payment.getRequestData().getBytes());
    }
    transaction.setTransactionData(transactionData);
  }
 else {
    transaction.setTransactionData(null);
  }
  String transactionDataSignature;
  try {
    NSData transactionReceipt=t.getTransactionReceipt();
    transactionDataSignature=transactionReceipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
  }
 catch (  Throwable e) {
    log(LOGTYPELOG,""String_Node_Str"",e);
    transactionDataSignature=null;
  }
  transaction.setTransactionDataSignature(transactionDataSignature);
  return transaction;
}"
57764,"protected void setInformationFields(Transaction transaction,String productId){
  Information information=purchaseManager.getInformation(productId);
  Integer priceInCents=information.getPriceInCents();
  transaction.setPurchaseCost(priceInCents == null ? null : priceInCents);
  transaction.setPurchaseCostCurrency(information.getPriceCurrencyCode());
}","protected void setInformationFields(Transaction transaction,String productId){
  Information information=purchaseManager.getInformation(productId);
  Integer priceInCents=information.getPriceInCents();
  transaction.setPurchaseCost(priceInCents == null ? 0 : priceInCents);
  transaction.setPurchaseCostCurrency(information.getPriceCurrencyCode());
}"
57765,"public static Offer offerFullEditionEntitlement(){
  Offer offer=new Offer();
  offer.setIdentifier(""String_Node_Str"");
  offer.setType(OfferType.ENTITLEMENT);
  return offer;
}","public static Offer offerFullEditionEntitlement(){
  Offer offer=new Offer();
  offer.setIdentifier(PRODUCT_IDENTIFIER_FULL_EDITION);
  offer.setType(OfferType.ENTITLEMENT);
  return offer;
}"
57766,"public static Transaction transactionFullEditionEuroGooglePlay(){
  Transaction transaction=new Transaction();
  transaction.setPurchaseCostCurrency(""String_Node_Str"");
  transaction.setPurchaseCost(100);
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_ANDROID_GOOGLE);
  transaction.setPurchaseTime(new Date());
  transaction.setIdentifier(""String_Node_Str"");
  transaction.setOrderId(""String_Node_Str"");
  return transaction;
}","public static Transaction transactionFullEditionEuroGooglePlay(){
  Transaction transaction=new Transaction();
  transaction.setPurchaseCostCurrency(""String_Node_Str"");
  transaction.setPurchaseCost(100);
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_ANDROID_GOOGLE);
  transaction.setPurchaseTime(new Date());
  transaction.setIdentifier(PRODUCT_IDENTIFIER_FULL_EDITION);
  transaction.setOrderId(""String_Node_Str"");
  return transaction;
}"
57767,"/** 
 * @param activity The AndroidApplication activity.
 * @param requestCode The request code to use in case they are needed (not all stores need them). 
 */
public IAP(Activity activity,int requestCode){
  try {
    Class<?> ouyaClazz=Class.forName(""String_Node_Str"");
    Method method=ouyaClazz.getMethod(""String_Node_Str"");
    if ((Boolean)method.invoke(ouyaClazz)) {
      PurchaseSystem.setManager((PurchaseManager)ouyaClazz.getConstructor(Activity.class,int.class).newInstance(activity,requestCode));
      return;
    }
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  try {
    Class<?> googlePlayClazz=Class.forName(""String_Node_Str"");
    Method method=googlePlayClazz.getMethod(""String_Node_Str"");
    if ((Boolean)method.invoke(googlePlayClazz,activity)) {
      PurchaseSystem.setManager((PurchaseManager)googlePlayClazz.getConstructor(Activity.class,int.class).newInstance(activity,requestCode));
      return;
    }
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  try {
    Class<?> iabClazz=Class.forName(""String_Node_Str"");
    PurchaseSystem.setManager((PurchaseManager)iabClazz.getConstructor(Activity.class,int.class).newInstance(activity,requestCode));
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
}","/** 
 * @param activity The AndroidApplication activity.
 * @param requestCode The request code to use in case they are needed (not all stores need them). 
 */
public IAP(Activity activity,int requestCode){
  try {
    Class<?> ouyaClazz=Class.forName(""String_Node_Str"");
    Method method=ouyaClazz.getMethod(""String_Node_Str"");
    if ((Boolean)method.invoke(ouyaClazz)) {
      PurchaseSystem.setManager((PurchaseManager)ouyaClazz.getConstructor(Activity.class,int.class).newInstance(activity,requestCode));
      return;
    }
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  try {
    Class<?> googlePlayClazz=Class.forName(""String_Node_Str"");
    Method method=googlePlayClazz.getMethod(""String_Node_Str"",Activity.class);
    if ((Boolean)method.invoke(googlePlayClazz,activity)) {
      PurchaseSystem.setManager((PurchaseManager)googlePlayClazz.getConstructor(Activity.class,int.class).newInstance(activity,requestCode));
      return;
    }
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
  try {
    Class<?> iabClazz=Class.forName(""String_Node_Str"");
    PurchaseSystem.setManager((PurchaseManager)iabClazz.getConstructor(Activity.class,int.class).newInstance(activity,requestCode));
  }
 catch (  Exception e) {
    Log.d(TAG,""String_Node_Str"",e);
  }
}"
57768,"@Override public void updatedTransactions(SKPaymentQueue queue,NSArray<SKPaymentTransaction> transactions){
  for (  final SKPaymentTransaction transaction : transactions) {
    SKPaymentTransactionState state=transaction.getTransactionState();
switch (state) {
case Purchased:
      final Transaction t=transaction(transaction);
    if (t == null)     break;
  if (Foundation.getMajorSystemVersion() >= 7) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    if (receipt == null) {
      log(LOGTYPELOG,""String_Node_Str"");
      final SKReceiptRefreshRequest request=new SKReceiptRefreshRequest();
      request.setDelegate(new SKRequestDelegateAdapter(){
        @Override public void didFinish(        SKRequest r){
          if (r.equals(request)) {
            NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
            NSData receipt=NSData.read(receiptURL);
            String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
            t.setTransactionDataSignature(encodedReceipt);
            log(LOGTYPELOG,""String_Node_Str"");
          }
 else {
            log(LOGTYPEERROR,""String_Node_Str"");
          }
          log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
        @Override public void didFail(        SKRequest request,        NSError error){
          log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
          log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
      }
);
      request.start();
    }
 else {
      String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
      t.setTransactionDataSignature(encodedReceipt);
      log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
      observer.handlePurchase(t);
      SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
    }
  }
 else {
    t.setTransactionDataSignature(Base64.encode(transaction.getTransactionReceipt().getBytes()));
    log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
    observer.handlePurchase(t);
    SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
  }
break;
case Failed:
NSError error=transaction.getError();
if (error == null) {
log(LOGTYPEERROR,""String_Node_Str"" + transaction);
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + transaction));
}
 else if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
log(LOGTYPEERROR,""String_Node_Str"");
observer.handlePurchaseCanceled();
}
 else {
log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + error.toString()));
}
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
break;
case Restored:
Transaction ta=transaction(transaction);
if (ta == null) break;
restoredTransactions.add(ta);
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
break;
default :
break;
}
}
}","@Override public void updatedTransactions(SKPaymentQueue queue,NSArray<SKPaymentTransaction> transactions){
  for (  final SKPaymentTransaction transaction : transactions) {
    SKPaymentTransactionState state=transaction.getTransactionState();
switch (state) {
case Purchased:
      final Transaction t=transaction(transaction);
    if (t == null) {
      break;
    }
  if (t.getTransactionDataSignature() == null) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    if (receipt == null) {
      log(LOGTYPELOG,""String_Node_Str"");
      final SKReceiptRefreshRequest request=new SKReceiptRefreshRequest();
      request.setDelegate(new SKRequestDelegateAdapter(){
        @Override public void didFinish(        SKRequest r){
          if (r.equals(request)) {
            NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
            NSData receipt=NSData.read(receiptURL);
            String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
            log(LOGTYPELOG,""String_Node_Str"");
          }
 else {
            log(LOGTYPEERROR,""String_Node_Str"");
          }
          log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
        @Override public void didFail(        SKRequest request,        NSError error){
          log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
          log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
          observer.handlePurchase(t);
          SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
        }
      }
);
      request.start();
    }
 else {
      String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
      log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
      observer.handlePurchase(t);
      SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
    }
  }
 else {
    log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
    observer.handlePurchase(t);
    SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
  }
break;
case Failed:
NSError error=transaction.getError();
if (error == null) {
log(LOGTYPEERROR,""String_Node_Str"" + transaction);
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + transaction));
}
 else if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
log(LOGTYPEERROR,""String_Node_Str"");
observer.handlePurchaseCanceled();
}
 else {
log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + error.toString()));
}
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
break;
case Restored:
Transaction ta=transaction(transaction);
if (ta == null) break;
restoredTransactions.add(ta);
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
break;
default :
break;
}
}
}"
57769,"void log(final int type,final String message){
  if (LOGDEBUG) {
    if (type == LOGTYPELOG)     System.out.println('[' + TAG + ""String_Node_Str""+ message);
    if (type == LOGTYPEERROR)     System.err.println('[' + TAG + ""String_Node_Str""+ message);
  }
}","void log(final int type,final String message,Throwable e){
  if (LOGDEBUG) {
    if (type == LOGTYPELOG)     System.out.println('[' + TAG + ""String_Node_Str""+ message);
    if (type == LOGTYPEERROR)     System.err.println('[' + TAG + ""String_Node_Str""+ message);
    if (e != null)     System.err.println('[' + TAG + ""String_Node_Str""+ e);
  }
}"
57770,"@Override public void didFinish(SKRequest r){
  if (r.equals(request)) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
    t.setTransactionDataSignature(encodedReceipt);
    log(LOGTYPELOG,""String_Node_Str"");
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
  }
  log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}","@Override public void didFinish(SKRequest r){
  if (r.equals(request)) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
    log(LOGTYPELOG,""String_Node_Str"");
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
  }
  log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}"
57771,"@Override public String toString(){
  return ""String_Node_Str"";
}","@Override public String toString(){
  return PurchaseManagerConfig.STORE_NAME_IOS_APPLE;
}"
57772,"/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  String productIdentifier=payment.getProductIdentifier();
  SKProduct product=getProductByStoreIdentifier(productIdentifier);
  if (product == null) {
    System.err.println(""String_Node_Str"" + productIdentifier);
    return null;
  }
  Transaction transaction=new Transaction();
  transaction.setIdentifier(config.getOfferForStore(PurchaseManagerConfig.STORE_NAME_IOS_APPLE,payment.getProductIdentifier()).getIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(t.getTransactionIdentifier());
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
  transaction.setPurchaseCost((int)Math.round(product.getPrice().doubleValue() * 100));
  transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  transaction.setReversalTime(null);
  transaction.setReversalText(null);
  if (payment.getRequestData() != null) {
    final String transactionData;
    if (Foundation.getMajorSystemVersion() >= 7) {
      transactionData=payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None);
    }
 else {
      transactionData=Base64.encode(payment.getRequestData().getBytes());
    }
    transaction.setTransactionData(transactionData);
  }
 else {
    transaction.setTransactionData(null);
  }
  transaction.setTransactionDataSignature(null);
  return transaction;
}","/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  String productIdentifier=payment.getProductIdentifier();
  SKProduct product=getProductByStoreIdentifier(productIdentifier);
  if (product == null) {
    System.err.println(""String_Node_Str"" + productIdentifier);
    return null;
  }
  Transaction transaction=new Transaction();
  transaction.setIdentifier(config.getOfferForStore(PurchaseManagerConfig.STORE_NAME_IOS_APPLE,payment.getProductIdentifier()).getIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(t.getTransactionIdentifier());
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
  transaction.setPurchaseCost((int)Math.round(product.getPrice().doubleValue() * 100));
  transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  transaction.setReversalTime(null);
  transaction.setReversalText(null);
  if (payment.getRequestData() != null) {
    final String transactionData;
    if (Foundation.getMajorSystemVersion() >= 7) {
      transactionData=payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None);
    }
 else {
      transactionData=Base64.encode(payment.getRequestData().getBytes());
    }
    transaction.setTransactionData(transactionData);
  }
 else {
    transaction.setTransactionData(null);
  }
  String transactionDataSignature;
  try {
    Selector sel=Selector.register(""String_Node_Str"");
    if (ObjCRuntime.class_respondsToSelector(t.getHandle(),sel.getHandle())) {
      NSData transactionReceipt=ObjCObject.toObjCObject(NSData.class,ObjCRuntime.ptr_objc_msgSend(t.getHandle(),sel.getHandle()),0);
      transactionDataSignature=transactionReceipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
    }
 else {
      transactionDataSignature=null;
      log(LOGTYPELOG,""String_Node_Str"");
    }
  }
 catch (  Throwable e) {
    log(LOGTYPELOG,""String_Node_Str"",e);
    transactionDataSignature=null;
  }
  transaction.setTransactionDataSignature(transactionDataSignature);
  return transaction;
}"
57773,"/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(Purchase purchase){
  SkuDetails skuDetails=inventory.getSkuDetails(purchase.getSku());
  Transaction transaction=new Transaction();
  transaction.setIdentifier(purchase.getSku());
  transaction.setStoreName(storeNameFromOpenIAB(purchase.getAppstoreName()));
  transaction.setOrderId(purchase.getOrderId());
  transaction.setPurchaseTime(new Date(purchase.getPurchaseTime()));
  transaction.setPurchaseText(skuDetails != null ? ""String_Node_Str"" + skuDetails.getTitle() : ""String_Node_Str"");
  transaction.setPurchaseCost(-1);
  transaction.setPurchaseCostCurrency(null);
  if (purchase.getPurchaseState() != 0) {
    transaction.setReversalTime(new Date());
    transaction.setReversalText(purchase.getPurchaseState() == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 else {
    transaction.setReversalTime(null);
    transaction.setReversalText(null);
  }
  transaction.setTransactionData(purchase.getOriginalJson());
  transaction.setTransactionDataSignature(purchase.getSignature());
  return transaction;
}","/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(Purchase purchase){
  SkuDetails skuDetails=inventory.getSkuDetails(purchase.getSku());
  Transaction transaction=new Transaction();
  transaction.setIdentifier(purchase.getSku());
  transaction.setStoreName(storeNameFromOpenIAB(purchase.getAppstoreName()));
  transaction.setOrderId(purchase.getOrderId());
  transaction.setPurchaseTime(new Date(purchase.getPurchaseTime()));
  transaction.setPurchaseText((skuDetails != null ? ""String_Node_Str"" + skuDetails.getTitle() + ""String_Node_Str""+ skuDetails.getPrice()+ ""String_Node_Str""+ skuDetails.getDescription() : ""String_Node_Str""));
  transaction.setPurchaseCost(-1);
  transaction.setPurchaseCostCurrency(null);
  if (purchase.getPurchaseState() != 0) {
    transaction.setReversalTime(new Date());
    transaction.setReversalText(purchase.getPurchaseState() == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 else {
    transaction.setReversalTime(null);
    transaction.setReversalText(null);
  }
  transaction.setTransactionData(purchase.getOriginalJson());
  transaction.setTransactionDataSignature(purchase.getSignature());
  return transaction;
}"
57774,"/** 
 * Converts a product to our transaction object. 
 */
Transaction convertPurchasedProductToTransaction(Product product){
  Transaction transaction=new Transaction();
  transaction.setIdentifier(product.getIdentifier());
  transaction.setStoreName(storeName());
  transaction.setPurchaseTime(new Date());
  showMessage(LOGTYPELOG,""String_Node_Str"");
  return transaction;
}","/** 
 * Converts a product to our transaction object. 
 */
Transaction convertPurchasedProductToTransaction(Product product){
  Transaction transaction=new Transaction();
  transaction.setIdentifier(config.getOfferForStore(PurchaseManagerConfig.STORE_NAME_ANDROID_OUYA,product.getIdentifier()).getIdentifier());
  transaction.setStoreName(storeName());
  transaction.setPurchaseTime(new Date());
  transaction.setPurchaseText(""String_Node_Str"" + product.getFormattedPrice() + ""String_Node_Str"");
  transaction.setPurchaseCost(product.getPriceInCents());
  transaction.setPurchaseCostCurrency(product.getCurrencyCode());
  transaction.setReversalTime(null);
  transaction.setReversalText(null);
  transaction.setTransactionData(null);
  transaction.setTransactionDataSignature(null);
  showMessage(LOGTYPELOG,""String_Node_Str"");
  return transaction;
}"
57775,"/** 
 * make a purchase 
 */
@Override public void purchase(String identifier){
  OUYApurchaseProduct=getProduct(identifier);
  if (OUYApurchaseProduct != null) {
    try {
      requestPurchase(OUYApurchaseProduct);
      handler.sendEmptyMessage(requestOUYApurchase);
    }
 catch (    UnsupportedEncodingException e) {
      observer.handlePurchaseError(e);
      e.printStackTrace();
    }
catch (    GeneralSecurityException e) {
      observer.handlePurchaseError(e);
      e.printStackTrace();
    }
catch (    JSONException e) {
      observer.handlePurchaseError(e);
      e.printStackTrace();
    }
  }
 else {
    showMessage(LOGTYPEERROR,""String_Node_Str"");
    observer.handlePurchaseError(new RuntimeException(""String_Node_Str""));
  }
}","/** 
 * make a purchase 
 */
@Override public void purchase(String identifier){
  OUYApurchaseProduct=getProduct(config.getOffer(identifier).getIdentifierForStore(PurchaseManagerConfig.STORE_NAME_ANDROID_OUYA));
  if (OUYApurchaseProduct != null) {
    try {
      requestPurchase(OUYApurchaseProduct);
      handler.sendEmptyMessage(requestOUYApurchase);
    }
 catch (    UnsupportedEncodingException e) {
      observer.handlePurchaseError(e);
      e.printStackTrace();
    }
catch (    GeneralSecurityException e) {
      observer.handlePurchaseError(e);
      e.printStackTrace();
    }
catch (    JSONException e) {
      observer.handlePurchaseError(e);
      e.printStackTrace();
    }
  }
 else {
    showMessage(LOGTYPEERROR,""String_Node_Str"");
    observer.handlePurchaseError(new RuntimeException(""String_Node_Str""));
  }
}"
57776,"/** 
 * Converts a purchase to our transaction object. 
 */
Transaction convertToTransaction(Receipt receipt){
  Transaction transaction=new Transaction();
  transaction.setIdentifier(receipt.getIdentifier());
  transaction.setStoreName(storeName());
  transaction.setPurchaseTime(receipt.getPurchaseDate());
  showMessage(LOGTYPELOG,""String_Node_Str"");
  return transaction;
}","/** 
 * Converts a purchase to our transaction object. 
 */
Transaction convertToTransaction(Receipt receipt){
  Transaction transaction=new Transaction();
  transaction.setIdentifier(config.getOfferForStore(PurchaseManagerConfig.STORE_NAME_ANDROID_OUYA,receipt.getIdentifier()).getIdentifier());
  transaction.setStoreName(storeName());
  transaction.setPurchaseTime(receipt.getPurchaseDate());
  transaction.setPurchaseText(""String_Node_Str"" + receipt.getGamer() + ""String_Node_Str""+ receipt.getFormattedPrice()+ ""String_Node_Str"");
  transaction.setPurchaseCost(receipt.getPriceInCents());
  transaction.setPurchaseCostCurrency(receipt.getCurrency());
  transaction.setReversalTime(null);
  transaction.setReversalText(null);
  transaction.setTransactionData(null);
  transaction.setTransactionDataSignature(null);
  showMessage(LOGTYPELOG,""String_Node_Str"");
  return transaction;
}"
57777,"@Override public void install(final PurchaseObserver observer,PurchaseManagerConfig config){
  this.observer=observer;
  this.config=config;
  Object[] configuration=(Object[])config.getStoreParam(PurchaseManagerConfig.STORE_NAME_ANDROID_OUYA);
  String developerID=(String)configuration[0];
  applicationKeyPath=(String)configuration[1];
  ouyaFacade=OuyaFacade.getInstance();
  ouyaFacade.init((Context)activity,developerID);
  productIDList=new ArrayList<Purchasable>(config.getOfferCount());
  for (int i=0; i < config.getOfferCount(); i++) {
    productIDList.add(new Purchasable(config.getOffer(i).getIdentifier()));
  }
  try {
    FileHandle fHandle=Gdx.files.internal(applicationKeyPath);
    byte[] applicationKey=fHandle.readBytes();
    X509EncodedKeySpec keySpec=new X509EncodedKeySpec(applicationKey);
    KeyFactory keyFactory=KeyFactory.getInstance(""String_Node_Str"");
    ouyaPublicKey=keyFactory.generatePublic(keySpec);
    showMessage(LOGTYPELOG,""String_Node_Str"");
    requestProductList();
    observer.handleInstall();
  }
 catch (  Exception e) {
    showMessage(LOGTYPEERROR,""String_Node_Str"");
    observer.handleInstallError(new RuntimeException(""String_Node_Str"" + e));
  }
}","@Override public void install(final PurchaseObserver observer,PurchaseManagerConfig config){
  this.observer=observer;
  this.config=config;
  Object[] configuration=(Object[])config.getStoreParam(PurchaseManagerConfig.STORE_NAME_ANDROID_OUYA);
  String developerID=(String)configuration[0];
  applicationKeyPath=(String)configuration[1];
  ouyaFacade=OuyaFacade.getInstance();
  ouyaFacade.init((Context)activity,developerID);
  productIDList=new ArrayList<Purchasable>(config.getOfferCount());
  for (int i=0; i < config.getOfferCount(); i++) {
    productIDList.add(new Purchasable(config.getOffer(i).getIdentifierForStore(PurchaseManagerConfig.STORE_NAME_ANDROID_OUYA)));
  }
  try {
    FileHandle fHandle=Gdx.files.internal(applicationKeyPath);
    byte[] applicationKey=fHandle.readBytes();
    X509EncodedKeySpec keySpec=new X509EncodedKeySpec(applicationKey);
    KeyFactory keyFactory=KeyFactory.getInstance(""String_Node_Str"");
    ouyaPublicKey=keyFactory.generatePublic(keySpec);
    showMessage(LOGTYPELOG,""String_Node_Str"");
    requestProductList();
    observer.handleInstall();
  }
 catch (  Exception e) {
    showMessage(LOGTYPEERROR,""String_Node_Str"");
    observer.handleInstallError(new RuntimeException(""String_Node_Str"" + e));
  }
}"
57778,"@Override public void purchase(String identifier){
  log(LOGTYPELOG,""String_Node_Str"" + identifier + ""String_Node_Str"");
  SKProduct product=getProductById(identifier);
  if (product == null) {
    log(LOGTYPEERROR,""String_Node_Str"" + identifier + ""String_Node_Str"");
    observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + identifier + ""String_Node_Str""));
  }
  SKPayment payment=SKPayment.createFromProduct(product);
  SKPaymentQueue.getDefaultQueue().addPayment(payment);
}","@Override public void purchase(String identifier){
  log(LOGTYPELOG,""String_Node_Str"" + identifier + ""String_Node_Str"");
  SKProduct product=getProductById(config.getOffer(identifier).getIdentifierForStore(PurchaseManagerConfig.STORE_NAME_IOS_APPLE));
  if (product == null) {
    log(LOGTYPEERROR,""String_Node_Str"" + identifier + ""String_Node_Str"");
    observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + identifier + ""String_Node_Str""));
  }
  SKPayment payment=SKPayment.createFromProduct(product);
  SKPaymentQueue.getDefaultQueue().addPayment(payment);
}"
57779,"@Override public void install(PurchaseObserver observer,PurchaseManagerConfig config){
  this.observer=observer;
  this.config=config;
  log(LOGTYPELOG,""String_Node_Str"");
  if (SKPaymentQueue.canMakePayments()) {
    Set<String> productIdentifiers=new HashSet<String>();
    int size=config.getOfferCount();
    for (int i=0; i < size; i++) {
      productIdentifiers.add(config.getOffer(i).getIdentifier());
    }
    log(LOGTYPELOG,""String_Node_Str"");
    productsRequest=new SKProductsRequest(productIdentifiers);
    productsRequest.setDelegate(new AppleProductsDelegate());
    productsRequest.start();
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
    observer.handleInstallError(new RuntimeException(""String_Node_Str""));
  }
}","@Override public void install(PurchaseObserver observer,PurchaseManagerConfig config){
  this.observer=observer;
  this.config=config;
  log(LOGTYPELOG,""String_Node_Str"");
  if (SKPaymentQueue.canMakePayments()) {
    Set<String> productIdentifiers=new HashSet<String>();
    int size=config.getOfferCount();
    for (int i=0; i < size; i++) {
      productIdentifiers.add(config.getOffer(i).getIdentifierForStore(PurchaseManagerConfig.STORE_NAME_IOS_APPLE));
    }
    log(LOGTYPELOG,""String_Node_Str"");
    productsRequest=new SKProductsRequest(productIdentifiers);
    productsRequest.setDelegate(new AppleProductsDelegate());
    productsRequest.start();
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
    observer.handleInstallError(new RuntimeException(""String_Node_Str""));
  }
}"
57780,"/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  SKProduct product=getProductById(payment.getProductIdentifier());
  final Transaction transaction=new Transaction();
  transaction.setIdentifier(product.getProductIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(t.getTransactionIdentifier());
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
  transaction.setPurchaseCost((int)(product.getPrice().doubleValue() * 100));
  transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  if (payment.getRequestData() != null) {
    transaction.setTransactionData(payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None));
  }
  return transaction;
}","/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  SKProduct product=getProductById(payment.getProductIdentifier());
  Transaction transaction=new Transaction();
  transaction.setIdentifier(config.getOfferForStore(PurchaseManagerConfig.STORE_NAME_IOS_APPLE,payment.getProductIdentifier()).getIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(t.getTransactionIdentifier());
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
  transaction.setPurchaseCost((int)Math.round(product.getPrice().doubleValue() * 100));
  transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  transaction.setReversalTime(null);
  transaction.setReversalText(null);
  if (payment.getRequestData() != null) {
    transaction.setTransactionData(payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None));
  }
 else {
    transaction.setTransactionData(null);
  }
  transaction.setTransactionDataSignature(null);
  return transaction;
}"
57781,"@Override public void dispose(){
  if (PurchaseSystem.hasManager())   PurchaseSystem.dispose();
  if (observer != null) {
    observer=null;
    config=null;
    showMessage(LOGTYPELOG,""String_Node_Str"");
  }
}","@Override public void dispose(){
  if (observer != null) {
    observer=null;
    config=null;
    showMessage(LOGTYPELOG,""String_Node_Str"");
  }
}"
57782,"@Override public void updatedTransactions(SKPaymentQueue queue,NSArray<SKPaymentTransaction> transactions){
  for (  SKPaymentTransaction transaction : transactions) {
    SKPaymentTransactionState state=transaction.getTransactionState();
switch (state) {
case Purchased:
      observer.handlePurchase(transaction(transaction));
    SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
  break;
case Failed:
NSError error=transaction.getError();
if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
observer.handlePurchaseCanceled();
}
 else {
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + error.toString()));
}
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
break;
case Restored:
restoredTransactions.add(transaction(transaction));
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
break;
default :
break;
}
}
}","@Override public void updatedTransactions(SKPaymentQueue queue,NSArray<SKPaymentTransaction> transactions){
  for (  final SKPaymentTransaction transaction : transactions) {
    SKPaymentTransactionState state=transaction.getTransactionState();
switch (state) {
case Purchased:
      final Transaction t=transaction(transaction);
    if (Foundation.getMajorSystemVersion() >= 7) {
      NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
      NSData receipt=NSData.read(receiptURL);
      if (receipt == null) {
        log(LOGTYPELOG,""String_Node_Str"");
        final SKReceiptRefreshRequest request=new SKReceiptRefreshRequest();
        request.setDelegate(new SKRequestDelegateAdapter(){
          @Override public void didFinish(          SKRequest r){
            if (r.equals(request)) {
              NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
              NSData receipt=NSData.read(receiptURL);
              String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
              t.setTransactionDataSignature(encodedReceipt);
              log(LOGTYPELOG,""String_Node_Str"");
            }
 else {
              log(LOGTYPEERROR,""String_Node_Str"");
            }
            log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
            observer.handlePurchase(t);
            SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
          }
          @Override public void didFail(          SKRequest request,          NSError error){
            log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
            log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
            observer.handlePurchase(t);
            SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
          }
        }
);
        request.start();
      }
 else {
        String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
        t.setTransactionDataSignature(encodedReceipt);
        log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
        observer.handlePurchase(t);
        SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
      }
    }
 else {
      t.setTransactionDataSignature(transaction.getTransactionReceipt().toBase64EncodedString(NSDataBase64EncodingOptions.None));
      log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
      observer.handlePurchase(t);
      SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
    }
  break;
case Failed:
NSError error=transaction.getError();
if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
log(LOGTYPEERROR,""String_Node_Str"");
observer.handlePurchaseCanceled();
}
 else {
log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + error.toString()));
}
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
break;
case Restored:
restoredTransactions.add(transaction(transaction));
SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
break;
default :
break;
}
}
}"
57783,"@Override public void didFail(SKRequest request,NSError error){
  observer.handleInstallError(new RuntimeException(""String_Node_Str"" + (error != null ? error.toString() : ""String_Node_Str"")));
}","@Override public void didFail(SKRequest request,NSError error){
  log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
  log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}"
57784,"@Override public void didReceiveResponse(SKProductsRequest request,SKProductsResponse response){
  products=response.getProducts();
  observer.handleInstall();
}","@Override public void didReceiveResponse(SKProductsRequest request,SKProductsResponse response){
  products=response.getProducts();
  appleObserver=new AppleTransactionObserver();
  SKPaymentQueue.getDefaultQueue().addTransactionObserver(appleObserver);
  log(LOGTYPELOG,""String_Node_Str"");
  log(LOGTYPELOG,""String_Node_Str"");
  observer.handleInstall();
}"
57785,"@Override public void restoreCompletedTransactionsFailed(SKPaymentQueue queue,NSError error){
  if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
    observer.handleRestoreError(new RuntimeException(""String_Node_Str""));
  }
 else {
    observer.handleRestoreError(new RuntimeException(""String_Node_Str"" + error.toString()));
  }
}","@Override public void restoreCompletedTransactionsFailed(SKPaymentQueue queue,NSError error){
  if (error.getCode() == SKErrorCode.PaymentCancelled.value()) {
    log(LOGTYPEERROR,""String_Node_Str"");
    observer.handleRestoreError(new RuntimeException(""String_Node_Str""));
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"" + error.toString());
    observer.handleRestoreError(new RuntimeException(""String_Node_Str"" + error.toString()));
  }
}"
57786,"@Override public void didFinish(SKRequest r){
  if (r.equals(request)) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
    transaction.setTransactionDataSignature(encodedReceipt);
  }
}","@Override public void didFinish(SKRequest r){
  if (r.equals(request)) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
    t.setTransactionDataSignature(encodedReceipt);
    log(LOGTYPELOG,""String_Node_Str"");
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
  }
  log(LOGTYPELOG,""String_Node_Str"" + transaction.getTransactionIdentifier());
  observer.handlePurchase(t);
  SKPaymentQueue.getDefaultQueue().finishTransaction(transaction);
}"
57787,"@Override public void purchase(String identifier){
  SKProduct product=getProductById(identifier);
  if (product == null) {
    observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + identifier + ""String_Node_Str""));
  }
  SKPayment payment=SKPayment.createFromProduct(product);
  SKPaymentQueue.getDefaultQueue().addPayment(payment);
}","@Override public void purchase(String identifier){
  log(LOGTYPELOG,""String_Node_Str"" + identifier + ""String_Node_Str"");
  SKProduct product=getProductById(identifier);
  if (product == null) {
    log(LOGTYPEERROR,""String_Node_Str"" + identifier + ""String_Node_Str"");
    observer.handlePurchaseError(new RuntimeException(""String_Node_Str"" + identifier + ""String_Node_Str""));
  }
  SKPayment payment=SKPayment.createFromProduct(product);
  SKPaymentQueue.getDefaultQueue().addPayment(payment);
}"
57788,"@Override public void restoreCompletedTransactionsFinished(SKPaymentQueue queue){
  observer.handleRestore(restoredTransactions.toArray(new Transaction[restoredTransactions.size()]));
}","@Override public void restoreCompletedTransactionsFinished(SKPaymentQueue queue){
  log(LOGTYPELOG,""String_Node_Str"");
  observer.handleRestore(restoredTransactions.toArray(new Transaction[restoredTransactions.size()]));
  restoredTransactions.clear();
}"
57789,"@Override public void install(PurchaseObserver observer,PurchaseManagerConfig config){
  this.observer=observer;
  this.config=config;
  if (SKPaymentQueue.canMakePayments()) {
    appleObserver=new AppleTransactionObserver();
    SKPaymentQueue.getDefaultQueue().addTransactionObserver(appleObserver);
    Set<String> productIdentifiers=new HashSet<String>();
    int size=config.getOfferCount();
    for (int i=0; i < size; i++) {
      productIdentifiers.add(config.getOffer(i).getIdentifier());
    }
    productsRequest=new SKProductsRequest(productIdentifiers);
    productsRequest.setDelegate(new AppleProductsDelegate());
    productsRequest.start();
  }
 else {
    observer.handleInstallError(new RuntimeException(""String_Node_Str""));
  }
}","@Override public void install(PurchaseObserver observer,PurchaseManagerConfig config){
  this.observer=observer;
  this.config=config;
  log(LOGTYPELOG,""String_Node_Str"");
  if (SKPaymentQueue.canMakePayments()) {
    Set<String> productIdentifiers=new HashSet<String>();
    int size=config.getOfferCount();
    for (int i=0; i < size; i++) {
      productIdentifiers.add(config.getOffer(i).getIdentifier());
    }
    log(LOGTYPELOG,""String_Node_Str"");
    productsRequest=new SKProductsRequest(productIdentifiers);
    productsRequest.setDelegate(new AppleProductsDelegate());
    productsRequest.start();
  }
 else {
    log(LOGTYPEERROR,""String_Node_Str"");
    observer.handleInstallError(new RuntimeException(""String_Node_Str""));
  }
}"
57790,"@Override public void purchaseRestore(){
  restoredTransactions.clear();
  SKPaymentQueue.getDefaultQueue().restoreCompletedTransactions();
}","@Override public void purchaseRestore(){
  log(LOGTYPELOG,""String_Node_Str"");
  restoredTransactions.clear();
  SKPaymentQueue.getDefaultQueue().restoreCompletedTransactions();
}"
57791,"@Override public void dispose(){
  if (appleObserver != null) {
    SKPaymentQueue.getDefaultQueue().removeTransactionObserver(appleObserver);
    appleObserver=null;
    productsRequest=null;
    products=null;
    restoredTransactions.clear();
    observer=null;
    config=null;
  }
}","@Override public void dispose(){
  if (appleObserver != null) {
    SKPaymentQueue.getDefaultQueue().removeTransactionObserver(appleObserver);
    appleObserver=null;
    productsRequest=null;
    products=null;
    restoredTransactions.clear();
    observer=null;
    config=null;
    log(LOGTYPELOG,""String_Node_Str"");
  }
}"
57792,"/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  SKProduct product=getProductById(payment.getProductIdentifier());
  final Transaction transaction=new Transaction();
  transaction.setIdentifier(product.getProductIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(t.getTransactionIdentifier());
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
  transaction.setPurchaseCost((int)(product.getPrice().doubleValue() * 100));
  transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  transaction.setTransactionData(payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None));
  if (Foundation.getMajorSystemVersion() >= 7) {
    NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
    NSData receipt=NSData.read(receiptURL);
    if (receipt == null) {
      final SKReceiptRefreshRequest request=new SKReceiptRefreshRequest();
      request.setDelegate(new SKRequestDelegateAdapter(){
        @Override public void didFinish(        SKRequest r){
          if (r.equals(request)) {
            NSURL receiptURL=NSBundle.getMainBundle().getAppStoreReceiptURL();
            NSData receipt=NSData.read(receiptURL);
            String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
            transaction.setTransactionDataSignature(encodedReceipt);
          }
        }
        @Override public void didFail(        SKRequest request,        NSError error){
        }
      }
);
      request.start();
    }
 else {
      String encodedReceipt=receipt.toBase64EncodedString(NSDataBase64EncodingOptions.None);
      transaction.setTransactionDataSignature(encodedReceipt);
    }
  }
 else {
    transaction.setTransactionDataSignature(t.getTransactionReceipt().toBase64EncodedString(NSDataBase64EncodingOptions.None));
  }
  return transaction;
}","/** 
 * Converts a purchase to our transaction object. 
 */
Transaction transaction(SKPaymentTransaction t){
  SKPayment payment=t.getPayment();
  SKProduct product=getProductById(payment.getProductIdentifier());
  final Transaction transaction=new Transaction();
  transaction.setIdentifier(product.getProductIdentifier());
  transaction.setStoreName(PurchaseManagerConfig.STORE_NAME_IOS_APPLE);
  transaction.setOrderId(t.getTransactionIdentifier());
  transaction.setPurchaseTime(t.getTransactionDate().toDate());
  transaction.setPurchaseText(""String_Node_Str"" + product.getLocalizedTitle());
  transaction.setPurchaseCost((int)(product.getPrice().doubleValue() * 100));
  transaction.setPurchaseCostCurrency(product.getPriceLocale().getCurrencyCode());
  if (payment.getRequestData() != null) {
    transaction.setTransactionData(payment.getRequestData().toBase64EncodedString(NSDataBase64EncodingOptions.None));
  }
  return transaction;
}"
57793,"@Override public void handlePurchaseCanceled(){
}","@Override public void handlePurchaseCanceled(){
  message(""String_Node_Str"");
  Gdx.app.postRunnable(new Runnable(){
    @Override public void run(){
      message(""String_Node_Str"");
      PurchaseSystem.dispose();
      message(""String_Node_Str"");
    }
  }
);
}"
57794,"@Override public void create(){
  font=new BitmapFont();
  batch=new SpriteBatch();
  message=""String_Node_Str"";
  if (PurchaseSystem.hasManager()) {
    final String IAP_TEST_CONSUMEABLE=""String_Node_Str"";
    PurchaseManagerConfig config=new PurchaseManagerConfig();
    config.addOffer(new Offer().setType(OfferType.CONSUMABLE).setIdentifier(IAP_TEST_CONSUMEABLE).putIdentifierForStore(PurchaseManagerConfig.STORE_NAME_ANDROID_GOOGLE,""String_Node_Str""));
    PurchaseSystem.install(new PurchaseObserver(){
      @Override public void handleRestore(      Transaction[] transactions){
        message(""String_Node_Str"" + transactions.length + ""String_Node_Str"");
        for (int i=0; i < transactions.length; i++) {
          message(""String_Node_Str"" + transactions[i].getIdentifier() + ""String_Node_Str"");
        }
        message(""String_Node_Str"" + IAP_TEST_CONSUMEABLE + ""String_Node_Str"");
        PurchaseSystem.purchase(IAP_TEST_CONSUMEABLE);
      }
      @Override public void handleRestoreError(      Throwable e){
        message(""String_Node_Str"" + e + ""String_Node_Str"");
        throw new GdxRuntimeException(e);
      }
      @Override public void handleInstall(){
        message(""String_Node_Str"" + PurchaseSystem.storeName() + ""String_Node_Str"");
        message(""String_Node_Str"");
        PurchaseSystem.purchaseRestore();
      }
      @Override public void handleInstallError(      Throwable e){
        message(""String_Node_Str"" + e + ""String_Node_Str"");
        throw new GdxRuntimeException(e);
      }
      @Override public void handlePurchase(      Transaction transaction){
        message(""String_Node_Str"" + transaction.getIdentifier() + ""String_Node_Str"");
        Gdx.app.postRunnable(new Runnable(){
          @Override public void run(){
            message(""String_Node_Str"");
            PurchaseSystem.dispose();
            message(""String_Node_Str"");
          }
        }
);
      }
      @Override public void handlePurchaseError(      Throwable e){
        message(""String_Node_Str"" + e + ""String_Node_Str"");
        throw new GdxRuntimeException(e);
      }
      @Override public void handlePurchaseCanceled(){
      }
    }
,config);
  }
 else {
    message(""String_Node_Str"");
  }
}","@Override public void create(){
  font=new BitmapFont();
  batch=new SpriteBatch();
  message=""String_Node_Str"";
  if (PurchaseSystem.hasManager()) {
    final String IAP_TEST_CONSUMEABLE=""String_Node_Str"";
    final String IAP_TEST_NONCONSUMEABLE=""String_Node_Str"";
    PurchaseManagerConfig config=new PurchaseManagerConfig();
    config.addOffer(new Offer().setType(OfferType.CONSUMABLE).setIdentifier(IAP_TEST_CONSUMEABLE).putIdentifierForStore(PurchaseManagerConfig.STORE_NAME_ANDROID_GOOGLE,""String_Node_Str""));
    config.addOffer(new Offer().setType(OfferType.ENTITLEMENT).setIdentifier(IAP_TEST_NONCONSUMEABLE));
    PurchaseSystem.install(new PurchaseObserver(){
      @Override public void handleRestore(      Transaction[] transactions){
        message(""String_Node_Str"" + transactions.length + ""String_Node_Str"");
        for (int i=0; i < transactions.length; i++) {
          message(""String_Node_Str"" + transactions[i].getIdentifier() + ""String_Node_Str"");
        }
        message(""String_Node_Str"" + IAP_TEST_CONSUMEABLE + ""String_Node_Str"");
        PurchaseSystem.purchase(IAP_TEST_CONSUMEABLE);
      }
      @Override public void handleRestoreError(      Throwable e){
        message(""String_Node_Str"" + e + ""String_Node_Str"");
        throw new GdxRuntimeException(e);
      }
      @Override public void handleInstall(){
        message(""String_Node_Str"" + PurchaseSystem.storeName() + ""String_Node_Str"");
        message(""String_Node_Str"");
        PurchaseSystem.purchaseRestore();
      }
      @Override public void handleInstallError(      Throwable e){
        message(""String_Node_Str"" + e + ""String_Node_Str"");
        throw new GdxRuntimeException(e);
      }
      @Override public void handlePurchase(      Transaction transaction){
        message(""String_Node_Str"" + transaction.getIdentifier() + ""String_Node_Str"");
        Gdx.app.postRunnable(new Runnable(){
          @Override public void run(){
            message(""String_Node_Str"");
            PurchaseSystem.dispose();
            message(""String_Node_Str"");
          }
        }
);
      }
      @Override public void handlePurchaseError(      Throwable e){
        message(""String_Node_Str"" + e + ""String_Node_Str"");
        throw new GdxRuntimeException(e);
      }
      @Override public void handlePurchaseCanceled(){
        message(""String_Node_Str"");
        Gdx.app.postRunnable(new Runnable(){
          @Override public void run(){
            message(""String_Node_Str"");
            PurchaseSystem.dispose();
            message(""String_Node_Str"");
          }
        }
);
      }
    }
,config);
  }
 else {
    message(""String_Node_Str"");
  }
}"
57795,"/** 
 * Returns the registered manager or null for none. 
 */
public static PurchaseManager getManager(){
  return manager;
}","/** 
 * Returns the registered manager or null for none. 
 */
public static PurchaseManager getManager(){
  if (manager == null) {
    resolve();
  }
  return manager;
}"
57796,"/** 
 * Returns true if the purchase system is installed and ready to go. 
 */
public static boolean installed(){
  if (manager != null) {
    return manager.installed();
  }
 else {
    return false;
  }
}","/** 
 * Returns true if the purchase system is installed and ready to go. 
 */
public static boolean installed(){
  if (hasManager()) {
    return manager.installed();
  }
 else {
    return false;
  }
}"
57797,"/** 
 * Installs a purchase observer. 
 */
public static void install(PurchaseObserver observer,PurchaseManagerConfig config){
  if (manager != null) {
    manager.install(observer,config);
  }
 else {
    observer.handleInstallError(new RuntimeException(""String_Node_Str""));
  }
}","/** 
 * Installs a purchase observer. 
 */
public static void install(PurchaseObserver observer,PurchaseManagerConfig config){
  if (hasManager()) {
    manager.install(observer,config);
  }
 else {
    observer.handleInstallError(new RuntimeException(""String_Node_Str""));
  }
}"
57798,"/** 
 * Asks to restore previous purchases. Results are returned to the observer. 
 */
public static void purchaseRestore(){
  if (manager != null) {
    manager.purchaseRestore();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Asks to restore previous purchases. Results are returned to the observer. 
 */
public static void purchaseRestore(){
  if (hasManager()) {
    manager.purchaseRestore();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
57799,"/** 
 * Executes a purchase. 
 */
public static void purchase(String identifier){
  if (manager != null) {
    manager.purchase(identifier);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Executes a purchase. 
 */
public static void purchase(String identifier){
  if (hasManager()) {
    manager.purchase(identifier);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
57800,"/** 
 * Returns the store name or null for none. 
 */
public static String storeName(){
  if (manager != null) {
    return manager.storeName();
  }
 else {
    return null;
  }
}","/** 
 * Returns the store name or null for none. 
 */
public static String storeName(){
  if (hasManager()) {
    return manager.storeName();
  }
 else {
    return null;
  }
}"
57801,"/** 
 * Disposes the purchase manager if there was one. 
 */
public static void dispose(){
  if (manager != null) {
    manager.dispose();
    manager=null;
  }
}","/** 
 * Disposes the purchase manager if there was one. 
 */
public static void dispose(){
  if (hasManager()) {
    manager.dispose();
    manager=null;
  }
}"
57802,"/** 
 * Returns true if there is a purchase manager available. 
 */
public static boolean hasManager(){
  return manager != null;
}","/** 
 * Returns true if there is a purchase manager available. 
 */
public static boolean hasManager(){
  return getManager() != null;
}"
57803,"/** 
 * The IV is produced by adding the initial IV to the counter. IV length  should be the same as   {@link #AES_BLOCK_SIZE}
 */
@Override public void calculateIV(byte[] initIV,long counter,byte[] IV){
  Preconditions.checkArgument(initIV.length == AES_BLOCK_SIZE);
  Preconditions.checkArgument(IV.length == AES_BLOCK_SIZE);
  System.arraycopy(initIV,0,IV,0,CTR_OFFSET);
  long l=(initIV[CTR_OFFSET + 0] << 56) + ((initIV[CTR_OFFSET + 1] & 0xFF) << 48) + ((initIV[CTR_OFFSET + 2] & 0xFF) << 40)+ ((initIV[CTR_OFFSET + 3] & 0xFF) << 32)+ ((initIV[CTR_OFFSET + 4] & 0xFF) << 24)+ ((initIV[CTR_OFFSET + 5] & 0xFF) << 16)+ ((initIV[CTR_OFFSET + 6] & 0xFF) << 8)+ (initIV[CTR_OFFSET + 7] & 0xFF);
  l+=counter;
  IV[CTR_OFFSET + 0]=(byte)(l >>> 56);
  IV[CTR_OFFSET + 1]=(byte)(l >>> 48);
  IV[CTR_OFFSET + 2]=(byte)(l >>> 40);
  IV[CTR_OFFSET + 3]=(byte)(l >>> 32);
  IV[CTR_OFFSET + 4]=(byte)(l >>> 24);
  IV[CTR_OFFSET + 5]=(byte)(l >>> 16);
  IV[CTR_OFFSET + 6]=(byte)(l >>> 8);
  IV[CTR_OFFSET + 7]=(byte)(l);
}","/** 
 * The IV is produced by adding the initial IV to the counter. IV length  should be the same as   {@link #AES_BLOCK_SIZE}
 */
@Override public void calculateIV(byte[] initIV,long counter,byte[] IV){
  Preconditions.checkArgument(initIV.length == AES_BLOCK_SIZE);
  Preconditions.checkArgument(IV.length == AES_BLOCK_SIZE);
  System.arraycopy(initIV,0,IV,0,CTR_OFFSET);
  long l=0;
  for (int i=0; i < 8; i++) {
    l=((l << 8) | (initIV[CTR_OFFSET + i] & 0xff));
  }
  l+=counter;
  IV[CTR_OFFSET + 0]=(byte)(l >>> 56);
  IV[CTR_OFFSET + 1]=(byte)(l >>> 48);
  IV[CTR_OFFSET + 2]=(byte)(l >>> 40);
  IV[CTR_OFFSET + 3]=(byte)(l >>> 32);
  IV[CTR_OFFSET + 4]=(byte)(l >>> 24);
  IV[CTR_OFFSET + 5]=(byte)(l >>> 16);
  IV[CTR_OFFSET + 6]=(byte)(l >>> 8);
  IV[CTR_OFFSET + 7]=(byte)(l);
}"
57804,"@Override synchronized protected int next(int nbits){
  fillReservoir(4);
  int n=reservoir[pos] | (reservoir[pos + 1] << 8) | (reservoir[pos + 2] << 16)| (reservoir[pos + 3] << 24);
  pos+=4;
  return n & (0xffffffff >> (32 - nbits));
}","@Override synchronized protected int next(int nbits){
  fillReservoir(4);
  int n=0;
  for (int i=0; i < 4; i++) {
    n=((n << 8) | (reservoir[pos++] & 0xff));
  }
  return n & (0xffffffff >> (32 - nbits));
}"
57805,"@Override public Configuration getConf(){
  return conf;
}","@Override synchronized public Configuration getConf(){
  return conf;
}"
57806,"@Override public void close() throws IOException {
  stream.close();
}","@Override synchronized public void close() throws IOException {
  stream.close();
}"
57807,"@Override public void setConf(Configuration conf){
  this.conf=conf;
  this.randomDevPath=conf.get(HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_KEY,HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_DEFAULT);
  File randomDevFile=new File(randomDevPath);
  try {
    this.stream=new FileInputStream(randomDevFile);
    fillReservoir(0);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override synchronized public void setConf(Configuration conf){
  this.conf=conf;
  this.randomDevPath=conf.get(HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_KEY,HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_DEFAULT);
  File randomDevFile=new File(randomDevPath);
  try {
    this.stream=new FileInputStream(randomDevFile);
    fillReservoir(0);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
57808,"/** 
 * Remove xattr of a file or directory.Value in xAttr parameter is ignored. <<<<<<< .working Name must be prefixed with user/trusted/security/system/raw. ======= The name must be prefixed with the namespace followed by ""."". For example, ""user.attr"". >>>>>>> .merge-right.r1614550 <p/> <<<<<<< .working A regular user only can remove xattr of ""user"" namespace. A super user can remove xattr of ""user"" and ""trusted"" namespace. XAttr of ""security"" and ""system"" namespace is only used/exposed  internally to the FS impl. The xattrs of the ""raw"" namespace are only used/exposed when accessed in the /.reserved/raw HDFS directory hierarchy. These attributes can only be accessed by the superuser. <p/>
 * @see <a href=""http://en.wikipedia.org/wiki/Extended_file_attributes"">
   * http://en.wikipedia.org/wiki/Extended_file_attributes</a>======= Refer to the HDFS extended attributes user documentation for details. >>>>>>> .merge-right.r1614550
 * @param src file or directory
 * @param xAttr <code>XAttr</code> to remove
 * @throws IOException
 */
@AtMostOnce public void removeXAttr(String src,XAttr xAttr) throws IOException ;","/** 
 * Remove xattr of a file or directory.Value in xAttr parameter is ignored. The name must be prefixed with the namespace followed by ""."". For example, ""user.attr"". <p/> Refer to the HDFS extended attributes user documentation for details.
 * @param src file or directory
 * @param xAttr <code>XAttr</code> to remove
 * @throws IOException
 */
@AtMostOnce public void removeXAttr(String src,XAttr xAttr) throws IOException ;"
57809,"@Override public synchronized void shutdownDatanode(boolean forUpgrade) throws IOException {
  LOG.info(""String_Node_Str"" + forUpgrade + ""String_Node_Str"");
  if (shutdownInProgress) {
    throw new IOException(""String_Node_Str"");
  }
  shutdownInProgress=true;
  shutdownForUpgrade=forUpgrade;
  Thread shutdownThread=new Thread(){
    @Override public void run(){
      if (!shutdownForUpgrade) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ie) {
        }
      }
      shutdown();
    }
  }
;
  shutdownThread.setDaemon(true);
  shutdownThread.start();
}","@Override public synchronized void shutdownDatanode(boolean forUpgrade) throws IOException {
  checkSuperuserPrivilege();
  LOG.info(""String_Node_Str"" + forUpgrade + ""String_Node_Str"");
  if (shutdownInProgress) {
    throw new IOException(""String_Node_Str"");
  }
  shutdownInProgress=true;
  shutdownForUpgrade=forUpgrade;
  Thread shutdownThread=new Thread(){
    @Override public void run(){
      if (!shutdownForUpgrade) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ie) {
        }
      }
      shutdown();
    }
  }
;
  shutdownThread.setDaemon(true);
  shutdownThread.start();
}"
57810,"@Override public void deleteBlockPool(String blockPoolId,boolean force) throws IOException {
  LOG.info(""String_Node_Str"" + blockPoolId + ""String_Node_Str""+ force);
  if (blockPoolManager.get(blockPoolId) != null) {
    LOG.warn(""String_Node_Str"" + blockPoolId + ""String_Node_Str"");
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
  }
  data.deleteBlockPool(blockPoolId,force);
}","@Override public void deleteBlockPool(String blockPoolId,boolean force) throws IOException {
  checkSuperuserPrivilege();
  LOG.info(""String_Node_Str"" + blockPoolId + ""String_Node_Str""+ force);
  if (blockPoolManager.get(blockPoolId) != null) {
    LOG.warn(""String_Node_Str"" + blockPoolId + ""String_Node_Str"");
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"");
  }
  data.deleteBlockPool(blockPoolId,force);
}"
57811,"/** 
 * This method starts the data node with the specified conf.
 * @param conf - the configurationif conf's CONFIG_PROPERTY_SIMULATED property is set then a simulated storage based data node is created.
 * @param dataDirs - only for a non-simulated storage data node
 * @throws IOException
 */
void startDataNode(Configuration conf,List<StorageLocation> dataDirs,SecureResources resources) throws IOException {
  if (UserGroupInformation.isSecurityEnabled() && resources == null) {
    if (!conf.getBoolean(""String_Node_Str"",false)) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  this.secureResources=resources;
  this.dataDirs=dataDirs;
  this.conf=conf;
  this.dnConf=new DNConf(conf);
  if (dnConf.maxLockedMemory > 0) {
    if (!NativeIO.POSIX.getCacheManipulator().verifyCanMlock()) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",DFS_DATANODE_MAX_LOCKED_MEMORY_KEY));
    }
    long ulimit=NativeIO.POSIX.getCacheManipulator().getMemlockLimit();
    if (dnConf.maxLockedMemory > ulimit) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DFS_DATANODE_MAX_LOCKED_MEMORY_KEY,dnConf.maxLockedMemory,ulimit));
    }
  }
  LOG.info(""String_Node_Str"" + dnConf.maxLockedMemory);
  storage=new DataStorage();
  registerMXBean();
  initDataXceiver(conf);
  startInfoServer(conf);
  pauseMonitor=new JvmPauseMonitor(conf);
  pauseMonitor.start();
  this.blockPoolTokenSecretManager=new BlockPoolTokenSecretManager();
  initIpcServer(conf);
  metrics=DataNodeMetrics.create(conf,getDisplayName());
  blockPoolManager=new BlockPoolManager(this);
  blockPoolManager.refreshNamenodes(conf);
  readaheadPool=ReadaheadPool.getInstance();
}","/** 
 * This method starts the data node with the specified conf.
 * @param conf - the configurationif conf's CONFIG_PROPERTY_SIMULATED property is set then a simulated storage based data node is created.
 * @param dataDirs - only for a non-simulated storage data node
 * @throws IOException
 */
void startDataNode(Configuration conf,List<StorageLocation> dataDirs,SecureResources resources) throws IOException {
  if (UserGroupInformation.isSecurityEnabled() && resources == null) {
    if (!conf.getBoolean(""String_Node_Str"",false)) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  this.secureResources=resources;
  this.dataDirs=dataDirs;
  this.conf=conf;
  this.dnConf=new DNConf(conf);
  if (dnConf.maxLockedMemory > 0) {
    if (!NativeIO.POSIX.getCacheManipulator().verifyCanMlock()) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"",DFS_DATANODE_MAX_LOCKED_MEMORY_KEY));
    }
    long ulimit=NativeIO.POSIX.getCacheManipulator().getMemlockLimit();
    if (dnConf.maxLockedMemory > ulimit) {
      throw new RuntimeException(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",DFS_DATANODE_MAX_LOCKED_MEMORY_KEY,dnConf.maxLockedMemory,ulimit));
    }
  }
  LOG.info(""String_Node_Str"" + dnConf.maxLockedMemory);
  storage=new DataStorage();
  registerMXBean();
  initDataXceiver(conf);
  startInfoServer(conf);
  pauseMonitor=new JvmPauseMonitor(conf);
  pauseMonitor.start();
  this.blockPoolTokenSecretManager=new BlockPoolTokenSecretManager();
  dnUserName=UserGroupInformation.getCurrentUser().getShortUserName();
  LOG.info(""String_Node_Str"" + dnUserName);
  LOG.info(""String_Node_Str"" + supergroup);
  initIpcServer(conf);
  metrics=DataNodeMetrics.create(conf,getDisplayName());
  blockPoolManager=new BlockPoolManager(this);
  blockPoolManager.refreshNamenodes(conf);
  readaheadPool=ReadaheadPool.getInstance();
}"
57812,"/** 
 * Create the DataNode given a configuration, an array of dataDirs, and a namenode proxy
 */
DataNode(final Configuration conf,final List<StorageLocation> dataDirs,final SecureResources resources) throws IOException {
  super(conf);
  this.lastDiskErrorCheck=0;
  this.maxNumberOfBlocksToLog=conf.getLong(DFS_MAX_NUM_BLOCKS_TO_LOG_KEY,DFS_MAX_NUM_BLOCKS_TO_LOG_DEFAULT);
  this.usersWithLocalPathAccess=Arrays.asList(conf.getTrimmedStrings(DFSConfigKeys.DFS_BLOCK_LOCAL_PATH_ACCESS_USER_KEY));
  this.connectToDnViaHostname=conf.getBoolean(DFSConfigKeys.DFS_DATANODE_USE_DN_HOSTNAME,DFSConfigKeys.DFS_DATANODE_USE_DN_HOSTNAME_DEFAULT);
  this.getHdfsBlockLocationsEnabled=conf.getBoolean(DFSConfigKeys.DFS_HDFS_BLOCKS_METADATA_ENABLED,DFSConfigKeys.DFS_HDFS_BLOCKS_METADATA_ENABLED_DEFAULT);
  confVersion=""String_Node_Str"" + conf.get(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ conf.get(""String_Node_Str"",""String_Node_Str"");
  if (conf.getBoolean(DFSConfigKeys.DFS_CLIENT_READ_SHORTCIRCUIT_KEY,DFSConfigKeys.DFS_CLIENT_READ_SHORTCIRCUIT_DEFAULT)) {
    String reason=DomainSocket.getLoadingFailureReason();
    if (reason != null) {
      LOG.warn(""String_Node_Str"" + reason);
      this.fileDescriptorPassingDisabledReason=reason;
    }
 else {
      LOG.info(""String_Node_Str"");
      this.fileDescriptorPassingDisabledReason=null;
    }
  }
 else {
    this.fileDescriptorPassingDisabledReason=""String_Node_Str"";
    LOG.debug(this.fileDescriptorPassingDisabledReason);
  }
  try {
    hostName=getHostName(conf);
    LOG.info(""String_Node_Str"" + hostName);
    startDataNode(conf,dataDirs,resources);
  }
 catch (  IOException ie) {
    shutdown();
    throw ie;
  }
}","/** 
 * Create the DataNode given a configuration, an array of dataDirs, and a namenode proxy
 */
DataNode(final Configuration conf,final List<StorageLocation> dataDirs,final SecureResources resources) throws IOException {
  super(conf);
  this.lastDiskErrorCheck=0;
  this.maxNumberOfBlocksToLog=conf.getLong(DFS_MAX_NUM_BLOCKS_TO_LOG_KEY,DFS_MAX_NUM_BLOCKS_TO_LOG_DEFAULT);
  this.usersWithLocalPathAccess=Arrays.asList(conf.getTrimmedStrings(DFSConfigKeys.DFS_BLOCK_LOCAL_PATH_ACCESS_USER_KEY));
  this.connectToDnViaHostname=conf.getBoolean(DFSConfigKeys.DFS_DATANODE_USE_DN_HOSTNAME,DFSConfigKeys.DFS_DATANODE_USE_DN_HOSTNAME_DEFAULT);
  this.getHdfsBlockLocationsEnabled=conf.getBoolean(DFSConfigKeys.DFS_HDFS_BLOCKS_METADATA_ENABLED,DFSConfigKeys.DFS_HDFS_BLOCKS_METADATA_ENABLED_DEFAULT);
  this.supergroup=conf.get(DFSConfigKeys.DFS_PERMISSIONS_SUPERUSERGROUP_KEY,DFSConfigKeys.DFS_PERMISSIONS_SUPERUSERGROUP_DEFAULT);
  this.isPermissionEnabled=conf.getBoolean(DFSConfigKeys.DFS_PERMISSIONS_ENABLED_KEY,DFSConfigKeys.DFS_PERMISSIONS_ENABLED_DEFAULT);
  confVersion=""String_Node_Str"" + conf.get(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str""+ conf.get(""String_Node_Str"",""String_Node_Str"");
  if (conf.getBoolean(DFSConfigKeys.DFS_CLIENT_READ_SHORTCIRCUIT_KEY,DFSConfigKeys.DFS_CLIENT_READ_SHORTCIRCUIT_DEFAULT)) {
    String reason=DomainSocket.getLoadingFailureReason();
    if (reason != null) {
      LOG.warn(""String_Node_Str"" + reason);
      this.fileDescriptorPassingDisabledReason=reason;
    }
 else {
      LOG.info(""String_Node_Str"");
      this.fileDescriptorPassingDisabledReason=null;
    }
  }
 else {
    this.fileDescriptorPassingDisabledReason=""String_Node_Str"";
    LOG.debug(this.fileDescriptorPassingDisabledReason);
  }
  try {
    hostName=getHostName(conf);
    LOG.info(""String_Node_Str"" + hostName);
    startDataNode(conf,dataDirs,resources);
  }
 catch (  IOException ie) {
    shutdown();
    throw ie;
  }
}"
57813,"@Override public void refreshNamenodes() throws IOException {
  conf=new Configuration();
  refreshNamenodes(conf);
}","@Override public void refreshNamenodes() throws IOException {
  checkSuperuserPrivilege();
  conf=new Configuration();
  refreshNamenodes(conf);
}"
57814,"/** 
 * Returns the length of the input. 
 */
public int getLength(){
  return buffer.getLength();
}","/** 
 * Returns the index one greater than the last valid character in the input stream buffer.
 */
public int getLength(){
  return buffer.getLength();
}"
57815,"@Override public void run(){
  LOG.info(this + ""String_Node_Str"" + interruptCheckPeriodMs);
  final TreeMap<Integer,Entry> entries=new TreeMap<Integer,Entry>();
  FdSet fdSet=new FdSet();
  addNotificationSocket(entries,fdSet);
  try {
    while (true) {
      lock.lock();
      try {
        for (        int fd : fdSet.getAndClearReadableFds()) {
          sendCallback(""String_Node_Str"",entries,fdSet,fd);
        }
        if (!(toAdd.isEmpty() && toRemove.isEmpty())) {
          for (Iterator<Entry> iter=toAdd.iterator(); iter.hasNext(); ) {
            Entry entry=iter.next();
            DomainSocket sock=entry.getDomainSocket();
            Entry prevEntry=entries.put(sock.fd,entry);
            Preconditions.checkState(prevEntry == null,this + ""String_Node_Str"" + ""String_Node_Str""+ sock);
            if (LOG.isTraceEnabled()) {
              LOG.trace(this + ""String_Node_Str"" + sock.fd);
            }
            fdSet.add(sock.fd);
            iter.remove();
          }
          while (true) {
            Map.Entry<Integer,DomainSocket> entry=toRemove.firstEntry();
            if (entry == null)             break;
            sendCallback(""String_Node_Str"",entries,fdSet,entry.getValue().fd);
          }
          processedCond.signalAll();
        }
        if (closed) {
          LOG.info(toString() + ""String_Node_Str"");
          return;
        }
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
      }
  finally {
        lock.unlock();
      }
      doPoll0(interruptCheckPeriodMs,fdSet);
    }
  }
 catch (  InterruptedException e) {
    LOG.info(toString() + ""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.error(toString() + ""String_Node_Str"",e);
  }
 finally {
    kick();
    for (    Entry entry : entries.values()) {
      sendCallback(""String_Node_Str"",entries,fdSet,entry.getDomainSocket().fd);
    }
    entries.clear();
    fdSet.close();
  }
}","@Override public void run(){
  if (LOG.isDebugEnabled()) {
    LOG.debug(this + ""String_Node_Str"" + interruptCheckPeriodMs);
  }
  final TreeMap<Integer,Entry> entries=new TreeMap<Integer,Entry>();
  FdSet fdSet=new FdSet();
  addNotificationSocket(entries,fdSet);
  try {
    while (true) {
      lock.lock();
      try {
        for (        int fd : fdSet.getAndClearReadableFds()) {
          sendCallback(""String_Node_Str"",entries,fdSet,fd);
        }
        if (!(toAdd.isEmpty() && toRemove.isEmpty())) {
          for (Iterator<Entry> iter=toAdd.iterator(); iter.hasNext(); ) {
            Entry entry=iter.next();
            DomainSocket sock=entry.getDomainSocket();
            Entry prevEntry=entries.put(sock.fd,entry);
            Preconditions.checkState(prevEntry == null,this + ""String_Node_Str"" + ""String_Node_Str""+ sock);
            if (LOG.isTraceEnabled()) {
              LOG.trace(this + ""String_Node_Str"" + sock.fd);
            }
            fdSet.add(sock.fd);
            iter.remove();
          }
          while (true) {
            Map.Entry<Integer,DomainSocket> entry=toRemove.firstEntry();
            if (entry == null)             break;
            sendCallback(""String_Node_Str"",entries,fdSet,entry.getValue().fd);
          }
          processedCond.signalAll();
        }
        if (closed) {
          if (LOG.isDebugEnabled()) {
            LOG.debug(toString() + ""String_Node_Str"");
          }
          return;
        }
        if (Thread.interrupted()) {
          throw new InterruptedException();
        }
      }
  finally {
        lock.unlock();
      }
      doPoll0(interruptCheckPeriodMs,fdSet);
    }
  }
 catch (  InterruptedException e) {
    LOG.info(toString() + ""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.error(toString() + ""String_Node_Str"",e);
  }
 finally {
    kick();
    for (    Entry entry : entries.values()) {
      sendCallback(""String_Node_Str"",entries,fdSet,entry.getDomainSocket().fd);
    }
    entries.clear();
    fdSet.close();
  }
}"
57816,"/** 
 * Close the DomainSocketWatcher and wait for its thread to terminate. If there is more than one close, all but the first will be ignored.
 */
@Override public void close() throws IOException {
  lock.lock();
  try {
    if (closed)     return;
    LOG.info(this + ""String_Node_Str"");
    closed=true;
  }
  finally {
    lock.unlock();
  }
  notificationSockets[0].close();
  Uninterruptibles.joinUninterruptibly(watcherThread);
}","/** 
 * Close the DomainSocketWatcher and wait for its thread to terminate. If there is more than one close, all but the first will be ignored.
 */
@Override public void close() throws IOException {
  lock.lock();
  try {
    if (closed)     return;
    if (LOG.isDebugEnabled()) {
      LOG.debug(this + ""String_Node_Str"");
    }
    closed=true;
  }
  finally {
    lock.unlock();
  }
  notificationSockets[0].close();
  Uninterruptibles.joinUninterruptibly(watcherThread);
}"
57817,"public void move(Queue newQueue){
  QueueMetrics oldMetrics=queue.getMetrics();
  QueueMetrics newMetrics=newQueue.getMetrics();
  String user=getUser();
  for (  RMContainer liveContainer : liveContainers.values()) {
    Resource resource=liveContainer.getContainer().getResource();
    oldMetrics.releaseResources(user,1,resource);
    newMetrics.allocateResources(user,1,resource,false);
  }
  for (  Map<NodeId,RMContainer> map : reservedContainers.values()) {
    for (    RMContainer reservedContainer : map.values()) {
      Resource resource=reservedContainer.getReservedResource();
      oldMetrics.unreserveResource(user,resource);
      newMetrics.reserveResource(user,resource);
    }
  }
  appSchedulingInfo.move(newQueue);
  this.queue=newQueue;
}","public synchronized void move(Queue newQueue){
  QueueMetrics oldMetrics=queue.getMetrics();
  QueueMetrics newMetrics=newQueue.getMetrics();
  String user=getUser();
  for (  RMContainer liveContainer : liveContainers.values()) {
    Resource resource=liveContainer.getContainer().getResource();
    oldMetrics.releaseResources(user,1,resource);
    newMetrics.allocateResources(user,1,resource,false);
  }
  for (  Map<NodeId,RMContainer> map : reservedContainers.values()) {
    for (    RMContainer reservedContainer : map.values()) {
      Resource resource=reservedContainer.getReservedResource();
      oldMetrics.unreserveResource(user,resource);
      newMetrics.reserveResource(user,resource);
    }
  }
  appSchedulingInfo.move(newQueue);
  this.queue=newQueue;
}"
57818,"@Override protected void processPath(PathData item) throws IOException {
  if (cf.getOpt(""String_Node_Str"")) {
    item.fs.removeAcl(item.path);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.removeDefaultAcl(item.path);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.modifyAclEntries(item.path,aclEntries);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.removeAclEntries(item.path,aclEntries);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.setAcl(path,aclEntries);
  }
}","@Override protected void processPath(PathData item) throws IOException {
  if (cf.getOpt(""String_Node_Str"")) {
    item.fs.removeAcl(item.path);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.removeDefaultAcl(item.path);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.modifyAclEntries(item.path,aclEntries);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.removeAclEntries(item.path,aclEntries);
  }
 else   if (cf.getOpt(""String_Node_Str"")) {
    item.fs.setAcl(item.path,aclEntries);
  }
}"
57819,"@Override protected void processOptions(LinkedList<String> args) throws IOException {
  cf.parse(args);
  setRecursive(cf.getOpt(""String_Node_Str""));
  boolean bothRemoveOptions=cf.getOpt(""String_Node_Str"") && cf.getOpt(""String_Node_Str"");
  boolean bothModifyOptions=cf.getOpt(""String_Node_Str"") && cf.getOpt(""String_Node_Str"");
  boolean oneRemoveOption=cf.getOpt(""String_Node_Str"") || cf.getOpt(""String_Node_Str"");
  boolean oneModifyOption=cf.getOpt(""String_Node_Str"") || cf.getOpt(""String_Node_Str"");
  boolean setOption=cf.getOpt(""String_Node_Str"");
  if ((bothRemoveOptions || bothModifyOptions) || (oneRemoveOption && oneModifyOption) || (setOption && (oneRemoveOption || oneModifyOption))) {
    throw new HadoopIllegalArgumentException(""String_Node_Str"");
  }
  if (oneModifyOption || setOption) {
    if (args.size() < 2) {
      throw new HadoopIllegalArgumentException(""String_Node_Str"");
    }
    aclEntries=parseAclSpec(args.removeFirst());
  }
  if (args.isEmpty()) {
    throw new HadoopIllegalArgumentException(""String_Node_Str"");
  }
  if (args.size() > 1) {
    throw new HadoopIllegalArgumentException(""String_Node_Str"");
  }
  path=new Path(args.removeFirst());
}","@Override protected void processOptions(LinkedList<String> args) throws IOException {
  cf.parse(args);
  setRecursive(cf.getOpt(""String_Node_Str""));
  boolean bothRemoveOptions=cf.getOpt(""String_Node_Str"") && cf.getOpt(""String_Node_Str"");
  boolean bothModifyOptions=cf.getOpt(""String_Node_Str"") && cf.getOpt(""String_Node_Str"");
  boolean oneRemoveOption=cf.getOpt(""String_Node_Str"") || cf.getOpt(""String_Node_Str"");
  boolean oneModifyOption=cf.getOpt(""String_Node_Str"") || cf.getOpt(""String_Node_Str"");
  boolean setOption=cf.getOpt(""String_Node_Str"");
  if ((bothRemoveOptions || bothModifyOptions) || (oneRemoveOption && oneModifyOption) || (setOption && (oneRemoveOption || oneModifyOption))) {
    throw new HadoopIllegalArgumentException(""String_Node_Str"");
  }
  if (oneModifyOption || setOption) {
    if (args.size() < 2) {
      throw new HadoopIllegalArgumentException(""String_Node_Str"");
    }
    aclEntries=AclEntry.parseAclSpec(args.removeFirst(),!cf.getOpt(""String_Node_Str""));
  }
  if (args.isEmpty()) {
    throw new HadoopIllegalArgumentException(""String_Node_Str"");
  }
  if (args.size() > 1) {
    throw new HadoopIllegalArgumentException(""String_Node_Str"");
  }
}"
57820,"@Test public void testSetfaclValidations() throws Exception {
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
}","@Test public void testSetfaclValidations() throws Exception {
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertFalse(""String_Node_Str"",0 == runCommand(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
}"
57821,"@Override public void run(){
  while (!stopped && !Thread.currentThread().isInterrupted()) {
    drained=eventQueue.isEmpty();
    Event event;
    try {
      event=eventQueue.take();
    }
 catch (    InterruptedException ie) {
      if (!stopped) {
        LOG.warn(""String_Node_Str"",ie);
      }
      return;
    }
    if (event != null) {
      dispatch(event);
    }
  }
}","@Override public void run(){
  while (!stopped && !Thread.currentThread().isInterrupted()) {
    drained=eventQueue.isEmpty();
    if (blockNewEvents) {
synchronized (waitForDrained) {
        if (drained) {
          waitForDrained.notify();
        }
      }
    }
    Event event;
    try {
      event=eventQueue.take();
    }
 catch (    InterruptedException ie) {
      if (!stopped) {
        LOG.warn(""String_Node_Str"",ie);
      }
      return;
    }
    if (event != null) {
      dispatch(event);
    }
  }
}"
57822,"Runnable createThread(){
  return new Runnable(){
    @Override public void run(){
      while (!stopped && !Thread.currentThread().isInterrupted()) {
        drained=eventQueue.isEmpty();
        Event event;
        try {
          event=eventQueue.take();
        }
 catch (        InterruptedException ie) {
          if (!stopped) {
            LOG.warn(""String_Node_Str"",ie);
          }
          return;
        }
        if (event != null) {
          dispatch(event);
        }
      }
    }
  }
;
}","Runnable createThread(){
  return new Runnable(){
    @Override public void run(){
      while (!stopped && !Thread.currentThread().isInterrupted()) {
        drained=eventQueue.isEmpty();
        if (blockNewEvents) {
synchronized (waitForDrained) {
            if (drained) {
              waitForDrained.notify();
            }
          }
        }
        Event event;
        try {
          event=eventQueue.take();
        }
 catch (        InterruptedException ie) {
          if (!stopped) {
            LOG.warn(""String_Node_Str"",ie);
          }
          return;
        }
        if (event != null) {
          dispatch(event);
        }
      }
    }
  }
;
}"
57823,"@Override protected void serviceStop() throws Exception {
  if (drainEventsOnStop) {
    blockNewEvents=true;
    LOG.info(""String_Node_Str"");
    while (!drained) {
      Thread.yield();
    }
  }
  stopped=true;
  if (eventHandlingThread != null) {
    eventHandlingThread.interrupt();
    try {
      eventHandlingThread.join();
    }
 catch (    InterruptedException ie) {
      LOG.warn(""String_Node_Str"",ie);
    }
  }
  super.serviceStop();
}","@Override protected void serviceStop() throws Exception {
  if (drainEventsOnStop) {
    blockNewEvents=true;
    LOG.info(""String_Node_Str"");
synchronized (waitForDrained) {
      while (!drained && eventHandlingThread.isAlive()) {
        waitForDrained.wait(1000);
        LOG.info(""String_Node_Str"");
      }
    }
  }
  stopped=true;
  if (eventHandlingThread != null) {
    eventHandlingThread.interrupt();
    try {
      eventHandlingThread.join();
    }
 catch (    InterruptedException ie) {
      LOG.warn(""String_Node_Str"",ie);
    }
  }
  super.serviceStop();
}"
57824,"@Override public XDR send(XDR xdr,int xid){
  super.send(xdr,xid);
  xdr.writeBoolean(true);
  postOpDirAttr.serialize(xdr);
  if (getStatus() == Nfs3Status.NFS3_OK) {
    xdr.writeLongAsHyper(cookieVerf);
    Entry3[] f=dirList.entries;
    for (int i=0; i < f.length; i++) {
      xdr.writeBoolean(true);
      xdr.writeLongAsHyper(f[i].getFileId());
      xdr.writeString(f[i].getName());
      xdr.writeLongAsHyper(f[i].getCookie());
    }
    xdr.writeBoolean(false);
    xdr.writeBoolean(dirList.eof);
  }
  return xdr;
}","@Override public XDR send(XDR xdr,int xid){
  super.send(xdr,xid);
  xdr.writeBoolean(true);
  postOpDirAttr.serialize(xdr);
  if (getStatus() == Nfs3Status.NFS3_OK) {
    xdr.writeLongAsHyper(cookieVerf);
    for (    Entry3 e : dirList.entries) {
      xdr.writeBoolean(true);
      xdr.writeLongAsHyper(e.getFileId());
      xdr.writeString(e.getName());
      xdr.writeLongAsHyper(e.getCookie());
    }
    xdr.writeBoolean(false);
    xdr.writeBoolean(dirList.eof);
  }
  return xdr;
}"
57825,"public DirList3(Entry3[] entries,boolean eof){
  this.entries=ObjectArrays.newArray(entries,entries.length);
  System.arraycopy(this.entries,0,entries,0,entries.length);
  this.eof=eof;
}","public DirList3(Entry3[] entries,boolean eof){
  this.entries=Collections.unmodifiableList(Arrays.asList(entries));
  this.eof=eof;
}"
57826,"EntryPlus3[] getEntries(){
  return entries;
}","List<EntryPlus3> getEntries(){
  return entries;
}"
57827,"public DirListPlus3(EntryPlus3[] entries,boolean eof){
  this.entries=ObjectArrays.newArray(entries,entries.length);
  System.arraycopy(this.entries,0,entries,0,entries.length);
  this.eof=eof;
}","public DirListPlus3(EntryPlus3[] entries,boolean eof){
  this.entries=Collections.unmodifiableList(Arrays.asList(entries));
  this.eof=eof;
}"
57828,"@Override public XDR send(XDR out,int xid){
  super.send(out,xid);
  out.writeBoolean(true);
  if (postOpDirAttr == null) {
    postOpDirAttr=new Nfs3FileAttributes();
  }
  postOpDirAttr.serialize(out);
  if (getStatus() == Nfs3Status.NFS3_OK) {
    out.writeLongAsHyper(cookieVerf);
    EntryPlus3[] f=dirListPlus.getEntries();
    for (int i=0; i < f.length; i++) {
      out.writeBoolean(true);
      f[i].seralize(out);
    }
    out.writeBoolean(false);
    out.writeBoolean(dirListPlus.getEof());
  }
  return out;
}","@Override public XDR send(XDR out,int xid){
  super.send(out,xid);
  out.writeBoolean(true);
  if (postOpDirAttr == null) {
    postOpDirAttr=new Nfs3FileAttributes();
  }
  postOpDirAttr.serialize(out);
  if (getStatus() == Nfs3Status.NFS3_OK) {
    out.writeLongAsHyper(cookieVerf);
    for (    EntryPlus3 f : dirListPlus.getEntries()) {
      out.writeBoolean(true);
      f.seralize(out);
    }
    out.writeBoolean(false);
    out.writeBoolean(dirListPlus.getEof());
  }
  return out;
}"
57829,"/** 
 * Instantiates a   {@link ContainerRequest} with the given constraints.
 * @param capability The  {@link Resource} to be requested for each container.
 * @param nodes Any hosts to request that the containers are placed on.
 * @param racks Any racks to request that the containers are placed on. The racks corresponding to any hosts requested will be automatically added to this list.
 * @param priority The priority at which to request the containers. Higher priorities have lower numerical values.
 * @param containerCount The number of containers to request.
 * @param relaxLocality If true, containers for this request may be assigned on hosts and racks other than the ones explicitly requested.
 */
public ContainerRequest(Resource capability,String[] nodes,String[] racks,Priority priority,int containerCount,boolean relaxLocality){
  Preconditions.checkArgument(capability != null,""String_Node_Str"" + ""String_Node_Str"");
  Preconditions.checkArgument(priority != null,""String_Node_Str"");
  Preconditions.checkArgument(containerCount > 0,""String_Node_Str"");
  Preconditions.checkArgument((!relaxLocality && (racks == null || racks.length == 0) && (nodes == null || nodes.length == 0)),""String_Node_Str"" + ""String_Node_Str"");
  this.capability=capability;
  this.nodes=(nodes != null ? ImmutableList.copyOf(nodes) : null);
  this.racks=(racks != null ? ImmutableList.copyOf(racks) : null);
  this.priority=priority;
  this.containerCount=containerCount;
  this.relaxLocality=relaxLocality;
}","/** 
 * Instantiates a   {@link ContainerRequest} with the given constraints.
 * @param capability The  {@link Resource} to be requested for each container.
 * @param nodes Any hosts to request that the containers are placed on.
 * @param racks Any racks to request that the containers are placed on. The racks corresponding to any hosts requested will be automatically added to this list.
 * @param priority The priority at which to request the containers. Higher priorities have lower numerical values.
 * @param containerCount The number of containers to request.
 * @param relaxLocality If true, containers for this request may be assigned on hosts and racks other than the ones explicitly requested.
 */
public ContainerRequest(Resource capability,String[] nodes,String[] racks,Priority priority,int containerCount,boolean relaxLocality){
  Preconditions.checkArgument(capability != null,""String_Node_Str"" + ""String_Node_Str"");
  Preconditions.checkArgument(priority != null,""String_Node_Str"");
  Preconditions.checkArgument(containerCount > 0,""String_Node_Str"");
  Preconditions.checkArgument(!(!relaxLocality && (racks == null || racks.length == 0) && (nodes == null || nodes.length == 0)),""String_Node_Str"" + ""String_Node_Str"");
  this.capability=capability;
  this.nodes=(nodes != null ? ImmutableList.copyOf(nodes) : null);
  this.racks=(racks != null ? ImmutableList.copyOf(racks) : null);
  this.priority=priority;
  this.containerCount=containerCount;
  this.relaxLocality=relaxLocality;
}"
57830,"public MockHistoryContext(int appid,int numJobs,int numTasks,int numAttempts,boolean hasFailedTasks){
  super(appid);
  JobsPair jobs;
  try {
    jobs=MockHistoryJobs.newHistoryJobs(getApplicationID(),numJobs,numTasks,numAttempts,hasFailedTasks);
  }
 catch (  IOException e) {
    throw new YarnException(e);
  }
  partialJobs=jobs.partial;
  fullJobs=jobs.full;
}","public MockHistoryContext(int appid,int numJobs,int numTasks,int numAttempts,boolean hasFailedTasks){
  super(appid);
  JobsPair jobs;
  try {
    jobs=MockHistoryJobs.newHistoryJobs(getApplicationID(),numJobs,numTasks,numAttempts,hasFailedTasks);
  }
 catch (  IOException e) {
    throw new YarnRuntimeException(e);
  }
  partialJobs=jobs.partial;
  fullJobs=jobs.full;
}"
57831,"@Test public void testRollMasterKey() throws Exception {
  TestDelegationTokenSecretManager dtSecretManager=new TestDelegationTokenSecretManager(800,800,1 * 1000,3600000);
  try {
    dtSecretManager.startThreads();
    Token<TestDelegationTokenIdentifier> token=generateDelegationToken(dtSecretManager,""String_Node_Str"",""String_Node_Str"");
    byte[] oldPasswd=token.getPassword();
    int prevNumKeys=dtSecretManager.getAllKeys().length;
    dtSecretManager.rollMasterKey();
    Assert.assertTrue(dtSecretManager.isStoreNewMasterKeyCalled);
    int currNumKeys=dtSecretManager.getAllKeys().length;
    Assert.assertEquals((currNumKeys - prevNumKeys) >= 1,true);
    ByteArrayInputStream bi=new ByteArrayInputStream(token.getIdentifier());
    TestDelegationTokenIdentifier identifier=dtSecretManager.createIdentifier();
    identifier.readFields(new DataInputStream(bi));
    byte[] newPasswd=dtSecretManager.retrievePassword(identifier);
    Assert.assertEquals(oldPasswd,newPasswd);
    Thread.sleep(2200);
    Assert.assertTrue(dtSecretManager.isRemoveStoredMasterKeyCalled);
  }
  finally {
    dtSecretManager.stopThreads();
  }
}","@Test(timeout=10000) public void testRollMasterKey() throws Exception {
  TestDelegationTokenSecretManager dtSecretManager=new TestDelegationTokenSecretManager(800,800,1 * 1000,3600000);
  try {
    dtSecretManager.startThreads();
    Token<TestDelegationTokenIdentifier> token=generateDelegationToken(dtSecretManager,""String_Node_Str"",""String_Node_Str"");
    byte[] oldPasswd=token.getPassword();
    int prevNumKeys=dtSecretManager.getAllKeys().length;
    dtSecretManager.rollMasterKey();
    Assert.assertTrue(dtSecretManager.isStoreNewMasterKeyCalled);
    int currNumKeys=dtSecretManager.getAllKeys().length;
    Assert.assertEquals((currNumKeys - prevNumKeys) >= 1,true);
    ByteArrayInputStream bi=new ByteArrayInputStream(token.getIdentifier());
    TestDelegationTokenIdentifier identifier=dtSecretManager.createIdentifier();
    identifier.readFields(new DataInputStream(bi));
    byte[] newPasswd=dtSecretManager.retrievePassword(identifier);
    Assert.assertEquals(oldPasswd,newPasswd);
    while (!dtSecretManager.isRemoveStoredMasterKeyCalled) {
      Thread.sleep(200);
    }
  }
  finally {
    dtSecretManager.stopThreads();
  }
}"
57832,"/** 
 * For use only by tests and initialization
 */
@InterfaceAudience.Private static void setTokenServiceUseIp(boolean flag){
  useIpForTokenService=flag;
  hostResolver=!useIpForTokenService ? new QualifiedHostResolver() : new StandardHostResolver();
}","/** 
 * For use only by tests and initialization
 */
@InterfaceAudience.Private public static void setTokenServiceUseIp(boolean flag){
  useIpForTokenService=flag;
  hostResolver=!useIpForTokenService ? new QualifiedHostResolver() : new StandardHostResolver();
}"
57833,"@Test public void testFilterFileSystem() throws Exception {
  for (  Method m : FileSystem.class.getDeclaredMethods()) {
    if (Modifier.isStatic(m.getModifiers()))     continue;
    if (Modifier.isPrivate(m.getModifiers()))     continue;
    try {
      DontCheck.class.getMethod(m.getName(),m.getParameterTypes());
      LOG.info(""String_Node_Str"" + m);
    }
 catch (    NoSuchMethodException exc) {
      LOG.info(""String_Node_Str"" + m);
      try {
        FilterFileSystem.class.getDeclaredMethod(m.getName(),m.getParameterTypes());
      }
 catch (      NoSuchMethodException exc2) {
        LOG.error(""String_Node_Str"" + m);
        throw exc2;
      }
    }
  }
}","@Test public void testFilterFileSystem() throws Exception {
  for (  Method m : FileSystem.class.getDeclaredMethods()) {
    if (Modifier.isStatic(m.getModifiers()))     continue;
    if (Modifier.isPrivate(m.getModifiers()))     continue;
    if (Modifier.isFinal(m.getModifiers()))     continue;
    try {
      DontCheck.class.getMethod(m.getName(),m.getParameterTypes());
      LOG.info(""String_Node_Str"" + m);
    }
 catch (    NoSuchMethodException exc) {
      LOG.info(""String_Node_Str"" + m);
      try {
        FilterFileSystem.class.getDeclaredMethod(m.getName(),m.getParameterTypes());
      }
 catch (      NoSuchMethodException exc2) {
        LOG.error(""String_Node_Str"" + m);
        throw exc2;
      }
    }
  }
}"
57834,"@Override public int compare(DatanodeDescriptor d1,DatanodeDescriptor d2){
  int ret=0;
switch (sortField) {
case FIELD_LAST_CONTACT:
    ret=(int)(d2.getLastUpdate() - d1.getLastUpdate());
  break;
case FIELD_CAPACITY:
long dlong=d1.getCapacity() - d2.getCapacity();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_USED:
dlong=d1.getDfsUsed() - d2.getDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_NONDFS_USED:
dlong=d1.getNonDfsUsed() - d2.getNonDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_REMAINING:
dlong=d1.getRemaining() - d2.getRemaining();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERCENT_USED:
double ddbl=((d1.getDfsUsedPercent()) - (d2.getDfsUsedPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_PERCENT_REMAINING:
ddbl=((d1.getRemainingPercent()) - (d2.getRemainingPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_BLOCKS:
ret=d1.numBlocks() - d2.numBlocks();
break;
case FIELD_ADMIN_STATE:
ret=d1.getAdminState().toString().compareTo(d2.getAdminState().toString());
break;
case FIELD_DECOMMISSIONED:
ret=DFSUtil.DECOM_COMPARATOR.compare(d1,d2);
break;
case FIELD_NAME:
ret=d1.getHostName().compareTo(d2.getHostName());
break;
case FIELD_BLOCKPOOL_USED:
dlong=d1.getBlockPoolUsed() - d2.getBlockPoolUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERBLOCKPOOL_USED:
ddbl=d1.getBlockPoolUsedPercent() - d2.getBlockPoolUsedPercent();
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_FAILED_VOLUMES:
int dint=d1.getVolumeFailures() - d2.getVolumeFailures();
ret=(dint < 0) ? -1 : ((dint > 0) ? 1 : 0);
break;
}
return (sortOrder == SORT_ORDER_DSC) ? -ret : ret;
}","@Override public int compare(DatanodeDescriptor d1,DatanodeDescriptor d2){
  int ret=0;
switch (sortField) {
case FIELD_LAST_CONTACT:
    ret=(int)(d2.getLastUpdate() - d1.getLastUpdate());
  break;
case FIELD_CAPACITY:
long dlong=d1.getCapacity() - d2.getCapacity();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_USED:
dlong=d1.getDfsUsed() - d2.getDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_NONDFS_USED:
dlong=d1.getNonDfsUsed() - d2.getNonDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_REMAINING:
dlong=d1.getRemaining() - d2.getRemaining();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERCENT_USED:
double ddbl=((d1.getDfsUsedPercent()) - (d2.getDfsUsedPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_PERCENT_REMAINING:
ddbl=((d1.getRemainingPercent()) - (d2.getRemainingPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_BLOCKS:
ret=d1.numBlocks() - d2.numBlocks();
break;
case FIELD_ADMIN_STATE:
ret=d1.getAdminState().toString().compareTo(d2.getAdminState().toString());
break;
case FIELD_DECOMMISSIONED:
ret=DFSUtil.DECOM_COMPARATOR.compare(d1,d2);
break;
case FIELD_NAME:
ret=d1.getHostName().compareTo(d2.getHostName());
break;
case FIELD_BLOCKPOOL_USED:
dlong=d1.getBlockPoolUsed() - d2.getBlockPoolUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERBLOCKPOOL_USED:
ddbl=d1.getBlockPoolUsedPercent() - d2.getBlockPoolUsedPercent();
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_FAILED_VOLUMES:
int dint=d1.getVolumeFailures() - d2.getVolumeFailures();
ret=(dint < 0) ? -1 : ((dint > 0) ? 1 : 0);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
return (sortOrder == SORT_ORDER_DSC) ? -ret : ret;
}"
57835,"public static void sortNodeList(final List<DatanodeDescriptor> nodes,String field,String order){
class NodeComapare implements Comparator<DatanodeDescriptor> {
    static final int FIELD_NAME=1, FIELD_LAST_CONTACT=2, FIELD_BLOCKS=3, FIELD_CAPACITY=4, FIELD_USED=5, FIELD_PERCENT_USED=6, FIELD_NONDFS_USED=7, FIELD_REMAINING=8, FIELD_PERCENT_REMAINING=9, FIELD_ADMIN_STATE=10, FIELD_DECOMMISSIONED=11, FIELD_BLOCKPOOL_USED=12, FIELD_PERBLOCKPOOL_USED=13, FIELD_FAILED_VOLUMES=14, SORT_ORDER_ASC=1, SORT_ORDER_DSC=2;
    int sortField=FIELD_NAME;
    int sortOrder=SORT_ORDER_ASC;
    public NodeComapare(    String field,    String order){
      if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_LAST_CONTACT;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_CAPACITY;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_NONDFS_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_REMAINING;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_PERCENT_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_PERCENT_REMAINING;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_BLOCKS;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_ADMIN_STATE;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_DECOMMISSIONED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_BLOCKPOOL_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_PERBLOCKPOOL_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_FAILED_VOLUMES;
      }
 else {
        sortField=FIELD_NAME;
      }
      if (order.equals(""String_Node_Str"")) {
        sortOrder=SORT_ORDER_DSC;
      }
 else {
        sortOrder=SORT_ORDER_ASC;
      }
    }
    @Override public int compare(    DatanodeDescriptor d1,    DatanodeDescriptor d2){
      int ret=0;
switch (sortField) {
case FIELD_LAST_CONTACT:
        ret=(int)(d2.getLastUpdate() - d1.getLastUpdate());
      break;
case FIELD_CAPACITY:
    long dlong=d1.getCapacity() - d2.getCapacity();
  ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_USED:
dlong=d1.getDfsUsed() - d2.getDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_NONDFS_USED:
dlong=d1.getNonDfsUsed() - d2.getNonDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_REMAINING:
dlong=d1.getRemaining() - d2.getRemaining();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERCENT_USED:
double ddbl=((d1.getDfsUsedPercent()) - (d2.getDfsUsedPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_PERCENT_REMAINING:
ddbl=((d1.getRemainingPercent()) - (d2.getRemainingPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_BLOCKS:
ret=d1.numBlocks() - d2.numBlocks();
break;
case FIELD_ADMIN_STATE:
ret=d1.getAdminState().toString().compareTo(d2.getAdminState().toString());
break;
case FIELD_DECOMMISSIONED:
ret=DFSUtil.DECOM_COMPARATOR.compare(d1,d2);
break;
case FIELD_NAME:
ret=d1.getHostName().compareTo(d2.getHostName());
break;
case FIELD_BLOCKPOOL_USED:
dlong=d1.getBlockPoolUsed() - d2.getBlockPoolUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERBLOCKPOOL_USED:
ddbl=d1.getBlockPoolUsedPercent() - d2.getBlockPoolUsedPercent();
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_FAILED_VOLUMES:
int dint=d1.getVolumeFailures() - d2.getVolumeFailures();
ret=(dint < 0) ? -1 : ((dint > 0) ? 1 : 0);
break;
}
return (sortOrder == SORT_ORDER_DSC) ? -ret : ret;
}
}
Collections.sort(nodes,new NodeComapare(field,order));
}","public static void sortNodeList(final List<DatanodeDescriptor> nodes,String field,String order){
class NodeComapare implements Comparator<DatanodeDescriptor> {
    static final int FIELD_NAME=1, FIELD_LAST_CONTACT=2, FIELD_BLOCKS=3, FIELD_CAPACITY=4, FIELD_USED=5, FIELD_PERCENT_USED=6, FIELD_NONDFS_USED=7, FIELD_REMAINING=8, FIELD_PERCENT_REMAINING=9, FIELD_ADMIN_STATE=10, FIELD_DECOMMISSIONED=11, FIELD_BLOCKPOOL_USED=12, FIELD_PERBLOCKPOOL_USED=13, FIELD_FAILED_VOLUMES=14, SORT_ORDER_ASC=1, SORT_ORDER_DSC=2;
    int sortField=FIELD_NAME;
    int sortOrder=SORT_ORDER_ASC;
    public NodeComapare(    String field,    String order){
      if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_LAST_CONTACT;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_CAPACITY;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_NONDFS_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_REMAINING;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_PERCENT_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_PERCENT_REMAINING;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_BLOCKS;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_ADMIN_STATE;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_DECOMMISSIONED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_BLOCKPOOL_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_PERBLOCKPOOL_USED;
      }
 else       if (field.equals(""String_Node_Str"")) {
        sortField=FIELD_FAILED_VOLUMES;
      }
 else {
        sortField=FIELD_NAME;
      }
      if (order.equals(""String_Node_Str"")) {
        sortOrder=SORT_ORDER_DSC;
      }
 else {
        sortOrder=SORT_ORDER_ASC;
      }
    }
    @Override public int compare(    DatanodeDescriptor d1,    DatanodeDescriptor d2){
      int ret=0;
switch (sortField) {
case FIELD_LAST_CONTACT:
        ret=(int)(d2.getLastUpdate() - d1.getLastUpdate());
      break;
case FIELD_CAPACITY:
    long dlong=d1.getCapacity() - d2.getCapacity();
  ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_USED:
dlong=d1.getDfsUsed() - d2.getDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_NONDFS_USED:
dlong=d1.getNonDfsUsed() - d2.getNonDfsUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_REMAINING:
dlong=d1.getRemaining() - d2.getRemaining();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERCENT_USED:
double ddbl=((d1.getDfsUsedPercent()) - (d2.getDfsUsedPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_PERCENT_REMAINING:
ddbl=((d1.getRemainingPercent()) - (d2.getRemainingPercent()));
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_BLOCKS:
ret=d1.numBlocks() - d2.numBlocks();
break;
case FIELD_ADMIN_STATE:
ret=d1.getAdminState().toString().compareTo(d2.getAdminState().toString());
break;
case FIELD_DECOMMISSIONED:
ret=DFSUtil.DECOM_COMPARATOR.compare(d1,d2);
break;
case FIELD_NAME:
ret=d1.getHostName().compareTo(d2.getHostName());
break;
case FIELD_BLOCKPOOL_USED:
dlong=d1.getBlockPoolUsed() - d2.getBlockPoolUsed();
ret=(dlong < 0) ? -1 : ((dlong > 0) ? 1 : 0);
break;
case FIELD_PERBLOCKPOOL_USED:
ddbl=d1.getBlockPoolUsedPercent() - d2.getBlockPoolUsedPercent();
ret=(ddbl < 0) ? -1 : ((ddbl > 0) ? 1 : 0);
break;
case FIELD_FAILED_VOLUMES:
int dint=d1.getVolumeFailures() - d2.getVolumeFailures();
ret=(dint < 0) ? -1 : ((dint > 0) ? 1 : 0);
break;
default :
throw new IllegalArgumentException(""String_Node_Str"");
}
return (sortOrder == SORT_ORDER_DSC) ? -ret : ret;
}
}
Collections.sort(nodes,new NodeComapare(field,order));
}"
57836,"public static DatanodeInfo bestNode(DatanodeInfo[] nodes,boolean doRandom,Configuration conf) throws IOException {
  TreeSet<DatanodeInfo> deadNodes=new TreeSet<DatanodeInfo>();
  DatanodeInfo chosenNode=null;
  int failures=0;
  Socket s=null;
  int index=-1;
  if (nodes == null || nodes.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  while (s == null) {
    if (chosenNode == null) {
      do {
        if (doRandom) {
          index=DFSUtil.getRandom().nextInt(nodes.length);
        }
 else {
          index++;
        }
        chosenNode=nodes[index];
      }
 while (deadNodes.contains(chosenNode));
    }
    chosenNode=nodes[index];
    InetSocketAddress targetAddr=NetUtils.createSocketAddr(chosenNode.getInfoAddr());
    try {
      s=NetUtils.getDefaultSocketFactory(conf).createSocket();
      s.connect(targetAddr,HdfsServerConstants.READ_TIMEOUT);
      s.setSoTimeout(HdfsServerConstants.READ_TIMEOUT);
    }
 catch (    IOException e) {
      deadNodes.add(chosenNode);
      s.close();
      s=null;
      failures++;
    }
    if (failures == nodes.length)     throw new IOException(""String_Node_Str"");
  }
  s.close();
  return chosenNode;
}","public static DatanodeInfo bestNode(DatanodeInfo[] nodes,boolean doRandom,Configuration conf) throws IOException {
  TreeSet<DatanodeInfo> deadNodes=new TreeSet<DatanodeInfo>();
  DatanodeInfo chosenNode=null;
  int failures=0;
  Socket s=null;
  int index=-1;
  if (nodes == null || nodes.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  while (s == null) {
    if (chosenNode == null) {
      do {
        if (doRandom) {
          index=DFSUtil.getRandom().nextInt(nodes.length);
        }
 else {
          index++;
        }
        chosenNode=nodes[index];
      }
 while (deadNodes.contains(chosenNode));
    }
    chosenNode=nodes[index];
    InetSocketAddress targetAddr=NetUtils.createSocketAddr(chosenNode.getInfoAddr());
    try {
      s=NetUtils.getDefaultSocketFactory(conf).createSocket();
      s.connect(targetAddr,HdfsServerConstants.READ_TIMEOUT);
      s.setSoTimeout(HdfsServerConstants.READ_TIMEOUT);
    }
 catch (    IOException e) {
      deadNodes.add(chosenNode);
      IOUtils.closeSocket(s);
      s=null;
      failures++;
    }
    if (failures == nodes.length)     throw new IOException(""String_Node_Str"");
  }
  s.close();
  return chosenNode;
}"
57837,"static void generateDirectoryStructure(JspWriter out,HttpServletRequest req,HttpServletResponse resp,Configuration conf) throws IOException, InterruptedException {
  final String dir=JspHelper.validatePath(StringEscapeUtils.unescapeHtml(req.getParameter(""String_Node_Str"")));
  if (dir == null) {
    out.print(""String_Node_Str"");
    return;
  }
  String tokenString=req.getParameter(JspHelper.DELEGATION_PARAMETER_NAME);
  UserGroupInformation ugi=JspHelper.getUGI(req,conf);
  String namenodeInfoPortStr=req.getParameter(""String_Node_Str"");
  int namenodeInfoPort=-1;
  if (namenodeInfoPortStr != null)   namenodeInfoPort=Integer.parseInt(namenodeInfoPortStr);
  final String nnAddr=req.getParameter(JspHelper.NAMENODE_ADDRESS);
  if (nnAddr == null) {
    out.print(JspHelper.NAMENODE_ADDRESS + ""String_Node_Str"");
    return;
  }
  DFSClient dfs=getDFSClient(ugi,nnAddr,conf);
  String target=dir;
  final HdfsFileStatus targetStatus=dfs.getFileInfo(target);
  if (targetStatus == null) {
    out.print(""String_Node_Str"" + StringEscapeUtils.escapeHtml(target) + ""String_Node_Str"");
    JspHelper.printGotoForm(out,namenodeInfoPort,tokenString,target,nnAddr);
  }
 else {
    if (!targetStatus.isDir()) {
      List<LocatedBlock> blocks=dfs.getNamenode().getBlockLocations(dir,0,1).getLocatedBlocks();
      LocatedBlock firstBlock=null;
      DatanodeInfo[] locations=null;
      if (blocks.size() > 0) {
        firstBlock=blocks.get(0);
        locations=firstBlock.getLocations();
      }
      if (locations == null || locations.length == 0) {
        out.print(""String_Node_Str"");
      }
 else {
        DatanodeInfo chosenNode=JspHelper.bestNode(firstBlock,conf);
        String fqdn=canonicalize(chosenNode.getIpAddr());
        int datanodePort=chosenNode.getXferPort();
        String redirectLocation=HttpConfig.getSchemePrefix() + fqdn + ""String_Node_Str""+ chosenNode.getInfoPort()+ ""String_Node_Str""+ firstBlock.getBlock().getBlockId()+ ""String_Node_Str""+ firstBlock.getBlock().getNumBytes()+ ""String_Node_Str""+ firstBlock.getBlock().getGenerationStamp()+ ""String_Node_Str""+ URLEncoder.encode(dir,""String_Node_Str"")+ ""String_Node_Str""+ datanodePort+ ""String_Node_Str""+ namenodeInfoPort+ JspHelper.getDelegationTokenUrlParam(tokenString)+ JspHelper.getUrlParam(JspHelper.NAMENODE_ADDRESS,nnAddr);
        resp.sendRedirect(redirectLocation);
      }
      return;
    }
    String[] headings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    out.print(""String_Node_Str"");
    JspHelper.printPathWithLinks(dir,out,namenodeInfoPort,tokenString,nnAddr);
    out.print(""String_Node_Str"");
    JspHelper.printGotoForm(out,namenodeInfoPort,tokenString,dir,nnAddr);
    out.print(""String_Node_Str"");
    File f=new File(dir);
    String parent;
    if ((parent=f.getParent()) != null)     out.print(""String_Node_Str"" + req.getRequestURL() + ""String_Node_Str""+ parent+ ""String_Node_Str""+ namenodeInfoPort+ JspHelper.getDelegationTokenUrlParam(tokenString)+ JspHelper.getUrlParam(JspHelper.NAMENODE_ADDRESS,nnAddr)+ ""String_Node_Str"");
    DirectoryListing thisListing=dfs.listPaths(target,HdfsFileStatus.EMPTY_NAME);
    if (thisListing == null || thisListing.getPartialListing().length == 0) {
      out.print(""String_Node_Str"");
    }
 else {
      JspHelper.addTableHeader(out);
      int row=0;
      JspHelper.addTableRow(out,headings,row++);
      String cols[]=new String[headings.length];
      do {
        HdfsFileStatus[] files=thisListing.getPartialListing();
        for (int i=0; i < files.length; i++) {
          String localFileName=files[i].getLocalName();
          if (!files[i].isDir()) {
            cols[1]=""String_Node_Str"";
            cols[2]=StringUtils.byteDesc(files[i].getLen());
            cols[3]=Short.toString(files[i].getReplication());
            cols[4]=StringUtils.byteDesc(files[i].getBlockSize());
          }
 else {
            cols[1]=""String_Node_Str"";
            cols[2]=""String_Node_Str"";
            cols[3]=""String_Node_Str"";
            cols[4]=""String_Node_Str"";
          }
          String datanodeUrl=req.getRequestURL() + ""String_Node_Str"" + URLEncoder.encode(files[i].getFullName(target),""String_Node_Str"")+ ""String_Node_Str""+ namenodeInfoPort+ JspHelper.getDelegationTokenUrlParam(tokenString)+ JspHelper.getUrlParam(JspHelper.NAMENODE_ADDRESS,nnAddr);
          cols[0]=""String_Node_Str"" + datanodeUrl + ""String_Node_Str""+ HtmlQuoting.quoteHtmlChars(localFileName)+ ""String_Node_Str"";
          cols[5]=lsDateFormat.format(new Date((files[i].getModificationTime())));
          cols[6]=files[i].getPermission().toString();
          cols[7]=files[i].getOwner();
          cols[8]=files[i].getGroup();
          JspHelper.addTableRow(out,cols,row++);
        }
        if (!thisListing.hasMore()) {
          break;
        }
        thisListing=dfs.listPaths(target,thisListing.getLastName());
      }
 while (thisListing != null);
      JspHelper.addTableFooter(out);
    }
  }
  out.print(""String_Node_Str"" + HttpConfig.getSchemePrefix() + canonicalize(nnAddr)+ ""String_Node_Str""+ namenodeInfoPort+ ""String_Node_Str"");
  dfs.close();
}","static void generateDirectoryStructure(JspWriter out,HttpServletRequest req,HttpServletResponse resp,Configuration conf) throws IOException, InterruptedException {
  final String dir=JspHelper.validatePath(StringEscapeUtils.unescapeHtml(req.getParameter(""String_Node_Str"")));
  if (dir == null) {
    out.print(""String_Node_Str"");
    return;
  }
  String tokenString=req.getParameter(JspHelper.DELEGATION_PARAMETER_NAME);
  UserGroupInformation ugi=JspHelper.getUGI(req,conf);
  String namenodeInfoPortStr=req.getParameter(""String_Node_Str"");
  int namenodeInfoPort=-1;
  if (namenodeInfoPortStr != null)   namenodeInfoPort=Integer.parseInt(namenodeInfoPortStr);
  final String nnAddr=req.getParameter(JspHelper.NAMENODE_ADDRESS);
  if (nnAddr == null) {
    out.print(JspHelper.NAMENODE_ADDRESS + ""String_Node_Str"");
    return;
  }
  DFSClient dfs=getDFSClient(ugi,nnAddr,conf);
  String target=dir;
  final HdfsFileStatus targetStatus=dfs.getFileInfo(target);
  if (targetStatus == null) {
    out.print(""String_Node_Str"" + StringEscapeUtils.escapeHtml(target) + ""String_Node_Str"");
    JspHelper.printGotoForm(out,namenodeInfoPort,tokenString,target,nnAddr);
  }
 else {
    if (!targetStatus.isDir()) {
      List<LocatedBlock> blocks=dfs.getNamenode().getBlockLocations(dir,0,1).getLocatedBlocks();
      LocatedBlock firstBlock=null;
      DatanodeInfo[] locations=null;
      if (blocks.size() > 0) {
        firstBlock=blocks.get(0);
        locations=firstBlock.getLocations();
      }
      if (locations == null || locations.length == 0) {
        out.print(""String_Node_Str"");
      }
 else {
        DatanodeInfo chosenNode=JspHelper.bestNode(firstBlock,conf);
        String fqdn=canonicalize(chosenNode.getIpAddr());
        int datanodePort=chosenNode.getXferPort();
        String redirectLocation=HttpConfig.getSchemePrefix() + fqdn + ""String_Node_Str""+ chosenNode.getInfoPort()+ ""String_Node_Str""+ firstBlock.getBlock().getBlockId()+ ""String_Node_Str""+ firstBlock.getBlock().getNumBytes()+ ""String_Node_Str""+ firstBlock.getBlock().getGenerationStamp()+ ""String_Node_Str""+ URLEncoder.encode(dir,""String_Node_Str"")+ ""String_Node_Str""+ datanodePort+ ""String_Node_Str""+ namenodeInfoPort+ JspHelper.getDelegationTokenUrlParam(tokenString)+ JspHelper.getUrlParam(JspHelper.NAMENODE_ADDRESS,nnAddr);
        resp.sendRedirect(redirectLocation);
      }
      return;
    }
    String[] headings={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    out.print(""String_Node_Str"");
    JspHelper.printPathWithLinks(dir,out,namenodeInfoPort,tokenString,nnAddr);
    out.print(""String_Node_Str"");
    JspHelper.printGotoForm(out,namenodeInfoPort,tokenString,dir,nnAddr);
    out.print(""String_Node_Str"");
    File f=new File(dir);
    String parent;
    if ((parent=f.getParent()) != null)     out.print(""String_Node_Str"" + req.getRequestURL() + ""String_Node_Str""+ parent+ ""String_Node_Str""+ namenodeInfoPort+ JspHelper.getDelegationTokenUrlParam(tokenString)+ JspHelper.getUrlParam(JspHelper.NAMENODE_ADDRESS,nnAddr)+ ""String_Node_Str"");
    DirectoryListing thisListing=dfs.listPaths(target,HdfsFileStatus.EMPTY_NAME);
    if (thisListing == null || thisListing.getPartialListing().length == 0) {
      out.print(""String_Node_Str"");
    }
 else {
      JspHelper.addTableHeader(out);
      int row=0;
      JspHelper.addTableRow(out,headings,row++);
      String cols[]=new String[headings.length];
      do {
        HdfsFileStatus[] files=thisListing.getPartialListing();
        for (int i=0; i < files.length; i++) {
          String localFileName=files[i].getLocalName();
          if (!files[i].isDir()) {
            cols[1]=""String_Node_Str"";
            cols[2]=StringUtils.byteDesc(files[i].getLen());
            cols[3]=Short.toString(files[i].getReplication());
            cols[4]=StringUtils.byteDesc(files[i].getBlockSize());
          }
 else {
            cols[1]=""String_Node_Str"";
            cols[2]=""String_Node_Str"";
            cols[3]=""String_Node_Str"";
            cols[4]=""String_Node_Str"";
          }
          String datanodeUrl=req.getRequestURL() + ""String_Node_Str"" + URLEncoder.encode(files[i].getFullName(target),""String_Node_Str"")+ ""String_Node_Str""+ namenodeInfoPort+ JspHelper.getDelegationTokenUrlParam(tokenString)+ JspHelper.getUrlParam(JspHelper.NAMENODE_ADDRESS,nnAddr);
          cols[0]=""String_Node_Str"" + datanodeUrl + ""String_Node_Str""+ HtmlQuoting.quoteHtmlChars(localFileName)+ ""String_Node_Str"";
          cols[5]=new SimpleDateFormat(""String_Node_Str"").format(new Date((files[i].getModificationTime())));
          cols[6]=files[i].getPermission().toString();
          cols[7]=files[i].getOwner();
          cols[8]=files[i].getGroup();
          JspHelper.addTableRow(out,cols,row++);
        }
        if (!thisListing.hasMore()) {
          break;
        }
        thisListing=dfs.listPaths(target,thisListing.getLastName());
      }
 while (thisListing != null);
      JspHelper.addTableFooter(out);
    }
  }
  out.print(""String_Node_Str"" + HttpConfig.getSchemePrefix() + canonicalize(nnAddr)+ ""String_Node_Str""+ namenodeInfoPort+ ""String_Node_Str"");
  dfs.close();
}"
57838,"/** 
 * Create an object with a data input stream and a checksum input stream. 
 */
public ReplicaInputStreams(InputStream dataIn,InputStream checksumIn){
  this.dataIn=dataIn;
  this.checksumIn=checksumIn;
}","/** 
 * Create an object with a data input stream and a checksum input stream. 
 */
public ReplicaInputStreams(FileDescriptor dataFd,FileDescriptor checksumFd){
  this.dataIn=new FileInputStream(dataFd);
  this.checksumIn=new FileInputStream(checksumFd);
}"
57839,"/** 
 * Returns handles to the block file and its metadata file
 */
@Override public synchronized ReplicaInputStreams getTmpInputStreams(ExtendedBlock b,long blkOffset,long ckoff) throws IOException {
  ReplicaInfo info=getReplicaInfo(b);
  File blockFile=info.getBlockFile();
  RandomAccessFile blockInFile=new RandomAccessFile(blockFile,""String_Node_Str"");
  if (blkOffset > 0) {
    blockInFile.seek(blkOffset);
  }
  File metaFile=info.getMetaFile();
  RandomAccessFile metaInFile=new RandomAccessFile(metaFile,""String_Node_Str"");
  if (ckoff > 0) {
    metaInFile.seek(ckoff);
  }
  return new ReplicaInputStreams(new FileInputStream(blockInFile.getFD()),new FileInputStream(metaInFile.getFD()));
}","/** 
 * Returns handles to the block file and its metadata file
 */
@Override public synchronized ReplicaInputStreams getTmpInputStreams(ExtendedBlock b,long blkOffset,long ckoff) throws IOException {
  ReplicaInfo info=getReplicaInfo(b);
  File blockFile=info.getBlockFile();
  RandomAccessFile blockInFile=new RandomAccessFile(blockFile,""String_Node_Str"");
  if (blkOffset > 0) {
    blockInFile.seek(blkOffset);
  }
  File metaFile=info.getMetaFile();
  RandomAccessFile metaInFile=new RandomAccessFile(metaFile,""String_Node_Str"");
  if (ckoff > 0) {
    metaInFile.seek(ckoff);
  }
  return new ReplicaInputStreams(blockInFile.getFD(),metaInFile.getFD());
}"
57840,"boolean setSafeMode(SafeModeAction action) throws IOException {
  if (action != SafeModeAction.SAFEMODE_GET) {
    checkSuperuserPrivilege();
switch (action) {
case SAFEMODE_LEAVE:
      leaveSafeMode();
    break;
case SAFEMODE_ENTER:
  enterSafeMode(false);
break;
}
}
return isInSafeMode();
}","boolean setSafeMode(SafeModeAction action) throws IOException {
  if (action != SafeModeAction.SAFEMODE_GET) {
    checkSuperuserPrivilege();
switch (action) {
case SAFEMODE_LEAVE:
      leaveSafeMode();
    break;
case SAFEMODE_ENTER:
  enterSafeMode(false);
break;
default :
LOG.error(""String_Node_Str"");
}
}
return isInSafeMode();
}"
57841,"@Override public boolean equals(Object o){
  if (!(o instanceof ReceivedDeletedBlockInfo)) {
    return false;
  }
  ReceivedDeletedBlockInfo other=(ReceivedDeletedBlockInfo)o;
  return this.block.equals(other.getBlock()) && this.status == other.status && (this.delHints == other.delHints || this.delHints != null && this.delHints.equals(other.delHints));
}","@Override public boolean equals(Object o){
  if (!(o instanceof ReceivedDeletedBlockInfo)) {
    return false;
  }
  ReceivedDeletedBlockInfo other=(ReceivedDeletedBlockInfo)o;
  return this.block.equals(other.getBlock()) && this.status == other.status && this.delHints != null && this.delHints.equals(other.delHints);
}"
57842,"@Override public Long apply(RemoteEditLog log){
  return log.getStartTxId();
}","@Override public Long apply(RemoteEditLog log){
  if (null == log) {
    return HdfsConstants.INVALID_TXID;
  }
  return log.getStartTxId();
}"
57843,"/** 
 * get single value by key
 */
public String getValue(String key) throws Exception {
  Object val=null;
  for (  ObjectName oname : hadoopObjectNames) {
    try {
      val=mbsc.getAttribute(oname,key);
    }
 catch (    AttributeNotFoundException anfe) {
      continue;
    }
catch (    ReflectionException re) {
      if (re.getCause() instanceof NoSuchMethodException) {
        continue;
      }
    }
    err(""String_Node_Str"" + key + ""String_Node_Str""+ val.getClass()+ ""String_Node_Str""+ val);
    break;
  }
  return (val == null) ? ""String_Node_Str"" : val.toString();
}","/** 
 * get single value by key
 */
public String getValue(String key) throws Exception {
  Object val=null;
  for (  ObjectName oname : hadoopObjectNames) {
    try {
      val=mbsc.getAttribute(oname,key);
    }
 catch (    AttributeNotFoundException anfe) {
      continue;
    }
catch (    ReflectionException re) {
      if (re.getCause() instanceof NoSuchMethodException) {
        continue;
      }
    }
    err(""String_Node_Str"" + key + ""String_Node_Str""+ (val == null ? ""String_Node_Str"" : val.getClass())+ ""String_Node_Str""+ val);
    break;
  }
  return (val == null) ? ""String_Node_Str"" : val.toString();
}"
57844,"private long doCopy(FileStatus sourceFileStatus,Path target,Mapper.Context context,EnumSet<FileAttribute> fileAttributes) throws IOException {
  Path tmpTargetPath=getTmpFile(target,context);
  final Configuration configuration=context.getConfiguration();
  FileSystem targetFS=target.getFileSystem(configuration);
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + sourceFileStatus.getPath() + ""String_Node_Str""+ target);
      LOG.debug(""String_Node_Str"" + tmpTargetPath);
    }
    FileSystem sourceFS=sourceFileStatus.getPath().getFileSystem(configuration);
    long bytesRead=copyToTmpFile(tmpTargetPath,targetFS,sourceFileStatus,context,fileAttributes);
    compareFileLengths(sourceFileStatus,tmpTargetPath,configuration,bytesRead);
    if (bytesRead != 0)     compareCheckSums(sourceFS,sourceFileStatus.getPath(),targetFS,tmpTargetPath);
    promoteTmpToTarget(tmpTargetPath,target,targetFS);
    return bytesRead;
  }
  finally {
    if (targetFS.exists(tmpTargetPath))     targetFS.delete(tmpTargetPath,false);
  }
}","private long doCopy(FileStatus sourceFileStatus,Path target,Mapper.Context context,EnumSet<FileAttribute> fileAttributes) throws IOException {
  Path tmpTargetPath=getTmpFile(target,context);
  final Configuration configuration=context.getConfiguration();
  FileSystem targetFS=target.getFileSystem(configuration);
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + sourceFileStatus.getPath() + ""String_Node_Str""+ target);
      LOG.debug(""String_Node_Str"" + tmpTargetPath);
    }
    FileSystem sourceFS=sourceFileStatus.getPath().getFileSystem(configuration);
    long bytesRead=copyToTmpFile(tmpTargetPath,targetFS,sourceFileStatus,context,fileAttributes);
    compareFileLengths(sourceFileStatus,tmpTargetPath,configuration,bytesRead);
    if (bytesRead != 0) {
      compareCheckSums(sourceFS,sourceFileStatus.getPath(),targetFS,tmpTargetPath);
    }
    promoteTmpToTarget(tmpTargetPath,target,targetFS);
    return bytesRead;
  }
  finally {
    if (targetFS.exists(tmpTargetPath))     targetFS.delete(tmpTargetPath,false);
  }
}"
57845,"/** 
 * Get block location info about file getBlockLocations() returns a list of hostnames that store  data for a specific file region.  It returns a set of hostnames for every block within the indicated region. This function is very useful when writing code that considers data-placement when performing operations.  For example, the MapReduce system tries to schedule tasks on the same machines as the data-block the task processes. 
 */
public BlockLocation[] getBlockLocations(String src,long start,long length) throws IOException, UnresolvedLinkException {
  LocatedBlocks blocks=callGetBlockLocations(namenode,src,start,length);
  return DFSUtil.locatedBlocks2Locations(blocks);
}","/** 
 * Get block location info about file getBlockLocations() returns a list of hostnames that store  data for a specific file region.  It returns a set of hostnames for every block within the indicated region. This function is very useful when writing code that considers data-placement when performing operations.  For example, the MapReduce system tries to schedule tasks on the same machines as the data-block the task processes. 
 */
public BlockLocation[] getBlockLocations(String src,long start,long length) throws IOException, UnresolvedLinkException {
  LocatedBlocks blocks=getLocatedBlocks(src,start,length);
  return DFSUtil.locatedBlocks2Locations(blocks);
}"
57846,"/** 
 * Fetch a block from namenode and cache it 
 */
private synchronized void fetchBlockAt(long offset) throws IOException {
  int targetBlockIdx=locatedBlocks.findBlock(offset);
  if (targetBlockIdx < 0) {
    targetBlockIdx=LocatedBlocks.getInsertIndex(targetBlockIdx);
  }
  LocatedBlocks newBlocks;
  newBlocks=DFSClient.callGetBlockLocations(dfsClient.namenode,src,offset,prefetchSize);
  if (newBlocks == null) {
    throw new IOException(""String_Node_Str"" + offset);
  }
  locatedBlocks.insertRange(targetBlockIdx,newBlocks.getLocatedBlocks());
}","/** 
 * Fetch a block from namenode and cache it 
 */
private synchronized void fetchBlockAt(long offset) throws IOException {
  int targetBlockIdx=locatedBlocks.findBlock(offset);
  if (targetBlockIdx < 0) {
    targetBlockIdx=LocatedBlocks.getInsertIndex(targetBlockIdx);
  }
  LocatedBlocks newBlocks;
  newBlocks=dfsClient.getLocatedBlocks(src,offset,prefetchSize);
  if (newBlocks == null) {
    throw new IOException(""String_Node_Str"" + offset);
  }
  locatedBlocks.insertRange(targetBlockIdx,newBlocks.getLocatedBlocks());
}"
57847,"private long fetchLocatedBlocksAndGetLastBlockLength() throws IOException {
  LocatedBlocks newInfo=DFSClient.callGetBlockLocations(dfsClient.namenode,src,0,prefetchSize);
  if (DFSClient.LOG.isDebugEnabled()) {
    DFSClient.LOG.debug(""String_Node_Str"" + newInfo);
  }
  if (newInfo == null) {
    throw new IOException(""String_Node_Str"" + src);
  }
  if (locatedBlocks != null) {
    Iterator<LocatedBlock> oldIter=locatedBlocks.getLocatedBlocks().iterator();
    Iterator<LocatedBlock> newIter=newInfo.getLocatedBlocks().iterator();
    while (oldIter.hasNext() && newIter.hasNext()) {
      if (!oldIter.next().getBlock().equals(newIter.next().getBlock())) {
        throw new IOException(""String_Node_Str"" + src + ""String_Node_Str"");
      }
    }
  }
  locatedBlocks=newInfo;
  long lastBlockBeingWrittenLength=0;
  if (!locatedBlocks.isLastBlockComplete()) {
    final LocatedBlock last=locatedBlocks.getLastLocatedBlock();
    if (last != null) {
      if (last.getLocations().length == 0) {
        return -1;
      }
      final long len=readBlockLength(last);
      last.getBlock().setNumBytes(len);
      lastBlockBeingWrittenLength=len;
    }
  }
  currentNode=null;
  return lastBlockBeingWrittenLength;
}","private long fetchLocatedBlocksAndGetLastBlockLength() throws IOException {
  LocatedBlocks newInfo=dfsClient.getLocatedBlocks(src,0,prefetchSize);
  if (DFSClient.LOG.isDebugEnabled()) {
    DFSClient.LOG.debug(""String_Node_Str"" + newInfo);
  }
  if (newInfo == null) {
    throw new IOException(""String_Node_Str"" + src);
  }
  if (locatedBlocks != null) {
    Iterator<LocatedBlock> oldIter=locatedBlocks.getLocatedBlocks().iterator();
    Iterator<LocatedBlock> newIter=newInfo.getLocatedBlocks().iterator();
    while (oldIter.hasNext() && newIter.hasNext()) {
      if (!oldIter.next().getBlock().equals(newIter.next().getBlock())) {
        throw new IOException(""String_Node_Str"" + src + ""String_Node_Str"");
      }
    }
  }
  locatedBlocks=newInfo;
  long lastBlockBeingWrittenLength=0;
  if (!locatedBlocks.isLastBlockComplete()) {
    final LocatedBlock last=locatedBlocks.getLastLocatedBlock();
    if (last != null) {
      if (last.getLocations().length == 0) {
        return -1;
      }
      final long len=readBlockLength(last);
      last.getBlock().setNumBytes(len);
      lastBlockBeingWrittenLength=len;
    }
  }
  currentNode=null;
  return lastBlockBeingWrittenLength;
}"
57848,"/** 
 * Given the configuration for this node, return a Configuration object for the other node in an HA setup.
 * @param myConf the configuration of this node
 * @return the configuration of the other node in an HA setup
 */
public static Configuration getConfForOtherNode(Configuration myConf){
}","/** 
 * Given the configuration for this node, return a Configuration object for the other node in an HA setup.
 * @param myConf the configuration of this node
 * @return the configuration of the other node in an HA setup
 */
public static Configuration getConfForOtherNode(Configuration myConf){
  String nsId=DFSUtil.getNamenodeNameServiceId(myConf);
  String otherNn=getNameNodeIdOfOtherNode(myConf,nsId);
  Configuration confForOtherNode=new Configuration(myConf);
  NameNode.initializeGenericKeys(confForOtherNode,nsId,otherNn);
  return confForOtherNode;
}"
57849,"/** 
 * Initialize block keys 
 */
private synchronized void generateKeys(){
  if (!isMaster)   return;
  serialNo++;
  currentKey=new BlockKey(serialNo,System.currentTimeMillis() + 2 * keyUpdateInterval + tokenLifetime,generateSecret());
  serialNo++;
  nextKey=new BlockKey(serialNo,System.currentTimeMillis() + 3 * keyUpdateInterval + tokenLifetime,generateSecret());
  allKeys.put(currentKey.getKeyId(),currentKey);
  allKeys.put(nextKey.getKeyId(),nextKey);
}","/** 
 * Initialize block keys 
 */
private synchronized void generateKeys(){
  if (!isMaster)   return;
  setSerialNo(serialNo + 1);
  currentKey=new BlockKey(serialNo,System.currentTimeMillis() + 2 * keyUpdateInterval + tokenLifetime,generateSecret());
  setSerialNo(serialNo + 1);
  nextKey=new BlockKey(serialNo,System.currentTimeMillis() + 3 * keyUpdateInterval + tokenLifetime,generateSecret());
  allKeys.put(currentKey.getKeyId(),currentKey);
  allKeys.put(nextKey.getKeyId(),nextKey);
}"
57850,"/** 
 * Update block keys, only to be used in master mode
 */
synchronized boolean updateKeys() throws IOException {
  if (!isMaster)   return false;
  LOG.info(""String_Node_Str"");
  removeExpiredKeys();
  allKeys.put(currentKey.getKeyId(),new BlockKey(currentKey.getKeyId(),System.currentTimeMillis() + keyUpdateInterval + tokenLifetime,currentKey.getKey()));
  currentKey=new BlockKey(nextKey.getKeyId(),System.currentTimeMillis() + 2 * keyUpdateInterval + tokenLifetime,nextKey.getKey());
  allKeys.put(currentKey.getKeyId(),currentKey);
  serialNo++;
  nextKey=new BlockKey(serialNo,System.currentTimeMillis() + 3 * keyUpdateInterval + tokenLifetime,generateSecret());
  allKeys.put(nextKey.getKeyId(),nextKey);
  return true;
}","/** 
 * Update block keys, only to be used in master mode
 */
synchronized boolean updateKeys() throws IOException {
  if (!isMaster)   return false;
  LOG.info(""String_Node_Str"");
  removeExpiredKeys();
  allKeys.put(currentKey.getKeyId(),new BlockKey(currentKey.getKeyId(),System.currentTimeMillis() + keyUpdateInterval + tokenLifetime,currentKey.getKey()));
  currentKey=new BlockKey(nextKey.getKeyId(),System.currentTimeMillis() + 2 * keyUpdateInterval + tokenLifetime,nextKey.getKey());
  allKeys.put(currentKey.getKeyId(),currentKey);
  setSerialNo(serialNo + 1);
  nextKey=new BlockKey(serialNo,System.currentTimeMillis() + 3 * keyUpdateInterval + tokenLifetime,generateSecret());
  allKeys.put(nextKey.getKeyId(),nextKey);
  return true;
}"
57851,"/** 
 * Constructor
 * @param isMaster
 * @param keyUpdateInterval
 * @param tokenLifetime
 * @throws IOException
 */
public BlockTokenSecretManager(boolean isMaster,long keyUpdateInterval,long tokenLifetime) throws IOException {
  this.isMaster=isMaster;
  this.keyUpdateInterval=keyUpdateInterval;
  this.tokenLifetime=tokenLifetime;
  this.allKeys=new HashMap<Integer,BlockKey>();
  generateKeys();
}","private BlockTokenSecretManager(boolean isMaster,long keyUpdateInterval,long tokenLifetime){
  this.isMaster=isMaster;
  this.keyUpdateInterval=keyUpdateInterval;
  this.tokenLifetime=tokenLifetime;
  this.allKeys=new HashMap<Integer,BlockKey>();
}"
57852,"NameNodeConnector(URI nameNodeUri,Configuration conf) throws IOException {
  this.nameNodeUri=nameNodeUri;
  this.namenode=NameNodeProxies.createProxy(conf,nameNodeUri,NamenodeProtocol.class).getProxy();
  this.client=NameNodeProxies.createProxy(conf,nameNodeUri,ClientProtocol.class).getProxy();
  this.fs=FileSystem.get(nameNodeUri,conf);
  final NamespaceInfo namespaceinfo=namenode.versionRequest();
  this.blockpoolID=namespaceinfo.getBlockPoolID();
  final ExportedBlockKeys keys=namenode.getBlockKeys();
  this.isBlockTokenEnabled=keys.isBlockTokenEnabled();
  if (isBlockTokenEnabled) {
    long blockKeyUpdateInterval=keys.getKeyUpdateInterval();
    long blockTokenLifetime=keys.getTokenLifetime();
    LOG.info(""String_Node_Str"" + blockKeyUpdateInterval / (60 * 1000) + ""String_Node_Str"" + blockTokenLifetime / (60 * 1000) + ""String_Node_Str"");
    this.blockTokenSecretManager=new BlockTokenSecretManager(false,blockKeyUpdateInterval,blockTokenLifetime);
    this.blockTokenSecretManager.setKeys(keys);
    this.keyUpdaterInterval=blockKeyUpdateInterval / 4;
    LOG.info(""String_Node_Str"" + keyUpdaterInterval / (60 * 1000) + ""String_Node_Str"");
    this.keyupdaterthread=new Daemon(new BlockKeyUpdater());
    this.shouldRun=true;
    this.keyupdaterthread.start();
  }
  out=checkAndMarkRunningBalancer();
  if (out == null) {
    throw new IOException(""String_Node_Str"");
  }
}","NameNodeConnector(URI nameNodeUri,Configuration conf) throws IOException {
  this.nameNodeUri=nameNodeUri;
  this.namenode=NameNodeProxies.createProxy(conf,nameNodeUri,NamenodeProtocol.class).getProxy();
  this.client=NameNodeProxies.createProxy(conf,nameNodeUri,ClientProtocol.class).getProxy();
  this.fs=FileSystem.get(nameNodeUri,conf);
  final NamespaceInfo namespaceinfo=namenode.versionRequest();
  this.blockpoolID=namespaceinfo.getBlockPoolID();
  final ExportedBlockKeys keys=namenode.getBlockKeys();
  this.isBlockTokenEnabled=keys.isBlockTokenEnabled();
  if (isBlockTokenEnabled) {
    long blockKeyUpdateInterval=keys.getKeyUpdateInterval();
    long blockTokenLifetime=keys.getTokenLifetime();
    LOG.info(""String_Node_Str"" + blockKeyUpdateInterval / (60 * 1000) + ""String_Node_Str"" + blockTokenLifetime / (60 * 1000) + ""String_Node_Str"");
    this.blockTokenSecretManager=new BlockTokenSecretManager(blockKeyUpdateInterval,blockTokenLifetime);
    this.blockTokenSecretManager.addKeys(keys);
    this.keyUpdaterInterval=blockKeyUpdateInterval / 4;
    LOG.info(""String_Node_Str"" + keyUpdaterInterval / (60 * 1000) + ""String_Node_Str"");
    this.keyupdaterthread=new Daemon(new BlockKeyUpdater());
    this.shouldRun=true;
    this.keyupdaterthread.start();
  }
  out=checkAndMarkRunningBalancer();
  if (out == null) {
    throw new IOException(""String_Node_Str"");
  }
}"
57853,"public void run(){
  try {
    while (shouldRun) {
      try {
        blockTokenSecretManager.setKeys(namenode.getBlockKeys());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
      }
      Thread.sleep(keyUpdaterInterval);
    }
  }
 catch (  InterruptedException e) {
    LOG.debug(""String_Node_Str"",e);
  }
catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
    shouldRun=false;
  }
}","public void run(){
  try {
    while (shouldRun) {
      try {
        blockTokenSecretManager.addKeys(namenode.getBlockKeys());
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
      }
      Thread.sleep(keyUpdaterInterval);
    }
  }
 catch (  InterruptedException e) {
    LOG.debug(""String_Node_Str"",e);
  }
catch (  Throwable e) {
    LOG.error(""String_Node_Str"",e);
    shouldRun=false;
  }
}"
57854,"private static BlockTokenSecretManager createBlockTokenSecretManager(final Configuration conf) throws IOException {
  final boolean isEnabled=conf.getBoolean(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);
  LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + ""String_Node_Str"" + isEnabled);
  if (!isEnabled) {
    return null;
  }
  final long updateMin=conf.getLong(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);
  final long lifetimeMin=conf.getLong(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);
  LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY + ""String_Node_Str"" + updateMin+ ""String_Node_Str""+ DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY+ ""String_Node_Str""+ lifetimeMin+ ""String_Node_Str"");
  return new BlockTokenSecretManager(true,updateMin * 60 * 1000L,lifetimeMin * 60 * 1000L);
}","private static BlockTokenSecretManager createBlockTokenSecretManager(final Configuration conf) throws IOException {
  final boolean isEnabled=conf.getBoolean(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_DEFAULT);
  LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY + ""String_Node_Str"" + isEnabled);
  if (!isEnabled) {
    return null;
  }
  final long updateMin=conf.getLong(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_DEFAULT);
  final long lifetimeMin=conf.getLong(DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY,DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_DEFAULT);
  LOG.info(DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY + ""String_Node_Str"" + updateMin+ ""String_Node_Str""+ DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY+ ""String_Node_Str""+ lifetimeMin+ ""String_Node_Str"");
  String nsId=DFSUtil.getNamenodeNameServiceId(conf);
  boolean isHaEnabled=HAUtil.isHAEnabled(conf,nsId);
  if (isHaEnabled) {
    String thisNnId=HAUtil.getNameNodeId(conf,nsId);
    String otherNnId=HAUtil.getNameNodeIdOfOtherNode(conf,nsId);
    return new BlockTokenSecretManager(updateMin * 60 * 1000L,lifetimeMin * 60 * 1000L,thisNnId.compareTo(otherNnId) < 0 ? 0 : 1);
  }
 else {
    return new BlockTokenSecretManager(updateMin * 60 * 1000L,lifetimeMin * 60 * 1000L,0);
  }
}"
57855,"/** 
 * get the BlockTokenSecretManager 
 */
BlockTokenSecretManager getBlockTokenSecretManager(){
  return blockTokenSecretManager;
}","/** 
 * get the BlockTokenSecretManager 
 */
@VisibleForTesting public BlockTokenSecretManager getBlockTokenSecretManager(){
  return blockTokenSecretManager;
}"
57856,"private void transitionOtherNNActive() throws AccessControlException, ServiceFailedException, IOException {
  LOG.info(""String_Node_Str"");
  createHAProtocolProxy().transitionToActive();
  LOG.info(""String_Node_Str"");
}","private void transitionOtherNNActive() throws AccessControlException, ServiceFailedException, IOException {
  LOG.info(""String_Node_Str"");
  createHAProtocolProxy().transitionToActive(new StateChangeRequestInfo(RequestSource.REQUEST_BY_USER));
  LOG.info(""String_Node_Str"");
}"
57857,"/** 
 * Initializes the authentication filter. <p/> It instantiates and initializes the specified   {@link AuthenticationHandler}. <p/>
 * @param filterConfig filter configuration.
 * @throws ServletException thrown if the filter or the authentication handler could not be initialized properly.
 */
@Override public void init(FilterConfig filterConfig) throws ServletException {
  String configPrefix=filterConfig.getInitParameter(CONFIG_PREFIX);
  configPrefix=(configPrefix != null) ? configPrefix + ""String_Node_Str"" : ""String_Node_Str"";
  Properties config=getConfiguration(configPrefix,filterConfig);
  String authHandlerName=config.getProperty(AUTH_TYPE,null);
  String authHandlerClassName;
  if (authHandlerName == null) {
    throw new ServletException(""String_Node_Str"");
  }
  if (authHandlerName.equals(""String_Node_Str"")) {
    authHandlerClassName=PseudoAuthenticationHandler.class.getName();
  }
 else   if (authHandlerName.equals(""String_Node_Str"")) {
    authHandlerClassName=KerberosAuthenticationHandler.class.getName();
  }
 else {
    authHandlerClassName=authHandlerName;
  }
  try {
    Class klass=Thread.currentThread().getContextClassLoader().loadClass(authHandlerClassName);
    authHandler=(AuthenticationHandler)klass.newInstance();
    authHandler.init(config);
  }
 catch (  ClassNotFoundException ex) {
    throw new ServletException(ex);
  }
catch (  InstantiationException ex) {
    throw new ServletException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new ServletException(ex);
  }
  String signatureSecret=config.getProperty(configPrefix + SIGNATURE_SECRET);
  if (signatureSecret == null) {
    signatureSecret=Long.toString(new Random(System.currentTimeMillis()).nextLong());
    randomSecret=true;
    LOG.warn(""String_Node_Str"");
  }
  signer=new Signer(signatureSecret.getBytes());
  validity=Long.parseLong(config.getProperty(AUTH_TOKEN_VALIDITY,""String_Node_Str"")) * 1000;
  cookieDomain=config.getProperty(COOKIE_DOMAIN,null);
  cookiePath=config.getProperty(COOKIE_PATH,null);
}","/** 
 * Initializes the authentication filter. <p/> It instantiates and initializes the specified   {@link AuthenticationHandler}. <p/>
 * @param filterConfig filter configuration.
 * @throws ServletException thrown if the filter or the authentication handler could not be initialized properly.
 */
@Override public void init(FilterConfig filterConfig) throws ServletException {
  String configPrefix=filterConfig.getInitParameter(CONFIG_PREFIX);
  configPrefix=(configPrefix != null) ? configPrefix + ""String_Node_Str"" : ""String_Node_Str"";
  Properties config=getConfiguration(configPrefix,filterConfig);
  String authHandlerName=config.getProperty(AUTH_TYPE,null);
  String authHandlerClassName;
  if (authHandlerName == null) {
    throw new ServletException(""String_Node_Str"");
  }
  if (authHandlerName.equals(""String_Node_Str"")) {
    authHandlerClassName=PseudoAuthenticationHandler.class.getName();
  }
 else   if (authHandlerName.equals(""String_Node_Str"")) {
    authHandlerClassName=KerberosAuthenticationHandler.class.getName();
  }
 else {
    authHandlerClassName=authHandlerName;
  }
  try {
    Class<?> klass=Thread.currentThread().getContextClassLoader().loadClass(authHandlerClassName);
    authHandler=(AuthenticationHandler)klass.newInstance();
    authHandler.init(config);
  }
 catch (  ClassNotFoundException ex) {
    throw new ServletException(ex);
  }
catch (  InstantiationException ex) {
    throw new ServletException(ex);
  }
catch (  IllegalAccessException ex) {
    throw new ServletException(ex);
  }
  String signatureSecret=config.getProperty(configPrefix + SIGNATURE_SECRET);
  if (signatureSecret == null) {
    signatureSecret=Long.toString(RAN.nextLong());
    randomSecret=true;
    LOG.warn(""String_Node_Str"");
  }
  signer=new Signer(signatureSecret.getBytes());
  validity=Long.parseLong(config.getProperty(AUTH_TOKEN_VALIDITY,""String_Node_Str"")) * 1000;
  cookieDomain=config.getProperty(COOKIE_DOMAIN,null);
  cookiePath=config.getProperty(COOKIE_PATH,null);
}"
57858,"/** 
 * Returns the filtered configuration (only properties starting with the specified prefix). The property keys are also trimmed from the prefix. The returned   {@link Properties} object is used to initialized the{@link AuthenticationHandler}. <p/> This method can be overriden by subclasses to obtain the configuration from other configuration source than the web.xml file.
 * @param configPrefix configuration prefix to use for extracting configuration properties.
 * @param filterConfig filter configuration object
 * @return the configuration to be used with the {@link AuthenticationHandler} instance.
 * @throws ServletException thrown if the configuration could not be created.
 */
protected Properties getConfiguration(String configPrefix,FilterConfig filterConfig) throws ServletException {
  Properties props=new Properties();
  Enumeration names=filterConfig.getInitParameterNames();
  while (names.hasMoreElements()) {
    String name=(String)names.nextElement();
    if (name.startsWith(configPrefix)) {
      String value=filterConfig.getInitParameter(name);
      props.put(name.substring(configPrefix.length()),value);
    }
  }
  return props;
}","/** 
 * Returns the filtered configuration (only properties starting with the specified prefix). The property keys are also trimmed from the prefix. The returned   {@link Properties} object is used to initialized the{@link AuthenticationHandler}. <p/> This method can be overriden by subclasses to obtain the configuration from other configuration source than the web.xml file.
 * @param configPrefix configuration prefix to use for extracting configuration properties.
 * @param filterConfig filter configuration object
 * @return the configuration to be used with the {@link AuthenticationHandler} instance.
 * @throws ServletException thrown if the configuration could not be created.
 */
protected Properties getConfiguration(String configPrefix,FilterConfig filterConfig) throws ServletException {
  Properties props=new Properties();
  Enumeration<?> names=filterConfig.getInitParameterNames();
  while (names.hasMoreElements()) {
    String name=(String)names.nextElement();
    if (name.startsWith(configPrefix)) {
      String value=filterConfig.getInitParameter(name);
      props.put(name.substring(configPrefix.length()),value);
    }
  }
  return props;
}"
57859,"/** 
 * test listCorruptFileBlocks in DistributedFileSystem
 */
@Test public void testlistCorruptFileBlocksDFS() throws Exception {
  Configuration conf=new Configuration();
  conf.setLong(""String_Node_Str"",1000);
  conf.setInt(""String_Node_Str"",1);
  FileSystem fs=null;
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DistributedFileSystem dfs=(DistributedFileSystem)fs;
    DFSTestUtil util=new DFSTestUtil(""String_Node_Str"",3,1,1024);
    util.createFiles(fs,""String_Node_Str"");
    final NameNode namenode=cluster.getNameNode();
    RemoteIterator<Path> corruptFileBlocks=dfs.listCorruptFileBlocks(new Path(""String_Node_Str""));
    int numCorrupt=countPaths(corruptFileBlocks);
    assertTrue(numCorrupt == 0);
    File baseDir=new File(System.getProperty(""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
    for (int i=0; i < 8; i++) {
      File data_dir=new File(baseDir,""String_Node_Str"" + (i + 1) + MiniDFSCluster.FINALIZED_DIR_NAME);
      File[] blocks=data_dir.listFiles();
      if (blocks == null)       continue;
      for (int idx=0; idx < blocks.length; idx++) {
        if (!blocks[idx].getName().startsWith(""String_Node_Str"")) {
          continue;
        }
        LOG.info(""String_Node_Str"" + blocks[idx].getName());
        assertTrue(""String_Node_Str"",blocks[idx].delete());
      }
    }
    int count=0;
    corruptFileBlocks=dfs.listCorruptFileBlocks(new Path(""String_Node_Str""));
    numCorrupt=countPaths(corruptFileBlocks);
    while (numCorrupt < 3) {
      Thread.sleep(1000);
      corruptFileBlocks=dfs.listCorruptFileBlocks(new Path(""String_Node_Str""));
      numCorrupt=countPaths(corruptFileBlocks);
      count++;
      if (count > 30)       break;
    }
    LOG.info(""String_Node_Str"" + numCorrupt);
    assertTrue(numCorrupt == 3);
    util.cleanup(fs,""String_Node_Str"");
    util.cleanup(fs,""String_Node_Str"");
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}","/** 
 * test listCorruptFileBlocks in DistributedFileSystem
 */
@Test public void testlistCorruptFileBlocksDFS() throws Exception {
  Configuration conf=new Configuration();
  conf.setLong(""String_Node_Str"",1000);
  conf.setInt(""String_Node_Str"",1);
  FileSystem fs=null;
  MiniDFSCluster cluster=null;
  try {
    cluster=new MiniDFSCluster.Builder(conf).build();
    cluster.waitActive();
    fs=cluster.getFileSystem();
    DistributedFileSystem dfs=(DistributedFileSystem)fs;
    DFSTestUtil util=new DFSTestUtil(""String_Node_Str"",3,1,1024);
    util.createFiles(fs,""String_Node_Str"");
    RemoteIterator<Path> corruptFileBlocks=dfs.listCorruptFileBlocks(new Path(""String_Node_Str""));
    int numCorrupt=countPaths(corruptFileBlocks);
    assertTrue(numCorrupt == 0);
    String bpid=cluster.getNamesystem().getBlockPoolId();
    for (int i=0; i < 2; i++) {
      File storageDir=MiniDFSCluster.getStorageDir(0,i);
      File data_dir=MiniDFSCluster.getFinalizedDir(storageDir,bpid);
      File[] blocks=data_dir.listFiles();
      if (blocks == null)       continue;
      for (int idx=0; idx < blocks.length; idx++) {
        if (!blocks[idx].getName().startsWith(""String_Node_Str"")) {
          continue;
        }
        LOG.info(""String_Node_Str"" + blocks[idx].getName());
        assertTrue(""String_Node_Str"",blocks[idx].delete());
      }
    }
    int count=0;
    corruptFileBlocks=dfs.listCorruptFileBlocks(new Path(""String_Node_Str""));
    numCorrupt=countPaths(corruptFileBlocks);
    while (numCorrupt < 3) {
      Thread.sleep(1000);
      corruptFileBlocks=dfs.listCorruptFileBlocks(new Path(""String_Node_Str""));
      numCorrupt=countPaths(corruptFileBlocks);
      count++;
      if (count > 30)       break;
    }
    LOG.info(""String_Node_Str"" + numCorrupt);
    assertTrue(numCorrupt == 3);
    util.cleanup(fs,""String_Node_Str"");
    util.cleanup(fs,""String_Node_Str"");
  }
  finally {
    if (cluster != null) {
      cluster.shutdown();
    }
  }
}"
57860,"/** 
 * Sync two replicas 
 */
private void testSyncReplicas(ReplicaRecoveryInfo replica1,ReplicaRecoveryInfo replica2,InterDatanodeProtocol dn1,InterDatanodeProtocol dn2,long expectLen) throws IOException {
  DatanodeInfo[] locs=new DatanodeInfo[]{mock(DatanodeInfo.class),mock(DatanodeInfo.class)};
  RecoveringBlock rBlock=new RecoveringBlock(block,locs,RECOVERY_ID);
  ArrayList<BlockRecord> syncList=new ArrayList<BlockRecord>(2);
  BlockRecord record1=new BlockRecord(new DatanodeID(""String_Node_Str"",""String_Node_Str"",44,55),dn1,replica1);
  BlockRecord record2=new BlockRecord(new DatanodeID(""String_Node_Str"",""String_Node_Str"",11,22),dn2,replica2);
  syncList.add(record1);
  syncList.add(record2);
  when(dn1.updateReplicaUnderRecovery((Block)anyObject(),anyLong(),anyLong())).thenReturn(new Block(block.getBlockId(),expectLen,block.getGenerationStamp()));
  when(dn2.updateReplicaUnderRecovery((Block)anyObject(),anyLong(),anyLong())).thenReturn(new Block(block.getBlockId(),expectLen,block.getGenerationStamp()));
  dn.syncBlock(rBlock,syncList);
}","/** 
 * Sync two replicas 
 */
private void testSyncReplicas(ReplicaRecoveryInfo replica1,ReplicaRecoveryInfo replica2,InterDatanodeProtocol dn1,InterDatanodeProtocol dn2,long expectLen) throws IOException {
  DatanodeInfo[] locs=new DatanodeInfo[]{mock(DatanodeInfo.class),mock(DatanodeInfo.class)};
  RecoveringBlock rBlock=new RecoveringBlock(block,locs,RECOVERY_ID);
  ArrayList<BlockRecord> syncList=new ArrayList<BlockRecord>(2);
  BlockRecord record1=new BlockRecord(new DatanodeID(""String_Node_Str"",""String_Node_Str"",44,55),dn1,replica1);
  BlockRecord record2=new BlockRecord(new DatanodeID(""String_Node_Str"",""String_Node_Str"",11,22),dn2,replica2);
  syncList.add(record1);
  syncList.add(record2);
  when(dn1.updateReplicaUnderRecovery((ExtendedBlock)anyObject(),anyLong(),anyLong())).thenReturn(new ExtendedBlock(block.getBlockPoolId(),block.getBlockId(),expectLen,block.getGenerationStamp()));
  when(dn2.updateReplicaUnderRecovery((ExtendedBlock)anyObject(),anyLong(),anyLong())).thenReturn(new ExtendedBlock(block.getBlockPoolId(),block.getBlockId(),expectLen,block.getGenerationStamp()));
  dn.syncBlock(rBlock,syncList);
}"
57861,"@Test public void getClasspath(){
  assertTrue(JVMUtil.getClasspath().length > 0);
  assertTrue(JVMUtil.getClasspath(ClassLoader.getSystemClassLoader()).length > 0);
  assertArrayEquals(JVMUtil.getClasspath(),JVMUtil.getClasspath(ClassLoader.getSystemClassLoader()));
  assertEquals(1,JVMUtil.getClasspath(null).length);
}","@Test public void getClasspath(){
  try {
    assertTrue(JVMUtil.getClasspath().length > 0);
    assertTrue(JVMUtil.getClasspath(ClassLoader.getSystemClassLoader()).length > 0);
    assertArrayEquals(JVMUtil.getClasspath(),JVMUtil.getClasspath(ClassLoader.getSystemClassLoader()));
    assertEquals(1,JVMUtil.getClasspath(null).length);
  }
 catch (  Exception e) {
    assertEquals(""String_Node_Str"",e.getMessage());
    assertEquals(RuntimeException.class,e.getClass());
    assertEquals(""String_Node_Str"",e.getCause().getMessage());
    assertEquals(java.util.zip.ZipException.class,e.getCause().getClass());
  }
}"
57862,"@Test public void getJavaRuntimeInfo(){
  String arch=JVMUtil.getJavaRuntimeInfo().getSunArchDataModel();
  assertTrue(""String_Node_Str"".equals(arch) || ""String_Node_Str"".equals(arch));
  String boot=JVMUtil.getJavaRuntimeInfo().getSunBootClassPath();
  File[] classpathes=JVMUtil.getClasspath();
  boolean flag=false;
  for (  File classpath : classpathes) {
    if (classpath.getAbsolutePath().equals(boot)) {
      flag=true;
      break;
    }
  }
  assertTrue(flag);
}","@Test public void getJavaRuntimeInfo(){
  String arch=JVMUtil.getJavaRuntimeInfo().getSunArchDataModel();
  assertTrue(""String_Node_Str"".equals(arch) || ""String_Node_Str"".equals(arch));
  String boot=JVMUtil.getJavaRuntimeInfo().getSunBootClassPath();
  try {
    File[] classpathes=JVMUtil.getClasspath();
    boolean flag=false;
    for (    File classpath : classpathes) {
      if (classpath.getAbsolutePath().equals(boot)) {
        flag=true;
        break;
      }
    }
    assertTrue(flag);
  }
 catch (  Exception e) {
    assertEquals(""String_Node_Str"",e.getMessage());
    assertEquals(RuntimeException.class,e.getClass());
    assertEquals(""String_Node_Str"",e.getCause().getMessage());
    assertEquals(java.util.zip.ZipException.class,e.getCause().getClass());
  }
}"
57863,"@Test public void getLocalHostname(){
  assertEquals(""String_Node_Str"",NetworkUtil.getLocalHostname());
}","@Test public void getLocalHostname(){
}"
57864,"@Test public void getLocalHostIp(){
  assertEquals(""String_Node_Str"",NetworkUtil.getLocalHostIp());
}","@Test public void getLocalHostIp(){
}"
57865,"@Test public void invokeMethod(){
  assertNull(ReflectionUtil.invokeMethod(null,null));
  assertNull(ReflectionUtil.invokeMethod(null,new Object(),new Object()));
  assertNull(ReflectionUtil.invokeMethod(null,new Object()));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,null));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,(Object[])null,(Class<?>)null));
  assertNull(ReflectionUtil.invokeMethod(""String_Node_Str"",(String)null,(Object[])null,(Class<?>)null));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,new Object[]{},(Class<?>)null));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,(Object[])null,Emptys.EMPTY_CLASS_ARRAY));
  assertNull(ReflectionUtil.invokeMethod(null,new Object(),new Object()));
  assertNull(ReflectionUtil.invokeMethod(null,new Object()));
  Method method=null;
  try {
    method=String.class.getMethod(""String_Node_Str"",int.class);
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,null,1));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,""String_Node_Str"",1));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,new Object(),1));
    method=String.class.getMethod(""String_Node_Str"");
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,""String_Node_Str""));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,new Object()));
  }
 catch (  Exception e) {
    assertTrue(e instanceof RuntimeException);
  }
  List<String> list=CollectionUtil.createArrayList();
  try {
    method=ArrayList.class.getDeclaredMethod(""String_Node_Str"",int.class);
    ReflectionUtil.invokeMethod(method,list,Integer.MAX_VALUE);
  }
 catch (  Exception e) {
    InvocationTargetException ex=(InvocationTargetException)e.getCause();
    assertTrue(ex.getTargetException() instanceof IndexOutOfBoundsException);
  }
  try {
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(""String_Node_Str"",""String_Node_Str"",null));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(new Object(),""String_Node_Str"",null));
  }
 catch (  Exception e) {
    assertTrue(e instanceof RuntimeException);
  }
  list=CollectionUtil.createArrayList();
  try {
    ReflectionUtil.invokeMethod(list,""String_Node_Str"",new Object[]{Integer.MAX_VALUE},int.class);
  }
 catch (  Exception e) {
    InvocationTargetException ex=(InvocationTargetException)e.getCause();
    assertTrue(ex.getTargetException() instanceof IndexOutOfBoundsException);
  }
}","@Test public void invokeMethod(){
  assertNull(ReflectionUtil.invokeMethod(null,null));
  assertNull(ReflectionUtil.invokeMethod(null,new Object(),new Object()));
  assertNull(ReflectionUtil.invokeMethod(null,new Object()));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,null));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,(Object[])null,(Class<?>)null));
  assertNull(ReflectionUtil.invokeMethod(""String_Node_Str"",(String)null,(Object[])null,(Class<?>)null));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,new Object[]{},(Class<?>)null));
  assertNull(ReflectionUtil.invokeMethod((Object)null,(String)null,(Object[])null,Emptys.EMPTY_CLASS_ARRAY));
  assertNull(ReflectionUtil.invokeMethod(null,new Object(),new Object()));
  assertNull(ReflectionUtil.invokeMethod(null,new Object()));
  Method method=null;
  try {
    method=String.class.getMethod(""String_Node_Str"",int.class);
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,null,1));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,""String_Node_Str"",1));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,new Object(),1));
    method=String.class.getMethod(""String_Node_Str"");
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,""String_Node_Str""));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(method,new Object()));
  }
 catch (  Exception e) {
    assertTrue(e instanceof RuntimeException);
  }
  List<String> list=CollectionUtil.createArrayList();
  try {
    method=ArrayList.class.getDeclaredMethod(""String_Node_Str"",int.class);
    ReflectionUtil.invokeMethod(method,list,Integer.MAX_VALUE);
  }
 catch (  Exception e) {
    InvocationTargetException ex=(InvocationTargetException)e.getCause();
    if (ex != null) {
      assertTrue(ex.getTargetException() instanceof IndexOutOfBoundsException);
    }
  }
  try {
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(""String_Node_Str"",""String_Node_Str"",null));
    assertEquals(""String_Node_Str"",ReflectionUtil.invokeMethod(new Object(),""String_Node_Str"",null));
  }
 catch (  Exception e) {
    assertTrue(e instanceof RuntimeException);
  }
  list=CollectionUtil.createArrayList();
  try {
    ReflectionUtil.invokeMethod(list,""String_Node_Str"",new Object[]{Integer.MAX_VALUE},int.class);
  }
 catch (  Exception e) {
    if (e.getCause() instanceof NoSuchMethodException) {
    }
 else {
      InvocationTargetException ex=(InvocationTargetException)e.getCause();
      assertTrue(ex.getTargetException() instanceof IndexOutOfBoundsException);
    }
  }
}"
57866,"@Test public void retrieve(){
  try {
    Resource resource=access.retrieve(id,""String_Node_Str"");
    byte[] raw=StreamUtil.readBytes(new File(log4j),true).getRawBytes();
    assertArrayEquals(raw,resource.getBody().getRawBytes());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Test public void retrieve(){
  store();
  try {
    Resource resource=access.retrieve(id,""String_Node_Str"");
    byte[] raw=StreamUtil.readBytes(new File(log4j),true).getRawBytes();
    assertArrayEquals(raw,resource.getBody().getRawBytes());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
57867,"@Test public void store(){
  File file=new File(log4j);
  try {
    ByteArray byteArray=StreamUtil.readBytes(file,true);
    Resource resource=new FileResource(id,byteArray);
    resource.getHeader().ext(""String_Node_Str"");
    assertEquals(2256099345L,resource.checksum());
    access.store(resource);
    byte[] raw=StreamUtil.readBytes(new File(log4j),true).getRawBytes();
    assertArrayEquals(raw,resource.getBody().getRawBytes());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","@Test public void store(){
  File file=new File(log4j);
  try {
    ByteArray byteArray=StreamUtil.readBytes(file,true);
    Resource resource=new FileResource(id,byteArray);
    resource.getHeader().ext(""String_Node_Str"");
    assertEquals(4114700253L,resource.checksum());
    access.store(resource);
    byte[] raw=StreamUtil.readBytes(new File(log4j),true).getRawBytes();
    assertArrayEquals(raw,resource.getBody().getRawBytes());
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
57868,"@Test public void remove(){
  try {
    assertTrue(access.remove(id,""String_Node_Str""));
  }
 catch (  AccessException e) {
    e.printStackTrace();
  }
}","@Test public void remove(){
  store();
  try {
    assertTrue(access.remove(id,""String_Node_Str""));
  }
 catch (  AccessException e) {
    e.printStackTrace();
  }
}"
57869,"@Test public void find(){
  AccessStrategy strategy=new DivideThousand();
  String where=strategy.find(1234567890);
  assertEquals(""String_Node_Str"",where);
  where=strategy.find(123456789);
  assertEquals(""String_Node_Str"",where);
}","@Test public void find(){
  AccessStrategy strategy=new DivideThousand();
  String where=strategy.find(1234567890);
  assertEquals(""String_Node_Str"".replace(""String_Node_Str"",File.separator),where);
  where=strategy.find(123456789);
  assertEquals(""String_Node_Str"".replace(""String_Node_Str"",File.separator),where);
}"
57870,"@Test public void exportBean() throws IOException {
  CsvBean bean=processor.exportBean(CsvBean.class,testBeanPath);
  assertEquals(bean,createBean(""String_Node_Str"",25,""String_Node_Str"",""String_Node_Str""));
}","@Test public void exportBean() throws IOException {
  importBean();
  CsvBean bean=processor.exportBean(CsvBean.class,testBeanPath);
  assertEquals(bean,createBean(""String_Node_Str"",25,""String_Node_Str"",""String_Node_Str""));
}"
57871,"@Test public void exportBeans() throws IOException {
  List<CsvBean> list=processor.exportBeans(CsvBean.class,testBeansPath);
  for (  CsvBean bean : list) {
    logger.info(bean);
  }
}","@Test public void exportBeans() throws IOException {
  importBeans();
  List<CsvBean> list=processor.exportBeans(CsvBean.class,testBeansPath);
  for (  CsvBean bean : list) {
    logger.info(bean);
  }
}"
57872,"@Test public void setLocation(){
  AppInfo app=new AppInfo();
  app.setLocation(""String_Node_Str"");
  assertEquals(""String_Node_Str"",app.getAppVersion());
  app.setLocation(""String_Node_Str"");
  assertEquals(""String_Node_Str"",app.getSpecificationTitle());
  assertEquals(""String_Node_Str"",app.getSpecificationVersion());
  assertEquals(""String_Node_Str"",app.getSpecificationVendor());
  assertEquals(""String_Node_Str"",app.getImplementationTitle());
}","@Test public void setLocation(){
  AppInfo app=new AppInfo();
  app.setLocation(""String_Node_Str"");
  assertEquals(""String_Node_Str"",app.getAppVersion());
}"
57873,"@Override public List<String> getSuggestions(CommandSource source,String arguments,Location<World> targetPosition) throws CommandException {
  if (!(source instanceof Player)) {
    return null;
  }
  PlotPlayer player=SpongeUtil.getPlayer((Player)source);
  String[] args=arguments.split(""String_Node_Str"");
  if (args.length == 0) {
    return Collections.singletonList(MainCommand.getInstance().toString());
  }
  Collection objects=MainCommand.getInstance().tab(player,args,arguments.endsWith(""String_Node_Str""));
  if (objects == null) {
    return null;
  }
  List<String> result=new ArrayList<>();
  for (  Object o : objects) {
    result.add(o.toString());
  }
  return result.isEmpty() ? null : result;
}","@Override public List<String> getSuggestions(CommandSource source,String arguments,Location<World> targetPosition) throws CommandException {
  if (!(source instanceof Player)) {
    return ImmutableList.of();
  }
  PlotPlayer player=SpongeUtil.getPlayer((Player)source);
  String[] args=arguments.split(""String_Node_Str"");
  if (args.length == 0) {
    return Collections.singletonList(MainCommand.getInstance().toString());
  }
  Collection objects=MainCommand.getInstance().tab(player,args,arguments.endsWith(""String_Node_Str""));
  if (objects == null) {
    return ImmutableList.of();
  }
  List<String> result=new ArrayList<>();
  for (  Object o : objects) {
    result.add(o.toString());
  }
  return result;
}"
57874,"@Override public List<String> getSuggestions(CommandSource source,String arguments,Location<World> targetPosition) throws CommandException {
  if (!(source instanceof Player)) {
    return null;
  }
  PlotPlayer player=SpongeUtil.getPlayer((Player)source);
  String[] args=arguments.split(""String_Node_Str"");
  if (args.length == 0) {
    return Collections.singletonList(MainCommand.getInstance().toString());
  }
  Collection objects=MainCommand.getInstance().tab(player,args,arguments.endsWith(""String_Node_Str""));
  if (objects == null) {
    return null;
  }
  List<String> result=new ArrayList<>();
  for (  Object o : objects) {
    result.add(o.toString());
  }
  return result.isEmpty() ? null : result;
}","@Override public List<String> getSuggestions(CommandSource source,String arguments,Location<World> targetPosition) throws CommandException {
  if (!(source instanceof Player)) {
    return ImmutableList.of();
  }
  PlotPlayer player=SpongeUtil.getPlayer((Player)source);
  String[] args=arguments.split(""String_Node_Str"");
  if (args.length == 0) {
    return Collections.singletonList(MainCommand.getInstance().toString());
  }
  Collection objects=MainCommand.getInstance().tab(player,args,arguments.endsWith(""String_Node_Str""));
  if (objects == null) {
    return ImmutableList.of();
  }
  List<String> result=new ArrayList<>();
  for (  Object o : objects) {
    result.add(o.toString());
  }
  return result;
}"
57875,"@Override public void execute(final PlotPlayer player,String[] args,RunnableVal3<Command,Runnable,Runnable> confirm,final RunnableVal2<Command,CommandResult> whenDone) throws CommandException {
  if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    args=args[0].split(""String_Node_Str"");
  }
  int page=Integer.MIN_VALUE;
  Collection<Plot> unsorted=null;
  PlotArea sortByArea=player.getApplicablePlotArea();
  boolean shouldSortByArea=Settings.Teleport.PER_WORLD_VISIT;
switch (args.length) {
case 2:
    if (MathMan.isInteger(args[1])) {
      page=tryReadPageIdFromArg(player,args[1]);
    }
 else {
      C.COMMAND_SYNTAX.send(player,getUsage());
      return;
    }
case 1:
  boolean isCorrectSyntaxWithoutResults=false;
Collection<Plot> plots=new HashSet<Plot>();
if (args[0] != null) {
plots=getPlotsFromSingleArgument(args[0],sortByArea);
if (!plots.isEmpty()) {
  unsorted=plots;
}
 else {
  if (MathMan.isInteger(args[0])) {
    page=tryReadPageIdFromArg(player,args[0]);
    if (page != PAGE_OUT_OF_RANGE && page != Integer.MIN_VALUE) {
      unsorted=PS.get().getPlots(player);
    }
  }
 else {
    isCorrectSyntaxWithoutResults=true;
  }
}
}
if (!isCorrectSyntaxWithoutResults && plots.isEmpty() && page == Integer.MIN_VALUE) {
C.COMMAND_SYNTAX.send(player,getUsage());
return;
}
break;
case 0:
unsorted=PS.get().getPlots(player);
break;
default :
C.COMMAND_SYNTAX.send(player,getUsage());
return;
}
if (page == Integer.MIN_VALUE) {
page=1;
}
if (unsorted == null || unsorted.isEmpty()) {
C.FOUND_NO_PLOTS.send(player);
return;
}
Iterator<Plot> iterator=unsorted.iterator();
while (iterator.hasNext()) {
if (!iterator.next().isBasePlot()) {
iterator.remove();
}
}
if (page < 1 || page > unsorted.size()) {
C.NOT_VALID_NUMBER.send(player,""String_Node_Str"" + unsorted.size() + ""String_Node_Str"");
return;
}
List<Plot> plots;
if (shouldSortByArea) {
plots=PS.get().sortPlots(unsorted,PS.SortType.CREATION_DATE,sortByArea);
}
 else {
plots=PS.get().sortPlotsByTemp(unsorted);
}
final Plot plot=plots.get(page - 1);
if (!plot.hasOwner()) {
if (!Permissions.hasPermission(player,C.PERMISSION_VISIT_UNOWNED)) {
C.NO_PERMISSION.send(player,C.PERMISSION_VISIT_UNOWNED);
return;
}
}
 else if (plot.isOwner(player.getUUID())) {
if (!Permissions.hasPermission(player,C.PERMISSION_VISIT_OWNED) && !Permissions.hasPermission(player,C.PERMISSION_HOME)) {
C.NO_PERMISSION.send(player,C.PERMISSION_VISIT_OWNED);
return;
}
}
 else if (plot.isAdded(player.getUUID())) {
if (!Permissions.hasPermission(player,C.PERMISSION_SHARED)) {
C.NO_PERMISSION.send(player,C.PERMISSION_SHARED);
return;
}
}
 else {
if (!Permissions.hasPermission(player,C.PERMISSION_VISIT_OTHER)) {
C.NO_PERMISSION.send(player,C.PERMISSION_VISIT_OTHER);
return;
}
}
confirm.run(this,new Runnable(){
@Override public void run(){
if (plot.teleportPlayer(player)) {
whenDone.run(Visit.this,CommandResult.SUCCESS);
}
 else {
whenDone.run(Visit.this,CommandResult.FAILURE);
}
}
}
,new Runnable(){
@Override public void run(){
whenDone.run(Visit.this,CommandResult.FAILURE);
}
}
);
}","@Override public void execute(final PlotPlayer player,String[] args,RunnableVal3<Command,Runnable,Runnable> confirm,final RunnableVal2<Command,CommandResult> whenDone) throws CommandException {
  if (args.length == 1 && args[0].contains(""String_Node_Str"")) {
    args=args[0].split(""String_Node_Str"");
  }
  int page=Integer.MIN_VALUE;
  Collection<Plot> unsorted=null;
  PlotArea sortByArea=player.getApplicablePlotArea();
  boolean shouldSortByArea=Settings.Teleport.PER_WORLD_VISIT;
switch (args.length) {
case 2:
    if (MathMan.isInteger(args[1])) {
      page=tryReadPageIdFromArg(player,args[1]);
    }
 else {
      C.COMMAND_SYNTAX.send(player,getUsage());
      return;
    }
case 1:
  boolean isCorrectSyntaxWithoutResults=false;
Collection<Plot> plots=new HashSet<Plot>();
if (args[0] != null) {
plots=getPlotsFromSingleArgument(args[0],sortByArea);
if (!plots.isEmpty()) {
  unsorted=plots;
}
 else {
  if (MathMan.isInteger(args[0])) {
    page=tryReadPageIdFromArg(player,args[0]);
    if (page != PAGE_OUT_OF_RANGE && page != Integer.MIN_VALUE) {
      unsorted=PS.get().getPlots(player);
    }
  }
 else {
    isCorrectSyntaxWithoutResults=true;
  }
}
}
if (!isCorrectSyntaxWithoutResults && plots.isEmpty() && page == Integer.MIN_VALUE) {
C.COMMAND_SYNTAX.send(player,getUsage());
return;
}
if ((args[0].contains(""String_Node_Str"") || args[0].contains(""String_Node_Str"")) && (unsorted == null || unsorted.isEmpty())) {
Plot plot=MainUtil.getPlotFromString(player,args[0],true);
if (plot != null) {
unsorted=Collections.singletonList(plot.getBasePlot(false));
}
}
break;
case 0:
unsorted=PS.get().getPlots(player);
break;
default :
C.COMMAND_SYNTAX.send(player,getUsage());
return;
}
if (page == Integer.MIN_VALUE) {
page=1;
}
if (unsorted == null || unsorted.isEmpty()) {
C.FOUND_NO_PLOTS.send(player);
return;
}
Iterator<Plot> iterator=unsorted.iterator();
while (iterator.hasNext()) {
if (!iterator.next().isBasePlot()) {
iterator.remove();
}
}
if (page < 1 || page > unsorted.size()) {
C.NOT_VALID_NUMBER.send(player,""String_Node_Str"" + unsorted.size() + ""String_Node_Str"");
return;
}
List<Plot> plots;
if (shouldSortByArea) {
plots=PS.get().sortPlots(unsorted,PS.SortType.CREATION_DATE,sortByArea);
}
 else {
plots=PS.get().sortPlotsByTemp(unsorted);
}
final Plot plot=plots.get(page - 1);
if (!plot.hasOwner()) {
if (!Permissions.hasPermission(player,C.PERMISSION_VISIT_UNOWNED)) {
C.NO_PERMISSION.send(player,C.PERMISSION_VISIT_UNOWNED);
return;
}
}
 else if (plot.isOwner(player.getUUID())) {
if (!Permissions.hasPermission(player,C.PERMISSION_VISIT_OWNED) && !Permissions.hasPermission(player,C.PERMISSION_HOME)) {
C.NO_PERMISSION.send(player,C.PERMISSION_VISIT_OWNED);
return;
}
}
 else if (plot.isAdded(player.getUUID())) {
if (!Permissions.hasPermission(player,C.PERMISSION_SHARED)) {
C.NO_PERMISSION.send(player,C.PERMISSION_SHARED);
return;
}
}
 else {
if (!Permissions.hasPermission(player,C.PERMISSION_VISIT_OTHER)) {
C.NO_PERMISSION.send(player,C.PERMISSION_VISIT_OTHER);
return;
}
}
confirm.run(this,new Runnable(){
@Override public void run(){
if (plot.teleportPlayer(player)) {
whenDone.run(Visit.this,CommandResult.SUCCESS);
}
 else {
whenDone.run(Visit.this,CommandResult.FAILURE);
}
}
}
,new Runnable(){
@Override public void run(){
whenDone.run(Visit.this,CommandResult.FAILURE);
}
}
);
}"
57876,"public boolean isSolid(int i){
  return i != 0 && Block.getBlockById(i).isVisuallyOpaque();
}","public boolean isSolid(int i){
  return i != 0 && Block.getBlockById(i).isFullyOpaque(Block.getBlockById(i).getDefaultState());
}"
57877,"public void setBiomes(LocalChunk<char[]> lc){
  if (lc.biomes != null) {
    World worldObj=getSpongeWorld();
    int bx=lc.getX() << 4;
    int bz=lc.getX() << 4;
    String last=null;
    BiomeType biome=null;
    for (int x=0; x < lc.biomes.length; x++) {
      String[] biomes2=lc.biomes[x];
      if (biomes2 != null) {
        for (int y=0; y < biomes2.length; y++) {
          String biomeStr=biomes2[y];
          if (biomeStr != null) {
            if (last == null || !StringMan.isEqual(last,biomeStr)) {
              biome=SpongeUtil.getBiome(biomeStr.toUpperCase());
            }
            worldObj.setBiome(bx,bz,biome);
          }
        }
      }
    }
  }
}","public void setBiomes(LocalChunk<char[]> lc){
  if (lc.biomes != null) {
    World worldObj=getSpongeWorld();
    int bx=lc.getX() << 4;
    int bz=lc.getX() << 4;
    String last=null;
    BiomeType biome=null;
    for (int x=0; x < lc.biomes.length; x++) {
      String[] biomes2=lc.biomes[x];
      if (biomes2 != null) {
        for (int y=0; y < biomes2.length; y++) {
          String biomeStr=biomes2[y];
          if (biomeStr != null) {
            if (last == null || !StringMan.isEqual(last,biomeStr)) {
              biome=SpongeUtil.getBiome(biomeStr.toUpperCase());
            }
            worldObj.setBiome(bx,0,bz,biome);
          }
        }
      }
    }
  }
}"
57878,"@Override public PlotBlock getBlock(int x,int y,int z){
  World worldObj=getSpongeWorld();
  BlockState block=worldObj.getBlock(x,y,z);
  if (block == null) {
    return PlotBlock.get(0,0);
  }
  return SpongeUtil.getPlotBlock(block);
}","@Override public PlotBlock getBlock(int x,int y,int z){
  World worldObj=getSpongeWorld();
  BlockState block=worldObj.getBlock(x,y,z);
  return SpongeUtil.getPlotBlock(block);
}"
57879,"@Override public void refreshChunk(int x,int z){
  World world=getSpongeWorld();
  Chunk nmsChunk=((net.minecraft.world.World)world).getChunkProvider().provideChunk(x,z);
  if (nmsChunk == null || !nmsChunk.isLoaded()) {
    return;
  }
  try {
    ChunkPos pos=nmsChunk.getChunkCoordIntPair();
    WorldServer w=(WorldServer)nmsChunk.getWorld();
    PlayerChunkMap chunkMap=w.getPlayerChunkMap();
    if (!chunkMap.contains(x,z)) {
      return;
    }
    EntityTracker tracker=w.getEntityTracker();
    HashSet<EntityPlayerMP> players=new HashSet<>();
    for (    EntityPlayer player : w.playerEntities) {
      if (player instanceof EntityPlayerMP) {
        if (chunkMap.isPlayerWatchingChunk((EntityPlayerMP)player,x,z)) {
          players.add((EntityPlayerMP)player);
        }
      }
    }
    if (players.size() == 0) {
      return;
    }
    HashSet<EntityTrackerEntry> entities=new HashSet<>();
    ClassInheritanceMultiMap<Entity>[] entitieSlices=nmsChunk.getEntityLists();
    IntHashMap<EntityTrackerEntry> entries=null;
    for (    Field field : tracker.getClass().getDeclaredFields()) {
      if (field.getType() == IntHashMap.class) {
        field.setAccessible(true);
        entries=(IntHashMap<EntityTrackerEntry>)field.get(tracker);
      }
    }
    for (    ClassInheritanceMultiMap<Entity> slice : entitieSlices) {
      if (slice == null) {
        continue;
      }
      for (      Entity ent : slice) {
        EntityTrackerEntry entry=entries != null ? entries.lookup(ent.getEntityId()) : null;
        if (entry == null) {
          continue;
        }
        entities.add(entry);
        SPacketDestroyEntities packet=new SPacketDestroyEntities(ent.getEntityId());
        for (        EntityPlayerMP player : players) {
          player.connection.sendPacket(packet);
        }
      }
    }
    SPacketChunkData packet=new SPacketChunkData(nmsChunk,65535);
    for (    EntityPlayerMP player : players) {
      player.connection.sendPacket(packet);
    }
    for (    EntityTrackerEntry entry : entities) {
      try {
        TaskManager.IMP.taskLater(new Runnable(){
          @Override public void run(){
            for (            EntityPlayerMP player : players) {
              if (entry.isVisibleTo(player)) {
                entry.removeFromTrackedPlayers(player);
                if (entry.getTrackedEntity() != player) {
                  entry.updatePlayerEntity(player);
                }
              }
            }
          }
        }
,2);
      }
 catch (      Throwable e) {
        e.printStackTrace();
      }
    }
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}","@Override public void refreshChunk(int x,int z){
  World world=getSpongeWorld();
  Chunk nmsChunk=((net.minecraft.world.World)world).getChunkProvider().provideChunk(x,z);
  if (nmsChunk == null || !nmsChunk.isLoaded()) {
    return;
  }
  try {
    ChunkPos pos=nmsChunk.getChunkCoordIntPair();
    WorldServer w=(WorldServer)nmsChunk.getWorld();
    PlayerChunkMap chunkMap=w.getPlayerChunkMap();
    if (!chunkMap.contains(x,z)) {
      return;
    }
    EntityTracker tracker=w.getEntityTracker();
    HashSet<EntityPlayerMP> players=new HashSet<>();
    for (    EntityPlayer player : w.playerEntities) {
      if (player instanceof EntityPlayerMP) {
        if (chunkMap.isPlayerWatchingChunk((EntityPlayerMP)player,x,z)) {
          players.add((EntityPlayerMP)player);
        }
      }
    }
    if (players.isEmpty()) {
      return;
    }
    HashSet<EntityTrackerEntry> entities=new HashSet<>();
    ClassInheritanceMultiMap<Entity>[] entitieSlices=nmsChunk.getEntityLists();
    IntHashMap<EntityTrackerEntry> entries=null;
    for (    Field field : tracker.getClass().getDeclaredFields()) {
      if (field.getType() == IntHashMap.class) {
        field.setAccessible(true);
        entries=(IntHashMap<EntityTrackerEntry>)field.get(tracker);
      }
    }
    for (    ClassInheritanceMultiMap<Entity> slice : entitieSlices) {
      if (slice == null) {
        continue;
      }
      for (      Entity ent : slice) {
        EntityTrackerEntry entry=entries != null ? entries.lookup(ent.getEntityId()) : null;
        if (entry == null) {
          continue;
        }
        entities.add(entry);
        SPacketDestroyEntities packet=new SPacketDestroyEntities(ent.getEntityId());
        for (        EntityPlayerMP player : players) {
          player.connection.sendPacket(packet);
        }
      }
    }
    SPacketChunkData packet=new SPacketChunkData(nmsChunk,65535);
    for (    EntityPlayerMP player : players) {
      player.connection.sendPacket(packet);
    }
    for (    EntityTrackerEntry entry : entities) {
      try {
        TaskManager.IMP.taskLater(new Runnable(){
          @Override public void run(){
            for (            EntityPlayerMP player : players) {
              if (entry.isVisibleTo(player)) {
                entry.removeFromTrackedPlayers(player);
                if (entry.getTrackedEntity() != player) {
                  entry.updatePlayerEntity(player);
                }
              }
            }
          }
        }
,2);
      }
 catch (      Throwable e) {
        e.printStackTrace();
      }
    }
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}"
57880,"/** 
 * Constructor
 * @param database
 * @param p prefix
 * @throws SQLException
 * @throws ClassNotFoundException
 */
public SQLManager(final Database database,String p,boolean debug) throws SQLException, ClassNotFoundException {
  this.database=database;
  this.connection=database.openConnection();
  this.mySQL=database instanceof MySQL;
  this.globalTasks=new ConcurrentLinkedQueue<>();
  this.notifyTasks=new ConcurrentLinkedQueue<>();
  this.plotTasks=new ConcurrentHashMap<>();
  this.playerTasks=new ConcurrentHashMap<>();
  this.clusterTasks=new ConcurrentHashMap<>();
  this.prefix=p;
  this.SET_OWNER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.GET_ALL_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_SETTINGS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_TIERS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOT=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_CLUSTER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  TaskManager.runTaskAsync(new Runnable(){
    @Override public void run(){
      try {
        createTables();
      }
 catch (      SQLException e) {
        e.printStackTrace();
      }
      long last=System.currentTimeMillis();
      while (true) {
        if (SQLManager.this.closed) {
          break;
        }
        boolean hasTask=!globalTasks.isEmpty() || !playerTasks.isEmpty() || !plotTasks.isEmpty()|| !clusterTasks.isEmpty();
        if (hasTask) {
          try {
            if (SQLManager.this.mySQL && System.currentTimeMillis() - last > 550000 || !isValid()) {
              last=System.currentTimeMillis();
              reconnect();
            }
          }
 catch (          SQLException impossible) {
            impossible.printStackTrace();
          }
          if (!sendBatch()) {
            try {
              if (!getNotifyTasks().isEmpty()) {
                for (                Runnable task : getNotifyTasks()) {
                  TaskManager.runTask(task);
                }
                getNotifyTasks().clear();
              }
              Thread.sleep(50);
            }
 catch (            InterruptedException e) {
              e.printStackTrace();
            }
          }
        }
 else {
          try {
            Thread.sleep(5000);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
);
}","/** 
 * Constructor
 * @param database
 * @param p prefix
 * @throws SQLException
 * @throws ClassNotFoundException
 */
public SQLManager(final Database database,String p,boolean debug) throws SQLException, ClassNotFoundException {
  this.database=database;
  this.connection=database.openConnection();
  this.mySQL=database instanceof MySQL;
  this.globalTasks=new ConcurrentLinkedQueue<>();
  this.notifyTasks=new ConcurrentLinkedQueue<>();
  this.plotTasks=new ConcurrentHashMap<>();
  this.playerTasks=new ConcurrentHashMap<>();
  this.clusterTasks=new ConcurrentHashMap<>();
  this.prefix=p;
  this.SET_OWNER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.GET_ALL_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_SETTINGS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_TIERS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOT=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_CLUSTER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  TaskManager.runTaskAsync(new Runnable(){
    @Override public void run(){
      try {
        createTables();
      }
 catch (      SQLException e) {
        e.printStackTrace();
      }
      long last=System.currentTimeMillis();
      while (true) {
        if (SQLManager.this.closed) {
          break;
        }
        boolean hasTask=!globalTasks.isEmpty() || !playerTasks.isEmpty() || !plotTasks.isEmpty()|| !clusterTasks.isEmpty();
        if (hasTask) {
          if (SQLManager.this.mySQL && System.currentTimeMillis() - last > 550000 || !isValid()) {
            last=System.currentTimeMillis();
            reconnect();
          }
          if (!sendBatch()) {
            try {
              if (!getNotifyTasks().isEmpty()) {
                for (                Runnable task : getNotifyTasks()) {
                  TaskManager.runTask(task);
                }
                getNotifyTasks().clear();
              }
              Thread.sleep(50);
            }
 catch (            InterruptedException e) {
              e.printStackTrace();
            }
          }
        }
 else {
          try {
            Thread.sleep(5000);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
);
}"
57881,"/** 
 * PLOT MERGING.
 */
@Override public boolean createRoadEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sx=pos2.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=pos1.getZ() - 2;
  int ez=pos2.getZ() + 2;
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  queue.setCuboid(new Location(plotArea.worldname,sx,Math.min(dpw.WALL_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz + 1),new Location(plotArea.worldname,ex,Math.min(maxY,255),ez - 1),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,0,sz + 1),new Location(plotArea.worldname,ex,0,ez - 1),PlotBlock.get((short)7,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,1,sz + 1),new Location(plotArea.worldname,sx,dpw.WALL_HEIGHT,ez - 1),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.WALL_HEIGHT + 1,sz + 1),new Location(plotArea.worldname,sx,dpw.WALL_HEIGHT + 1,ez - 1),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,ex,1,sz + 1),new Location(plotArea.worldname,ex,dpw.WALL_HEIGHT,ez - 1),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,ex,dpw.WALL_HEIGHT + 1,sz + 1),new Location(plotArea.worldname,ex,dpw.WALL_HEIGHT + 1,ez - 1),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz + 1),new Location(plotArea.worldname,ex - 1,dpw.ROAD_HEIGHT,ez - 1),dpw.ROAD_BLOCK);
  queue.enqueue();
  return true;
}","/** 
 * PLOT MERGING.
 */
@Override public boolean createRoadEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sx=pos2.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=pos1.getZ() - 2;
  int ez=pos2.getZ() + 2;
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  queue.setCuboid(new Location(plotArea.worldname,sx,Math.min(dpw.WALL_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz + 1),new Location(plotArea.worldname,ex,maxY,ez - 1),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,0,sz + 1),new Location(plotArea.worldname,ex,0,ez - 1),PlotBlock.get((short)7,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,1,sz + 1),new Location(plotArea.worldname,sx,dpw.WALL_HEIGHT,ez - 1),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.WALL_HEIGHT + 1,sz + 1),new Location(plotArea.worldname,sx,dpw.WALL_HEIGHT + 1,ez - 1),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,ex,1,sz + 1),new Location(plotArea.worldname,ex,dpw.WALL_HEIGHT,ez - 1),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,ex,dpw.WALL_HEIGHT + 1,sz + 1),new Location(plotArea.worldname,ex,dpw.WALL_HEIGHT + 1,ez - 1),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz + 1),new Location(plotArea.worldname,ex - 1,dpw.ROAD_HEIGHT,ez - 1),dpw.ROAD_BLOCK);
  queue.enqueue();
  return true;
}"
57882,"public boolean setAir(PlotArea plotArea,PlotId plotId,PlotBlock[] blocks){
  Plot plot=plotArea.getPlotAbs(plotId);
  if (!plot.isBasePlot()) {
    return false;
  }
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  for (  RegionWrapper region : plot.getRegions()) {
    Location pos1=new Location(plotArea.worldname,region.minX,dpw.PLOT_HEIGHT + 1,region.minZ);
    Location pos2=new Location(plotArea.worldname,region.maxX,Math.min(maxY,255),region.maxZ);
    queue.setCuboid(pos1,pos2,blocks);
  }
  queue.enqueue();
  return true;
}","public boolean setAir(PlotArea plotArea,PlotId plotId,PlotBlock[] blocks){
  Plot plot=plotArea.getPlotAbs(plotId);
  if (!plot.isBasePlot()) {
    return false;
  }
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  for (  RegionWrapper region : plot.getRegions()) {
    Location pos1=new Location(plotArea.worldname,region.minX,dpw.PLOT_HEIGHT + 1,region.minZ);
    Location pos2=new Location(plotArea.worldname,region.maxX,maxY,region.maxZ);
    queue.setCuboid(pos1,pos2,blocks);
  }
  queue.enqueue();
  return true;
}"
57883,"public boolean setOutline(PlotArea plotArea,PlotId plotId,PlotBlock[] blocks){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  if (dpw.ROAD_WIDTH == 0) {
    return false;
  }
  Plot plot=plotArea.getPlotAbs(plotId);
  Location bottom=plot.getBottomAbs();
  Location top=plot.getExtendedTopAbs();
  PseudoRandom random=new PseudoRandom();
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  if (!plot.getMerged(0)) {
    int z=bottom.getZ();
    for (int x=bottom.getX(); x <= top.getX(); x++) {
      for (int y=dpw.PLOT_HEIGHT; y <= Math.min(maxY,255); y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (!plot.getMerged(3)) {
    int x=bottom.getX();
    for (int z=bottom.getZ(); z <= top.getZ(); z++) {
      for (int y=dpw.PLOT_HEIGHT; y <= Math.min(maxY,255); y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (!plot.getMerged(2)) {
    int z=top.getZ();
    for (int x=bottom.getX(); x <= top.getX(); x++) {
      for (int y=dpw.PLOT_HEIGHT; y <= Math.min(maxY,255); y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (!plot.getMerged(1)) {
    int x=top.getX();
    for (int z=bottom.getZ(); z <= top.getZ(); z++) {
      for (int y=dpw.PLOT_HEIGHT; y <= Math.min(maxY,255); y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (plot.isBasePlot()) {
    for (    RegionWrapper region : plot.getRegions()) {
      Location pos1=new Location(plotArea.worldname,region.minX,Math.min(maxY,255),region.minZ);
      Location pos2=new Location(plotArea.worldname,region.maxX,Math.min(maxY,255),region.maxZ);
      queue.setCuboid(pos1,pos2,blocks);
    }
  }
  queue.enqueue();
  return true;
}","public boolean setOutline(PlotArea plotArea,PlotId plotId,PlotBlock[] blocks){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  if (dpw.ROAD_WIDTH == 0) {
    return false;
  }
  Plot plot=plotArea.getPlotAbs(plotId);
  Location bottom=plot.getBottomAbs();
  Location top=plot.getExtendedTopAbs();
  PseudoRandom random=new PseudoRandom();
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  if (!plot.getMerged(0)) {
    int z=bottom.getZ();
    for (int x=bottom.getX(); x <= top.getX(); x++) {
      for (int y=dpw.PLOT_HEIGHT; y <= maxY; y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (!plot.getMerged(3)) {
    int x=bottom.getX();
    for (int z=bottom.getZ(); z <= top.getZ(); z++) {
      for (int y=dpw.PLOT_HEIGHT; y <= maxY; y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (!plot.getMerged(2)) {
    int z=top.getZ();
    for (int x=bottom.getX(); x <= top.getX(); x++) {
      for (int y=dpw.PLOT_HEIGHT; y <= maxY; y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (!plot.getMerged(1)) {
    int x=top.getX();
    for (int z=bottom.getZ(); z <= top.getZ(); z++) {
      for (int y=dpw.PLOT_HEIGHT; y <= maxY; y++) {
        queue.setBlock(x,y,z,blocks[random.random(blocks.length)]);
      }
    }
  }
  if (plot.isBasePlot()) {
    for (    RegionWrapper region : plot.getRegions()) {
      Location pos1=new Location(plotArea.worldname,region.minX,maxY,region.minZ);
      Location pos2=new Location(plotArea.worldname,region.maxX,maxY,region.maxZ);
      queue.setCuboid(pos1,pos2,blocks);
    }
  }
  queue.enqueue();
  return true;
}"
57884,"@Override public boolean createRoadSouthEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sx=pos2.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=pos2.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.ROAD_HEIGHT + 1,sz + 1),new Location(plotArea.worldname,ex - 1,255,ez - 1),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,0,sz + 1),new Location(plotArea.worldname,ex - 1,0,ez - 1),PlotBlock.get((short)7,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz + 1),new Location(plotArea.worldname,ex - 1,dpw.ROAD_HEIGHT,ez - 1),dpw.ROAD_BLOCK);
  queue.enqueue();
  return true;
}","@Override public boolean createRoadSouthEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sx=pos2.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=pos2.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.ROAD_HEIGHT + 1,sz + 1),new Location(plotArea.worldname,ex - 1,dpw.getPlotManager().getWorldHeight(),ez - 1),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,0,sz + 1),new Location(plotArea.worldname,ex - 1,0,ez - 1),PlotBlock.get((short)7,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz + 1),new Location(plotArea.worldname,ex - 1,dpw.ROAD_HEIGHT,ez - 1),dpw.ROAD_BLOCK);
  queue.enqueue();
  return true;
}"
57885,"@Override public boolean removeRoadSouthEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location location=getPlotTopLocAbs(dpw,plot.getId());
  int sx=location.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=location.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.ROAD_HEIGHT + 1,sz),new Location(plotArea.worldname,ex,255,ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,1,sz),new Location(plotArea.worldname,ex,dpw.ROAD_HEIGHT - 1,ez),dpw.MAIN_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.ROAD_HEIGHT,sz),new Location(plotArea.worldname,ex,dpw.ROAD_HEIGHT,ez),dpw.TOP_BLOCK);
  queue.enqueue();
  return true;
}","@Override public boolean removeRoadSouthEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location location=getPlotTopLocAbs(dpw,plot.getId());
  int sx=location.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=location.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.ROAD_HEIGHT + 1,sz),new Location(plotArea.worldname,ex,plotArea.getPlotManager().getWorldHeight(),ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,1,sz),new Location(plotArea.worldname,ex,dpw.ROAD_HEIGHT - 1,ez),dpw.MAIN_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.ROAD_HEIGHT,sz),new Location(plotArea.worldname,ex,dpw.ROAD_HEIGHT,ez),dpw.TOP_BLOCK);
  queue.enqueue();
  return true;
}"
57886,"@Override public boolean removeRoadSouth(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sz=pos2.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  int sx=pos1.getX() - 1;
  int ex=pos2.getX() + 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  queue.setCuboid(new Location(plotArea.worldname,sx,Math.min(dpw.PLOT_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz),new Location(plotArea.worldname,ex,Math.min(maxY,255),ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz),new Location(plotArea.worldname,ex - 1,dpw.PLOT_HEIGHT - 1,ez),dpw.MAIN_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.PLOT_HEIGHT,sz),new Location(plotArea.worldname,ex - 1,dpw.PLOT_HEIGHT,ez),dpw.TOP_BLOCK);
  queue.enqueue();
  return true;
}","@Override public boolean removeRoadSouth(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sz=pos2.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  int sx=pos1.getX() - 1;
  int ex=pos2.getX() + 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  queue.setCuboid(new Location(plotArea.worldname,sx,Math.min(dpw.PLOT_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz),new Location(plotArea.worldname,ex,plotArea.getPlotManager().getWorldHeight(),ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz),new Location(plotArea.worldname,ex - 1,dpw.PLOT_HEIGHT - 1,ez),dpw.MAIN_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.PLOT_HEIGHT,sz),new Location(plotArea.worldname,ex - 1,dpw.PLOT_HEIGHT,ez),dpw.TOP_BLOCK);
  queue.enqueue();
  return true;
}"
57887,"@Override public boolean removeRoadEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sx=pos2.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=pos1.getZ() - 1;
  int ez=pos2.getZ() + 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  queue.setCuboid(new Location(plotArea.worldname,sx,Math.min(dpw.PLOT_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz),new Location(plotArea.worldname,ex,Math.min(maxY,255),ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,1,sz + 1),new Location(plotArea.worldname,ex,dpw.PLOT_HEIGHT - 1,ez - 1),dpw.MAIN_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.PLOT_HEIGHT,sz + 1),new Location(plotArea.worldname,ex,dpw.PLOT_HEIGHT,ez - 1),dpw.TOP_BLOCK);
  queue.enqueue();
  return true;
}","@Override public boolean removeRoadEast(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sx=pos2.getX() + 1;
  int ex=sx + dpw.ROAD_WIDTH - 1;
  int sz=pos1.getZ() - 1;
  int ez=pos2.getZ() + 1;
  LocalBlockQueue queue=plotArea.getQueue(false);
  queue.setCuboid(new Location(plotArea.worldname,sx,Math.min(dpw.PLOT_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz),new Location(plotArea.worldname,ex,plotArea.getPlotManager().getWorldHeight(),ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx,1,sz + 1),new Location(plotArea.worldname,ex,dpw.PLOT_HEIGHT - 1,ez - 1),dpw.MAIN_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx,dpw.PLOT_HEIGHT,sz + 1),new Location(plotArea.worldname,ex,dpw.PLOT_HEIGHT,ez - 1),dpw.TOP_BLOCK);
  queue.enqueue();
  return true;
}"
57888,"public boolean setAll(PlotArea plotArea,PlotId plotId,PlotBlock[] blocks){
  Plot plot=plotArea.getPlotAbs(plotId);
  if (!plot.isBasePlot()) {
    return false;
  }
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  for (  RegionWrapper region : plot.getRegions()) {
    Location pos1=new Location(plotArea.worldname,region.minX,1,region.minZ);
    Location pos2=new Location(plotArea.worldname,region.maxX,Math.min(maxY,255),region.maxZ);
    queue.setCuboid(pos1,pos2,blocks);
  }
  queue.enqueue();
  return true;
}","public boolean setAll(PlotArea plotArea,PlotId plotId,PlotBlock[] blocks){
  Plot plot=plotArea.getPlotAbs(plotId);
  if (!plot.isBasePlot()) {
    return false;
  }
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  for (  RegionWrapper region : plot.getRegions()) {
    Location pos1=new Location(plotArea.worldname,region.minX,1,region.minZ);
    Location pos2=new Location(plotArea.worldname,region.maxX,maxY,region.maxZ);
    queue.setCuboid(pos1,pos2,blocks);
  }
  queue.enqueue();
  return true;
}"
57889,"@Override public boolean createRoadSouth(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sz=pos2.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  int sx=pos1.getX() - 2;
  int ex=pos2.getX() + 2;
  LocalBlockQueue queue=plotArea.getQueue(false);
  int maxY=plotArea.getPlotManager().getWorldHeight();
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,Math.min(dpw.WALL_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz),new Location(plotArea.worldname,ex - 1,Math.min(maxY,255),ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,0,sz),new Location(plotArea.worldname,ex - 1,0,ez),PlotBlock.get((short)7,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT,sz),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.WALL_HEIGHT + 1,sz),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT + 1,sz),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,ez),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT,ez),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.WALL_HEIGHT + 1,ez),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT + 1,ez),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz + 1),new Location(plotArea.worldname,ex - 1,dpw.ROAD_HEIGHT,ez - 1),dpw.ROAD_BLOCK);
  queue.enqueue();
  return true;
}","@Override public boolean createRoadSouth(PlotArea plotArea,Plot plot){
  ClassicPlotWorld dpw=(ClassicPlotWorld)plotArea;
  Location pos1=getPlotBottomLocAbs(plotArea,plot.getId());
  Location pos2=getPlotTopLocAbs(plotArea,plot.getId());
  int sz=pos2.getZ() + 1;
  int ez=sz + dpw.ROAD_WIDTH - 1;
  int sx=pos1.getX() - 2;
  int ex=pos2.getX() + 2;
  LocalBlockQueue queue=plotArea.getQueue(false);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,Math.min(dpw.WALL_HEIGHT,dpw.ROAD_HEIGHT) + 1,sz),new Location(plotArea.worldname,ex - 1,plotArea.getPlotManager().getWorldHeight(),ez),PlotBlock.get((short)0,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,0,sz),new Location(plotArea.worldname,ex - 1,0,ez),PlotBlock.get((short)7,(byte)0));
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT,sz),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.WALL_HEIGHT + 1,sz),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT + 1,sz),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,ez),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT,ez),dpw.WALL_FILLING);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,dpw.WALL_HEIGHT + 1,ez),new Location(plotArea.worldname,ex - 1,dpw.WALL_HEIGHT + 1,ez),dpw.WALL_BLOCK);
  queue.setCuboid(new Location(plotArea.worldname,sx + 1,1,sz + 1),new Location(plotArea.worldname,ex - 1,dpw.ROAD_HEIGHT,ez - 1),dpw.ROAD_BLOCK);
  queue.enqueue();
  return true;
}"
57890,"public int get_ey(LocalBlockQueue queue,int sx,int ex,int sz,int ez,int sy){
  int ey=sy;
  for (int x=sx; x <= ex; x++) {
    for (int z=sz; z <= ez; z++) {
      for (int y=sy; y < 256; y++) {
        if (y > ey) {
          PlotBlock block=queue.getBlock(x,y,z);
          if (block.id != 0) {
            ey=y;
          }
        }
      }
    }
  }
  return ey;
}","public int get_ey(final PlotManager pm,LocalBlockQueue queue,int sx,int ex,int sz,int ez,int sy){
  int ey=sy;
  for (int x=sx; x <= ex; x++) {
    for (int z=sz; z <= ez; z++) {
      for (int y=sy; y <= pm.getWorldHeight(); y++) {
        if (y > ey) {
          PlotBlock block=queue.getBlock(x,y,z);
          if (block.id != 0) {
            ey=y;
          }
        }
      }
    }
  }
  return ey;
}"
57891,"public boolean setupRoadSchematic(Plot plot){
  final String world=plot.getArea().worldname;
  final LocalBlockQueue queue=GlobalBlockQueue.IMP.getNewQueue(world,false);
  Location bot=plot.getBottomAbs().subtract(1,0,1);
  Location top=plot.getTopAbs();
  final HybridPlotWorld plotworld=(HybridPlotWorld)plot.getArea();
  int sx=bot.getX() - plotworld.ROAD_WIDTH + 1;
  int sz=bot.getZ() + 1;
  int sy=plotworld.ROAD_HEIGHT;
  int ex=bot.getX();
  int ez=top.getZ();
  int ey=get_ey(queue,sx,ex,sz,ez,sy);
  int bz=sz - plotworld.ROAD_WIDTH;
  int tz=sz - 1;
  int ty=get_ey(queue,sx,ex,bz,tz,sy);
  Set<RegionWrapper> sideRoad=new HashSet<>(Collections.singletonList(new RegionWrapper(sx,ex,sy,ey,sz,ez)));
  final Set<RegionWrapper> intersection=new HashSet<>(Collections.singletonList(new RegionWrapper(sx,ex,sy,ty,bz,tz)));
  final String dir=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ plot.getArea().toString()+ File.separator;
  SchematicHandler.manager.getCompoundTag(world,sideRoad,new RunnableVal<CompoundTag>(){
    @Override public void run(    CompoundTag value){
      SchematicHandler.manager.save(value,dir + ""String_Node_Str"");
      SchematicHandler.manager.getCompoundTag(world,intersection,new RunnableVal<CompoundTag>(){
        @Override public void run(        CompoundTag value){
          SchematicHandler.manager.save(value,dir + ""String_Node_Str"");
          plotworld.ROAD_SCHEMATIC_ENABLED=true;
          plotworld.setupSchematics();
        }
      }
);
    }
  }
);
  return true;
}","public boolean setupRoadSchematic(Plot plot){
  final String world=plot.getArea().worldname;
  final LocalBlockQueue queue=GlobalBlockQueue.IMP.getNewQueue(world,false);
  Location bot=plot.getBottomAbs().subtract(1,0,1);
  Location top=plot.getTopAbs();
  final HybridPlotWorld plotworld=(HybridPlotWorld)plot.getArea();
  PlotManager plotManager=plotworld.getPlotManager();
  int sx=bot.getX() - plotworld.ROAD_WIDTH + 1;
  int sz=bot.getZ() + 1;
  int sy=plotworld.ROAD_HEIGHT;
  int ex=bot.getX();
  int ez=top.getZ();
  int ey=get_ey(plotManager,queue,sx,ex,sz,ez,sy);
  int bz=sz - plotworld.ROAD_WIDTH;
  int tz=sz - 1;
  int ty=get_ey(plotManager,queue,sx,ex,bz,tz,sy);
  Set<RegionWrapper> sideRoad=new HashSet<>(Collections.singletonList(new RegionWrapper(sx,ex,sy,ey,sz,ez)));
  final Set<RegionWrapper> intersection=new HashSet<>(Collections.singletonList(new RegionWrapper(sx,ex,sy,ty,bz,tz)));
  final String dir=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ plot.getArea().toString()+ File.separator;
  SchematicHandler.manager.getCompoundTag(world,sideRoad,new RunnableVal<CompoundTag>(){
    @Override public void run(    CompoundTag value){
      SchematicHandler.manager.save(value,dir + ""String_Node_Str"");
      SchematicHandler.manager.getCompoundTag(world,intersection,new RunnableVal<CompoundTag>(){
        @Override public void run(        CompoundTag value){
          SchematicHandler.manager.save(value,dir + ""String_Node_Str"");
          plotworld.ROAD_SCHEMATIC_ENABLED=true;
          plotworld.setupSchematics();
        }
      }
);
    }
  }
);
  return true;
}"
57892,"/** 
 * Constructor
 * @param database
 * @param p prefix
 * @throws SQLException
 * @throws ClassNotFoundException
 */
public SQLManager(final Database database,String p,boolean debug) throws SQLException, ClassNotFoundException {
  this.database=database;
  this.connection=database.openConnection();
  this.mySQL=database instanceof MySQL;
  this.globalTasks=new ConcurrentLinkedQueue<>();
  this.notifyTasks=new ConcurrentLinkedQueue<>();
  this.plotTasks=new ConcurrentHashMap<>();
  this.playerTasks=new ConcurrentHashMap<>();
  this.clusterTasks=new ConcurrentHashMap<>();
  TaskManager.runTaskAsync(new Runnable(){
    @Override public void run(){
      long last=System.currentTimeMillis();
      while (true) {
        if (SQLManager.this.closed) {
          break;
        }
        if (SQLManager.this.mySQL && System.currentTimeMillis() - last > 550000) {
          last=System.currentTimeMillis();
          try {
            close();
            SQLManager.this.closed=false;
            SQLManager.this.connection=database.forceConnection();
          }
 catch (          SQLException|ClassNotFoundException e) {
            e.printStackTrace();
          }
        }
        if (!sendBatch()) {
          try {
            if (!getNotifyTasks().isEmpty()) {
              for (              Runnable task : getNotifyTasks()) {
                TaskManager.runTask(task);
              }
              getNotifyTasks().clear();
            }
            Thread.sleep(50);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
);
  this.prefix=p;
  this.SET_OWNER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.GET_ALL_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_SETTINGS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_TIERS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOT=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_CLUSTER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  createTables();
}","/** 
 * Constructor
 * @param database
 * @param p prefix
 * @throws SQLException
 * @throws ClassNotFoundException
 */
public SQLManager(final Database database,String p,boolean debug) throws SQLException, ClassNotFoundException {
  this.database=database;
  this.connection=database.openConnection();
  this.mySQL=database instanceof MySQL;
  this.globalTasks=new ConcurrentLinkedQueue<>();
  this.notifyTasks=new ConcurrentLinkedQueue<>();
  this.plotTasks=new ConcurrentHashMap<>();
  this.playerTasks=new ConcurrentHashMap<>();
  this.clusterTasks=new ConcurrentHashMap<>();
  this.prefix=p;
  this.SET_OWNER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.GET_ALL_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOTS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_SETTINGS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_TIERS=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_PLOT=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  this.CREATE_CLUSTER=""String_Node_Str"" + this.prefix + ""String_Node_Str"";
  TaskManager.runTaskAsync(new Runnable(){
    @Override public void run(){
      try {
        createTables();
      }
 catch (      SQLException e) {
        e.printStackTrace();
      }
      long last=System.currentTimeMillis();
      while (true) {
        if (SQLManager.this.closed) {
          break;
        }
        boolean hasTask=!globalTasks.isEmpty() || !playerTasks.isEmpty() || !plotTasks.isEmpty()|| !clusterTasks.isEmpty();
        if (hasTask) {
          try {
            if (SQLManager.this.mySQL && System.currentTimeMillis() - last > 550000 || !connection.isValid(10000)) {
              last=System.currentTimeMillis();
              reconnect();
            }
          }
 catch (          SQLException impossible) {
            impossible.printStackTrace();
          }
          if (!sendBatch()) {
            try {
              if (!getNotifyTasks().isEmpty()) {
                for (                Runnable task : getNotifyTasks()) {
                  TaskManager.runTask(task);
                }
                getNotifyTasks().clear();
              }
              Thread.sleep(50);
            }
 catch (            InterruptedException e) {
              e.printStackTrace();
            }
          }
        }
 else {
          try {
            Thread.sleep(5000);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
);
}"
57893,"@Override public void playMusic(Location location,int id){
  this.player.playEffect(BukkitUtil.getLocation(location),Effect.RECORD_PLAY,Material.getMaterial(id));
}","@Override public void playMusic(Location location,int id){
  this.player.playEffect(BukkitUtil.getLocation(location),Effect.RECORD_PLAY,id);
}"
57894,"@Override public void restoreTile(String world,CompoundTag tag,int x,int y,int z){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public boolean restoreTile(LocalBlockQueue queue,CompoundTag tag,int x,int y,int z){
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
57895,"@Override public void startMetrics(){
  try {
    SpongeMetrics metrics=new SpongeMetrics(this.game,this.plugin);
    metrics.start();
    PS.log(C.PREFIX.s() + ""String_Node_Str"");
  }
 catch (  IOException ignored) {
    PS.log(C.PREFIX.s() + ""String_Node_Str"");
  }
}","@Override public void startMetrics(){
  SpongeMetrics metrics=new SpongeMetrics(this.game,this.plugin);
  metrics.start();
  PS.log(C.PREFIX.s() + ""String_Node_Str"");
}"
57896,"@Override public List<String> getPluginIds(){
  ArrayList<String> names=new ArrayList<>();
  for (  Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
    names.add(plugin.getName() + ""String_Node_Str"" + plugin.getDescription().getVersion()+ ""String_Node_Str""+ plugin.isEnabled());
  }
  return names;
}","@Override public List<String> getPluginIds(){
  ArrayList<String> names=new ArrayList<>();
  for (  Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
    names.add(plugin.getName() + ';' + plugin.getDescription().getVersion()+ ':'+ plugin.isEnabled());
  }
  return names;
}"
57897,"@Override public PlotQueue<Chunk> initPlotQueue(){
  try {
    new SendChunk();
    MainUtil.canSendChunk=true;
  }
 catch (  Throwable e) {
    e.printStackTrace();
    MainUtil.canSendChunk=false;
  }
  if (PS.get().checkVersion(getServerVersion(),1,9,0)) {
    try {
      return new FastQueue_1_9();
    }
 catch (    Throwable e) {
      e.printStackTrace();
      return new SlowQueue();
    }
  }
  if (PS.get().checkVersion(getServerVersion(),1,8,0)) {
    try {
      return new FastQueue_1_8_3();
    }
 catch (    Throwable e) {
      e.printStackTrace();
      try {
        return new FastQueue_1_8();
      }
 catch (      Throwable e2) {
        e2.printStackTrace();
        return new SlowQueue();
      }
    }
  }
  try {
    return new FastQueue_1_7();
  }
 catch (  Throwable e) {
    e.printStackTrace();
    return new SlowQueue();
  }
}","@Override public PlotQueue<Chunk> initPlotQueue(){
  try {
    new SendChunk();
    MainUtil.canSendChunk=true;
  }
 catch (  ClassNotFoundException|NoSuchFieldException|NoSuchMethodException e) {
    e.printStackTrace();
    MainUtil.canSendChunk=false;
  }
  if (PS.get().checkVersion(getServerVersion(),1,9,0)) {
    try {
      return new FastQueue_1_9();
    }
 catch (    ClassNotFoundException|NoSuchFieldException|NoSuchMethodException e) {
      e.printStackTrace();
      return new SlowQueue();
    }
  }
  if (PS.get().checkVersion(getServerVersion(),1,8,0)) {
    try {
      return new FastQueue_1_8_3();
    }
 catch (    NoSuchMethodException|ClassNotFoundException|NoSuchFieldException e) {
      e.printStackTrace();
      try {
        return new FastQueue_1_8();
      }
 catch (      NoSuchMethodException|NoSuchFieldException|ClassNotFoundException e2) {
        e2.printStackTrace();
        return new SlowQueue();
      }
    }
  }
  try {
    return new FastQueue_1_7();
  }
 catch (  ClassNotFoundException|NoSuchFieldException|NoSuchMethodException e) {
    e.printStackTrace();
    return new SlowQueue();
  }
}"
57898,"@Override public boolean onCommand(final PlotPlayer player,String[] args){
  final UUIDWrapper currentUUIDWrapper=UUIDHandler.getUUIDWrapper();
  final UUIDWrapper newWrapper;
switch (args[0].toLowerCase()) {
case ""String_Node_Str"":
    newWrapper=new LowerOfflineUUIDWrapper();
  break;
case ""String_Node_Str"":
newWrapper=new OfflineUUIDWrapper();
break;
case ""String_Node_Str"":
newWrapper=new DefaultUUIDWrapper();
break;
default :
try {
Class<?> clazz=Class.forName(args[0]);
newWrapper=(UUIDWrapper)clazz.newInstance();
}
 catch (ClassNotFoundException|IllegalAccessException|InstantiationException e) {
MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
}
if (args.length != 2 || !""String_Node_Str"".equals(args[1])) {
MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"" + args[0] + ""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
return false;
}
if (currentUUIDWrapper.getClass().getCanonicalName().equals(newWrapper.getClass().getCanonicalName())) {
MainUtil.sendMessage(player,""String_Node_Str"");
return false;
}
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
for (Entry<String,PlotPlayer> entry : UUIDHandler.getPlayers().entrySet()) {
entry.getValue().kick(""String_Node_Str"");
}
MainUtil.sendMessage(player,""String_Node_Str"");
final HashMap<UUID,UUID> uCMap=new HashMap<>();
final HashMap<UUID,UUID> uCReverse=new HashMap<>();
MainUtil.sendMessage(player,""String_Node_Str"");
HashSet<String> worlds=new HashSet<>();
worlds.add(WorldUtil.IMP.getMainWorld());
worlds.add(""String_Node_Str"");
HashSet<UUID> uuids=new HashSet<>();
HashSet<String> names=new HashSet<>();
for (String worldName : worlds) {
File playerDataFolder=new File(worldName + File.separator + ""String_Node_Str"");
String[] dat=playerDataFolder.list(new FilenameFilter(){
@Override public boolean accept(File f,String s){
return s.endsWith(""String_Node_Str"");
}
}
);
if (dat != null) {
for (String current : dat) {
String s=current.replaceAll(""String_Node_Str"",""String_Node_Str"");
try {
UUID uuid=UUID.fromString(s);
uuids.add(uuid);
}
 catch (Exception ignored) {
MainUtil.sendMessage(player,C.PREFIX + ""String_Node_Str"" + current);
}
}
}
File playersFolder=new File(worldName + File.separator + ""String_Node_Str"");
dat=playersFolder.list(new FilenameFilter(){
@Override public boolean accept(File f,String s){
return s.endsWith(""String_Node_Str"");
}
}
);
if (dat != null) {
for (String current : dat) {
names.add(current.replaceAll(""String_Node_Str"",""String_Node_Str""));
}
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
UUID uuid2;
UUIDWrapper wrapper=new DefaultUUIDWrapper();
for (UUID uuid : uuids) {
try {
OfflinePlotPlayer op=wrapper.getOfflinePlayer(uuid);
uuid=currentUUIDWrapper.getUUID(op);
uuid2=newWrapper.getUUID(op);
if (!uuid.equals(uuid2) && !uCMap.containsKey(uuid) && !uCReverse.containsKey(uuid2)) {
uCMap.put(uuid,uuid2);
uCReverse.put(uuid2,uuid);
}
}
 catch (Throwable ignored) {
MainUtil.sendMessage(player,C.PREFIX + ""String_Node_Str"" + uuid.toString()+ ""String_Node_Str"");
}
}
for (String name : names) {
UUID uuid=currentUUIDWrapper.getUUID(name);
uuid2=newWrapper.getUUID(name);
if (!uuid.equals(uuid2)) {
uCMap.put(uuid,uuid2);
uCReverse.put(uuid2,uuid);
}
}
if (uCMap.isEmpty()) {
MainUtil.sendMessage(player,""String_Node_Str"");
for (OfflinePlotPlayer op : currentUUIDWrapper.getOfflinePlayers()) {
if (op.getLastPlayed() != 0) {
UUID uuid=currentUUIDWrapper.getUUID(op);
uuid2=newWrapper.getUUID(op);
if (!uuid.equals(uuid2)) {
uCMap.put(uuid,uuid2);
uCReverse.put(uuid2,uuid);
}
}
}
if (uCMap.isEmpty()) {
MainUtil.sendMessage(player,""String_Node_Str"");
return false;
}
 else {
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
TaskManager.runTaskAsync(new Runnable(){
@Override public void run(){
for (Entry<UUID,UUID> entry : uCMap.entrySet()) {
String name=UUIDHandler.getName(entry.getKey());
if (name != null) {
UUIDHandler.add(new StringWrapper(name),entry.getValue());
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
File file=new File(PS.get().IMP.getDirectory(),""String_Node_Str"");
if (file.exists()) {
try {
List<String> lines=Files.readAllLines(file.toPath(),StandardCharsets.UTF_8);
for (String line : lines) {
try {
line=line.trim();
if (line.isEmpty()) {
  continue;
}
line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
String[] split=line.split(""String_Node_Str"");
String name=split[0];
if (name.isEmpty() || name.length() > 16 || !StringMan.isAlphanumericUnd(name)) {
  continue;
}
UUID old=currentUUIDWrapper.getUUID(name);
if (old == null) {
  continue;
}
UUID now=newWrapper.getUUID(name);
UUIDHandler.add(new StringWrapper(name),now);
uCMap.put(old,now);
uCReverse.put(now,old);
}
 catch (Exception e2) {
e2.printStackTrace();
}
}
}
 catch (IOException e) {
e.printStackTrace();
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
UUIDHandler.setUUIDWrapper(newWrapper);
MainUtil.sendMessage(player,""String_Node_Str"");
for (Plot plot : PS.get().getPlots()) {
UUID value=uCMap.get(plot.owner);
if (value != null) {
plot.owner=value;
}
plot.getTrusted().clear();
plot.getMembers().clear();
plot.getDenied().clear();
}
MainUtil.sendMessage(player,""String_Node_Str"");
final AbstractDB database=DBFunc.dbManager;
boolean result=database.deleteTables();
MainUtil.sendMessage(player,""String_Node_Str"");
try {
database.createTables();
if (!result) {
MainUtil.sendMessage(player,""String_Node_Str"");
for (Plot plot : PS.get().getPlots()) {
UUID value=uCReverse.get(plot.owner);
if (value != null) {
plot.owner=value;
}
}
database.createPlotsAndData(new ArrayList<>(PS.get().getPlots()),new Runnable(){
@Override public void run(){
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
);
return;
}
}
 catch (Exception e) {
e.printStackTrace();
return;
}
if (newWrapper instanceof OfflineUUIDWrapper) {
PS.get().config.set(""String_Node_Str"",false);
PS.get().config.set(""String_Node_Str"",true);
}
 else if (newWrapper instanceof DefaultUUIDWrapper) {
PS.get().config.set(""String_Node_Str"",false);
PS.get().config.set(""String_Node_Str"",false);
}
try {
PS.get().config.save(PS.get().configFile);
}
 catch (IOException e) {
MainUtil.sendMessage(player,""String_Node_Str"");
}
MainUtil.sendMessage(player,""String_Node_Str"");
TaskManager.runTaskAsync(new Runnable(){
@Override public void run(){
ArrayList<Plot> plots=new ArrayList<>(PS.get().getPlots());
database.createPlotsAndData(plots,new Runnable(){
@Override public void run(){
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
);
}
}
);
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
);
return true;
}","@Override public boolean onCommand(final PlotPlayer player,String[] args){
  final UUIDWrapper currentUUIDWrapper=UUIDHandler.getUUIDWrapper();
  final UUIDWrapper newWrapper;
switch (args[0].toLowerCase()) {
case ""String_Node_Str"":
    newWrapper=new LowerOfflineUUIDWrapper();
  break;
case ""String_Node_Str"":
newWrapper=new OfflineUUIDWrapper();
break;
case ""String_Node_Str"":
newWrapper=new DefaultUUIDWrapper();
break;
default :
try {
Class<?> clazz=Class.forName(args[0]);
newWrapper=(UUIDWrapper)clazz.newInstance();
}
 catch (ClassNotFoundException|IllegalAccessException|InstantiationException e) {
MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
}
if (args.length != 2 || !""String_Node_Str"".equals(args[1])) {
MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"" + args[0] + ""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
return false;
}
if (currentUUIDWrapper.getClass().getCanonicalName().equals(newWrapper.getClass().getCanonicalName())) {
MainUtil.sendMessage(player,""String_Node_Str"");
return false;
}
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
for (Entry<String,PlotPlayer> entry : UUIDHandler.getPlayers().entrySet()) {
entry.getValue().kick(""String_Node_Str"");
}
MainUtil.sendMessage(player,""String_Node_Str"");
final HashMap<UUID,UUID> uCMap=new HashMap<>();
final HashMap<UUID,UUID> uCReverse=new HashMap<>();
MainUtil.sendMessage(player,""String_Node_Str"");
HashSet<String> worlds=new HashSet<>();
worlds.add(WorldUtil.IMP.getMainWorld());
worlds.add(""String_Node_Str"");
HashSet<UUID> uuids=new HashSet<>();
HashSet<String> names=new HashSet<>();
for (String worldName : worlds) {
File playerDataFolder=new File(worldName + File.separator + ""String_Node_Str"");
String[] dat=playerDataFolder.list(new FilenameFilter(){
@Override public boolean accept(File f,String s){
return s.endsWith(""String_Node_Str"");
}
}
);
if (dat != null) {
for (String current : dat) {
String s=current.replaceAll(""String_Node_Str"",""String_Node_Str"");
try {
UUID uuid=UUID.fromString(s);
uuids.add(uuid);
}
 catch (Exception ignored) {
MainUtil.sendMessage(player,C.PREFIX + ""String_Node_Str"" + current);
}
}
}
File playersFolder=new File(worldName + File.separator + ""String_Node_Str"");
dat=playersFolder.list(new FilenameFilter(){
@Override public boolean accept(File f,String s){
return s.endsWith(""String_Node_Str"");
}
}
);
if (dat != null) {
for (String current : dat) {
names.add(current.replaceAll(""String_Node_Str"",""String_Node_Str""));
}
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
UUID uuid2;
UUIDWrapper wrapper=new DefaultUUIDWrapper();
for (UUID uuid : uuids) {
try {
OfflinePlotPlayer op=wrapper.getOfflinePlayer(uuid);
uuid=currentUUIDWrapper.getUUID(op);
uuid2=newWrapper.getUUID(op);
if (!uuid.equals(uuid2) && !uCMap.containsKey(uuid) && !uCReverse.containsKey(uuid2)) {
uCMap.put(uuid,uuid2);
uCReverse.put(uuid2,uuid);
}
}
 catch (Throwable ignored) {
MainUtil.sendMessage(player,C.PREFIX + ""String_Node_Str"" + uuid.toString()+ ""String_Node_Str"");
}
}
for (String name : names) {
UUID uuid=currentUUIDWrapper.getUUID(name);
uuid2=newWrapper.getUUID(name);
if (!uuid.equals(uuid2)) {
uCMap.put(uuid,uuid2);
uCReverse.put(uuid2,uuid);
}
}
if (uCMap.isEmpty()) {
MainUtil.sendMessage(player,""String_Node_Str"");
for (OfflinePlotPlayer op : currentUUIDWrapper.getOfflinePlayers()) {
if (op.getLastPlayed() != 0) {
UUID uuid=currentUUIDWrapper.getUUID(op);
uuid2=newWrapper.getUUID(op);
if (!uuid.equals(uuid2)) {
uCMap.put(uuid,uuid2);
uCReverse.put(uuid2,uuid);
}
}
}
if (uCMap.isEmpty()) {
MainUtil.sendMessage(player,""String_Node_Str"");
return false;
}
 else {
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
TaskManager.runTaskAsync(new Runnable(){
@Override public void run(){
for (Entry<UUID,UUID> entry : uCMap.entrySet()) {
String name=UUIDHandler.getName(entry.getKey());
if (name != null) {
UUIDHandler.add(new StringWrapper(name),entry.getValue());
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
File file=new File(PS.get().IMP.getDirectory(),""String_Node_Str"");
if (file.exists()) {
try {
List<String> lines=Files.readAllLines(file.toPath(),StandardCharsets.UTF_8);
for (String line : lines) {
try {
line=line.trim();
if (line.isEmpty()) {
  continue;
}
line=line.replaceAll(""String_Node_Str"",""String_Node_Str"");
String[] split=line.split(""String_Node_Str"");
String name=split[0];
if (name.isEmpty() || name.length() > 16 || !StringMan.isAlphanumericUnd(name)) {
  continue;
}
UUID old=currentUUIDWrapper.getUUID(name);
if (old == null) {
  continue;
}
UUID now=newWrapper.getUUID(name);
UUIDHandler.add(new StringWrapper(name),now);
uCMap.put(old,now);
uCReverse.put(now,old);
}
 catch (Exception e2) {
e2.printStackTrace();
}
}
}
 catch (IOException e) {
e.printStackTrace();
}
}
MainUtil.sendMessage(player,""String_Node_Str"");
UUIDHandler.setUUIDWrapper(newWrapper);
MainUtil.sendMessage(player,""String_Node_Str"");
for (Plot plot : PS.get().getPlots()) {
UUID value=uCMap.get(plot.owner);
if (value != null) {
plot.owner=value;
}
plot.getTrusted().clear();
plot.getMembers().clear();
plot.getDenied().clear();
}
MainUtil.sendMessage(player,""String_Node_Str"");
final AbstractDB database=DBFunc.dbManager;
boolean result=database.deleteTables();
MainUtil.sendMessage(player,""String_Node_Str"");
try {
database.createTables();
if (!result) {
MainUtil.sendMessage(player,""String_Node_Str"");
for (Plot plot : PS.get().getPlots()) {
UUID value=uCReverse.get(plot.owner);
if (value != null) {
plot.owner=value;
}
}
database.createPlotsAndData(new ArrayList<>(PS.get().getPlots()),new Runnable(){
@Override public void run(){
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
);
return;
}
}
 catch (Exception e) {
e.printStackTrace();
return;
}
if (newWrapper instanceof OfflineUUIDWrapper) {
PS.get().config.set(""String_Node_Str"",false);
PS.get().config.set(""String_Node_Str"",true);
}
 else if (newWrapper instanceof DefaultUUIDWrapper) {
PS.get().config.set(""String_Node_Str"",false);
PS.get().config.set(""String_Node_Str"",false);
}
try {
PS.get().config.save(PS.get().configFile);
}
 catch (IOException ignored) {
MainUtil.sendMessage(player,""String_Node_Str"");
}
MainUtil.sendMessage(player,""String_Node_Str"");
TaskManager.runTaskAsync(new Runnable(){
@Override public void run(){
ArrayList<Plot> plots=new ArrayList<>(PS.get().getPlots());
database.createPlotsAndData(plots,new Runnable(){
@Override public void run(){
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
);
}
}
);
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
}
}
);
return true;
}"
57899,"@Override public Connection getPlotMeConnection(FileConfiguration plotConfig,String dataFolder){
  this.plugin=this.plugin.toLowerCase();
  this.prefix=plotConfig.getString(""String_Node_Str"",this.plugin.toLowerCase());
  try {
    if (plotConfig.getBoolean(""String_Node_Str"")) {
      String user=plotConfig.getString(""String_Node_Str"");
      String password=plotConfig.getString(""String_Node_Str"");
      String con=plotConfig.getString(""String_Node_Str"");
      return DriverManager.getConnection(con,user,password);
    }
 else {
      return new SQLite(dataFolder + File.separator + ""String_Node_Str"").openConnection();
    }
  }
 catch (  SQLException|ClassNotFoundException ignored) {
    ignored.printStackTrace();
  }
  return null;
}","@Override public Connection getPlotMeConnection(FileConfiguration plotConfig,String dataFolder){
  this.plugin=this.plugin.toLowerCase();
  this.prefix=plotConfig.getString(""String_Node_Str"",this.plugin.toLowerCase());
  try {
    if (plotConfig.getBoolean(""String_Node_Str"")) {
      String user=plotConfig.getString(""String_Node_Str"");
      String password=plotConfig.getString(""String_Node_Str"");
      String con=plotConfig.getString(""String_Node_Str"");
      return DriverManager.getConnection(con,user,password);
    }
 else {
      return new SQLite(dataFolder + File.separator + ""String_Node_Str"").openConnection();
    }
  }
 catch (  SQLException|ClassNotFoundException e) {
    e.printStackTrace();
  }
  return null;
}"
57900,"@Override public List<BlockPopulator> getDefaultPopulators(World world){
  try {
    if (!this.loaded) {
      String name=world.getName();
      PS.get().loadWorld(name,this);
      Set<PlotArea> areas=PS.get().getPlotAreas(name);
      if (!areas.isEmpty()) {
        PlotArea area=areas.iterator().next();
        if (!area.MOB_SPAWNING) {
          if (!area.SPAWN_EGGS) {
            world.setSpawnFlags(false,false);
          }
          world.setAmbientSpawnLimit(0);
          world.setAnimalSpawnLimit(0);
          world.setMonsterSpawnLimit(0);
          world.setWaterAnimalSpawnLimit(0);
        }
 else {
          world.setSpawnFlags(true,true);
          world.setAmbientSpawnLimit(-1);
          world.setAnimalSpawnLimit(-1);
          world.setMonsterSpawnLimit(-1);
          world.setWaterAnimalSpawnLimit(-1);
        }
      }
      this.loaded=true;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  ArrayList<BlockPopulator> toAdd=new ArrayList<BlockPopulator>();
  List<BlockPopulator> existing=world.getPopulators();
  for (  BlockPopulator populator : this.populators) {
    if (!existing.contains(populator)) {
      toAdd.add(populator);
    }
  }
  return toAdd;
}","@Override public List<BlockPopulator> getDefaultPopulators(World world){
  try {
    if (!this.loaded) {
      String name=world.getName();
      PS.get().loadWorld(name,this);
      Set<PlotArea> areas=PS.get().getPlotAreas(name);
      if (!areas.isEmpty()) {
        PlotArea area=areas.iterator().next();
        if (!area.MOB_SPAWNING) {
          if (!area.SPAWN_EGGS) {
            world.setSpawnFlags(false,false);
          }
          world.setAmbientSpawnLimit(0);
          world.setAnimalSpawnLimit(0);
          world.setMonsterSpawnLimit(0);
          world.setWaterAnimalSpawnLimit(0);
        }
 else {
          world.setSpawnFlags(true,true);
          world.setAmbientSpawnLimit(-1);
          world.setAnimalSpawnLimit(-1);
          world.setMonsterSpawnLimit(-1);
          world.setWaterAnimalSpawnLimit(-1);
        }
      }
      this.loaded=true;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  ArrayList<BlockPopulator> toAdd=new ArrayList<>();
  List<BlockPopulator> existing=world.getPopulators();
  for (  BlockPopulator populator : this.populators) {
    if (!existing.contains(populator)) {
      toAdd.add(populator);
    }
  }
  return toAdd;
}"
57901,"public int getInt(String s){
  try {
    int max=0;
    String[] split=s.split(""String_Node_Str"");
    for (    String rad : split) {
      int val=Integer.parseInt(rad);
      if (val > max) {
        max=val;
      }
    }
    return max;
  }
 catch (  NumberFormatException e) {
    return 0;
  }
}","public int getInt(String s){
  try {
    int max=0;
    String[] split=s.split(""String_Node_Str"");
    for (    String rad : split) {
      int val=Integer.parseInt(rad);
      if (val > max) {
        max=val;
      }
    }
    return max;
  }
 catch (  NumberFormatException ignored) {
    return 0;
  }
}"
57902,"public boolean checkVolume(PlotPlayer player,long volume,long max,Cancellable e){
  if (volume > max) {
    MainUtil.sendMessage(player,C.WORLDEDIT_VOLUME.s().replaceAll(""String_Node_Str"",volume + ""String_Node_Str"").replaceAll(""String_Node_Str"",max + ""String_Node_Str""));
    e.setCancelled(true);
  }
  if (Permissions.hasPermission(player,""String_Node_Str"")) {
    MainUtil.sendMessage(player,C.WORLDEDIT_BYPASS);
  }
  return true;
}","public boolean checkVolume(PlotPlayer player,long volume,long max,Cancellable e){
  if (volume > max) {
    MainUtil.sendMessage(player,C.WORLDEDIT_VOLUME.s().replaceAll(""String_Node_Str"",String.valueOf(volume)).replaceAll(""String_Node_Str"",String.valueOf(max)));
    e.setCancelled(true);
  }
  if (Permissions.hasPermission(player,""String_Node_Str"")) {
    MainUtil.sendMessage(player,C.WORLDEDIT_BYPASS);
  }
  return true;
}"
57903,"@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public boolean onPlayerCommand(PlayerCommandPreprocessEvent e){
  WorldEditPlugin worldedit=BukkitMain.worldEdit;
  if (worldedit == null) {
    HandlerList.unregisterAll(this);
    return true;
  }
  Player p=e.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(p);
  if (!PS.get().hasPlotArea(p.getWorld().getName())) {
    return true;
  }
  String message=e.getMessage();
  String cmd=message.toLowerCase();
  String[] split=cmd.split(""String_Node_Str"");
  long maxVolume=Settings.WE_MAX_VOLUME;
  long maxIterations=Settings.WE_MAX_ITERATIONS;
  if (pp.getAttribute(""String_Node_Str"")) {
    return true;
  }
  boolean single=true;
  if (split.length >= 2) {
    String reduced=reduceCmd(split[0],single);
    String reduced2=reduceCmd(split[0] + ""String_Node_Str"" + split[1],single);
    if (this.rad1.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      long volume=getInt(split[1]) * 256;
      return checkVolume(pp,volume,maxVolume,e);
    }
    if (this.rad2.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        long volume=getInt(split[2]) * 256;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad2_1.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 4) {
        long volume=getInt(split[2]) * getInt(split[3]);
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad2_2.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        long radius=getInt(split[2]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad2_3.contains(reduced2)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        if (split.length == 4) {
          int iterations=getInt(split[3]);
          if (iterations > maxIterations) {
            MainUtil.sendMessage(pp,C.WORLDEDIT_ITERATIONS.s().replaceAll(""String_Node_Str"",iterations + ""String_Node_Str"").replaceAll(""String_Node_Str"",maxIterations + ""String_Node_Str""));
            e.setCancelled(true);
            if (Permissions.hasPermission(pp,""String_Node_Str"")) {
              MainUtil.sendMessage(pp,C.WORLDEDIT_BYPASS);
            }
            return true;
          }
        }
        long radius=getInt(split[2]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad3_1.contains(reduced2)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        int i=2;
        if (split[i].equalsIgnoreCase(""String_Node_Str"")) {
          i=3;
        }
        long radius=getInt(split[i]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad3_2.contains(reduced2)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 4) {
        int i=3;
        if (split[i].equalsIgnoreCase(""String_Node_Str"")) {
          i=4;
        }
        long radius=getInt(split[i]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.regionExtend.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      return checkSelection(p,pp,getInt(split[1]),maxVolume,e);
    }
  }
  String reduced=reduceCmd(split[0],single);
  if (Settings.WE_BLACKLIST.contains(reduced)) {
    MainUtil.sendMessage(pp,C.WORLDEDIT_UNSAFE);
    e.setCancelled(true);
    if (Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.WORLDEDIT_BYPASS);
    }
  }
  if (this.restricted.contains(reduced)) {
    Plot plot=pp.getCurrentPlot();
    if ((plot != null) && plot.isAdded(pp.getUUID())) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      return true;
    }
    e.setCancelled(true);
    MainUtil.sendMessage(pp,C.NO_PLOT_PERMS);
    if (Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.WORLDEDIT_BYPASS);
    }
    return true;
  }
  if (this.region.contains(reduced)) {
    if (delay(p,message,false)) {
      e.setCancelled(true);
      return true;
    }
    return checkSelection(p,pp,1,maxVolume,e);
  }
  if (this.other.contains(reduced)) {
    if (delay(p,message,false)) {
      e.setCancelled(true);
      return true;
    }
  }
  return true;
}","@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public boolean onPlayerCommand(PlayerCommandPreprocessEvent e){
  WorldEditPlugin worldedit=BukkitMain.worldEdit;
  if (worldedit == null) {
    HandlerList.unregisterAll(this);
    return true;
  }
  Player p=e.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(p);
  if (!PS.get().hasPlotArea(p.getWorld().getName())) {
    return true;
  }
  String message=e.getMessage();
  String cmd=message.toLowerCase();
  String[] split=cmd.split(""String_Node_Str"");
  long maxVolume=Settings.WE_MAX_VOLUME;
  long maxIterations=Settings.WE_MAX_ITERATIONS;
  if (pp.getAttribute(""String_Node_Str"")) {
    return true;
  }
  boolean single=true;
  if (split.length >= 2) {
    String reduced=reduceCmd(split[0],single);
    String reduced2=reduceCmd(split[0] + ' ' + split[1],single);
    if (this.rad1.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      long volume=getInt(split[1]) * 256;
      return checkVolume(pp,volume,maxVolume,e);
    }
    if (this.rad2.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        long volume=getInt(split[2]) * 256;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad2_1.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 4) {
        long volume=getInt(split[2]) * getInt(split[3]);
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad2_2.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        long radius=getInt(split[2]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad2_3.contains(reduced2)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        if (split.length == 4) {
          int iterations=getInt(split[3]);
          if (iterations > maxIterations) {
            MainUtil.sendMessage(pp,C.WORLDEDIT_ITERATIONS.s().replaceAll(""String_Node_Str"",String.valueOf(iterations)).replaceAll(""String_Node_Str"",String.valueOf(maxIterations)));
            e.setCancelled(true);
            if (Permissions.hasPermission(pp,""String_Node_Str"")) {
              MainUtil.sendMessage(pp,C.WORLDEDIT_BYPASS);
            }
            return true;
          }
        }
        long radius=getInt(split[2]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad3_1.contains(reduced2)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 3) {
        int i=2;
        if (split[i].equalsIgnoreCase(""String_Node_Str"")) {
          i=3;
        }
        long radius=getInt(split[i]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.rad3_2.contains(reduced2)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      if (split.length >= 4) {
        int i=3;
        if (split[i].equalsIgnoreCase(""String_Node_Str"")) {
          i=4;
        }
        long radius=getInt(split[i]);
        long volume=radius * radius;
        return checkVolume(pp,volume,maxVolume,e);
      }
      return true;
    }
    if (this.regionExtend.contains(reduced)) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      return checkSelection(p,pp,getInt(split[1]),maxVolume,e);
    }
  }
  String reduced=reduceCmd(split[0],single);
  if (Settings.WE_BLACKLIST.contains(reduced)) {
    MainUtil.sendMessage(pp,C.WORLDEDIT_UNSAFE);
    e.setCancelled(true);
    if (Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.WORLDEDIT_BYPASS);
    }
  }
  if (this.restricted.contains(reduced)) {
    Plot plot=pp.getCurrentPlot();
    if ((plot != null) && plot.isAdded(pp.getUUID())) {
      if (delay(p,message,false)) {
        e.setCancelled(true);
        return true;
      }
      return true;
    }
    e.setCancelled(true);
    MainUtil.sendMessage(pp,C.NO_PLOT_PERMS);
    if (Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.WORLDEDIT_BYPASS);
    }
    return true;
  }
  if (this.region.contains(reduced)) {
    if (delay(p,message,false)) {
      e.setCancelled(true);
      return true;
    }
    return checkSelection(p,pp,1,maxVolume,e);
  }
  if (this.other.contains(reduced)) {
    if (delay(p,message,false)) {
      e.setCancelled(true);
      return true;
    }
  }
  return true;
}"
57904,"/** 
 * Appends a json encoded key/value pair to the given string builder.
 * @param json
 * @param key
 * @param value
 */
private static void appendJSONPair(StringBuilder json,String key,String value){
  boolean isValueNumeric=false;
  try {
    if (value.equals(""String_Node_Str"") || !value.endsWith(""String_Node_Str"")) {
      Double.parseDouble(value);
      isValueNumeric=true;
    }
  }
 catch (  NumberFormatException e) {
    isValueNumeric=false;
  }
  if (json.charAt(json.length() - 1) != '{') {
    json.append(',');
  }
  json.append(escapeJSON(key));
  json.append(':');
  if (isValueNumeric) {
    json.append(value);
  }
 else {
    json.append(escapeJSON(value));
  }
}","/** 
 * Appends a json encoded key/value pair to the given string builder.
 * @param json
 * @param key
 * @param value
 */
private static void appendJSONPair(StringBuilder json,String key,String value){
  boolean isValueNumeric=false;
  try {
    if (value.equals(""String_Node_Str"") || !value.endsWith(""String_Node_Str"")) {
      Double.parseDouble(value);
      isValueNumeric=true;
    }
  }
 catch (  NumberFormatException ignored) {
    isValueNumeric=false;
  }
  if (json.charAt(json.length() - 1) != '{') {
    json.append(',');
  }
  json.append(escapeJSON(key));
  json.append(':');
  if (isValueNumeric) {
    json.append(value);
  }
 else {
    json.append(escapeJSON(value));
  }
}"
57905,"/** 
 * Check if mineshafter is present. If it is, we need to bypass it to send POST requests
 * @return true if mineshafter is installed on the server
 */
private boolean isMineshafterPresent(){
  try {
    Class.forName(""String_Node_Str"");
    return true;
  }
 catch (  ClassNotFoundException e) {
    return false;
  }
}","/** 
 * Check if mineshafter is present. If it is, we need to bypass it to send POST requests
 * @return true if mineshafter is installed on the server
 */
private boolean isMineshafterPresent(){
  try {
    Class.forName(""String_Node_Str"");
    return true;
  }
 catch (  ClassNotFoundException ignored) {
    return false;
  }
}"
57906,"/** 
 * Constructor
 */
public SendChunk(){
  RefClass classCraftPlayer=getRefClass(""String_Node_Str"");
  this.methodGetHandlePlayer=classCraftPlayer.getMethod(""String_Node_Str"");
  RefClass classCraftChunk=getRefClass(""String_Node_Str"");
  this.methodGetHandleChunk=classCraftChunk.getMethod(""String_Node_Str"");
  RefClass classChunk=getRefClass(""String_Node_Str"");
  this.methodInitLighting=classChunk.getMethod(""String_Node_Str"");
  RefClass classMapChunk=getRefClass(""String_Node_Str"");
  this.mapChunk=classMapChunk.getConstructor(classChunk.getRealClass(),boolean.class,int.class);
  RefClass classEntityPlayer=getRefClass(""String_Node_Str"");
  this.connection=classEntityPlayer.getField(""String_Node_Str"");
  RefClass classPacket=getRefClass(""String_Node_Str"");
  RefClass classConnection=getRefClass(""String_Node_Str"");
  this.send=classConnection.getMethod(""String_Node_Str"",classPacket.getRealClass());
}","/** 
 * Constructor
 */
public SendChunk() throws ClassNotFoundException, NoSuchMethodException, NoSuchFieldException {
  RefClass classCraftPlayer=getRefClass(""String_Node_Str"");
  this.methodGetHandlePlayer=classCraftPlayer.getMethod(""String_Node_Str"");
  RefClass classCraftChunk=getRefClass(""String_Node_Str"");
  this.methodGetHandleChunk=classCraftChunk.getMethod(""String_Node_Str"");
  RefClass classChunk=getRefClass(""String_Node_Str"");
  this.methodInitLighting=classChunk.getMethod(""String_Node_Str"");
  RefClass classMapChunk=getRefClass(""String_Node_Str"");
  this.mapChunk=classMapChunk.getConstructor(classChunk.getRealClass(),boolean.class,int.class);
  RefClass classEntityPlayer=getRefClass(""String_Node_Str"");
  this.connection=classEntityPlayer.getField(""String_Node_Str"");
  RefClass classPacket=getRefClass(""String_Node_Str"");
  RefClass classConnection=getRefClass(""String_Node_Str"");
  this.send=classConnection.getMethod(""String_Node_Str"",classPacket.getRealClass());
}"
57907,"public FastQueue_1_7() throws RuntimeException {
  this.methodGetHandle=this.classCraftWorld.getMethod(""String_Node_Str"");
  this.methodGetChunkAt=this.classWorld.getMethod(""String_Node_Str"",int.class,int.class);
  this.methodA=this.classChunk.getMethod(""String_Node_Str"",int.class,int.class,int.class,this.classBlock,int.class);
  this.methodGetById=this.classBlock.getMethod(""String_Node_Str"",int.class);
  this.methodInitLighting=this.classChunk.getMethod(""String_Node_Str"");
  this.sendChunk=new SendChunk();
  TaskManager.runTaskRepeat(new Runnable(){
    @Override public void run(){
      if (FastQueue_1_7.this.toUpdate.isEmpty()) {
        return;
      }
      int count=0;
      ArrayList<Chunk> chunks=new ArrayList<>();
      Iterator<Entry<ChunkWrapper,Chunk>> i=FastQueue_1_7.this.toUpdate.entrySet().iterator();
      while (i.hasNext() && (count < 128)) {
        chunks.add(i.next().getValue());
        i.remove();
        count++;
      }
      if (count == 0) {
        return;
      }
      update(chunks);
    }
  }
,1);
  MainUtil.initCache();
}","public FastQueue_1_7() throws NoSuchMethodException, ClassNotFoundException, NoSuchFieldException {
  this.methodGetHandle=this.classCraftWorld.getMethod(""String_Node_Str"");
  this.methodGetChunkAt=this.classWorld.getMethod(""String_Node_Str"",int.class,int.class);
  this.methodA=this.classChunk.getMethod(""String_Node_Str"",int.class,int.class,int.class,this.classBlock,int.class);
  this.methodGetById=this.classBlock.getMethod(""String_Node_Str"",int.class);
  this.methodInitLighting=this.classChunk.getMethod(""String_Node_Str"");
  this.sendChunk=new SendChunk();
  TaskManager.runTaskRepeat(new Runnable(){
    @Override public void run(){
      if (FastQueue_1_7.this.toUpdate.isEmpty()) {
        return;
      }
      int count=0;
      ArrayList<Chunk> chunks=new ArrayList<>();
      Iterator<Entry<ChunkWrapper,Chunk>> i=FastQueue_1_7.this.toUpdate.entrySet().iterator();
      while (i.hasNext() && (count < 128)) {
        chunks.add(i.next().getValue());
        i.remove();
        count++;
      }
      if (count == 0) {
        return;
      }
      update(chunks);
    }
  }
,1);
  MainUtil.initCache();
}"
57908,"@Override public void run(){
  if (FastQueue_1_8.this.toUpdate.isEmpty()) {
    return;
  }
  int count=0;
  ArrayList<Chunk> chunks=new ArrayList<Chunk>();
  Iterator<Entry<ChunkWrapper,Chunk>> i=FastQueue_1_8.this.toUpdate.entrySet().iterator();
  while (i.hasNext() && count < 128) {
    chunks.add(i.next().getValue());
    i.remove();
    count++;
  }
  if (count == 0) {
    return;
  }
  update(chunks);
}","@Override public void run(){
  if (FastQueue_1_8.this.toUpdate.isEmpty()) {
    return;
  }
  int count=0;
  ArrayList<Chunk> chunks=new ArrayList<>();
  Iterator<Entry<ChunkWrapper,Chunk>> i=FastQueue_1_8.this.toUpdate.entrySet().iterator();
  while (i.hasNext() && count < 128) {
    chunks.add(i.next().getValue());
    i.remove();
    count++;
  }
  if (count == 0) {
    return;
  }
  update(chunks);
}"
57909,"public FastQueue_1_8() throws RuntimeException {
  this.methodInitLighting=this.classChunk.getMethod(""String_Node_Str"");
  this.constructorBlockPosition=this.classBlockPosition.getConstructor(int.class,int.class,int.class);
  this.methodGetByCombinedId=this.classBlock.getMethod(""String_Node_Str"",int.class);
  this.methodGetHandle=this.classCraftWorld.getMethod(""String_Node_Str"");
  this.methodGetChunkAt=this.classWorld.getMethod(""String_Node_Str"",int.class,int.class);
  this.methodA=this.classChunk.getMethod(""String_Node_Str"",this.classBlockPosition,this.classIBlockData);
  this.sendChunk=new SendChunk();
  TaskManager.runTaskRepeat(new Runnable(){
    @Override public void run(){
      if (FastQueue_1_8.this.toUpdate.isEmpty()) {
        return;
      }
      int count=0;
      ArrayList<Chunk> chunks=new ArrayList<Chunk>();
      Iterator<Entry<ChunkWrapper,Chunk>> i=FastQueue_1_8.this.toUpdate.entrySet().iterator();
      while (i.hasNext() && count < 128) {
        chunks.add(i.next().getValue());
        i.remove();
        count++;
      }
      if (count == 0) {
        return;
      }
      update(chunks);
    }
  }
,1);
  MainUtil.initCache();
}","public FastQueue_1_8() throws NoSuchMethodException, ClassNotFoundException, NoSuchFieldException {
  this.methodInitLighting=this.classChunk.getMethod(""String_Node_Str"");
  this.constructorBlockPosition=this.classBlockPosition.getConstructor(int.class,int.class,int.class);
  this.methodGetByCombinedId=this.classBlock.getMethod(""String_Node_Str"",int.class);
  this.methodGetHandle=this.classCraftWorld.getMethod(""String_Node_Str"");
  this.methodGetChunkAt=this.classWorld.getMethod(""String_Node_Str"",int.class,int.class);
  this.methodA=this.classChunk.getMethod(""String_Node_Str"",this.classBlockPosition,this.classIBlockData);
  this.sendChunk=new SendChunk();
  TaskManager.runTaskRepeat(new Runnable(){
    @Override public void run(){
      if (FastQueue_1_8.this.toUpdate.isEmpty()) {
        return;
      }
      int count=0;
      ArrayList<Chunk> chunks=new ArrayList<>();
      Iterator<Entry<ChunkWrapper,Chunk>> i=FastQueue_1_8.this.toUpdate.entrySet().iterator();
      while (i.hasNext() && count < 128) {
        chunks.add(i.next().getValue());
        i.remove();
        count++;
      }
      if (count == 0) {
        return;
      }
      update(chunks);
    }
  }
,1);
  MainUtil.initCache();
}"
57910,"@Test public void flagTest() throws Exception {
  Plot plot=new Plot(null,new PlotId(0,0));
  plot.owner=UUID.fromString(""String_Node_Str"");
  Optional<? extends Collection> flag=plot.getFlag(use);
  if (flag.isPresent()) {
    System.out.println(Flags.USE.valueToString(flag.get()));
    testBlock=new PlotBlock((short)1,(byte)0);
    flag.get().add(testBlock);
  }
  if (flag.isPresent()) {
    System.out.println(Flags.USE.valueToString(flag.get()));
  }
  Optional<HashSet<PlotBlock>> flag2=plot.getFlag(Flags.USE);
  if (flag2.isPresent()) {
    assertThat(flag2.get(),(Matcher<? super HashSet<PlotBlock>>)IsCollectionContaining.hasItem(testBlock));
  }
  if (flag.isPresent() && flag2.isPresent()) {
    assertEquals(flag.get(),flag2.get());
  }
}","@Test public void flagTest() throws Exception {
  Plot plot=new Plot(null,new PlotId(0,0));
  plot.owner=UUID.fromString(""String_Node_Str"");
  Optional<? extends Collection> flag=plot.getFlag(use);
  if (flag.isPresent()) {
    System.out.println(Flags.USE.valueToString(flag.get()));
    testBlock=new PlotBlock((short)1,(byte)0);
    flag.get().add(testBlock);
  }
  if (flag.isPresent()) {
    System.out.println(Flags.USE.valueToString(flag.get()));
  }
  Optional<HashSet<PlotBlock>> flag2=plot.getFlag(Flags.USE);
  if (flag2.isPresent()) {
  }
  if (flag.isPresent() && flag2.isPresent()) {
    assertEquals(flag.get(),flag2.get());
  }
}"
57911,"@Override public PlotPlayer wrapPlayer(Object player){
  if (player instanceof Player) {
    return BukkitUtil.getPlayer((Player)player);
  }
 else   if (player instanceof OfflinePlayer) {
    return BukkitUtil.getPlayer((OfflinePlayer)player);
  }
 else   if (player instanceof String) {
    return UUIDHandler.getPlayer((String)player);
  }
 else   if (player instanceof UUID) {
    return UUIDHandler.getPlayer((UUID)player);
  }
  return null;
}","@Override public PlotPlayer wrapPlayer(Object player){
  if (player instanceof Player) {
    return BukkitUtil.getPlayer((Player)player);
  }
  if (player instanceof OfflinePlayer) {
    return BukkitUtil.getPlayer((OfflinePlayer)player);
  }
  if (player instanceof String) {
    return UUIDHandler.getPlayer((String)player);
  }
  if (player instanceof UUID) {
    return UUIDHandler.getPlayer((UUID)player);
  }
  return null;
}"
57912,"@Override public TextualComponent clone() throws CloneNotSupportedException {
  return new ComplexTextTypeComponent(getKey(),getValue());
}","@Override public TextualComponent clone(){
  return new ComplexTextTypeComponent(getKey(),getValue());
}"
57913,"@Override public void run(){
  try {
    boolean mv=false;
    boolean mw=false;
    if ((Bukkit.getPluginManager().getPlugin(""String_Node_Str"") != null) && Bukkit.getPluginManager().getPlugin(""String_Node_Str"").isEnabled()) {
      mv=true;
    }
 else     if ((Bukkit.getPluginManager().getPlugin(""String_Node_Str"") != null) && Bukkit.getPluginManager().getPlugin(""String_Node_Str"").isEnabled()) {
      mw=true;
    }
    for (    String worldName : worlds) {
      World world=Bukkit.getWorld(getWorld(worldName));
      if (world == null) {
        sendMessage(""String_Node_Str"" + worldName);
      }
      String actualWorldName=world.getName();
      sendMessage(""String_Node_Str"" + actualWorldName + ""String_Node_Str"");
      PS.get().removePlotAreas(actualWorldName);
      if (mv) {
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ex) {
          Thread.currentThread().interrupt();
        }
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName + ""String_Node_Str"");
      }
 else       if (mw) {
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ex) {
          Thread.currentThread().interrupt();
        }
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName + ""String_Node_Str"");
      }
 else {
        Bukkit.getServer().unloadWorld(world,true);
        World myWorld=WorldCreator.name(actualWorldName).generator(new BukkitPlotGenerator(new HybridGen())).createWorld();
        myWorld.save();
      }
    }
  }
 catch (  CommandException e) {
    e.printStackTrace();
  }
  if (done.get()) {
    done();
    sendMessage(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
  }
 else {
    sendMessage(""String_Node_Str"");
    done.set(true);
  }
}","@Override public void run(){
  try {
    boolean mv=false;
    boolean mw=false;
    if ((Bukkit.getPluginManager().getPlugin(""String_Node_Str"") != null) && Bukkit.getPluginManager().getPlugin(""String_Node_Str"").isEnabled()) {
      mv=true;
    }
 else     if ((Bukkit.getPluginManager().getPlugin(""String_Node_Str"") != null) && Bukkit.getPluginManager().getPlugin(""String_Node_Str"").isEnabled()) {
      mw=true;
    }
    for (    String worldName : worlds) {
      World world=Bukkit.getWorld(getWorld(worldName));
      if (world == null) {
        sendMessage(""String_Node_Str"" + worldName);
      }
      String actualWorldName=world.getName();
      sendMessage(""String_Node_Str"" + actualWorldName + ""String_Node_Str"");
      PS.get().removePlotAreas(actualWorldName);
      if (mv) {
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
          Thread.currentThread().interrupt();
        }
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName + ""String_Node_Str"");
      }
 else       if (mw) {
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
          Thread.currentThread().interrupt();
        }
        Bukkit.getServer().dispatchCommand(Bukkit.getServer().getConsoleSender(),""String_Node_Str"" + actualWorldName + ""String_Node_Str"");
      }
 else {
        Bukkit.getServer().unloadWorld(world,true);
        World myWorld=WorldCreator.name(actualWorldName).generator(new BukkitPlotGenerator(new HybridGen())).createWorld();
        myWorld.save();
      }
    }
  }
 catch (  CommandException e) {
    e.printStackTrace();
  }
  if (done.get()) {
    done();
    sendMessage(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
    PS.debug(""String_Node_Str"");
  }
 else {
    sendMessage(""String_Node_Str"");
    done.set(true);
  }
}"
57914,"@EventHandler(ignoreCancelled=true,priority=EventPriority.HIGHEST) public void onEntityFall(EntityChangeBlockEvent event){
  if (event.getEntityType() != EntityType.FALLING_BLOCK) {
    return;
  }
  Block block=event.getBlock();
  World world=block.getWorld();
  String worldName=world.getName();
  if (!PS.get().hasPlotArea(worldName)) {
    return;
  }
  Location location=BukkitUtil.getLocation(block.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlotAbs(location);
  if (plot == null) {
    event.setCancelled(true);
    return;
  }
  if (plot.getFlag(Flags.DISABLE_PHYSICS).or(false)) {
    event.setCancelled(true);
    return;
  }
  if (event.getTo().hasGravity()) {
    Entity entity=event.getEntity();
    List<MetadataValue> meta=entity.getMetadata(""String_Node_Str"");
    if (meta.isEmpty()) {
      return;
    }
    Plot origin=(Plot)meta.get(0).value();
    if (origin != null && !origin.equals(plot)) {
      event.setCancelled(true);
      entity.remove();
    }
  }
 else   if (event.getTo() == Material.AIR) {
    event.getEntity().setMetadata(""String_Node_Str"",new FixedMetadataValue((Plugin)PS.get().IMP,plot));
  }
}","@EventHandler(ignoreCancelled=true,priority=EventPriority.HIGHEST) public void onEntityFall(EntityChangeBlockEvent event){
  if (event.getEntityType() != EntityType.FALLING_BLOCK) {
    return;
  }
  Block block=event.getBlock();
  World world=block.getWorld();
  String worldName=world.getName();
  if (!PS.get().hasPlotArea(worldName)) {
    return;
  }
  Location location=BukkitUtil.getLocation(block.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlotAbs(location);
  if (plot == null || plot.getFlag(Flags.DISABLE_PHYSICS).or(false)) {
    event.setCancelled(true);
    return;
  }
  if (event.getTo().hasGravity()) {
    Entity entity=event.getEntity();
    List<MetadataValue> meta=entity.getMetadata(""String_Node_Str"");
    if (meta.isEmpty()) {
      return;
    }
    Plot origin=(Plot)meta.get(0).value();
    if (origin != null && !origin.equals(plot)) {
      event.setCancelled(true);
      entity.remove();
    }
  }
 else   if (event.getTo() == Material.AIR) {
    event.getEntity().setMetadata(""String_Node_Str"",new FixedMetadataValue((Plugin)PS.get().IMP,plot));
  }
}"
57915,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onEntityDamageByEntityEvent(EntityDamageByEntityEvent e){
  Entity damager=e.getDamager();
  Location l=BukkitUtil.getLocation(damager);
  if (!PS.get().hasPlotArea(l.getWorld())) {
    return;
  }
  Entity victim=e.getEntity();
  if (!entityDamage(damager,victim)) {
    e.setCancelled(true);
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onEntityDamageByEntityEvent(EntityDamageByEntityEvent event){
  Entity damager=event.getDamager();
  Location l=BukkitUtil.getLocation(damager);
  if (!PS.get().hasPlotArea(l.getWorld())) {
    return;
  }
  Entity victim=event.getEntity();
  if (!entityDamage(damager,victim)) {
    event.setCancelled(true);
  }
}"
57916,"@EventHandler public boolean onProjectileHit(ProjectileHitEvent event){
  Projectile entity=event.getEntity();
  Location loc=BukkitUtil.getLocation(entity);
  if (!PS.get().hasPlotArea(loc.getWorld())) {
    return true;
  }
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return true;
  }
  Plot plot=area.getPlotAbs(loc);
  ProjectileSource shooter=entity.getShooter();
  if (shooter instanceof Player) {
    PlotPlayer pp=BukkitUtil.getPlayer((Player)shooter);
    if (plot == null) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_PROJECTILE_UNOWNED)) {
        entity.remove();
        return false;
      }
      return true;
    }
    if (plot.isAdded(pp.getUUID()) || Permissions.hasPermission(pp,C.PERMISSION_PROJECTILE_OTHER)) {
      return true;
    }
    entity.remove();
    return false;
  }
 else   if (!(shooter instanceof Entity) && shooter != null) {
    if (plot == null) {
      entity.remove();
      return false;
    }
    Location sLoc=BukkitUtil.getLocation(((BlockProjectileSource)shooter).getBlock().getLocation());
    if (!area.contains(sLoc.getX(),sLoc.getZ())) {
      entity.remove();
      return false;
    }
    Plot sPlot=area.getOwnedPlotAbs(sLoc);
    if (sPlot == null || !PlotHandler.sameOwners(plot,sPlot)) {
      entity.remove();
      return false;
    }
  }
  return true;
}","@EventHandler public boolean onProjectileHit(ProjectileHitEvent event){
  Projectile entity=event.getEntity();
  Location loc=BukkitUtil.getLocation(entity);
  if (!PS.get().hasPlotArea(loc.getWorld())) {
    return true;
  }
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return true;
  }
  Plot plot=area.getPlotAbs(loc);
  ProjectileSource shooter=entity.getShooter();
  if (shooter instanceof Player) {
    PlotPlayer pp=BukkitUtil.getPlayer((Player)shooter);
    if (plot == null) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_PROJECTILE_UNOWNED)) {
        entity.remove();
        return false;
      }
      return true;
    }
    if (plot.isAdded(pp.getUUID()) || Permissions.hasPermission(pp,C.PERMISSION_PROJECTILE_OTHER)) {
      return true;
    }
    entity.remove();
    return false;
  }
  if (!(shooter instanceof Entity) && shooter != null) {
    if (plot == null) {
      entity.remove();
      return false;
    }
    Location sLoc=BukkitUtil.getLocation(((BlockProjectileSource)shooter).getBlock().getLocation());
    if (!area.contains(sLoc.getX(),sLoc.getZ())) {
      entity.remove();
      return false;
    }
    Plot sPlot=area.getOwnedPlotAbs(sLoc);
    if (sPlot == null || !PlotHandler.sameOwners(plot,sPlot)) {
      entity.remove();
      return false;
    }
  }
  return true;
}"
57917,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockSpread(BlockSpreadEvent event){
  Block block=event.getBlock();
  Location location=BukkitUtil.getLocation(block.getLocation());
  if (location.isPlotRoad()) {
    event.setCancelled(true);
    return;
  }
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlot(location);
switch (block.getType()) {
case GRASS:
    if (plot.getFlag(Flags.GRASS_GROW).isPresent() && plot.getFlag(Flags.GRASS_GROW).get()) {
      event.setCancelled(true);
    }
  break;
case MYCEL:
if (plot.getFlag(Flags.MYCEL_GROW).isPresent() && plot.getFlag(Flags.MYCEL_GROW).get()) {
  event.setCancelled(true);
}
break;
case VINE:
if (plot.getFlag(Flags.VINE_GROW).isPresent() && plot.getFlag(Flags.VINE_GROW).get()) {
event.setCancelled(true);
}
break;
}
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockSpread(BlockSpreadEvent event){
  Block block=event.getBlock();
  Location location=BukkitUtil.getLocation(block.getLocation());
  if (location.isPlotRoad()) {
    event.setCancelled(true);
    return;
  }
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlot(location);
  Optional<Boolean> flag;
switch (block.getType()) {
case GRASS:
    flag=plot.getFlag(Flags.GRASS_GROW);
  if (flag.isPresent() && flag.get()) {
    event.setCancelled(true);
  }
break;
case MYCEL:
flag=plot.getFlag(Flags.MYCEL_GROW);
if (flag.isPresent() && flag.get()) {
event.setCancelled(true);
}
break;
case VINE:
flag=plot.getFlag(Flags.VINE_GROW);
if (flag.isPresent() && flag.get()) {
event.setCancelled(true);
}
break;
}
}"
57918,"public boolean checkEntity(Entity entity,Plot plot){
  if (plot == null || plot.owner == null || plot.getFlags().isEmpty() && plot.getArea().DEFAULT_FLAGS.isEmpty()) {
    return false;
  }
switch (entity.getType()) {
case PLAYER:
    return false;
case SMALL_FIREBALL:
case FIREBALL:
case DROPPED_ITEM:
case EGG:
case THROWN_EXP_BOTTLE:
case SPLASH_POTION:
case LINGERING_POTION:
case SNOWBALL:
case ENDER_PEARL:
case ARROW:
case TIPPED_ARROW:
case SPECTRAL_ARROW:
case SHULKER_BULLET:
case DRAGON_FIREBALL:
case PRIMED_TNT:
case FALLING_BLOCK:
case ENDER_CRYSTAL:
case COMPLEX_PART:
case FISHING_HOOK:
case ENDER_SIGNAL:
case EXPERIENCE_ORB:
case LEASH_HITCH:
case FIREWORK:
case WEATHER:
case AREA_EFFECT_CLOUD:
case LIGHTNING:
case WITHER_SKULL:
case UNKNOWN:
  return checkEntity(plot,Flags.ENTITY_CAP);
case ITEM_FRAME:
case PAINTING:
case ARMOR_STAND:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MISC_CAP);
case MINECART:
case MINECART_CHEST:
case MINECART_COMMAND:
case MINECART_FURNACE:
case MINECART_HOPPER:
case MINECART_MOB_SPAWNER:
case MINECART_TNT:
case BOAT:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.VEHICLE_CAP);
case RABBIT:
case SHEEP:
case MUSHROOM_COW:
case OCELOT:
case PIG:
case SQUID:
case VILLAGER:
case IRON_GOLEM:
case WOLF:
case CHICKEN:
case COW:
case SNOWMAN:
case BAT:
case HORSE:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.ANIMAL_CAP);
case BLAZE:
case CAVE_SPIDER:
case CREEPER:
case ENDERMAN:
case ENDERMITE:
case ENDER_DRAGON:
case GHAST:
case GIANT:
case GUARDIAN:
case MAGMA_CUBE:
case PIG_ZOMBIE:
case SILVERFISH:
case SKELETON:
case SLIME:
case SPIDER:
case WITCH:
case WITHER:
case ZOMBIE:
case SHULKER:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.HOSTILE_CAP);
default :
if (entity instanceof LivingEntity) {
if (entity instanceof Animals) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.ANIMAL_CAP);
}
 else if (entity instanceof Monster) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.HOSTILE_CAP);
}
 else {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP);
}
}
 else if (entity instanceof Vehicle) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.VEHICLE_CAP);
}
 else if (entity instanceof Hanging) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MISC_CAP);
}
return checkEntity(plot,Flags.ENTITY_CAP);
}
}","public boolean checkEntity(Entity entity,Plot plot){
  if (plot == null || !plot.hasOwner() || plot.getFlags().isEmpty() && plot.getArea().DEFAULT_FLAGS.isEmpty()) {
    return false;
  }
switch (entity.getType()) {
case PLAYER:
    return false;
case SMALL_FIREBALL:
case FIREBALL:
case DROPPED_ITEM:
case EGG:
case THROWN_EXP_BOTTLE:
case SPLASH_POTION:
case LINGERING_POTION:
case SNOWBALL:
case ENDER_PEARL:
case ARROW:
case TIPPED_ARROW:
case SPECTRAL_ARROW:
case SHULKER_BULLET:
case DRAGON_FIREBALL:
case PRIMED_TNT:
case FALLING_BLOCK:
case ENDER_CRYSTAL:
case COMPLEX_PART:
case FISHING_HOOK:
case ENDER_SIGNAL:
case EXPERIENCE_ORB:
case LEASH_HITCH:
case FIREWORK:
case WEATHER:
case AREA_EFFECT_CLOUD:
case LIGHTNING:
case WITHER_SKULL:
case UNKNOWN:
  return checkEntity(plot,Flags.ENTITY_CAP);
case ITEM_FRAME:
case PAINTING:
case ARMOR_STAND:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MISC_CAP);
case MINECART:
case MINECART_CHEST:
case MINECART_COMMAND:
case MINECART_FURNACE:
case MINECART_HOPPER:
case MINECART_MOB_SPAWNER:
case MINECART_TNT:
case BOAT:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.VEHICLE_CAP);
case RABBIT:
case SHEEP:
case MUSHROOM_COW:
case OCELOT:
case PIG:
case SQUID:
case VILLAGER:
case IRON_GOLEM:
case WOLF:
case CHICKEN:
case COW:
case SNOWMAN:
case BAT:
case HORSE:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.ANIMAL_CAP);
case BLAZE:
case CAVE_SPIDER:
case CREEPER:
case ENDERMAN:
case ENDERMITE:
case ENDER_DRAGON:
case GHAST:
case GIANT:
case GUARDIAN:
case MAGMA_CUBE:
case PIG_ZOMBIE:
case SILVERFISH:
case SKELETON:
case SLIME:
case SPIDER:
case WITCH:
case WITHER:
case ZOMBIE:
case SHULKER:
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.HOSTILE_CAP);
default :
if (entity instanceof LivingEntity) {
if (entity instanceof Animals) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.ANIMAL_CAP);
}
 else if (entity instanceof Monster) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP,Flags.HOSTILE_CAP);
}
 else {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MOB_CAP);
}
}
if (entity instanceof Vehicle) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.VEHICLE_CAP);
}
if (entity instanceof Hanging) {
return checkEntity(plot,Flags.ENTITY_CAP,Flags.MISC_CAP);
}
return checkEntity(plot,Flags.ENTITY_CAP);
}
}"
57919,"@EventHandler(priority=EventPriority.LOWEST) public void blockDestroy(BlockBreakEvent event){
  Player player=event.getPlayer();
  Location loc=BukkitUtil.getLocation(event.getBlock().getLocation());
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getPlotAbs(loc);
  if (plot != null) {
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (event.getBlock().getY() == 0) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_GROUNDLEVEL)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_GROUNDLEVEL);
        event.setCancelled(true);
        return;
      }
    }
    if (!plot.hasOwner()) {
      if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_UNOWNED)) {
        return;
      }
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_UNOWNED);
      event.setCancelled(true);
      return;
    }
 else     if (!plot.isAdded(pp.getUUID())) {
      Optional<HashSet<PlotBlock>> destroy=plot.getFlag(Flags.BREAK);
      Block block=event.getBlock();
      if (destroy.isPresent() && destroy.get().contains(new PlotBlock((short)block.getTypeId(),block.getData()))) {
        return;
      }
      if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_OTHER)) {
        return;
      }
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_OTHER);
      event.setCancelled(true);
    }
 else     if (Settings.DONE_RESTRICTS_BUILDING && plot.getFlags().containsKey(Flags.DONE)) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
        return;
      }
    }
    return;
  }
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_ROAD)) {
    return;
  }
  if (PS.get().worldedit != null && pp.getAttribute(""String_Node_Str"")) {
    if (player.getItemInHand().getTypeId() == PS.get().worldedit.getConfiguration().wandItem) {
      return;
    }
  }
  MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_ROAD);
  event.setCancelled(true);
}","@EventHandler(priority=EventPriority.LOWEST) public void blockDestroy(BlockBreakEvent event){
  Player player=event.getPlayer();
  Location loc=BukkitUtil.getLocation(event.getBlock().getLocation());
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getPlotAbs(loc);
  if (plot != null) {
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (event.getBlock().getY() == 0) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_GROUNDLEVEL)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_GROUNDLEVEL);
        event.setCancelled(true);
        return;
      }
    }
    if (!plot.hasOwner()) {
      if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_UNOWNED)) {
        return;
      }
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_UNOWNED);
      event.setCancelled(true);
      return;
    }
    if (!plot.isAdded(pp.getUUID())) {
      Optional<HashSet<PlotBlock>> destroy=plot.getFlag(Flags.BREAK);
      Block block=event.getBlock();
      if (destroy.isPresent() && destroy.get().contains(new PlotBlock((short)block.getTypeId(),block.getData()))) {
        return;
      }
      if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_OTHER)) {
        return;
      }
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_OTHER);
      event.setCancelled(true);
    }
 else     if (Settings.DONE_RESTRICTS_BUILDING && plot.getFlags().containsKey(Flags.DONE)) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
        return;
      }
    }
    return;
  }
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_ROAD)) {
    return;
  }
  if (PS.get().worldedit != null && pp.getAttribute(""String_Node_Str"")) {
    if (player.getItemInHand().getTypeId() == PS.get().worldedit.getConfiguration().wandItem) {
      return;
    }
  }
  MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_DESTROY_ROAD);
  event.setCancelled(true);
}"
57920,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockDamage(BlockDamageEvent event){
  Player player=event.getPlayer();
  Location location=BukkitUtil.getLocation(event.getBlock().getLocation());
  if (player == null) {
    if (location.isPlotRoad()) {
      event.setCancelled(true);
      return;
    }
  }
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getPlotAbs(location);
  if (plot != null) {
    if (location.getY() == 0) {
      event.setCancelled(true);
      return;
    }
    if (!plot.hasOwner()) {
      PlotPlayer pp=BukkitUtil.getPlayer(player);
      if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_UNOWNED)) {
        return;
      }
      event.setCancelled(true);
      return;
    }
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (!plot.isAdded(pp.getUUID())) {
      Optional<HashSet<PlotBlock>> destroy=plot.getFlag(Flags.BREAK);
      Block block=event.getBlock();
      if (destroy.isPresent() && destroy.get().contains(new PlotBlock((short)block.getTypeId(),block.getData()))) {
        return;
      }
      if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_OTHER)) {
        return;
      }
      event.setCancelled(true);
      return;
    }
    return;
  }
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_ROAD)) {
    return;
  }
  event.setCancelled(true);
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockDamage(BlockDamageEvent event){
  Player player=event.getPlayer();
  Location location=BukkitUtil.getLocation(event.getBlock().getLocation());
  if (player == null) {
    if (location.isPlotRoad()) {
      event.setCancelled(true);
      return;
    }
  }
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getPlotAbs(location);
  if (plot != null) {
    if (location.getY() == 0) {
      event.setCancelled(true);
      return;
    }
    if (!plot.hasOwner()) {
      PlotPlayer pp=BukkitUtil.getPlayer(player);
      if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_UNOWNED)) {
        return;
      }
      event.setCancelled(true);
      return;
    }
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (!plot.isAdded(pp.getUUID())) {
      Optional<HashSet<PlotBlock>> destroy=plot.getFlag(Flags.BREAK);
      Block block=event.getBlock();
      if (destroy.isPresent() && destroy.get().contains(new PlotBlock((short)block.getTypeId(),block.getData())) || Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_OTHER)) {
        return;
      }
      event.setCancelled(true);
      return;
    }
    return;
  }
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  if (Permissions.hasPermission(pp,C.PERMISSION_ADMIN_DESTROY_ROAD)) {
    return;
  }
  event.setCancelled(true);
}"
57921,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockIgnite(BlockIgniteEvent event){
  Player player=event.getPlayer();
  Entity ignitingEntity=event.getIgnitingEntity();
  Block block=event.getBlock();
  BlockIgniteEvent.IgniteCause igniteCause=event.getCause();
  Location loc;
  if (block != null) {
    loc=BukkitUtil.getLocation(block.getLocation());
  }
 else   if (ignitingEntity != null) {
    loc=BukkitUtil.getLocation(ignitingEntity);
  }
 else   if (player != null) {
    loc=BukkitUtil.getLocation(player);
  }
 else {
    return;
  }
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return;
  }
  if (igniteCause == BlockIgniteEvent.IgniteCause.LIGHTNING) {
    event.setCancelled(true);
    return;
  }
  Plot plot=area.getOwnedPlotAbs(loc);
  if (player != null) {
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (plot == null) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_ROAD)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_ROAD);
        event.setCancelled(true);
      }
    }
 else     if (!plot.hasOwner()) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_UNOWNED)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_UNOWNED);
        event.setCancelled(true);
      }
    }
 else     if (!plot.isAdded(pp.getUUID())) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
      }
    }
 else     if (!plot.getFlag(Flags.BLOCK_IGNITION).or(false)) {
      event.setCancelled(true);
    }
  }
 else   if (ignitingEntity != null) {
    if (plot == null || !plot.getFlag(Flags.BLOCK_IGNITION).or(false)) {
      event.setCancelled(true);
      return;
    }
    if (igniteCause == BlockIgniteEvent.IgniteCause.FIREBALL) {
      if (ignitingEntity instanceof Fireball) {
        Projectile fireball=(Projectile)ignitingEntity;
        Location location=null;
        if (fireball.getShooter() instanceof Entity) {
          Entity shooter=(Entity)fireball.getShooter();
          location=BukkitUtil.getLocation(shooter.getLocation());
        }
 else         if (fireball.getShooter() instanceof BlockProjectileSource) {
          Block shooter=((BlockProjectileSource)fireball.getShooter()).getBlock();
          location=BukkitUtil.getLocation(shooter.getLocation());
        }
        if (location != null && (location.getPlot() == null || !location.getPlot().equals(plot))) {
          event.setCancelled(true);
        }
      }
    }
  }
 else   if (event.getIgnitingBlock() != null) {
    Block ignitingBlock=event.getIgnitingBlock();
    if (igniteCause == BlockIgniteEvent.IgniteCause.FLINT_AND_STEEL) {
      if (plot == null || !plot.getFlag(Flags.BLOCK_IGNITION).or(false)) {
        event.setCancelled(true);
        return;
      }
      if (BukkitUtil.getLocation(ignitingBlock.getLocation()).getPlot() == null) {
        event.setCancelled(true);
        return;
      }
      if (!BukkitUtil.getLocation(ignitingBlock.getLocation()).getPlot().equals(plot)) {
        event.setCancelled(true);
        return;
      }
    }
    if (igniteCause == BlockIgniteEvent.IgniteCause.SPREAD || igniteCause == BlockIgniteEvent.IgniteCause.LAVA) {
      if (plot == null || !plot.getFlag(Flags.BLOCK_IGNITION).or(false)) {
        event.setCancelled(true);
        return;
      }
      if (BukkitUtil.getLocation(ignitingBlock.getLocation()).getPlot() == null) {
        event.setCancelled(true);
        return;
      }
      if (!BukkitUtil.getLocation(ignitingBlock.getLocation()).getPlot().equals(plot)) {
        event.setCancelled(true);
        return;
      }
    }
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockIgnite(BlockIgniteEvent event){
  Player player=event.getPlayer();
  Entity ignitingEntity=event.getIgnitingEntity();
  Block block=event.getBlock();
  BlockIgniteEvent.IgniteCause igniteCause=event.getCause();
  Location loc;
  if (block != null) {
    loc=BukkitUtil.getLocation(block.getLocation());
  }
 else   if (ignitingEntity != null) {
    loc=BukkitUtil.getLocation(ignitingEntity);
  }
 else   if (player != null) {
    loc=BukkitUtil.getLocation(player);
  }
 else {
    return;
  }
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return;
  }
  if (igniteCause == BlockIgniteEvent.IgniteCause.LIGHTNING) {
    event.setCancelled(true);
    return;
  }
  Plot plot=area.getOwnedPlotAbs(loc);
  if (player != null) {
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (plot == null) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_ROAD)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_ROAD);
        event.setCancelled(true);
      }
    }
 else     if (!plot.hasOwner()) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_UNOWNED)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_UNOWNED);
        event.setCancelled(true);
      }
    }
 else     if (!plot.isAdded(pp.getUUID())) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
      }
    }
 else     if (!plot.getFlag(Flags.BLOCK_IGNITION).or(false)) {
      event.setCancelled(true);
    }
  }
 else {
    if (plot == null) {
      event.setCancelled(true);
      return;
    }
    if (ignitingEntity != null) {
      if (!plot.getFlag(Flags.BLOCK_IGNITION).or(false)) {
        event.setCancelled(true);
        return;
      }
      if (igniteCause == BlockIgniteEvent.IgniteCause.FIREBALL) {
        if (ignitingEntity instanceof Fireball) {
          Projectile fireball=(Projectile)ignitingEntity;
          Location location=null;
          if (fireball.getShooter() instanceof Entity) {
            Entity shooter=(Entity)fireball.getShooter();
            location=BukkitUtil.getLocation(shooter.getLocation());
          }
 else           if (fireball.getShooter() instanceof BlockProjectileSource) {
            Block shooter=((BlockProjectileSource)fireball.getShooter()).getBlock();
            location=BukkitUtil.getLocation(shooter.getLocation());
          }
          if (location != null && !plot.equals(location.getPlot())) {
            event.setCancelled(true);
          }
        }
      }
    }
 else     if (event.getIgnitingBlock() != null) {
      Block ignitingBlock=event.getIgnitingBlock();
      Plot plotIgnited=BukkitUtil.getLocation(ignitingBlock.getLocation()).getPlot();
      if (igniteCause == BlockIgniteEvent.IgniteCause.FLINT_AND_STEEL && (!plot.getFlag(Flags.BLOCK_IGNITION).or(false) || plotIgnited == null || !plotIgnited.equals(plot)) || (igniteCause == BlockIgniteEvent.IgniteCause.SPREAD || igniteCause == BlockIgniteEvent.IgniteCause.LAVA) && (!plot.getFlag(Flags.BLOCK_IGNITION).or(false) || plotIgnited == null || !plotIgnited.equals(plot))) {
        event.setCancelled(true);
      }
    }
  }
}"
57922,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockPistonRetract(BlockPistonRetractEvent event){
  Block block=event.getBlock();
  Location location=BukkitUtil.getLocation(block.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    if (!PS.get().hasPlotArea(location.getWorld())) {
      return;
    }
    if (this.pistonBlocks) {
      try {
        for (        Block pulled : event.getBlocks()) {
          location=BukkitUtil.getLocation(pulled.getLocation());
          if (location.getPlotArea() != null) {
            event.setCancelled(true);
            return;
          }
        }
      }
 catch (      Throwable e) {
        this.pistonBlocks=false;
      }
    }
    if (!this.pistonBlocks && block.getType() != Material.PISTON_BASE) {
      BlockFace dir=event.getDirection();
      location=BukkitUtil.getLocation(block.getLocation().add(dir.getModX() * 2,dir.getModY() * 2,dir.getModZ() * 2));
      if (location.getPlotArea() != null) {
        event.setCancelled(true);
        return;
      }
    }
    return;
  }
  Plot plot=area.getOwnedPlot(location);
  if (this.pistonBlocks) {
    try {
      for (      Block pulled : event.getBlocks()) {
        location=BukkitUtil.getLocation(pulled.getLocation());
        if (!area.contains(location.getX(),location.getZ())) {
          event.setCancelled(true);
          return;
        }
        Plot newPlot=area.getOwnedPlot(location);
        if (!Objects.equals(plot,newPlot)) {
          event.setCancelled(true);
          return;
        }
      }
    }
 catch (    Throwable e) {
      this.pistonBlocks=false;
    }
  }
  if (!this.pistonBlocks && block.getType() != Material.PISTON_BASE) {
    BlockFace dir=event.getDirection();
    location=BukkitUtil.getLocation(block.getLocation().add(dir.getModX() * 2,dir.getModY() * 2,dir.getModZ() * 2));
    if (!area.contains(location)) {
      event.setCancelled(true);
      return;
    }
    Plot newPlot=area.getOwnedPlot(location);
    if (!Objects.equals(plot,newPlot)) {
      event.setCancelled(true);
    }
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockPistonRetract(BlockPistonRetractEvent event){
  Block block=event.getBlock();
  Location location=BukkitUtil.getLocation(block.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    if (!PS.get().hasPlotArea(location.getWorld())) {
      return;
    }
    if (this.pistonBlocks) {
      try {
        for (        Block pulled : event.getBlocks()) {
          location=BukkitUtil.getLocation(pulled.getLocation());
          if (location.getPlotArea() != null) {
            event.setCancelled(true);
            return;
          }
        }
      }
 catch (      Throwable ignored) {
        this.pistonBlocks=false;
      }
    }
    if (!this.pistonBlocks && block.getType() != Material.PISTON_BASE) {
      BlockFace dir=event.getDirection();
      location=BukkitUtil.getLocation(block.getLocation().add(dir.getModX() * 2,dir.getModY() * 2,dir.getModZ() * 2));
      if (location.getPlotArea() != null) {
        event.setCancelled(true);
        return;
      }
    }
    return;
  }
  Plot plot=area.getOwnedPlot(location);
  if (this.pistonBlocks) {
    try {
      for (      Block pulled : event.getBlocks()) {
        location=BukkitUtil.getLocation(pulled.getLocation());
        if (!area.contains(location.getX(),location.getZ())) {
          event.setCancelled(true);
          return;
        }
        Plot newPlot=area.getOwnedPlot(location);
        if (!Objects.equals(plot,newPlot)) {
          event.setCancelled(true);
          return;
        }
      }
    }
 catch (    Throwable ignored) {
      this.pistonBlocks=false;
    }
  }
  if (!this.pistonBlocks && block.getType() != Material.PISTON_BASE) {
    BlockFace dir=event.getDirection();
    location=BukkitUtil.getLocation(block.getLocation().add(dir.getModX() * 2,dir.getModY() * 2,dir.getModZ() * 2));
    if (!area.contains(location)) {
      event.setCancelled(true);
      return;
    }
    Plot newPlot=area.getOwnedPlot(location);
    if (!Objects.equals(plot,newPlot)) {
      event.setCancelled(true);
    }
  }
}"
57923,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onFade(BlockFadeEvent e){
  Block b=e.getBlock();
  Location location=BukkitUtil.getLocation(b.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlot(location);
  if (plot == null) {
    e.setCancelled(true);
    return;
  }
switch (b.getType()) {
case ICE:
    Optional<Boolean> ice_melt=plot.getFlag(Flags.ICE_MELT);
  if (ice_melt.isPresent()) {
    if (!ice_melt.get()) {
      e.setCancelled(true);
    }
  }
break;
case SNOW:
Optional<Boolean> snow_melt=plot.getFlag(Flags.SNOW_MELT);
if (snow_melt.isPresent()) {
if (!snow_melt.get()) {
e.setCancelled(true);
}
}
break;
case SOIL:
Optional<Boolean> soil_dry=plot.getFlag(Flags.SOIL_DRY);
if (soil_dry.isPresent()) {
if (!soil_dry.get()) {
e.setCancelled(true);
}
}
break;
}
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onFade(BlockFadeEvent event){
  Block b=event.getBlock();
  Location location=BukkitUtil.getLocation(b.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlot(location);
  if (plot == null) {
    event.setCancelled(true);
    return;
  }
switch (b.getType()) {
case ICE:
    Optional<Boolean> ice_melt=plot.getFlag(Flags.ICE_MELT);
  if (ice_melt.isPresent()) {
    if (!ice_melt.get()) {
      event.setCancelled(true);
    }
  }
break;
case SNOW:
Optional<Boolean> snow_melt=plot.getFlag(Flags.SNOW_MELT);
if (snow_melt.isPresent()) {
if (!snow_melt.get()) {
event.setCancelled(true);
}
}
break;
case SOIL:
Optional<Boolean> soil_dry=plot.getFlag(Flags.SOIL_DRY);
if (soil_dry.isPresent()) {
if (!soil_dry.get()) {
event.setCancelled(true);
}
}
break;
}
}"
57924,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onChange(BlockFromToEvent event){
  Block from=event.getBlock();
  Block to=event.getToBlock();
  Location tLocation=BukkitUtil.getLocation(to.getLocation());
  PlotArea area=tLocation.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlot(tLocation);
  Location fLocation=BukkitUtil.getLocation(from.getLocation());
  if (plot != null) {
    if (plot.getFlag(Flags.DISABLE_PHYSICS).or(false)) {
      event.setCancelled(true);
    }
 else     if (!area.contains(fLocation.getX(),fLocation.getZ()) || !Objects.equals(plot,area.getOwnedPlot(fLocation))) {
      event.setCancelled(true);
    }
  }
 else   if (!area.contains(fLocation.getX(),fLocation.getZ()) || !Objects.equals(plot,area.getOwnedPlot(fLocation))) {
    event.setCancelled(true);
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onChange(BlockFromToEvent event){
  Block from=event.getBlock();
  Block to=event.getToBlock();
  Location tLocation=BukkitUtil.getLocation(to.getLocation());
  PlotArea area=tLocation.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=area.getOwnedPlot(tLocation);
  Location fLocation=BukkitUtil.getLocation(from.getLocation());
  if (plot != null) {
    if (plot.getFlag(Flags.DISABLE_PHYSICS).or(false) || !area.contains(fLocation.getX(),fLocation.getZ()) || !Objects.equals(plot,area.getOwnedPlot(fLocation))) {
      event.setCancelled(true);
    }
  }
 else   if (!area.contains(fLocation.getX(),fLocation.getZ()) || !Objects.equals(plot,area.getOwnedPlot(fLocation))) {
    event.setCancelled(true);
  }
}"
57925,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onHangingPlace(HangingPlaceEvent event){
  Block b=event.getBlock().getRelative(event.getBlockFace());
  Location location=BukkitUtil.getLocation(b.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Player p=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(p);
  Plot plot=area.getPlotAbs(location);
  if (plot == null) {
    if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_ROAD)) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_ROAD);
      event.setCancelled(true);
    }
  }
 else {
    if (!plot.hasOwner()) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_UNOWNED)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_UNOWNED);
        event.setCancelled(true);
      }
      return;
    }
 else     if (!plot.isAdded(pp.getUUID())) {
      if (!plot.getFlag(Flags.HANGING_PLACE).or(false)) {
        if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
          MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
          event.setCancelled(true);
        }
        return;
      }
    }
    if (checkEntity(event.getEntity(),plot)) {
      event.setCancelled(true);
    }
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onHangingPlace(HangingPlaceEvent event){
  Block b=event.getBlock().getRelative(event.getBlockFace());
  Location location=BukkitUtil.getLocation(b.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Player p=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(p);
  Plot plot=area.getPlotAbs(location);
  if (plot == null) {
    if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_ROAD)) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_ROAD);
      event.setCancelled(true);
    }
  }
 else {
    if (!plot.hasOwner()) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_UNOWNED)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_UNOWNED);
        event.setCancelled(true);
      }
      return;
    }
    if (!plot.isAdded(pp.getUUID())) {
      if (!plot.getFlag(Flags.HANGING_PLACE).or(false)) {
        if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
          MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
          event.setCancelled(true);
        }
        return;
      }
    }
    if (checkEntity(event.getEntity(),plot)) {
      event.setCancelled(true);
    }
  }
}"
57926,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void blockCreate(BlockPlaceEvent event){
  Location loc=BukkitUtil.getLocation(event.getBlock().getLocation());
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return;
  }
  Player player=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  Plot plot=area.getPlotAbs(loc);
  if (plot != null) {
    if (!plot.hasOwner()) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_UNOWNED)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_UNOWNED);
        event.setCancelled(true);
        return;
      }
    }
 else     if (!plot.isAdded(pp.getUUID())) {
      Optional<HashSet<PlotBlock>> place=plot.getFlag(Flags.PLACE);
      Block block=event.getBlock();
      if ((place.isPresent() && !place.get().contains(new PlotBlock((short)block.getTypeId(),block.getData()))) && !Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
        return;
      }
    }
 else     if (Settings.DONE_RESTRICTS_BUILDING && plot.getFlags().containsKey(Flags.DONE)) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
        return;
      }
    }
    if (plot.getFlag(Flags.DISABLE_PHYSICS).or(false)) {
      Block block=event.getBlockPlaced();
      if (block.getType().hasGravity()) {
        sendBlockChange(block.getLocation(),block.getType(),block.getData());
      }
    }
    if (loc.getY() > area.MAX_BUILD_HEIGHT && loc.getY() < area.MIN_BUILD_HEIGHT && !Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_HEIGHTLIMIT)) {
      event.setCancelled(true);
      MainUtil.sendMessage(pp,C.HEIGHT_LIMIT.s().replace(""String_Node_Str"",""String_Node_Str"" + area.MAX_BUILD_HEIGHT));
    }
  }
 else   if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
    MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_ROAD);
    event.setCancelled(true);
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void blockCreate(BlockPlaceEvent event){
  Location loc=BukkitUtil.getLocation(event.getBlock().getLocation());
  PlotArea area=loc.getPlotArea();
  if (area == null) {
    return;
  }
  Player player=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  Plot plot=area.getPlotAbs(loc);
  if (plot != null) {
    if (!plot.hasOwner()) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_UNOWNED)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_UNOWNED);
        event.setCancelled(true);
        return;
      }
    }
 else     if (!plot.isAdded(pp.getUUID())) {
      Optional<HashSet<PlotBlock>> place=plot.getFlag(Flags.PLACE);
      Block block=event.getBlock();
      if ((place.isPresent() && !place.get().contains(new PlotBlock((short)block.getTypeId(),block.getData()))) && !Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
        return;
      }
    }
 else     if (Settings.DONE_RESTRICTS_BUILDING && plot.getFlags().containsKey(Flags.DONE)) {
      if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_OTHER);
        event.setCancelled(true);
        return;
      }
    }
    if (plot.getFlag(Flags.DISABLE_PHYSICS).or(false)) {
      Block block=event.getBlockPlaced();
      if (block.getType().hasGravity()) {
        sendBlockChange(block.getLocation(),block.getType(),block.getData());
      }
    }
    if (loc.getY() > area.MAX_BUILD_HEIGHT && loc.getY() < area.MIN_BUILD_HEIGHT && !Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_HEIGHTLIMIT)) {
      event.setCancelled(true);
      MainUtil.sendMessage(pp,C.HEIGHT_LIMIT.s().replace(""String_Node_Str"",String.valueOf(area.MAX_BUILD_HEIGHT)));
    }
  }
 else   if (!Permissions.hasPermission(pp,C.PERMISSION_ADMIN_BUILD_OTHER)) {
    MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_BUILD_ROAD);
    event.setCancelled(true);
  }
}"
57927,"@EventHandler public void onRedstoneEvent(BlockRedstoneEvent event){
  Block block=event.getBlock();
switch (block.getType()) {
case REDSTONE_LAMP_OFF:
case REDSTONE_WIRE:
case REDSTONE_LAMP_ON:
case PISTON_BASE:
case PISTON_STICKY_BASE:
case IRON_DOOR_BLOCK:
case LEVER:
case WOODEN_DOOR:
case FENCE_GATE:
case WOOD_BUTTON:
case STONE_BUTTON:
case IRON_PLATE:
case WOOD_PLATE:
case STONE_PLATE:
case GOLD_PLATE:
case SPRUCE_DOOR:
case BIRCH_DOOR:
case JUNGLE_DOOR:
case ACACIA_DOOR:
case DARK_OAK_DOOR:
case IRON_TRAPDOOR:
case SPRUCE_FENCE_GATE:
case BIRCH_FENCE_GATE:
case JUNGLE_FENCE_GATE:
case ACACIA_FENCE_GATE:
case DARK_OAK_FENCE_GATE:
case POWERED_RAIL:
    return;
default :
  Location loc=BukkitUtil.getLocation(block.getLocation());
PlotArea area=loc.getPlotArea();
if (area == null) {
return;
}
Plot plot=area.getOwnedPlotAbs(loc);
if (plot == null) {
return;
}
if (plot.getFlag(Flags.REDSTONE).isPresent()) {
if (plot.getFlag(Flags.REDSTONE).get()) {
return;
}
 else {
event.setNewCurrent(0);
return;
}
}
if (Settings.REDSTONE_DISABLER) {
if (UUIDHandler.getPlayer(plot.owner) == null) {
boolean disable=true;
for (UUID trusted : plot.getTrusted()) {
if (UUIDHandler.getPlayer(trusted) != null) {
disable=false;
break;
}
}
if (disable) {
event.setNewCurrent(0);
return;
}
}
}
if (Settings.REDSTONE_DISABLER_UNOCCUPIED) {
for (Entry<String,PlotPlayer> entry : UUIDHandler.getPlayers().entrySet()) {
if (plot.equals(entry.getValue().getCurrentPlot())) {
return;
}
}
event.setNewCurrent(0);
}
}
}","@EventHandler public void onRedstoneEvent(BlockRedstoneEvent event){
  Block block=event.getBlock();
switch (block.getType()) {
case REDSTONE_LAMP_OFF:
case REDSTONE_WIRE:
case REDSTONE_LAMP_ON:
case PISTON_BASE:
case PISTON_STICKY_BASE:
case IRON_DOOR_BLOCK:
case LEVER:
case WOODEN_DOOR:
case FENCE_GATE:
case WOOD_BUTTON:
case STONE_BUTTON:
case IRON_PLATE:
case WOOD_PLATE:
case STONE_PLATE:
case GOLD_PLATE:
case SPRUCE_DOOR:
case BIRCH_DOOR:
case JUNGLE_DOOR:
case ACACIA_DOOR:
case DARK_OAK_DOOR:
case IRON_TRAPDOOR:
case SPRUCE_FENCE_GATE:
case BIRCH_FENCE_GATE:
case JUNGLE_FENCE_GATE:
case ACACIA_FENCE_GATE:
case DARK_OAK_FENCE_GATE:
case POWERED_RAIL:
    return;
default :
  Location loc=BukkitUtil.getLocation(block.getLocation());
PlotArea area=loc.getPlotArea();
if (area == null) {
return;
}
Plot plot=area.getOwnedPlotAbs(loc);
if (plot == null) {
return;
}
Optional<Boolean> flag=plot.getFlag(Flags.REDSTONE);
if (flag.isPresent()) {
if (flag.get()) {
return;
}
 else {
event.setNewCurrent(0);
return;
}
}
if (Settings.REDSTONE_DISABLER) {
if (UUIDHandler.getPlayer(plot.owner) == null) {
boolean disable=true;
for (UUID trusted : plot.getTrusted()) {
if (UUIDHandler.getPlayer(trusted) != null) {
disable=false;
break;
}
}
if (disable) {
event.setNewCurrent(0);
return;
}
}
}
if (Settings.REDSTONE_DISABLER_UNOCCUPIED) {
for (Entry<String,PlotPlayer> entry : UUIDHandler.getPlayers().entrySet()) {
if (plot.equals(entry.getValue().getCurrentPlot())) {
return;
}
}
event.setNewCurrent(0);
}
}
}"
57928,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBigBoom(EntityExplodeEvent event){
  Location location=BukkitUtil.getLocation(event.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    if (!PS.get().hasPlotArea(location.getWorld())) {
      return;
    }
    Iterator<Block> iterator=event.blockList().iterator();
    while (iterator.hasNext()) {
      iterator.next();
      if (location.getPlotArea() != null) {
        iterator.remove();
      }
    }
    return;
  }
  Plot plot=area.getOwnedPlot(location);
  if (plot != null) {
    if (plot.getFlag(Flags.EXPLOSION).isPresent() && plot.getFlag(Flags.EXPLOSION).get()) {
      List<MetadataValue> meta=event.getEntity().getMetadata(""String_Node_Str"");
      Plot origin;
      if (meta.isEmpty()) {
        origin=plot;
      }
 else {
        origin=(Plot)meta.get(0).value();
      }
      if (this.lastRadius != 0) {
        List<Entity> nearby=event.getEntity().getNearbyEntities(this.lastRadius,this.lastRadius,this.lastRadius);
        for (        Entity near : nearby) {
          if (near instanceof TNTPrimed || near.getType() == EntityType.MINECART_TNT) {
            if (!near.hasMetadata(""String_Node_Str"")) {
              near.setMetadata(""String_Node_Str"",new FixedMetadataValue((Plugin)PS.get().IMP,plot));
            }
          }
        }
        this.lastRadius=0;
      }
      Iterator<Block> iterator=event.blockList().iterator();
      while (iterator.hasNext()) {
        Block block=iterator.next();
        location=BukkitUtil.getLocation(block.getLocation());
        if (!area.contains(location.getX(),location.getZ()) || !origin.equals(area.getOwnedPlot(location))) {
          iterator.remove();
        }
      }
      return;
    }
  }
  event.setCancelled(true);
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBigBoom(EntityExplodeEvent event){
  Location location=BukkitUtil.getLocation(event.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    if (!PS.get().hasPlotArea(location.getWorld())) {
      return;
    }
    Iterator<Block> iterator=event.blockList().iterator();
    while (iterator.hasNext()) {
      iterator.next();
      if (location.getPlotArea() != null) {
        iterator.remove();
      }
    }
    return;
  }
  Plot plot=area.getOwnedPlot(location);
  if (plot != null) {
    Optional<Boolean> flag=plot.getFlag(Flags.EXPLOSION);
    if (flag.isPresent() && flag.get()) {
      List<MetadataValue> meta=event.getEntity().getMetadata(""String_Node_Str"");
      Plot origin;
      if (meta.isEmpty()) {
        origin=plot;
      }
 else {
        origin=(Plot)meta.get(0).value();
      }
      if (this.lastRadius != 0) {
        List<Entity> nearby=event.getEntity().getNearbyEntities(this.lastRadius,this.lastRadius,this.lastRadius);
        for (        Entity near : nearby) {
          if (near instanceof TNTPrimed || near.getType() == EntityType.MINECART_TNT) {
            if (!near.hasMetadata(""String_Node_Str"")) {
              near.setMetadata(""String_Node_Str"",new FixedMetadataValue((Plugin)PS.get().IMP,plot));
            }
          }
        }
        this.lastRadius=0;
      }
      Iterator<Block> iterator=event.blockList().iterator();
      while (iterator.hasNext()) {
        Block block=iterator.next();
        location=BukkitUtil.getLocation(block.getLocation());
        if (!area.contains(location.getX(),location.getZ()) || !origin.equals(area.getOwnedPlot(location))) {
          iterator.remove();
        }
      }
      return;
    }
  }
  event.setCancelled(true);
}"
57929,"@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onInteract(PlayerInteractEvent event){
  Player player=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  PlotArea area=pp.getPlotAreaAbs();
  if (area == null) {
    return;
  }
  PlayerBlockEventType eventType=null;
  BukkitLazyBlock lb;
  Location location;
  Action action=event.getAction();
switch (action) {
case PHYSICAL:
{
      eventType=PlayerBlockEventType.TRIGGER_PHYSICAL;
      Block block=event.getClickedBlock();
      lb=new BukkitLazyBlock(block);
      location=BukkitUtil.getLocation(block.getLocation());
      break;
    }
case RIGHT_CLICK_BLOCK:
{
    Block block=event.getClickedBlock();
    location=BukkitUtil.getLocation(block.getLocation());
    Material blockType=block.getType();
    int blockId=blockType.getId();
switch (blockType) {
case ANVIL:
case ACACIA_DOOR:
case BIRCH_DOOR:
case DARK_OAK_DOOR:
case IRON_DOOR:
case JUNGLE_DOOR:
case SPRUCE_DOOR:
case TRAP_DOOR:
case IRON_TRAPDOOR:
case WOOD_DOOR:
case WOODEN_DOOR:
case TRAPPED_CHEST:
case ENDER_CHEST:
case CHEST:
case ACACIA_FENCE_GATE:
case BIRCH_FENCE_GATE:
case DARK_OAK_FENCE_GATE:
case FENCE_GATE:
case JUNGLE_FENCE_GATE:
case SPRUCE_FENCE_GATE:
case LEVER:
case DIODE:
case DIODE_BLOCK_OFF:
case DIODE_BLOCK_ON:
case COMMAND:
case REDSTONE_COMPARATOR:
case REDSTONE_COMPARATOR_OFF:
case REDSTONE_COMPARATOR_ON:
case REDSTONE_ORE:
case WOOD_BUTTON:
case STONE_BUTTON:
case BEACON:
case BED_BLOCK:
case SIGN:
case WALL_SIGN:
case SIGN_POST:
case ENCHANTMENT_TABLE:
case BREWING_STAND:
case STANDING_BANNER:
case BURNING_FURNACE:
case FURNACE:
case CAKE_BLOCK:
case DISPENSER:
case DROPPER:
case HOPPER:
case NOTE_BLOCK:
case JUKEBOX:
case WORKBENCH:
      eventType=PlayerBlockEventType.INTERACT_BLOCK;
    break;
case DRAGON_EGG:
  eventType=PlayerBlockEventType.TELEPORT_OBJECT;
break;
default :
if (blockId > 197) {
eventType=PlayerBlockEventType.INTERACT_BLOCK;
}
break;
}
lb=new BukkitLazyBlock(blockId,block);
ItemStack hand=player.getItemInHand();
if (eventType != null) {
break;
}
Material type=(hand == null) ? null : hand.getType();
int id=(type == null) ? 0 : type.getId();
if (id == 0) {
eventType=PlayerBlockEventType.INTERACT_BLOCK;
lb=new BukkitLazyBlock(0,block);
break;
}
 else if (id < 198) {
location=BukkitUtil.getLocation(block.getRelative(event.getBlockFace()).getLocation());
eventType=PlayerBlockEventType.PLACE_BLOCK;
lb=new BukkitLazyBlock(id,block);
break;
}
Material handType=hand.getType();
lb=new BukkitLazyBlock(new PlotBlock((short)handType.getId(),(byte)0));
switch (handType) {
case MONSTER_EGG:
case MONSTER_EGGS:
eventType=PlayerBlockEventType.SPAWN_MOB;
break;
case ARMOR_STAND:
location=BukkitUtil.getLocation(block.getRelative(event.getBlockFace()).getLocation());
eventType=PlayerBlockEventType.PLACE_MISC;
break;
case WRITTEN_BOOK:
case BOOK_AND_QUILL:
case BOOK:
eventType=PlayerBlockEventType.READ;
break;
case APPLE:
case BAKED_POTATO:
case MUSHROOM_SOUP:
case BREAD:
case CARROT:
case CARROT_ITEM:
case COOKIE:
case GRILLED_PORK:
case POISONOUS_POTATO:
case MUTTON:
case PORK:
case POTATO:
case POTATO_ITEM:
case POTION:
case PUMPKIN_PIE:
case RABBIT:
case RABBIT_FOOT:
case RABBIT_STEW:
case RAW_BEEF:
case RAW_FISH:
case RAW_CHICKEN:
eventType=PlayerBlockEventType.EAT;
break;
case MINECART:
case STORAGE_MINECART:
case POWERED_MINECART:
case HOPPER_MINECART:
case EXPLOSIVE_MINECART:
case COMMAND_MINECART:
case BOAT:
eventType=PlayerBlockEventType.PLACE_VEHICLE;
break;
case PAINTING:
case ITEM_FRAME:
location=BukkitUtil.getLocation(block.getRelative(event.getBlockFace()).getLocation());
eventType=PlayerBlockEventType.PLACE_HANGING;
break;
default :
eventType=PlayerBlockEventType.INTERACT_BLOCK;
break;
}
break;
}
case LEFT_CLICK_BLOCK:
Block block=event.getClickedBlock();
location=BukkitUtil.getLocation(block.getLocation());
eventType=PlayerBlockEventType.BREAK_BLOCK;
lb=new BukkitLazyBlock(block);
break;
default :
return;
}
if (PS.get().worldedit != null && pp.getAttribute(""String_Node_Str"")) {
if (player.getItemInHand().getTypeId() == PS.get().worldedit.getConfiguration().wandItem) {
return;
}
}
if (!EventUtil.manager.checkPlayerBlockEvent(pp,eventType,location,lb,true)) {
event.setCancelled(true);
}
}","@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onInteract(PlayerInteractEvent event){
  Player player=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  PlotArea area=pp.getPlotAreaAbs();
  if (area == null) {
    return;
  }
  PlayerBlockEventType eventType=null;
  BukkitLazyBlock lb;
  Location location;
  Action action=event.getAction();
switch (action) {
case PHYSICAL:
{
      eventType=PlayerBlockEventType.TRIGGER_PHYSICAL;
      Block block=event.getClickedBlock();
      lb=new BukkitLazyBlock(block);
      location=BukkitUtil.getLocation(block.getLocation());
      break;
    }
case RIGHT_CLICK_BLOCK:
{
    Block block=event.getClickedBlock();
    location=BukkitUtil.getLocation(block.getLocation());
    Material blockType=block.getType();
    int blockId=blockType.getId();
switch (blockType) {
case ANVIL:
case ACACIA_DOOR:
case BIRCH_DOOR:
case DARK_OAK_DOOR:
case IRON_DOOR:
case JUNGLE_DOOR:
case SPRUCE_DOOR:
case TRAP_DOOR:
case IRON_TRAPDOOR:
case WOOD_DOOR:
case WOODEN_DOOR:
case TRAPPED_CHEST:
case ENDER_CHEST:
case CHEST:
case ACACIA_FENCE_GATE:
case BIRCH_FENCE_GATE:
case DARK_OAK_FENCE_GATE:
case FENCE_GATE:
case JUNGLE_FENCE_GATE:
case SPRUCE_FENCE_GATE:
case LEVER:
case DIODE:
case DIODE_BLOCK_OFF:
case DIODE_BLOCK_ON:
case COMMAND:
case REDSTONE_COMPARATOR:
case REDSTONE_COMPARATOR_OFF:
case REDSTONE_COMPARATOR_ON:
case REDSTONE_ORE:
case WOOD_BUTTON:
case STONE_BUTTON:
case BEACON:
case BED_BLOCK:
case SIGN:
case WALL_SIGN:
case SIGN_POST:
case ENCHANTMENT_TABLE:
case BREWING_STAND:
case STANDING_BANNER:
case BURNING_FURNACE:
case FURNACE:
case CAKE_BLOCK:
case DISPENSER:
case DROPPER:
case HOPPER:
case NOTE_BLOCK:
case JUKEBOX:
case WORKBENCH:
      eventType=PlayerBlockEventType.INTERACT_BLOCK;
    break;
case DRAGON_EGG:
  eventType=PlayerBlockEventType.TELEPORT_OBJECT;
break;
default :
if (blockId > 197) {
eventType=PlayerBlockEventType.INTERACT_BLOCK;
}
break;
}
lb=new BukkitLazyBlock(blockId,block);
ItemStack hand=player.getItemInHand();
if (eventType != null) {
break;
}
Material type=(hand == null) ? null : hand.getType();
int id=(type == null) ? 0 : type.getId();
if (id == 0) {
eventType=PlayerBlockEventType.INTERACT_BLOCK;
lb=new BukkitLazyBlock(0,block);
break;
}
if (id < 198) {
location=BukkitUtil.getLocation(block.getRelative(event.getBlockFace()).getLocation());
eventType=PlayerBlockEventType.PLACE_BLOCK;
lb=new BukkitLazyBlock(id,block);
break;
}
Material handType=hand.getType();
lb=new BukkitLazyBlock(new PlotBlock((short)handType.getId(),(byte)0));
switch (handType) {
case MONSTER_EGG:
case MONSTER_EGGS:
eventType=PlayerBlockEventType.SPAWN_MOB;
break;
case ARMOR_STAND:
location=BukkitUtil.getLocation(block.getRelative(event.getBlockFace()).getLocation());
eventType=PlayerBlockEventType.PLACE_MISC;
break;
case WRITTEN_BOOK:
case BOOK_AND_QUILL:
case BOOK:
eventType=PlayerBlockEventType.READ;
break;
case APPLE:
case BAKED_POTATO:
case MUSHROOM_SOUP:
case BREAD:
case CARROT:
case CARROT_ITEM:
case COOKIE:
case GRILLED_PORK:
case POISONOUS_POTATO:
case MUTTON:
case PORK:
case POTATO:
case POTATO_ITEM:
case POTION:
case PUMPKIN_PIE:
case RABBIT:
case RABBIT_FOOT:
case RABBIT_STEW:
case RAW_BEEF:
case RAW_FISH:
case RAW_CHICKEN:
eventType=PlayerBlockEventType.EAT;
break;
case MINECART:
case STORAGE_MINECART:
case POWERED_MINECART:
case HOPPER_MINECART:
case EXPLOSIVE_MINECART:
case COMMAND_MINECART:
case BOAT:
eventType=PlayerBlockEventType.PLACE_VEHICLE;
break;
case PAINTING:
case ITEM_FRAME:
location=BukkitUtil.getLocation(block.getRelative(event.getBlockFace()).getLocation());
eventType=PlayerBlockEventType.PLACE_HANGING;
break;
default :
eventType=PlayerBlockEventType.INTERACT_BLOCK;
break;
}
break;
}
case LEFT_CLICK_BLOCK:
Block block=event.getClickedBlock();
location=BukkitUtil.getLocation(block.getLocation());
eventType=PlayerBlockEventType.BREAK_BLOCK;
lb=new BukkitLazyBlock(block);
break;
default :
return;
}
if (PS.get().worldedit != null && pp.getAttribute(""String_Node_Str"")) {
if (player.getItemInHand().getTypeId() == PS.get().worldedit.getConfiguration().wandItem) {
return;
}
}
if (!EventUtil.manager.checkPlayerBlockEvent(pp,eventType,location,lb,true)) {
event.setCancelled(true);
}
}"
57930,"@EventHandler(ignoreCancelled=true,priority=EventPriority.HIGHEST) public void playerCommand(PlayerCommandPreprocessEvent event){
  String msg=event.getMessage().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
  if (msg.isEmpty()) {
    return;
  }
  String[] split=msg.split(""String_Node_Str"");
  PluginCommand cmd=Bukkit.getServer().getPluginCommand(split[0]);
  if (cmd == null) {
    if (split[0].equals(""String_Node_Str"") || split[0].equals(""String_Node_Str"")) {
      Player player=event.getPlayer();
      if (Settings.USE_PLOTME_ALIAS) {
        player.performCommand(""String_Node_Str"" + StringMan.join(Arrays.copyOfRange(split,1,split.length),""String_Node_Str""));
      }
 else {
        MainUtil.sendMessage(BukkitUtil.getPlayer(player),C.NOT_USING_PLOTME);
      }
      event.setCancelled(true);
      return;
    }
  }
  Player player=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  Plot plot=pp.getCurrentPlot();
  if (plot == null) {
    return;
  }
  Optional<List<String>> flag=plot.getFlag(Flags.BLOCKED_CMDS);
  if (flag.isPresent() && !Permissions.hasPermission(pp,C.PERMISSION_ADMIN_INTERACT_BLOCKED_CMDS)) {
    List<String> blocked_cmds=flag.get();
    String[] parts=msg.split(""String_Node_Str"");
    String c=parts[0];
    if (parts[0].contains(""String_Node_Str"")) {
      c=parts[0].split(""String_Node_Str"")[1];
      msg=msg.replace(parts[0].split(""String_Node_Str"")[0] + ""String_Node_Str"",""String_Node_Str"");
    }
    String l=c;
    List<String> aliases=new ArrayList<>();
    for (    HelpTopic cmdLabel : Bukkit.getServer().getHelpMap().getHelpTopics()) {
      if (c.equals(cmdLabel.getName())) {
        break;
      }
      String label=cmdLabel.getName().replaceFirst(""String_Node_Str"",""String_Node_Str"");
      if (aliases.contains(label)) {
        continue;
      }
      PluginCommand p;
      if ((p=Bukkit.getPluginCommand(label)) != null) {
        for (        String a : p.getAliases()) {
          if (aliases.contains(a)) {
            continue;
          }
          aliases.add(a);
          a=a.replaceFirst(""String_Node_Str"",""String_Node_Str"");
          if (!a.equals(label) && a.equals(c)) {
            c=label;
            break;
          }
        }
      }
    }
    if (!l.equals(c)) {
      msg=msg.replace(l,c);
    }
    for (    String s : blocked_cmds) {
      Pattern pattern;
      if (!RegExUtil.compiledPatterns.containsKey(s)) {
        RegExUtil.compiledPatterns.put(s,pattern=Pattern.compile(s));
      }
 else {
        pattern=RegExUtil.compiledPatterns.get(s);
      }
      if (pattern.matcher(msg).matches()) {
        MainUtil.sendMessage(pp,C.COMMAND_BLOCKED);
        String perm;
        if (plot.isAdded(pp.getUUID())) {
          perm=""String_Node_Str"";
        }
 else {
          perm=""String_Node_Str"";
        }
        if (!Permissions.hasPermission(pp,perm)) {
          event.setCancelled(true);
        }
        return;
      }
    }
  }
}","@EventHandler(ignoreCancelled=true,priority=EventPriority.HIGHEST) public void playerCommand(PlayerCommandPreprocessEvent event){
  String msg=event.getMessage().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str"").trim();
  if (msg.isEmpty()) {
    return;
  }
  String[] split=msg.split(""String_Node_Str"");
  PluginCommand cmd=Bukkit.getServer().getPluginCommand(split[0]);
  if (cmd == null) {
    if (split[0].equals(""String_Node_Str"") || split[0].equals(""String_Node_Str"")) {
      Player player=event.getPlayer();
      if (Settings.USE_PLOTME_ALIAS) {
        player.performCommand(""String_Node_Str"" + StringMan.join(Arrays.copyOfRange(split,1,split.length),""String_Node_Str""));
      }
 else {
        MainUtil.sendMessage(BukkitUtil.getPlayer(player),C.NOT_USING_PLOTME);
      }
      event.setCancelled(true);
      return;
    }
  }
  Player player=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(player);
  Plot plot=pp.getCurrentPlot();
  if (plot == null) {
    return;
  }
  Optional<List<String>> flag=plot.getFlag(Flags.BLOCKED_CMDS);
  if (flag.isPresent() && !Permissions.hasPermission(pp,C.PERMISSION_ADMIN_INTERACT_BLOCKED_CMDS)) {
    List<String> blocked_cmds=flag.get();
    String[] parts=msg.split(""String_Node_Str"");
    String c=parts[0];
    if (parts[0].contains(""String_Node_Str"")) {
      c=parts[0].split(""String_Node_Str"")[1];
      msg=msg.replace(parts[0].split(""String_Node_Str"")[0] + ':',""String_Node_Str"");
    }
    String l=c;
    List<String> aliases=new ArrayList<>();
    for (    HelpTopic cmdLabel : Bukkit.getServer().getHelpMap().getHelpTopics()) {
      if (c.equals(cmdLabel.getName())) {
        break;
      }
      String label=cmdLabel.getName().replaceFirst(""String_Node_Str"",""String_Node_Str"");
      if (aliases.contains(label)) {
        continue;
      }
      PluginCommand p;
      if ((p=Bukkit.getPluginCommand(label)) != null) {
        for (        String a : p.getAliases()) {
          if (aliases.contains(a)) {
            continue;
          }
          aliases.add(a);
          a=a.replaceFirst(""String_Node_Str"",""String_Node_Str"");
          if (!a.equals(label) && a.equals(c)) {
            c=label;
            break;
          }
        }
      }
    }
    if (!l.equals(c)) {
      msg=msg.replace(l,c);
    }
    for (    String s : blocked_cmds) {
      Pattern pattern;
      if (!RegExUtil.compiledPatterns.containsKey(s)) {
        RegExUtil.compiledPatterns.put(s,pattern=Pattern.compile(s));
      }
 else {
        pattern=RegExUtil.compiledPatterns.get(s);
      }
      if (pattern.matcher(msg).matches()) {
        MainUtil.sendMessage(pp,C.COMMAND_BLOCKED);
        String perm;
        if (plot.isAdded(pp.getUUID())) {
          perm=""String_Node_Str"";
        }
 else {
          perm=""String_Node_Str"";
        }
        if (!Permissions.hasPermission(pp,perm)) {
          event.setCancelled(true);
        }
        return;
      }
    }
  }
}"
57931,"@EventHandler(ignoreCancelled=true,priority=EventPriority.HIGHEST) public void onPhysicsEvent(BlockPhysicsEvent event){
switch (event.getChangedType()) {
case REDSTONE_COMPARATOR_OFF:
case REDSTONE_COMPARATOR_ON:
{
      Block block=event.getBlock();
      Location loc=BukkitUtil.getLocation(block.getLocation());
      PlotArea area=loc.getPlotArea();
      if (area == null) {
        return;
      }
      Plot plot=area.getOwnedPlotAbs(loc);
      if (plot == null) {
        return;
      }
      if (plot.getFlag(Flags.REDSTONE).isPresent() && !plot.getFlag(Flags.REDSTONE).get()) {
        event.setCancelled(true);
      }
      return;
    }
case DRAGON_EGG:
case ANVIL:
case SAND:
case GRAVEL:
  Block block=event.getBlock();
Location loc=BukkitUtil.getLocation(block.getLocation());
PlotArea area=loc.getPlotArea();
if (area == null) {
return;
}
Plot plot=area.getOwnedPlotAbs(loc);
if (plot != null && plot.getFlag(Flags.DISABLE_PHYSICS).or(false)) {
event.setCancelled(true);
return;
}
return;
default :
break;
}
}","@EventHandler(ignoreCancelled=true,priority=EventPriority.HIGHEST) public void onPhysicsEvent(BlockPhysicsEvent event){
switch (event.getChangedType()) {
case REDSTONE_COMPARATOR_OFF:
case REDSTONE_COMPARATOR_ON:
{
      Block block=event.getBlock();
      Location loc=BukkitUtil.getLocation(block.getLocation());
      PlotArea area=loc.getPlotArea();
      if (area == null) {
        return;
      }
      Plot plot=area.getOwnedPlotAbs(loc);
      if (plot == null) {
        return;
      }
      Optional<Boolean> flag=plot.getFlag(Flags.REDSTONE);
      if (flag.isPresent() && !flag.get()) {
        event.setCancelled(true);
      }
      return;
    }
case DRAGON_EGG:
case ANVIL:
case SAND:
case GRAVEL:
  Block block=event.getBlock();
Location loc=BukkitUtil.getLocation(block.getLocation());
PlotArea area=loc.getPlotArea();
if (area == null) {
return;
}
Plot plot=area.getOwnedPlotAbs(loc);
if (plot != null && plot.getFlag(Flags.DISABLE_PHYSICS).or(false)) {
event.setCancelled(true);
return;
}
return;
default :
break;
}
}"
57932,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onVehicleDestroy(VehicleDestroyEvent e){
  Location l=BukkitUtil.getLocation(e.getVehicle());
  PlotArea area=l.getPlotArea();
  if (area == null) {
    return;
  }
  Entity d=e.getAttacker();
  if (d instanceof Player) {
    Player p=(Player)d;
    PlotPlayer pp=BukkitUtil.getPlayer(p);
    Plot plot=area.getPlotAbs(l);
    if (plot == null) {
      if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
        e.setCancelled(true);
      }
    }
 else {
      if (!plot.hasOwner()) {
        if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
          MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
          e.setCancelled(true);
          return;
        }
        return;
      }
      if (!plot.isAdded(pp.getUUID())) {
        if (plot.getFlag(Flags.VEHICLE_BREAK).or(false)) {
          return;
        }
        if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
          MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
          e.setCancelled(true);
        }
      }
    }
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onVehicleDestroy(VehicleDestroyEvent event){
  Location l=BukkitUtil.getLocation(event.getVehicle());
  PlotArea area=l.getPlotArea();
  if (area == null) {
    return;
  }
  Entity d=event.getAttacker();
  if (d instanceof Player) {
    Player p=(Player)d;
    PlotPlayer pp=BukkitUtil.getPlayer(p);
    Plot plot=area.getPlotAbs(l);
    if (plot == null) {
      if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
        event.setCancelled(true);
      }
    }
 else {
      if (!plot.hasOwner()) {
        if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
          MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
          event.setCancelled(true);
          return;
        }
        return;
      }
      if (!plot.isAdded(pp.getUUID())) {
        if (plot.getFlag(Flags.VEHICLE_BREAK).or(false)) {
          return;
        }
        if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
          MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
          event.setCancelled(true);
        }
      }
    }
  }
}"
57933,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void playerMove(PlayerMoveEvent event){
  org.bukkit.Location from=event.getFrom();
  org.bukkit.Location to=event.getTo();
  int x2;
  if (MathMan.roundInt(from.getX()) != (x2=MathMan.roundInt(to.getX()))) {
    Player player=event.getPlayer();
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    TaskManager.TELEPORT_QUEUE.remove(pp.getName());
    Location loc=BukkitUtil.getLocation(to);
    pp.setMeta(""String_Node_Str"",loc);
    PlotArea area=loc.getPlotArea();
    if (area == null) {
      pp.deleteMeta(""String_Node_Str"");
      return;
    }
    Plot now=area.getPlot(loc);
    Plot lastPlot=pp.getMeta(""String_Node_Str"");
    if (now == null) {
      if (lastPlot != null && !plotExit(pp,lastPlot)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_EXIT_DENIED);
        if (lastPlot.equals(BukkitUtil.getLocation(from).getPlot())) {
          player.teleport(from);
        }
 else {
          player.teleport(player.getWorld().getSpawnLocation());
        }
        event.setCancelled(true);
        return;
      }
    }
 else     if (now.equals(lastPlot)) {
      return;
    }
 else     if (!plotEntry(pp,now)) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_ENTRY_DENIED);
      player.teleport(from);
      event.setCancelled(true);
      return;
    }
    Integer border=area.getBorder();
    if (x2 > border) {
      to.setX(border - 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
      return;
    }
 else     if (x2 < -border) {
      to.setX(-border + 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
      return;
    }
    return;
  }
  int z2;
  if (MathMan.roundInt(from.getZ()) != (z2=MathMan.roundInt(to.getZ()))) {
    Player player=event.getPlayer();
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    TaskManager.TELEPORT_QUEUE.remove(pp.getName());
    Location loc=BukkitUtil.getLocation(to);
    pp.setMeta(""String_Node_Str"",loc);
    PlotArea area=loc.getPlotArea();
    if (area == null) {
      pp.deleteMeta(""String_Node_Str"");
      return;
    }
    Plot now=area.getPlot(loc);
    Plot lastPlot=pp.getMeta(""String_Node_Str"");
    if (now == null) {
      if (lastPlot != null && !plotExit(pp,lastPlot)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_EXIT_DENIED);
        if (lastPlot.equals(BukkitUtil.getLocation(from).getPlot())) {
          player.teleport(from);
        }
 else {
          player.teleport(player.getWorld().getSpawnLocation());
        }
        event.setCancelled(true);
        return;
      }
    }
 else     if (now.equals(lastPlot)) {
      return;
    }
 else     if (!plotEntry(pp,now)) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_ENTRY_DENIED);
      player.teleport(from);
      event.setCancelled(true);
      return;
    }
    Integer border=area.getBorder();
    if (z2 > border) {
      to.setZ(border - 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
    }
 else     if (z2 < -border) {
      to.setZ(-border + 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
    }
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void playerMove(PlayerMoveEvent event){
  org.bukkit.Location from=event.getFrom();
  org.bukkit.Location to=event.getTo();
  int x2;
  if (MathMan.roundInt(from.getX()) != (x2=MathMan.roundInt(to.getX()))) {
    Player player=event.getPlayer();
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    TaskManager.TELEPORT_QUEUE.remove(pp.getName());
    Location loc=BukkitUtil.getLocation(to);
    pp.setMeta(""String_Node_Str"",loc);
    PlotArea area=loc.getPlotArea();
    if (area == null) {
      pp.deleteMeta(""String_Node_Str"");
      return;
    }
    Plot now=area.getPlot(loc);
    Plot lastPlot=pp.getMeta(""String_Node_Str"");
    if (now == null) {
      if (lastPlot != null && !plotExit(pp,lastPlot)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_EXIT_DENIED);
        if (lastPlot.equals(BukkitUtil.getLocation(from).getPlot())) {
          player.teleport(from);
        }
 else {
          player.teleport(player.getWorld().getSpawnLocation());
        }
        event.setCancelled(true);
        return;
      }
    }
 else     if (now.equals(lastPlot)) {
      return;
    }
 else     if (!plotEntry(pp,now)) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_ENTRY_DENIED);
      player.teleport(from);
      event.setCancelled(true);
      return;
    }
    Integer border=area.getBorder();
    if (x2 > border) {
      to.setX(border - 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
      return;
    }
    if (x2 < -border) {
      to.setX(-border + 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
      return;
    }
    return;
  }
  int z2;
  if (MathMan.roundInt(from.getZ()) != (z2=MathMan.roundInt(to.getZ()))) {
    Player player=event.getPlayer();
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    TaskManager.TELEPORT_QUEUE.remove(pp.getName());
    Location loc=BukkitUtil.getLocation(to);
    pp.setMeta(""String_Node_Str"",loc);
    PlotArea area=loc.getPlotArea();
    if (area == null) {
      pp.deleteMeta(""String_Node_Str"");
      return;
    }
    Plot now=area.getPlot(loc);
    Plot lastPlot=pp.getMeta(""String_Node_Str"");
    if (now == null) {
      if (lastPlot != null && !plotExit(pp,lastPlot)) {
        MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_EXIT_DENIED);
        if (lastPlot.equals(BukkitUtil.getLocation(from).getPlot())) {
          player.teleport(from);
        }
 else {
          player.teleport(player.getWorld().getSpawnLocation());
        }
        event.setCancelled(true);
        return;
      }
    }
 else     if (now.equals(lastPlot)) {
      return;
    }
 else     if (!plotEntry(pp,now)) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,C.PERMISSION_ADMIN_ENTRY_DENIED);
      player.teleport(from);
      event.setCancelled(true);
      return;
    }
    Integer border=area.getBorder();
    if (z2 > border) {
      to.setZ(border - 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
    }
 else     if (z2 < -border) {
      to.setZ(-border + 4);
      player.teleport(event.getTo());
      MainUtil.sendMessage(pp,C.BORDER);
    }
  }
}"
57934,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockBurn(BlockBurnEvent e){
  Block b=e.getBlock();
  Location location=BukkitUtil.getLocation(b.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=location.getOwnedPlot();
  if (plot == null || !plot.getFlag(Flags.BLOCK_BURN).or(false)) {
    e.setCancelled(true);
    return;
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onBlockBurn(BlockBurnEvent event){
  Block b=event.getBlock();
  Location location=BukkitUtil.getLocation(b.getLocation());
  PlotArea area=location.getPlotArea();
  if (area == null) {
    return;
  }
  Plot plot=location.getOwnedPlot();
  if (plot == null || !plot.getFlag(Flags.BLOCK_BURN).or(false)) {
    event.setCancelled(true);
  }
}"
57935,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onPlayerEggThrow(PlayerEggThrowEvent e){
  Location l=BukkitUtil.getLocation(e.getEgg().getLocation());
  PlotArea area=l.getPlotArea();
  if (area == null) {
    return;
  }
  Player p=e.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(p);
  Plot plot=area.getPlot(l);
  if (plot == null) {
    if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
      e.setHatching(false);
    }
  }
 else   if (!plot.hasOwner()) {
    if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
      e.setHatching(false);
    }
  }
 else   if (!plot.isAdded(pp.getUUID())) {
    if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
      e.setHatching(false);
    }
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onPlayerEggThrow(PlayerEggThrowEvent event){
  Location l=BukkitUtil.getLocation(event.getEgg().getLocation());
  PlotArea area=l.getPlotArea();
  if (area == null) {
    return;
  }
  Player p=event.getPlayer();
  PlotPlayer pp=BukkitUtil.getPlayer(p);
  Plot plot=area.getPlot(l);
  if (plot == null) {
    if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
      event.setHatching(false);
    }
  }
 else   if (!plot.hasOwner()) {
    if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
      event.setHatching(false);
    }
  }
 else   if (!plot.isAdded(pp.getUUID())) {
    if (!Permissions.hasPermission(pp,""String_Node_Str"")) {
      MainUtil.sendMessage(pp,C.NO_PERMISSION_EVENT,""String_Node_Str"");
      event.setHatching(false);
    }
  }
}"
57936,"/** 
 * Send the title to a player.
 * @param player Player
 * @throws Exception
 */
@Override public void send(Player player) throws Exception {
  if (this.packetTitle != null) {
    resetTitle(player);
    Object handle=getHandle(player);
    Object connection=getField(handle.getClass(),""String_Node_Str"").get(handle);
    Object[] actions=this.packetActions.getEnumConstants();
    Method sendPacket=getMethod(connection.getClass(),""String_Node_Str"");
    Object packet=this.packetTitle.getConstructor(this.packetActions,this.chatBaseComponent,Integer.TYPE,Integer.TYPE,Integer.TYPE).newInstance(actions[2],null,this.fadeInTime * (this.ticks ? 1 : 20),this.stayTime * (this.ticks ? 1 : 20),this.fadeOutTime * (this.ticks ? 1 : 20));
    if (this.fadeInTime != -1 && this.fadeOutTime != -1 && this.stayTime != -1) {
      sendPacket.invoke(connection,packet);
    }
    Object serialized=getMethod(this.nmsChatSerializer,""String_Node_Str"",String.class).invoke(null,""String_Node_Str"" + ChatColor.translateAlternateColorCodes('&',this.getTitle()) + ""String_Node_Str""+ this.titleColor.name().toLowerCase()+ ""String_Node_Str"");
    packet=this.packetTitle.getConstructor(this.packetActions,this.chatBaseComponent).newInstance(actions[0],serialized);
    sendPacket.invoke(connection,packet);
    if (!this.getSubtitle().isEmpty()) {
      serialized=getMethod(this.nmsChatSerializer,""String_Node_Str"",String.class).invoke(null,""String_Node_Str"" + ChatColor.translateAlternateColorCodes('&',this.getSubtitle()) + ""String_Node_Str""+ this.subtitleColor.name().toLowerCase()+ ""String_Node_Str"");
      packet=this.packetTitle.getConstructor(this.packetActions,this.chatBaseComponent).newInstance(actions[1],serialized);
      sendPacket.invoke(connection,packet);
    }
  }
}","/** 
 * Send the title to a player.
 * @param player Player
 * @throws Exception
 */
@Override public void send(Player player) throws Exception {
  if (this.packetTitle != null) {
    resetTitle(player);
    Object handle=getHandle(player);
    Object connection=getField(handle.getClass(),""String_Node_Str"").get(handle);
    Object[] actions=this.packetActions.getEnumConstants();
    Method sendPacket=getMethod(connection.getClass(),""String_Node_Str"");
    Object packet=this.packetTitle.getConstructor(this.packetActions,this.chatBaseComponent,Integer.TYPE,Integer.TYPE,Integer.TYPE).newInstance(actions[2],null,this.fadeInTime * (this.ticks ? 1 : 20),this.stayTime * (this.ticks ? 1 : 20),this.fadeOutTime * (this.ticks ? 1 : 20));
    if (this.fadeInTime != -1 && this.fadeOutTime != -1 && this.stayTime != -1) {
      sendPacket.invoke(connection,packet);
    }
    Object serialized=getMethod(this.nmsChatSerializer,""String_Node_Str"",String.class).invoke(null,""String_Node_Str"" + ChatColor.translateAlternateColorCodes('&',this.getTitle()) + ""String_Node_Str""+ this.titleColor.name().toLowerCase()+ '}');
    packet=this.packetTitle.getConstructor(this.packetActions,this.chatBaseComponent).newInstance(actions[0],serialized);
    sendPacket.invoke(connection,packet);
    if (!this.getSubtitle().isEmpty()) {
      serialized=getMethod(this.nmsChatSerializer,""String_Node_Str"",String.class).invoke(null,""String_Node_Str"" + ChatColor.translateAlternateColorCodes('&',this.getSubtitle()) + ""String_Node_Str""+ this.subtitleColor.name().toLowerCase()+ '}');
      packet=this.packetTitle.getConstructor(this.packetActions,this.chatBaseComponent).newInstance(actions[1],serialized);
      sendPacket.invoke(connection,packet);
    }
  }
}"
57937,"@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onChat(AsyncPlayerChatEvent event){
  PlotPlayer plotPlayer=BukkitUtil.getPlayer(event.getPlayer());
  Location location=plotPlayer.getLocation();
  PlotArea area=location.getPlotArea();
  if (area == null || (!area.PLOT_CHAT && !plotPlayer.getAttribute(""String_Node_Str""))) {
    return;
  }
  Plot plot=area.getPlot(location);
  if (plot == null) {
    return;
  }
  event.setCancelled(true);
  String message=event.getMessage();
  String format=C.PLOT_CHAT_FORMAT.s();
  String sender=event.getPlayer().getDisplayName();
  PlotId id=plot.getId();
  Set<Player> recipients=event.getRecipients();
  recipients.clear();
  for (  Entry<String,PlotPlayer> entry : UUIDHandler.getPlayers().entrySet()) {
    PlotPlayer pp=entry.getValue();
    if (pp.getAttribute(""String_Node_Str"")) {
      String spy=event.getFormat();
      spy=String.format(spy,sender,message);
      pp.sendMessage(spy);
    }
 else {
      Plot current=pp.getCurrentPlot();
      if (current != null && current.getBasePlot(false).equals(plot)) {
        recipients.add(((BukkitPlayer)pp).player);
      }
    }
  }
  String full=format.replaceAll(""String_Node_Str"",id.x + ""String_Node_Str"" + id.y).replaceAll(""String_Node_Str"",sender).replaceAll(""String_Node_Str"",message);
  full=ChatColor.translateAlternateColorCodes('&',full);
  for (  Player receiver : recipients) {
    receiver.sendMessage(full);
  }
}","@EventHandler(priority=EventPriority.LOWEST,ignoreCancelled=true) public void onChat(AsyncPlayerChatEvent event){
  PlotPlayer plotPlayer=BukkitUtil.getPlayer(event.getPlayer());
  Location location=plotPlayer.getLocation();
  PlotArea area=location.getPlotArea();
  if (area == null || (!area.PLOT_CHAT && !plotPlayer.getAttribute(""String_Node_Str""))) {
    return;
  }
  Plot plot=area.getPlot(location);
  if (plot == null) {
    return;
  }
  event.setCancelled(true);
  String message=event.getMessage();
  String format=C.PLOT_CHAT_FORMAT.s();
  String sender=event.getPlayer().getDisplayName();
  PlotId id=plot.getId();
  Set<Player> recipients=event.getRecipients();
  recipients.clear();
  for (  Entry<String,PlotPlayer> entry : UUIDHandler.getPlayers().entrySet()) {
    PlotPlayer pp=entry.getValue();
    if (pp.getAttribute(""String_Node_Str"")) {
      String spy=event.getFormat();
      spy=String.format(spy,sender,message);
      pp.sendMessage(spy);
    }
 else {
      Plot current=pp.getCurrentPlot();
      if (current != null && current.getBasePlot(false).equals(plot)) {
        recipients.add(((BukkitPlayer)pp).player);
      }
    }
  }
  String full=format.replace(""String_Node_Str"",id.x + ""String_Node_Str"" + id.y).replace(""String_Node_Str"",sender).replace(""String_Node_Str"",message);
  full=ChatColor.translateAlternateColorCodes('&',full);
  for (  Player receiver : recipients) {
    receiver.sendMessage(full);
  }
}"
57938,"/** 
 * Remove a helper (use DBFunc as well)<br> Using the * uuid will remove all users
 * @param uuid
 */
public boolean removeTrusted(UUID uuid){
  if (uuid == DBFunc.everyone) {
    boolean result=false;
    for (    UUID other : getTrusted()) {
      result=result || rmvTrusted(other);
    }
    return result;
  }
  return rmvTrusted(uuid);
}","/** 
 * Remove a helper (use DBFunc as well)<br> Using the * uuid will remove all users
 * @param uuid
 */
public boolean removeTrusted(UUID uuid){
  if (uuid == DBFunc.everyone) {
    boolean result=false;
    for (    UUID other : new HashSet<>(getTrusted())) {
      result=result || rmvTrusted(other);
    }
    return result;
  }
  return rmvTrusted(uuid);
}"
57939,"/** 
 * Remove a denied player (use DBFunc as well)<br> Using the * uuid will remove all users
 * @param uuid
 */
public boolean removeDenied(UUID uuid){
  if (uuid == DBFunc.everyone) {
    boolean result=false;
    for (    UUID other : getDenied()) {
      result=result || rmvDenied(other);
    }
    return result;
  }
  return rmvDenied(uuid);
}","/** 
 * Remove a denied player (use DBFunc as well)<br> Using the * uuid will remove all users
 * @param uuid
 */
public boolean removeDenied(UUID uuid){
  if (uuid == DBFunc.everyone) {
    boolean result=false;
    for (    UUID other : new HashSet<>(getDenied())) {
      result=result || rmvDenied(other);
    }
    return result;
  }
  return rmvDenied(uuid);
}"
57940,"@Override public boolean onCommand(PlotPlayer plr,String[] args){
  try {
    Field fPlots=PS.class.getDeclaredField(""String_Node_Str"");
    fPlots.setAccessible(true);
    fPlots.set(null,DBFunc.getPlots());
  }
 catch (  Exception e) {
    PS.debug(""String_Node_Str"");
    e.printStackTrace();
    PS.debug(""String_Node_Str"");
  }
  return true;
}","@Override public boolean onCommand(PlotPlayer plr,String[] args){
  PS.get().plots_tmp=DBFunc.getPlots();
  return true;
}"
57941,"/** 
 * This should be overridden by any specialized queues
 * @param pc
 */
@Override public void execute(PlotChunk<Chunk> pc){
  FastChunk_1_9 fs=(FastChunk_1_9)pc;
  Chunk chunk=pc.getChunk();
  final World world=chunk.getWorld();
  ChunkWrapper wrapper=pc.getChunkWrapper();
  if (!toUpdate.containsKey(wrapper)) {
    toUpdate.put(wrapper,chunk);
  }
  chunk.load(true);
  try {
    final boolean flag=world.getEnvironment() == Environment.NORMAL;
    final Method getHandele=chunk.getClass().getDeclaredMethod(""String_Node_Str"");
    final Object c=getHandele.invoke(chunk);
    final Class<? extends Object> clazz=c.getClass();
    final Field sf=clazz.getDeclaredField(""String_Node_Str"");
    sf.setAccessible(true);
    final Field tf=clazz.getDeclaredField(""String_Node_Str"");
    final Field ef=clazz.getDeclaredField(""String_Node_Str"");
    final Object[] sections=(Object[])sf.get(c);
    final HashMap<?,?> tiles=(HashMap<?,?>)tf.get(c);
    final List<?>[] entities=(List<?>[])ef.get(c);
    Method xm=null;
    Method ym=null;
    Method zm=null;
    final Set<Entry<?,?>> entryset=(Set<Entry<?,?>>)(Set<?>)tiles.entrySet();
    final Iterator<Entry<?,?>> iter=entryset.iterator();
    while (iter.hasNext()) {
      final Entry<?,?> tile=iter.next();
      final Object pos=tile.getKey();
      if (xm == null) {
        final Class<? extends Object> clazz2=pos.getClass().getSuperclass();
        xm=clazz2.getDeclaredMethod(""String_Node_Str"");
        ym=clazz2.getDeclaredMethod(""String_Node_Str"");
        zm=clazz2.getDeclaredMethod(""String_Node_Str"");
      }
      final int lx=(int)xm.invoke(pos) & 15;
      final int ly=(int)ym.invoke(pos);
      final int lz=(int)zm.invoke(pos) & 15;
      final int j=MainUtil.CACHE_I[ly][lx][lz];
      final int k=MainUtil.CACHE_J[ly][lx][lz];
      final int[] array=fs.getIdArray(j);
      if (array == null) {
        continue;
      }
      if (array[k] != 0) {
        iter.remove();
      }
    }
    for (int i=0; i < 16; i++) {
      if ((entities[i] != null) && (fs.getCount(i) >= 4096)) {
        entities[i].clear();
      }
    }
    for (int j=0; j < sections.length; j++) {
      if (fs.getCount(j) == 0) {
        continue;
      }
      final int[] newArray=fs.getIdArray(j);
      if (newArray == null) {
        continue;
      }
      Object section=sections[j];
      if ((section == null) || (fs.getCount(j) >= 4096)) {
        char[] array=new char[4096];
        for (int i=0; i < newArray.length; i++) {
          int combined=newArray[i];
          int id=combined & 4095;
          int data=combined >> 12;
          array[i]=(char)((id << 4) + data);
        }
        section=sections[j]=newChunkSection(j << 4,flag,array);
        continue;
      }
      final Object currentArray=getBlocks(section);
      RefExecutor setType=methodSetType.of(section);
      boolean fill=true;
      for (int k=0; k < newArray.length; k++) {
        final int n=newArray[k];
switch (n) {
case 0:
          fill=false;
        continue;
case -1:
{
        fill=false;
        int x=MainUtil.x_loc[j][k];
        int y=MainUtil.y_loc[j][k];
        int z=MainUtil.z_loc[j][k];
        setType.call(x,y & 15,z,air);
        continue;
      }
default :
{
      int x=MainUtil.x_loc[j][k];
      int y=MainUtil.y_loc[j][k];
      int z=MainUtil.z_loc[j][k];
      int id=(int)n;
      Object iblock=methodGetByCombinedId.call((int)n);
      setType.call(x,y & 15,z,iblock);
      continue;
    }
}
}
if (fill) {
fs.setCount(j,Short.MAX_VALUE);
}
}
}
 catch (IllegalAccessException|IllegalArgumentException|NoSuchMethodException|SecurityException|InvocationTargetException|NoSuchFieldException e) {
e.printStackTrace();
}
int[][] biomes=fs.biomes;
Biome[] values=Biome.values();
if (biomes != null) {
for (int x=0; x < 16; x++) {
int[] array=biomes[x];
if (array == null) {
continue;
}
for (int z=0; z < 16; z++) {
int biome=array[z];
if (biome == 0) {
  continue;
}
chunk.getBlock(x,0,z).setBiome(values[biome]);
}
}
}
}","/** 
 * This should be overridden by any specialized queues
 * @param pc
 */
@Override public void execute(PlotChunk<Chunk> pc){
  FastChunk_1_9 fs=(FastChunk_1_9)pc;
  Chunk chunk=pc.getChunk();
  final World world=chunk.getWorld();
  ChunkWrapper wrapper=pc.getChunkWrapper();
  if (!toUpdate.containsKey(wrapper)) {
    toUpdate.put(wrapper,chunk);
  }
  chunk.load(true);
  try {
    final boolean flag=world.getEnvironment() == Environment.NORMAL;
    final Method getHandele=chunk.getClass().getDeclaredMethod(""String_Node_Str"");
    final Object c=getHandele.invoke(chunk);
    final Class<? extends Object> clazz=c.getClass();
    final Field sf=clazz.getDeclaredField(""String_Node_Str"");
    sf.setAccessible(true);
    final Field tf=clazz.getDeclaredField(""String_Node_Str"");
    final Field entitySlices=clazz.getDeclaredField(""String_Node_Str"");
    final Object[] sections=(Object[])sf.get(c);
    final HashMap<?,?> tiles=(HashMap<?,?>)tf.get(c);
    final AbstractSet<?>[] entities=(AbstractSet<?>[])entitySlices.get(c);
    Method xm=null;
    Method ym=null;
    Method zm=null;
    final Set<Entry<?,?>> entryset=(Set<Entry<?,?>>)(Set<?>)tiles.entrySet();
    final Iterator<Entry<?,?>> iter=entryset.iterator();
    while (iter.hasNext()) {
      final Entry<?,?> tile=iter.next();
      final Object pos=tile.getKey();
      if (xm == null) {
        final Class<? extends Object> clazz2=pos.getClass().getSuperclass();
        xm=clazz2.getDeclaredMethod(""String_Node_Str"");
        ym=clazz2.getDeclaredMethod(""String_Node_Str"");
        zm=clazz2.getDeclaredMethod(""String_Node_Str"");
      }
      final int lx=(int)xm.invoke(pos) & 15;
      final int ly=(int)ym.invoke(pos);
      final int lz=(int)zm.invoke(pos) & 15;
      final int j=MainUtil.CACHE_I[ly][lx][lz];
      final int k=MainUtil.CACHE_J[ly][lx][lz];
      final int[] array=fs.getIdArray(j);
      if (array == null) {
        continue;
      }
      if (array[k] != 0) {
        iter.remove();
      }
    }
    for (int i=0; i < 16; i++) {
      if ((entities[i] != null) && (fs.getCount(i) >= 4096)) {
        entities[i].clear();
      }
    }
    for (int j=0; j < sections.length; j++) {
      if (fs.getCount(j) == 0) {
        continue;
      }
      final int[] newArray=fs.getIdArray(j);
      if (newArray == null) {
        continue;
      }
      Object section=sections[j];
      if ((section == null) || (fs.getCount(j) >= 4096)) {
        char[] array=new char[4096];
        for (int i=0; i < newArray.length; i++) {
          int combined=newArray[i];
          int id=combined & 4095;
          int data=combined >> 12;
          array[i]=(char)((id << 4) + data);
        }
        section=sections[j]=newChunkSection(j << 4,flag,array);
        continue;
      }
      final Object currentArray=getBlocks(section);
      RefExecutor setType=methodSetType.of(section);
      boolean fill=true;
      for (int k=0; k < newArray.length; k++) {
        final int n=newArray[k];
switch (n) {
case 0:
          fill=false;
        continue;
case -1:
{
        fill=false;
        int x=MainUtil.x_loc[j][k];
        int y=MainUtil.y_loc[j][k];
        int z=MainUtil.z_loc[j][k];
        setType.call(x,y & 15,z,air);
        continue;
      }
default :
{
      int x=MainUtil.x_loc[j][k];
      int y=MainUtil.y_loc[j][k];
      int z=MainUtil.z_loc[j][k];
      int id=n;
      Object iblock=methodGetByCombinedId.call((int)n);
      setType.call(x,y & 15,z,iblock);
      continue;
    }
}
}
if (fill) {
fs.setCount(j,Short.MAX_VALUE);
}
}
}
 catch (IllegalAccessException|IllegalArgumentException|NoSuchMethodException|SecurityException|InvocationTargetException|NoSuchFieldException e) {
e.printStackTrace();
}
int[][] biomes=fs.biomes;
Biome[] values=Biome.values();
if (biomes != null) {
for (int x=0; x < 16; x++) {
int[] array=biomes[x];
if (array == null) {
continue;
}
for (int z=0; z < 16; z++) {
int biome=array[z];
if (biome == 0) {
  continue;
}
chunk.getBlock(x,0,z).setBiome(values[biome]);
}
}
}
}"
57942,"public FastQueue_1_9() throws NoSuchMethodException, RuntimeException {
  methodGetHandleChunk=classCraftChunk.getMethod(""String_Node_Str"");
  methodInitLighting=classChunk.getMethod(""String_Node_Str"");
  MapChunk=classMapChunk.getConstructor(classChunk.getRealClass(),boolean.class,int.class);
  classBlockPositionConstructor=classBlockPosition.getConstructor(int.class,int.class,int.class);
  methodW=classWorld.getMethod(""String_Node_Str"",classBlockPosition.getRealClass());
  fieldSections=classChunk.getField(""String_Node_Str"");
  fieldWorld=classChunk.getField(""String_Node_Str"");
  methodGetCombinedId=classBlock.getMethod(""String_Node_Str"",classIBlockData.getRealClass());
  methodGetByCombinedId=classBlock.getMethod(""String_Node_Str"",int.class);
  methodGetBlocks=classChunkSection.getMethod(""String_Node_Str"");
  methodGetType=classChunkSection.getMethod(""String_Node_Str"",int.class,int.class,int.class);
  methodSetType=classChunkSection.getMethod(""String_Node_Str"",int.class,int.class,int.class,classIBlockData.getRealClass());
  methodAreNeighborsLoaded=classChunk.getMethod(""String_Node_Str"",int.class);
  classChunkSectionConstructor=classChunkSection.getConstructor(int.class,boolean.class,char[].class);
  air=methodGetByCombinedId.call(0);
  chunksender=new SendChunk();
  TaskManager.runTaskRepeat(new Runnable(){
    @Override public void run(){
      if (toUpdate.isEmpty()) {
        return;
      }
      int count=0;
      final ArrayList<Chunk> chunks=new ArrayList<Chunk>();
      final Iterator<Entry<ChunkWrapper,Chunk>> i=toUpdate.entrySet().iterator();
      while (i.hasNext() && (count < 128)) {
        chunks.add(i.next().getValue());
        i.remove();
        count++;
      }
      if (count == 0) {
        return;
      }
      update(chunks);
    }
  }
,1);
  MainUtil.initCache();
}","public FastQueue_1_9() throws RuntimeException {
  methodGetHandleChunk=classCraftChunk.getMethod(""String_Node_Str"");
  methodInitLighting=classChunk.getMethod(""String_Node_Str"");
  MapChunk=classMapChunk.getConstructor(classChunk.getRealClass(),boolean.class,int.class);
  classBlockPositionConstructor=classBlockPosition.getConstructor(int.class,int.class,int.class);
  methodW=classWorld.getMethod(""String_Node_Str"",classBlockPosition.getRealClass());
  fieldSections=classChunk.getField(""String_Node_Str"");
  fieldWorld=classChunk.getField(""String_Node_Str"");
  methodGetCombinedId=classBlock.getMethod(""String_Node_Str"",classIBlockData.getRealClass());
  methodGetByCombinedId=classBlock.getMethod(""String_Node_Str"",int.class);
  methodGetBlocks=classChunkSection.getMethod(""String_Node_Str"");
  methodGetType=classChunkSection.getMethod(""String_Node_Str"",int.class,int.class,int.class);
  methodSetType=classChunkSection.getMethod(""String_Node_Str"",int.class,int.class,int.class,classIBlockData.getRealClass());
  methodAreNeighborsLoaded=classChunk.getMethod(""String_Node_Str"",int.class);
  classChunkSectionConstructor=classChunkSection.getConstructor(int.class,boolean.class,char[].class);
  air=methodGetByCombinedId.call(0);
  chunksender=new SendChunk();
  TaskManager.runTaskRepeat(new Runnable(){
    @Override public void run(){
      if (toUpdate.isEmpty()) {
        return;
      }
      int count=0;
      final ArrayList<Chunk> chunks=new ArrayList<Chunk>();
      final Iterator<Entry<ChunkWrapper,Chunk>> i=toUpdate.entrySet().iterator();
      while (i.hasNext() && (count < 128)) {
        chunks.add(i.next().getValue());
        i.remove();
        count++;
      }
      if (count == 0) {
        return;
      }
      update(chunks);
    }
  }
,1);
  MainUtil.initCache();
}"
57943,"public boolean update(final PlotPlayer sender,final URL url){
  try {
    final String name=FILE.getName();
    final File newJar=new File(""String_Node_Str"" + name);
    MainUtil.sendMessage(sender,""String_Node_Str"" + url);
    final URLConnection con=url.openConnection();
    try (InputStream stream=con.getInputStream()){
      final File parent=newJar.getParentFile();
      if (!parent.exists()) {
        parent.mkdirs();
      }
      MainUtil.sendMessage(sender,""String_Node_Str"" + newJar);
      if (newJar.delete()) {
        MainUtil.sendMessage(sender,""String_Node_Str"");
        MainUtil.sendMessage(sender,""String_Node_Str"");
        MainUtil.sendMessage(sender,""String_Node_Str"");
      }
      Files.copy(stream,newJar.toPath());
    }
     MainUtil.sendMessage(sender,""String_Node_Str"");
    return true;
  }
 catch (  IOException e) {
    MainUtil.sendMessage(sender,""String_Node_Str"");
    MainUtil.sendMessage(sender,""String_Node_Str"");
    log(""String_Node_Str"");
    e.printStackTrace();
    log(""String_Node_Str"");
  }
  return false;
}","public boolean update(final PlotPlayer sender,final URL url){
  try {
    final String name=FILE.getName();
    final File newJar=new File(""String_Node_Str"" + name);
    MainUtil.sendMessage(sender,""String_Node_Str"" + url);
    final URLConnection con=url.openConnection();
    try (InputStream stream=con.getInputStream()){
      final File parent=newJar.getParentFile();
      if (!parent.exists()) {
        parent.mkdirs();
      }
      MainUtil.sendMessage(sender,""String_Node_Str"" + newJar);
      if (!newJar.delete()) {
        MainUtil.sendMessage(sender,""String_Node_Str"");
        MainUtil.sendMessage(sender,""String_Node_Str"");
        MainUtil.sendMessage(sender,""String_Node_Str"");
      }
      Files.copy(stream,newJar.toPath());
    }
     MainUtil.sendMessage(sender,""String_Node_Str"");
    return true;
  }
 catch (  IOException e) {
    MainUtil.sendMessage(sender,""String_Node_Str"");
    MainUtil.sendMessage(sender,""String_Node_Str"");
    log(""String_Node_Str"");
    e.printStackTrace();
    log(""String_Node_Str"");
  }
  return false;
}"
57944,"/** 
 * Get the raw plot object
 * @return set of plot
 * @see #setAllPlotsRaw(LinkedHashMap) to set the raw plot object
 */
@Deprecated public Set<Plot> getPlotsRaw(){
  int size=0;
  for (  final Entry<String,ConcurrentHashMap<PlotId,Plot>> entry : plots.entrySet()) {
    size+=entry.getValue().size();
  }
  final Set<Plot> result=new HashSet<>(size);
  for (  final Entry<String,ConcurrentHashMap<PlotId,Plot>> entry : plots.entrySet()) {
    for (    Entry<PlotId,Plot> entry2 : entry.getValue().entrySet()) {
      result.add(entry2.getValue());
    }
  }
  return result;
}","/** 
 * Get the raw plot object
 * @return set of plot
 * @see #setAllPlotsRaw(ConcurrentHashMap) to set the raw plot object
 */
@Deprecated public Set<Plot> getPlotsRaw(){
  int size=0;
  for (  final Entry<String,ConcurrentHashMap<PlotId,Plot>> entry : plots.entrySet()) {
    size+=entry.getValue().size();
  }
  final Set<Plot> result=new HashSet<>(size);
  for (  final Entry<String,ConcurrentHashMap<PlotId,Plot>> entry : plots.entrySet()) {
    for (    Entry<PlotId,Plot> entry2 : entry.getValue().entrySet()) {
      result.add(entry2.getValue());
    }
  }
  return result;
}"
57945,"/** 
 * Get all plots for the world
 * @param world to get plots of
 * @return Plot[] - array of plot objects in world
 * @see PS#getPlots(String)
 * @see com.intellectualcrafters.plot.object.Plot
 */
public Plot[] getPlots(final World world){
  final Collection<Plot> plots=PS.get().getPlotsInWorld(world.getName());
  return plots.toArray(new Plot[plots.size()]);
}","/** 
 * Get all plots for the world
 * @param world to get plots of
 * @return Plot[] - array of plot objects in world
 * @see PS#getPlots(String)
 * @see Plot
 */
public Plot[] getPlots(final World world){
  final Collection<Plot> plots=PS.get().getPlotsInWorld(world.getName());
  return plots.toArray(new Plot[plots.size()]);
}"
57946,"/** 
 * Get the PlotPlayer for an offline player<br> Note that this will work if the player is offline, however not all functionality will work
 * @see PlotPlayer.wrap(OfflinePlayer op)
 * @param player
 * @return
 */
public PlotPlayer wrapPlayer(final OfflinePlayer player){
  return PlotPlayer.wrap(player);
}","/** 
 * Get the PlotPlayer for an offline player<br> Note that this will work if the player is offline, however not all functionality will work
 * @see PlotPlayer#wrap(Object)
 * @param player
 * @return
 */
public PlotPlayer wrapPlayer(final OfflinePlayer player){
  return PlotPlayer.wrap(player);
}"
57947,"/** 
 * Do not use this. Instead use MainUtil.[method] in your code. - Basic plot management stuff
 * @return MainUtil
 * @see com.intellectualcrafters.plot.util.MainUtil
 */
@Deprecated public MainUtil getMainUtil(){
  return new MainUtil();
}","/** 
 * Do not use this. Instead use MainUtil.[method] in your code. - Basic plot management stuff
 * @return MainUtil
 * @see MainUtil
 */
@Deprecated public MainUtil getMainUtil(){
  return new MainUtil();
}"
57948,"/** 
 * Get a plot based on the player location
 * @param player Get the current plot for the player location
 * @return plot if found, otherwise it creates a temporary plot
 * @see #getPlot(org.bukkit.Location)
 * @see com.intellectualcrafters.plot.object.Plot
 */
public Plot getPlot(final Player player){
  return this.getPlot(player.getLocation());
}","/** 
 * Get a plot based on the player location
 * @param player Get the current plot for the player location
 * @return plot if found, otherwise it creates a temporary plot
 * @see #getPlot(org.bukkit.Location)
 * @see Plot
 */
public Plot getPlot(final Player player){
  return this.getPlot(player.getLocation());
}"
57949,"/** 
 * @param plugin Plugin used to access this method
 * @throws com.intellectualcrafters.plot.util.PlotSquaredException if the program fails to fetch the PlotSquaredinstance
 * @see com.intellectualcrafters.plot.PS
 * @deprecated Use this class if you just want to do a few simple things.<br>- It will remain stable for future versions of the plugin - The PlotPlayer and Plot class should be considered relatively safe - For more advanced/intensive tasks you should consider using other classes
 */
@Deprecated public PlotAPI(){
}","/** 
 * @see PS
 * @deprecated Use this class if you just want to do a few simple things.<br>- It will remain stable for future versions of the plugin - The PlotPlayer and Plot class should be considered relatively safe - For more advanced/intensive tasks you should consider using other classes
 */
@Deprecated public PlotAPI(){
}"
57950,"/** 
 * Get if plot world
 * @param world (to check if plot world)
 * @return boolean (if plot world or not)
 * @see com.intellectualcrafters.plot.PS#isPlotWorld(String)
 */
public boolean isPlotWorld(final World world){
  return PS.get().isPlotWorld(world.getName());
}","/** 
 * Get if plot world
 * @param world (to check if plot world)
 * @return boolean (if plot world or not)
 * @see PS#isPlotWorld(String)
 */
public boolean isPlotWorld(final World world){
  return PS.get().isPlotWorld(world.getName());
}"
57951,"/** 
 * Get home location
 * @param p Plot that you want to get the location for
 * @return plot bottom location
 * @see com.intellectualcrafters.plot.util.MainUtil#getPlotHome(String,com.intellectualcrafters.plot.object.Plot)
 * @see com.intellectualcrafters.plot.object.Plot
 */
public Location getHomeLocation(final Plot p){
  return BukkitUtil.getLocation(MainUtil.getPlotHome(p.world,p.id));
}","/** 
 * Get home location
 * @param p Plot that you want to get the location for
 * @return plot bottom location
 * @see MainUtil#getPlotHome(String,PlotId)
 * @see Plot
 */
public Location getHomeLocation(final Plot p){
  return BukkitUtil.getLocation(MainUtil.getPlotHome(p.world,p.id));
}"
57952,"/** 
 * Get Top Location (max, max, max)
 * @param p Plot that you want to get the location for
 * @return plot top location
 * @see MainUtil#getPlotTopLoc(String,com.intellectualcrafters.plot.object.PlotId)
 * @see com.intellectualcrafters.plot.object.Plot
 */
public Location getTopLocation(final Plot p){
  return BukkitUtil.getLocation(MainUtil.getPlotTopLocAbs(p.world,p.id));
}","/** 
 * Get Top Location (max, max, max)
 * @param p Plot that you want to get the location for
 * @return plot top location
 * @see MainUtil#getPlotTopLocAbs(String,PlotId)
 * @see Plot
 */
public Location getTopLocation(final Plot p){
  return BukkitUtil.getLocation(MainUtil.getPlotTopLocAbs(p.world,p.id));
}"
57953,"/** 
 * Get the player plot count
 * @param world  Specify the world we want to select the plots from
 * @param player Player, for whom we're getting the plot count
 * @return the number of plots the player has
 * @see com.intellectualcrafters.plot.util.MainUtil#getPlayerPlotCount(String,PlotPlayer)
 */
public int getPlayerPlotCount(final World world,final Player player){
  return MainUtil.getPlayerPlotCount(world.getName(),BukkitUtil.getPlayer(player));
}","/** 
 * Get the player plot count
 * @param world  Specify the world we want to select the plots from
 * @param player Player, for whom we're getting the plot count
 * @return the number of plots the player has
 * @see MainUtil#getPlayerPlotCount(String,PlotPlayer)
 */
public int getPlayerPlotCount(final World world,final Player player){
  return MainUtil.getPlayerPlotCount(world.getName(),BukkitUtil.getPlayer(player));
}"
57954,"/** 
 * Get Bottom Location (min, min, min)
 * @param p Plot that you want to get the location for
 * @return plot bottom location
 * @see com.intellectualcrafters.plot.util.MainUtil#getPlotBottomLoc(String,com.intellectualcrafters.plot.object.PlotId)
 * @see com.intellectualcrafters.plot.object.Plot
 */
public Location getBottomLocation(final Plot p){
  return BukkitUtil.getLocation(MainUtil.getPlotBottomLocAbs(p.world,p.id).subtract(1,0,1));
}","/** 
 * Get Bottom Location (min, min, min)
 * @param p Plot that you want to get the location for
 * @return plot bottom location
 * @see MainUtil#getPlotBottomLocAbs(String,PlotId)
 * @see Plot
 */
public Location getBottomLocation(final Plot p){
  return BukkitUtil.getLocation(MainUtil.getPlotBottomLocAbs(p.world,p.id).subtract(1,0,1));
}"
57955,"/** 
 * Get all plot worlds
 * @return World[] - array of plot worlds
 * @see com.intellectualcrafters.plot.PS#getPlotWorlds()
 */
public String[] getPlotWorlds(){
  final Set<String> worlds=PS.get().getPlotWorlds();
  return worlds.toArray(new String[worlds.size()]);
}","/** 
 * Get all plot worlds
 * @return World[] - array of plot worlds
 * @see PS#getPlotWorlds()
 */
public String[] getPlotWorlds(){
  final Set<String> worlds=PS.get().getPlotWorlds();
  return worlds.toArray(new String[worlds.size()]);
}"
57956,"/** 
 * Send a message to a player. - Supports color codes
 * @param player Player that will receive the message
 * @param string The message
 * @see com.intellectualcrafters.plot.util.MainUtil#sendMessage(PlotPlayer,String)
 */
public void sendMessage(final Player player,final String string){
  MainUtil.sendMessage(BukkitUtil.getPlayer(player),string);
}","/** 
 * Send a message to a player. - Supports color codes
 * @param player Player that will receive the message
 * @param string The message
 * @see MainUtil#sendMessage(PlotPlayer,String)
 */
public void sendMessage(final Player player,final String string){
  MainUtil.sendMessage(BukkitUtil.getPlayer(player),string);
}"
57957,"/** 
 * Add a plot world
 * @param world     World Name
 * @param plotWorld Plot World Object
 * @param manager   World Manager
 * @see com.intellectualcrafters.plot.PS#addPlotWorld(String,com.intellectualcrafters.plot.object.PlotWorld,com.intellectualcrafters.plot.object.PlotManager)
 */
public void addPlotWorld(final String world,final PlotWorld plotWorld,final PlotManager manager){
  PS.get().addPlotWorld(world,plotWorld,manager);
}","/** 
 * Add a plot world
 * @param world     World Name
 * @param plotWorld Plot World Object
 * @param manager   World Manager
 * @see PS#addPlotWorld(String,com.intellectualcrafters.plot.object.PlotWorld,com.intellectualcrafters.plot.object.PlotManager)
 */
public void addPlotWorld(final String world,final PlotWorld plotWorld,final PlotManager manager){
  PS.get().addPlotWorld(world,plotWorld,manager);
}"
57958,"/** 
 * Get the main class for this plugin <br> - Contains a lot of fields and methods - not very well organized <br> Only use this if you really need it
 * @return PlotSquared PlotSquared Main Class
 * @see com.intellectualcrafters.plot.PS
 */
public PS getMain(){
  return PS.get();
}","/** 
 * Get the main class for this plugin <br> - Contains a lot of fields and methods - not very well organized <br> Only use this if you really need it
 * @return PlotSquared PlotSquared Main Class
 * @see PS
 */
public PS getMain(){
  return PS.get();
}"
57959,"/** 
 * @return main configuration
 * @see com.intellectualcrafters.plot.PS#config
 */
public YamlConfiguration getConfig(){
  return PS.get().config;
}","/** 
 * @return main configuration
 * @see PS#config
 */
public YamlConfiguration getConfig(){
  return PS.get().config;
}"
57960,"/** 
 * Get a collection containing the players plots
 * @param world  Specify the world we want to select the plots from
 * @param player Player, for whom we're getting the plots
 * @return a set containing the players plots
 * @see com.intellectualcrafters.plot.PS#getPlots(String,PlotPlayer) org.bukkit.entity.Player)
 * @see com.intellectualcrafters.plot.object.Plot
 */
public Set<Plot> getPlayerPlots(final World world,final Player player){
  return PS.get().getPlots(world.getName(),BukkitUtil.getPlayer(player));
}","/** 
 * Get a collection containing the players plots
 * @param world  Specify the world we want to select the plots from
 * @param player Player, for whom we're getting the plots
 * @return a set containing the players plots
 * @see PS#getPlots(String,PlotPlayer)
 * @see Plot
 */
public Set<Plot> getPlayerPlots(final World world,final Player player){
  return PS.get().getPlots(world.getName(),BukkitUtil.getPlayer(player));
}"
57961,"/** 
 * Get all plots
 * @return all plots
 * @see com.intellectualcrafters.plot.PS#getPlots()
 */
public Set<Plot> getAllPlots(){
  return PS.get().getPlots();
}","/** 
 * Get all plots
 * @return all plots
 * @see PS#getPlots()
 */
public Set<Plot> getAllPlots(){
  return PS.get().getPlots();
}"
57962,"/** 
 * @return storage configuration
 * @see com.intellectualcrafters.plot.PS#storage
 */
public YamlConfiguration getStorage(){
  return PS.get().storage;
}","/** 
 * @return storage configuration
 * @see PS#storage
 */
public YamlConfiguration getStorage(){
  return PS.get().storage;
}"
57963,"/** 
 * Get plot locations
 * @param p Plot that you want to get the locations for
 * @return [0] = bottomLc, [1] = topLoc, [2] = home
 * @see com.intellectualcrafters.plot.util.MainUtil#getPlotBottomLoc(String,com.intellectualcrafters.plot.object.PlotId)
 * @see com.intellectualcrafters.plot.util.MainUtil#getPlotTopLoc(String,com.intellectualcrafters.plot.object.PlotId)
 * @see com.intellectualcrafters.plot.util.MainUtil#getPlotHome(String,com.intellectualcrafters.plot.object.Plot)
 * @see com.intellectualcrafters.plot.object.Plot
 */
public Location[] getLocations(final Plot p){
  return new Location[]{BukkitUtil.getLocation(MainUtil.getPlotBottomLocAbs(p.world,p.id).subtract(1,0,1)),BukkitUtil.getLocation(MainUtil.getPlotTopLocAbs(p.world,p.id)),BukkitUtil.getLocation(MainUtil.getPlotHome(p.world,p.id))};
}","/** 
 * Get plot locations
 * @param p Plot that you want to get the locations for
 * @return [0] = bottomLc, [1] = topLoc, [2] = home
 * @see MainUtil#getPlotBottomLocAbs(String,PlotId)
 * @see MainUtil#getPlotTopLocAbs(String,PlotId)
 * @see MainUtil#getPlotHome(String,PlotId)
 * @see Plot
 */
public Location[] getLocations(final Plot p){
  return new Location[]{BukkitUtil.getLocation(MainUtil.getPlotBottomLocAbs(p.world,p.id).subtract(1,0,1)),BukkitUtil.getLocation(MainUtil.getPlotTopLocAbs(p.world,p.id)),BukkitUtil.getLocation(MainUtil.getPlotHome(p.world,p.id))};
}"
57964,"/** 
 * Get the PlotSquared class
 * @return PlotSquared Class
 * @see com.intellectualcrafters.plot.PS
 */
public PS getPlotSquared(){
  return PS.get();
}","/** 
 * Get the PlotSquared class
 * @return PlotSquared Class
 * @see PS
 */
public PS getPlotSquared(){
  return PS.get();
}"
57965,"/** 
 * Check whether or not a player is in a plot
 * @param player who we're checking for
 * @return true if the player is in a plot, false if not-
 * @see com.intellectualcrafters.plot.util.MainUtil#getPlotAbs(com.intellectualcrafters.plot.object.Location)
 */
public boolean isInPlot(final Player player){
  return MainUtil.getPlotAbs(BukkitUtil.getLocation(player)) != null;
}","/** 
 * Check whether or not a player is in a plot
 * @param player who we're checking for
 * @return true if the player is in a plot, false if not-
 * @see MainUtil#getPlotAbs(com.intellectualcrafters.plot.object.Location)
 */
public boolean isInPlot(final Player player){
  return MainUtil.getPlotAbs(BukkitUtil.getLocation(player)) != null;
}"
57966,"/** 
 * Get the table entry ID
 * @param world Which the plot is located in
 * @param id2   Plot ID
 * @return Integer = Plot Entry Id
 */
int getId(final Plot plot);","/** 
 * Get the table entry ID
 * @param plot Plot Object
 * @return Integer = Plot Entry Id
 */
int getId(final Plot plot);"
57967,"/** 
 * Get the id of a given plot cluster
 * @param world Which the plot is located in
 * @param id cluster id
 * @return Integer = Cluster Entry Id
 */
int getClusterId(final PlotCluster cluster);","/** 
 * Get the id of a given plot cluster
 * @param cluster PlotCluster Object
 * @return Integer = Cluster Entry Id
 */
int getClusterId(final PlotCluster cluster);"
57968,"/** 
 * Get Plot Comments
 * @param world World in which the plot is located
 * @param plot  Plot Object
 * @param tier  Comment Tier
 * @return Plot Comments within the specified tier
 */
void getComments(final Plot plot,final String inbox,final RunnableVal whenDone);","/** 
 * Get Plot Comments
 * @param plot  Plot Object
 * @return Plot Comments within the specified tier
 */
void getComments(final Plot plot,final String inbox,final RunnableVal whenDone);"
57969,"/** 
 * Remove a plot comment
 * @param world   World in which the plot is located
 * @param plot    Plot Object
 * @param comment Comment to remove
 */
void removeComment(final Plot plot,final PlotComment comment);","/** 
 * Remove a plot comment
 * @param plot    Plot Object
 * @param comment Comment to remove
 */
void removeComment(final Plot plot,final PlotComment comment);"
57970,"/** 
 * @param world
 * @param cluster
 * @param uuid
 */
void setInvited(final PlotCluster cluster,final UUID uuid);","/** 
 * @param cluster
 * @param uuid
 */
void setInvited(final PlotCluster cluster,final UUID uuid);"
57971,"/** 
 * Create tables
 * @param database Database in which the tables will be created
 * @throws SQLException If the database manager is unable to create the tables
 */
void createTables() throws Exception ;","/** 
 * Create tables
 * @throws SQLException If the database manager is unable to create the tables
 */
void createTables() throws Exception ;"
57972,"/** 
 * Set a plot comment
 * @param world   World in which the plot is located
 * @param plot    Plot Object
 * @param comment Comment to add
 */
void setComment(final Plot plot,final PlotComment comment);","/** 
 * Set a plot comment
 * @param plot    Plot Object
 * @param comment Comment to add
 */
void setComment(final Plot plot,final PlotComment comment);"
57973,"/** 
 * Set the merged status for a plot
 * @param world  World in which the plot is located
 * @param plot   Plot Object
 * @param merged boolean[]
 */
void setMerged(final Plot plot,final boolean[] merged);","/** 
 * Set the merged status for a plot
 * @param plot   Plot Object
 * @param merged boolean[]
 */
void setMerged(final Plot plot,final boolean[] merged);"
57974,"@Override public void sendMessage(String message){
  player.sendMessage(ChatTypes.CHAT,message);
}","@Override public void sendMessage(String message){
  player.sendMessage(ChatTypes.CHAT,Texts.of(message));
}"
57975,"/** 
 * Finishing off plot merging by adding in the walls surrounding the plot (OPTIONAL)(UNFINISHED)
 */
@Override public boolean finishPlotMerge(final PlotWorld plotworld,final ArrayList<PlotId> plotIds){
  final PlotId pos1=plotIds.get(0);
  final PlotBlock block=((ClassicPlotWorld)plotworld).CLAIMED_WALL_BLOCK;
  final PlotBlock unclaim=((ClassicPlotWorld)plotworld).WALL_BLOCK;
  if (!block.equals(unclaim)) {
    setWall(plotworld,pos1,new PlotBlock[]{block});
  }
  return true;
}","/** 
 * Finishing off plot merging by adding in the walls surrounding the plot (OPTIONAL)(UNFINISHED)
 */
@Override public boolean finishPlotMerge(final PlotWorld plotworld,final ArrayList<PlotId> plotIds){
  final PlotId pos1=plotIds.get(0);
  final PlotBlock block=((ClassicPlotWorld)plotworld).CLAIMED_WALL_BLOCK;
  final PlotBlock unclaim=((ClassicPlotWorld)plotworld).WALL_BLOCK;
  if (block.id != 0 || !block.equals(unclaim)) {
    setWall(plotworld,pos1,new PlotBlock[]{block});
  }
  return true;
}"
57976,"/** 
 * Clearing the plot needs to only consider removing the blocks - This implementation has used the setCuboidAsync function, as it is fast, and uses NMS code - It also makes use of the fact that deleting chunks is a lot faster than block updates This code is very messy, but you don't need to do something quite as complex unless you happen to have 512x512 sized plots
 */
@Override public boolean clearPlot(final PlotWorld plotworld,final Plot plot,final boolean isDelete,final Runnable whenDone){
  final String world=plotworld.worldname;
  final HybridPlotWorld dpw=((HybridPlotWorld)plotworld);
  final Location pos1=MainUtil.getPlotBottomLocAbs(world,plot.id).add(1,0,1);
  final Location pos2=MainUtil.getPlotTopLocAbs(world,plot.id);
  final boolean canRegen=plotworld.TYPE == 0 && plotworld.TERRAIN == 0;
  final PlotBlock[] plotfloor=dpw.TOP_BLOCK;
  final PlotBlock[] filling=dpw.MAIN_BLOCK;
  final PlotBlock[] bedrock=(dpw.PLOT_BEDROCK ? new PlotBlock[]{new PlotBlock((short)7,(byte)0)} : filling);
  final PlotBlock air=new PlotBlock((short)0,(byte)0);
  setWallFilling(dpw,plot.id,new PlotBlock[]{dpw.WALL_FILLING});
  ChunkManager.chunkTask(pos1,pos2,new RunnableVal<int[]>(){
    @Override public void run(){
      if (canRegen && value[6] == 0) {
        ChunkManager.manager.regenerateChunk(world,new ChunkLoc(value[0],value[1]));
        return;
      }
      MainUtil.setBiome(world,value[2],value[3],value[4],value[5],dpw.PLOT_BIOME);
      Location bot=new Location(world,value[2],0,value[3]);
      Location top=new Location(world,value[4] + 1,1,value[5] + 1);
      MainUtil.setCuboidAsync(world,bot,top,bedrock);
      bot.setY(1);
      top.setY(dpw.PLOT_HEIGHT);
      MainUtil.setCuboidAsync(world,bot,top,filling);
      bot.setY(dpw.PLOT_HEIGHT);
      top.setY(dpw.PLOT_HEIGHT + 1);
      MainUtil.setCuboidAsync(world,bot,top,plotfloor);
      bot.setY(dpw.PLOT_HEIGHT + 1);
      top.setY(256);
      MainUtil.setSimpleCuboidAsync(world,bot,top,air);
      pastePlotSchematic(dpw,bot,top);
    }
  }
,new Runnable(){
    @Override public void run(){
      final PlotBlock wall=isDelete ? dpw.WALL_BLOCK : dpw.CLAIMED_WALL_BLOCK;
      setWall(dpw,plot.id,new PlotBlock[]{wall});
      SetBlockQueue.addNotify(whenDone);
    }
  }
,5);
  return true;
}","/** 
 * Clearing the plot needs to only consider removing the blocks - This implementation has used the setCuboidAsync function, as it is fast, and uses NMS code - It also makes use of the fact that deleting chunks is a lot faster than block updates This code is very messy, but you don't need to do something quite as complex unless you happen to have 512x512 sized plots
 */
@Override public boolean clearPlot(final PlotWorld plotworld,final Plot plot,final boolean isDelete,final Runnable whenDone){
  final String world=plotworld.worldname;
  final HybridPlotWorld dpw=((HybridPlotWorld)plotworld);
  final Location pos1=MainUtil.getPlotBottomLocAbs(world,plot.id).add(1,0,1);
  final Location pos2=MainUtil.getPlotTopLocAbs(world,plot.id);
  final boolean canRegen=plotworld.TYPE == 0 && plotworld.TERRAIN == 0;
  final PlotBlock[] plotfloor=dpw.TOP_BLOCK;
  final PlotBlock[] filling=dpw.MAIN_BLOCK;
  final PlotBlock[] bedrock=(dpw.PLOT_BEDROCK ? new PlotBlock[]{new PlotBlock((short)7,(byte)0)} : filling);
  final PlotBlock air=new PlotBlock((short)0,(byte)0);
  setWallFilling(dpw,plot.id,new PlotBlock[]{dpw.WALL_FILLING});
  ChunkManager.chunkTask(pos1,pos2,new RunnableVal<int[]>(){
    @Override public void run(){
      if (canRegen && value[6] == 0) {
        ChunkManager.manager.regenerateChunk(world,new ChunkLoc(value[0],value[1]));
        return;
      }
      MainUtil.setBiome(world,value[2],value[3],value[4],value[5],dpw.PLOT_BIOME);
      Location bot=new Location(world,value[2],0,value[3]);
      Location top=new Location(world,value[4] + 1,1,value[5] + 1);
      MainUtil.setCuboidAsync(world,bot,top,bedrock);
      bot.setY(1);
      top.setY(dpw.PLOT_HEIGHT);
      MainUtil.setCuboidAsync(world,bot,top,filling);
      bot.setY(dpw.PLOT_HEIGHT);
      top.setY(dpw.PLOT_HEIGHT + 1);
      MainUtil.setCuboidAsync(world,bot,top,plotfloor);
      bot.setY(dpw.PLOT_HEIGHT + 1);
      top.setY(256);
      MainUtil.setSimpleCuboidAsync(world,bot,top,air);
      pastePlotSchematic(dpw,bot,top);
    }
  }
,new Runnable(){
    @Override public void run(){
      final PlotBlock wall=isDelete ? dpw.WALL_BLOCK : dpw.CLAIMED_WALL_BLOCK;
      if (wall.id != 0 || !dpw.WALL_BLOCK.equals(dpw.CLAIMED_WALL_BLOCK)) {
        setWall(dpw,plot.id,new PlotBlock[]{wall});
      }
      SetBlockQueue.addNotify(whenDone);
    }
  }
,5);
  return true;
}"
57977,"@Override public void run(){
  final PlotBlock wall=isDelete ? dpw.WALL_BLOCK : dpw.CLAIMED_WALL_BLOCK;
  setWall(dpw,plot.id,new PlotBlock[]{wall});
  SetBlockQueue.addNotify(whenDone);
}","@Override public void run(){
  final PlotBlock wall=isDelete ? dpw.WALL_BLOCK : dpw.CLAIMED_WALL_BLOCK;
  if (wall.id != 0 || !dpw.WALL_BLOCK.equals(dpw.CLAIMED_WALL_BLOCK)) {
    setWall(dpw,plot.id,new PlotBlock[]{wall});
  }
  SetBlockQueue.addNotify(whenDone);
}"
57978,"@Override public boolean hasPermission(final String perm){
  if (Settings.PERMISSION_CACHING) {
    if (this.noPerm.contains(perm)) {
      return false;
    }
    if (this.hasPerm.contains(perm)) {
      return true;
    }
    final boolean result=this.player.hasPermission(perm);
    if (!result) {
      this.noPerm.add(perm);
      return false;
    }
    this.hasPerm.add(perm);
    return true;
  }
  if (offline && EconHandler.manager != null) {
    System.out.print(""String_Node_Str"");
    return EconHandler.manager.hasPermission(getName(),perm);
  }
  System.out.print(""String_Node_Str"" + perm + ""String_Node_Str""+ player.hasPermission(perm));
  return this.player.hasPermission(perm);
}","@Override public boolean hasPermission(final String perm){
  if (Settings.PERMISSION_CACHING) {
    if (this.noPerm.contains(perm)) {
      return false;
    }
    if (this.hasPerm.contains(perm)) {
      return true;
    }
    final boolean result=this.player.hasPermission(perm);
    if (!result) {
      this.noPerm.add(perm);
      return false;
    }
    this.hasPerm.add(perm);
    return true;
  }
  if (offline && EconHandler.manager != null) {
    return EconHandler.manager.hasPermission(getName(),perm);
  }
  return this.player.hasPermission(perm);
}"
57979,"@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onEntityDamageByEntityEvent(final EntityDamageByEntityEvent e){
  final Location l=BukkitUtil.getLocation(e.getEntity());
  if (!PS.get().isPlotWorld(l.getWorld())) {
    return;
  }
  final Entity damager=e.getDamager();
  final Entity victim=e.getEntity();
  Location dloc=BukkitUtil.getLocation(damager);
  Location vloc=BukkitUtil.getLocation(victim);
  Plot dplot=MainUtil.getPlot(dloc);
  Plot vplot=MainUtil.getPlot(vloc);
  Plot plot;
  String stub;
  if (dplot == null && vplot == null) {
    if (!MainUtil.isPlotAreaAbs(dloc)) {
      return;
    }
    plot=null;
    stub=""String_Node_Str"";
  }
 else {
    plot=vplot == null ? dplot : ((dplot == null || !(victim instanceof Player)) ? vplot : (victim.getTicksLived() > damager.getTicksLived() ? dplot : vplot));
    stub=plot.hasOwner() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
  Player player;
  if (damager instanceof Player) {
    player=(Player)damager;
  }
 else   if (damager instanceof Projectile) {
    Projectile projectile=(Projectile)damager;
    ProjectileSource shooter=projectile.getShooter();
    if (shooter instanceof Player) {
      player=(Player)shooter;
    }
 else {
      player=null;
    }
  }
 else {
    player=null;
  }
  if (player != null) {
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (victim instanceof Hanging) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof ArmorStand) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Monster || victim instanceof EnderDragon) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Tameable) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Player) {
      if (plot != null) {
        Flag pvp=FlagManager.getPlotFlag(plot,FLAG_PVP);
        if (pvp == null) {
          return;
        }
 else {
          if ((Boolean)pvp.getValue()) {
            return;
          }
        }
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Creature) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Vehicle) {
      return;
    }
 else {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
    return;
  }
  if ((damager instanceof Arrow) && (!(victim instanceof Creature))) {
    e.setCancelled(true);
  }
}","@EventHandler(priority=EventPriority.HIGHEST,ignoreCancelled=true) public void onEntityDamageByEntityEvent(final EntityDamageByEntityEvent e){
  final Location l=BukkitUtil.getLocation(e.getEntity());
  if (!PS.get().isPlotWorld(l.getWorld())) {
    return;
  }
  final Entity damager=e.getDamager();
  final Entity victim=e.getEntity();
  Location dloc=BukkitUtil.getLocation(damager);
  Location vloc=BukkitUtil.getLocation(victim);
  Plot dplot=MainUtil.getPlot(dloc);
  Plot vplot=MainUtil.getPlot(vloc);
  Plot plot;
  String stub;
  if (dplot == null && vplot == null) {
    if (!MainUtil.isPlotAreaAbs(dloc)) {
      return;
    }
    plot=null;
    stub=""String_Node_Str"";
  }
 else {
    plot=vplot == null ? dplot : ((dplot == null || !(victim instanceof Player)) ? vplot : (victim.getTicksLived() > damager.getTicksLived() ? dplot : vplot));
    stub=plot.hasOwner() ? ""String_Node_Str"" : ""String_Node_Str"";
  }
  Player player;
  if (damager instanceof Player) {
    player=(Player)damager;
  }
 else   if (damager instanceof Projectile) {
    Projectile projectile=(Projectile)damager;
    ProjectileSource shooter=projectile.getShooter();
    if (shooter instanceof Player) {
      player=(Player)shooter;
    }
 else {
      player=null;
    }
  }
 else {
    player=null;
  }
  if (player != null) {
    PlotPlayer pp=BukkitUtil.getPlayer(player);
    if (victim instanceof Hanging) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim.getEntityId() == 30) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Monster || victim instanceof EnderDragon) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Tameable) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Player) {
      if (plot != null) {
        Flag pvp=FlagManager.getPlotFlag(plot,FLAG_PVP);
        if (pvp == null) {
          return;
        }
 else {
          if ((Boolean)pvp.getValue()) {
            return;
          }
        }
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Creature) {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
 else     if (victim instanceof Vehicle) {
      return;
    }
 else {
      if (plot != null && ((FlagManager.isPlotFlagTrue(plot,""String_Node_Str"") || plot.isAdded(pp.getUUID())))) {
        return;
      }
      if (!Permissions.hasPermission(pp,""String_Node_Str"" + stub)) {
        e.setCancelled(true);
        MainUtil.sendMessage(pp,C.NO_PERMISSION,""String_Node_Str"" + stub);
        return;
      }
    }
    return;
  }
  if ((damager instanceof Arrow) && (!(victim instanceof Creature))) {
    e.setCancelled(true);
  }
}"
57980,"@Override public boolean onCommand(final CommandCaller caller,final String... args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  if (args.length == 0) {
    MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
    return false;
  }
  final String sub=args[0].toLowerCase();
switch (sub) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
        MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
        return false;
      }
      if (args.length != 1) {
        MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
        return false;
      }
      final HashSet<PlotCluster> clusters=ClusterManager.getClusters(plr.getLocation().getWorld());
      MainUtil.sendMessage(plr,C.CLUSTER_LIST_HEADING,clusters.size() + ""String_Node_Str"");
      for (      final PlotCluster cluster : clusters) {
        final String name=""String_Node_Str"" + cluster.getName() + ""String_Node_Str""+ cluster.toString();
        if (UUIDHandler.getUUID(plr).equals(cluster.owner)) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.helpers.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.invited.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,cluster.toString());
        }
      }
      return true;
    }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
    if (args.length != 4) {
      final PlotId id=ClusterManager.estimatePlotId(plr.getLocation());
      MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
      MainUtil.sendMessage(plr,C.CLUSTER_CURRENT_PLOTID,""String_Node_Str"" + id);
      return false;
    }
    PlotId pos1=MainUtil.parseId(args[2]);
    PlotId pos2=MainUtil.parseId(args[3]);
    if ((pos1 == null) || (pos2 == null)) {
      MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
      return false;
    }
    final String name=args[1];
    for (    final PlotCluster cluster : ClusterManager.getClusters(plr.getLocation().getWorld())) {
      if (name.equals(cluster.getName())) {
        MainUtil.sendMessage(plr,C.ALIAS_IS_TAKEN);
        return false;
      }
    }
    final PlotClusterId id=new PlotClusterId(pos1,pos2);
    final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
    if ((intersects.size() > 0)) {
      MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,intersects.size() + ""String_Node_Str"");
      return false;
    }
    if ((pos2.x < pos1.x) || (pos2.y < pos1.y)) {
      pos1=new PlotId(Math.min(pos1.x,pos2.x),Math.min(pos1.y,pos2.y));
      pos2=new PlotId(Math.max(pos1.x,pos2.x),Math.max(pos1.y,pos2.y));
    }
    final String world=plr.getLocation().getWorld();
    final PlotCluster cluster=new PlotCluster(world,pos1,pos2,UUIDHandler.getUUID(plr));
    cluster.settings.setAlias(name);
    DBFunc.createCluster(world,cluster);
    if (!ClusterManager.clusters.containsKey(world)) {
      ClusterManager.clusters.put(world,new HashSet<PlotCluster>());
    }
    ClusterManager.clusters.get(world).add(cluster);
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster current=ClusterManager.getCluster(plot);
      if (cluster.equals(current) && !cluster.isAdded(plot.owner)) {
        cluster.invited.add(plot.owner);
        DBFunc.setInvited(world,cluster,plot.owner);
      }
    }
    PlotWorld plotworld=PS.get().getPlotWorld(world);
    if (plotworld == null) {
      PS.get().config.createSection(""String_Node_Str"" + world);
      PS.get().loadWorld(world,null);
    }
 else {
      final String gen_string=PS.get().config.getString(""String_Node_Str"" + world + ""String_Node_Str""+ ""String_Node_Str"");
      PlotGenerator generator;
      if (gen_string == null) {
        generator=new HybridGen(world);
      }
 else {
        generator=(PlotGenerator)PS.get().IMP.getGenerator(world,gen_string);
      }
      new AugmentedPopulator(world,generator,cluster,plotworld.TERRAIN == 2,plotworld.TERRAIN != 2);
    }
    MainUtil.sendMessage(plr,C.CLUSTER_ADDED);
    return true;
  }
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
  if ((args.length != 1) && (args.length != 2)) {
    MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
    return false;
  }
  PlotCluster cluster;
  if (args.length == 2) {
    cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
      return false;
    }
  }
 else {
    cluster=ClusterManager.getCluster(plr.getLocation());
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
      return false;
    }
  }
  if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
  }
  final PlotWorld plotworld=PS.get().getPlotWorld(plr.getLocation().getWorld());
  if (plotworld.TYPE == 2) {
    final ArrayList<Plot> toRemove=new ArrayList<>();
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster other=ClusterManager.getCluster(plot);
      if (cluster.equals(other)) {
        toRemove.add(plot);
      }
    }
    for (    final Plot plot : toRemove) {
      plot.unclaim();
    }
  }
  DBFunc.delete(cluster);
  if (plotworld.TYPE == 2) {
    AugmentedPopulator.removePopulator(plr.getLocation().getWorld(),cluster);
  }
  ClusterManager.last=null;
  ClusterManager.clusters.get(cluster.world).remove(cluster);
  ClusterManager.regenCluster(cluster);
  MainUtil.sendMessage(plr,C.CLUSTER_DELETED);
  return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
if (args.length != 3) {
  MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
  return false;
}
final PlotId pos1=MainUtil.parseId(args[1]);
final PlotId pos2=MainUtil.parseId(args[2]);
if ((pos1 == null) || (pos2 == null)) {
  MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
  return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
}
final PlotClusterId id=new PlotClusterId(pos1,pos2);
final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
if (intersects.size() > 1) {
  MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,(intersects.size() - 1) + ""String_Node_Str"");
  return false;
}
DBFunc.resizeCluster(cluster,id);
MainUtil.sendMessage(plr,C.CLUSTER_RESIZED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
  MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
  return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
}
if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
}
ClusterManager.regenCluster(cluster);
MainUtil.sendMessage(plr,C.CLUSTER_REGENERATED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (!cluster.isAdded(uuid)) {
cluster.invited.add(uuid);
final String world=plr.getLocation().getWorld();
DBFunc.setInvited(world,cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_INVITED,cluster.getName());
}
}
MainUtil.sendMessage(plr,C.CLUSTER_ADDED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[1]);
return false;
}
if (uuid.equals(UUIDHandler.getUUID(plr)) || uuid.equals(cluster.owner) || !cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CANNOT_KICK_PLAYER,cluster.getName());
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_REMOVED,cluster.getName());
}
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
MainUtil.sendMessage(plr,C.CLUSTER_KICKED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CLUSTER_NOT_ADDED);
return false;
}
if (uuid.equals(cluster.owner)) {
MainUtil.sendMessage(plr,C.CLUSTER_CANNOT_LEAVE);
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
MainUtil.sendMessage(plr,C.CLUSTER_REMOVED,cluster.getName());
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 3) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
final UUID uuid=UUIDHandler.getUUID(args[2]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.add(uuid);
DBFunc.setHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_ADDED_HELPER);
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_REMOVED_HELPER);
}
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
plr.teleport(ClusterManager.getHome(cluster));
return MainUtil.sendMessage(plr,C.CLUSTER_TELEPORTING);
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final String id=cluster.toString();
String owner=UUIDHandler.getName(cluster.owner);
if (owner == null) {
owner=""String_Node_Str"";
}
final String name=cluster.getName();
final String size=((cluster.getP2().x - cluster.getP1().x) + 1) + ""String_Node_Str"" + ((cluster.getP2().y - cluster.getP1().y) + 1);
final String rights=cluster.isAdded(UUIDHandler.getUUID(plr)) + ""String_Node_Str"";
String message=C.CLUSTER_INFO.s();
message=message.replaceAll(""String_Node_Str"",id);
message=message.replaceAll(""String_Node_Str"",owner);
message=message.replaceAll(""String_Node_Str"",name);
message=message.replaceAll(""String_Node_Str"",size);
message=message.replaceAll(""String_Node_Str"",rights);
MainUtil.sendMessage(plr,message);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final Location base=ClusterManager.getClusterBottom(cluster);
final Location relative=plr.getLocation().subtract(base.getX(),0,base.getZ());
final BlockLoc blockloc=new BlockLoc(relative.getX(),relative.getY(),relative.getZ());
cluster.settings.setPosition(blockloc);
DBFunc.setPosition(cluster,relative.getX() + ""String_Node_Str"" + relative.getY()+ ""String_Node_Str""+ relative.getZ());
return MainUtil.sendMessage(plr,C.POSITION_SET);
}
}
MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
return false;
}","@Override public boolean onCommand(final CommandCaller caller,final String... args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  if (args.length == 0) {
    MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
    return false;
  }
  final String sub=args[0].toLowerCase();
switch (sub) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
        MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
        return false;
      }
      if (args.length != 1) {
        MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
        return false;
      }
      final HashSet<PlotCluster> clusters=ClusterManager.getClusters(plr.getLocation().getWorld());
      MainUtil.sendMessage(plr,C.CLUSTER_LIST_HEADING,clusters.size() + ""String_Node_Str"");
      for (      final PlotCluster cluster : clusters) {
        final String name=""String_Node_Str"" + cluster.getName() + ""String_Node_Str""+ cluster.toString();
        if (UUIDHandler.getUUID(plr).equals(cluster.owner)) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.helpers.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.invited.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,cluster.toString());
        }
      }
      return true;
    }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
    if (args.length != 4) {
      final PlotId id=ClusterManager.estimatePlotId(plr.getLocation());
      MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
      MainUtil.sendMessage(plr,C.CLUSTER_CURRENT_PLOTID,""String_Node_Str"" + id);
      return false;
    }
    PlotId pos1=MainUtil.parseId(args[2]);
    PlotId pos2=MainUtil.parseId(args[3]);
    if ((pos1 == null) || (pos2 == null)) {
      MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
      return false;
    }
    final String name=args[1];
    for (    final PlotCluster cluster : ClusterManager.getClusters(plr.getLocation().getWorld())) {
      if (name.equals(cluster.getName())) {
        MainUtil.sendMessage(plr,C.ALIAS_IS_TAKEN);
        return false;
      }
    }
    final PlotClusterId id=new PlotClusterId(pos1,pos2);
    final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
    if ((intersects.size() > 0)) {
      MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,intersects.size() + ""String_Node_Str"");
      return false;
    }
    if ((pos2.x < pos1.x) || (pos2.y < pos1.y)) {
      pos1=new PlotId(Math.min(pos1.x,pos2.x),Math.min(pos1.y,pos2.y));
      pos2=new PlotId(Math.max(pos1.x,pos2.x),Math.max(pos1.y,pos2.y));
    }
    final String world=plr.getLocation().getWorld();
    final PlotCluster cluster=new PlotCluster(world,pos1,pos2,UUIDHandler.getUUID(plr));
    cluster.settings.setAlias(name);
    DBFunc.createCluster(world,cluster);
    if (!ClusterManager.clusters.containsKey(world)) {
      ClusterManager.clusters.put(world,new HashSet<PlotCluster>());
    }
    ClusterManager.clusters.get(world).add(cluster);
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster current=ClusterManager.getCluster(plot);
      if (cluster.equals(current) && !cluster.isAdded(plot.owner)) {
        cluster.invited.add(plot.owner);
        DBFunc.setInvited(world,cluster,plot.owner);
      }
    }
    PlotWorld plotworld=PS.get().getPlotWorld(world);
    if (plotworld == null) {
      PS.get().config.createSection(""String_Node_Str"" + world);
      PS.get().loadWorld(world,null);
    }
 else {
      final String gen_string=PS.get().config.getString(""String_Node_Str"" + world + ""String_Node_Str""+ ""String_Node_Str"");
      BukkitPlotGenerator generator;
      if (gen_string == null) {
        generator=new HybridGen(world);
      }
 else {
        ChunkGenerator chunkgen=(ChunkGenerator)PS.get().IMP.getGenerator(world,gen_string).generator;
        if (chunkgen instanceof BukkitPlotGenerator) {
          generator=(BukkitPlotGenerator)chunkgen;
        }
 else {
          MainUtil.sendMessage(plr,C.SETUP_INVALID_GENERATOR,StringMan.join(SetupUtils.generators.keySet(),""String_Node_Str""));
          return false;
        }
      }
      new AugmentedPopulator(world,generator,cluster,plotworld.TERRAIN == 2,plotworld.TERRAIN != 2);
    }
    MainUtil.sendMessage(plr,C.CLUSTER_ADDED);
    return true;
  }
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
  if ((args.length != 1) && (args.length != 2)) {
    MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
    return false;
  }
  PlotCluster cluster;
  if (args.length == 2) {
    cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
      return false;
    }
  }
 else {
    cluster=ClusterManager.getCluster(plr.getLocation());
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
      return false;
    }
  }
  if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
  }
  final PlotWorld plotworld=PS.get().getPlotWorld(plr.getLocation().getWorld());
  if (plotworld.TYPE == 2) {
    final ArrayList<Plot> toRemove=new ArrayList<>();
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster other=ClusterManager.getCluster(plot);
      if (cluster.equals(other)) {
        toRemove.add(plot);
      }
    }
    for (    final Plot plot : toRemove) {
      plot.unclaim();
    }
  }
  DBFunc.delete(cluster);
  if (plotworld.TYPE == 2) {
    AugmentedPopulator.removePopulator(plr.getLocation().getWorld(),cluster);
  }
  ClusterManager.last=null;
  ClusterManager.clusters.get(cluster.world).remove(cluster);
  ClusterManager.regenCluster(cluster);
  MainUtil.sendMessage(plr,C.CLUSTER_DELETED);
  return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
if (args.length != 3) {
  MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
  return false;
}
final PlotId pos1=MainUtil.parseId(args[1]);
final PlotId pos2=MainUtil.parseId(args[2]);
if ((pos1 == null) || (pos2 == null)) {
  MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
  return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
}
final PlotClusterId id=new PlotClusterId(pos1,pos2);
final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
if (intersects.size() > 1) {
  MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,(intersects.size() - 1) + ""String_Node_Str"");
  return false;
}
DBFunc.resizeCluster(cluster,id);
MainUtil.sendMessage(plr,C.CLUSTER_RESIZED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
  MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
  return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
}
if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
}
ClusterManager.regenCluster(cluster);
MainUtil.sendMessage(plr,C.CLUSTER_REGENERATED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (!cluster.isAdded(uuid)) {
cluster.invited.add(uuid);
final String world=plr.getLocation().getWorld();
DBFunc.setInvited(world,cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_INVITED,cluster.getName());
}
}
MainUtil.sendMessage(plr,C.CLUSTER_ADDED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[1]);
return false;
}
if (uuid.equals(UUIDHandler.getUUID(plr)) || uuid.equals(cluster.owner) || !cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CANNOT_KICK_PLAYER,cluster.getName());
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_REMOVED,cluster.getName());
}
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
MainUtil.sendMessage(plr,C.CLUSTER_KICKED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CLUSTER_NOT_ADDED);
return false;
}
if (uuid.equals(cluster.owner)) {
MainUtil.sendMessage(plr,C.CLUSTER_CANNOT_LEAVE);
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
MainUtil.sendMessage(plr,C.CLUSTER_REMOVED,cluster.getName());
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 3) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
final UUID uuid=UUIDHandler.getUUID(args[2]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.add(uuid);
DBFunc.setHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_ADDED_HELPER);
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_REMOVED_HELPER);
}
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
plr.teleport(ClusterManager.getHome(cluster));
return MainUtil.sendMessage(plr,C.CLUSTER_TELEPORTING);
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final String id=cluster.toString();
String owner=UUIDHandler.getName(cluster.owner);
if (owner == null) {
owner=""String_Node_Str"";
}
final String name=cluster.getName();
final String size=((cluster.getP2().x - cluster.getP1().x) + 1) + ""String_Node_Str"" + ((cluster.getP2().y - cluster.getP1().y) + 1);
final String rights=cluster.isAdded(UUIDHandler.getUUID(plr)) + ""String_Node_Str"";
String message=C.CLUSTER_INFO.s();
message=message.replaceAll(""String_Node_Str"",id);
message=message.replaceAll(""String_Node_Str"",owner);
message=message.replaceAll(""String_Node_Str"",name);
message=message.replaceAll(""String_Node_Str"",size);
message=message.replaceAll(""String_Node_Str"",rights);
MainUtil.sendMessage(plr,message);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final Location base=ClusterManager.getClusterBottom(cluster);
final Location relative=plr.getLocation().subtract(base.getX(),0,base.getZ());
final BlockLoc blockloc=new BlockLoc(relative.getX(),relative.getY(),relative.getZ());
cluster.settings.setPosition(blockloc);
DBFunc.setPosition(cluster,relative.getX() + ""String_Node_Str"" + relative.getY()+ ""String_Node_Str""+ relative.getZ());
return MainUtil.sendMessage(plr,C.POSITION_SET);
}
}
MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
return false;
}"
57981,"public static List<String> helpMenu(final PlotPlayer player,final CommandCategory category,int page){
  List<Command> commands;
  if (category != null) {
    commands=getCommands(category,player);
  }
 else {
    commands=instance.commands;
  }
  final int perPage=5;
  final int totalPages=(commands.size() / perPage) + (commands.size() % perPage == 0 ? 0 : 1);
  if (page > totalPages) {
    page=totalPages;
  }
  int max=(page * perPage) + perPage;
  if (max > commands.size()) {
    max=commands.size();
  }
  final List<String> help=new ArrayList<>();
  help.add(C.HELP_HEADER.s());
  help.add(C.HELP_CATEGORY.s().replace(""String_Node_Str"",category == null ? ""String_Node_Str"" : category.toString()).replace(""String_Node_Str"",""String_Node_Str"" + (page + 1)).replace(""String_Node_Str"",""String_Node_Str"" + (totalPages)).replace(""String_Node_Str"",""String_Node_Str"" + perPage).replace(""String_Node_Str"",""String_Node_Str"" + commands.size()));
  Command cmd;
  final int start=page * perPage;
  for (int x=start; x < max; x++) {
    cmd=commands.get(x);
    String s=C.HELP_ITEM.s();
    if (cmd.getAliases().length > 0) {
      s=s.replace(""String_Node_Str"",cmd.getAliases()[0]);
    }
 else {
      s=s.replace(""String_Node_Str"",""String_Node_Str"");
    }
    s=s.replace(""String_Node_Str"",cmd.getUsage().contains(""String_Node_Str"") ? cmd.getUsage() : ""String_Node_Str"" + cmd.getUsage()).replace(""String_Node_Str"",cmd.getCommand()).replace(""String_Node_Str"",cmd.getDescription()).replace(""String_Node_Str"",""String_Node_Str"");
    help.add(s);
  }
  if (help.size() < 2) {
    help.add(C.NO_COMMANDS.s());
  }
  return help;
}","public static List<String> helpMenu(final PlotPlayer player,final CommandCategory category,int page){
  List<Command> commands;
  commands=getCommands(category,player);
  final int perPage=5;
  final int totalPages=(commands.size() / perPage) + (commands.size() % perPage == 0 ? 0 : 1);
  if (page > totalPages) {
    page=totalPages;
  }
  int max=(page * perPage) + perPage;
  if (max > commands.size()) {
    max=commands.size();
  }
  final List<String> help=new ArrayList<>();
  help.add(C.HELP_HEADER.s());
  help.add(C.HELP_CATEGORY.s().replace(""String_Node_Str"",category == null ? ""String_Node_Str"" : category.toString()).replace(""String_Node_Str"",""String_Node_Str"" + (page + 1)).replace(""String_Node_Str"",""String_Node_Str"" + (totalPages)).replace(""String_Node_Str"",""String_Node_Str"" + perPage).replace(""String_Node_Str"",""String_Node_Str"" + commands.size()));
  Command cmd;
  final int start=page * perPage;
  for (int x=start; x < max; x++) {
    cmd=commands.get(x);
    String s=C.HELP_ITEM.s();
    if (cmd.getAliases().size() > 0) {
      s=s.replace(""String_Node_Str"",StringMan.join(cmd.getAliases(),""String_Node_Str""));
    }
 else {
      s=s.replace(""String_Node_Str"",""String_Node_Str"");
    }
    s=s.replace(""String_Node_Str"",cmd.getUsage().contains(""String_Node_Str"") ? cmd.getUsage() : ""String_Node_Str"" + cmd.getUsage()).replace(""String_Node_Str"",cmd.getCommand()).replace(""String_Node_Str"",cmd.getDescription()).replace(""String_Node_Str"",""String_Node_Str"");
    help.add(s);
  }
  if (help.size() < 2) {
    help.add(C.NO_COMMANDS.s());
  }
  return help;
}"
57982,"@Override public int handle(CommandCaller caller,String input){
  String[] parts=input.split(""String_Node_Str"");
  String[] args;
  String command=parts[0].toLowerCase();
  if (parts.length == 1) {
    args=new String[0];
  }
 else {
    args=new String[parts.length - 1];
    System.arraycopy(parts,1,args,0,args.length);
  }
  Command cmd=null;
  for (  Command c1 : this.commands) {
    if (c1.getCommand().equalsIgnoreCase(command) || c1.getAliases().contains(command)) {
      cmd=c1;
      break;
    }
  }
  if (cmd == null) {
    caller.message(C.NOT_VALID_SUBCOMMAND);
{
      final String[] commands=new String[this.commands.size()];
      for (int i=0; i < commands.length; i++) {
        commands[i]=this.commands.get(i).getCommand();
      }
      final String bestMatch=new StringComparison<String>(args[0],commands).getBestMatch();
      caller.message(C.DID_YOU_MEAN,""String_Node_Str"" + bestMatch);
    }
    return CommandHandlingOutput.NOT_FOUND;
  }
  if (!cmd.getRequiredType().isInstance(caller.getSuperCaller())) {
    if (caller instanceof PlotPlayerCaller) {
      caller.message(C.NOT_CONSOLE);
    }
 else {
      caller.message(C.IS_CONSOLE);
      return CommandHandlingOutput.CALLER_OF_WRONG_TYPE;
    }
  }
  if (!caller.hasPermission(cmd.getPermission())) {
    caller.message(C.NO_PERMISSION,cmd.getPermission());
    return CommandHandlingOutput.NOT_PERMITTED;
  }
  Argument[] requiredArguments=cmd.getRequiredArguments();
  if (requiredArguments != null && requiredArguments.length > 0) {
    boolean success=true;
    if (args.length < requiredArguments.length) {
      success=false;
    }
 else {
      for (int i=0; i < requiredArguments.length; i++) {
        if (requiredArguments[i].parse(args[i]) == null) {
          success=false;
          break;
        }
      }
    }
    if (!success) {
      caller.sendRequiredArgumentsList(this,cmd,requiredArguments);
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
  try {
    boolean a=cmd.onCommand(caller,args);
    if (!a) {
      String usage=cmd.getUsage();
      if (usage != null && !usage.isEmpty()) {
        caller.message(usage);
      }
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
 catch (  final Throwable t) {
    t.printStackTrace();
    return CommandHandlingOutput.ERROR;
  }
  return CommandHandlingOutput.SUCCESS;
}","@Override public int handle(CommandCaller caller,String input){
  String[] parts=input.split(""String_Node_Str"");
  String[] args;
  String command=parts[0].toLowerCase();
  if (parts.length == 1) {
    args=new String[0];
  }
 else {
    args=new String[parts.length - 1];
    System.arraycopy(parts,1,args,0,args.length);
  }
  Command cmd=null;
  cmd=this.commands.get(command);
  if (cmd == null) {
    caller.message(C.NOT_VALID_SUBCOMMAND);
{
      final String[] commands=new String[this.commands.size()];
      for (int i=0; i < commands.length; i++) {
        commands[i]=this.commands.get(i).getCommand();
      }
      final String bestMatch=new StringComparison<String>(args[0],commands).getBestMatch();
      caller.message(C.DID_YOU_MEAN,""String_Node_Str"" + bestMatch);
    }
    return CommandHandlingOutput.NOT_FOUND;
  }
  if (!cmd.getRequiredType().isInstance(caller.getSuperCaller())) {
    if (caller instanceof PlotPlayerCaller) {
      caller.message(C.NOT_CONSOLE);
    }
 else {
      caller.message(C.IS_CONSOLE);
      return CommandHandlingOutput.CALLER_OF_WRONG_TYPE;
    }
  }
  if (!caller.hasPermission(cmd.getPermission())) {
    caller.message(C.NO_PERMISSION,cmd.getPermission());
    return CommandHandlingOutput.NOT_PERMITTED;
  }
  Argument[] requiredArguments=cmd.getRequiredArguments();
  if (requiredArguments != null && requiredArguments.length > 0) {
    boolean success=true;
    if (args.length < requiredArguments.length) {
      success=false;
    }
 else {
      for (int i=0; i < requiredArguments.length; i++) {
        if (requiredArguments[i].parse(args[i]) == null) {
          success=false;
          break;
        }
      }
    }
    if (!success) {
      caller.sendRequiredArgumentsList(this,cmd,requiredArguments);
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
  try {
    boolean a=cmd.onCommand(caller,args);
    if (!a) {
      String usage=cmd.getUsage();
      if (usage != null && !usage.isEmpty()) {
        caller.message(usage);
      }
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
 catch (  final Throwable t) {
    t.printStackTrace();
    return CommandHandlingOutput.ERROR;
  }
  return CommandHandlingOutput.SUCCESS;
}"
57983,"public static List<Command> getCommands(final CommandCategory category,final PlotPlayer player){
  final List<Command> cmds=new ArrayList<>();
  for (  final Command c : instance.commands) {
    if (!c.getRequiredType().equals(PlotPlayer.class)) {
      if ((c.getCategory().equals(category)) && player.hasPermission(c.getPermission())) {
        cmds.add(c);
      }
    }
  }
  return cmds;
}","public static List<Command> getCommands(final CommandCategory category,final PlotPlayer player){
  final List<Command> cmds=new ArrayList<>();
  for (  final Command c : instance.commands.values()) {
    if (c.getRequiredType().isInstance(PlotPlayer.class)) {
      if ((category == null || (c.getCategory().equals(category))) && player.hasPermission(c.getPermission())) {
        cmds.add(c);
      }
    }
  }
  return cmds;
}"
57984,"public void displayGenerators(PlotPlayer plr){
  StringBuffer message=new StringBuffer();
  message.append(""String_Node_Str"");
  for (  Entry<String,ChunkGenerator> entry : SetupUtils.generators.entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
 else     if (entry.getValue() instanceof HybridGen) {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
 else     if (entry.getValue() instanceof PlotGenerator) {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
 else {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
  }
  MainUtil.sendMessage(plr,message.toString());
}","public void displayGenerators(PlotPlayer plr){
  StringBuffer message=new StringBuffer();
  message.append(""String_Node_Str"");
  for (  Entry<String,ChunkGenerator> entry : SetupUtils.generators.entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
 else     if (entry.getValue() instanceof HybridGen) {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
 else     if (entry.getValue() instanceof BukkitPlotGenerator) {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
 else {
      message.append(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
    }
  }
  MainUtil.sendMessage(plr,message.toString());
}"
57985,"@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  PlotPlayer plr=(caller instanceof PlotPlayerCaller) ? (PlotPlayer)caller.getSuperCaller() : null;
  String name;
  if (plr == null) {
    name=""String_Node_Str"";
  }
 else {
    name=plr.getName();
  }
  if (!SetupUtils.setupMap.containsKey(name)) {
    final SetupObject object=new SetupObject();
    SetupUtils.setupMap.put(name,object);
    SetupUtils.manager.updateGenerators();
    sendMessage(plr,C.SETUP_INIT);
    displayGenerators(plr);
    return false;
  }
  if (args.length == 1) {
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      SetupUtils.setupMap.remove(name);
      MainUtil.sendMessage(plr,""String_Node_Str"");
      return false;
    }
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      final SetupObject object=SetupUtils.setupMap.get(name);
      if (object.setup_index > 0) {
        object.setup_index--;
        final ConfigurationNode node=object.step[object.setup_index];
        sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",node.getDescription(),node.getType().getType(),node.getDefaultValue() + ""String_Node_Str"");
        return false;
      }
 else       if (object.current > 0) {
        object.current--;
      }
    }
  }
  final SetupObject object=SetupUtils.setupMap.get(name);
  final int index=object.current;
switch (index) {
case 0:
{
      if ((args.length != 1) || !SetupUtils.generators.containsKey(args[0])) {
        final String prefix=""String_Node_Str"";
        MainUtil.sendMessage(plr,""String_Node_Str"" + prefix + StringUtils.join(SetupUtils.generators.keySet(),prefix).replaceAll(""String_Node_Str"",""String_Node_Str""));
        sendMessage(plr,C.SETUP_INIT);
        return false;
      }
      object.setupGenerator=args[0];
      object.current++;
      final String partial=Settings.ENABLE_CLUSTERS ? ""String_Node_Str"" : ""String_Node_Str"";
      MainUtil.sendMessage(plr,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ partial);
      break;
    }
case 1:
{
    List<String> allTypes=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    List<String> allDesc=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    ArrayList<String> types=new ArrayList<>();
    if (SetupUtils.generators.get(object.setupGenerator) instanceof PlotGenerator) {
      types.add(""String_Node_Str"");
    }
    types.add(""String_Node_Str"");
    if (Settings.ENABLE_CLUSTERS) {
      types.add(""String_Node_Str"");
    }
    if ((args.length != 1) || !types.contains(args[0].toLowerCase())) {
      MainUtil.sendMessage(plr,""String_Node_Str"");
      for (      String type : types) {
        int i=allTypes.indexOf(type);
        if (type.equals(""String_Node_Str"")) {
          MainUtil.sendMessage(plr,""String_Node_Str"" + type + ""String_Node_Str""+ allDesc.get(i));
        }
 else {
          MainUtil.sendMessage(plr,""String_Node_Str"" + type + ""String_Node_Str""+ allDesc.get(i));
        }
      }
      return false;
    }
    object.type=allTypes.indexOf(args[0].toLowerCase());
    ChunkGenerator gen=SetupUtils.generators.get(object.setupGenerator);
    if (object.type == 0) {
      object.current++;
      if (object.step == null) {
        object.plotManager=object.setupGenerator;
        object.step=((PlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
        ((PlotGenerator)SetupUtils.generators.get(object.plotManager)).processSetup(object);
      }
      if (object.step.length == 0) {
        object.current=4;
        MainUtil.sendMessage(plr,""String_Node_Str"");
        object.setup_index=0;
        return true;
      }
      final ConfigurationNode step=object.step[object.setup_index];
      sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
    }
 else {
      if (gen instanceof PlotGenerator) {
        object.plotManager=object.setupGenerator;
        object.setupGenerator=null;
        object.step=((PlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
        ((PlotGenerator)SetupUtils.generators.get(object.plotManager)).processSetup(object);
      }
 else {
        object.plotManager=""String_Node_Str"";
        MainUtil.sendMessage(plr,""String_Node_Str"");
        MainUtil.sendMessage(plr,""String_Node_Str"");
        object.step=((PlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
      }
      MainUtil.sendMessage(plr,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    object.current++;
    break;
  }
case 2:
{
  final List<String> terrain=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  if ((args.length != 1) || !terrain.contains(args[0].toLowerCase())) {
    MainUtil.sendMessage(plr,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return false;
  }
  object.terrain=terrain.indexOf(args[0].toLowerCase());
  object.current++;
  if (object.step == null) {
    object.step=((PlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
  }
  final ConfigurationNode step=object.step[object.setup_index];
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  break;
}
case 3:
{
if (object.setup_index == object.step.length) {
  MainUtil.sendMessage(plr,""String_Node_Str"");
  object.setup_index=0;
  object.current++;
  return true;
}
ConfigurationNode step=object.step[object.setup_index];
if (args.length < 1) {
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  return false;
}
final boolean valid=step.isValid(args[0]);
if (valid) {
  sendMessage(plr,C.SETUP_VALID_ARG,step.getConstant(),args[0]);
  step.setValue(args[0]);
  object.setup_index++;
  if (object.setup_index == object.step.length) {
    onCommand(caller,args);
    return false;
  }
  step=object.step[object.setup_index];
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  return false;
}
 else {
  sendMessage(plr,C.SETUP_INVALID_ARG,args[0],step.getConstant());
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  return false;
}
}
case 4:
{
if (args.length != 1) {
MainUtil.sendMessage(plr,""String_Node_Str"");
return false;
}
if (BlockManager.manager.isWorld(args[0])) {
MainUtil.sendMessage(plr,""String_Node_Str"");
}
object.world=args[0];
SetupUtils.setupMap.remove(name);
final String world;
if (object.setupManager == null) {
world=SetupUtils.manager.setupWorld(object);
}
 else {
world=object.setupManager.setupWorld(object);
}
try {
if (plr != null) {
  plr.teleport(BlockManager.manager.getSpawn(world));
}
}
 catch (final Exception e) {
plr.sendMessage(""String_Node_Str"");
e.printStackTrace();
}
sendMessage(plr,C.SETUP_FINISHED,object.world);
SetupUtils.setupMap.remove(name);
}
}
return false;
}","@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  PlotPlayer plr=(caller instanceof PlotPlayerCaller) ? (PlotPlayer)caller.getSuperCaller() : null;
  String name;
  if (plr == null) {
    name=""String_Node_Str"";
  }
 else {
    name=plr.getName();
  }
  if (!SetupUtils.setupMap.containsKey(name)) {
    final SetupObject object=new SetupObject();
    SetupUtils.setupMap.put(name,object);
    SetupUtils.manager.updateGenerators();
    sendMessage(plr,C.SETUP_INIT);
    displayGenerators(plr);
    return false;
  }
  if (args.length == 1) {
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      SetupUtils.setupMap.remove(name);
      MainUtil.sendMessage(plr,""String_Node_Str"");
      return false;
    }
    if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
      final SetupObject object=SetupUtils.setupMap.get(name);
      if (object.setup_index > 0) {
        object.setup_index--;
        final ConfigurationNode node=object.step[object.setup_index];
        sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",node.getDescription(),node.getType().getType(),node.getDefaultValue() + ""String_Node_Str"");
        return false;
      }
 else       if (object.current > 0) {
        object.current--;
      }
    }
  }
  final SetupObject object=SetupUtils.setupMap.get(name);
  final int index=object.current;
switch (index) {
case 0:
{
      if ((args.length != 1) || !SetupUtils.generators.containsKey(args[0])) {
        final String prefix=""String_Node_Str"";
        MainUtil.sendMessage(plr,""String_Node_Str"" + prefix + StringUtils.join(SetupUtils.generators.keySet(),prefix).replaceAll(""String_Node_Str"",""String_Node_Str""));
        sendMessage(plr,C.SETUP_INIT);
        return false;
      }
      object.setupGenerator=args[0];
      object.current++;
      final String partial=Settings.ENABLE_CLUSTERS ? ""String_Node_Str"" : ""String_Node_Str"";
      MainUtil.sendMessage(plr,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ partial);
      break;
    }
case 1:
{
    List<String> allTypes=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    List<String> allDesc=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
    ArrayList<String> types=new ArrayList<>();
    if (SetupUtils.generators.get(object.setupGenerator) instanceof BukkitPlotGenerator) {
      types.add(""String_Node_Str"");
    }
    types.add(""String_Node_Str"");
    if (Settings.ENABLE_CLUSTERS) {
      types.add(""String_Node_Str"");
    }
    if ((args.length != 1) || !types.contains(args[0].toLowerCase())) {
      MainUtil.sendMessage(plr,""String_Node_Str"");
      for (      String type : types) {
        int i=allTypes.indexOf(type);
        if (type.equals(""String_Node_Str"")) {
          MainUtil.sendMessage(plr,""String_Node_Str"" + type + ""String_Node_Str""+ allDesc.get(i));
        }
 else {
          MainUtil.sendMessage(plr,""String_Node_Str"" + type + ""String_Node_Str""+ allDesc.get(i));
        }
      }
      return false;
    }
    object.type=allTypes.indexOf(args[0].toLowerCase());
    ChunkGenerator gen=SetupUtils.generators.get(object.setupGenerator);
    if (object.type == 0) {
      object.current++;
      if (object.step == null) {
        object.plotManager=object.setupGenerator;
        object.step=((BukkitPlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
        ((BukkitPlotGenerator)SetupUtils.generators.get(object.plotManager)).processSetup(object);
      }
      if (object.step.length == 0) {
        object.current=4;
        MainUtil.sendMessage(plr,""String_Node_Str"");
        object.setup_index=0;
        return true;
      }
      final ConfigurationNode step=object.step[object.setup_index];
      sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
    }
 else {
      if (gen instanceof BukkitPlotGenerator) {
        object.plotManager=object.setupGenerator;
        object.setupGenerator=null;
        object.step=((BukkitPlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
        ((BukkitPlotGenerator)SetupUtils.generators.get(object.plotManager)).processSetup(object);
      }
 else {
        object.plotManager=""String_Node_Str"";
        MainUtil.sendMessage(plr,""String_Node_Str"");
        MainUtil.sendMessage(plr,""String_Node_Str"");
        object.step=((BukkitPlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
      }
      MainUtil.sendMessage(plr,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    object.current++;
    break;
  }
case 2:
{
  final List<String> terrain=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  if ((args.length != 1) || !terrain.contains(args[0].toLowerCase())) {
    MainUtil.sendMessage(plr,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return false;
  }
  object.terrain=terrain.indexOf(args[0].toLowerCase());
  object.current++;
  if (object.step == null) {
    object.step=((BukkitPlotGenerator)SetupUtils.generators.get(object.plotManager)).getNewPlotWorld(null).getSettingNodes();
  }
  final ConfigurationNode step=object.step[object.setup_index];
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  break;
}
case 3:
{
if (object.setup_index == object.step.length) {
  MainUtil.sendMessage(plr,""String_Node_Str"");
  object.setup_index=0;
  object.current++;
  return true;
}
ConfigurationNode step=object.step[object.setup_index];
if (args.length < 1) {
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  return false;
}
final boolean valid=step.isValid(args[0]);
if (valid) {
  sendMessage(plr,C.SETUP_VALID_ARG,step.getConstant(),args[0]);
  step.setValue(args[0]);
  object.setup_index++;
  if (object.setup_index == object.step.length) {
    onCommand(caller,args);
    return false;
  }
  step=object.step[object.setup_index];
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  return false;
}
 else {
  sendMessage(plr,C.SETUP_INVALID_ARG,args[0],step.getConstant());
  sendMessage(plr,C.SETUP_STEP,object.setup_index + 1 + ""String_Node_Str"",step.getDescription(),step.getType().getType(),step.getDefaultValue() + ""String_Node_Str"");
  return false;
}
}
case 4:
{
if (args.length != 1) {
MainUtil.sendMessage(plr,""String_Node_Str"");
return false;
}
if (BlockManager.manager.isWorld(args[0])) {
MainUtil.sendMessage(plr,""String_Node_Str"");
}
object.world=args[0];
SetupUtils.setupMap.remove(name);
final String world;
if (object.setupManager == null) {
world=SetupUtils.manager.setupWorld(object);
}
 else {
world=object.setupManager.setupWorld(object);
}
try {
if (plr != null) {
  plr.teleport(BlockManager.manager.getSpawn(world));
}
}
 catch (final Exception e) {
plr.sendMessage(""String_Node_Str"");
e.printStackTrace();
}
sendMessage(plr,C.SETUP_FINISHED,object.world);
SetupUtils.setupMap.remove(name);
}
}
return false;
}"
57986,"final public Collection<Command> getCommands(){
  return this.commands.values();
}","final public ArrayList<Command> getCommands(){
  ArrayList<Command> result=new ArrayList<>(this.commands.values());
  Collections.sort(result,new Comparator<Command>(){
    @Override public int compare(    Command a,    Command b){
      if (a == b) {
        return 0;
      }
      if (a == null) {
        return -1;
      }
      if (b == null) {
        return 1;
      }
      return a.getCommand().compareTo(b.getCommand());
    }
  }
);
  return result;
}"
57987,"public static boolean onCommand(final PlotPlayer player,final String cmd,String... args){
  int help_index=-1;
  String category=null;
  if (args.length == 0) {
    help_index=0;
  }
 else   if (StringMan.isEqualIgnoreCaseToAny(args[0],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    help_index=0;
switch (args.length) {
case 3:
{
        category=args[1];
        if (MathMan.isInteger(args[2])) {
          try {
            help_index=Integer.parseInt(args[2]);
          }
 catch (          NumberFormatException e) {
          }
        }
        break;
      }
case 2:
{
      if (MathMan.isInteger(args[1])) {
        category=null;
        try {
          help_index=Integer.parseInt(args[1]);
        }
 catch (        NumberFormatException e) {
        }
      }
      if (category == null) {
        category=args[1];
      }
      break;
    }
}
}
 else if (args.length == 1 && MathMan.isInteger(args[args.length - 1])) {
try {
  help_index=Integer.parseInt(args[args.length - 1]);
}
 catch (NumberFormatException e) {
}
}
 else if (ConsolePlayer.isConsole(player) && args.length >= 2) {
System.out.print(1);
String[] split=args[0].split(""String_Node_Str"");
String world;
PlotId id;
if (split.length == 2) {
  world=player.getLocation().getWorld();
  id=PlotId.fromString(split[0] + ""String_Node_Str"" + split[1]);
}
 else if (split.length == 3) {
  world=split[0];
  id=PlotId.fromString(split[1] + ""String_Node_Str"" + split[2]);
}
 else {
  id=null;
  world=null;
}
if (id != null && PS.get().isPlotWorld(world)) {
  System.out.print(2 + ""String_Node_Str"" + id+ ""String_Node_Str""+ world);
  Plot plot=MainUtil.getPlot(world,id);
  if (plot != null) {
    System.out.print(3 + ""String_Node_Str"" + plot);
    player.teleport(MainUtil.getPlotCenter(plot));
    args=Arrays.copyOfRange(args,1,args.length);
  }
}
}
if (help_index != -1) {
displayHelp(player,category,help_index,cmd);
return true;
}
StringBuilder builder=new StringBuilder(cmd).append(""String_Node_Str"");
Iterator<String> iterator=Arrays.asList(args).iterator();
while (iterator.hasNext()) {
builder.append(iterator.next());
if (iterator.hasNext()) {
  builder.append(""String_Node_Str"");
}
}
getInstance().handle(player,builder.toString());
return true;
}","public static boolean onCommand(final PlotPlayer player,final String cmd,String... args){
  int help_index=-1;
  String category=null;
  if (args.length == 0) {
    help_index=0;
  }
 else   if (StringMan.isEqualIgnoreCaseToAny(args[0],""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")) {
    help_index=0;
switch (args.length) {
case 3:
{
        category=args[1];
        if (MathMan.isInteger(args[2])) {
          try {
            help_index=Integer.parseInt(args[2]);
          }
 catch (          NumberFormatException e) {
          }
        }
        break;
      }
case 2:
{
      if (MathMan.isInteger(args[1])) {
        category=null;
        try {
          help_index=Integer.parseInt(args[1]);
        }
 catch (        NumberFormatException e) {
        }
      }
      if (category == null) {
        category=args[1];
      }
      break;
    }
}
}
 else if (args.length == 1 && MathMan.isInteger(args[args.length - 1])) {
try {
  help_index=Integer.parseInt(args[args.length - 1]);
}
 catch (NumberFormatException e) {
}
}
 else if (ConsolePlayer.isConsole(player) && args.length >= 2) {
String[] split=args[0].split(""String_Node_Str"");
String world;
PlotId id;
if (split.length == 2) {
  world=player.getLocation().getWorld();
  id=PlotId.fromString(split[0] + ""String_Node_Str"" + split[1]);
}
 else if (split.length == 3) {
  world=split[0];
  id=PlotId.fromString(split[1] + ""String_Node_Str"" + split[2]);
}
 else {
  id=null;
  world=null;
}
if (id != null && PS.get().isPlotWorld(world)) {
  Plot plot=MainUtil.getPlot(world,id);
  if (plot != null) {
    player.teleport(MainUtil.getPlotCenter(plot));
    args=Arrays.copyOfRange(args,1,args.length);
  }
}
}
if (help_index != -1) {
displayHelp(player,category,help_index,cmd);
return true;
}
StringBuilder builder=new StringBuilder(cmd).append(""String_Node_Str"");
Iterator<String> iterator=Arrays.asList(args).iterator();
while (iterator.hasNext()) {
builder.append(iterator.next());
if (iterator.hasNext()) {
  builder.append(""String_Node_Str"");
}
}
getInstance().handle(player,builder.toString());
return true;
}"
57988,"@Override public int handle(PlotPlayer plr,String input){
  String[] parts=input.split(""String_Node_Str"");
  String[] args;
  String label;
  if (parts.length == 1) {
    label=null;
    args=new String[0];
  }
 else {
    label=parts[1];
    args=new String[parts.length - 2];
    System.arraycopy(parts,2,args,0,args.length);
  }
  Command<PlotPlayer> cmd=null;
  cmd=this.commands.get(label);
  if (cmd == null) {
    MainUtil.sendMessage(plr,C.NOT_VALID_SUBCOMMAND);
{
      ArrayList<Command<PlotPlayer>> cmds=getCommands();
      cmd=new StringComparison<Command<PlotPlayer>>(label,cmds).getMatchObject();
      MainUtil.sendMessage(plr,C.DID_YOU_MEAN,cmd.getUsage().replaceAll(""String_Node_Str"",label));
    }
    return CommandHandlingOutput.NOT_FOUND;
  }
  if (!cmd.getRequiredType().allows(plr)) {
    if (ConsolePlayer.isConsole(plr)) {
      MainUtil.sendMessage(plr,C.IS_CONSOLE);
    }
 else {
      MainUtil.sendMessage(plr,C.NOT_CONSOLE);
    }
    return CommandHandlingOutput.CALLER_OF_WRONG_TYPE;
  }
  if (!plr.hasPermission(cmd.getPermission())) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,cmd.getPermission());
    return CommandHandlingOutput.NOT_PERMITTED;
  }
  Argument<?>[] requiredArguments=cmd.getRequiredArguments();
  if (requiredArguments != null && requiredArguments.length > 0) {
    boolean success=true;
    if (args.length < requiredArguments.length) {
      success=false;
    }
 else {
      for (int i=0; i < requiredArguments.length; i++) {
        if (requiredArguments[i].parse(args[i]) == null) {
          success=false;
          break;
        }
      }
    }
    if (!success) {
      C.COMMAND_SYNTAX.send(plr,cmd.getUsage());
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
  try {
    boolean result=cmd.onCommand(plr,args);
    if (!result) {
      String usage=cmd.getUsage();
      if (usage != null && !usage.isEmpty()) {
        MainUtil.sendMessage(plr,usage);
      }
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
 catch (  final Throwable t) {
    t.printStackTrace();
    return CommandHandlingOutput.ERROR;
  }
  return CommandHandlingOutput.SUCCESS;
}","@Override public int handle(PlotPlayer plr,String input){
  String[] parts=input.split(""String_Node_Str"");
  String[] args;
  String label;
  if (parts.length == 1) {
    label=null;
    args=new String[0];
  }
 else {
    label=parts[1];
    args=new String[parts.length - 2];
    System.arraycopy(parts,2,args,0,args.length);
  }
  Command<PlotPlayer> cmd=null;
  cmd=this.commands.get(label);
  if (cmd == null) {
    MainUtil.sendMessage(plr,C.NOT_VALID_SUBCOMMAND);
{
      ArrayList<Command<PlotPlayer>> cmds=getCommands();
      cmd=new StringComparison<Command<PlotPlayer>>(label,cmds).getMatchObject();
      if (cmd == null) {
        MainUtil.sendMessage(plr,C.DID_YOU_MEAN,""String_Node_Str"");
      }
 else {
        MainUtil.sendMessage(plr,C.DID_YOU_MEAN,cmd.getUsage().replaceAll(""String_Node_Str"",label));
      }
    }
    return CommandHandlingOutput.NOT_FOUND;
  }
  if (!cmd.getRequiredType().allows(plr)) {
    if (ConsolePlayer.isConsole(plr)) {
      MainUtil.sendMessage(plr,C.IS_CONSOLE);
    }
 else {
      MainUtil.sendMessage(plr,C.NOT_CONSOLE);
    }
    return CommandHandlingOutput.CALLER_OF_WRONG_TYPE;
  }
  if (!plr.hasPermission(cmd.getPermission())) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,cmd.getPermission());
    return CommandHandlingOutput.NOT_PERMITTED;
  }
  Argument<?>[] requiredArguments=cmd.getRequiredArguments();
  if (requiredArguments != null && requiredArguments.length > 0) {
    boolean success=true;
    if (args.length < requiredArguments.length) {
      success=false;
    }
 else {
      for (int i=0; i < requiredArguments.length; i++) {
        if (requiredArguments[i].parse(args[i]) == null) {
          success=false;
          break;
        }
      }
    }
    if (!success) {
      C.COMMAND_SYNTAX.send(plr,cmd.getUsage());
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
  try {
    boolean result=cmd.onCommand(plr,args);
    if (!result) {
      String usage=cmd.getUsage();
      if (usage != null && !usage.isEmpty()) {
        MainUtil.sendMessage(plr,usage);
      }
      return CommandHandlingOutput.WRONG_USAGE;
    }
  }
 catch (  final Throwable t) {
    t.printStackTrace();
    return CommandHandlingOutput.ERROR;
  }
  return CommandHandlingOutput.SUCCESS;
}"
57989,"public void displayPlots(PlotPlayer player,List<Plot> plots,int pageSize,int page,String world,String[] args,boolean sort){
  if (sort) {
    if (world != null) {
      plots=PS.get().sortPlots(plots,world);
    }
 else {
      plots=PS.get().sortPlots(plots);
    }
  }
  if (page < 0) {
    page=0;
  }
  final int totalPages=(int)Math.ceil(plots.size() / pageSize);
  if (page > totalPages) {
    page=totalPages;
  }
  int max=(page * pageSize) + pageSize;
  if (max > plots.size()) {
    max=plots.size();
  }
  List<Plot> subList=plots.subList(page * pageSize,max);
  String header=C.PLOT_LIST_HEADER_PAGED.s().replaceAll(""String_Node_Str"",page + 1 + ""String_Node_Str"").replaceAll(""String_Node_Str"",totalPages + 1 + ""String_Node_Str"").replaceAll(""String_Node_Str"",plots.size() + ""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  MainUtil.sendMessage(player,header);
  int i=page * pageSize;
  for (  Plot plot : subList) {
    if (plot.getSettings().isMerged()) {
      if (!MainUtil.getBottomPlot(plot).equals(plot)) {
        continue;
      }
    }
    i++;
    if (player != null && Settings.FANCY_CHAT) {
      ChatColor color;
      if (plot.owner == null) {
        color=ChatColor.GOLD;
      }
 else       if (plot.isOwner(player.getUUID())) {
        color=ChatColor.BLUE;
      }
 else       if (plot.isAdded(player.getUUID())) {
        color=ChatColor.DARK_GREEN;
      }
 else       if (plot.isDenied(player.getUUID())) {
        color=ChatColor.RED;
      }
 else {
        color=ChatColor.GOLD;
      }
      FancyMessage trusted=new FancyMessage(ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&',C.PLOT_INFO_TRUSTED.s().replaceAll(""String_Node_Str"",Info.getPlayerList(plot.getTrusted()))))).color(ChatColor.GOLD);
      FancyMessage members=new FancyMessage(ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&',C.PLOT_INFO_MEMBERS.s().replaceAll(""String_Node_Str"",Info.getPlayerList(plot.getMembers()))))).color(ChatColor.GOLD);
      String strFlags=StringUtils.join(plot.getSettings().flags.values(),""String_Node_Str"");
      if (strFlags.length() == 0) {
        strFlags=C.NONE.s();
      }
      FancyMessage flags=new FancyMessage(ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&',C.PLOT_INFO_FLAGS.s().replaceAll(""String_Node_Str"",strFlags)))).color(ChatColor.GOLD);
      FancyMessage message=new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(i + ""String_Node_Str"").command(""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id).tooltip(""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id).color(ChatColor.GOLD).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"" + plot.toString()).formattedTooltip(trusted,members,flags).command(""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id).color(color).then(""String_Node_Str"").color(ChatColor.GRAY);
      String prefix=""String_Node_Str"";
      for (      UUID uuid : plot.getOwners()) {
        String name=UUIDHandler.getName(uuid);
        if (name == null) {
          message=message.then(prefix).color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.GRAY).tooltip(uuid.toString()).suggest(uuid.toString());
        }
 else {
          PlotPlayer pp=UUIDHandler.getPlayer(uuid);
          if (pp != null) {
            message=message.then(prefix).color(ChatColor.DARK_GRAY).then(name).color(ChatColor.GOLD).formattedTooltip(new FancyMessage(""String_Node_Str"").color(ChatColor.DARK_GREEN));
          }
 else {
            message=message.then(prefix).color(ChatColor.DARK_GRAY).then(name).color(ChatColor.GOLD).formattedTooltip(new FancyMessage(""String_Node_Str"").color(ChatColor.RED));
          }
        }
        prefix=""String_Node_Str"";
      }
      message.send(((BukkitPlayer)player).player);
    }
 else {
      String message=C.PLOT_LIST_ITEM.s().replaceAll(""String_Node_Str"",i + 1 + ""String_Node_Str"").replaceAll(""String_Node_Str"",plot.id.toString()).replaceAll(""String_Node_Str"",plot.world).replaceAll(""String_Node_Str"",getName(plot.owner)).replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      MainUtil.sendMessage(player,message);
    }
  }
  if (player != null && Settings.FANCY_CHAT) {
    if (page < totalPages && page > 0) {
      new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page)).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page + 2)).then(C.CLICKABLE.s()).color(ChatColor.GRAY).send(((BukkitPlayer)player).player);
      return;
    }
    if (page == 0 && totalPages != 0) {
      new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page + 2)).then(C.CLICKABLE.s()).color(ChatColor.GRAY).send(((BukkitPlayer)player).player);
      return;
    }
    if (page == totalPages && totalPages != 0) {
      new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page)).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(C.CLICKABLE.s()).color(ChatColor.GRAY).send(((BukkitPlayer)player).player);
      return;
    }
  }
 else {
    String footer=C.PLOT_LIST_FOOTER.s().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",plots.size() + ""String_Node_Str"").replaceAll(""String_Node_Str"",plots.size() == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
    MainUtil.sendMessage(player,footer);
  }
}","public void displayPlots(PlotPlayer player,List<Plot> plots,int pageSize,int page,String world,String[] args,boolean sort){
  if (sort) {
    if (world != null) {
      plots=PS.get().sortPlots(plots,world);
    }
 else {
      plots=PS.get().sortPlots(plots);
    }
  }
  if (page < 0) {
    page=0;
  }
  final int totalPages=(int)Math.ceil(plots.size() / pageSize);
  if (page > totalPages) {
    page=totalPages;
  }
  int max=(page * pageSize) + pageSize;
  if (max > plots.size()) {
    max=plots.size();
  }
  List<Plot> subList=plots.subList(page * pageSize,max);
  String header=C.PLOT_LIST_HEADER_PAGED.s().replaceAll(""String_Node_Str"",page + 1 + ""String_Node_Str"").replaceAll(""String_Node_Str"",totalPages + 1 + ""String_Node_Str"").replaceAll(""String_Node_Str"",plots.size() + ""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  MainUtil.sendMessage(player,header);
  int i=page * pageSize;
  for (  Plot plot : subList) {
    if (plot.getSettings().isMerged()) {
      if (!MainUtil.getBottomPlot(plot).equals(plot)) {
        continue;
      }
    }
    i++;
    if (!ConsolePlayer.isConsole(player) && Settings.FANCY_CHAT) {
      ChatColor color;
      if (plot.owner == null) {
        color=ChatColor.GOLD;
      }
 else       if (plot.isOwner(player.getUUID())) {
        color=ChatColor.BLUE;
      }
 else       if (plot.isAdded(player.getUUID())) {
        color=ChatColor.DARK_GREEN;
      }
 else       if (plot.isDenied(player.getUUID())) {
        color=ChatColor.RED;
      }
 else {
        color=ChatColor.GOLD;
      }
      FancyMessage trusted=new FancyMessage(ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&',C.PLOT_INFO_TRUSTED.s().replaceAll(""String_Node_Str"",Info.getPlayerList(plot.getTrusted()))))).color(ChatColor.GOLD);
      FancyMessage members=new FancyMessage(ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&',C.PLOT_INFO_MEMBERS.s().replaceAll(""String_Node_Str"",Info.getPlayerList(plot.getMembers()))))).color(ChatColor.GOLD);
      String strFlags=StringUtils.join(plot.getSettings().flags.values(),""String_Node_Str"");
      if (strFlags.length() == 0) {
        strFlags=C.NONE.s();
      }
      FancyMessage flags=new FancyMessage(ChatColor.stripColor(ChatColor.translateAlternateColorCodes('&',C.PLOT_INFO_FLAGS.s().replaceAll(""String_Node_Str"",strFlags)))).color(ChatColor.GOLD);
      FancyMessage message=new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(i + ""String_Node_Str"").command(""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id).tooltip(""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id).color(ChatColor.GOLD).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"" + plot.toString()).formattedTooltip(trusted,members,flags).command(""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id).color(color).then(""String_Node_Str"").color(ChatColor.GRAY);
      String prefix=""String_Node_Str"";
      for (      UUID uuid : plot.getOwners()) {
        String name=UUIDHandler.getName(uuid);
        if (name == null) {
          message=message.then(prefix).color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.GRAY).tooltip(uuid.toString()).suggest(uuid.toString());
        }
 else {
          PlotPlayer pp=UUIDHandler.getPlayer(uuid);
          if (pp != null) {
            message=message.then(prefix).color(ChatColor.DARK_GRAY).then(name).color(ChatColor.GOLD).formattedTooltip(new FancyMessage(""String_Node_Str"").color(ChatColor.DARK_GREEN));
          }
 else {
            message=message.then(prefix).color(ChatColor.DARK_GRAY).then(name).color(ChatColor.GOLD).formattedTooltip(new FancyMessage(""String_Node_Str"").color(ChatColor.RED));
          }
        }
        prefix=""String_Node_Str"";
      }
      message.send(((BukkitPlayer)player).player);
    }
 else {
      String message=C.PLOT_LIST_ITEM.s().replaceAll(""String_Node_Str"",i + 1 + ""String_Node_Str"").replaceAll(""String_Node_Str"",plot.id.toString()).replaceAll(""String_Node_Str"",plot.world).replaceAll(""String_Node_Str"",getName(plot.owner)).replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
      MainUtil.sendMessage(player,message);
    }
  }
  if (player != null && Settings.FANCY_CHAT) {
    if (page < totalPages && page > 0) {
      new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page)).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page + 2)).then(C.CLICKABLE.s()).color(ChatColor.GRAY).send(((BukkitPlayer)player).player);
      return;
    }
    if (page == 0 && totalPages != 0) {
      new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page + 2)).then(C.CLICKABLE.s()).color(ChatColor.GRAY).send(((BukkitPlayer)player).player);
      return;
    }
    if (page == totalPages && totalPages != 0) {
      new FancyMessage(""String_Node_Str"").then(""String_Node_Str"").color(ChatColor.GOLD).command(""String_Node_Str"" + args[0] + ""String_Node_Str""+ (page)).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(""String_Node_Str"").color(ChatColor.DARK_GRAY).then(C.CLICKABLE.s()).color(ChatColor.GRAY).send(((BukkitPlayer)player).player);
      return;
    }
  }
 else {
    String footer=C.PLOT_LIST_FOOTER.s().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",plots.size() + ""String_Node_Str"").replaceAll(""String_Node_Str"",plots.size() == 1 ? ""String_Node_Str"" : ""String_Node_Str"");
    MainUtil.sendMessage(player,footer);
  }
}"
57990,"@Override public Location getLocation(){
  System.out.print(loc);
  return loc;
}","@Override public Location getLocation(){
  return loc;
}"
57991,"@Override public boolean onCommand(CommandCaller caller,String[] args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if (!plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  UUID uuid;
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    uuid=DBFunc.everyone;
  }
 else {
    uuid=UUIDHandler.getUUID(args[0]);
  }
  if (uuid == null) {
    if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
    }
 else {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
    }
    return false;
  }
  if (plot.isOwner(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_OWNER);
    return false;
  }
  if (plot.getMembers().contains(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_ADDED);
    return false;
  }
  if (plot.removeTrusted(uuid)) {
    plot.addMember(uuid);
  }
 else {
    if (plot.getMembers().size() + plot.getTrusted().size() >= PS.get().getPlotWorld(plot.world).MAX_PLOT_MEMBERS) {
      MainUtil.sendMessage(plr,C.PLOT_MAX_MEMBERS);
      return false;
    }
    if (plot.getDenied().contains(uuid)) {
      plot.removeDenied(uuid);
    }
    plot.addMember(uuid);
  }
  EventUtil.manager.callMember(plr,plot,uuid,true);
  MainUtil.sendMessage(plr,C.MEMBER_ADDED);
  return true;
}","@Override public boolean onCommand(CommandCaller caller,String[] args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if (!plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  UUID uuid;
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    uuid=DBFunc.everyone;
  }
 else {
    uuid=UUIDHandler.getUUID(args[0],null);
  }
  if (uuid == null) {
    if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
    }
 else {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
    }
    return false;
  }
  if (plot.isOwner(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_OWNER);
    return false;
  }
  if (plot.getMembers().contains(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_ADDED);
    return false;
  }
  if (plot.removeTrusted(uuid)) {
    plot.addMember(uuid);
  }
 else {
    if (plot.getMembers().size() + plot.getTrusted().size() >= PS.get().getPlotWorld(plot.world).MAX_PLOT_MEMBERS) {
      MainUtil.sendMessage(plr,C.PLOT_MAX_MEMBERS);
      return false;
    }
    if (plot.getDenied().contains(uuid)) {
      plot.removeDenied(uuid);
    }
    plot.addMember(uuid);
  }
  EventUtil.manager.callMember(plr,plot,uuid,true);
  MainUtil.sendMessage(plr,C.MEMBER_ADDED);
  return true;
}"
57992,"@Override public boolean onCommand(final CommandCaller caller,final String... args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  if (args.length == 0) {
    MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
    return false;
  }
  final String sub=args[0].toLowerCase();
switch (sub) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
        MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
        return false;
      }
      if (args.length != 1) {
        MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
        return false;
      }
      final HashSet<PlotCluster> clusters=ClusterManager.getClusters(plr.getLocation().getWorld());
      MainUtil.sendMessage(plr,C.CLUSTER_LIST_HEADING,clusters.size() + ""String_Node_Str"");
      for (      final PlotCluster cluster : clusters) {
        final String name=""String_Node_Str"" + cluster.getName() + ""String_Node_Str""+ cluster.toString();
        if (UUIDHandler.getUUID(plr).equals(cluster.owner)) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.helpers.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.invited.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,cluster.toString());
        }
      }
      return true;
    }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
    if (args.length != 4) {
      final PlotId id=ClusterManager.estimatePlotId(plr.getLocation());
      MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
      MainUtil.sendMessage(plr,C.CLUSTER_CURRENT_PLOTID,""String_Node_Str"" + id);
      return false;
    }
    PlotId pos1=MainUtil.parseId(args[2]);
    PlotId pos2=MainUtil.parseId(args[3]);
    if ((pos1 == null) || (pos2 == null)) {
      MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
      return false;
    }
    final String name=args[1];
    for (    final PlotCluster cluster : ClusterManager.getClusters(plr.getLocation().getWorld())) {
      if (name.equals(cluster.getName())) {
        MainUtil.sendMessage(plr,C.ALIAS_IS_TAKEN);
        return false;
      }
    }
    final PlotClusterId id=new PlotClusterId(pos1,pos2);
    final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
    if ((intersects.size() > 0)) {
      MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,intersects.size() + ""String_Node_Str"");
      return false;
    }
    if ((pos2.x < pos1.x) || (pos2.y < pos1.y)) {
      pos1=new PlotId(Math.min(pos1.x,pos2.x),Math.min(pos1.y,pos2.y));
      pos2=new PlotId(Math.max(pos1.x,pos2.x),Math.max(pos1.y,pos2.y));
    }
    final String world=plr.getLocation().getWorld();
    final PlotCluster cluster=new PlotCluster(world,pos1,pos2,UUIDHandler.getUUID(plr));
    cluster.settings.setAlias(name);
    DBFunc.createCluster(world,cluster);
    if (!ClusterManager.clusters.containsKey(world)) {
      ClusterManager.clusters.put(world,new HashSet<PlotCluster>());
    }
    ClusterManager.clusters.get(world).add(cluster);
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster current=ClusterManager.getCluster(plot);
      if (cluster.equals(current) && !cluster.isAdded(plot.owner)) {
        cluster.invited.add(plot.owner);
        DBFunc.setInvited(world,cluster,plot.owner);
      }
    }
    PlotWorld plotworld=PS.get().getPlotWorld(world);
    if (plotworld == null) {
      PS.get().config.createSection(""String_Node_Str"" + world);
      PS.get().loadWorld(world,null);
    }
 else {
      final String gen_string=PS.get().config.getString(""String_Node_Str"" + world + ""String_Node_Str""+ ""String_Node_Str"");
      BukkitPlotGenerator generator;
      if (gen_string == null) {
        generator=new HybridGen(world);
      }
 else {
        ChunkGenerator chunkgen=(ChunkGenerator)PS.get().IMP.getGenerator(world,gen_string).generator;
        if (chunkgen instanceof BukkitPlotGenerator) {
          generator=(BukkitPlotGenerator)chunkgen;
        }
 else {
          MainUtil.sendMessage(plr,C.SETUP_INVALID_GENERATOR,StringMan.join(SetupUtils.generators.keySet(),""String_Node_Str""));
          return false;
        }
      }
      new AugmentedPopulator(world,generator,cluster,plotworld.TERRAIN == 2,plotworld.TERRAIN != 2);
    }
    MainUtil.sendMessage(plr,C.CLUSTER_ADDED);
    return true;
  }
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
  if ((args.length != 1) && (args.length != 2)) {
    MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
    return false;
  }
  PlotCluster cluster;
  if (args.length == 2) {
    cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
      return false;
    }
  }
 else {
    cluster=ClusterManager.getCluster(plr.getLocation());
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
      return false;
    }
  }
  if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
  }
  final PlotWorld plotworld=PS.get().getPlotWorld(plr.getLocation().getWorld());
  if (plotworld.TYPE == 2) {
    final ArrayList<Plot> toRemove=new ArrayList<>();
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster other=ClusterManager.getCluster(plot);
      if (cluster.equals(other)) {
        toRemove.add(plot);
      }
    }
    for (    final Plot plot : toRemove) {
      plot.unclaim();
    }
  }
  DBFunc.delete(cluster);
  if (plotworld.TYPE == 2) {
    AugmentedPopulator.removePopulator(plr.getLocation().getWorld(),cluster);
  }
  ClusterManager.last=null;
  ClusterManager.clusters.get(cluster.world).remove(cluster);
  ClusterManager.regenCluster(cluster);
  MainUtil.sendMessage(plr,C.CLUSTER_DELETED);
  return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
if (args.length != 3) {
  MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
  return false;
}
final PlotId pos1=MainUtil.parseId(args[1]);
final PlotId pos2=MainUtil.parseId(args[2]);
if ((pos1 == null) || (pos2 == null)) {
  MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
  return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
}
final PlotClusterId id=new PlotClusterId(pos1,pos2);
final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
if (intersects.size() > 1) {
  MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,(intersects.size() - 1) + ""String_Node_Str"");
  return false;
}
DBFunc.resizeCluster(cluster,id);
MainUtil.sendMessage(plr,C.CLUSTER_RESIZED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
  MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
  return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
}
if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
}
ClusterManager.regenCluster(cluster);
MainUtil.sendMessage(plr,C.CLUSTER_REGENERATED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (!cluster.isAdded(uuid)) {
cluster.invited.add(uuid);
final String world=plr.getLocation().getWorld();
DBFunc.setInvited(world,cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_INVITED,cluster.getName());
}
}
MainUtil.sendMessage(plr,C.CLUSTER_ADDED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[1]);
return false;
}
if (uuid.equals(UUIDHandler.getUUID(plr)) || uuid.equals(cluster.owner) || !cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CANNOT_KICK_PLAYER,cluster.getName());
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_REMOVED,cluster.getName());
}
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
MainUtil.sendMessage(plr,C.CLUSTER_KICKED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CLUSTER_NOT_ADDED);
return false;
}
if (uuid.equals(cluster.owner)) {
MainUtil.sendMessage(plr,C.CLUSTER_CANNOT_LEAVE);
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
MainUtil.sendMessage(plr,C.CLUSTER_REMOVED,cluster.getName());
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 3) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
final UUID uuid=UUIDHandler.getUUID(args[2]);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.add(uuid);
DBFunc.setHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_ADDED_HELPER);
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_REMOVED_HELPER);
}
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
plr.teleport(ClusterManager.getHome(cluster));
return MainUtil.sendMessage(plr,C.CLUSTER_TELEPORTING);
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final String id=cluster.toString();
String owner=UUIDHandler.getName(cluster.owner);
if (owner == null) {
owner=""String_Node_Str"";
}
final String name=cluster.getName();
final String size=((cluster.getP2().x - cluster.getP1().x) + 1) + ""String_Node_Str"" + ((cluster.getP2().y - cluster.getP1().y) + 1);
final String rights=cluster.isAdded(UUIDHandler.getUUID(plr)) + ""String_Node_Str"";
String message=C.CLUSTER_INFO.s();
message=message.replaceAll(""String_Node_Str"",id);
message=message.replaceAll(""String_Node_Str"",owner);
message=message.replaceAll(""String_Node_Str"",name);
message=message.replaceAll(""String_Node_Str"",size);
message=message.replaceAll(""String_Node_Str"",rights);
MainUtil.sendMessage(plr,message);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final Location base=ClusterManager.getClusterBottom(cluster);
final Location relative=plr.getLocation().subtract(base.getX(),0,base.getZ());
final BlockLoc blockloc=new BlockLoc(relative.getX(),relative.getY(),relative.getZ());
cluster.settings.setPosition(blockloc);
DBFunc.setPosition(cluster,relative.getX() + ""String_Node_Str"" + relative.getY()+ ""String_Node_Str""+ relative.getZ());
return MainUtil.sendMessage(plr,C.POSITION_SET);
}
}
MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
return false;
}","@Override public boolean onCommand(final CommandCaller caller,final String... args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  if (args.length == 0) {
    MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
    return false;
  }
  final String sub=args[0].toLowerCase();
switch (sub) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
      if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
        MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
        return false;
      }
      if (args.length != 1) {
        MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
        return false;
      }
      final HashSet<PlotCluster> clusters=ClusterManager.getClusters(plr.getLocation().getWorld());
      MainUtil.sendMessage(plr,C.CLUSTER_LIST_HEADING,clusters.size() + ""String_Node_Str"");
      for (      final PlotCluster cluster : clusters) {
        final String name=""String_Node_Str"" + cluster.getName() + ""String_Node_Str""+ cluster.toString();
        if (UUIDHandler.getUUID(plr).equals(cluster.owner)) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.helpers.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else         if (cluster.invited.contains(UUIDHandler.getUUID(plr))) {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,""String_Node_Str"" + name);
        }
 else {
          MainUtil.sendMessage(plr,C.CLUSTER_LIST_ELEMENT,cluster.toString());
        }
      }
      return true;
    }
case ""String_Node_Str"":
case ""String_Node_Str"":
{
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
    if (args.length != 4) {
      final PlotId id=ClusterManager.estimatePlotId(plr.getLocation());
      MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
      MainUtil.sendMessage(plr,C.CLUSTER_CURRENT_PLOTID,""String_Node_Str"" + id);
      return false;
    }
    PlotId pos1=MainUtil.parseId(args[2]);
    PlotId pos2=MainUtil.parseId(args[3]);
    if ((pos1 == null) || (pos2 == null)) {
      MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
      return false;
    }
    final String name=args[1];
    for (    final PlotCluster cluster : ClusterManager.getClusters(plr.getLocation().getWorld())) {
      if (name.equals(cluster.getName())) {
        MainUtil.sendMessage(plr,C.ALIAS_IS_TAKEN);
        return false;
      }
    }
    final PlotClusterId id=new PlotClusterId(pos1,pos2);
    final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
    if ((intersects.size() > 0)) {
      MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,intersects.size() + ""String_Node_Str"");
      return false;
    }
    if ((pos2.x < pos1.x) || (pos2.y < pos1.y)) {
      pos1=new PlotId(Math.min(pos1.x,pos2.x),Math.min(pos1.y,pos2.y));
      pos2=new PlotId(Math.max(pos1.x,pos2.x),Math.max(pos1.y,pos2.y));
    }
    final String world=plr.getLocation().getWorld();
    final PlotCluster cluster=new PlotCluster(world,pos1,pos2,UUIDHandler.getUUID(plr));
    cluster.settings.setAlias(name);
    DBFunc.createCluster(world,cluster);
    if (!ClusterManager.clusters.containsKey(world)) {
      ClusterManager.clusters.put(world,new HashSet<PlotCluster>());
    }
    ClusterManager.clusters.get(world).add(cluster);
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster current=ClusterManager.getCluster(plot);
      if (cluster.equals(current) && !cluster.isAdded(plot.owner)) {
        cluster.invited.add(plot.owner);
        DBFunc.setInvited(world,cluster,plot.owner);
      }
    }
    PlotWorld plotworld=PS.get().getPlotWorld(world);
    if (plotworld == null) {
      PS.get().config.createSection(""String_Node_Str"" + world);
      PS.get().loadWorld(world,null);
    }
 else {
      final String gen_string=PS.get().config.getString(""String_Node_Str"" + world + ""String_Node_Str""+ ""String_Node_Str"");
      BukkitPlotGenerator generator;
      if (gen_string == null) {
        generator=new HybridGen(world);
      }
 else {
        ChunkGenerator chunkgen=(ChunkGenerator)PS.get().IMP.getGenerator(world,gen_string).generator;
        if (chunkgen instanceof BukkitPlotGenerator) {
          generator=(BukkitPlotGenerator)chunkgen;
        }
 else {
          MainUtil.sendMessage(plr,C.SETUP_INVALID_GENERATOR,StringMan.join(SetupUtils.generators.keySet(),""String_Node_Str""));
          return false;
        }
      }
      new AugmentedPopulator(world,generator,cluster,plotworld.TERRAIN == 2,plotworld.TERRAIN != 2);
    }
    MainUtil.sendMessage(plr,C.CLUSTER_ADDED);
    return true;
  }
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
  if ((args.length != 1) && (args.length != 2)) {
    MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
    return false;
  }
  PlotCluster cluster;
  if (args.length == 2) {
    cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
      return false;
    }
  }
 else {
    cluster=ClusterManager.getCluster(plr.getLocation());
    if (cluster == null) {
      MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
      return false;
    }
  }
  if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
    if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
      MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
      return false;
    }
  }
  final PlotWorld plotworld=PS.get().getPlotWorld(plr.getLocation().getWorld());
  if (plotworld.TYPE == 2) {
    final ArrayList<Plot> toRemove=new ArrayList<>();
    for (    final Plot plot : PS.get().getPlots(plr.getLocation().getWorld()).values()) {
      final PlotCluster other=ClusterManager.getCluster(plot);
      if (cluster.equals(other)) {
        toRemove.add(plot);
      }
    }
    for (    final Plot plot : toRemove) {
      plot.unclaim();
    }
  }
  DBFunc.delete(cluster);
  if (plotworld.TYPE == 2) {
    AugmentedPopulator.removePopulator(plr.getLocation().getWorld(),cluster);
  }
  ClusterManager.last=null;
  ClusterManager.clusters.get(cluster.world).remove(cluster);
  ClusterManager.regenCluster(cluster);
  MainUtil.sendMessage(plr,C.CLUSTER_DELETED);
  return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
if (args.length != 3) {
  MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
  return false;
}
final PlotId pos1=MainUtil.parseId(args[1]);
final PlotId pos2=MainUtil.parseId(args[2]);
if ((pos1 == null) || (pos2 == null)) {
  MainUtil.sendMessage(plr,C.NOT_VALID_PLOT_ID);
  return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
  if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
    return false;
  }
}
final PlotClusterId id=new PlotClusterId(pos1,pos2);
final HashSet<PlotCluster> intersects=ClusterManager.getIntersects(plr.getLocation().getWorld(),id);
if (intersects.size() > 1) {
  MainUtil.sendMessage(plr,C.CLUSTER_INTERSECTION,(intersects.size() - 1) + ""String_Node_Str"");
  return false;
}
DBFunc.resizeCluster(cluster,id);
MainUtil.sendMessage(plr,C.CLUSTER_RESIZED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
  MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
  return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
  MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
  return false;
}
}
if (!cluster.owner.equals(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
  MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
  return false;
}
}
ClusterManager.regenCluster(cluster);
MainUtil.sendMessage(plr,C.CLUSTER_REGENERATED);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1],null);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (!cluster.isAdded(uuid)) {
cluster.invited.add(uuid);
final String world=plr.getLocation().getWorld();
DBFunc.setInvited(world,cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_INVITED,cluster.getName());
}
}
MainUtil.sendMessage(plr,C.CLUSTER_ADDED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(args[1],null);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[1]);
return false;
}
if (uuid.equals(UUIDHandler.getUUID(plr)) || uuid.equals(cluster.owner) || !cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CANNOT_KICK_PLAYER,cluster.getName());
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
final PlotPlayer player=UUIDHandler.getPlayer(uuid);
if (player != null) {
MainUtil.sendMessage(player,C.CLUSTER_REMOVED,cluster.getName());
}
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
MainUtil.sendMessage(plr,C.CLUSTER_KICKED_USER);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
MainUtil.sendMessage(plr,C.CLUSTER_NOT_ADDED);
return false;
}
if (uuid.equals(cluster.owner)) {
MainUtil.sendMessage(plr,C.CLUSTER_CANNOT_LEAVE);
return false;
}
if (cluster.helpers.contains(uuid)) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
}
cluster.invited.remove(uuid);
DBFunc.removeInvited(cluster,uuid);
MainUtil.sendMessage(plr,C.CLUSTER_REMOVED,cluster.getName());
for (final Plot plot : new ArrayList<>(PS.get().getPlots(plr.getLocation().getWorld(),uuid))) {
final PlotCluster current=ClusterManager.getCluster(plot);
if ((current != null) && current.equals(cluster)) {
final String world=plr.getLocation().getWorld();
plot.unclaim();
}
}
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 3) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
final UUID uuid=UUIDHandler.getUUID(args[2],null);
if (uuid == null) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[2]);
return false;
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.add(uuid);
DBFunc.setHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_ADDED_HELPER);
}
if (args[1].toLowerCase().equals(""String_Node_Str"")) {
cluster.helpers.remove(uuid);
DBFunc.removeHelper(cluster,uuid);
return MainUtil.sendMessage(plr,C.CLUSTER_REMOVED_HELPER);
}
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if (args.length != 2) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
final UUID uuid=UUIDHandler.getUUID(plr);
if (!cluster.isAdded(uuid)) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
plr.teleport(ClusterManager.getHome(cluster));
return MainUtil.sendMessage(plr,C.CLUSTER_TELEPORTING);
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
PlotCluster cluster;
if (args.length == 2) {
cluster=ClusterManager.getCluster(plr.getLocation().getWorld(),args[1]);
if (cluster == null) {
MainUtil.sendMessage(plr,C.INVALID_CLUSTER,args[1]);
return false;
}
}
 else {
cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
}
final String id=cluster.toString();
String owner=UUIDHandler.getName(cluster.owner);
if (owner == null) {
owner=""String_Node_Str"";
}
final String name=cluster.getName();
final String size=((cluster.getP2().x - cluster.getP1().x) + 1) + ""String_Node_Str"" + ((cluster.getP2().y - cluster.getP1().y) + 1);
final String rights=cluster.isAdded(UUIDHandler.getUUID(plr)) + ""String_Node_Str"";
String message=C.CLUSTER_INFO.s();
message=message.replaceAll(""String_Node_Str"",id);
message=message.replaceAll(""String_Node_Str"",owner);
message=message.replaceAll(""String_Node_Str"",name);
message=message.replaceAll(""String_Node_Str"",size);
message=message.replaceAll(""String_Node_Str"",rights);
MainUtil.sendMessage(plr,message);
return true;
}
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
{
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
if ((args.length != 1) && (args.length != 2)) {
MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
return false;
}
final PlotCluster cluster=ClusterManager.getCluster(plr.getLocation());
if (cluster == null) {
MainUtil.sendMessage(plr,C.NOT_IN_CLUSTER);
return false;
}
if (!cluster.hasHelperRights(UUIDHandler.getUUID(plr))) {
if (!Permissions.hasPermission(plr,""String_Node_Str"")) {
MainUtil.sendMessage(plr,C.NO_PERMISSION,""String_Node_Str"");
return false;
}
}
final Location base=ClusterManager.getClusterBottom(cluster);
final Location relative=plr.getLocation().subtract(base.getX(),0,base.getZ());
final BlockLoc blockloc=new BlockLoc(relative.getX(),relative.getY(),relative.getZ());
cluster.settings.setPosition(blockloc);
DBFunc.setPosition(cluster,relative.getX() + ""String_Node_Str"" + relative.getY()+ ""String_Node_Str""+ relative.getZ());
return MainUtil.sendMessage(plr,C.POSITION_SET);
}
}
MainUtil.sendMessage(plr,C.CLUSTER_AVAILABLE_ARGS);
return false;
}"
57993,"@Override public boolean onCommand(CommandCaller caller,String[] args){
  if (args.length < 3) {
    return !MainUtil.sendMessage(null,""String_Node_Str"");
  }
  final String world=args[0];
  if (!BlockManager.manager.isWorld(world) || !PS.get().isPlotWorld(world)) {
    return !MainUtil.sendMessage(null,""String_Node_Str"");
  }
  PlotId min, max;
  try {
    final String[] split1=args[1].split(""String_Node_Str"");
    final String[] split2=args[2].split(""String_Node_Str"");
    min=new PlotId(Integer.parseInt(split1[0]),Integer.parseInt(split1[1]));
    max=new PlotId(Integer.parseInt(split2[0]),Integer.parseInt(split2[1]));
  }
 catch (  final Exception e) {
    return !MainUtil.sendMessage(null,""String_Node_Str"");
  }
  MainUtil.sendMessage(null,""String_Node_Str"");
  MainUtil.sendMessage(null,""String_Node_Str"");
  final PlotManager manager=PS.get().getPlotManager(world);
  final PlotWorld plotworld=PS.get().getPlotWorld(world);
  final ArrayList<Plot> plots=new ArrayList<>();
  for (  final PlotId id : MainUtil.getPlotSelectionIds(min,max)) {
    final Plot plot=MainUtil.getPlot(world,id);
    final boolean contains=PS.get().getPlots(world).containsKey(plot.id);
    if (contains) {
      MainUtil.sendMessage(null,""String_Node_Str"" + plot.id);
      continue;
    }
    final Location loc=manager.getSignLoc(plotworld,plot);
    final ChunkLoc chunk=new ChunkLoc(loc.getX() >> 4,loc.getZ() >> 4);
    final boolean result=ChunkManager.manager.loadChunk(world,chunk);
    if (!result) {
      continue;
    }
    final String[] lines=BlockManager.manager.getSign(loc);
    if (lines != null) {
      String line=lines[2];
      if ((line != null) && (line.length() > 2)) {
        line=line.substring(2);
        final BiMap<StringWrapper,UUID> map=UUIDHandler.getUuidMap();
        UUID uuid=(map.get(new StringWrapper(line)));
        if (uuid == null) {
          for (          final StringWrapper string : map.keySet()) {
            if (string.value.toLowerCase().startsWith(line.toLowerCase())) {
              uuid=map.get(string);
              break;
            }
          }
        }
        if (uuid == null) {
          uuid=UUIDHandler.getUUID(line);
        }
        if (uuid != null) {
          MainUtil.sendMessage(null,""String_Node_Str"" + plot.id + ""String_Node_Str""+ line);
          plot.owner=uuid;
          plots.add(plot);
        }
 else {
          MainUtil.sendMessage(null,""String_Node_Str"" + plot.id + ""String_Node_Str""+ line);
        }
      }
    }
  }
  if (plots.size() > 0) {
    MainUtil.sendMessage(null,""String_Node_Str"" + plots.size() + ""String_Node_Str"");
    DBFunc.createPlotsAndData(plots,new Runnable(){
      @Override public void run(){
        MainUtil.sendMessage(null,""String_Node_Str"");
      }
    }
);
    for (    final Plot plot : plots) {
      PS.get().updatePlot(plot);
    }
    MainUtil.sendMessage(null,""String_Node_Str"");
  }
 else {
    MainUtil.sendMessage(null,""String_Node_Str"");
  }
  return true;
}","@Override public boolean onCommand(CommandCaller caller,String[] args){
  if (args.length < 3) {
    return !MainUtil.sendMessage(null,""String_Node_Str"");
  }
  final String world=args[0];
  if (!BlockManager.manager.isWorld(world) || !PS.get().isPlotWorld(world)) {
    return !MainUtil.sendMessage(null,""String_Node_Str"");
  }
  PlotId min, max;
  try {
    final String[] split1=args[1].split(""String_Node_Str"");
    final String[] split2=args[2].split(""String_Node_Str"");
    min=new PlotId(Integer.parseInt(split1[0]),Integer.parseInt(split1[1]));
    max=new PlotId(Integer.parseInt(split2[0]),Integer.parseInt(split2[1]));
  }
 catch (  final Exception e) {
    return !MainUtil.sendMessage(null,""String_Node_Str"");
  }
  MainUtil.sendMessage(null,""String_Node_Str"");
  MainUtil.sendMessage(null,""String_Node_Str"");
  final PlotManager manager=PS.get().getPlotManager(world);
  final PlotWorld plotworld=PS.get().getPlotWorld(world);
  final ArrayList<Plot> plots=new ArrayList<>();
  for (  final PlotId id : MainUtil.getPlotSelectionIds(min,max)) {
    final Plot plot=MainUtil.getPlot(world,id);
    final boolean contains=PS.get().getPlots(world).containsKey(plot.id);
    if (contains) {
      MainUtil.sendMessage(null,""String_Node_Str"" + plot.id);
      continue;
    }
    final Location loc=manager.getSignLoc(plotworld,plot);
    final ChunkLoc chunk=new ChunkLoc(loc.getX() >> 4,loc.getZ() >> 4);
    final boolean result=ChunkManager.manager.loadChunk(world,chunk);
    if (!result) {
      continue;
    }
    final String[] lines=BlockManager.manager.getSign(loc);
    if (lines != null) {
      String line=lines[2];
      if ((line != null) && (line.length() > 2)) {
        line=line.substring(2);
        final BiMap<StringWrapper,UUID> map=UUIDHandler.getUuidMap();
        UUID uuid=(map.get(new StringWrapper(line)));
        if (uuid == null) {
          for (          final StringWrapper string : map.keySet()) {
            if (string.value.toLowerCase().startsWith(line.toLowerCase())) {
              uuid=map.get(string);
              break;
            }
          }
        }
        if (uuid == null) {
          uuid=UUIDHandler.getUUID(line,null);
        }
        if (uuid != null) {
          MainUtil.sendMessage(null,""String_Node_Str"" + plot.id + ""String_Node_Str""+ line);
          plot.owner=uuid;
          plots.add(plot);
        }
 else {
          MainUtil.sendMessage(null,""String_Node_Str"" + plot.id + ""String_Node_Str""+ line);
        }
      }
    }
  }
  if (plots.size() > 0) {
    MainUtil.sendMessage(null,""String_Node_Str"" + plots.size() + ""String_Node_Str"");
    DBFunc.createPlotsAndData(plots,new Runnable(){
      @Override public void run(){
        MainUtil.sendMessage(null,""String_Node_Str"");
      }
    }
);
    for (    final Plot plot : plots) {
      PS.get().updatePlot(plot);
    }
    MainUtil.sendMessage(null,""String_Node_Str"");
  }
 else {
    MainUtil.sendMessage(null,""String_Node_Str"");
  }
  return true;
}"
57994,"@Override public boolean onCommand(CommandCaller caller,String[] args){
  final PlotPlayer player=caller instanceof PlotPlayerCaller ? (PlotPlayer)caller.getSuperCaller() : null;
  final List<String> allowed_params=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (args.length > 0) {
    final String arg=args[0].toLowerCase();
switch (arg) {
case ""String_Node_Str"":
{
        if (player == null) {
          MainUtil.sendMessage(player,C.IS_CONSOLE);
          return false;
        }
        Plot plot=MainUtil.getPlot(player.getLocation());
        if (plot == null) {
          MainUtil.sendMessage(player,C.NOT_IN_PLOT);
          return false;
        }
        PlotAnalysis analysis=plot.getComplexity();
        if (analysis != null) {
          int complexity=analysis.getComplexity();
          MainUtil.sendMessage(player,""String_Node_Str"" + analysis.changes);
          MainUtil.sendMessage(player,""String_Node_Str"" + complexity);
          return true;
        }
        MainUtil.sendMessage(player,""String_Node_Str"");
        HybridUtils.manager.analyzePlot(plot,new RunnableVal<PlotAnalysis>(){
          @Override public void run(){
            MainUtil.sendMessage(player,""String_Node_Str"");
          }
        }
);
        return true;
      }
case ""String_Node_Str"":
{
      if (args.length != 2) {
        MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"");
        MainUtil.sendMessage(player,""String_Node_Str"");
        return false;
      }
      double threshold;
      try {
        threshold=Integer.parseInt(args[1]) / 100d;
      }
 catch (      NumberFormatException e) {
        MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
        MainUtil.sendMessage(player,""String_Node_Str"");
        return false;
      }
      PlotAnalysis.calcOptimalModifiers(new Runnable(){
        @Override public void run(){
          PS.log(""String_Node_Str"");
        }
      }
,threshold);
      return true;
    }
case ""String_Node_Str"":
{
    if (ExpireManager.task != -1) {
      Bukkit.getScheduler().cancelTask(ExpireManager.task);
    }
 else {
      return MainUtil.sendMessage(player,""String_Node_Str"");
    }
    ExpireManager.task=-1;
    return MainUtil.sendMessage(player,""String_Node_Str"");
  }
case ""String_Node_Str"":
{
  if (args.length != 2) {
    MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"");
    return false;
  }
  String flag=args[1];
  for (  Plot plot : PS.get().getPlots()) {
    if (FlagManager.getPlotFlag(plot,flag) != null) {
      FlagManager.removePlotFlag(plot,flag);
    }
  }
  return MainUtil.sendMessage(player,""String_Node_Str"" + flag);
}
case ""String_Node_Str"":
{
if (args.length != 2) {
  PS.log(""String_Node_Str"");
  return false;
}
boolean result;
if (!PS.get().isPlotWorld(args[1])) {
  MainUtil.sendMessage(player,C.NOT_VALID_PLOT_WORLD,args[1]);
  return false;
}
if (BukkitHybridUtils.regions != null) {
  result=((BukkitHybridUtils)(HybridUtils.manager)).scheduleRoadUpdate(args[1],BukkitHybridUtils.regions,0);
}
 else {
  result=HybridUtils.manager.scheduleRoadUpdate(args[1],0);
}
if (!result) {
  PS.log(""String_Node_Str"");
  return false;
}
return true;
}
case ""String_Node_Str"":
{
if (((BukkitHybridUtils)(HybridUtils.manager)).task == 0) {
PS.log(""String_Node_Str"");
return false;
}
((BukkitHybridUtils)(HybridUtils.manager)).task=0;
Bukkit.getScheduler().cancelTask(((BukkitHybridUtils)(HybridUtils.manager)).task);
PS.log(""String_Node_Str"");
while (BukkitHybridUtils.chunks.size() > 0) {
ChunkLoc chunk=BukkitHybridUtils.chunks.get(0);
BukkitHybridUtils.chunks.remove(0);
HybridUtils.manager.regenerateRoad(BukkitHybridUtils.world,chunk,0);
ChunkManager.manager.unloadChunk(BukkitHybridUtils.world,chunk);
}
PS.log(""String_Node_Str"");
return true;
}
case ""String_Node_Str"":
{
if (ExpireManager.task == -1) {
ExpireManager.runTask();
}
 else {
return MainUtil.sendMessage(player,""String_Node_Str"");
}
return MainUtil.sendMessage(player,""String_Node_Str"");
}
case ""String_Node_Str"":
{
if (args.length > 1) {
final String world=args[1];
if (!BlockManager.manager.isWorld(world)) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
MainUtil.sendMessage(player,""String_Node_Str"");
ExpireManager.updateExpired(args[1]);
return true;
}
return MainUtil.sendMessage(player,""String_Node_Str"");
}
case ""String_Node_Str"":
{
if (args.length > 1) {
final String world=args[1];
if (!BlockManager.manager.isWorld(world)) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
if (!ExpireManager.expiredPlots.containsKey(args[1])) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
MainUtil.sendMessage(player,""String_Node_Str"" + ExpireManager.expiredPlots.get(args[1]).size() + ""String_Node_Str"");
for (final Plot plot : ExpireManager.expiredPlots.get(args[1])) {
MainUtil.sendMessage(player,""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id.x+ ""String_Node_Str""+ plot.id.y+ ""String_Node_Str""+ UUIDHandler.getName(plot.owner)+ ""String_Node_Str""+ ExpireManager.dates.get(plot.owner));
}
return true;
}
return MainUtil.sendMessage(player,""String_Node_Str"");
}
case ""String_Node_Str"":
{
if (args.length != 2) {
return MainUtil.sendMessage(player,""String_Node_Str"");
}
final UUID uuid=UUIDHandler.getUUID(args[1]);
if (uuid == null) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
final OfflinePlotPlayer op=UUIDHandler.getUUIDWrapper().getOfflinePlayer(uuid);
if ((op == null) || (op.getLastPlayed() == 0)) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
final Timestamp stamp=new Timestamp(op.getLastPlayed());
final Date date=new Date(stamp.getTime());
MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
MainUtil.sendMessage(player,""String_Node_Str"" + uuid);
MainUtil.sendMessage(player,""String_Node_Str"" + date.toGMTString());
MainUtil.sendMessage(player,""String_Node_Str"" + date.toGMTString());
MainUtil.sendMessage(player,""String_Node_Str"" + date.toLocaleString());
return true;
}
case ""String_Node_Str"":
{
if (args.length != 2) {
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
return MainUtil.sendMessage(player,""String_Node_Str"");
}
final String world=args[1];
if (!BlockManager.manager.isWorld(world) || !PS.get().isPlotWorld(args[1])) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
final ArrayList<ChunkLoc> empty=new ArrayList<>();
final boolean result=Trim.getTrimRegions(empty,world,new Runnable(){
@Override public void run(){
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"" + empty.size());
Trim.sendMessage(""String_Node_Str"" + (empty.size() * 1024) + ""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
final File file=new File(PS.get().IMP.getDirectory() + File.separator + ""String_Node_Str"");
PrintWriter writer;
try {
writer=new PrintWriter(file);
for (final ChunkLoc loc : empty) {
writer.println(world + ""String_Node_Str"" + loc.x+ ""String_Node_Str""+ loc.z+ ""String_Node_Str"");
}
writer.close();
Trim.sendMessage(""String_Node_Str"");
}
 catch (final FileNotFoundException e) {
e.printStackTrace();
Trim.sendMessage(""String_Node_Str"");
}
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
}
}
);
if (!result) {
MainUtil.sendMessage(player,""String_Node_Str"");
}
return result;
}
}
}
MainUtil.sendMessage(player,""String_Node_Str"" + StringUtils.join(allowed_params,""String_Node_Str"") + ""String_Node_Str"");
return true;
}","@Override public boolean onCommand(CommandCaller caller,String[] args){
  final PlotPlayer player=caller instanceof PlotPlayerCaller ? (PlotPlayer)caller.getSuperCaller() : null;
  final List<String> allowed_params=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (args.length > 0) {
    final String arg=args[0].toLowerCase();
switch (arg) {
case ""String_Node_Str"":
{
        if (player == null) {
          MainUtil.sendMessage(player,C.IS_CONSOLE);
          return false;
        }
        Plot plot=MainUtil.getPlot(player.getLocation());
        if (plot == null) {
          MainUtil.sendMessage(player,C.NOT_IN_PLOT);
          return false;
        }
        PlotAnalysis analysis=plot.getComplexity();
        if (analysis != null) {
          int complexity=analysis.getComplexity();
          MainUtil.sendMessage(player,""String_Node_Str"" + analysis.changes);
          MainUtil.sendMessage(player,""String_Node_Str"" + complexity);
          return true;
        }
        MainUtil.sendMessage(player,""String_Node_Str"");
        HybridUtils.manager.analyzePlot(plot,new RunnableVal<PlotAnalysis>(){
          @Override public void run(){
            MainUtil.sendMessage(player,""String_Node_Str"");
          }
        }
);
        return true;
      }
case ""String_Node_Str"":
{
      if (args.length != 2) {
        MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"");
        MainUtil.sendMessage(player,""String_Node_Str"");
        return false;
      }
      double threshold;
      try {
        threshold=Integer.parseInt(args[1]) / 100d;
      }
 catch (      NumberFormatException e) {
        MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
        MainUtil.sendMessage(player,""String_Node_Str"");
        return false;
      }
      PlotAnalysis.calcOptimalModifiers(new Runnable(){
        @Override public void run(){
          PS.log(""String_Node_Str"");
        }
      }
,threshold);
      return true;
    }
case ""String_Node_Str"":
{
    if (ExpireManager.task != -1) {
      Bukkit.getScheduler().cancelTask(ExpireManager.task);
    }
 else {
      return MainUtil.sendMessage(player,""String_Node_Str"");
    }
    ExpireManager.task=-1;
    return MainUtil.sendMessage(player,""String_Node_Str"");
  }
case ""String_Node_Str"":
{
  if (args.length != 2) {
    MainUtil.sendMessage(player,C.COMMAND_SYNTAX,""String_Node_Str"");
    return false;
  }
  String flag=args[1];
  for (  Plot plot : PS.get().getPlots()) {
    if (FlagManager.getPlotFlag(plot,flag) != null) {
      FlagManager.removePlotFlag(plot,flag);
    }
  }
  return MainUtil.sendMessage(player,""String_Node_Str"" + flag);
}
case ""String_Node_Str"":
{
if (args.length != 2) {
  PS.log(""String_Node_Str"");
  return false;
}
boolean result;
if (!PS.get().isPlotWorld(args[1])) {
  MainUtil.sendMessage(player,C.NOT_VALID_PLOT_WORLD,args[1]);
  return false;
}
if (BukkitHybridUtils.regions != null) {
  result=((BukkitHybridUtils)(HybridUtils.manager)).scheduleRoadUpdate(args[1],BukkitHybridUtils.regions,0);
}
 else {
  result=HybridUtils.manager.scheduleRoadUpdate(args[1],0);
}
if (!result) {
  PS.log(""String_Node_Str"");
  return false;
}
return true;
}
case ""String_Node_Str"":
{
if (((BukkitHybridUtils)(HybridUtils.manager)).task == 0) {
PS.log(""String_Node_Str"");
return false;
}
((BukkitHybridUtils)(HybridUtils.manager)).task=0;
Bukkit.getScheduler().cancelTask(((BukkitHybridUtils)(HybridUtils.manager)).task);
PS.log(""String_Node_Str"");
while (BukkitHybridUtils.chunks.size() > 0) {
ChunkLoc chunk=BukkitHybridUtils.chunks.get(0);
BukkitHybridUtils.chunks.remove(0);
HybridUtils.manager.regenerateRoad(BukkitHybridUtils.world,chunk,0);
ChunkManager.manager.unloadChunk(BukkitHybridUtils.world,chunk);
}
PS.log(""String_Node_Str"");
return true;
}
case ""String_Node_Str"":
{
if (ExpireManager.task == -1) {
ExpireManager.runTask();
}
 else {
return MainUtil.sendMessage(player,""String_Node_Str"");
}
return MainUtil.sendMessage(player,""String_Node_Str"");
}
case ""String_Node_Str"":
{
if (args.length > 1) {
final String world=args[1];
if (!BlockManager.manager.isWorld(world)) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
MainUtil.sendMessage(player,""String_Node_Str"");
ExpireManager.updateExpired(args[1]);
return true;
}
return MainUtil.sendMessage(player,""String_Node_Str"");
}
case ""String_Node_Str"":
{
if (args.length > 1) {
final String world=args[1];
if (!BlockManager.manager.isWorld(world)) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
if (!ExpireManager.expiredPlots.containsKey(args[1])) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
MainUtil.sendMessage(player,""String_Node_Str"" + ExpireManager.expiredPlots.get(args[1]).size() + ""String_Node_Str"");
for (final Plot plot : ExpireManager.expiredPlots.get(args[1])) {
MainUtil.sendMessage(player,""String_Node_Str"" + plot.world + ""String_Node_Str""+ plot.id.x+ ""String_Node_Str""+ plot.id.y+ ""String_Node_Str""+ UUIDHandler.getName(plot.owner)+ ""String_Node_Str""+ ExpireManager.dates.get(plot.owner));
}
return true;
}
return MainUtil.sendMessage(player,""String_Node_Str"");
}
case ""String_Node_Str"":
{
if (args.length != 2) {
return MainUtil.sendMessage(player,""String_Node_Str"");
}
final UUID uuid=UUIDHandler.getUUID(args[1],null);
if (uuid == null) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
final OfflinePlotPlayer op=UUIDHandler.getUUIDWrapper().getOfflinePlayer(uuid);
if ((op == null) || (op.getLastPlayed() == 0)) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
final Timestamp stamp=new Timestamp(op.getLastPlayed());
final Date date=new Date(stamp.getTime());
MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
MainUtil.sendMessage(player,""String_Node_Str"" + uuid);
MainUtil.sendMessage(player,""String_Node_Str"" + date.toGMTString());
MainUtil.sendMessage(player,""String_Node_Str"" + date.toGMTString());
MainUtil.sendMessage(player,""String_Node_Str"" + date.toLocaleString());
return true;
}
case ""String_Node_Str"":
{
if (args.length != 2) {
MainUtil.sendMessage(player,""String_Node_Str"");
MainUtil.sendMessage(player,""String_Node_Str"");
return MainUtil.sendMessage(player,""String_Node_Str"");
}
final String world=args[1];
if (!BlockManager.manager.isWorld(world) || !PS.get().isPlotWorld(args[1])) {
return MainUtil.sendMessage(player,""String_Node_Str"" + args[1]);
}
final ArrayList<ChunkLoc> empty=new ArrayList<>();
final boolean result=Trim.getTrimRegions(empty,world,new Runnable(){
@Override public void run(){
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"" + empty.size());
Trim.sendMessage(""String_Node_Str"" + (empty.size() * 1024) + ""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
final File file=new File(PS.get().IMP.getDirectory() + File.separator + ""String_Node_Str"");
PrintWriter writer;
try {
writer=new PrintWriter(file);
for (final ChunkLoc loc : empty) {
writer.println(world + ""String_Node_Str"" + loc.x+ ""String_Node_Str""+ loc.z+ ""String_Node_Str"");
}
writer.close();
Trim.sendMessage(""String_Node_Str"");
}
 catch (final FileNotFoundException e) {
e.printStackTrace();
Trim.sendMessage(""String_Node_Str"");
}
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
Trim.sendMessage(""String_Node_Str"");
}
}
);
if (!result) {
MainUtil.sendMessage(player,""String_Node_Str"");
}
return result;
}
}
}
MainUtil.sendMessage(player,""String_Node_Str"" + StringUtils.join(allowed_params,""String_Node_Str"") + ""String_Node_Str"");
return true;
}"
57995,"@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if ((plot == null) || !plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  UUID uuid;
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    uuid=DBFunc.everyone;
  }
 else {
    uuid=UUIDHandler.getUUID(args[0]);
  }
  if (uuid == null) {
    if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
    }
 else {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
    }
    return false;
  }
  if (plot.isOwner(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_OWNER);
    return false;
  }
  if (plot.getDenied().contains(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_ADDED);
    return false;
  }
  plot.removeMember(uuid);
  plot.removeTrusted(uuid);
  plot.addDenied(uuid);
  EventUtil.manager.callDenied(plr,plot,uuid,true);
  MainUtil.sendMessage(plr,C.DENIED_ADDED);
  if (!uuid.equals(DBFunc.everyone)) {
    handleKick(uuid,plot);
  }
  return true;
}","@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if ((plot == null) || !plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  UUID uuid;
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    uuid=DBFunc.everyone;
  }
 else {
    uuid=UUIDHandler.getUUID(args[0],null);
  }
  if (uuid == null) {
    if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
    }
 else {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
    }
    return false;
  }
  if (plot.isOwner(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_OWNER);
    return false;
  }
  if (plot.getDenied().contains(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_ADDED);
    return false;
  }
  plot.removeMember(uuid);
  plot.removeTrusted(uuid);
  plot.addDenied(uuid);
  EventUtil.manager.callDenied(plr,plot,uuid,true);
  MainUtil.sendMessage(plr,C.DENIED_ADDED);
  if (!uuid.equals(DBFunc.everyone)) {
    handleKick(uuid,plot);
  }
  return true;
}"
57996,"@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  if (args.length == 1) {
    final String arg=args[0].toLowerCase();
    final PlotId id=getId(arg);
    if (id != null) {
      caller.message(""String_Node_Str"");
      return false;
    }
    final UUID uuid=UUIDHandler.getUUID(args[0]);
    if (uuid != null) {
      caller.message(""String_Node_Str"" + args[0] + ""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    caller.message(C.PURGE_SYNTAX);
    return false;
  }
  if (args.length != 2) {
    caller.message(C.PURGE_SYNTAX);
    return false;
  }
  final String worldname=args[1];
  if (!PS.get().getAllPlotsRaw().containsKey(worldname)) {
    caller.message(""String_Node_Str"");
    return false;
  }
  final String arg=args[0].toLowerCase();
  final PlotId id=getId(arg);
  if (id != null) {
    final HashSet<Integer> ids=new HashSet<Integer>();
    final int DBid=DBFunc.getId(worldname,id);
    if (DBid != Integer.MAX_VALUE) {
      ids.add(DBid);
    }
    DBFunc.purgeIds(worldname,ids);
    return finishPurge(DBid == Integer.MAX_VALUE ? 1 : 0);
  }
  if (arg.equals(""String_Node_Str"")) {
    final Set<PlotId> ids=PS.get().getPlots(worldname).keySet();
    int length=ids.size();
    if (length == 0) {
      return MainUtil.sendMessage(null,""String_Node_Str"");
    }
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  if (arg.equals(""String_Node_Str"")) {
    final Collection<Plot> plots=PS.get().getPlots(worldname).values();
    final Set<PlotId> ids=new HashSet<>();
    for (    final Plot plot : plots) {
      if (plot.owner != null) {
        final String name=UUIDHandler.getName(plot.owner);
        if (name == null) {
          ids.add(plot.id);
        }
      }
    }
    int length=ids.size();
    if (length == 0) {
      return MainUtil.sendMessage(null,""String_Node_Str"");
    }
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  if (arg.equals(""String_Node_Str"")) {
    final Collection<Plot> plots=PS.get().getPlots(worldname).values();
    final Set<PlotId> ids=new HashSet<>();
    for (    final Plot plot : plots) {
      if (plot.owner == null) {
        ids.add(plot.id);
      }
    }
    int length=ids.size();
    if (length == 0) {
      return MainUtil.sendMessage(null,""String_Node_Str"");
    }
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  final UUID uuid=UUIDHandler.getUUID(args[0]);
  if (uuid != null) {
    final Set<Plot> plots=PS.get().getPlots(worldname,uuid);
    final Set<PlotId> ids=new HashSet<>();
    for (    final Plot plot : plots) {
      ids.add(plot.id);
    }
    int length=ids.size();
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  caller.message(C.PURGE_SYNTAX);
  return false;
}","@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  if (args.length == 1) {
    final String arg=args[0].toLowerCase();
    final PlotId id=getId(arg);
    if (id != null) {
      caller.message(""String_Node_Str"");
      return false;
    }
    final UUID uuid=UUIDHandler.getUUID(args[0],null);
    if (uuid != null) {
      caller.message(""String_Node_Str"" + args[0] + ""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    if (arg.equals(""String_Node_Str"")) {
      caller.message(""String_Node_Str"");
      return false;
    }
    caller.message(C.PURGE_SYNTAX);
    return false;
  }
  if (args.length != 2) {
    caller.message(C.PURGE_SYNTAX);
    return false;
  }
  final String worldname=args[1];
  if (!PS.get().getAllPlotsRaw().containsKey(worldname)) {
    caller.message(""String_Node_Str"");
    return false;
  }
  final String arg=args[0].toLowerCase();
  final PlotId id=getId(arg);
  if (id != null) {
    final HashSet<Integer> ids=new HashSet<Integer>();
    final int DBid=DBFunc.getId(worldname,id);
    if (DBid != Integer.MAX_VALUE) {
      ids.add(DBid);
    }
    DBFunc.purgeIds(worldname,ids);
    return finishPurge(DBid == Integer.MAX_VALUE ? 1 : 0);
  }
  if (arg.equals(""String_Node_Str"")) {
    final Set<PlotId> ids=PS.get().getPlots(worldname).keySet();
    int length=ids.size();
    if (length == 0) {
      return MainUtil.sendMessage(null,""String_Node_Str"");
    }
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  if (arg.equals(""String_Node_Str"")) {
    final Collection<Plot> plots=PS.get().getPlots(worldname).values();
    final Set<PlotId> ids=new HashSet<>();
    for (    final Plot plot : plots) {
      if (plot.owner != null) {
        final String name=UUIDHandler.getName(plot.owner);
        if (name == null) {
          ids.add(plot.id);
        }
      }
    }
    int length=ids.size();
    if (length == 0) {
      return MainUtil.sendMessage(null,""String_Node_Str"");
    }
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  if (arg.equals(""String_Node_Str"")) {
    final Collection<Plot> plots=PS.get().getPlots(worldname).values();
    final Set<PlotId> ids=new HashSet<>();
    for (    final Plot plot : plots) {
      if (plot.owner == null) {
        ids.add(plot.id);
      }
    }
    int length=ids.size();
    if (length == 0) {
      return MainUtil.sendMessage(null,""String_Node_Str"");
    }
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  final UUID uuid=UUIDHandler.getUUID(args[0],null);
  if (uuid != null) {
    final Set<Plot> plots=PS.get().getPlots(worldname,uuid);
    final Set<PlotId> ids=new HashSet<>();
    for (    final Plot plot : plots) {
      ids.add(plot.id);
    }
    int length=ids.size();
    DBFunc.purge(worldname,ids);
    return finishPurge(length);
  }
  caller.message(C.PURGE_SYNTAX);
  return false;
}"
57997,"@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  if (args.length != 1) {
    MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
    return true;
  }
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if ((plot == null) || !plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  int count=0;
switch (args[0]) {
case ""String_Node_Str"":
{
      ArrayList<UUID> toRemove=new ArrayList<>();
      HashSet<UUID> all=new HashSet<>();
      all.addAll(plot.getMembers());
      all.addAll(plot.getTrusted());
      all.addAll(plot.getDenied());
      for (      UUID uuid : all) {
        if (UUIDHandler.getName(uuid) == null) {
          toRemove.add(uuid);
          count++;
        }
      }
      for (      UUID uuid : toRemove) {
        plot.removeDenied(uuid);
        plot.removeTrusted(uuid);
        plot.removeMember(uuid);
      }
      break;
    }
case ""String_Node_Str"":
{
    ArrayList<UUID> toRemove=new ArrayList<>();
    HashSet<UUID> all=new HashSet<>();
    all.addAll(plot.getMembers());
    all.addAll(plot.getTrusted());
    all.addAll(plot.getDenied());
    for (    UUID uuid : all) {
      toRemove.add(uuid);
      count++;
    }
    for (    UUID uuid : toRemove) {
      plot.removeDenied(uuid);
      plot.removeTrusted(uuid);
      plot.removeMember(uuid);
    }
    break;
  }
default :
UUID uuid=UUIDHandler.getUUID(args[0]);
if (uuid != null) {
if (plot.getTrusted().contains(uuid)) {
  if (plot.removeTrusted(uuid)) {
    count++;
  }
}
 else if (plot.getMembers().contains(uuid)) {
  if (plot.removeMember(uuid)) {
    count++;
  }
}
 else if (plot.getDenied().contains(uuid)) {
  if (plot.removeDenied(uuid)) {
    count++;
  }
}
}
break;
}
if (count == 0) {
if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
}
 else {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
}
return false;
}
 else {
MainUtil.sendMessage(plr,C.REMOVED_PLAYERS,count + ""String_Node_Str"");
}
return true;
}","@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  if (args.length != 1) {
    MainUtil.sendMessage(plr,C.COMMAND_SYNTAX,""String_Node_Str"");
    return true;
  }
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if ((plot == null) || !plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  int count=0;
switch (args[0]) {
case ""String_Node_Str"":
{
      ArrayList<UUID> toRemove=new ArrayList<>();
      HashSet<UUID> all=new HashSet<>();
      all.addAll(plot.getMembers());
      all.addAll(plot.getTrusted());
      all.addAll(plot.getDenied());
      for (      UUID uuid : all) {
        if (UUIDHandler.getName(uuid) == null) {
          toRemove.add(uuid);
          count++;
        }
      }
      for (      UUID uuid : toRemove) {
        plot.removeDenied(uuid);
        plot.removeTrusted(uuid);
        plot.removeMember(uuid);
      }
      break;
    }
case ""String_Node_Str"":
{
    ArrayList<UUID> toRemove=new ArrayList<>();
    HashSet<UUID> all=new HashSet<>();
    all.addAll(plot.getMembers());
    all.addAll(plot.getTrusted());
    all.addAll(plot.getDenied());
    for (    UUID uuid : all) {
      toRemove.add(uuid);
      count++;
    }
    for (    UUID uuid : toRemove) {
      plot.removeDenied(uuid);
      plot.removeTrusted(uuid);
      plot.removeMember(uuid);
    }
    break;
  }
default :
UUID uuid=UUIDHandler.getUUID(args[0],null);
if (uuid != null) {
if (plot.getTrusted().contains(uuid)) {
  if (plot.removeTrusted(uuid)) {
    count++;
  }
}
 else if (plot.getMembers().contains(uuid)) {
  if (plot.removeMember(uuid)) {
    count++;
  }
}
 else if (plot.getDenied().contains(uuid)) {
  if (plot.removeDenied(uuid)) {
    count++;
  }
}
}
break;
}
if (count == 0) {
if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
}
 else {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
}
return false;
}
 else {
MainUtil.sendMessage(plr,C.REMOVED_PLAYERS,count + ""String_Node_Str"");
}
return true;
}"
57998,"private UUID getUUID(final String string){
  return UUIDHandler.getUUID(string);
}","private UUID getUUID(final String string){
  return UUIDHandler.getUUID(string,null);
}"
57999,"@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if (!plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  UUID uuid;
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    uuid=DBFunc.everyone;
  }
 else {
    uuid=UUIDHandler.getUUID(args[0]);
  }
  if (uuid == null) {
    if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
    }
 else {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
    }
    return false;
  }
  if (plot.isOwner(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_OWNER);
    return false;
  }
  if (plot.getTrusted().contains(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_ADDED);
    return false;
  }
  if (plot.removeMember(uuid)) {
    plot.addTrusted(uuid);
  }
 else {
    if (plot.getMembers().size() + plot.getTrusted().size() >= PS.get().getPlotWorld(plot.world).MAX_PLOT_MEMBERS) {
      MainUtil.sendMessage(plr,C.PLOT_MAX_MEMBERS);
      return false;
    }
    if (plot.getDenied().contains(uuid)) {
      plot.removeDenied(uuid);
    }
    plot.addTrusted(uuid);
  }
  EventUtil.manager.callTrusted(plr,plot,uuid,true);
  MainUtil.sendMessage(plr,C.TRUSTED_ADDED);
  return true;
}","@Override public boolean onCommand(final CommandCaller caller,final String[] args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if (!plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  UUID uuid;
  if (args[0].equalsIgnoreCase(""String_Node_Str"")) {
    uuid=DBFunc.everyone;
  }
 else {
    uuid=UUIDHandler.getUUID(args[0],null);
  }
  if (uuid == null) {
    if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
    }
 else {
      MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
    }
    return false;
  }
  if (plot.isOwner(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_OWNER);
    return false;
  }
  if (plot.getTrusted().contains(uuid)) {
    MainUtil.sendMessage(plr,C.ALREADY_ADDED);
    return false;
  }
  if (plot.removeMember(uuid)) {
    plot.addTrusted(uuid);
  }
 else {
    if (plot.getMembers().size() + plot.getTrusted().size() >= PS.get().getPlotWorld(plot.world).MAX_PLOT_MEMBERS) {
      MainUtil.sendMessage(plr,C.PLOT_MAX_MEMBERS);
      return false;
    }
    if (plot.getDenied().contains(uuid)) {
      plot.removeDenied(uuid);
    }
    plot.addTrusted(uuid);
  }
  EventUtil.manager.callTrusted(plr,plot,uuid,true);
  MainUtil.sendMessage(plr,C.TRUSTED_ADDED);
  return true;
}"
58000,"@Override public boolean onCommand(final CommandCaller caller,final String... args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if (!plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  int count=0;
switch (args[0]) {
case ""String_Node_Str"":
    ArrayList<UUID> toRemove=new ArrayList<>();
  for (  UUID uuid : plot.getDenied()) {
    if (UUIDHandler.getName(uuid) == null) {
      toRemove.add(uuid);
    }
  }
for (UUID uuid : toRemove) {
  plot.removeDenied(uuid);
  count++;
}
break;
case ""String_Node_Str"":
for (UUID uuid : new ArrayList<>(plot.getDenied())) {
plot.removeDenied(uuid);
count++;
}
break;
default :
UUID uuid=UUIDHandler.getUUID(args[0]);
if (uuid != null) {
if (plot.removeDenied(uuid)) {
count++;
}
}
break;
}
if (count == 0) {
if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
}
 else {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
}
return false;
}
 else {
MainUtil.sendMessage(plr,C.REMOVED_PLAYERS,count + ""String_Node_Str"");
}
return true;
}","@Override public boolean onCommand(final CommandCaller caller,final String... args){
  final PlotPlayer plr=(PlotPlayer)caller.getSuperCaller();
  final Location loc=plr.getLocation();
  final Plot plot=MainUtil.getPlot(loc);
  if (plot == null) {
    return !sendMessage(plr,C.NOT_IN_PLOT);
  }
  if (!plot.hasOwner()) {
    MainUtil.sendMessage(plr,C.PLOT_UNOWNED);
    return false;
  }
  if (!plot.isOwner(plr.getUUID()) && !Permissions.hasPermission(plr,""String_Node_Str"")) {
    MainUtil.sendMessage(plr,C.NO_PLOT_PERMS);
    return true;
  }
  int count=0;
switch (args[0]) {
case ""String_Node_Str"":
    ArrayList<UUID> toRemove=new ArrayList<>();
  for (  UUID uuid : plot.getDenied()) {
    if (UUIDHandler.getName(uuid) == null) {
      toRemove.add(uuid);
    }
  }
for (UUID uuid : toRemove) {
  plot.removeDenied(uuid);
  count++;
}
break;
case ""String_Node_Str"":
for (UUID uuid : new ArrayList<>(plot.getDenied())) {
plot.removeDenied(uuid);
count++;
}
break;
default :
UUID uuid=UUIDHandler.getUUID(args[0],null);
if (uuid != null) {
if (plot.removeDenied(uuid)) {
count++;
}
}
break;
}
if (count == 0) {
if (UUIDHandler.implementation instanceof SQLUUIDHandler) {
MainUtil.sendMessage(plr,C.INVALID_PLAYER_WAIT,args[0]);
}
 else {
MainUtil.sendMessage(plr,C.INVALID_PLAYER,args[0]);
}
return false;
}
 else {
MainUtil.sendMessage(plr,C.REMOVED_PLAYERS,count + ""String_Node_Str"");
}
return true;
}"
