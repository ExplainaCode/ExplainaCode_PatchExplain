record_number,buggy_code,fixed_code
23001,"public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
}","public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
  updateVoiceButton(TextUtils.isEmpty(s));
}"
23002,"/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 */
private void updateVoiceButton(){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled()) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}","/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 * @param empty whether the search query text field is empty. If it is, then the othercriteria apply to make the voice button visible. Otherwise the voice button will not be visible - i.e., if the user has typed a query, remove the voice button.
 */
private void updateVoiceButton(boolean empty){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled() && empty) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}"
23003,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent,searchable);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
  dismiss();
}"
23004,"/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mActivityContext=null;
  mUserQuery=null;
}","/** 
 * The search dialog is being dismissed, so handle all of the local shutdown operations. This function is designed to be idempotent so that dismiss() can be safely called at any time (even if already closed) and more likely to really dump any memory.  No leaks!
 */
@Override public void onStop(){
  super.onStop();
  closeSuggestionsAdapter();
  mLaunchComponent=null;
  mAppSearchData=null;
  mSearchable=null;
  mUserQuery=null;
}"
23005,"/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton();
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}","/** 
 * Update the UI according to the info in the current value of   {@link #mSearchable}.
 */
private void updateUI(){
  if (mSearchable != null) {
    mDecor.setVisibility(View.VISIBLE);
    updateSearchAutoComplete();
    updateSearchButton();
    updateSearchAppIcon();
    updateSearchBadge();
    updateQueryHint();
    updateVoiceButton(TextUtils.isEmpty(mUserQuery));
    int inputType=mSearchable.getInputType();
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
      inputType&=~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      if (mSearchable.getSuggestAuthority() != null) {
        inputType|=InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
      }
    }
    mSearchAutoComplete.setInputType(inputType);
    mSearchAutoCompleteImeOptions=mSearchable.getImeOptions();
    mSearchAutoComplete.setImeOptions(mSearchAutoCompleteImeOptions);
    if (mSearchable.getVoiceSearchEnabled()) {
      mSearchAutoComplete.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
 else {
      mSearchAutoComplete.setPrivateImeOptions(null);
    }
  }
}"
23006,"public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
}","public void onTextChanged(CharSequence s,int start,int before,int after){
  if (DBG_LOG_TIMING) {
    dbgLogTiming(""String_Node_Str"");
  }
  if (mSearchable == null) {
    return;
  }
  updateWidgetState();
  if (!mSearchAutoComplete.isPerformingCompletion()) {
    mUserQuery=s == null ? ""String_Node_Str"" : s.toString();
  }
  updateVoiceButton(TextUtils.isEmpty(s));
}"
23007,"/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 */
private void updateVoiceButton(){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled()) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}","/** 
 * Update the visibility of the voice button.  There are actually two voice search modes,  either of which will activate the button.
 * @param empty whether the search query text field is empty. If it is, then the othercriteria apply to make the voice button visible. Otherwise the voice button will not be visible - i.e., if the user has typed a query, remove the voice button.
 */
private void updateVoiceButton(boolean empty){
  int visibility=View.GONE;
  if (mSearchable.getVoiceSearchEnabled() && empty) {
    Intent testIntent=null;
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      testIntent=mVoiceWebSearchIntent;
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      testIntent=mVoiceAppSearchIntent;
    }
    if (testIntent != null) {
      ResolveInfo ri=getContext().getPackageManager().resolveActivity(testIntent,PackageManager.MATCH_DEFAULT_ONLY);
      if (ri != null) {
        visibility=View.VISIBLE;
      }
    }
  }
  mVoiceButton.setVisibility(visibility);
}"
23008,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  if (!inChild((int)ev.getX(),(int)y)) {
    mIsBeingDragged=false;
    return false;
  }
mLastMotionY=y;
break;
case MotionEvent.ACTION_MOVE:
if (mIsBeingDragged) {
final int deltaY=(int)(mLastMotionY - y);
mLastMotionY=y;
overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
break;
}
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity();
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
fling(-initialVelocity);
}
 else {
final int bottom=getScrollRange();
if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
  invalidate();
}
}
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}"
23009,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_MOVE:
    final int yDiff=(int)Math.abs(y - mLastMotionY);
  if (yDiff > mTouchSlop) {
    mIsBeingDragged=true;
    mLastMotionY=y;
  }
break;
case MotionEvent.ACTION_DOWN:
if (!inChild((int)ev.getX(),(int)y)) {
mIsBeingDragged=false;
break;
}
mLastMotionY=y;
mIsBeingDragged=!mScroller.isFinished();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
23010,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  if (!inChild((int)ev.getX(),(int)y)) {
    mIsBeingDragged=false;
    return false;
  }
mLastMotionY=y;
break;
case MotionEvent.ACTION_MOVE:
if (mIsBeingDragged) {
final int deltaY=(int)(mLastMotionY - y);
mLastMotionY=y;
overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
break;
}
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity();
if (getChildCount() > 0) {
if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
fling(-initialVelocity);
}
 else {
final int bottom=getScrollRange();
if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
  invalidate();
}
}
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (ev.getAction() == MotionEvent.ACTION_DOWN && ev.getEdgeFlags() != 0) {
    return false;
  }
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      if (!mScroller.isFinished()) {
        mScroller.abortAnimation();
      }
      final float y=ev.getY();
      if (!(mIsBeingDragged=inChild((int)ev.getX(),(int)y))) {
        return false;
      }
      mLastMotionY=y;
      mActivePointerId=ev.getPointerId(0);
      break;
    }
case MotionEvent.ACTION_MOVE:
  if (mIsBeingDragged) {
    final int activePointerIndex=ev.findPointerIndex(mActivePointerId);
    final float y=ev.getY(activePointerIndex);
    final int deltaY=(int)(mLastMotionY - y);
    mLastMotionY=y;
    overscrollBy(0,deltaY,0,mScrollY,0,getScrollRange(),0,getOverscrollMax());
  }
break;
case MotionEvent.ACTION_UP:
if (mIsBeingDragged) {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int initialVelocity=(int)velocityTracker.getYVelocity(mActivePointerId);
if (getChildCount() > 0) {
  if ((Math.abs(initialVelocity) > mMinimumVelocity)) {
    fling(-initialVelocity);
  }
 else {
    final int bottom=getScrollRange();
    if (mScroller.springback(mScrollX,mScrollY,0,0,0,bottom)) {
      invalidate();
    }
  }
}
mActivePointerId=INVALID_POINTER;
mIsBeingDragged=false;
if (mVelocityTracker != null) {
  mVelocityTracker.recycle();
  mVelocityTracker=null;
}
}
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}"
23011,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
  final float y=ev.getY();
switch (action) {
case MotionEvent.ACTION_MOVE:
    final int yDiff=(int)Math.abs(y - mLastMotionY);
  if (yDiff > mTouchSlop) {
    mIsBeingDragged=true;
    mLastMotionY=y;
  }
break;
case MotionEvent.ACTION_DOWN:
if (!inChild((int)ev.getX(),(int)y)) {
mIsBeingDragged=false;
break;
}
mLastMotionY=y;
mIsBeingDragged=!mScroller.isFinished();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
break;
}
return mIsBeingDragged;
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  final int action=ev.getAction();
  if ((action == MotionEvent.ACTION_MOVE) && (mIsBeingDragged)) {
    return true;
  }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
      final int pointerIndex=ev.findPointerIndex(mActivePointerId);
      final float y=ev.getY(pointerIndex);
      final int yDiff=(int)Math.abs(y - mLastMotionY);
      if (yDiff > mTouchSlop) {
        mIsBeingDragged=true;
        mLastMotionY=y;
      }
      break;
    }
case MotionEvent.ACTION_DOWN:
{
    final float y=ev.getY();
    if (!inChild((int)ev.getX(),(int)y)) {
      mIsBeingDragged=false;
      break;
    }
    mLastMotionY=y;
    mActivePointerId=ev.getPointerId(0);
    mIsBeingDragged=!mScroller.isFinished();
    break;
  }
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
mIsBeingDragged=false;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return mIsBeingDragged;
}"
23012,"SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
    mCompiledSql.acquire();
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}","SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    mCompiledSql.acquire();
    db.addToCompiledQueries(sql,mCompiledSql);
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}"
23013,"SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
    mCompiledSql.acquire();
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}","SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    mCompiledSql.acquire();
    db.addToCompiledQueries(sql,mCompiledSql);
  }
 else {
    if (!mCompiledSql.acquire()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
  }
  nStatement=mCompiledSql.nStatement;
}"
23014,"final void releaseTheme(int theme){
synchronized (this) {
    deleteTheme(theme);
    decRefsLocked();
  }
}","final void releaseTheme(int theme){
synchronized (this) {
    deleteTheme(theme);
    decRefsLocked(theme);
  }
}"
23015,"private final void decRefsLocked(){
  mNumRefs--;
  if (mNumRefs == 0) {
    destroy();
  }
}","private final void decRefsLocked(int id){
  if (DEBUG_REFS && mRefStacks != null) {
    mRefStacks.remove(id);
  }
  mNumRefs--;
  if (mNumRefs == 0) {
    destroy();
  }
}"
23016,"final int createTheme(){
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    mNumRefs++;
    return newTheme();
  }
}","final int createTheme(){
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int res=newTheme();
    incRefsLocked(res);
    return res;
  }
}"
23017,"public final void close() throws IOException {
synchronized (AssetManager.this) {
    if (mAsset != 0) {
      destroyAsset(mAsset);
      mAsset=0;
      decRefsLocked();
    }
  }
}","public final void close() throws IOException {
synchronized (AssetManager.this) {
    if (mAsset != 0) {
      destroyAsset(mAsset);
      mAsset=0;
      decRefsLocked(hashCode());
    }
  }
}"
23018,"private AssetManager(boolean isSystem){
  init();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + this);
}","private AssetManager(boolean isSystem){
  if (DEBUG_REFS) {
synchronized (this) {
      mNumRefs=0;
      incRefsLocked(this.hashCode());
    }
  }
  init();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + this);
}"
23019,"/** 
 * {@hide}Retrieve a non-asset as a compiled XML file.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 */
final XmlBlock openXmlBlockAsset(int cookie,String fileName) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int xmlBlock=openXmlAssetNative(cookie,fileName);
    if (xmlBlock != 0) {
      mNumRefs++;
      return new XmlBlock(this,xmlBlock);
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}","/** 
 * {@hide}Retrieve a non-asset as a compiled XML file.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 */
final XmlBlock openXmlBlockAsset(int cookie,String fileName) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int xmlBlock=openXmlAssetNative(cookie,fileName);
    if (xmlBlock != 0) {
      XmlBlock res=new XmlBlock(this,xmlBlock);
      incRefsLocked(res.hashCode());
      return res;
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}"
23020,"/** 
 * {@hide}Open a non-asset in a specified package.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 * @param accessMode Desired access mode for retrieving the data.
 */
public final InputStream openNonAsset(int cookie,String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openNonAssetNative(cookie,fileName,accessMode);
    if (asset != 0) {
      mNumRefs++;
      return new AssetInputStream(asset);
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}","/** 
 * {@hide}Open a non-asset in a specified package.  Not for use by applications.
 * @param cookie Identifier of the package to be opened.
 * @param fileName Name of the asset to retrieve.
 * @param accessMode Desired access mode for retrieving the data.
 */
public final InputStream openNonAsset(int cookie,String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openNonAssetNative(cookie,fileName,accessMode);
    if (asset != 0) {
      AssetInputStream res=new AssetInputStream(asset);
      incRefsLocked(res.hashCode());
      return res;
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}"
23021,"void xmlBlockGone(){
synchronized (this) {
    decRefsLocked();
  }
}","void xmlBlockGone(int id){
synchronized (this) {
    decRefsLocked(id);
  }
}"
23022,"/** 
 * Open an asset using an explicit access mode, returning an InputStream to read its contents.  This provides access to files that have been bundled with an application as assets -- that is, files placed in to the ""assets"" directory.
 * @param fileName The name of the asset to open.  This name can behierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
public final InputStream open(String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openAsset(fileName,accessMode);
    if (asset != 0) {
      mNumRefs++;
      return new AssetInputStream(asset);
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}","/** 
 * Open an asset using an explicit access mode, returning an InputStream to read its contents.  This provides access to files that have been bundled with an application as assets -- that is, files placed in to the ""assets"" directory.
 * @param fileName The name of the asset to open.  This name can behierarchical.
 * @param accessMode Desired access mode for retrieving the data.
 * @see #ACCESS_UNKNOWN
 * @see #ACCESS_STREAMING
 * @see #ACCESS_RANDOM
 * @see #ACCESS_BUFFER
 * @see #open(String)
 * @see #list
 */
public final InputStream open(String fileName,int accessMode) throws IOException {
synchronized (this) {
    if (!mOpen) {
      throw new RuntimeException(""String_Node_Str"");
    }
    int asset=openAsset(fileName,accessMode);
    if (asset != 0) {
      AssetInputStream res=new AssetInputStream(asset);
      incRefsLocked(res.hashCode());
      return res;
    }
  }
  throw new FileNotFoundException(""String_Node_Str"" + fileName);
}"
23023,"private void decOpenCountLocked(){
  mOpenCount--;
  if (mOpenCount == 0) {
    nativeDestroy(mNative);
    if (mAssets != null) {
      mAssets.xmlBlockGone();
    }
  }
}","private void decOpenCountLocked(){
  mOpenCount--;
  if (mOpenCount == 0) {
    nativeDestroy(mNative);
    if (mAssets != null) {
      mAssets.xmlBlockGone(hashCode());
    }
  }
}"
23024,"public static final void installSystemProviders(){
  ProcessRecord app=mSelf.mProcessNames.get(""String_Node_Str"",Process.SYSTEM_UID);
  List providers=mSelf.generateApplicationProvidersLocked(app);
  mSystemThread.installSystemProviders(providers);
}","public static final void installSystemProviders(){
  ProcessRecord app=mSelf.mProcessNames.get(""String_Node_Str"",Process.SYSTEM_UID);
  List providers=mSelf.generateApplicationProvidersLocked(app);
  if (providers != null) {
    for (int i=providers.size() - 1; i >= 0; i--) {
      ProviderInfo pi=(ProviderInfo)providers.get(i);
      if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
        Log.w(TAG,""String_Node_Str"" + pi.name + ""String_Node_Str"");
        providers.remove(i);
      }
    }
  }
  mSystemThread.installSystemProviders(providers);
}"
23025,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (!mSystemReady && !mDidUpdate && !mWaitingUpdate&& !cpi.processName.equals(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
23026,"void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(uid);
  pw.print(""String_Node_Str"");
  pw.print(key.packageName);
  pw.print(""String_Node_Str"");
  pw.print(key.typeName());
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(key.flags));
  if (key.activity != null || key.who != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.activity);
    pw.print(""String_Node_Str"");
    pw.println(key.who);
  }
  if (key.requestCode != 0 || key.requestResolvedType != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.requestCode);
    pw.print(""String_Node_Str"");
    pw.println(key.requestResolvedType);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(key.requestIntent.toShortString(true,true));
  if (sent || canceled) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(sent);
    pw.print(""String_Node_Str"");
    pw.println(canceled);
  }
}","void dump(PrintWriter pw,String prefix){
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(uid);
  pw.print(""String_Node_Str"");
  pw.print(key.packageName);
  pw.print(""String_Node_Str"");
  pw.print(key.typeName());
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(key.flags));
  if (key.activity != null || key.who != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.activity);
    pw.print(""String_Node_Str"");
    pw.println(key.who);
  }
  if (key.requestCode != 0 || key.requestResolvedType != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(key.requestCode);
    pw.print(""String_Node_Str"");
    pw.println(key.requestResolvedType);
  }
  if (key.requestIntent != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(key.requestIntent.toShortString(true,true));
  }
  if (sent || canceled) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(sent);
    pw.print(""String_Node_Str"");
    pw.println(canceled);
  }
}"
23027,"public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}","public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId) || mAsecMountSet.contains(newId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}"
23028,"public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}","public int renameSecureContainer(String oldId,String newId){
  validatePermission(android.Manifest.permission.ASEC_RENAME);
  waitForReady();
  warnOnNotMounted();
synchronized (mAsecMountSet) {
    if (mAsecMountSet.contains(oldId) || mAsecMountSet.contains(newId)) {
      return StorageResultCode.OperationFailedStorageMounted;
    }
  }
  int rc=StorageResultCode.OperationSucceeded;
  String cmd=String.format(""String_Node_Str"",oldId,newId);
  try {
    mConnector.doCommand(cmd);
  }
 catch (  NativeDaemonConnectorException e) {
    rc=StorageResultCode.OperationFailedInternalError;
  }
  return rc;
}"
23029,"private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=ruleStr.split(RULE_SEPARATOR);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}","private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=getRuleStrings(ruleStr);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}"
23030,"public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  boolean allDay=values.getAsInteger(Calendar.Events.ALL_DAY) == 1;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}","public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  Integer allDayInteger=values.getAsInteger(Calendar.Events.ALL_DAY);
  boolean allDay=(null != allDayInteger) ? (allDayInteger == 1) : false;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}"
23031,"private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=ruleStr.split(RULE_SEPARATOR);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}","private static void addPropertiesForRuleStr(ICalendar.Component component,String propertyName,String ruleStr){
  if (TextUtils.isEmpty(ruleStr)) {
    return;
  }
  String[] rrules=getRuleStrings(ruleStr);
  for (  String rrule : rrules) {
    ICalendar.Property prop=new ICalendar.Property(propertyName);
    prop.setValue(rrule);
    component.addProperty(prop);
  }
}"
23032,"public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  boolean allDay=values.getAsInteger(Calendar.Events.ALL_DAY) == 1;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}","public static boolean populateComponent(ContentValues values,ICalendar.Component component){
  long dtstart=-1;
  if (values.containsKey(Calendar.Events.DTSTART)) {
    dtstart=values.getAsLong(Calendar.Events.DTSTART);
  }
  String duration=values.getAsString(Calendar.Events.DURATION);
  String tzid=values.getAsString(Calendar.Events.EVENT_TIMEZONE);
  String rruleStr=values.getAsString(Calendar.Events.RRULE);
  String rdateStr=values.getAsString(Calendar.Events.RDATE);
  String exruleStr=values.getAsString(Calendar.Events.EXRULE);
  String exdateStr=values.getAsString(Calendar.Events.EXDATE);
  Integer allDayInteger=values.getAsInteger(Calendar.Events.ALL_DAY);
  boolean allDay=(null != allDayInteger) ? (allDayInteger == 1) : false;
  if ((dtstart == -1) || (TextUtils.isEmpty(duration)) || ((TextUtils.isEmpty(rruleStr)) && (TextUtils.isEmpty(rdateStr)))) {
    return false;
  }
  ICalendar.Property dtstartProp=new ICalendar.Property(""String_Node_Str"");
  Time dtstartTime=null;
  if (!TextUtils.isEmpty(tzid)) {
    if (!allDay) {
      dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",tzid));
    }
    dtstartTime=new Time(tzid);
  }
 else {
    dtstartTime=new Time(Time.TIMEZONE_UTC);
  }
  dtstartTime.set(dtstart);
  if (allDay) {
    dtstartProp.addParameter(new ICalendar.Parameter(""String_Node_Str"",""String_Node_Str""));
    dtstartTime.allDay=true;
    dtstartTime.hour=0;
    dtstartTime.minute=0;
    dtstartTime.second=0;
  }
  dtstartProp.setValue(dtstartTime.format2445());
  component.addProperty(dtstartProp);
  ICalendar.Property durationProp=new ICalendar.Property(""String_Node_Str"");
  durationProp.setValue(duration);
  component.addProperty(durationProp);
  addPropertiesForRuleStr(component,""String_Node_Str"",rruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",rdateStr);
  addPropertiesForRuleStr(component,""String_Node_Str"",exruleStr);
  addPropertyForDateStr(component,""String_Node_Str"",exdateStr);
  return true;
}"
23033,"private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    Bundle oldState=r.state;
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        r.state=oldState;
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}"
23034,"private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}","private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}"
23035,"public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    wl=new Wakelock();
    mWakelockStats.put(name,wl);
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}","public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    if (mWakelockStats.size() > MAX_WAKELOCKS_PER_UID) {
      name=BATCHED_WAKELOCK_NAME;
      wl=mWakelockStats.get(name);
    }
    if (wl == null) {
      wl=new Wakelock();
      mWakelockStats.put(name,wl);
    }
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}"
23036,"private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        Log.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}"
23037,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    if (deletedPs != null) {
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
23038,"private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}","private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        if (DEBUG_URI_PERMISSION)         Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}"
23039,"private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}","private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}"
23040,"private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    return;
  }
  if (checkUriPermissionLocked(uri,targetUid,modeFlags)) {
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}","private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + uri);
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + targetPkg);
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}"
23041,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}"
23042,"protected void finalize() throws Throwable {
  if (!canceled) {
synchronized (owner) {
      WeakReference<PendingIntentRecord> current=owner.mIntentSenderRecords.get(key);
      if (current == ref) {
        owner.mIntentSenderRecords.remove(key);
      }
    }
  }
}","protected void finalize() throws Throwable {
  try {
    if (!canceled) {
      owner.mHandler.sendMessage(owner.mHandler.obtainMessage(ActivityManagerService.FINALIZE_PENDING_INTENT_MSG,this));
    }
  }
  finally {
    super.finalize();
  }
}"
23043,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,localForegroundId,null,true);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23044,"public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23045,"public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}","public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}"
23046,"private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  try {
    test_path=new File(test_path).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
  }
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}","private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  test_path=new File(test_path).getAbsolutePath();
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}"
23047,"public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  try {
    this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
    return;
  }
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}","public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getAbsolutePath();
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}"
23048,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion == 50) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.SET_INSTALL_LOCATION,R.bool.set_install_location);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=51;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}"
23049,"/** 
 * Gets an auth token of the specified type for a particular account, optionally raising a notification if the user must enter credentials. This method is intended for background tasks and services where the user should not be immediately interrupted with a password prompt. <p>If a previously generated auth token is cached for this account and type, then it will be returned.  Otherwise, if we have saved credentials the server accepts, it will be used to generate a new auth token. Otherwise, an Intent will be returned which, when started, will prompt the user for a password.  If the notifyAuthFailure parameter is set, the same Intent will be associated with a status bar notification, alerting the user that they need to enter a password at some point. <p>If the intent is left in a notification, you will need to wait until the user gets around to entering a password before trying again, which could be hours or days or never.  When it does happen, the account manager will broadcast the   {@link #LOGIN_ACCOUNTS_CHANGED_ACTION}{@link Intent}, which applications can use to trigger another attempt to fetch an auth token. <p>If notifications are not enabled, it is the application's responsibility to launch the returned intent at some point to let the user enter credentials.  In either case, the result from this call will not wait for user action. <p>The value of the auth token type depends on the authenticator. Some services use different tokens to access different functionality -- for example, Google uses different auth tokens to access Gmail and Google Calendar for the same account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#USE_CREDENTIALS}.
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependentstring token, must not be null
 * @param options Authenticator-specific options for the request,may be null or empty
 * @param notifyAuthFailure True to add a notification to prompt theuser for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields on success: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> (Other authenticator-specific values may be returned.)  If the user must enter credentials, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.<p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if the authenticator failed to respond<li>  {@link OperationCanceledException} if the operation is canceled forany reason, incluidng the user canceling a credential request <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new auth token, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthToken(final Account account,final String authTokenType,final boolean notifyAuthFailure,AccountManagerCallback<Bundle> callback,Handler handler){
  if (account == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  return new AmsTask(null,handler,callback){
    public void doWork() throws RemoteException {
      mService.getAuthToken(mResponse,account,authTokenType,notifyAuthFailure,false,null);
    }
  }
.start();
}","/** 
 * Gets an auth token of the specified type for a particular account, optionally raising a notification if the user must enter credentials. This method is intended for background tasks and services where the user should not be immediately interrupted with a password prompt. <p>If a previously generated auth token is cached for this account and type, then it will be returned.  Otherwise, if we have saved credentials the server accepts, it will be used to generate a new auth token. Otherwise, an Intent will be returned which, when started, will prompt the user for a password.  If the notifyAuthFailure parameter is set, the same Intent will be associated with a status bar notification, alerting the user that they need to enter a password at some point. <p>If the intent is left in a notification, you will need to wait until the user gets around to entering a password before trying again, which could be hours or days or never.  When it does happen, the account manager will broadcast the   {@link #LOGIN_ACCOUNTS_CHANGED_ACTION}{@link Intent}, which applications can use to trigger another attempt to fetch an auth token. <p>If notifications are not enabled, it is the application's responsibility to launch the returned intent at some point to let the user enter credentials.  In either case, the result from this call will not wait for user action. <p>The value of the auth token type depends on the authenticator. Some services use different tokens to access different functionality -- for example, Google uses different auth tokens to access Gmail and Google Calendar for the same account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#USE_CREDENTIALS}.
 * @param account The account to fetch an auth token for
 * @param authTokenType The auth token type, an authenticator-dependentstring token, must not be null
 * @param notifyAuthFailure True to add a notification to prompt theuser for a password if necessary, false to leave that to the caller
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields on success: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> (Other authenticator-specific values may be returned.)  If the user must enter credentials, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.<p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if the authenticator failed to respond<li>  {@link OperationCanceledException} if the operation is canceled forany reason, incluidng the user canceling a credential request <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new auth token, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthToken(final Account account,final String authTokenType,final boolean notifyAuthFailure,AccountManagerCallback<Bundle> callback,Handler handler){
  if (account == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  return new AmsTask(null,handler,callback){
    public void doWork() throws RemoteException {
      mService.getAuthToken(mResponse,account,authTokenType,notifyAuthFailure,false,null);
    }
  }
.start();
}"
23050,"/** 
 * Asks the user to add an account of a specified type.  The authenticator for this account type processes this request with the appropriate user interface.  If the user does elect to create a new account, the account name is returned. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken}) this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,may be null or empty
 * @param activity The {@link Activity} context to use for launching a newauthenticator-defined sub-Activity to prompt the user to create an account; used only to call startActivity(); if null, the prompt will not be launched directly, but the necessary  {@link Intent}will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFeature} which resolves to a Bundle withthese fields if activity was specified and an account was created: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account created<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account</ul> If no activity was specified, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch theactual account creation process. <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling the creation process <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new account, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> addAccount(final String accountType,final String authTokenType,final String[] requiredFeatures,final Bundle addAccountOptions,final Activity activity,AccountManagerCallback<Bundle> callback,Handler handler){
  return new AmsTask(activity,handler,callback){
    public void doWork() throws RemoteException {
      if (accountType == null) {
        Log.e(TAG,""String_Node_Str"");
        set(new Bundle());
        return;
      }
      mService.addAcount(mResponse,accountType,authTokenType,requiredFeatures,activity != null,addAccountOptions);
    }
  }
.start();
}","/** 
 * Asks the user to add an account of a specified type.  The authenticator for this account type processes this request with the appropriate user interface.  If the user does elect to create a new account, the account name is returned. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken}) this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,may be null or empty
 * @param activity The {@link Activity} context to use for launching a newauthenticator-defined sub-Activity to prompt the user to create an account; used only to call startActivity(); if null, the prompt will not be launched directly, but the necessary  {@link Intent}will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withthese fields if activity was specified and an account was created: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account created<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account</ul> If no activity was specified, the returned Bundle contains only {@link #KEY_INTENT} with the {@link Intent} needed to launch theactual account creation process. <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling the creation process <li>  {@link IOException} if the authenticator experienced an I/O problemcreating a new account, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> addAccount(final String accountType,final String authTokenType,final String[] requiredFeatures,final Bundle addAccountOptions,final Activity activity,AccountManagerCallback<Bundle> callback,Handler handler){
  return new AmsTask(activity,handler,callback){
    public void doWork() throws RemoteException {
      if (accountType == null) {
        Log.e(TAG,""String_Node_Str"");
        set(new Bundle());
        return;
      }
      mService.addAcount(mResponse,accountType,authTokenType,requiredFeatures,activity != null,addAccountOptions);
    }
  }
.start();
}"
23051,"/** 
 * This convenience helper combines the functionality of  {@link #getAccountsByTypeAndFeatures},   {@link #getAuthToken}, and  {@link #addAccount}. <p>This method gets a list of the accounts matching the specified type and feature set; if there is exactly one, it is used; if there are more than one, the user is prompted to pick one; if there are none, the user is prompted to add one.  Finally, an auth token is acquired for the chosen account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The account type required(see  {@link getAccountsByType}), must not be null
 * @param authTokenType The desired auth token type(see  {@link #getAuthToken}), must not be null
 * @param features Required features for the account(see  {@link #getAccountsByTypeAndFeatures}), may be null or empty
 * @param activity The {@link Activity} context to use for launching newsub-Activities to prompt to add an account, select an account, and/or enter a password, as necessary; used only to call startActivity(); should not be null
 * @param addAccountOptions Authenticator-specific options to use foradding new accounts; may be null or empty
 * @param getAuthTokenOptions Authenticator-specific options to use forgetting auth tokens; may be null or empty
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling any operation <li>  {@link IOException} if the authenticator experienced an I/O problemupdating settings, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthTokenByFeatures(final String accountType,final String authTokenType,final String[] features,final Activity activity,final Bundle addAccountOptions,final Bundle getAuthTokenOptions,final AccountManagerCallback<Bundle> callback,final Handler handler){
  if (accountType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final GetAuthTokenByTypeAndFeaturesTask task=new GetAuthTokenByTypeAndFeaturesTask(accountType,authTokenType,features,activity,addAccountOptions,getAuthTokenOptions,callback,handler);
  task.start();
  return task;
}","/** 
 * This convenience helper combines the functionality of  {@link #getAccountsByTypeAndFeatures},   {@link #getAuthToken}, and  {@link #addAccount}. <p>This method gets a list of the accounts matching the specified type and feature set; if there is exactly one, it is used; if there are more than one, the user is prompted to pick one; if there are none, the user is prompted to add one.  Finally, an auth token is acquired for the chosen account. <p>This method may be called from any thread, but the returned  {@link AccountManagerFuture} must not be used on the main thread.<p>This method requires the caller to hold the permission {@link android.Manifest.permission#MANAGE_ACCOUNTS}.
 * @param accountType The account type required(see  {@link #getAccountsByType}), must not be null
 * @param authTokenType The desired auth token type(see  {@link #getAuthToken}), must not be null
 * @param features Required features for the account(see  {@link #getAccountsByTypeAndFeatures}), may be null or empty
 * @param activity The {@link Activity} context to use for launching newsub-Activities to prompt to add an account, select an account, and/or enter a password, as necessary; used only to call startActivity(); should not be null
 * @param addAccountOptions Authenticator-specific options to use foradding new accounts; may be null or empty
 * @param getAuthTokenOptions Authenticator-specific options to use forgetting auth tokens; may be null or empty
 * @param callback Callback to invoke when the request completes,null for no callback
 * @param handler {@link Handler} identifying the callback thread,null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle withat least the following fields: <ul> <li>  {@link #KEY_ACCOUNT_NAME} - the name of the account<li>  {@link #KEY_ACCOUNT_TYPE} - the type of the account<li>  {@link #KEY_AUTHTOKEN} - the auth token you wanted</ul> <p>If an error occurred,  {@link AccountManagerFuture#getResult()} throws:<ul> <li>  {@link AuthenticatorException} if no authenticator was registered forthis account type or the authenticator failed to respond <li>  {@link OperationCanceledException} if the operation was canceled forany reason, including the user canceling any operation <li>  {@link IOException} if the authenticator experienced an I/O problemupdating settings, usually because of network trouble </ul>
 */
public AccountManagerFuture<Bundle> getAuthTokenByFeatures(final String accountType,final String authTokenType,final String[] features,final Activity activity,final Bundle addAccountOptions,final Bundle getAuthTokenOptions,final AccountManagerCallback<Bundle> callback,final Handler handler){
  if (accountType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  if (authTokenType == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final GetAuthTokenByTypeAndFeaturesTask task=new GetAuthTokenByTypeAndFeaturesTask(accountType,authTokenType,features,activity,addAccountOptions,getAuthTokenOptions,callback,handler);
  task.start();
  return task;
}"
23052,"private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    Bundle oldState=r.state;
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        r.state=oldState;
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}"
23053,"private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}","private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ContextImpl appContext=new ContextImpl();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}"
23054,"public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    wl=new Wakelock();
    mWakelockStats.put(name,wl);
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}","public StopwatchTimer getWakeTimerLocked(String name,int type){
  Wakelock wl=mWakelockStats.get(name);
  if (wl == null) {
    if (mWakelockStats.size() > MAX_WAKELOCKS_PER_UID) {
      name=BATCHED_WAKELOCK_NAME;
      wl=mWakelockStats.get(name);
    }
    if (wl == null) {
      wl=new Wakelock();
      mWakelockStats.put(name,wl);
    }
  }
  StopwatchTimer t=null;
switch (type) {
case WAKE_TYPE_PARTIAL:
    t=wl.mTimerPartial;
  if (t == null) {
    t=new StopwatchTimer(WAKE_TYPE_PARTIAL,mPartialTimers,mUnpluggables);
    wl.mTimerPartial=t;
  }
return t;
case WAKE_TYPE_FULL:
t=wl.mTimerFull;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_FULL,mFullTimers,mUnpluggables);
wl.mTimerFull=t;
}
return t;
case WAKE_TYPE_WINDOW:
t=wl.mTimerWindow;
if (t == null) {
t=new StopwatchTimer(WAKE_TYPE_WINDOW,mWindowTimers,mUnpluggables);
wl.mTimerWindow=t;
}
return t;
default :
throw new IllegalArgumentException(""String_Node_Str"" + type);
}
}"
23055,"private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}","private PackageSetting getPackageLP(String name,PackageSetting origPackage,String realName,SharedUserSetting sharedUser,File codePath,File resourcePath,int vc,int pkgFlags,boolean create,boolean add){
  PackageSetting p=mPackages.get(name);
  if (p != null) {
    if (!p.codePath.equals(codePath)) {
      if ((p != null) && ((p.pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0)) {
        Log.w(TAG,""String_Node_Str"" + p.codePathString + ""String_Node_Str""+ codePath.toString());
      }
 else {
        Log.i(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ p.codePath+ ""String_Node_Str""+ codePath+ ""String_Node_Str"");
      }
    }
    if (p.sharedUser != sharedUser) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str""+ (p.sharedUser != null ? p.sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str""+ (sharedUser != null ? sharedUser.name : ""String_Node_Str"")+ ""String_Node_Str"");
      p=null;
    }
 else {
      if ((pkgFlags & ApplicationInfo.FLAG_SYSTEM) != 0) {
        p.pkgFlags|=ApplicationInfo.FLAG_SYSTEM;
      }
    }
  }
  if (p == null) {
    if (!create) {
      return null;
    }
    if (origPackage != null) {
      p=new PackageSetting(origPackage.name,name,codePath,resourcePath,vc,pkgFlags);
      if (DEBUG_UPGRADE)       Log.v(TAG,""String_Node_Str"" + name + ""String_Node_Str""+ origPackage.name);
      p.copyFrom(origPackage);
      p.sharedUser=origPackage.sharedUser;
      p.userId=origPackage.userId;
      p.origPackage=origPackage;
      mRenamedPackages.put(name,origPackage.name);
      name=origPackage.name;
      p.setTimeStamp(codePath.lastModified());
    }
 else {
      p=new PackageSetting(name,realName,codePath,resourcePath,vc,pkgFlags);
      p.setTimeStamp(codePath.lastModified());
      p.sharedUser=sharedUser;
      if (sharedUser != null) {
        p.userId=sharedUser.userId;
      }
 else       if (MULTIPLE_APPLICATION_UIDS) {
        PackageSetting dis=mDisabledSysPackages.get(name);
        if (dis != null) {
          if (dis.signatures.mSignatures != null) {
            p.signatures.mSignatures=dis.signatures.mSignatures.clone();
          }
          p.userId=dis.userId;
          p.grantedPermissions=new HashSet<String>(dis.grantedPermissions);
          p.loadedPermissions=new HashSet<String>(dis.loadedPermissions);
          p.disabledComponents=new HashSet<String>(dis.disabledComponents);
          p.enabledComponents=new HashSet<String>(dis.enabledComponents);
          addUserIdLP(p.userId,p,name);
        }
 else {
          p.userId=newUserIdLP(p);
        }
      }
 else {
        p.userId=FIRST_APPLICATION_UID;
      }
    }
    if (p.userId < 0) {
      reportSettingsProblem(Log.WARN,""String_Node_Str"" + name + ""String_Node_Str"");
      return null;
    }
    if (add) {
      addPackageSettingLP(p,name,sharedUser);
    }
  }
  return p;
}"
23056,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    boolean useEncryptedFSDir=useEncryptedFilesystemForPackage(p);
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName,useEncryptedFSDir);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
    schedulePackageCleaning(packageName);
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    if (deletedPs != null) {
      ArrayList<PreferredActivity> removed=new ArrayList<PreferredActivity>();
      for (      PreferredActivity pa : mSettings.mPreferredActivities.filterSet()) {
        if (pa.mActivity.getPackageName().equals(deletedPs.name)) {
          removed.add(pa);
        }
      }
      for (      PreferredActivity pa : removed) {
        mSettings.mPreferredActivities.removeFilter(pa);
      }
    }
    mSettings.writeLP();
  }
}"
23057,"private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}","private void revokeUriPermissionLocked(int callingUid,Uri uri,int modeFlags){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  final String authority=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(authority);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(authority,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + authority);
    return;
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
  }
  final List<String> SEGMENTS=uri.getPathSegments();
  if (SEGMENTS != null) {
    final int NS=SEGMENTS.size();
    int N=mGrantedUriPermissions.size();
    for (int i=0; i < N; i++) {
      HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.valueAt(i);
      Iterator<UriPermission> it=perms.values().iterator();
      toploop:       while (it.hasNext()) {
        UriPermission perm=it.next();
        Uri targetUri=perm.uri;
        if (!authority.equals(targetUri.getAuthority())) {
          continue;
        }
        List<String> targetSegments=targetUri.getPathSegments();
        if (targetSegments == null) {
          continue;
        }
        if (targetSegments.size() < NS) {
          continue;
        }
        for (int j=0; j < NS; j++) {
          if (!SEGMENTS.get(j).equals(targetSegments.get(j))) {
            continue toploop;
          }
        }
        if (DEBUG_URI_PERMISSION)         Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
        perm.clearModes(modeFlags);
        if (perm.modeFlags == 0) {
          it.remove();
        }
      }
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(mGrantedUriPermissions.keyAt(i));
        N--;
        i--;
      }
    }
  }
}"
23058,"private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}","private void removeUriPermissionIfNeededLocked(UriPermission perm){
  if ((perm.modeFlags & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION)) == 0) {
    HashMap<Uri,UriPermission> perms=mGrantedUriPermissions.get(perm.uid);
    if (perms != null) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + perm.uid + ""String_Node_Str""+ perm.uri);
      perms.remove(perm.uri);
      if (perms.size() == 0) {
        mGrantedUriPermissions.remove(perm.uid);
      }
    }
  }
}"
23059,"private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    return;
  }
  if (checkUriPermissionLocked(uri,targetUid,modeFlags)) {
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}","private void grantUriPermissionLocked(int callingUid,String targetPkg,Uri uri,int modeFlags,HistoryRecord activity){
  modeFlags&=(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
  if (modeFlags == 0) {
    return;
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  final IPackageManager pm=ActivityThread.getPackageManager();
  if (!ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + uri);
    return;
  }
  String name=uri.getAuthority();
  ProviderInfo pi=null;
  ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
  if (cpr != null) {
    pi=cpr.info;
  }
 else {
    try {
      pi=pm.resolveContentProvider(name,PackageManager.GET_URI_PERMISSION_PATTERNS);
    }
 catch (    RemoteException ex) {
    }
  }
  if (pi == null) {
    Log.w(TAG,""String_Node_Str"" + name);
    return;
  }
  int targetUid;
  try {
    targetUid=pm.getPackageUid(targetPkg);
    if (targetUid < 0) {
      if (DEBUG_URI_PERMISSION)       Log.v(TAG,""String_Node_Str"" + targetPkg);
      return;
    }
  }
 catch (  RemoteException ex) {
    return;
  }
  if (checkHoldingPermissionsLocked(pm,pi,targetUid,modeFlags)) {
    if (DEBUG_URI_PERMISSION)     Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
    return;
  }
  if (!pi.grantUriPermissions) {
    throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri+ ""String_Node_Str"");
  }
  if (pi.uriPermissionPatterns != null) {
    final int N=pi.uriPermissionPatterns.length;
    boolean allowed=false;
    for (int i=0; i < N; i++) {
      if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(uri.getPath())) {
        allowed=true;
        break;
      }
    }
    if (!allowed) {
      throw new SecurityException(""String_Node_Str"" + pi.packageName + ""String_Node_Str""+ pi.name+ ""String_Node_Str""+ uri);
    }
  }
  if (!checkHoldingPermissionsLocked(pm,pi,callingUid,modeFlags)) {
    if (!checkUriPermissionLocked(uri,callingUid,modeFlags)) {
      throw new SecurityException(""String_Node_Str"" + callingUid + ""String_Node_Str""+ uri);
    }
  }
  if (DEBUG_URI_PERMISSION)   Log.v(TAG,""String_Node_Str"" + targetPkg + ""String_Node_Str""+ uri);
  HashMap<Uri,UriPermission> targetUris=mGrantedUriPermissions.get(targetUid);
  if (targetUris == null) {
    targetUris=new HashMap<Uri,UriPermission>();
    mGrantedUriPermissions.put(targetUid,targetUris);
  }
  UriPermission perm=targetUris.get(uri);
  if (perm == null) {
    perm=new UriPermission(targetUid,uri);
    targetUris.put(uri,perm);
  }
  perm.modeFlags|=modeFlags;
  if (activity == null) {
    perm.globalModeFlags|=modeFlags;
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
    perm.readActivities.add(activity);
    if (activity.readUriPermissions == null) {
      activity.readUriPermissions=new HashSet<UriPermission>();
    }
    activity.readUriPermissions.add(perm);
  }
 else   if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
    perm.writeActivities.add(activity);
    if (activity.writeUriPermissions == null) {
      activity.writeUriPermissions=new HashSet<UriPermission>();
    }
    activity.writeUriPermissions.add(perm);
  }
}"
23060,"public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,-1,-1,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int startActivity(IApplicationThread caller,Intent intent,String resolvedType,Uri[] grantedUriPermissions,int grantedMode,IBinder resultTo,String resultWho,int requestCode,boolean onlyIfNeeded,boolean debug){
  if (intent != null && intent.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final boolean componentSpecified=intent.getComponent() != null;
  intent=new Intent(intent);
  ActivityInfo aInfo;
  try {
    ResolveInfo rInfo=ActivityThread.getPackageManager().resolveIntent(intent,resolvedType,PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS);
    aInfo=rInfo != null ? rInfo.activityInfo : null;
  }
 catch (  RemoteException e) {
    aInfo=null;
  }
  if (aInfo != null) {
    intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName,aInfo.name));
    if (debug) {
      if (!aInfo.processName.equals(""String_Node_Str"")) {
        setDebugApp(aInfo.processName,true,false);
      }
    }
  }
synchronized (this) {
    int callingPid;
    int callingUid;
    if (caller == null) {
      callingPid=Binder.getCallingPid();
      callingUid=Binder.getCallingUid();
    }
 else {
      callingPid=callingUid=-1;
    }
    final long origId=Binder.clearCallingIdentity();
    int res=startActivityLocked(caller,intent,resolvedType,grantedUriPermissions,grantedMode,aInfo,resultTo,resultWho,requestCode,callingPid,callingUid,onlyIfNeeded,componentSpecified);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}"
23061,"protected void finalize() throws Throwable {
  if (!canceled) {
synchronized (owner) {
      WeakReference<PendingIntentRecord> current=owner.mIntentSenderRecords.get(key);
      if (current == ref) {
        owner.mIntentSenderRecords.remove(key);
      }
    }
  }
}","protected void finalize() throws Throwable {
  try {
    if (!canceled) {
      owner.mHandler.sendMessage(owner.mHandler.obtainMessage(ActivityManagerService.FINALIZE_PENDING_INTENT_MSG,this));
    }
  }
  finally {
    super.finalize();
  }
}"
23062,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
          ams.setServiceForeground(name,ServiceRecord.this,localForegroundId,null,true);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23063,"public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RuntimeException e) {
          Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
        }
catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23064,"public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"" + ""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}","public void run(){
  INotificationManager inm=NotificationManager.getService();
  if (inm == null) {
    return;
  }
  try {
    inm.cancelNotification(localPackageName,localForegroundId);
  }
 catch (  RuntimeException e) {
    Log.w(ActivityManagerService.TAG,""String_Node_Str"",e);
  }
catch (  RemoteException e) {
  }
}"
23065,"private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  try {
    test_path=new File(test_path).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage());
  }
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}","private String getTestPath(){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  String test_path=LAYOUT_TESTS_ROOT;
  if (runner.mTestPath != null) {
    test_path+=runner.mTestPath;
  }
  test_path=new File(test_path).getAbsolutePath();
  Log.v(""String_Node_Str"",""String_Node_Str"" + test_path);
  return test_path;
}"
23066,"public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  try {
    this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getCanonicalPath();
  }
 catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
    return;
  }
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}","public void executeLayoutTests(boolean resume){
  LayoutTestsAutoRunner runner=(LayoutTestsAutoRunner)getInstrumentation();
  if (runner.mTestPath == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return;
  }
  this.mTestList=new Vector<String>();
  this.mTestPathPrefix=(new File(LAYOUT_TESTS_ROOT + runner.mTestPath)).getAbsolutePath();
  this.mRebaselineResults=runner.mRebaseline;
  int timeout=runner.mTimeoutInMillis;
  if (timeout <= 0) {
    timeout=DEFAULT_TIMEOUT_IN_MILLIS;
  }
  this.mResultRecorder=new MyTestRecorder(resume);
  if (!resume)   clearTestStatus();
  getTestList();
  if (resume)   resumeTestList();
  TestShellActivity activity=getActivity();
  activity.setDefaultDumpDataType(DumpDataType.DUMP_AS_TEXT);
  int addr=-1;
  try {
    addr=AdbUtils.resolve(""String_Node_Str"");
  }
 catch (  IOException ioe) {
    Log.w(LOGTAG,""String_Node_Str"",ioe);
  }
  if (addr == -1) {
    Log.w(LOGTAG,""String_Node_Str"");
  }
  for (int i=0; i < mTestList.size(); i++) {
    String s=mTestList.elementAt(i);
    FsUtils.updateTestStatus(TEST_STATUS_FILE,s);
    runTestAndWaitUntilDone(activity,s,runner.mTimeoutInMillis);
  }
  FsUtils.updateTestStatus(TEST_STATUS_FILE,""String_Node_Str"");
  ForwardService.getForwardService().stopForwardService();
  activity.finish();
}"
23067,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion == 39) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.def_screen_brightness_automatic_mode) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.System.SCREEN_BRIGHTNESS_MODE + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=40;
  }
  if (upgradeVersion == 40) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=41;
  }
  if (upgradeVersion == 41) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.HAPTIC_FEEDBACK_ENABLED + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultHapticSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=42;
  }
  if (upgradeVersion == 42) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.NOTIFICATION_LIGHT_PULSE,R.bool.def_notification_pulse);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=43;
  }
  if (upgradeVersion == 43) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,AudioManager.DEFAULT_STREAM_VOLUME[AudioManager.STREAM_BLUETOOTH_SCO]);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=44;
  }
  if (upgradeVersion == 44) {
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    upgradeVersion=45;
  }
  if (upgradeVersion == 45) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_PLAY_NOTIFICATION_SND + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_AUTOSTART + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_PROMPT + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.Secure.MOUNT_UMS_NOTIFY_ENABLED + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=46;
  }
  if (upgradeVersion == 46) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=47;
  }
  if (upgradeVersion == 47) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=48;
  }
  if (upgradeVersion == 48) {
    upgradeVersion=49;
  }
  if (upgradeVersion == 49) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadUISoundEffectsSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=50;
  }
  if (upgradeVersion == 50) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadBooleanSetting(stmt,Settings.System.SET_INSTALL_LOCATION,R.bool.set_install_location);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=51;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
    String wipeReason=oldVersion + ""String_Node_Str"" + upgradeVersion+ ""String_Node_Str""+ currentVersion;
    db.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + wipeReason + ""String_Node_Str"");
  }
}"
23068,"public boolean onKeyDown(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyDown(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}"
23069,"private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  int centerMedium=a.getResourceId(R.styleable.AlertDialog_centerMedium,R.drawable.popup_center_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView == null ? false : true;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}","private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}"
23070,"public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositiveMessage != null ? mButtonPositive : null;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegativeMessage != null ? mButtonNegative : null;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutralMessage != null ? mButtonNeutral : null;
default :
return null;
}
}","public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositive;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegative;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutral;
default :
return null;
}
}"
23071,"public boolean onKeyUp(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyUp(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}"
23072,"private boolean setupButtons(){
  View defaultButton=null;
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    defaultButton=mButtonPositive;
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNegative;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNeutral;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}","private boolean setupButtons(){
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}"
23073,"public boolean onKeyDown(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyDown(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}"
23074,"private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  int centerMedium=a.getResourceId(R.styleable.AlertDialog_centerMedium,R.drawable.popup_center_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView == null ? false : true;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}","private void setBackground(LinearLayout topPanel,LinearLayout contentPanel,View customPanel,boolean hasButtons,TypedArray a,boolean hasTitle,View buttonPanel){
  int fullDark=a.getResourceId(R.styleable.AlertDialog_fullDark,R.drawable.popup_full_dark);
  int topDark=a.getResourceId(R.styleable.AlertDialog_topDark,R.drawable.popup_top_dark);
  int centerDark=a.getResourceId(R.styleable.AlertDialog_centerDark,R.drawable.popup_center_dark);
  int bottomDark=a.getResourceId(R.styleable.AlertDialog_bottomDark,R.drawable.popup_bottom_dark);
  int fullBright=a.getResourceId(R.styleable.AlertDialog_fullBright,R.drawable.popup_full_bright);
  int topBright=a.getResourceId(R.styleable.AlertDialog_topBright,R.drawable.popup_top_bright);
  int centerBright=a.getResourceId(R.styleable.AlertDialog_centerBright,R.drawable.popup_center_bright);
  int bottomBright=a.getResourceId(R.styleable.AlertDialog_bottomBright,R.drawable.popup_bottom_bright);
  int bottomMedium=a.getResourceId(R.styleable.AlertDialog_bottomMedium,R.drawable.popup_bottom_medium);
  View[] views=new View[4];
  boolean[] light=new boolean[4];
  View lastView=null;
  boolean lastLight=false;
  int pos=0;
  if (hasTitle) {
    views[pos]=topPanel;
    light[pos]=false;
    pos++;
  }
  views[pos]=(contentPanel.getVisibility() == View.GONE) ? null : contentPanel;
  light[pos]=mListView != null;
  pos++;
  if (customPanel != null) {
    views[pos]=customPanel;
    light[pos]=mForceInverseBackground;
    pos++;
  }
  if (hasButtons) {
    views[pos]=buttonPanel;
    light[pos]=true;
  }
  boolean setView=false;
  for (pos=0; pos < views.length; pos++) {
    View v=views[pos];
    if (v == null) {
      continue;
    }
    if (lastView != null) {
      if (!setView) {
        lastView.setBackgroundResource(lastLight ? topBright : topDark);
      }
 else {
        lastView.setBackgroundResource(lastLight ? centerBright : centerDark);
      }
      setView=true;
    }
    lastView=v;
    lastLight=light[pos];
  }
  if (lastView != null) {
    if (setView) {
      lastView.setBackgroundResource(lastLight ? (hasButtons ? bottomMedium : bottomBright) : bottomDark);
    }
 else {
      lastView.setBackgroundResource(lastLight ? fullBright : fullDark);
    }
  }
  if ((mListView != null) && (mAdapter != null)) {
    mListView.setAdapter(mAdapter);
    if (mCheckedItem > -1) {
      mListView.setItemChecked(mCheckedItem,true);
      mListView.setSelection(mCheckedItem);
    }
  }
}"
23075,"public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositiveMessage != null ? mButtonPositive : null;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegativeMessage != null ? mButtonNegative : null;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutralMessage != null ? mButtonNeutral : null;
default :
return null;
}
}","public Button getButton(int whichButton){
switch (whichButton) {
case DialogInterface.BUTTON_POSITIVE:
    return mButtonPositive;
case DialogInterface.BUTTON_NEGATIVE:
  return mButtonNegative;
case DialogInterface.BUTTON_NEUTRAL:
return mButtonNeutral;
default :
return null;
}
}"
23076,"public boolean onKeyUp(int keyCode,KeyEvent event){
  if (mScrollView != null && mScrollView.executeKeyEvent(event))   return true;
  return false;
}","@SuppressWarnings({""String_Node_Str""}) public boolean onKeyUp(int keyCode,KeyEvent event){
  return mScrollView != null && mScrollView.executeKeyEvent(event);
}"
23077,"private boolean setupButtons(){
  View defaultButton=null;
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    defaultButton=mButtonPositive;
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNegative;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    if (defaultButton == null) {
      defaultButton=mButtonNeutral;
    }
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}","private boolean setupButtons(){
  int BIT_BUTTON_POSITIVE=1;
  int BIT_BUTTON_NEGATIVE=2;
  int BIT_BUTTON_NEUTRAL=4;
  int whichButtons=0;
  mButtonPositive=(Button)mWindow.findViewById(R.id.button1);
  mButtonPositive.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonPositiveText)) {
    mButtonPositive.setVisibility(View.GONE);
  }
 else {
    mButtonPositive.setText(mButtonPositiveText);
    mButtonPositive.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_POSITIVE;
  }
  mButtonNegative=(Button)mWindow.findViewById(R.id.button2);
  mButtonNegative.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNegativeText)) {
    mButtonNegative.setVisibility(View.GONE);
  }
 else {
    mButtonNegative.setText(mButtonNegativeText);
    mButtonNegative.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEGATIVE;
  }
  mButtonNeutral=(Button)mWindow.findViewById(R.id.button3);
  mButtonNeutral.setOnClickListener(mButtonHandler);
  if (TextUtils.isEmpty(mButtonNeutralText)) {
    mButtonNeutral.setVisibility(View.GONE);
  }
 else {
    mButtonNeutral.setText(mButtonNeutralText);
    mButtonNeutral.setVisibility(View.VISIBLE);
    whichButtons=whichButtons | BIT_BUTTON_NEUTRAL;
  }
  if (whichButtons == BIT_BUTTON_POSITIVE) {
    centerButton(mButtonPositive);
  }
 else   if (whichButtons == BIT_BUTTON_NEGATIVE) {
    centerButton(mButtonNeutral);
  }
 else   if (whichButtons == BIT_BUTTON_NEUTRAL) {
    centerButton(mButtonNeutral);
  }
  return whichButtons != 0;
}"
23078,"/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
  int numCursors=mManagedCursors.size();
  for (int i=0; i < numCursors; i++) {
    ManagedCursor c=mManagedCursors.get(i);
    if (c != null) {
      c.mCursor.close();
    }
  }
  mManagedCursors.clear();
}","/** 
 * Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called  {@link #finish} on it, or because the system is temporarily destroyingthis instance of the activity to save space.  You can distinguish between these two scenarios with the  {@link #isFinishing} method.<p><em>Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either  {@link #onPause} or{@link #onSaveInstanceState}, not here.</em> This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running.  There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. <p><em>Derived classes must call through to the super class's implementation of this method.  If they do not, an exception will be thrown.</em></p>
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */
protected void onDestroy(){
  mCalled=true;
  if (mManagedDialogs != null) {
    final int numDialogs=mManagedDialogs.size();
    for (int i=0; i < numDialogs; i++) {
      final ManagedDialog md=mManagedDialogs.valueAt(i);
      if (md.mDialog.isShowing()) {
        md.mDialog.dismiss();
      }
    }
    mManagedDialogs=null;
  }
synchronized (mManagedCursors) {
    int numCursors=mManagedCursors.size();
    for (int i=0; i < numCursors; i++) {
      ManagedCursor c=mManagedCursors.get(i);
      if (c != null) {
        c.mCursor.close();
      }
    }
    mManagedCursors.clear();
  }
}"
23079,"final void performRestart(){
  final int N=mManagedCursors.size();
  for (int i=0; i < N; i++) {
    ManagedCursor mc=mManagedCursors.get(i);
    if (mc.mReleased || mc.mUpdated) {
      mc.mCursor.requery();
      mc.mReleased=false;
      mc.mUpdated=false;
    }
  }
  if (mStopped) {
    mStopped=false;
    mCalled=false;
    mInstrumentation.callActivityOnRestart(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
    performStart();
  }
}","final void performRestart(){
synchronized (mManagedCursors) {
    final int N=mManagedCursors.size();
    for (int i=0; i < N; i++) {
      ManagedCursor mc=mManagedCursors.get(i);
      if (mc.mReleased || mc.mUpdated) {
        mc.mCursor.requery();
        mc.mReleased=false;
        mc.mUpdated=false;
      }
    }
  }
  if (mStopped) {
    mStopped=false;
    mCalled=false;
    mInstrumentation.callActivityOnRestart(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
    performStart();
  }
}"
23080,"final void performStop(){
  if (!mStopped) {
    if (mWindow != null) {
      mWindow.closeAllPanels();
    }
    mCalled=false;
    mInstrumentation.callActivityOnStop(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
    final int N=mManagedCursors.size();
    for (int i=0; i < N; i++) {
      ManagedCursor mc=mManagedCursors.get(i);
      if (!mc.mReleased) {
        mc.mCursor.deactivate();
        mc.mReleased=true;
      }
    }
    mStopped=true;
  }
  mResumed=false;
}","final void performStop(){
  if (!mStopped) {
    if (mWindow != null) {
      mWindow.closeAllPanels();
    }
    mCalled=false;
    mInstrumentation.callActivityOnStop(this);
    if (!mCalled) {
      throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
    }
synchronized (mManagedCursors) {
      final int N=mManagedCursors.size();
      for (int i=0; i < N; i++) {
        ManagedCursor mc=mManagedCursors.get(i);
        if (!mc.mReleased) {
          mc.mCursor.deactivate();
          mc.mReleased=true;
        }
      }
    }
    mStopped=true;
  }
  mResumed=false;
}"
23081,"public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
}","public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
  mKeyboardHelper.setVibratePattern(mLockPatternUtils.isTactileFeedbackEnabled() ? com.android.internal.R.array.config_virtualKeyVibePattern : 0);
}"
23082,"public void onPress(int primaryCode){
}","public void onPress(int primaryCode){
  if (mVibratePattern != null) {
    mVibrator.vibrate(mVibratePattern,-1);
  }
}"
23083,"public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
}","public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
  mVibrator=new Vibrator();
}"
23084,"/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23085,"/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23086,"/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23087,"/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23088,"/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise 
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}","/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}"
23089,"/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23090,"/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23091,"/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23092,"/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Float.
 * @param key the value to get
 * @return the Float value, or null if the value is missing or cannot be converted
 */
public Float getAsFloat(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).floatValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Float.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23093,"/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Byte.
 * @param key the value to get
 * @return the Byte value, or null if the value is missing or cannot be converted
 */
public Byte getAsByte(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).byteValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Byte.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23094,"/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to an Integer.
 * @param key the value to get
 * @return the Integer value, or null if the value is missing or cannot be converted
 */
public Integer getAsInteger(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).intValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Integer.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23095,"/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Long.
 * @param key the value to get
 * @return the Long value, or null if the value is missing or cannot be converted
 */
public Long getAsLong(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).longValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Long.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23096,"/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise 
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}","/** 
 * Returns true if this object has the named value.
 * @param key the value to check for
 * @return {@code true} if the value is present, {@code false} otherwise
 */
public boolean containsKey(String key){
  return mValues.containsKey(key);
}"
23097,"/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Double.
 * @param key the value to get
 * @return the Double value, or null if the value is missing or cannot be converted
 */
public Double getAsDouble(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).doubleValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Double.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23098,"/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Boolean.
 * @param key the value to get
 * @return the Boolean value, or null if the value is missing or cannot be converted
 */
public Boolean getAsBoolean(String key){
  Object value=mValues.get(key);
  try {
    return (Boolean)value;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      return Boolean.valueOf(value.toString());
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23099,"/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str"");
      return null;
    }
  }
}","/** 
 * Gets a value and converts it to a Short.
 * @param key the value to get
 * @return the Short value, or null if the value is missing or cannot be converted
 */
public Short getAsShort(String key){
  Object value=mValues.get(key);
  try {
    return value != null ? ((Number)value).shortValue() : null;
  }
 catch (  ClassCastException e) {
    if (value instanceof CharSequence) {
      try {
        return Short.valueOf(value.toString());
      }
 catch (      NumberFormatException e2) {
        Log.e(TAG,""String_Node_Str"" + value + ""String_Node_Str""+ key);
        return null;
      }
    }
 else {
      Log.e(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ value,e);
      return null;
    }
  }
}"
23100,"public void onPress(int primaryCode){
}","public void onPress(int primaryCode){
  if (mVibratePattern != null) {
    mVibrator.vibrate(mVibratePattern,-1);
  }
}"
23101,"public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
}","public PasswordEntryKeyboardHelper(Context context,KeyboardView keyboardView,View targetView){
  mContext=context;
  mTargetView=targetView;
  mKeyboardView=keyboardView;
  createKeyboards();
  mKeyboardView.setOnKeyboardActionListener(this);
  mVibrator=new Vibrator();
}"
23102,"public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
}","public PasswordUnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback){
  super(context);
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mCreatedWithKeyboardOpen=mUpdateMonitor.isKeyboardOpen();
  LayoutInflater layoutInflater=LayoutInflater.from(context);
  if (mUpdateMonitor.isInPortrait()) {
    layoutInflater.inflate(R.layout.keyguard_screen_password_portrait,this,true);
  }
 else {
    layoutInflater.inflate(R.layout.keyguard_screen_password_landscape,this,true);
  }
  boolean isAlpha=lockPatternUtils.getPasswordMode() == LockPatternUtils.MODE_PASSWORD;
  mKeyboardView=(PasswordEntryKeyboardView)findViewById(R.id.keyboard);
  mPasswordEntry=(EditText)findViewById(R.id.passwordEntry);
  mPasswordEntry.setOnEditorActionListener(this);
  mEmergencyCallButton=(TextView)findViewById(R.id.emergencyCall);
  mEmergencyCallButton.setOnClickListener(this);
  mUpdateMonitor.registerConfigurationChangeCallback(this);
  mLockPatternUtils=lockPatternUtils;
  mKeyboardHelper=new PasswordEntryKeyboardHelper(context,mKeyboardView,this);
  mKeyboardHelper.setKeyboardMode(isAlpha ? PasswordEntryKeyboardHelper.KEYBOARD_MODE_ALPHA : PasswordEntryKeyboardHelper.KEYBOARD_MODE_NUMERIC);
  mKeyboardView.setVisibility(mCreatedWithKeyboardOpen ? View.INVISIBLE : View.VISIBLE);
  mPasswordEntry.requestFocus();
  mKeyboardHelper.setVibratePattern(mLockPatternUtils.isTactileFeedbackEnabled() ? com.android.internal.R.array.config_virtualKeyVibePattern : 0);
}"
23103,"/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
    }
  }
}","/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
      i--;
    }
  }
}"
23104,"/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
    }
  }
}","/** 
 * Updates the state of   {@link android.view.accessibility.AccessibilityManager} clients.
 */
private void updateClientsLocked(){
  for (int i=0, count=mClients.size(); i < count; i++) {
    try {
      mClients.get(i).setEnabled(mIsEnabled);
    }
 catch (    RemoteException re) {
      mClients.remove(i);
      count--;
      i--;
    }
  }
}"
23105,"SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
  }
  nStatement=mCompiledSql.nStatement;
}","SQLiteProgram(SQLiteDatabase db,String sql){
  mDatabase=db;
  mSql=sql;
  db.acquireReference();
  db.addSQLiteClosable(this);
  this.nHandle=db.mNativeHandle;
  mCompiledSql=db.getCompiledStatementForSql(sql);
  if (mCompiledSql == null) {
    mCompiledSql=new SQLiteCompiledSql(db,sql);
    db.addToCompiledQueries(sql,mCompiledSql);
    mCompiledSql.acquire();
  }
 else {
    if (mCompiledSql.isInUse()) {
      mCompiledSql=new SQLiteCompiledSql(db,sql);
    }
 else {
      mCompiledSql.acquire();
    }
  }
  nStatement=mCompiledSql.nStatement;
}"
23106,"@Override protected void onAllReferencesReleasedFromContainer(){
  releaseCompiledSqlIfInCache();
  mDatabase.releaseReference();
}","@Override protected void onAllReferencesReleasedFromContainer(){
  releaseCompiledSqlIfNotInCache();
  mDatabase.releaseReference();
}"
23107,"@Override protected void onAllReferencesReleased(){
  releaseCompiledSqlIfInCache();
  mDatabase.releaseReference();
  mDatabase.removeSQLiteClosable(this);
}","@Override protected void onAllReferencesReleased(){
  releaseCompiledSqlIfNotInCache();
  mDatabase.releaseReference();
  mDatabase.removeSQLiteClosable(this);
}"
23108,"@MediumTest public void testInsertHelper() throws Exception {
  Cursor cur;
  ContentValues cv;
  long row;
  mDatabase.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  DatabaseUtils.InsertHelper ih=new DatabaseUtils.InsertHelper(mDatabase,""String_Node_Str"");
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",2345);
  cv.put(""String_Node_Str"",3456);
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(2345,cur.getLong(3));
  Assert.assertEquals(3456,cur.getLong(4));
  Assert.assertEquals(""String_Node_Str"",cur.getString(5));
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",6789);
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  row=ih.replace(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(6789,cur.getLong(3));
  ih.close();
}","@MediumTest public void testInsertHelper() throws Exception {
  Cursor cur;
  ContentValues cv;
  long row;
  mDatabase.execSQL(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  DatabaseUtils.InsertHelper ih=new DatabaseUtils.InsertHelper(mDatabase,""String_Node_Str"");
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cur.close();
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertNull(cur.getString(3));
  Assert.assertEquals(1234,cur.getLong(4));
  Assert.assertNull(cur.getString(5));
  cur.close();
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",2345);
  cv.put(""String_Node_Str"",3456);
  cv.put(""String_Node_Str"",""String_Node_Str"");
  row=ih.insert(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(2345,cur.getLong(3));
  Assert.assertEquals(3456,cur.getLong(4));
  Assert.assertEquals(""String_Node_Str"",cur.getString(5));
  cur.close();
  cv=new ContentValues();
  cv.put(""String_Node_Str"",""String_Node_Str"");
  cv.put(""String_Node_Str"",6789);
  row=ih.insert(cv);
  Assert.assertEquals(-1,row);
  row=ih.replace(cv);
  cur=mDatabase.rawQuery(""String_Node_Str"" + row,null);
  Assert.assertTrue(cur.moveToFirst());
  Assert.assertEquals(""String_Node_Str"",cur.getString(1));
  Assert.assertEquals(""String_Node_Str"",cur.getString(2));
  Assert.assertEquals(6789,cur.getLong(3));
  cur.close();
  ih.close();
}"
23109,"private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}","private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}"
23110,"public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}","public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}"
23111,"/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (LOGV) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}","/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (Config.DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}"
23112,"/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
  }
}","/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
}"
23113,"/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        manageServicesLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          updateClientsLocked();
        }
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}","/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          if (mIsEnabled) {
            updateClientsLocked();
          }
        }
        manageServicesLocked();
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}"
23114,"@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    manageServicesLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      updateClientsLocked();
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      if (mIsEnabled) {
        updateClientsLocked();
      }
    }
    manageServicesLocked();
  }
}"
23115,"/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}","/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  boolean isEnabled=mIsEnabled;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (isEnabled && enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}"
23116,"/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (LOGV) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}","/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (Config.DEBUG) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}"
23117,"private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}","private void init(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  if (!TextUtils.isEmpty(rruleStr) || !TextUtils.isEmpty(rdateStr)) {
    if (!TextUtils.isEmpty(rruleStr)) {
      String[] rruleStrs=rruleStr.split(RULE_SEPARATOR);
      rrules=new EventRecurrence[rruleStrs.length];
      for (int i=0; i < rruleStrs.length; ++i) {
        EventRecurrence rrule=new EventRecurrence();
        rrule.parse(rruleStrs[i]);
        rrules[i]=rrule;
      }
    }
    if (!TextUtils.isEmpty(rdateStr)) {
      rdates=parseRecurrenceDates(rdateStr);
    }
    if (!TextUtils.isEmpty(exruleStr)) {
      String[] exruleStrs=exruleStr.split(RULE_SEPARATOR);
      exrules=new EventRecurrence[exruleStrs.length];
      for (int i=0; i < exruleStrs.length; ++i) {
        EventRecurrence exrule=new EventRecurrence();
        exrule.parse(exruleStr);
        exrules[i]=exrule;
      }
    }
    if (!TextUtils.isEmpty(exdateStr)) {
      exdates=parseRecurrenceDates(exdateStr);
    }
  }
}"
23118,"public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr){
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}","public RecurrenceSet(String rruleStr,String rdateStr,String exruleStr,String exdateStr) throws EventRecurrence.InvalidFormatException {
  init(rruleStr,rdateStr,exruleStr,exdateStr);
}"
23119,"public void writeToParcel(Parcel parcel,int flags){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}","public void writeToParcel(Parcel parcel,int flagz){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}"
23120,"/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (LOGV) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}","/** 
 * Removes a dead service.
 * @param service The service.
 * @return True if the service was removed, false otherwise.
 */
private boolean removeDeadServiceLocked(Service service){
  mServices.remove(service);
  mHandler.removeMessages(service.mId);
  if (Config.DEBUG) {
    Log.i(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
  }
  if (mServices.isEmpty()) {
    mIsEnabled=false;
    updateClientsLocked();
  }
  return true;
}"
23121,"/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
  }
}","/** 
 * Creates a new instance.
 * @param context A {@link Context} instance.
 */
AccessibilityManagerService(Context context){
  mContext=context;
  mPackageManager=mContext.getPackageManager();
  mCaller=new HandlerCaller(context,this);
  registerPackageChangeAndBootCompletedBroadcastReceiver();
  registerSettingsContentObservers();
}"
23122,"/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        manageServicesLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          updateClientsLocked();
        }
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}","/** 
 * Registers a   {@link BroadcastReceiver} for the events ofadding/changing/removing/restarting a package and boot completion.
 */
private void registerPackageChangeAndBootCompletedBroadcastReceiver(){
  Context context=mContext;
  BroadcastReceiver broadcastReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
synchronized (mLock) {
        populateAccessibilityServiceListLocked();
        if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
          mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
          if (mIsEnabled) {
            updateClientsLocked();
          }
        }
        manageServicesLocked();
      }
    }
  }
;
  IntentFilter packageFilter=new IntentFilter();
  packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
  packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
  packageFilter.addDataScheme(""String_Node_Str"");
  context.registerReceiver(broadcastReceiver,packageFilter);
  IntentFilter sdFilter=new IntentFilter();
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE);
  sdFilter.addAction(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
  mContext.registerReceiver(broadcastReceiver,sdFilter);
  IntentFilter bootFiler=new IntentFilter(Intent.ACTION_BOOT_COMPLETED);
  mContext.registerReceiver(broadcastReceiver,bootFiler);
}"
23123,"@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    manageServicesLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      updateClientsLocked();
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
synchronized (mLock) {
    populateAccessibilityServiceListLocked();
    if (intent.getAction() == Intent.ACTION_BOOT_COMPLETED) {
      mIsEnabled=Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_ENABLED,0) == 1;
      if (mIsEnabled) {
        updateClientsLocked();
      }
    }
    manageServicesLocked();
  }
}"
23124,"/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}","/** 
 * Updates the state of each service by starting (or keeping running) enabled ones and stopping the rest.
 * @param installedServices All installed {@link AccessibilityService}s.
 * @param enabledServices The {@link ComponentName}s of the enabled services.
 */
private void updateServicesStateLocked(List<ServiceInfo> installedServices,Set<ComponentName> enabledServices){
  Map<ComponentName,Service> componentNameToServiceMap=mComponentNameToServiceMap;
  List<Service> services=mServices;
  boolean isEnabled=mIsEnabled;
  for (int i=0, count=installedServices.size(); i < count; i++) {
    ServiceInfo intalledService=installedServices.get(i);
    ComponentName componentName=new ComponentName(intalledService.packageName,intalledService.name);
    Service service=componentNameToServiceMap.get(componentName);
    if (isEnabled && enabledServices.contains(componentName)) {
      if (service == null) {
        new Service(componentName).bind();
      }
    }
 else {
      if (service != null) {
        service.unbind();
        componentNameToServiceMap.remove(componentName);
        services.remove(service);
      }
    }
  }
}"
23125,"/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (LOGV) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}","/** 
 * Notifies a service for a scheduled event given the event type.
 * @param service The service.
 * @param eventType The type of the event to dispatch.
 */
private void notifyEventListenerLocked(Service service,int eventType){
  IEventListener listener=service.mServiceInterface;
  AccessibilityEvent event=service.mPendingEvents.get(eventType);
  try {
    listener.onAccessibilityEvent(event);
    if (Config.DEBUG) {
      Log.i(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ listener);
    }
  }
 catch (  RemoteException re) {
    if (re instanceof DeadObjectException) {
      Log.w(LOG_TAG,""String_Node_Str"" + service.mService + ""String_Node_Str"");
synchronized (mLock) {
        removeDeadServiceLocked(service);
      }
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"" + event + ""String_Node_Str""+ service.mService,re);
    }
  }
}"
23126,"public void writeToParcel(Parcel parcel,int flags){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}","public void writeToParcel(Parcel parcel,int flagz){
  parcel.writeInt(eventTypes);
  parcel.writeStringArray(packageNames);
  parcel.writeInt(feedbackType);
  parcel.writeLong(notificationTimeout);
  parcel.writeInt(flags);
}"
23127,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}"
23128,"private void sendVolumeUpdate(int streamType){
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,getStreamVolume(streamType));
  if (streamType == AudioSystem.STREAM_BLUETOOTH_SCO) {
    mContext.sendBroadcast(intent);
  }
}","private void sendVolumeUpdate(int streamType,int oldIndex,int index){
  oldIndex=(oldIndex + 5) / 10;
  index=(index + 5) / 10;
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,index);
  intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE,oldIndex);
  mContext.sendBroadcast(intent);
}"
23129,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}"
23130,"/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#adjustStreamVolume(int,int,int) 
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  ensureValidDirection(direction);
  ensureValidStreamType(streamType);
  VolumeStreamState streamState=mStreamStates[STREAM_VOLUME_ALIAS[streamType]];
  final int oldIndex=streamState.mIndex;
  boolean adjustVolume=true;
  if ((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0 || streamType == AudioSystem.STREAM_RING) {
    adjustVolume=checkForRingerModeChange(oldIndex,direction);
  }
  if (adjustVolume && streamState.adjustIndex(direction)) {
    if (streamState.muteCount() == 0) {
      sendMsg(mAudioHandler,MSG_SET_SYSTEM_VOLUME,STREAM_VOLUME_ALIAS[streamType],SENDMSG_NOOP,0,0,streamState,0);
    }
  }
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,streamState.mIndex);
}"
23131,"private void sendVolumeUpdate(int streamType){
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,getStreamVolume(streamType));
  if (streamType == AudioSystem.STREAM_BLUETOOTH_SCO) {
    mContext.sendBroadcast(intent);
  }
}","private void sendVolumeUpdate(int streamType,int oldIndex,int index){
  oldIndex=(oldIndex + 5) / 10;
  index=(index + 5) / 10;
  Intent intent=new Intent(AudioManager.VOLUME_CHANGED_ACTION);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE,streamType);
  intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE,index);
  intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE,oldIndex);
  mContext.sendBroadcast(intent);
}"
23132,"/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType);
}","/** 
 * @see AudioManager#setStreamVolume(int,int,int) 
 */
public void setStreamVolume(int streamType,int index,int flags){
  ensureValidStreamType(streamType);
  final int oldIndex=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
  index=rescaleIndex(index * 10,streamType,STREAM_VOLUME_ALIAS[streamType]);
  setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,false,true);
  mVolumePanel.postVolumeChanged(streamType,flags);
  sendVolumeUpdate(streamType,oldIndex,index);
}"
23133,"/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}","/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE && AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}"
23134,"/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),0);
  return list != null && list.size() != 0;
}","/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognitionService.SERVICE_INTERFACE),0);
  return list != null && list.size() != 0;
}"
23135,"private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}","private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
mLastMoveTime=eventTime;
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mCurrentKeyTime < DEBOUNCE_TIME && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}"
23136,"private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}","private boolean onModifiedTouchEvent(MotionEvent me,boolean possiblePoly){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  final int action=me.getAction();
  final long eventTime=me.getEventTime();
  mOldEventTime=eventTime;
  int keyIndex=getKeyIndices(touchX,touchY,null);
  mPossiblePoly=possiblePoly;
  if (action == MotionEvent.ACTION_DOWN)   mSwipeTracker.clear();
  mSwipeTracker.addMovement(me);
  if (mAbortKey && action != MotionEvent.ACTION_DOWN && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen && action != MotionEvent.ACTION_CANCEL) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
repeatKey();
if (mAbortKey) {
mRepeatKeyIndex=NOT_A_KEY;
break;
}
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
mLastMoveTime=eventTime;
break;
case MotionEvent.ACTION_UP:
removeMessages();
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mCurrentKeyTime < DEBOUNCE_TIME && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(mCurrentKey,touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
case MotionEvent.ACTION_CANCEL:
removeMessages();
dismissPopupKeyboard();
mAbortKey=true;
showPreview(NOT_A_KEY);
invalidateKey(mCurrentKey);
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}"
23137,"/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),0);
  return list != null && list.size() != 0;
}","/** 
 * Checks whether a speech recognition service is available on the system. If this method returns   {@code false},   {@link RecognitionManager#createRecognitionManager(Context)} willfail.
 * @param context with which {@code RecognitionManager} will be created
 * @return {@code true} if recognition is available, {@code false} otherwise
 */
public static boolean isRecognitionAvailable(final Context context){
  final List<ResolveInfo> list=context.getPackageManager().queryIntentServices(new Intent(RecognitionService.SERVICE_INTERFACE),0);
  return list != null && list.size() != 0;
}"
23138,"/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}","/** 
 * Checks whether audio routing to the wired headset is on or off.
 * @return true if audio is being routed to/from wired headset;false if otherwise
 */
public boolean isWiredHeadsetOn(){
  if (AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE && AudioSystem.getDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,""String_Node_Str"") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
    return false;
  }
 else {
    return true;
  }
}"
23139,"public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}","public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}"
23140,"public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}","public void testBasicAccess() throws Exception {
  try {
    byte[] newKey=mSysKeyStore.generateNewKey(128,""String_Node_Str"",keyName);
    assertNotNull(newKey);
    byte[] recKey=mSysKeyStore.retrieveKey(keyName);
    assertEquals(newKey.length,recKey.length);
    for (int i=0; i < newKey.length; i++) {
      assertEquals(newKey[i],recKey[i]);
    }
    mSysKeyStore.deleteKey(keyName);
    byte[] nullKey=mSysKeyStore.retrieveKey(keyName);
    assertNull(nullKey);
    String newKeyStr=mSysKeyStore.generateNewKeyHexString(128,""String_Node_Str"",keyName2);
    assertNotNull(newKeyStr);
    String recKeyStr=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertEquals(newKeyStr,recKeyStr);
    mSysKeyStore.deleteKey(keyName2);
    String nullKey2=mSysKeyStore.retrieveKeyHexString(keyName2);
    assertNull(nullKey2);
  }
 catch (  Exception e) {
    fail();
  }
}"
23141,"/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}","/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}"
23142,"/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}","/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}"
23143,"/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}"
23144,"/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}"
23145,"/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}","/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}"
23146,"/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}"
23147,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}"
23148,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
23149,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
23150,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    String engine=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
            engine=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (engine.length() > 0) {
        setEngine(engine);
      }
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(SERVICE_TAG,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(SERVICE_TAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
      processSpeechQueue();
    }
  }
}"
23151,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(SERVICE_TAG,""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
23152,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        String engine=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_ENGINE)) {
                engine=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (engine.length() > 0) {
            setEngine(engine);
          }
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(SERVICE_TAG,""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(SERVICE_TAG,""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
          processSpeechQueue();
        }
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.setPriority(Thread.MAX_PRIORITY);
  synth.start();
}"
23153,"/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}","/** 
 * Cancels the speech recognition. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void cancel(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_CANCEL));
}"
23154,"/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}","/** 
 * Starts listening for speech. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 * @param recognizerIntent contains parameters for the recognition to be performed. The intentmay also contain optional extras, see  {@link RecognizerIntent}. If these values are not set explicitly, default values will be used by the recognizer.
 */
public void startListening(final Intent recognizerIntent){
  if (recognizerIntent == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkIsCalledFromMainThread();
  if (mConnection == null) {
    mConnection=new Connection();
    if (!mContext.bindService(new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH),mConnection,Context.BIND_AUTO_CREATE)) {
      Log.e(TAG,""String_Node_Str"");
      mConnection=null;
      mService=null;
      mListener.onError(ERROR_CLIENT);
      return;
    }
  }
  putMessage(Message.obtain(mHandler,MSG_START,recognizerIntent));
}"
23155,"/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStopMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.stopListening(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}"
23156,"/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleCancelMessage(){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.cancel(mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}"
23157,"/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  checkIsCommandAllowed();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}","/** 
 * Stops listening for speech. Speech captured so far will be recognized as if the user had stopped speaking at this point. Note that in the default case, this does not need to be called, as the speech endpointer will automatically stop the recognizer listening when it determines speech has completed. However, you can manipulate endpointer parameters directly using the intent extras defined in   {@link RecognizerIntent}, in which case you may sometimes want to manually call this method to stop listening sooner. Please note that  {@link #setRecognitionListener(RecognitionListener)} must be called beforehand, otherwise a{@link RuntimeException} will be thrown.
 */
public void stopListening(){
  checkIsCalledFromMainThread();
  putMessage(Message.obtain(mHandler,MSG_STOP));
}"
23158,"/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}","/** 
 * sends the actual message to the service 
 */
private void handleStartListening(Intent recognizerIntent){
  if (!checkOpenConnection()) {
    return;
  }
  try {
    mService.startListening(recognizerIntent,mListener);
    if (DBG)     Log.d(TAG,""String_Node_Str"");
  }
 catch (  final RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    mListener.onError(ERROR_CLIENT);
  }
}"
23159,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
int topOffset=motionView.getTop() - mMotionViewNewTop;
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}"
23160,"private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  if (distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}","private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  final boolean overscroll=mScrollY != 0;
  if (overscroll || distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=overscroll ? TOUCH_MODE_OVERSCROLL : TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}"
23161,"private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller.abortAnimation();
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}","private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    mCurrScroller.abortAnimation();
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}"
23162,"private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller.abortAnimation();
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}","private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  mCurrScroller.abortAnimation();
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}"
23163,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
int topOffset=motionView.getTop() - mMotionViewNewTop;
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return isClickable() || isLongClickable();
  }
  if (mFastScroller != null) {
    boolean intercepted=mFastScroller.onTouchEvent(ev);
    if (intercepted) {
      return true;
    }
  }
  final int action=ev.getAction();
  final int x=(int)ev.getX();
  final int y=(int)ev.getY();
  View v;
  int deltaY;
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
switch (action) {
case MotionEvent.ACTION_DOWN:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERFLING:
{
          mFlingRunnable.endFling();
          mTouchMode=TOUCH_MODE_OVERSCROLL;
          mLastY=y;
          mMotionCorrection=0;
          break;
        }
default :
{
        int motionPosition=pointToPosition(x,y);
        if (!mDataChanged) {
          if ((mTouchMode != TOUCH_MODE_FLING) && (motionPosition >= 0) && (getAdapter().isEnabled(motionPosition))) {
            mTouchMode=TOUCH_MODE_DOWN;
            if (mPendingCheckForTap == null) {
              mPendingCheckForTap=new CheckForTap();
            }
            postDelayed(mPendingCheckForTap,ViewConfiguration.getTapTimeout());
          }
 else {
            if (ev.getEdgeFlags() != 0 && motionPosition < 0) {
              return false;
            }
            createScrollingCache();
            mTouchMode=TOUCH_MODE_SCROLL;
            mMotionCorrection=0;
            motionPosition=findMotionRow(y);
            reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
          }
        }
        if (motionPosition >= 0) {
          v=getChildAt(motionPosition - mFirstPosition);
          mMotionViewOriginalTop=v.getTop();
          mMotionX=x;
          mMotionY=y;
          mMotionPosition=motionPosition;
        }
        mLastY=Integer.MIN_VALUE;
        break;
      }
  }
  break;
}
case MotionEvent.ACTION_MOVE:
{
deltaY=y - mMotionY;
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
  startScrollIfNeeded(deltaY);
break;
case TOUCH_MODE_SCROLL:
if (PROFILE_SCROLLING) {
if (!mScrollProfilingStarted) {
  Debug.startMethodTracing(""String_Node_Str"");
  mScrollProfilingStarted=true;
}
}
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
int motionViewPrevTop=0;
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionViewPrevTop=motionView.getTop();
}
if (incrementalDeltaY != 0) {
trackMotionScroll(deltaY,incrementalDeltaY);
}
motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
final int motionViewRealTop=motionView.getTop();
final int motionViewNewTop=mMotionViewNewTop;
if (motionViewRealTop != motionViewNewTop) {
  mScrollY-=incrementalDeltaY - (motionViewRealTop - motionViewPrevTop);
  mTouchMode=TOUCH_MODE_OVERSCROLL;
  invalidate();
}
}
mLastY=y;
}
break;
case TOUCH_MODE_OVERSCROLL:
if (y != mLastY) {
deltaY-=mMotionCorrection;
int incrementalDeltaY=mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;
final int oldScroll=mScrollY;
final int newScroll=oldScroll - incrementalDeltaY;
if ((oldScroll >= 0 && newScroll <= 0) || (oldScroll <= 0 && newScroll >= 0)) {
incrementalDeltaY=-newScroll;
mScrollY=0;
if (incrementalDeltaY != 0) {
trackMotionScroll(incrementalDeltaY,incrementalDeltaY);
}
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
mTouchMode=TOUCH_MODE_SCROLL;
final int motionPosition=findMotionRow(y);
mMotionCorrection=0;
motionView=getChildAt(motionPosition - mFirstPosition);
mMotionViewOriginalTop=motionView.getTop();
mMotionY=y;
mMotionPosition=motionPosition;
}
}
 else {
mScrollY-=incrementalDeltaY;
invalidate();
}
mLastY=y;
}
break;
}
break;
}
case MotionEvent.ACTION_UP:
{
switch (mTouchMode) {
case TOUCH_MODE_DOWN:
case TOUCH_MODE_TAP:
case TOUCH_MODE_DONE_WAITING:
final int motionPosition=mMotionPosition;
final View child=getChildAt(motionPosition - mFirstPosition);
if (child != null && !child.hasFocusable()) {
if (mTouchMode != TOUCH_MODE_DOWN) {
child.setPressed(false);
}
if (mPerformClick == null) {
mPerformClick=new PerformClick();
}
final AbsListView.PerformClick performClick=mPerformClick;
performClick.mChild=child;
performClick.mClickMotionPosition=motionPosition;
performClick.rememberWindowAttachCount();
mResurrectToPosition=motionPosition;
if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) {
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap : mPendingCheckForLongPress);
}
mLayoutMode=LAYOUT_NORMAL;
mTouchMode=TOUCH_MODE_TAP;
if (!mDataChanged) {
setSelectedPositionInt(mMotionPosition);
layoutChildren();
child.setPressed(true);
positionSelector(child);
setPressed(true);
if (mSelector != null) {
Drawable d=mSelector.getCurrent();
if (d != null && d instanceof TransitionDrawable) {
((TransitionDrawable)d).resetTransition();
}
}
postDelayed(new Runnable(){
public void run(){
child.setPressed(false);
setPressed(false);
if (!mDataChanged) {
post(performClick);
}
mTouchMode=TOUCH_MODE_REST;
}
}
,ViewConfiguration.getPressedStateDuration());
}
return true;
}
 else {
if (!mDataChanged) {
post(performClick);
}
}
}
mTouchMode=TOUCH_MODE_REST;
break;
case TOUCH_MODE_SCROLL:
final int childCount=getChildCount();
if (childCount > 0) {
if (mFirstPosition == 0 && getChildAt(0).getTop() >= mListPadding.top && mFirstPosition + childCount < mItemCount && getChildAt(childCount - 1).getBottom() <= getHeight() - mListPadding.bottom) {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
 else {
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
if (Math.abs(initialVelocity) > mMinimumVelocity) {
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
mFlingRunnable.start(-initialVelocity);
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
}
}
 else {
mTouchMode=TOUCH_MODE_REST;
reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
}
break;
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
final int initialVelocity=(int)velocityTracker.getYVelocity();
reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);
if (Math.abs(initialVelocity) > mMinimumVelocity) {
mFlingRunnable.startOverfling(-initialVelocity);
}
 else {
mFlingRunnable.startSpringback();
}
break;
}
setPressed(false);
invalidate();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (PROFILE_SCROLLING) {
if (mScrollProfilingStarted) {
Debug.stopMethodTracing();
mScrollProfilingStarted=false;
}
}
break;
}
case MotionEvent.ACTION_CANCEL:
{
switch (mTouchMode) {
case TOUCH_MODE_OVERSCROLL:
if (mFlingRunnable == null) {
mFlingRunnable=new FlingRunnable();
}
mFlingRunnable.startSpringback();
break;
case TOUCH_MODE_OVERFLING:
break;
default :
mTouchMode=TOUCH_MODE_REST;
setPressed(false);
View motionView=this.getChildAt(mMotionPosition - mFirstPosition);
if (motionView != null) {
motionView.setPressed(false);
}
clearScrollingCache();
final Handler handler=getHandler();
if (handler != null) {
handler.removeCallbacks(mPendingCheckForLongPress);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
}
}
return true;
}"
23164,"private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  if (distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}","private boolean startScrollIfNeeded(int deltaY){
  final int distance=Math.abs(deltaY);
  final boolean overscroll=mScrollY != 0;
  if (overscroll || distance > mTouchSlop) {
    createScrollingCache();
    mTouchMode=overscroll ? TOUCH_MODE_OVERSCROLL : TOUCH_MODE_SCROLL;
    mMotionCorrection=deltaY;
    final Handler handler=getHandler();
    if (handler != null) {
      handler.removeCallbacks(mPendingCheckForLongPress);
    }
    setPressed(false);
    View motionView=getChildAt(mMotionPosition - mFirstPosition);
    if (motionView != null) {
      motionView.setPressed(false);
    }
    reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
    requestDisallowInterceptTouchEvent(true);
    return true;
  }
  return false;
}"
23165,"private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller.abortAnimation();
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}","private boolean springback(int startX,int startY,int minX,int maxX,int minY,int maxY,Scroller scroller){
  int xoff=0;
  int yoff=0;
  if (startX < minX) {
    xoff=minX - startX;
  }
 else   if (startX > maxX) {
    xoff=maxX - startX;
  }
  if (startY < minY) {
    yoff=minY - startY;
  }
 else   if (startY > maxY) {
    yoff=maxY - startY;
  }
  if (xoff != 0 || yoff != 0) {
    mCurrScroller.abortAnimation();
    scroller.startScroll(startX,startY,xoff,yoff,SPRINGBACK_DURATION);
    mCurrScroller=scroller;
    mScrollMode=MODE_SPRINGBACK;
    return true;
  }
  return false;
}"
23166,"private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller.abortAnimation();
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}","private void overfling(int startx,int starty,float xvel,float yvel){
  Scroller scroller=mDecelScroller;
  final float durationSecs=(OVERFLING_DURATION / 1000.f);
  int dx=(int)(xvel * durationSecs) / 8;
  int dy=(int)(yvel * durationSecs) / 8;
  mCurrScroller.abortAnimation();
  scroller.startScroll(startx,starty,dx,dy,OVERFLING_DURATION);
  mCurrScroller=scroller;
  mScrollMode=MODE_OVERFLING;
}"
23167,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}"
23168,"void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}","void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}"
23169,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}"
23170,"void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}","void updateProvidersForPackageLocked(String pkgName){
  HashSet<String> keep=new HashSet<String>();
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      ComponentName component=new ComponentName(ai.packageName,ai.name);
      Provider p=lookupProviderLocked(component);
      if (p == null) {
        if (addProviderLocked(ri)) {
          keep.add(ai.name);
        }
      }
 else {
        Provider parsed=parseProviderInfoXml(component,ri);
        if (parsed != null) {
          keep.add(ai.name);
          p.info=parsed.info;
          final int M=p.instances.size();
          if (M > 0) {
            int[] appWidgetIds=getAppWidgetIds(p);
            cancelBroadcasts(p);
            registerForBroadcastsLocked(p,appWidgetIds);
            for (int j=0; j < M; j++) {
              AppWidgetId id=p.instances.get(j);
              if (id.host != null && id.host.callbacks != null) {
                try {
                  id.host.callbacks.providerChanged(id.appWidgetId,p.info);
                }
 catch (                RemoteException ex) {
                  id.host.callbacks=null;
                }
              }
            }
            sendUpdateIntentLocked(p,appWidgetIds);
          }
        }
      }
    }
  }
  N=mInstalledProviders.size();
  for (int i=N - 1; i >= 0; i--) {
    Provider p=mInstalledProviders.get(i);
    if (pkgName.equals(p.info.provider.getPackageName()) && !keep.contains(p.info.provider.getClassName())) {
      removeProviderLocked(i,p);
    }
  }
}"
23171,"void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}","void addProvidersForPackageLocked(String pkgName){
  Intent intent=new Intent(AppWidgetManager.ACTION_APPWIDGET_UPDATE);
  intent.setPackage(pkgName);
  List<ResolveInfo> broadcastReceivers=mPackageManager.queryBroadcastReceivers(intent,PackageManager.GET_META_DATA);
  final int N=broadcastReceivers.size();
  for (int i=0; i < N; i++) {
    ResolveInfo ri=broadcastReceivers.get(i);
    ActivityInfo ai=ri.activityInfo;
    if (pkgName.equals(ai.packageName)) {
      addProviderLocked(ri);
    }
  }
}"
23172,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  try {
    ((SearchManager)getContext().getSystemService(Context.SEARCH_SERVICE)).stopSearch();
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}"
23173,"private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}","private DateFormat getDateFormat(){
  String format=Settings.System.getString(getContext().getContentResolver(),Settings.System.DATE_FORMAT);
  if (format == null || ""String_Node_Str"".equals(format)) {
    return DateFormat.getDateInstance(DateFormat.SHORT);
  }
 else {
    return new SimpleDateFormat(format);
  }
}"
23174,"public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  try {
    ((SearchManager)getContext().getSystemService(Context.SEARCH_SERVICE)).stopSearch();
    if (mSearchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (mSearchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}","public void onClick(View v){
  if (mSearchable == null) {
    return;
  }
  SearchableInfo searchable=mSearchable;
  cancel();
  try {
    if (searchable.getVoiceSearchLaunchWebSearch()) {
      getContext().startActivity(mVoiceWebSearchIntent);
    }
 else     if (searchable.getVoiceSearchLaunchRecognizer()) {
      Intent appSearchIntent=createVoiceAppSearchIntent(mVoiceAppSearchIntent);
      getContext().startActivity(appSearchIntent);
    }
  }
 catch (  ActivityNotFoundException e) {
    Log.w(LOG_TAG,""String_Node_Str"");
  }
}"
23175,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}"
23176,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}"
23177,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}"
23178,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}"
23179,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}"
23180,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}"
23181,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}"
23182,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}"
23183,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}"
23184,"public void uploadToBufferObject(){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToBufferObject(mID);
}","public void uploadToBufferObject(){
  mRS.validate();
  mRS.nAllocationUploadToBufferObject(mID);
}"
23185,"public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}","public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}"
23186,"public void contextBindProgramFragmentStore(ProgramStore p){
  nContextBindProgramFragmentStore(safeID(p));
}","public void contextBindProgramFragmentStore(ProgramStore p){
  validate();
  nContextBindProgramFragmentStore(safeID(p));
}"
23187,"public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  nContextSetSurface(w,h,mSurface);
}","public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  validate();
  nContextSetSurface(w,h,mSurface);
}"
23188,"public void destroy(){
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","public void destroy(){
  validate();
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}"
23189,"public void contextBindProgramVertex(ProgramVertex p){
  nContextBindProgramVertex(safeID(p));
}","public void contextBindProgramVertex(ProgramVertex p){
  validate();
  nContextBindProgramVertex(safeID(p));
}"
23190,"public void contextBindProgramFragment(ProgramFragment p){
  nContextBindProgramFragment(safeID(p));
}","public void contextBindProgramFragment(ProgramFragment p){
  validate();
  nContextBindProgramFragment(safeID(p));
}"
23191,"void resume(){
  nContextResume();
}","void resume(){
  validate();
  nContextResume();
}"
23192,"public void contextBindRootScript(Script s){
  nContextBindRootScript(safeID(s));
}","public void contextBindRootScript(Script s){
  validate();
  nContextBindRootScript(safeID(s));
}"
23193,"public void contextDump(int bits){
  nContextDump(bits);
}","public void contextDump(int bits){
  validate();
  nContextDump(bits);
}"
23194,"void pause(){
  nContextPause();
}","void pause(){
  validate();
  nContextPause();
}"
23195,"public void contextBindProgramRaster(ProgramRaster p){
  nContextBindProgramRaster(safeID(p));
}","public void contextBindProgramRaster(ProgramRaster p){
  validate();
  nContextBindProgramRaster(safeID(p));
}"
23196,"public void contextSetPriority(Priority p){
  nContextSetPriority(p.mID);
}","public void contextSetPriority(Priority p){
  validate();
  nContextSetPriority(p.mID);
}"
23197,"@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}","@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case UPDATE_ZOOM_RANGE:
{
WebViewCore.RestoreState restoreState=(WebViewCore.RestoreState)msg.obj;
updateZoomRange(restoreState,getViewWidth(),restoreState.mScrollX,false);
break;
}
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
updateZoomRange(restoreState,viewSize.x,draw.mMinPrefWidth,true);
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}"
23198,"private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState)   return;
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}","private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState) {
    RestoreState restoreState=new RestoreState();
    restoreState.mMinScale=mViewportMinimumScale / 100.0f;
    restoreState.mMaxScale=mViewportMaximumScale / 100.0f;
    restoreState.mDefaultScale=adjust;
    restoreState.mMobileSite=false;
    restoreState.mScrollX=0;
    Message.obtain(mWebView.mPrivateHandler,WebView.UPDATE_ZOOM_RANGE,restoreState).sendToTarget();
    return;
  }
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}"
23199,"@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}","@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > SHOW_RECT_MSG_ID ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=TOUCH_SHORTPRESS_START_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  performLongClick();
  rebuildWebTextView();
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case UPDATE_ZOOM_RANGE:
{
WebViewCore.RestoreState restoreState=(WebViewCore.RestoreState)msg.obj;
updateZoomRange(restoreState,getViewWidth(),restoreState.mScrollX,false);
break;
}
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
if (restoreState != null) {
mInZoomOverview=false;
updateZoomRange(restoreState,viewSize.x,draw.mMinPrefWidth,true);
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / WebViewCore.DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case MOVE_OUT_OF_PLUGIN:
if (nativePluginEatsNavKey()) {
navHandledKey(msg.arg1,1,false,0,true);
}
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case UPDATE_CLIPBOARD:
String str=(String)msg.obj;
if (DebugFlags.WEB_VIEW) {
Log.v(LOGTAG,""String_Node_Str"" + str);
}
try {
IClipboard clip=IClipboard.Stub.asInterface(ServiceManager.getService(""String_Node_Str""));
clip.setClipboardText(str);
}
 catch (android.os.RemoteException e) {
Log.e(LOGTAG,""String_Node_Str"",e);
}
break;
case RESUME_WEBCORE_UPDATE:
WebViewCore.resumeUpdate(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=msg.arg2 == 1 ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(false);
}
break;
case SHOW_RECT_MSG_ID:
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
break;
default :
super.handleMessage(msg);
break;
}
}"
23200,"private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState)   return;
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}","private void setupViewport(boolean updateRestoreState){
  setViewportSettingsFromNative();
  float adjust=1.0f;
  if (mViewportDensityDpi == -1) {
    if (WebView.DEFAULT_SCALE_PERCENT != 100) {
      adjust=WebView.DEFAULT_SCALE_PERCENT / 100.0f;
    }
  }
 else   if (mViewportDensityDpi > 0) {
    adjust=(float)mContext.getResources().getDisplayMetrics().densityDpi / mViewportDensityDpi;
  }
  int defaultScale=(int)(adjust * 100);
  if (mViewportInitialScale > 0) {
    mViewportInitialScale*=adjust;
  }
  if (mViewportMinimumScale > 0) {
    mViewportMinimumScale*=adjust;
  }
  if (mViewportMaximumScale > 0) {
    mViewportMaximumScale*=adjust;
  }
  if (mViewportWidth == 0) {
    if (mViewportInitialScale == 0) {
      mViewportInitialScale=defaultScale;
    }
  }
  if (mViewportUserScalable == false) {
    mViewportInitialScale=defaultScale;
    mViewportMinimumScale=defaultScale;
    mViewportMaximumScale=defaultScale;
  }
  if (mViewportMinimumScale > mViewportInitialScale && mViewportInitialScale != 0) {
    mViewportMinimumScale=mViewportInitialScale;
  }
  if (mViewportMaximumScale > 0 && mViewportMaximumScale < mViewportInitialScale) {
    mViewportMaximumScale=mViewportInitialScale;
  }
  if (mViewportWidth < 0 && mViewportInitialScale == defaultScale) {
    mViewportWidth=0;
  }
  if (mViewportWidth != 0 && !updateRestoreState) {
    RestoreState restoreState=new RestoreState();
    restoreState.mMinScale=mViewportMinimumScale / 100.0f;
    restoreState.mMaxScale=mViewportMaximumScale / 100.0f;
    restoreState.mDefaultScale=adjust;
    restoreState.mMobileSite=false;
    restoreState.mScrollX=0;
    Message.obtain(mWebView.mPrivateHandler,WebView.UPDATE_ZOOM_RANGE,restoreState).sendToTarget();
    return;
  }
  int webViewWidth;
  int viewportWidth=mCurrentViewWidth;
  if (viewportWidth == 0) {
    webViewWidth=mWebView.getViewWidth();
    viewportWidth=(int)(webViewWidth / adjust);
    if (viewportWidth == 0) {
      Log.w(LOGTAG,""String_Node_Str"");
    }
  }
 else {
    webViewWidth=Math.round(viewportWidth * mCurrentViewScale);
  }
  mRestoreState=new RestoreState();
  mRestoreState.mMinScale=mViewportMinimumScale / 100.0f;
  mRestoreState.mMaxScale=mViewportMaximumScale / 100.0f;
  mRestoreState.mDefaultScale=adjust;
  mRestoreState.mScrollX=mRestoredX;
  mRestoreState.mScrollY=mRestoredY;
  mRestoreState.mMobileSite=(0 == mViewportWidth);
  if (mRestoredScale > 0) {
    mRestoreState.mViewScale=mRestoredScale / 100.0f;
    if (mRestoredScreenWidthScale > 0) {
      mRestoreState.mTextWrapScale=mRestoredScreenWidthScale / 100.0f;
    }
 else {
      mRestoreState.mTextWrapScale=mRestoreState.mViewScale;
    }
  }
 else {
    if (mViewportInitialScale > 0) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=mViewportInitialScale / 100.0f;
    }
 else     if (mViewportWidth > 0 && mViewportWidth < webViewWidth) {
      mRestoreState.mViewScale=mRestoreState.mTextWrapScale=(float)webViewWidth / mViewportWidth;
    }
 else {
      mRestoreState.mTextWrapScale=adjust;
      mRestoreState.mViewScale=0;
    }
  }
  if (mWebView.mHeightCanMeasure) {
    mWebView.mLastHeightSent=0;
    WebView.ViewSizeData data=new WebView.ViewSizeData();
    data.mWidth=mWebView.mLastWidthSent;
    data.mHeight=0;
    data.mTextWrapWidth=data.mWidth;
    data.mScale=-1.0f;
    data.mIgnoreHeight=false;
    data.mAnchorX=data.mAnchorY=0;
    mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
    mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
  }
 else   if (mSettings.getUseWideViewPort()) {
    if (viewportWidth == 0) {
      mWebView.mLastWidthSent=0;
    }
 else {
      WebView.ViewSizeData data=new WebView.ViewSizeData();
      data.mScale=mRestoreState.mViewScale == 0 ? (mRestoredScale > 0 ? mRestoredScale : mRestoreState.mTextWrapScale) : mRestoreState.mViewScale;
      data.mWidth=Math.round(webViewWidth / data.mScale);
      data.mHeight=mCurrentViewHeight * data.mWidth / viewportWidth;
      data.mTextWrapWidth=Math.round(webViewWidth / mRestoreState.mTextWrapScale);
      data.mIgnoreHeight=false;
      data.mAnchorX=data.mAnchorY=0;
      mEventHub.removeMessages(EventHub.VIEW_SIZE_CHANGED);
      mEventHub.sendMessageAtFrontOfQueue(Message.obtain(null,EventHub.VIEW_SIZE_CHANGED,data));
    }
  }
}"
23201,"public void uploadToBufferObject(){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToBufferObject(mID);
}","public void uploadToBufferObject(){
  mRS.validate();
  mRS.nAllocationUploadToBufferObject(mID);
}"
23202,"public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.validateSurface();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}","public void uploadToTexture(int baseMipLevel){
  mRS.validate();
  mRS.nAllocationUploadToTexture(mID,baseMipLevel);
}"
23203,"public void contextBindProgramFragmentStore(ProgramStore p){
  nContextBindProgramFragmentStore(safeID(p));
}","public void contextBindProgramFragmentStore(ProgramStore p){
  validate();
  nContextBindProgramFragmentStore(safeID(p));
}"
23204,"public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  nContextSetSurface(w,h,mSurface);
}","public void contextSetSurface(int w,int h,Surface sur){
  mSurface=sur;
  mWidth=w;
  mHeight=h;
  validate();
  nContextSetSurface(w,h,mSurface);
}"
23205,"public void destroy(){
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","public void destroy(){
  validate();
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}"
23206,"public void contextBindProgramVertex(ProgramVertex p){
  nContextBindProgramVertex(safeID(p));
}","public void contextBindProgramVertex(ProgramVertex p){
  validate();
  nContextBindProgramVertex(safeID(p));
}"
23207,"public void contextBindProgramFragment(ProgramFragment p){
  nContextBindProgramFragment(safeID(p));
}","public void contextBindProgramFragment(ProgramFragment p){
  validate();
  nContextBindProgramFragment(safeID(p));
}"
23208,"void resume(){
  nContextResume();
}","void resume(){
  validate();
  nContextResume();
}"
23209,"public void contextBindRootScript(Script s){
  nContextBindRootScript(safeID(s));
}","public void contextBindRootScript(Script s){
  validate();
  nContextBindRootScript(safeID(s));
}"
23210,"public void contextDump(int bits){
  nContextDump(bits);
}","public void contextDump(int bits){
  validate();
  nContextDump(bits);
}"
23211,"void pause(){
  nContextPause();
}","void pause(){
  validate();
  nContextPause();
}"
23212,"public void contextBindProgramRaster(ProgramRaster p){
  nContextBindProgramRaster(safeID(p));
}","public void contextBindProgramRaster(ProgramRaster p){
  validate();
  nContextBindProgramRaster(safeID(p));
}"
23213,"public void contextSetPriority(Priority p){
  nContextSetPriority(p.mID);
}","public void contextSetPriority(Priority p){
  validate();
  nContextSetPriority(p.mID);
}"
23214,"@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > RETURN_LABEL ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
    mPreventLongPress=false;
    mPreventDoubleTap=false;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=mFullScreenHolder == null ? TOUCH_SHORTPRESS_START_MODE : TOUCH_SHORTPRESS_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventLongPress) {
  mTouchMode=TOUCH_DONE_MODE;
  WebViewCore.TouchEventData ted=new WebViewCore.TouchEventData();
  ted.mAction=WebViewCore.ACTION_LONGPRESS;
  ted.mX=viewToContentX((int)mLastTouchX + mScrollX);
  ted.mY=viewToContentY((int)mLastTouchY + mScrollY);
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  if (mFullScreenHolder == null) {
    performLongClick();
    rebuildWebTextView();
  }
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=PREVENT_DRAG_NO;
mPreventLongPress=false;
mPreventDoubleTap=false;
}
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
boolean hasRestoreState=restoreState != null;
if (hasRestoreState) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
if (getSettings().getBuiltInZoomControls()) {
updateZoomButtonsEnabled();
}
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.min(sMaxViewportWidth,Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x)));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
if (draw.mFocusSizeChanged && inEditingMode()) {
mFocusSizeChanged=true;
}
if (hasRestoreState) {
mViewManager.postReadyToDrawAll();
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case RETURN_LABEL:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setHint((String)msg.obj);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
}
break;
case MOVE_OUT_OF_PLUGIN:
navHandledKey(msg.arg1,1,false,0,true);
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case IMMEDIATE_REPAINT_MSG_ID:
{
int updates=msg.arg1;
if (updates != 0) {
nativeUpdateLayers(mRootLayer,updates);
}
invalidate();
break;
}
case SET_ROOT_LAYER_MSG_ID:
{
int oldLayer=mRootLayer;
mRootLayer=msg.arg1;
if (oldLayer > 0) {
nativeDestroyLayer(oldLayer);
}
if (mRootLayer == 0) {
mLayersHaveAnimations=false;
}
if (mEvaluateThread != null) {
mEvaluateThread.cancel();
mEvaluateThread=null;
}
if (nativeLayersHaveAnimations(mRootLayer)) {
mLayersHaveAnimations=true;
mEvaluateThread=new EvaluateLayersAnimations();
mEvaluateThread.start();
}
invalidate();
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case RESUME_WEBCORE_PRIORITY:
WebViewCore.resumePriority(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=(msg.arg2 & TOUCH_PREVENT_DRAG) == TOUCH_PREVENT_DRAG ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
 else {
mPreventLongPress=(msg.arg2 & TOUCH_PREVENT_LONGPRESS) == TOUCH_PREVENT_LONGPRESS;
mPreventDoubleTap=(msg.arg2 & TOUCH_PREVENT_DOUBLETAP) == TOUCH_PREVENT_DOUBLETAP;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(1 == msg.arg2);
}
break;
case FIND_AGAIN:
if (mFindIsUp) {
findAll(mLastFind);
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case DO_MOTION_UP:
doMotionUp(msg.arg1,msg.arg2);
break;
case SHOW_FULLSCREEN:
{
WebViewCore.PluginFullScreenData data=(WebViewCore.PluginFullScreenData)msg.obj;
if (data.mNpp != 0 && data.mView != null) {
if (mFullScreenHolder != null) {
Log.w(LOGTAG,""String_Node_Str"");
mFullScreenHolder.dismiss();
}
mFullScreenHolder=new PluginFullScreenHolder(WebView.this,data.mNpp);
data.mView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.FILL_PARENT));
mFullScreenHolder.setContentView(data.mView);
mFullScreenHolder.setCancelable(false);
mFullScreenHolder.setCanceledOnTouchOutside(false);
mFullScreenHolder.show();
}
 else if (mFullScreenHolder == null) {
break;
}
int x=contentToViewX(data.mDocX);
int y=contentToViewY(data.mDocY);
int width=contentToViewDimension(data.mDocWidth);
int height=contentToViewDimension(data.mDocHeight);
int viewWidth=getViewWidth();
int viewHeight=getViewHeight();
int newX=mScrollX;
int newY=mScrollY;
if (x < mScrollX) {
newX=x + (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
 else if (x + width > mScrollX + viewWidth) {
newX=x + width - viewWidth - (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
if (y < mScrollY) {
newY=y + (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
 else if (y + height > mScrollY + viewHeight) {
newY=y + height - viewHeight - (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
scrollTo(newX,newY);
if (width > viewWidth || height > viewHeight) {
mZoomCenterX=viewWidth * .5f;
mZoomCenterY=viewHeight * .5f;
setNewZoomScale(mActualScale / Math.max((float)width / viewWidth,(float)height / viewHeight),false,false);
}
mFullScreenHolder.updateBound(contentToViewX(data.mDocX) - mScrollX,contentToViewY(data.mDocY) - mScrollY,contentToViewDimension(data.mDocWidth),contentToViewDimension(data.mDocHeight));
}
break;
case HIDE_FULLSCREEN:
if (mFullScreenHolder != null) {
mFullScreenHolder.dismiss();
mFullScreenHolder=null;
}
break;
case DOM_FOCUS_CHANGED:
if (inEditingMode()) {
nativeClearCursor();
rebuildWebTextView();
}
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
}
break;
default :
super.handleMessage(msg);
break;
}
}","@Override public void handleMessage(Message msg){
  if (DebugFlags.WEB_VIEW && msg.what != INVAL_RECT_MSG_ID) {
    Log.v(LOGTAG,msg.what < REMEMBER_PASSWORD || msg.what > RETURN_LABEL ? Integer.toString(msg.what) : HandlerDebugString[msg.what - REMEMBER_PASSWORD]);
  }
  if (mWebViewCore == null) {
    return;
  }
switch (msg.what) {
case REMEMBER_PASSWORD:
{
      mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""),msg.getData().getString(""String_Node_Str""));
      ((Message)msg.obj).sendToTarget();
      break;
    }
case NEVER_REMEMBER_PASSWORD:
{
    mDatabase.setUsernamePassword(msg.getData().getString(""String_Node_Str""),null,null);
    ((Message)msg.obj).sendToTarget();
    break;
  }
case SWITCH_TO_SHORTPRESS:
{
  if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
    mPreventDrag=PREVENT_DRAG_NO;
    mPreventLongPress=false;
    mPreventDoubleTap=false;
  }
  if (mTouchMode == TOUCH_INIT_MODE) {
    mTouchMode=mFullScreenHolder == null ? TOUCH_SHORTPRESS_START_MODE : TOUCH_SHORTPRESS_MODE;
    updateSelection();
  }
 else   if (mTouchMode == TOUCH_DOUBLE_TAP_MODE) {
    mTouchMode=TOUCH_DONE_MODE;
  }
  break;
}
case SWITCH_TO_LONGPRESS:
{
if (mPreventLongPress) {
  mTouchMode=TOUCH_DONE_MODE;
  WebViewCore.TouchEventData ted=new WebViewCore.TouchEventData();
  ted.mAction=WebViewCore.ACTION_LONGPRESS;
  ted.mX=viewToContentX((int)mLastTouchX + mScrollX);
  ted.mY=viewToContentY((int)mLastTouchY + mScrollY);
  mWebViewCore.sendMessage(EventHub.TOUCH_EVENT,ted);
}
 else if (mPreventDrag == PREVENT_DRAG_NO) {
  mTouchMode=TOUCH_DONE_MODE;
  if (mFullScreenHolder == null) {
    performLongClick();
    rebuildWebTextView();
  }
}
break;
}
case RELEASE_SINGLE_TAP:
{
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=PREVENT_DRAG_NO;
mPreventLongPress=false;
mPreventDoubleTap=false;
}
if (mPreventDrag == PREVENT_DRAG_NO) {
mTouchMode=TOUCH_DONE_MODE;
doShortPress();
}
break;
}
case SCROLL_BY_MSG_ID:
setContentScrollBy(msg.arg1,msg.arg2,(Boolean)msg.obj);
break;
case SYNC_SCROLL_TO_MSG_ID:
if (mUserScroll) {
mUserScroll=false;
break;
}
case SCROLL_TO_MSG_ID:
if (setContentScrollTo(msg.arg1,msg.arg2)) {
mUserScroll=false;
mWebViewCore.sendMessage(EventHub.SYNC_SCROLL,msg.arg1,msg.arg2);
}
break;
case SPAWN_SCROLL_TO_MSG_ID:
spawnContentScrollTo(msg.arg1,msg.arg2);
break;
case NEW_PICTURE_MSG_ID:
{
WebSettings settings=mWebViewCore.getSettings();
final int viewWidth=getViewWidth();
final WebViewCore.DrawData draw=(WebViewCore.DrawData)msg.obj;
final Point viewSize=draw.mViewPoint;
boolean useWideViewport=settings.getUseWideViewPort();
WebViewCore.RestoreState restoreState=draw.mRestoreState;
boolean hasRestoreState=restoreState != null;
if (hasRestoreState) {
mInZoomOverview=false;
if (restoreState.mMinScale == 0) {
if (restoreState.mMobileSite) {
if (draw.mMinPrefWidth > Math.max(0,draw.mViewPoint.x)) {
mMinZoomScale=(float)viewWidth / draw.mMinPrefWidth;
mMinZoomScaleFixed=false;
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
}
 else {
mMinZoomScale=restoreState.mDefaultScale;
mMinZoomScaleFixed=true;
}
}
 else {
mMinZoomScale=DEFAULT_MIN_ZOOM_SCALE;
mMinZoomScaleFixed=false;
}
}
 else {
mMinZoomScale=restoreState.mMinScale;
mMinZoomScaleFixed=true;
}
if (restoreState.mMaxScale == 0) {
mMaxZoomScale=DEFAULT_MAX_ZOOM_SCALE;
}
 else {
mMaxZoomScale=restoreState.mMaxScale;
}
if (mInitialScaleInPercent > 0) {
setNewZoomScale(mInitialScaleInPercent / 100.0f,mInitialScaleInPercent != mTextWrapScale * 100,false);
}
 else if (restoreState.mViewScale > 0) {
mTextWrapScale=restoreState.mTextWrapScale;
setNewZoomScale(restoreState.mViewScale,false,false);
}
 else {
mInZoomOverview=useWideViewport && settings.getLoadWithOverviewMode();
float scale;
if (mInZoomOverview) {
scale=(float)viewWidth / DEFAULT_VIEWPORT_WIDTH;
}
 else {
scale=restoreState.mTextWrapScale;
}
setNewZoomScale(scale,Math.abs(scale - mTextWrapScale) >= 0.01f,false);
}
setContentScrollTo(restoreState.mScrollX,restoreState.mScrollY);
clearTextEntry();
if (getSettings().getBuiltInZoomControls()) {
updateZoomButtonsEnabled();
}
}
final boolean updateLayout=viewSize.x == mLastWidthSent && viewSize.y == mLastHeightSent;
recordNewContentSize(draw.mWidthHeight.x,draw.mWidthHeight.y + (mFindIsUp ? mFindHeight : 0),updateLayout);
if (DebugFlags.WEB_VIEW) {
Rect b=draw.mInvalRegion.getBounds();
Log.v(LOGTAG,""String_Node_Str"" + b.left + ""String_Node_Str""+ b.top+ ""String_Node_Str""+ b.right+ ""String_Node_Str""+ b.bottom+ ""String_Node_Str"");
}
invalidateContentRect(draw.mInvalRegion.getBounds());
if (mPictureListener != null) {
mPictureListener.onNewPicture(WebView.this,capturePicture());
}
if (useWideViewport) {
mZoomOverviewWidth=Math.min(sMaxViewportWidth,Math.max((int)(viewWidth / mDefaultScale),Math.max(draw.mMinPrefWidth,draw.mViewPoint.x)));
}
if (!mMinZoomScaleFixed) {
mMinZoomScale=(float)viewWidth / mZoomOverviewWidth;
}
if (!mDrawHistory && mInZoomOverview) {
if (Math.abs((viewWidth * mInvActualScale) - mZoomOverviewWidth) > 1) {
setNewZoomScale((float)viewWidth / mZoomOverviewWidth,Math.abs(mActualScale - mTextWrapScale) < 0.01f,false);
}
}
if (draw.mFocusSizeChanged && inEditingMode()) {
mFocusSizeChanged=true;
}
if (hasRestoreState) {
mViewManager.postReadyToDrawAll();
}
break;
}
case WEBCORE_INITIALIZED_MSG_ID:
nativeCreate(msg.arg1);
break;
case UPDATE_TEXTFIELD_TEXT_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
if (msg.getData().getBoolean(""String_Node_Str"")) {
Spannable text=(Spannable)mWebTextView.getText();
int start=Selection.getSelectionStart(text);
int end=Selection.getSelectionEnd(text);
mWebTextView.setInPassword(true);
Spannable pword=(Spannable)mWebTextView.getText();
Selection.setSelection(pword,start,end);
}
 else if (msg.arg2 == mTextGeneration) {
mWebTextView.setTextAndKeepSelection((String)msg.obj);
}
}
break;
case UPDATE_TEXT_SELECTION_MSG_ID:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1) && msg.arg2 == mTextGeneration) {
WebViewCore.TextSelectionData tData=(WebViewCore.TextSelectionData)msg.obj;
mWebTextView.setSelectionFromWebKit(tData.mStart,tData.mEnd);
}
break;
case RETURN_LABEL:
if (inEditingMode() && mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setHint((String)msg.obj);
InputMethodManager imm=InputMethodManager.peekInstance();
if (imm != null && imm.isActive(mWebTextView)) {
imm.restartInput(mWebTextView);
}
}
break;
case MOVE_OUT_OF_PLUGIN:
navHandledKey(msg.arg1,1,false,0,true);
break;
case UPDATE_TEXT_ENTRY_MSG_ID:
if (inEditingMode() && nativeCursorIsTextInput()) {
mWebTextView.bringIntoView();
rebuildWebTextView();
}
break;
case CLEAR_TEXT_ENTRY:
clearTextEntry();
break;
case INVAL_RECT_MSG_ID:
{
Rect r=(Rect)msg.obj;
if (r == null) {
invalidate();
}
 else {
viewInvalidate(r.left,r.top,r.right,r.bottom);
}
break;
}
case IMMEDIATE_REPAINT_MSG_ID:
{
int updates=msg.arg1;
if (updates != 0) {
nativeUpdateLayers(updates);
}
invalidate();
break;
}
case SET_ROOT_LAYER_MSG_ID:
{
int oldLayer=mRootLayer;
mRootLayer=msg.arg1;
if (oldLayer > 0) {
nativeDestroyLayer(oldLayer);
}
if (mRootLayer == 0) {
mLayersHaveAnimations=false;
}
if (mEvaluateThread != null) {
mEvaluateThread.cancel();
mEvaluateThread=null;
}
if (nativeLayersHaveAnimations(mRootLayer)) {
mLayersHaveAnimations=true;
mEvaluateThread=new EvaluateLayersAnimations();
mEvaluateThread.start();
}
invalidate();
break;
}
case REQUEST_FORM_DATA:
AutoCompleteAdapter adapter=(AutoCompleteAdapter)msg.obj;
if (mWebTextView.isSameTextField(msg.arg1)) {
mWebTextView.setAdapterCustom(adapter);
}
break;
case RESUME_WEBCORE_PRIORITY:
WebViewCore.resumePriority(mWebViewCore);
break;
case LONG_PRESS_CENTER:
mGotCenterDown=false;
mTrackballDown=false;
if (getParent() != null) {
performLongClick();
}
break;
case WEBCORE_NEED_TOUCH_EVENTS:
mForwardTouchEvents=(msg.arg1 != 0);
break;
case PREVENT_TOUCH_ID:
if (msg.arg1 == MotionEvent.ACTION_DOWN) {
if (mPreventDrag == PREVENT_DRAG_MAYBE_YES) {
mPreventDrag=(msg.arg2 & TOUCH_PREVENT_DRAG) == TOUCH_PREVENT_DRAG ? PREVENT_DRAG_YES : PREVENT_DRAG_NO;
if (mPreventDrag == PREVENT_DRAG_YES) {
mTouchMode=TOUCH_DONE_MODE;
}
 else {
mPreventLongPress=(msg.arg2 & TOUCH_PREVENT_LONGPRESS) == TOUCH_PREVENT_LONGPRESS;
mPreventDoubleTap=(msg.arg2 & TOUCH_PREVENT_DOUBLETAP) == TOUCH_PREVENT_DOUBLETAP;
}
}
}
break;
case REQUEST_KEYBOARD:
if (msg.arg1 == 0) {
hideSoftKeyboard();
}
 else {
displaySoftKeyboard(1 == msg.arg2);
}
break;
case FIND_AGAIN:
if (mFindIsUp) {
findAll(mLastFind);
}
break;
case DRAG_HELD_MOTIONLESS:
mHeldMotionless=MOTIONLESS_TRUE;
invalidate();
case AWAKEN_SCROLL_BARS:
if (mTouchMode == TOUCH_DRAG_MODE && mHeldMotionless == MOTIONLESS_TRUE) {
awakenScrollBars(ViewConfiguration.getScrollDefaultDelay(),false);
mPrivateHandler.sendMessageDelayed(mPrivateHandler.obtainMessage(AWAKEN_SCROLL_BARS),ViewConfiguration.getScrollDefaultDelay());
}
break;
case DO_MOTION_UP:
doMotionUp(msg.arg1,msg.arg2);
break;
case SHOW_FULLSCREEN:
{
WebViewCore.PluginFullScreenData data=(WebViewCore.PluginFullScreenData)msg.obj;
if (data.mNpp != 0 && data.mView != null) {
if (mFullScreenHolder != null) {
Log.w(LOGTAG,""String_Node_Str"");
mFullScreenHolder.dismiss();
}
mFullScreenHolder=new PluginFullScreenHolder(WebView.this,data.mNpp);
data.mView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.FILL_PARENT));
mFullScreenHolder.setContentView(data.mView);
mFullScreenHolder.setCancelable(false);
mFullScreenHolder.setCanceledOnTouchOutside(false);
mFullScreenHolder.show();
}
 else if (mFullScreenHolder == null) {
break;
}
int x=contentToViewX(data.mDocX);
int y=contentToViewY(data.mDocY);
int width=contentToViewDimension(data.mDocWidth);
int height=contentToViewDimension(data.mDocHeight);
int viewWidth=getViewWidth();
int viewHeight=getViewHeight();
int newX=mScrollX;
int newY=mScrollY;
if (x < mScrollX) {
newX=x + (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
 else if (x + width > mScrollX + viewWidth) {
newX=x + width - viewWidth - (width > viewWidth ? (width - viewWidth) / 2 : 0);
}
if (y < mScrollY) {
newY=y + (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
 else if (y + height > mScrollY + viewHeight) {
newY=y + height - viewHeight - (height > viewHeight ? (height - viewHeight) / 2 : 0);
}
scrollTo(newX,newY);
if (width > viewWidth || height > viewHeight) {
mZoomCenterX=viewWidth * .5f;
mZoomCenterY=viewHeight * .5f;
setNewZoomScale(mActualScale / Math.max((float)width / viewWidth,(float)height / viewHeight),false,false);
}
mFullScreenHolder.updateBound(contentToViewX(data.mDocX) - mScrollX,contentToViewY(data.mDocY) - mScrollY,contentToViewDimension(data.mDocWidth),contentToViewDimension(data.mDocHeight));
}
break;
case HIDE_FULLSCREEN:
if (mFullScreenHolder != null) {
mFullScreenHolder.dismiss();
mFullScreenHolder=null;
}
break;
case DOM_FOCUS_CHANGED:
if (inEditingMode()) {
nativeClearCursor();
rebuildWebTextView();
}
break;
case SHOW_RECT_MSG_ID:
{
WebViewCore.ShowRectData data=(WebViewCore.ShowRectData)msg.obj;
int x=mScrollX;
int left=contentToViewDimension(data.mLeft);
int width=contentToViewDimension(data.mWidth);
int maxWidth=contentToViewDimension(data.mContentWidth);
int viewWidth=getViewWidth();
if (width < viewWidth) {
x+=left + width / 2 - mScrollX - viewWidth / 2;
}
 else {
x+=(int)(left + data.mXPercentInDoc * width - mScrollX - data.mXPercentInView * viewWidth);
}
x=Math.max(0,(Math.min(maxWidth,x + viewWidth)) - viewWidth);
int y=mScrollY;
int top=contentToViewDimension(data.mTop);
int height=contentToViewDimension(data.mHeight);
int maxHeight=contentToViewDimension(data.mContentHeight);
int viewHeight=getViewHeight();
if (height < viewHeight) {
y+=top + height / 2 - mScrollY - viewHeight / 2;
}
 else {
y+=(int)(top + data.mYPercentInDoc * height - mScrollY - data.mYPercentInView * viewHeight);
}
y=Math.max(0,(Math.min(maxHeight,y + viewHeight) - viewHeight));
scrollTo(x,y);
}
break;
default :
super.handleMessage(msg);
break;
}
}"
23215,"private native void nativeUpdateLayers(int layer,int updates);",private native void nativeUpdateLayers(int updates);
23216,"/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23217,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mMode=AudioSystem.MODE_NORMAL;
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}"
23218,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}"
23219,"/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23220,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mMode=AudioSystem.MODE_NORMAL;
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]=SystemProperties.getInt(""String_Node_Str"",MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMode=AudioSystem.MODE_INVALID;
  setMode(AudioSystem.MODE_NORMAL,null);
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
  intentFilter.addAction(BluetoothHeadset.ACTION_STATE_CHANGED);
  context.registerReceiver(mReceiver,intentFilter);
}"
23221,"/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}","/** 
 * @see AudioManager#setMode(int) 
 */
public void setMode(int mode,IBinder cb){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (mode < AudioSystem.MODE_CURRENT || mode > AudioSystem.MODE_IN_CALL) {
    return;
  }
synchronized (mSettingsLock) {
    if (mode == AudioSystem.MODE_CURRENT) {
      mode=mMode;
    }
    if (mode != mMode) {
      if (AudioSystem.setPhoneState(mode) == AudioSystem.AUDIO_STATUS_OK) {
        mMode=mode;
synchronized (mSetModeDeathHandlers) {
          SetModeDeathHandler hdlr=null;
          Iterator iter=mSetModeDeathHandlers.iterator();
          while (iter.hasNext()) {
            SetModeDeathHandler h=(SetModeDeathHandler)iter.next();
            if (h.getBinder() == cb) {
              hdlr=h;
              iter.remove();
              break;
            }
          }
          if (hdlr == null) {
            hdlr=new SetModeDeathHandler(cb);
            if (cb != null) {
              try {
                cb.linkToDeath(hdlr,0);
              }
 catch (              RemoteException e) {
                Log.w(TAG,""String_Node_Str"" + cb + ""String_Node_Str"");
              }
            }
          }
          mSetModeDeathHandlers.add(0,hdlr);
          hdlr.setMode(mode);
        }
      }
    }
    int streamType=getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
    int index=mStreamStates[STREAM_VOLUME_ALIAS[streamType]].mIndex;
    setStreamVolumeInt(STREAM_VOLUME_ALIAS[streamType],index,true,true);
  }
}"
23222,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<String> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
23223,"ArrayList<String> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<String> ret=new ArrayList<String>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(key);
    }
  }
  return ret;
}","ArrayList<PackageSetting> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<PackageSetting> ret=new ArrayList<PackageSetting>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(ps);
    }
  }
  return ret;
}"
23224,"void cleanupInstallFailedPackage(String packageName){
  if (mInstaller != null) {
    int retCode=mInstaller.remove(packageName);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(packageName);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  mSettings.removePackageLP(packageName);
}","void cleanupInstallFailedPackage(PackageSetting ps){
  Log.i(TAG,""String_Node_Str"" + ps.name);
  if (mInstaller != null) {
    int retCode=mInstaller.remove(ps.name);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(ps.name);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  if (ps.codePath != null) {
    if (!ps.codePath.delete()) {
      Log.w(TAG,""String_Node_Str"" + ps.codePath);
    }
  }
  if (ps.resourcePath != null) {
    if (!ps.resourcePath.delete() && !ps.resourcePath.equals(ps.codePath)) {
      Log.w(TAG,""String_Node_Str"" + ps.resourcePath);
    }
  }
  mSettings.removePackageLP(ps.name);
}"
23225,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<String> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
23226,"ArrayList<String> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<String> ret=new ArrayList<String>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(key);
    }
  }
  return ret;
}","ArrayList<PackageSetting> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<PackageSetting> ret=new ArrayList<PackageSetting>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(ps);
    }
  }
  return ret;
}"
23227,"void cleanupInstallFailedPackage(String packageName){
  if (mInstaller != null) {
    int retCode=mInstaller.remove(packageName);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(packageName);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  mSettings.removePackageLP(packageName);
}","void cleanupInstallFailedPackage(PackageSetting ps){
  Log.i(TAG,""String_Node_Str"" + ps.name);
  if (mInstaller != null) {
    int retCode=mInstaller.remove(ps.name);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(ps.name);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  if (ps.codePath != null) {
    if (!ps.codePath.delete()) {
      Log.w(TAG,""String_Node_Str"" + ps.codePath);
    }
  }
  if (ps.resourcePath != null) {
    if (!ps.resourcePath.delete() && !ps.resourcePath.equals(ps.codePath)) {
      Log.w(TAG,""String_Node_Str"" + ps.resourcePath);
    }
  }
  mSettings.removePackageLP(ps.name);
}"
23228,"public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<String> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}","public PackageManagerService(Context context,boolean factoryTest){
  EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis());
  if (mSdkVersion <= 0) {
    Log.w(TAG,""String_Node_Str"");
  }
  mContext=context;
  mFactoryTest=factoryTest;
  mNoDexOpt=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mMetrics=new DisplayMetrics();
  mSettings=new Settings();
  mSettings.addSharedUserLP(""String_Node_Str"",Process.SYSTEM_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? RADIO_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  mSettings.addSharedUserLP(""String_Node_Str"",MULTIPLE_APPLICATION_UIDS ? LOG_UID : FIRST_APPLICATION_UID,ApplicationInfo.FLAG_SYSTEM);
  String separateProcesses=SystemProperties.get(""String_Node_Str"");
  if (separateProcesses != null && separateProcesses.length() > 0) {
    if (""String_Node_Str"".equals(separateProcesses)) {
      mDefParseFlags=PackageParser.PARSE_IGNORE_PROCESSES;
      mSeparateProcesses=null;
      Log.w(TAG,""String_Node_Str"");
    }
 else {
      mDefParseFlags=0;
      mSeparateProcesses=separateProcesses.split(""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + separateProcesses);
    }
  }
 else {
    mDefParseFlags=0;
    mSeparateProcesses=null;
  }
  Installer installer=new Installer();
  if (installer.ping() && Process.supportsProcesses()) {
    mInstaller=installer;
  }
 else {
    mInstaller=null;
  }
  WindowManager wm=(WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
  Display d=wm.getDefaultDisplay();
  d.getMetrics(mMetrics);
synchronized (mInstallLock) {
synchronized (mPackages) {
      mHandlerThread.start();
      mHandler=new PackageHandler(mHandlerThread.getLooper());
      File dataDir=Environment.getDataDirectory();
      mAppDataDir=new File(dataDir,""String_Node_Str"");
      mDrmAppPrivateInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        File miscDir=new File(dataDir,""String_Node_Str"");
        miscDir.mkdirs();
        mAppDataDir.mkdirs();
        mDrmAppPrivateInstallDir.mkdirs();
      }
      readPermissions();
      mRestoredSettings=mSettings.readLP();
      long startTime=SystemClock.uptimeMillis();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,startTime);
      int scanMode=SCAN_MONITOR;
      if (mNoDexOpt) {
        Log.w(TAG,""String_Node_Str"");
        scanMode|=SCAN_NO_DEX;
      }
      final HashSet<String> libFiles=new HashSet<String>();
      mFrameworkDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mDalvikCacheDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller != null) {
        boolean didDexOpt=false;
        String bootClassPath=System.getProperty(""String_Node_Str"");
        if (bootClassPath != null) {
          String[] paths=splitString(bootClassPath,':');
          for (int i=0; i < paths.length; i++) {
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(paths[i])) {
                libFiles.add(paths[i]);
                mInstaller.dexopt(paths[i],Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i]);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + paths[i],e);
            }
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if (mSharedLibraries.size() > 0) {
          Iterator<String> libs=mSharedLibraries.values().iterator();
          while (libs.hasNext()) {
            String lib=libs.next();
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(lib)) {
                libFiles.add(lib);
                mInstaller.dexopt(lib,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + lib);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + lib,e);
            }
          }
        }
        libFiles.add(mFrameworkDir.getPath() + ""String_Node_Str"");
        String[] frameworkFiles=mFrameworkDir.list();
        if (frameworkFiles != null) {
          for (int i=0; i < frameworkFiles.length; i++) {
            File libPath=new File(mFrameworkDir,frameworkFiles[i]);
            String path=libPath.getPath();
            if (libFiles.contains(path)) {
              continue;
            }
            if (!path.endsWith(""String_Node_Str"") && !path.endsWith(""String_Node_Str"")) {
              continue;
            }
            try {
              if (dalvik.system.DexFile.isDexOptNeeded(path)) {
                mInstaller.dexopt(path,Process.SYSTEM_UID,true);
                didDexOpt=true;
              }
            }
 catch (            FileNotFoundException e) {
              Log.w(TAG,""String_Node_Str"" + path);
            }
catch (            IOException e) {
              Log.w(TAG,""String_Node_Str"" + path,e);
            }
          }
        }
        if (didDexOpt) {
          String[] files=mDalvikCacheDir.list();
          if (files != null) {
            for (int i=0; i < files.length; i++) {
              String fn=files[i];
              if (fn.startsWith(""String_Node_Str"") || fn.startsWith(""String_Node_Str"")) {
                Log.i(TAG,""String_Node_Str"" + fn);
                (new File(mDalvikCacheDir,fn)).delete();
              }
            }
          }
        }
      }
      mFrameworkInstallObserver=new AppDirObserver(mFrameworkDir.getPath(),OBSERVER_EVENTS,true);
      mFrameworkInstallObserver.startWatching();
      scanDirLI(mFrameworkDir,PackageParser.PARSE_IS_SYSTEM,scanMode | SCAN_NO_DEX);
      mSystemAppDir=new File(Environment.getRootDirectory(),""String_Node_Str"");
      mSystemInstallObserver=new AppDirObserver(mSystemAppDir.getPath(),OBSERVER_EVENTS,true);
      mSystemInstallObserver.startWatching();
      scanDirLI(mSystemAppDir,PackageParser.PARSE_IS_SYSTEM,scanMode);
      mAppInstallDir=new File(dataDir,""String_Node_Str"");
      if (mInstaller == null) {
        mAppInstallDir.mkdirs();
      }
      ArrayList<PackageSetting> deletePkgsList=mSettings.getListOfIncompleteInstallPackages();
      for (int i=0; i < deletePkgsList.size(); i++) {
        cleanupInstallFailedPackage(deletePkgsList.get(i));
      }
      deleteTempPackageFiles();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_DATA_SCAN_START,SystemClock.uptimeMillis());
      mAppInstallObserver=new AppDirObserver(mAppInstallDir.getPath(),OBSERVER_EVENTS,false);
      mAppInstallObserver.startWatching();
      scanDirLI(mAppInstallDir,0,scanMode);
      mDrmAppInstallObserver=new AppDirObserver(mDrmAppPrivateInstallDir.getPath(),OBSERVER_EVENTS,false);
      mDrmAppInstallObserver.startWatching();
      scanDirLI(mDrmAppPrivateInstallDir,0,scanMode | SCAN_FORWARD_LOCKED);
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());
      Log.i(TAG,""String_Node_Str"" + ((SystemClock.uptimeMillis() - startTime) / 1000f) + ""String_Node_Str"");
      updatePermissionsLP();
      mSettings.writeLP();
      EventLog.writeEvent(LOG_BOOT_PROGRESS_PMS_READY,SystemClock.uptimeMillis());
      Runtime.getRuntime().gc();
    }
  }
}"
23229,"ArrayList<String> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<String> ret=new ArrayList<String>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(key);
    }
  }
  return ret;
}","ArrayList<PackageSetting> getListOfIncompleteInstallPackages(){
  HashSet<String> kList=new HashSet<String>(mPackages.keySet());
  Iterator<String> its=kList.iterator();
  ArrayList<PackageSetting> ret=new ArrayList<PackageSetting>();
  while (its.hasNext()) {
    String key=its.next();
    PackageSetting ps=mPackages.get(key);
    if (ps.getInstallStatus() == PKG_INSTALL_INCOMPLETE) {
      ret.add(ps);
    }
  }
  return ret;
}"
23230,"void cleanupInstallFailedPackage(String packageName){
  if (mInstaller != null) {
    int retCode=mInstaller.remove(packageName);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(packageName);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  mSettings.removePackageLP(packageName);
}","void cleanupInstallFailedPackage(PackageSetting ps){
  Log.i(TAG,""String_Node_Str"" + ps.name);
  if (mInstaller != null) {
    int retCode=mInstaller.remove(ps.name);
    if (retCode < 0) {
      Log.w(TAG,""String_Node_Str"" + ps.name + ""String_Node_Str""+ retCode);
    }
  }
 else {
    PackageParser.Package pkg=mPackages.get(ps.name);
    File dataDir=new File(pkg.applicationInfo.dataDir);
    dataDir.delete();
  }
  if (ps.codePath != null) {
    if (!ps.codePath.delete()) {
      Log.w(TAG,""String_Node_Str"" + ps.codePath);
    }
  }
  if (ps.resourcePath != null) {
    if (!ps.resourcePath.delete() && !ps.resourcePath.equals(ps.codePath)) {
      Log.w(TAG,""String_Node_Str"" + ps.resourcePath);
    }
  }
  mSettings.removePackageLP(ps.name);
}"
23231,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}"
23232,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}"
23233,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  int delay=0;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    delay=1000;
  }
 else {
    if (mHandler.hasMessages(0)) {
      delay=1000;
    }
  }
  mWakeLock.acquire();
  mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),delay);
}"
23234,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(this,ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}"
23235,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        int[] outId=new int[1];
        inm.enqueueNotification(packageName,foregroundId,foregroundNoti,outId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23236,"public void cancelNotification(){
  if (foregroundId != 0) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        inm.cancelNotification(packageName,foregroundId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23237,"ServiceRecord(BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}","ServiceRecord(ActivityManagerService ams,BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.ams=ams;
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}"
23238,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}"
23239,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}"
23240,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}"
23241,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}"
23242,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}"
23243,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}"
23244,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}"
23245,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}"
23246,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}"
23247,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}"
23248,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}"
23249,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}"
23250,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}"
23251,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}"
23252,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}"
23253,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}"
23254,"protected void startPhotoQuery(long photoId,Uri lookupKey){
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}","/** 
 * startPhotoQuery internal method to query contact photo by photo id and uri.
 * @param photoId the photo id.
 * @param lookupKey the lookup uri.
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not.
 */
protected void startPhotoQuery(long photoId,Uri lookupKey,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_PHOTO_QUERY,lookupKey,ContentUris.withAppendedId(Data.CONTENT_URI,photoId),PhotoQuery.COLUMNS,null,null,null);
}"
23255,"private void startContactQuery(Uri contactUri){
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}","/** 
 * startContactQuery internal method to query contact by Uri.
 * @param contactUri the contact uri
 * @param resetQueryHandler whether to use a new AsyncQueryHandler or not
 */
private void startContactQuery(Uri contactUri,boolean resetQueryHandler){
  if (resetQueryHandler) {
    resetAsyncQueryHandler();
  }
  mQueryHandler.startQuery(TOKEN_CONTACT_INFO,null,contactUri,ContactQuery.COLUMNS,null,null,null);
}"
23256,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param conatctUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  mContactUri=contactLookupUri;
  startContactQuery(contactLookupUri);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param contactLookupUri a {Contacts.CONTENT_LOOKUP_URI} style URI.
 */
public void bindFromContactLookupUri(Uri contactLookupUri){
  bindFromContactUriInternal(contactLookupUri,true);
}"
23257,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
}"
23258,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  resetAsyncQueryHandler();
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}"
23259,"/** 
 * Method to force this widget to forget everything it knows about the contact. The widget isn't automatically updated or redrawn.
 */
public void wipeClean(){
  setDisplayName(null,null);
  setPhoto(null);
  setSocialSnippet(null);
  mContactUri=null;
  mExcludeMimes=null;
}","/** 
 * Method to force this widget to forget everything it knows about the contact. We need to stop any existing async queries for phone, email, contact, and photos.
 */
public void wipeClean(){
  resetAsyncQueryHandler();
  setDisplayName(null,null);
  setPhoto(loadPlaceholderPhoto(null));
  setSocialSnippet(null);
  setPresence(0);
  mContactUri=null;
  mExcludeMimes=null;
}"
23260,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mAggregateBadge=findViewById(R.id.aggregate_badge);
  mAggregateBadge.setVisibility(View.GONE);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(QuickContactBadge)findViewById(R.id.photo);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  mStatusAttributionView=(TextView)findViewById(R.id.status_date);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  resetAsyncQueryHandler();
}"
23261,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri);
        invalidate();
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (this != mQueryHandler) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
switch (token) {
case TOKEN_PHOTO_QUERY:
{
        Bitmap photoBitmap=null;
        if (cursor != null && cursor.moveToFirst() && !cursor.isNull(PhotoQuery.PHOTO)) {
          byte[] photoData=cursor.getBlob(PhotoQuery.PHOTO);
          photoBitmap=BitmapFactory.decodeByteArray(photoData,0,photoData.length,null);
        }
        if (photoBitmap == null) {
          photoBitmap=loadPlaceholderPhoto(null);
        }
        mPhotoView.setImageBitmap(photoBitmap);
        if (cookie != null && cookie instanceof Uri) {
          mPhotoView.assignContactUri((Uri)cookie);
        }
        invalidate();
        break;
      }
case TOKEN_CONTACT_INFO:
{
      if (cursor != null && cursor.moveToFirst()) {
        bindContactInfo(cursor);
        Uri lookupUri=Contacts.getLookupUri(cursor.getLong(ContactQuery._ID),cursor.getString(ContactQuery.LOOKUP_KEY));
        startPhotoQuery(cursor.getLong(ContactQuery.PHOTO_ID),lookupUri,false);
        invalidate();
      }
 else {
        setDisplayName(null,null);
        setSocialSnippet(null);
        setPhoto(loadPlaceholderPhoto(null));
      }
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      setSocialSnippet(null);
      setPhoto(loadPlaceholderPhoto(null));
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUriInternal(Contacts.getLookupUri(contactId,lookupKey),false);
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    setSocialSnippet(null);
    setPhoto(loadPlaceholderPhoto(null));
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}"
23262,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(this,ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}"
23263,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        int[] outId=new int[1];
        inm.enqueueNotification(packageName,foregroundId,foregroundNoti,outId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23264,"public void cancelNotification(){
  if (foregroundId != 0) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        inm.cancelNotification(packageName,foregroundId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23265,"ServiceRecord(BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}","ServiceRecord(ActivityManagerService ams,BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.ams=ams;
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}"
23266,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,int callingPid,int callingUid){
  ServiceRecord r=null;
  if (service.getComponent() != null) {
    r=mServices.get(service.getComponent());
  }
  Intent.FilterComparison filter=new Intent.FilterComparison(service);
  r=mServicesByIntent.get(filter);
  if (r == null) {
    try {
      ResolveInfo rInfo=ActivityThread.getPackageManager().resolveService(service,resolvedType,STOCK_PM_FLAGS);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Log.w(TAG,""String_Node_Str"" + service + ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      r=mServices.get(name);
      if (r == null) {
        filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(this,ss,name,filter,sInfo,res);
        res.setService(r);
        mServices.put(name,r);
        mServicesByIntent.put(filter,r);
        int N=mPendingServices.size();
        for (int i=0; i < N; i++) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.name.equals(name)) {
            mPendingServices.remove(i);
            i--;
            N--;
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (checkComponentPermission(r.permission,callingPid,callingUid,r.exported ? -1 : r.appInfo.uid) != PackageManager.PERMISSION_GRANTED) {
      Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}"
23267,"public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        int[] outId=new int[1];
        inm.enqueueNotification(packageName,foregroundId,foregroundNoti,outId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void postNotification(){
  if (foregroundId != 0 && foregroundNoti != null) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    final Notification localForegroundNoti=foregroundNoti;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          int[] outId=new int[1];
          inm.enqueueNotification(localPackageName,localForegroundId,localForegroundNoti,outId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23268,"public void cancelNotification(){
  if (foregroundId != 0) {
    INotificationManager inm=NotificationManager.getService();
    if (inm != null) {
      try {
        inm.cancelNotification(packageName,foregroundId);
      }
 catch (      RemoteException e) {
      }
    }
  }
}","public void cancelNotification(){
  if (foregroundId != 0) {
    final String localPackageName=packageName;
    final int localForegroundId=foregroundId;
    ams.mHandler.post(new Runnable(){
      public void run(){
        INotificationManager inm=NotificationManager.getService();
        if (inm == null) {
          return;
        }
        try {
          inm.cancelNotification(localPackageName,localForegroundId);
        }
 catch (        RemoteException e) {
        }
      }
    }
);
  }
}"
23269,"ServiceRecord(BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}","ServiceRecord(ActivityManagerService ams,BatteryStatsImpl.Uid.Pkg.Serv servStats,ComponentName name,Intent.FilterComparison intent,ServiceInfo sInfo,Runnable restarter){
  this.ams=ams;
  this.stats=servStats;
  this.name=name;
  shortName=name.flattenToShortString();
  this.intent=intent;
  serviceInfo=sInfo;
  appInfo=sInfo.applicationInfo;
  packageName=sInfo.applicationInfo.packageName;
  processName=sInfo.processName;
  permission=sInfo.permission;
  baseDir=sInfo.applicationInfo.sourceDir;
  resDir=sInfo.applicationInfo.publicSourceDir;
  dataDir=sInfo.applicationInfo.dataDir;
  exported=sInfo.exported;
  this.restarter=restarter;
  createTime=lastActivity=SystemClock.uptimeMillis();
}"
23270,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      ProximityAlert alert=mProximityAlerts.remove(i);
      mProximitiesEntered.remove(alert);
    }
  }
}"
23271,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      ProximityAlert alert=mProximityAlerts.remove(i);
      mProximitiesEntered.remove(alert);
    }
  }
}"
23272,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      ProximityAlert alert=mProximityAlerts.remove(i);
      mProximitiesEntered.remove(alert);
    }
  }
}"
23273,"@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    removeCallbacks(mFlingRunnable);
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}","@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    if (mFlingRunnable != null) {
      removeCallbacks(mFlingRunnable);
      mFlingRunnable.endFling();
    }
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}"
23274,"@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    removeCallbacks(mFlingRunnable);
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}","@Override public void onWindowFocusChanged(boolean hasWindowFocus){
  super.onWindowFocusChanged(hasWindowFocus);
  final int touchMode=isInTouchMode() ? TOUCH_MODE_ON : TOUCH_MODE_OFF;
  if (!hasWindowFocus) {
    setChildrenDrawingCacheEnabled(false);
    if (mFlingRunnable != null) {
      removeCallbacks(mFlingRunnable);
      mFlingRunnable.endFling();
    }
    dismissPopup();
    if (touchMode == TOUCH_MODE_OFF) {
      mResurrectToPosition=mSelectedPosition;
    }
  }
 else {
    if (mFiltered) {
      showPopup();
    }
    if (touchMode != mLastTouchMode && mLastTouchMode != TOUCH_MODE_UNKNOWN) {
      if (touchMode == TOUCH_MODE_OFF) {
        resurrectSelection();
      }
 else {
        hideSelector();
        mLayoutMode=LAYOUT_NORMAL;
        layoutChildren();
      }
    }
  }
  mLastTouchMode=touchMode;
}"
23275,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
23276,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
AudioSystem.setParameters(""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}"
23277,"/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetUsageForOrigin(origin),nativeGetQuotaForOrigin(origin));
    mOrigins.put(origin,website);
  }
}","/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetQuotaForOrigin(origin),nativeGetUsageForOrigin(origin));
    mOrigins.put(origin,website);
  }
}"
23278,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
23279,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
AudioSystem.setParameters(""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}"
23280,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (getSinkPriority(device) > BluetoothA2dp.PRIORITY_OFF && state == BluetoothA2dp.STATE_CONNECTING || state == BluetoothA2dp.STATE_CONNECTED) {
      setSinkPriority(device,BluetoothA2dp.PRIORITY_AUTO_CONNECT);
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
23281,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.ACTION_SINK_STATE_CHANGED)) {
    int state=intent.getIntExtra(BluetoothA2dp.EXTRA_SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
    String address=btDevice.getAddress();
    boolean isConnected=(mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP) && ((String)mConnectedDevices.get(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP)).equals(address));
    if (isConnected && state != BluetoothA2dp.STATE_CONNECTED && state != BluetoothA2dp.STATE_PLAYING) {
      if (address.equals(sBtDockAddress)) {
        Log.v(TAG,""String_Node_Str"");
        AudioSystem.setForceUse(AudioSystem.FOR_DOCK,AudioSystem.FORCE_NONE);
      }
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (!isConnected && (state == BluetoothA2dp.STATE_CONNECTED || state == BluetoothA2dp.STATE_PLAYING)) {
      if (btDevice.isBluetoothDock()) {
        Log.v(TAG,""String_Node_Str"");
        sBtDockAddress=address;
        Intent i=context.registerReceiver(null,new IntentFilter(Intent.ACTION_DOCK_EVENT));
        if (i != null) {
          int dockState=i.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
          int config;
switch (dockState) {
case Intent.EXTRA_DOCK_STATE_DESK:
            config=AudioSystem.FORCE_BT_DESK_DOCK;
          break;
case Intent.EXTRA_DOCK_STATE_CAR:
        config=AudioSystem.FORCE_BT_CAR_DOCK;
      break;
case Intent.EXTRA_DOCK_STATE_UNDOCKED:
default :
    config=AudioSystem.FORCE_NONE;
}
AudioSystem.setForceUse(AudioSystem.FOR_DOCK,config);
}
}
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
AudioSystem.setParameters(""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
}
}
 else if (action.equals(BluetoothHeadset.ACTION_STATE_CHANGED)) {
int state=intent.getIntExtra(BluetoothHeadset.EXTRA_STATE,BluetoothHeadset.STATE_ERROR);
int device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
BluetoothDevice btDevice=intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
String address=null;
if (btDevice != null) {
address=btDevice.getAddress();
BluetoothClass btClass=btDevice.getBluetoothClass();
if (btClass != null) {
switch (btClass.getDeviceClass()) {
case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
break;
case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
device=AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
break;
}
}
}
boolean isConnected=(mConnectedDevices.containsKey(device) && ((String)mConnectedDevices.get(device)).equals(address));
if (isConnected && state != BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
mConnectedDevices.remove(device);
}
 else if (!isConnected && state == BluetoothHeadset.STATE_CONNECTED) {
AudioSystem.setDeviceConnectionState(device,AudioSystem.DEVICE_STATE_AVAILABLE,address);
mConnectedDevices.put(new Integer(device),address);
}
}
 else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
int state=intent.getIntExtra(""String_Node_Str"",0);
int microphone=intent.getIntExtra(""String_Node_Str"",0);
if (microphone != 0) {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
}
}
 else {
boolean isConnected=mConnectedDevices.containsKey(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
if (state == 0 && isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
}
 else if (state == 1 && !isConnected) {
AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
}
}
}
}"
23282,"public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecPathResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecListResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
23283,"/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetUsageForOrigin(origin),nativeGetQuotaForOrigin(origin));
    mOrigins.put(origin,website);
  }
}","/** 
 * Run on the webcore thread set the local values with the current ones
 */
private void syncValues(){
  Set<String> tmp=nativeGetOrigins();
  mOrigins=new HashMap<String,Origin>();
  for (  String origin : tmp) {
    Origin website=new Origin(origin,nativeGetQuotaForOrigin(origin),nativeGetUsageForOrigin(origin));
    mOrigins.put(origin,website);
  }
}"
23284,"public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecPathResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","public String[] listAsec() throws IllegalStateException {
  ArrayList<String> rsp=doCommand(""String_Node_Str"");
  String[] rdata=new String[rsp.size()];
  int idx=0;
  for (  String line : rsp) {
    String[] tok=line.split(""String_Node_Str"");
    int code=Integer.parseInt(tok[0]);
    if (code == ResponseCode.AsecListResult) {
      rdata[idx++]=tok[1];
    }
 else     if (code == ResponseCode.CommandOkay) {
      return rdata;
    }
 else {
      throw new IllegalStateException(String.format(""String_Node_Str"",code));
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}"
23285,"/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position){
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}","/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true ifthe returned view was taken from the scrap heap, false if otherwise.
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position,boolean[] isScrap){
  isScrap[0]=false;
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
 else {
      isScrap[0]=true;
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}"
23286,"/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}","/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        removeDetachedView(victim,false);
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}"
23287,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}"
23288,"/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override protected View obtainView(int position){
  View view=super.obtainView(position);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}","/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override View obtainView(int position,boolean[] isScrap){
  View view=super.obtainView(position,isScrap);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}"
23289,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false,where);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0],where);
  return child;
}"
23290,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0,mIsScrap);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}"
23291,"private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,false);
  return view;
}","private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition,mIsScrap);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,mIsScrap[0]);
  return view;
}"
23292,"private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,false);
  return view;
}","private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition,mIsScrap);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,mIsScrap[0]);
  return view;
}"
23293,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0]);
  return child;
}"
23294,"/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}","/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  final boolean[] isScrap=mIsScrap;
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i,isScrap);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}"
23295,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0,mIsScrap);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}"
23296,"/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position){
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}","/** 
 * Get a view and have it show the data associated with the specified position. This is called when we have already discovered that the view is not available for reuse in the recycle bin. The only choices left are converting an old view or making a new one.
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true ifthe returned view was taken from the scrap heap, false if otherwise.
 * @return A view displaying the data associated with the specified position
 */
View obtainView(int position,boolean[] isScrap){
  isScrap[0]=false;
  View scrapView;
  scrapView=mRecycler.getScrapView(position);
  View child;
  if (scrapView != null) {
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.RECYCLE_FROM_SCRAP_HEAP,position,-1);
    }
    child=mAdapter.getView(position,scrapView,this);
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.BIND_VIEW,position,getChildCount());
    }
    if (child != scrapView) {
      mRecycler.addScrapView(scrapView);
      if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(scrapView,ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,position,-1);
      }
    }
 else {
      isScrap[0]=true;
    }
  }
 else {
    child=mAdapter.getView(position,null,this);
    if (mCacheColorHint != 0) {
      child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (ViewDebug.TRACE_RECYCLER) {
      ViewDebug.trace(child,ViewDebug.RecyclerTraceType.NEW_VIEW,position,getChildCount());
    }
  }
  return child;
}"
23297,"/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}","/** 
 * Move all views remaining in mActiveViews to mScrapViews.
 */
void scrapActiveViews(){
  final View[] activeViews=mActiveViews;
  final boolean hasListener=mRecyclerListener != null;
  final boolean multipleScraps=mViewTypeCount > 1;
  ArrayList<View> scrapViews=mCurrentScrap;
  final int count=activeViews.length;
  for (int i=0; i < count; ++i) {
    final View victim=activeViews[i];
    if (victim != null) {
      int whichScrap=((AbsListView.LayoutParams)victim.getLayoutParams()).viewType;
      activeViews[i]=null;
      if (whichScrap == AdapterView.ITEM_VIEW_TYPE_IGNORE) {
        removeDetachedView(victim,false);
        continue;
      }
      if (multipleScraps) {
        scrapViews=mScrapViews[whichScrap];
      }
      scrapViews.add(victim);
      if (hasListener) {
        mRecyclerListener.onMovedToScrapHeap(victim);
      }
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(victim,ViewDebug.RecyclerTraceType.MOVE_FROM_ACTIVE_TO_SCRAP_HEAP,mFirstActivePosition + i,-1);
      }
    }
  }
  pruneScrapViews();
}"
23298,"@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}","@Override protected void onDetachedFromWindow(){
  super.onDetachedFromWindow();
  dismissPopup();
  mRecycler.clear();
  final ViewTreeObserver treeObserver=getViewTreeObserver();
  if (treeObserver != null) {
    treeObserver.removeOnTouchModeChangeListener(this);
    if (mTextFilterEnabled && mPopup != null) {
      treeObserver.removeGlobalOnLayoutListener(this);
      mGlobalLayoutListenerAddedFilter=false;
    }
  }
}"
23299,"/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override protected View obtainView(int position){
  View view=super.obtainView(position);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}","/** 
 * <p>Avoids jarring scrolling effect by ensuring that list elements made of a text view fit on a single line.</p>
 * @param position the item index in the list to get a view for
 * @return the view for the specified item
 */
@Override View obtainView(int position,boolean[] isScrap){
  View view=super.obtainView(position,isScrap);
  if (view instanceof TextView) {
    ((TextView)view).setHorizontallyScrolling(true);
  }
  return view;
}"
23300,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false,where);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow if true, align top edge to y. If false, align bottom edge toy.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param where to add new item in the list
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected,int where){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      setupChild(child,position,y,flow,childrenLeft,selected,true,where);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0],where);
  return child;
}"
23301,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    if (mColumnWidth > 0) {
      widthSize=mColumnWidth + mListPadding.left + mListPadding.right;
    }
 else {
      widthSize=mListPadding.left + mListPadding.right;
    }
    widthSize+=getVerticalScrollbarWidth();
  }
  int childWidth=widthSize - mListPadding.left - mListPadding.right;
  determineColumns(childWidth);
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  final int count=mItemCount;
  if (count > 0) {
    final View child=obtainView(0,mIsScrap);
    AbsListView.LayoutParams p=(AbsListView.LayoutParams)child.getLayoutParams();
    if (p == null) {
      p=new AbsListView.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT,0);
      child.setLayoutParams(p);
    }
    p.viewType=mAdapter.getItemViewType(0);
    int childHeightSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED),0,p.height);
    int childWidthSpec=getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth,MeasureSpec.EXACTLY),0,p.width);
    child.measure(childWidthSpec,childHeightSpec);
    childHeight=child.getMeasuredHeight();
    if (mRecycler.shouldRecycleViewType(p.viewType)) {
      mRecycler.addScrapView(child);
    }
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    int ourSize=mListPadding.top + mListPadding.bottom;
    final int numColumns=mNumColumns;
    for (int i=0; i < count; i+=numColumns) {
      ourSize+=childHeight;
      if (i + numColumns < count) {
        ourSize+=mVerticalSpacing;
      }
      if (ourSize >= heightSize) {
        ourSize=heightSize;
        break;
      }
    }
    heightSize=ourSize;
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}"
23302,"private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,false);
  return view;
}","private View addViewAbove(View theView,int position){
  int abovePosition=position - 1;
  View view=obtainView(abovePosition,mIsScrap);
  int edgeOfNewChild=theView.getTop() - mDividerHeight;
  setupChild(view,abovePosition,edgeOfNewChild,false,mListPadding.left,false,mIsScrap[0]);
  return view;
}"
23303,"private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,false);
  return view;
}","private View addViewBelow(View theView,int position){
  int belowPosition=position + 1;
  View view=obtainView(belowPosition,mIsScrap);
  int edgeOfNewChild=theView.getBottom() + mDividerHeight;
  setupChild(view,belowPosition,edgeOfNewChild,true,mListPadding.left,false,mIsScrap[0]);
  return view;
}"
23304,"/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position);
  setupChild(child,position,y,flow,childrenLeft,selected,false);
  return child;
}","/** 
 * Obtain the view and add it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.
 * @param position Logical position in the list
 * @param y Top or bottom edge of the view to add
 * @param flow If flow is true, align top edge to y. If false, align bottomedge to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @return View that was added
 */
private View makeAndAddView(int position,int y,boolean flow,int childrenLeft,boolean selected){
  View child;
  if (!mDataChanged) {
    child=mRecycler.getActiveView(position);
    if (child != null) {
      if (ViewDebug.TRACE_RECYCLER) {
        ViewDebug.trace(child,ViewDebug.RecyclerTraceType.RECYCLE_FROM_ACTIVE_HEAP,position,getChildCount());
      }
      setupChild(child,position,y,flow,childrenLeft,selected,true);
      return child;
    }
  }
  child=obtainView(position,mIsScrap);
  setupChild(child,position,y,flow,childrenLeft,selected,mIsScrap[0]);
  return child;
}"
23305,"/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}","/** 
 * Measures the height of the given range of children (inclusive) and returns the height with this ListView's padding and divider heights included. If maxHeight is provided, the measuring will stop when the current height reaches maxHeight.
 * @param widthMeasureSpec The width measure spec to be given to a child's{@link View#measure(int,int)}.
 * @param startPosition The position of the first child to be shown.
 * @param endPosition The (inclusive) position of the last child to beshown. Specify  {@link #NO_POSITION} if the last child should bethe last available child from the adapter.
 * @param maxHeight The maximum height that will be returned (if all thechildren don't fit in this value, this value will be returned).
 * @param disallowPartialChildPosition In general, whether the returnedheight should only contain entire children. This is more powerful--it is the first inclusive position at which partial children will not be allowed. Example: it looks nice to have at least 3 completely visible children, and in portrait this will most likely fit; but in landscape there could be times when even 2 children can not be completely shown, so a value of 2 (remember, inclusive) would be good (assuming startPosition is 0).
 * @return The height of this ListView with the given children.
 */
final int measureHeightOfChildren(int widthMeasureSpec,int startPosition,int endPosition,final int maxHeight,int disallowPartialChildPosition){
  final ListAdapter adapter=mAdapter;
  if (adapter == null) {
    return mListPadding.top + mListPadding.bottom;
  }
  int returnedHeight=mListPadding.top + mListPadding.bottom;
  final int dividerHeight=((mDividerHeight > 0) && mDivider != null) ? mDividerHeight : 0;
  int prevHeightWithoutPartialChild=0;
  int i;
  View child;
  endPosition=(endPosition == NO_POSITION) ? adapter.getCount() - 1 : endPosition;
  final AbsListView.RecycleBin recycleBin=mRecycler;
  final boolean recyle=recycleOnMeasure();
  final boolean[] isScrap=mIsScrap;
  for (i=startPosition; i <= endPosition; ++i) {
    child=obtainView(i,isScrap);
    measureScrapChild(child,i,widthMeasureSpec);
    if (i > 0) {
      returnedHeight+=dividerHeight;
    }
    if (recyle) {
      recycleBin.addScrapView(child);
    }
    returnedHeight+=child.getMeasuredHeight();
    if (returnedHeight >= maxHeight) {
      return (disallowPartialChildPosition >= 0) && (i > disallowPartialChildPosition) && (prevHeightWithoutPartialChild > 0)&& (returnedHeight != maxHeight) ? prevHeightWithoutPartialChild : maxHeight;
    }
    if ((disallowPartialChildPosition >= 0) && (i >= disallowPartialChildPosition)) {
      prevHeightWithoutPartialChild=returnedHeight;
    }
  }
  return returnedHeight;
}"
23306,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int childWidth=0;
  int childHeight=0;
  mItemCount=mAdapter == null ? 0 : mAdapter.getCount();
  if (mItemCount > 0 && (widthMode == MeasureSpec.UNSPECIFIED || heightMode == MeasureSpec.UNSPECIFIED)) {
    final View child=obtainView(0,mIsScrap);
    measureScrapChild(child,0,widthMeasureSpec);
    childWidth=child.getMeasuredWidth();
    childHeight=child.getMeasuredHeight();
    if (recycleOnMeasure()) {
      mRecycler.addScrapView(child);
    }
  }
  if (widthMode == MeasureSpec.UNSPECIFIED) {
    widthSize=mListPadding.left + mListPadding.right + childWidth+ getVerticalScrollbarWidth();
  }
  if (heightMode == MeasureSpec.UNSPECIFIED) {
    heightSize=mListPadding.top + mListPadding.bottom + childHeight+ getVerticalFadingEdgeLength() * 2;
  }
  if (heightMode == MeasureSpec.AT_MOST) {
    heightSize=measureHeightOfChildren(widthMeasureSpec,0,NO_POSITION,heightSize,-1);
  }
  setMeasuredDimension(widthSize,heightSize);
  mWidthMeasureSpec=widthMeasureSpec;
}"
23307,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}"
23308,"public void run(AccountManagerFuture<Account[]> future){
  boolean hasSAMLAccount=true;
  try {
    hasSAMLAccount=future.getResult().length > 0;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=!hasSAMLAccount;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(true);
  }
}","public void run(AccountManagerFuture<Account[]> future){
  int samlAccounts=0;
  try {
    samlAccounts=future.getResult().length;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=samlAccounts < mNumAccounts;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(mEnableFallback);
  }
}"
23309,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + failedAttempts + ""String_Node_Str""+ mEnableFallback+ ""String_Node_Str"");
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mEnableFallback);
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  maybeEnableFallback(context);
  addView(mUnlockScreen);
  updateScreen(mMode);
}"
23310,"public void run(AccountManagerFuture<Account[]> future){
  boolean hasSAMLAccount=true;
  try {
    hasSAMLAccount=future.getResult().length > 0;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=!hasSAMLAccount;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(true);
  }
}","public void run(AccountManagerFuture<Account[]> future){
  int samlAccounts=0;
  try {
    samlAccounts=future.getResult().length;
  }
 catch (  OperationCanceledException e) {
  }
catch (  IOException e) {
  }
catch (  AuthenticatorException e) {
  }
  mEnableFallback=samlAccounts < mNumAccounts;
  if (mUnlockScreen == null) {
    Log.w(TAG,""String_Node_Str"");
  }
 else   if (mUnlockScreen instanceof UnlockScreen) {
    ((UnlockScreen)mUnlockScreen).setEnableFallback(mEnableFallback);
  }
}"
23311,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing || win.mViewVisibility != View.VISIBLE) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}"
23312,"public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    sGLThreadManager.notifyAll();
  }
}","public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    mRenderComplete=false;
    sGLThreadManager.notifyAll();
    while (!mExited && !mPaused && !mRenderComplete) {
      if (LOG_SURFACE) {
        Log.i(""String_Node_Str"",""String_Node_Str"");
      }
      try {
        sGLThreadManager.wait();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
    }
  }
}"
23313,"private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}","private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    boolean wantRenderNotification=false;
    boolean doRenderNotification=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if (doRenderNotification) {
            wantRenderNotification=false;
            doRenderNotification=false;
            mRenderComplete=true;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                wantRenderNotification=true;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
      if (wantRenderNotification) {
        doRenderNotification=true;
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}"
23314,"public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    sGLThreadManager.notifyAll();
  }
}","public void onWindowResize(int w,int h){
synchronized (sGLThreadManager) {
    mWidth=w;
    mHeight=h;
    mSizeChanged=true;
    mRequestRender=true;
    mRenderComplete=false;
    sGLThreadManager.notifyAll();
    while (!mExited && !mPaused && !mRenderComplete) {
      if (LOG_SURFACE) {
        Log.i(""String_Node_Str"",""String_Node_Str"");
      }
      try {
        sGLThreadManager.wait();
      }
 catch (      InterruptedException ex) {
        Thread.currentThread().interrupt();
      }
    }
  }
}"
23315,"private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        sGLThreadManager.checkGLDriver(gl);
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}","private void guardedRun() throws InterruptedException {
  mEglHelper=new EglHelper();
  try {
    GL10 gl=null;
    boolean createEglSurface=false;
    boolean sizeChanged=false;
    boolean wantRenderNotification=false;
    boolean doRenderNotification=false;
    int w=0;
    int h=0;
    Runnable event=null;
    while (true) {
synchronized (sGLThreadManager) {
        while (true) {
          if (mShouldExit) {
            return;
          }
          if (!mEventQueue.isEmpty()) {
            event=mEventQueue.remove(0);
            break;
          }
          if (mHaveEgl && mPaused) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            stopEglLocked();
          }
          if ((!mHasSurface) && (!mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            if (mHaveEgl) {
              stopEglLocked();
            }
            mWaitingForSurface=true;
            sGLThreadManager.notifyAll();
          }
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
            }
            mWaitingForSurface=false;
            sGLThreadManager.notifyAll();
          }
          if (doRenderNotification) {
            wantRenderNotification=false;
            doRenderNotification=false;
            mRenderComplete=true;
            sGLThreadManager.notifyAll();
          }
          if ((!mPaused) && mHasSurface && (mWidth > 0)&& (mHeight > 0)&& (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
            if ((!mHaveEgl) && sGLThreadManager.tryAcquireEglSurfaceLocked(this)) {
              mHaveEgl=true;
              mEglHelper.start();
              createEglSurface=true;
              sizeChanged=true;
              sGLThreadManager.notifyAll();
            }
            if (mHaveEgl) {
              if (mSizeChanged) {
                sizeChanged=true;
                w=mWidth;
                h=mHeight;
                wantRenderNotification=true;
                if (DRAW_TWICE_AFTER_SIZE_CHANGED) {
                }
 else {
                  mRequestRender=false;
                }
                mSizeChanged=false;
              }
 else {
                mRequestRender=false;
              }
              sGLThreadManager.notifyAll();
              break;
            }
          }
          if (LOG_THREADS) {
            Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
          }
          sGLThreadManager.wait();
        }
      }
      if (event != null) {
        event.run();
        event=null;
        continue;
      }
      if (createEglSurface) {
        gl=(GL10)mEglHelper.createSurface(getHolder());
        sGLThreadManager.checkGLDriver(gl);
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"");
        }
        mRenderer.onSurfaceCreated(gl,mEglHelper.mEglConfig);
        createEglSurface=false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w(""String_Node_Str"",""String_Node_Str"" + w + ""String_Node_Str""+ h+ ""String_Node_Str"");
        }
        mRenderer.onSurfaceChanged(gl,w,h);
        sizeChanged=false;
      }
      if (LOG_RENDERER) {
        Log.w(""String_Node_Str"",""String_Node_Str"");
      }
      mRenderer.onDrawFrame(gl);
      if (!mEglHelper.swap()) {
        if (LOG_SURFACE) {
          Log.i(""String_Node_Str"",""String_Node_Str"" + getId());
        }
      }
      if (wantRenderNotification) {
        doRenderNotification=true;
      }
    }
  }
  finally {
synchronized (sGLThreadManager) {
      stopEglLocked();
    }
  }
}"
23316,"/** 
 * Default implementation of   {@link KeyEvent.Callback#onKeyMultiple(int,int,KeyEvent) KeyEvent.Callback.onKeyMultiple()}: perform clicking of the view when   {@link KeyEvent#KEYCODE_DPAD_CENTER} or{@link KeyEvent#KEYCODE_ENTER} is released.
 * @param keyCode A key code that represents the button pressed, from{@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
public boolean onKeyUp(int keyCode,KeyEvent event){
  boolean result=false;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
{
      if ((mViewFlags & ENABLED_MASK) == DISABLED) {
        return true;
      }
      if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
        setPressed(false);
        if (!mHasPerformedLongPress) {
          cancelLongPress();
          result=performClick();
        }
      }
      break;
    }
}
return result;
}","/** 
 * Default implementation of   {@link KeyEvent.Callback#onKeyMultiple(int,int,KeyEvent) KeyEvent.Callback.onKeyMultiple()}: perform clicking of the view when   {@link KeyEvent#KEYCODE_DPAD_CENTER} or{@link KeyEvent#KEYCODE_ENTER} is released.
 * @param keyCode A key code that represents the button pressed, from{@link android.view.KeyEvent}.
 * @param event   The KeyEvent object that defines the button action.
 */
public boolean onKeyUp(int keyCode,KeyEvent event){
  boolean result=false;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
{
      if ((mViewFlags & ENABLED_MASK) == DISABLED) {
        return true;
      }
      if ((mViewFlags & CLICKABLE) == CLICKABLE && isPressed()) {
        setPressed(false);
        if (!mHasPerformedLongPress) {
          removeLongPressCallback();
          result=performClick();
        }
      }
      break;
    }
}
return result;
}"
23317,"private void resetPressedState(){
  if ((mViewFlags & ENABLED_MASK) == DISABLED) {
    return;
  }
  if (isPressed()) {
    setPressed(false);
    if (!mHasPerformedLongPress) {
      cancelLongPress();
    }
  }
}","private void resetPressedState(){
  if ((mViewFlags & ENABLED_MASK) == DISABLED) {
    return;
  }
  if (isPressed()) {
    setPressed(false);
    if (!mHasPerformedLongPress) {
      removeLongPressCallback();
    }
  }
}"
23318,"/** 
 * Cancels a pending long press.  Your subclass can use this if you want the context menu to come up if the user presses and holds at the same place, but you don't want it to come up if they press and then move around enough to cause scrolling.
 */
public void cancelLongPress(){
  if (mPendingCheckForLongPress != null) {
    removeCallbacks(mPendingCheckForLongPress);
  }
}","/** 
 * Cancels a pending long press.  Your subclass can use this if you want the context menu to come up if the user presses and holds at the same place, but you don't want it to come up if they press and then move around enough to cause scrolling.
 */
public void cancelLongPress(){
  removeLongPressCallback();
}"
23319,"/** 
 * Implement this method to handle touch screen motion events.
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
public boolean onTouchEvent(MotionEvent event){
  final int viewFlags=mViewFlags;
  if ((viewFlags & ENABLED_MASK) == DISABLED) {
    return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
  }
  if (mTouchDelegate != null) {
    if (mTouchDelegate.onTouchEvent(event)) {
      return true;
    }
  }
  if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
switch (event.getAction()) {
case MotionEvent.ACTION_UP:
      if ((mPrivateFlags & PRESSED) != 0) {
        boolean focusTaken=false;
        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
          focusTaken=requestFocus();
        }
        if (!mHasPerformedLongPress) {
          cancelLongPress();
          if (!focusTaken) {
            performClick();
          }
        }
        if (mUnsetPressedState == null) {
          mUnsetPressedState=new UnsetPressedState();
        }
        if (!post(mUnsetPressedState)) {
          mUnsetPressedState.run();
        }
      }
    break;
case MotionEvent.ACTION_DOWN:
  mPrivateFlags|=PRESSED;
refreshDrawableState();
if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
postCheckForLongClick();
}
break;
case MotionEvent.ACTION_CANCEL:
mPrivateFlags&=~PRESSED;
refreshDrawableState();
break;
case MotionEvent.ACTION_MOVE:
final int x=(int)event.getX();
final int y=(int)event.getY();
int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
if ((x < 0 - slop) || (x >= getWidth() + slop) || (y < 0 - slop)|| (y >= getHeight() + slop)) {
if ((mPrivateFlags & PRESSED) != 0) {
cancelLongPress();
mPrivateFlags&=~PRESSED;
refreshDrawableState();
}
}
 else {
if ((mPrivateFlags & PRESSED) == 0) {
mPrivateFlags|=PRESSED;
refreshDrawableState();
}
}
break;
}
return true;
}
return false;
}","/** 
 * Implement this method to handle touch screen motion events.
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
public boolean onTouchEvent(MotionEvent event){
  final int viewFlags=mViewFlags;
  if ((viewFlags & ENABLED_MASK) == DISABLED) {
    return (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE));
  }
  if (mTouchDelegate != null) {
    if (mTouchDelegate.onTouchEvent(event)) {
      return true;
    }
  }
  if (((viewFlags & CLICKABLE) == CLICKABLE || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)) {
switch (event.getAction()) {
case MotionEvent.ACTION_UP:
      if ((mPrivateFlags & PRESSED) != 0) {
        boolean focusTaken=false;
        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
          focusTaken=requestFocus();
        }
        if (!mHasPerformedLongPress) {
          removeLongPressCallback();
          if (!focusTaken) {
            performClick();
          }
        }
        if (mUnsetPressedState == null) {
          mUnsetPressedState=new UnsetPressedState();
        }
        if (!post(mUnsetPressedState)) {
          mUnsetPressedState.run();
        }
      }
    break;
case MotionEvent.ACTION_DOWN:
  mPrivateFlags|=PRESSED;
refreshDrawableState();
if ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {
postCheckForLongClick();
}
break;
case MotionEvent.ACTION_CANCEL:
mPrivateFlags&=~PRESSED;
refreshDrawableState();
break;
case MotionEvent.ACTION_MOVE:
final int x=(int)event.getX();
final int y=(int)event.getY();
int slop=ViewConfiguration.get(mContext).getScaledTouchSlop();
if ((x < 0 - slop) || (x >= getWidth() + slop) || (y < 0 - slop)|| (y >= getHeight() + slop)) {
if ((mPrivateFlags & PRESSED) != 0) {
removeLongPressCallback();
mPrivateFlags&=~PRESSED;
refreshDrawableState();
}
}
 else {
if ((mPrivateFlags & PRESSED) == 0) {
mPrivateFlags|=PRESSED;
refreshDrawableState();
}
}
break;
}
return true;
}
return false;
}"
23320,"/** 
 * Called when the window containing this view gains or loses focus.  Note that this is separate from view focus: to receive key events, both your view and its window must have focus.  If a window is displayed on top of yours that takes input focus, then your own window will lose focus but the view focus will remain unchanged.
 * @param hasWindowFocus True if the window containing this view now hasfocus, false otherwise.
 */
public void onWindowFocusChanged(boolean hasWindowFocus){
  InputMethodManager imm=InputMethodManager.peekInstance();
  if (!hasWindowFocus) {
    if (isPressed()) {
      setPressed(false);
    }
    if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
      imm.focusOut(this);
    }
    cancelLongPress();
    onFocusLost();
  }
 else   if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
    imm.focusIn(this);
  }
  refreshDrawableState();
}","/** 
 * Called when the window containing this view gains or loses focus.  Note that this is separate from view focus: to receive key events, both your view and its window must have focus.  If a window is displayed on top of yours that takes input focus, then your own window will lose focus but the view focus will remain unchanged.
 * @param hasWindowFocus True if the window containing this view now hasfocus, false otherwise.
 */
public void onWindowFocusChanged(boolean hasWindowFocus){
  InputMethodManager imm=InputMethodManager.peekInstance();
  if (!hasWindowFocus) {
    if (isPressed()) {
      setPressed(false);
    }
    if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
      imm.focusOut(this);
    }
    removeLongPressCallback();
    onFocusLost();
  }
 else   if (imm != null && (mPrivateFlags & FOCUSED) != 0) {
    imm.focusIn(this);
  }
  refreshDrawableState();
}"
23321,"/** 
 * This is called when the view is detached from a window.  At this point it no longer has a surface for drawing.
 * @see #onAttachedToWindow()
 */
protected void onDetachedFromWindow(){
  cancelLongPress();
  destroyDrawingCache();
}","/** 
 * This is called when the view is detached from a window.  At this point it no longer has a surface for drawing.
 * @see #onAttachedToWindow()
 */
protected void onDetachedFromWindow(){
  removeLongPressCallback();
  destroyDrawingCache();
}"
23322,"/** 
 * When visibility is set to   {@link #VISIBLE} or {@link #INVISIBLE},  {@link #inflate()} is invoked and this StubbedView is replaced in its parentby the inflated layout resource.
 * @param visibility One of {@link #VISIBLE},   {@link #INVISIBLE}, or   {@link #GONE}.
 * @see #inflate() 
 */
@Override public void setVisibility(int visibility){
  if (mInflatedViewRef != null) {
    View view=mInflatedViewRef.get();
    if (view != null) {
      view.setVisibility(visibility);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 else   if (visibility == VISIBLE || visibility == INVISIBLE) {
    super.setVisibility(visibility);
    inflate();
  }
}","/** 
 * When visibility is set to   {@link #VISIBLE} or {@link #INVISIBLE},  {@link #inflate()} is invoked and this StubbedView is replaced in its parentby the inflated layout resource.
 * @param visibility One of {@link #VISIBLE},   {@link #INVISIBLE}, or   {@link #GONE}.
 * @see #inflate() 
 */
@Override public void setVisibility(int visibility){
  if (mInflatedViewRef != null) {
    View view=mInflatedViewRef.get();
    if (view != null) {
      view.setVisibility(visibility);
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 else {
    super.setVisibility(visibility);
    if (visibility == VISIBLE || visibility == INVISIBLE) {
      inflate();
    }
  }
}"
23323,"/** 
 * Inflates the layout resource identified by   {@link #getLayoutResource()}and replaces this StubbedView in its parent by the inflated layout resource.
 * @return The inflated layout resource.
 */
public View inflate(){
  final ViewParent viewParent=getParent();
  if (viewParent != null && viewParent instanceof ViewGroup) {
    if (mLayoutResource != 0) {
      final ViewGroup parent=(ViewGroup)viewParent;
      final LayoutInflater factory=LayoutInflater.from(mContext);
      final View view=factory.inflate(mLayoutResource,parent,false);
      if (mInflatedId != NO_ID) {
        view.setId(mInflatedId);
      }
      final int index=parent.indexOfChild(this);
      parent.removeViewInLayout(this);
      final ViewGroup.LayoutParams layoutParams=getLayoutParams();
      if (layoutParams != null) {
        parent.addView(view,index,layoutParams);
      }
 else {
        parent.addView(view,index);
      }
      mInflatedViewRef=new WeakReference(view);
      if (mInflateListener != null) {
        mInflateListener.onInflate(this,view);
      }
      return view;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}","/** 
 * Inflates the layout resource identified by   {@link #getLayoutResource()}and replaces this StubbedView in its parent by the inflated layout resource.
 * @return The inflated layout resource.
 */
public View inflate(){
  final ViewParent viewParent=getParent();
  if (viewParent != null && viewParent instanceof ViewGroup) {
    if (mLayoutResource != 0) {
      final ViewGroup parent=(ViewGroup)viewParent;
      final LayoutInflater factory=LayoutInflater.from(mContext);
      final View view=factory.inflate(mLayoutResource,parent,false);
      if (mInflatedId != NO_ID) {
        view.setId(mInflatedId);
      }
      final int index=parent.indexOfChild(this);
      parent.removeViewInLayout(this);
      final ViewGroup.LayoutParams layoutParams=getLayoutParams();
      if (layoutParams != null) {
        parent.addView(view,index,layoutParams);
      }
 else {
        parent.addView(view,index);
      }
      mInflatedViewRef=new WeakReference<View>(view);
      if (mInflateListener != null) {
        mInflateListener.onInflate(this,view);
      }
      return view;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
}"
23324,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}"
23325,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}"
23326,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}"
23327,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}"
23328,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}"
23329,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}"
23330,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}"
23331,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}"
23332,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}"
23333,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}"
23334,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}"
23335,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}"
23336,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}"
23337,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}"
23338,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}"
23339,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}"
23340,"public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed){
  ActivityRecord r=new ActivityRecord();
  r.token=token;
  r.pendingResults=pendingResults;
  r.pendingIntents=pendingNewIntents;
  r.startsNotResumed=notResumed;
synchronized (mRelaunchingActivities) {
    mRelaunchingActivities.add(r);
  }
  queueOrSendMessage(H.RELAUNCH_ACTIVITY,r,configChanges);
}","public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed,Configuration config){
  ActivityRecord r=new ActivityRecord();
  r.token=token;
  r.pendingResults=pendingResults;
  r.pendingIntents=pendingNewIntents;
  r.startsNotResumed=notResumed;
  r.createdConfig=config;
synchronized (mRelaunchingActivities) {
    mRelaunchingActivities.add(r);
  }
  queueOrSendMessage(H.RELAUNCH_ACTIVITY,r,configChanges);
}"
23341,"private final void handleRelaunchActivity(ActivityRecord tmp,int configChanges){
  unscheduleGcIdler();
  Configuration changedConfig=null;
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ Integer.toHexString(configChanges));
synchronized (mRelaunchingActivities) {
    int N=mRelaunchingActivities.size();
    IBinder token=tmp.token;
    tmp=null;
    for (int i=0; i < N; i++) {
      ActivityRecord r=mRelaunchingActivities.get(i);
      if (r.token == token) {
        tmp=r;
        mRelaunchingActivities.remove(i);
        i--;
        N--;
      }
    }
    if (tmp == null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"");
      return;
    }
    if (mPendingConfiguration != null) {
      changedConfig=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ changedConfig);
  if (changedConfig != null) {
    handleConfigurationChanged(changedConfig);
  }
  ActivityRecord r=mActivities.get(tmp.token);
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + r);
  if (r == null) {
    return;
  }
  r.activity.mConfigChangeFlags|=configChanges;
  Intent currentIntent=r.activity.mIntent;
  Bundle savedState=null;
  if (!r.paused) {
    savedState=performPauseActivity(r.token,false,true);
  }
  handleDestroyActivity(r.token,false,configChanges,true);
  r.activity=null;
  r.window=null;
  r.hideForNow=false;
  r.nextIdle=null;
  if (tmp.pendingResults != null) {
    if (r.pendingResults == null) {
      r.pendingResults=tmp.pendingResults;
    }
 else {
      r.pendingResults.addAll(tmp.pendingResults);
    }
  }
  if (tmp.pendingIntents != null) {
    if (r.pendingIntents == null) {
      r.pendingIntents=tmp.pendingIntents;
    }
 else {
      r.pendingIntents.addAll(tmp.pendingIntents);
    }
  }
  r.startsNotResumed=tmp.startsNotResumed;
  if (savedState != null) {
    r.state=savedState;
  }
  handleLaunchActivity(r,currentIntent);
}","private final void handleRelaunchActivity(ActivityRecord tmp,int configChanges){
  unscheduleGcIdler();
  Configuration changedConfig=null;
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ Integer.toHexString(configChanges));
synchronized (mRelaunchingActivities) {
    int N=mRelaunchingActivities.size();
    IBinder token=tmp.token;
    tmp=null;
    for (int i=0; i < N; i++) {
      ActivityRecord r=mRelaunchingActivities.get(i);
      if (r.token == token) {
        tmp=r;
        mRelaunchingActivities.remove(i);
        i--;
        N--;
      }
    }
    if (tmp == null) {
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"");
      return;
    }
    if (mPendingConfiguration != null) {
      changedConfig=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  if (tmp.createdConfig != null) {
    if (mConfiguration == null || mConfiguration.diff(tmp.createdConfig) != 0) {
      changedConfig=tmp.createdConfig;
    }
  }
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + tmp.token + ""String_Node_Str""+ changedConfig);
  if (changedConfig != null) {
    handleConfigurationChanged(changedConfig);
  }
  ActivityRecord r=mActivities.get(tmp.token);
  if (DEBUG_CONFIGURATION)   Log.v(TAG,""String_Node_Str"" + r);
  if (r == null) {
    return;
  }
  r.activity.mConfigChangeFlags|=configChanges;
  Intent currentIntent=r.activity.mIntent;
  Bundle savedState=null;
  if (!r.paused) {
    savedState=performPauseActivity(r.token,false,true);
  }
  handleDestroyActivity(r.token,false,configChanges,true);
  r.activity=null;
  r.window=null;
  r.hideForNow=false;
  r.nextIdle=null;
  if (tmp.pendingResults != null) {
    if (r.pendingResults == null) {
      r.pendingResults=tmp.pendingResults;
    }
 else {
      r.pendingResults.addAll(tmp.pendingResults);
    }
  }
  if (tmp.pendingIntents != null) {
    if (r.pendingIntents == null) {
      r.pendingIntents=tmp.pendingIntents;
    }
 else {
      r.pendingIntents.addAll(tmp.pendingIntents);
    }
  }
  r.startsNotResumed=tmp.startsNotResumed;
  if (savedState != null) {
    r.state=savedState;
  }
  handleLaunchActivity(r,currentIntent);
}"
23342,"private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(a.getResources().getConfiguration());
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","private final void handleLaunchActivity(ActivityRecord r,Intent customIntent){
  unscheduleGcIdler();
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r);
  Activity a=performLaunchActivity(r,customIntent);
  if (a != null) {
    r.createdConfig=new Configuration(mConfiguration);
    handleResumeActivity(r.token,false,r.isForward);
    if (!r.activity.mFinished && r.startsNotResumed) {
      try {
        r.activity.mCalled=false;
        mInstrumentation.callActivityOnPause(r.activity);
        if (!r.activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
 catch (      SuperNotCalledException e) {
        throw e;
      }
catch (      Exception e) {
        if (!mInstrumentation.onException(r.activity,e)) {
          throw new RuntimeException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str""+ e.toString(),e);
        }
      }
      r.paused=true;
    }
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(r.token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}"
23343,"public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeStrongBinder(token);
  data.writeTypedList(pendingResults);
  data.writeTypedList(pendingNewIntents);
  data.writeInt(configChanges);
  data.writeInt(notResumed ? 1 : 0);
  mRemote.transact(SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}","public final void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed,Configuration config) throws RemoteException {
  Parcel data=Parcel.obtain();
  data.writeInterfaceToken(IApplicationThread.descriptor);
  data.writeStrongBinder(token);
  data.writeTypedList(pendingResults);
  data.writeTypedList(pendingNewIntents);
  data.writeInt(configChanges);
  data.writeInt(notResumed ? 1 : 0);
  if (config != null) {
    data.writeInt(1);
    config.writeToParcel(data,0);
  }
 else {
    data.writeInt(0);
  }
  mRemote.transact(SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION,data,null,IBinder.FLAG_ONEWAY);
  data.recycle();
}"
23344,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case SCHEDULE_PAUSE_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IApplicationThread.descriptor);
      IBinder b=data.readStrongBinder();
      boolean finished=data.readInt() != 0;
      boolean userLeaving=data.readInt() != 0;
      int configChanges=data.readInt();
      schedulePauseActivity(b,finished,userLeaving,configChanges);
      return true;
    }
case SCHEDULE_STOP_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IApplicationThread.descriptor);
    IBinder b=data.readStrongBinder();
    boolean show=data.readInt() != 0;
    int configChanges=data.readInt();
    scheduleStopActivity(b,show,configChanges);
    return true;
  }
case SCHEDULE_WINDOW_VISIBILITY_TRANSACTION:
{
  data.enforceInterface(IApplicationThread.descriptor);
  IBinder b=data.readStrongBinder();
  boolean show=data.readInt() != 0;
  scheduleWindowVisibility(b,show);
  return true;
}
case SCHEDULE_RESUME_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean isForward=data.readInt() != 0;
scheduleResumeActivity(b,isForward);
return true;
}
case SCHEDULE_SEND_RESULT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
scheduleSendResult(b,ri);
return true;
}
case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder b=data.readStrongBinder();
int ident=data.readInt();
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
Bundle state=data.readBundle();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
boolean notResumed=data.readInt() != 0;
boolean isForward=data.readInt() != 0;
scheduleLaunchActivity(intent,b,ident,info,state,ri,pi,notResumed,isForward);
return true;
}
case SCHEDULE_RELAUNCH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
List<ResultInfo> ri=data.createTypedArrayList(ResultInfo.CREATOR);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
int configChanges=data.readInt();
boolean notResumed=data.readInt() != 0;
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
scheduleRelaunchActivity(b,ri,pi,configChanges,notResumed,config);
return true;
}
case SCHEDULE_NEW_INTENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
List<Intent> pi=data.createTypedArrayList(Intent.CREATOR);
IBinder b=data.readStrongBinder();
scheduleNewIntent(pi,b);
return true;
}
case SCHEDULE_FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
boolean finishing=data.readInt() != 0;
int configChanges=data.readInt();
scheduleDestroyActivity(b,finishing,configChanges);
return true;
}
case SCHEDULE_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityInfo info=ActivityInfo.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean sync=data.readInt() != 0;
scheduleReceiver(intent,info,resultCode,resultData,resultExtras,sync);
return true;
}
case SCHEDULE_CREATE_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
ServiceInfo info=ServiceInfo.CREATOR.createFromParcel(data);
scheduleCreateService(token,info);
return true;
}
case SCHEDULE_BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean rebind=data.readInt() != 0;
scheduleBindService(token,intent,rebind);
return true;
}
case SCHEDULE_UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
scheduleUnbindService(token,intent);
return true;
}
case SCHEDULE_SERVICE_ARGS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
int fl=data.readInt();
Intent args;
if (data.readInt() != 0) {
args=Intent.CREATOR.createFromParcel(data);
}
 else {
args=null;
}
scheduleServiceArgs(token,startId,fl,args);
return true;
}
case SCHEDULE_STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder token=data.readStrongBinder();
scheduleStopService(token);
return true;
}
case BIND_APPLICATION_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
String packageName=data.readString();
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
List<ProviderInfo> providers=data.createTypedArrayList(ProviderInfo.CREATOR);
ComponentName testName=(data.readInt() != 0) ? new ComponentName(data) : null;
String profileName=data.readString();
Bundle testArgs=data.readBundle();
IBinder binder=data.readStrongBinder();
IInstrumentationWatcher testWatcher=IInstrumentationWatcher.Stub.asInterface(binder);
int testMode=data.readInt();
boolean restrictedBackupMode=(data.readInt() != 0);
Configuration config=Configuration.CREATOR.createFromParcel(data);
HashMap<String,IBinder> services=data.readHashMap(null);
bindApplication(packageName,info,providers,testName,profileName,testArgs,testWatcher,testMode,restrictedBackupMode,config,services);
return true;
}
case SCHEDULE_EXIT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleExit();
return true;
}
case SCHEDULE_SUICIDE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
scheduleSuicide();
return true;
}
case REQUEST_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
requestThumbnail(b);
return true;
}
case SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
scheduleConfigurationChanged(config);
return true;
}
case UPDATE_TIME_ZONE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
updateTimeZone();
return true;
}
case PROCESS_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
processInBackground();
return true;
}
case DUMP_SERVICE_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ParcelFileDescriptor fd=data.readFileDescriptor();
final IBinder service=data.readStrongBinder();
final String[] args=data.readStringArray();
if (fd != null) {
dumpService(fd.getFileDescriptor(),service,args);
try {
fd.close();
}
 catch (IOException e) {
}
}
return true;
}
case SCHEDULE_REGISTERED_RECEIVER_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IIntentReceiver receiver=IIntentReceiver.Stub.asInterface(data.readStrongBinder());
Intent intent=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
String dataStr=data.readString();
Bundle extras=data.readBundle();
boolean ordered=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
scheduleRegisteredReceiver(receiver,intent,resultCode,dataStr,extras,ordered,sticky);
return true;
}
case SCHEDULE_LOW_MEMORY_TRANSACTION:
{
scheduleLowMemory();
return true;
}
case SCHEDULE_ACTIVITY_CONFIGURATION_CHANGED_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
IBinder b=data.readStrongBinder();
scheduleActivityConfigurationChanged(b);
return true;
}
case REQUEST_PSS_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
requestPss();
return true;
}
case PROFILER_CONTROL_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
profilerControl(start,path,fd);
return true;
}
case SET_SCHEDULING_GROUP_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
int group=data.readInt();
setSchedulingGroup(group);
return true;
}
case SCHEDULE_CREATE_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
int backupMode=data.readInt();
scheduleCreateBackupAgent(appInfo,backupMode);
return true;
}
case SCHEDULE_DESTROY_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
ApplicationInfo appInfo=ApplicationInfo.CREATOR.createFromParcel(data);
scheduleDestroyBackupAgent(appInfo);
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IApplicationThread.descriptor);
Debug.MemoryInfo mi=new Debug.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
}
return super.onTransact(code,data,reply,flags);
}"
23345,"void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed) throws RemoteException ;","void scheduleRelaunchActivity(IBinder token,List<ResultInfo> pendingResults,List<Intent> pendingNewIntents,int configChanges,boolean notResumed,Configuration config) throws RemoteException ;"
23346,"private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    reportResumedActivityLocked(r);
  }
  return true;
}","private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume,mConfiguration);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    reportResumedActivityLocked(r);
  }
  return true;
}"
23347,"private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}","private final void sendIntent(int headset,int headsetState,int prevHeadsetState,String headsetName){
  if ((headsetState & headset) != (prevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((headsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",headsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ headsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}"
23348,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  sendIntents(msg.arg1,msg.arg2,(String)msg.obj);
  mWakeLock.release();
}"
23349,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendMessageDelayed(mHandler.obtainMessage(0,mHeadsetState,mPrevHeadsetState,mHeadsetName),1000);
  }
 else {
    sendIntents(mHeadsetState,mPrevHeadsetState,mHeadsetName);
  }
}"
23350,"private synchronized final void sendIntents(){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset);
      allHeadsets&=~curHeadset;
    }
  }
}","private synchronized final void sendIntents(int headsetState,int prevHeadsetState,String headsetName){
  int allHeadsets=SUPPORTED_HEADSETS;
  for (int curHeadset=1; allHeadsets != 0; curHeadset<<=1) {
    if ((curHeadset & allHeadsets) != 0) {
      sendIntent(curHeadset,headsetState,prevHeadsetState,headsetName);
      allHeadsets&=~curHeadset;
    }
  }
}"
23351,"@Override protected void layoutChildren(){
  final boolean blockLayoutRequests=mBlockLayoutRequests;
  if (!blockLayoutRequests) {
    mBlockLayoutRequests=true;
  }
 else {
    return;
  }
  try {
    super.layoutChildren();
    invalidate();
    if (mAdapter == null) {
      resetList();
      invokeOnItemScrollListener();
      return;
    }
    int childrenTop=mListPadding.top;
    int childrenBottom=mBottom - mTop - mListPadding.bottom;
    int childCount=getChildCount();
    int index;
    int delta=0;
    View sel;
    View oldSel=null;
    View oldFirst=null;
    View newSel=null;
    View focusLayoutRestoreView=null;
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
      index=mNextSelectedPosition - mFirstPosition;
    if (index >= 0 && index < childCount) {
      newSel=getChildAt(index);
    }
  break;
case LAYOUT_FORCE_TOP:
case LAYOUT_FORCE_BOTTOM:
case LAYOUT_SPECIFIC:
case LAYOUT_SYNC:
break;
case LAYOUT_MOVE_SELECTION:
default :
index=mSelectedPosition - mFirstPosition;
if (index >= 0 && index < childCount) {
oldSel=getChildAt(index);
}
oldFirst=getChildAt(0);
if (mNextSelectedPosition >= 0) {
delta=mNextSelectedPosition - mSelectedPosition;
}
newSel=getChildAt(index + delta);
}
boolean dataChanged=mDataChanged;
if (dataChanged) {
handleDataChanged();
}
if (mItemCount == 0) {
resetList();
invokeOnItemScrollListener();
return;
}
 else if (mItemCount != mAdapter.getCount()) {
throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + getId() + ""String_Node_Str""+ getClass()+ ""String_Node_Str""+ mAdapter.getClass()+ ""String_Node_Str"");
}
setSelectedPositionInt(mNextSelectedPosition);
final int firstPosition=mFirstPosition;
final RecycleBin recycleBin=mRecycler;
View focusLayoutRestoreDirectChild=null;
if (dataChanged) {
for (int i=0; i < childCount; i++) {
recycleBin.addScrapView(getChildAt(i));
if (ViewDebug.TRACE_RECYCLER) {
ViewDebug.trace(getChildAt(i),ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,index,i);
}
}
}
 else {
recycleBin.fillActiveViews(childCount,firstPosition);
}
final View focusedChild=getFocusedChild();
if (focusedChild != null) {
if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
focusLayoutRestoreDirectChild=focusedChild;
focusLayoutRestoreView=findFocus();
if (focusLayoutRestoreView != null) {
focusLayoutRestoreView.onStartTemporaryDetach();
}
}
requestFocus();
}
detachAllViewsFromParent();
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
if (newSel != null) {
sel=fillFromSelection(newSel.getTop(),childrenTop,childrenBottom);
}
 else {
sel=fillFromMiddle(childrenTop,childrenBottom);
}
break;
case LAYOUT_SYNC:
sel=fillSpecific(mSyncPosition,mSpecificTop);
break;
case LAYOUT_FORCE_BOTTOM:
sel=fillUp(mItemCount - 1,childrenBottom);
adjustViewsUpOrDown();
break;
case LAYOUT_FORCE_TOP:
mFirstPosition=0;
sel=fillFromTop(childrenTop);
adjustViewsUpOrDown();
break;
case LAYOUT_SPECIFIC:
sel=fillSpecific(reconcileSelectedPosition(),mSpecificTop);
break;
case LAYOUT_MOVE_SELECTION:
sel=moveSelection(oldSel,newSel,delta,childrenTop,childrenBottom);
break;
default :
if (childCount == 0) {
if (!mStackFromBottom) {
final int position=lookForSelectablePosition(0,true);
setSelectedPositionInt(position);
sel=fillFromTop(childrenTop);
}
 else {
final int position=lookForSelectablePosition(mItemCount - 1,false);
setSelectedPositionInt(position);
sel=fillUp(mItemCount - 1,childrenBottom);
}
}
 else {
if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
sel=fillSpecific(mSelectedPosition,oldSel == null ? childrenTop : oldSel.getTop());
}
 else if (mFirstPosition < mItemCount) {
sel=fillSpecific(mFirstPosition,oldFirst == null ? childrenTop : oldFirst.getTop());
}
 else {
sel=fillSpecific(0,childrenTop);
}
}
break;
}
recycleBin.scrapActiveViews();
if (sel != null) {
if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
final boolean focusWasTaken=(sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
if (!focusWasTaken) {
final View focused=getFocusedChild();
if (focused != null) {
focused.clearFocus();
}
positionSelector(sel);
}
 else {
sel.setSelected(false);
mSelectorRect.setEmpty();
}
}
 else {
positionSelector(sel);
}
mSelectedTop=sel.getTop();
}
 else {
if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
View child=getChildAt(mMotionPosition - mFirstPosition);
if (child != null) positionSelector(child);
}
 else {
mSelectedTop=0;
mSelectorRect.setEmpty();
}
if (hasFocus() && focusLayoutRestoreView != null) {
focusLayoutRestoreView.requestFocus();
}
}
if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
focusLayoutRestoreView.onFinishTemporaryDetach();
}
mLayoutMode=LAYOUT_NORMAL;
mDataChanged=false;
mNeedSync=false;
setNextSelectedPositionInt(mSelectedPosition);
updateScrollIndicators();
if (mItemCount > 0) {
checkSelectionChanged();
}
invokeOnItemScrollListener();
}
  finally {
if (!blockLayoutRequests) {
mBlockLayoutRequests=false;
}
}
}","@Override protected void layoutChildren(){
  final boolean blockLayoutRequests=mBlockLayoutRequests;
  if (!blockLayoutRequests) {
    mBlockLayoutRequests=true;
  }
 else {
    return;
  }
  try {
    super.layoutChildren();
    invalidate();
    if (mAdapter == null) {
      resetList();
      invokeOnItemScrollListener();
      return;
    }
    int childrenTop=mListPadding.top;
    int childrenBottom=mBottom - mTop - mListPadding.bottom;
    int childCount=getChildCount();
    int index=0;
    int delta=0;
    View sel;
    View oldSel=null;
    View oldFirst=null;
    View newSel=null;
    View focusLayoutRestoreView=null;
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
      index=mNextSelectedPosition - mFirstPosition;
    if (index >= 0 && index < childCount) {
      newSel=getChildAt(index);
    }
  break;
case LAYOUT_FORCE_TOP:
case LAYOUT_FORCE_BOTTOM:
case LAYOUT_SPECIFIC:
case LAYOUT_SYNC:
break;
case LAYOUT_MOVE_SELECTION:
default :
index=mSelectedPosition - mFirstPosition;
if (index >= 0 && index < childCount) {
oldSel=getChildAt(index);
}
oldFirst=getChildAt(0);
if (mNextSelectedPosition >= 0) {
delta=mNextSelectedPosition - mSelectedPosition;
}
newSel=getChildAt(index + delta);
}
boolean dataChanged=mDataChanged;
if (dataChanged) {
handleDataChanged();
}
if (mItemCount == 0) {
resetList();
invokeOnItemScrollListener();
return;
}
 else if (mItemCount != mAdapter.getCount()) {
throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + getId() + ""String_Node_Str""+ getClass()+ ""String_Node_Str""+ mAdapter.getClass()+ ""String_Node_Str"");
}
setSelectedPositionInt(mNextSelectedPosition);
final int firstPosition=mFirstPosition;
final RecycleBin recycleBin=mRecycler;
View focusLayoutRestoreDirectChild=null;
if (dataChanged) {
for (int i=0; i < childCount; i++) {
recycleBin.addScrapView(getChildAt(i));
if (ViewDebug.TRACE_RECYCLER) {
ViewDebug.trace(getChildAt(i),ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP,index,i);
}
}
}
 else {
recycleBin.fillActiveViews(childCount,firstPosition);
}
final View focusedChild=getFocusedChild();
if (focusedChild != null) {
if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) {
focusLayoutRestoreDirectChild=focusedChild;
focusLayoutRestoreView=findFocus();
if (focusLayoutRestoreView != null) {
focusLayoutRestoreView.onStartTemporaryDetach();
}
}
requestFocus();
}
detachAllViewsFromParent();
switch (mLayoutMode) {
case LAYOUT_SET_SELECTION:
if (newSel != null) {
sel=fillFromSelection(newSel.getTop(),childrenTop,childrenBottom);
}
 else {
sel=fillFromMiddle(childrenTop,childrenBottom);
}
break;
case LAYOUT_SYNC:
sel=fillSpecific(mSyncPosition,mSpecificTop);
break;
case LAYOUT_FORCE_BOTTOM:
sel=fillUp(mItemCount - 1,childrenBottom);
adjustViewsUpOrDown();
break;
case LAYOUT_FORCE_TOP:
mFirstPosition=0;
sel=fillFromTop(childrenTop);
adjustViewsUpOrDown();
break;
case LAYOUT_SPECIFIC:
sel=fillSpecific(reconcileSelectedPosition(),mSpecificTop);
break;
case LAYOUT_MOVE_SELECTION:
sel=moveSelection(oldSel,newSel,delta,childrenTop,childrenBottom);
break;
default :
if (childCount == 0) {
if (!mStackFromBottom) {
final int position=lookForSelectablePosition(0,true);
setSelectedPositionInt(position);
sel=fillFromTop(childrenTop);
}
 else {
final int position=lookForSelectablePosition(mItemCount - 1,false);
setSelectedPositionInt(position);
sel=fillUp(mItemCount - 1,childrenBottom);
}
}
 else {
if (mSelectedPosition >= 0 && mSelectedPosition < mItemCount) {
sel=fillSpecific(mSelectedPosition,oldSel == null ? childrenTop : oldSel.getTop());
}
 else if (mFirstPosition < mItemCount) {
sel=fillSpecific(mFirstPosition,oldFirst == null ? childrenTop : oldFirst.getTop());
}
 else {
sel=fillSpecific(0,childrenTop);
}
}
break;
}
recycleBin.scrapActiveViews();
if (sel != null) {
if (mItemsCanFocus && hasFocus() && !sel.hasFocus()) {
final boolean focusWasTaken=(sel == focusLayoutRestoreDirectChild && focusLayoutRestoreView.requestFocus()) || sel.requestFocus();
if (!focusWasTaken) {
final View focused=getFocusedChild();
if (focused != null) {
focused.clearFocus();
}
positionSelector(sel);
}
 else {
sel.setSelected(false);
mSelectorRect.setEmpty();
}
}
 else {
positionSelector(sel);
}
mSelectedTop=sel.getTop();
}
 else {
if (mTouchMode > TOUCH_MODE_DOWN && mTouchMode < TOUCH_MODE_SCROLL) {
View child=getChildAt(mMotionPosition - mFirstPosition);
if (child != null) positionSelector(child);
}
 else {
mSelectedTop=0;
mSelectorRect.setEmpty();
}
if (hasFocus() && focusLayoutRestoreView != null) {
focusLayoutRestoreView.requestFocus();
}
}
if (focusLayoutRestoreView != null && focusLayoutRestoreView.getWindowToken() != null) {
focusLayoutRestoreView.onFinishTemporaryDetach();
}
mLayoutMode=LAYOUT_NORMAL;
mDataChanged=false;
mNeedSync=false;
setNextSelectedPositionInt(mSelectedPosition);
updateScrollIndicators();
if (mItemCount > 0) {
checkSelectionChanged();
}
invokeOnItemScrollListener();
}
  finally {
if (!blockLayoutRequests) {
mBlockLayoutRequests=false;
}
}
}"
23352,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}"
23353,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}"
23354,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}"
23355,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}"
23356,"/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}","/** 
 * {@inheritDoc} 
 */
public int windowTypeToLayerLw(int type){
  if (type >= FIRST_APPLICATION_WINDOW && type <= LAST_APPLICATION_WINDOW) {
    return APPLICATION_LAYER;
  }
switch (type) {
case TYPE_STATUS_BAR:
    return STATUS_BAR_LAYER;
case TYPE_STATUS_BAR_PANEL:
  return STATUS_BAR_PANEL_LAYER;
case TYPE_SYSTEM_DIALOG:
return SYSTEM_DIALOG_LAYER;
case TYPE_SEARCH_BAR:
return SEARCH_BAR_LAYER;
case TYPE_PHONE:
return PHONE_LAYER;
case TYPE_KEYGUARD:
return KEYGUARD_LAYER;
case TYPE_KEYGUARD_DIALOG:
return KEYGUARD_DIALOG_LAYER;
case TYPE_SYSTEM_ALERT:
return SYSTEM_ALERT_LAYER;
case TYPE_SYSTEM_ERROR:
return SYSTEM_ERROR_LAYER;
case TYPE_INPUT_METHOD:
return INPUT_METHOD_LAYER;
case TYPE_INPUT_METHOD_DIALOG:
return INPUT_METHOD_DIALOG_LAYER;
case TYPE_SYSTEM_OVERLAY:
return SYSTEM_OVERLAY_LAYER;
case TYPE_PRIORITY_PHONE:
return PRIORITY_PHONE_LAYER;
case TYPE_TOAST:
return TOAST_LAYER;
case TYPE_WALLPAPER:
return WALLPAPER_LAYER;
}
Log.e(TAG,""String_Node_Str"" + type);
return APPLICATION_LAYER;
}"
23357,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23358,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23359,"private boolean assignPointer(int nextIndex,boolean allowOverlap){
  final int lastNumPointers=mLastNumPointers;
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  final int[] last2Next=mLast2Next;
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int id=nextIndex * MotionEvent.NUM_SAMPLE_DATA;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ id);
  final int x1=nextData[id + MotionEvent.SAMPLE_X];
  final int y1=nextData[id + MotionEvent.SAMPLE_Y];
  long bestDistance=-1;
  int bestIndex=-1;
  for (int j=0; j < lastNumPointers; j++) {
    if (!allowOverlap && last2Next[j] < 0) {
      continue;
    }
    final int jd=j * MotionEvent.NUM_SAMPLE_DATA;
    final int xd=lastData[jd + MotionEvent.SAMPLE_X] - x1;
    final int yd=lastData[jd + MotionEvent.SAMPLE_Y] - y1;
    final long distance=xd * (long)xd + yd * (long)yd;
    if (j == 0 || distance < bestDistance) {
      bestDistance=distance;
      bestIndex=j;
    }
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ bestIndex+ ""String_Node_Str""+ bestDistance+ ""String_Node_Str"");
  next2Last[nextIndex]=bestIndex;
  next2LastDistance[nextIndex]=bestDistance;
  if (bestIndex < 0) {
    return true;
  }
  if (last2Next[bestIndex] == -1) {
    last2Next[bestIndex]=nextIndex;
    return false;
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + bestIndex + ""String_Node_Str"");
  last2Next[bestIndex]=-2;
  return true;
}","private boolean assignPointer(int nextIndex,boolean allowOverlap){
  final int lastNumPointers=mLastNumPointers;
  final int[] next2Last=mNext2Last;
  final long[] next2LastDistance=mNext2LastDistance;
  final int[] last2Next=mLast2Next;
  final int[] lastData=mLastData;
  final int[] nextData=mNextData;
  final int id=nextIndex * MotionEvent.NUM_SAMPLE_DATA;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ id);
  final int x1=nextData[id + MotionEvent.SAMPLE_X];
  final int y1=nextData[id + MotionEvent.SAMPLE_Y];
  long bestDistance=-1;
  int bestIndex=-1;
  for (int j=0; j < lastNumPointers; j++) {
    if (!allowOverlap && last2Next[j] < -1) {
      continue;
    }
    final int jd=j * MotionEvent.NUM_SAMPLE_DATA;
    final int xd=lastData[jd + MotionEvent.SAMPLE_X] - x1;
    final int yd=lastData[jd + MotionEvent.SAMPLE_Y] - y1;
    final long distance=xd * (long)xd + yd * (long)yd;
    if (bestDistance == -1 || distance < bestDistance) {
      bestDistance=distance;
      bestIndex=j;
    }
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + nextIndex + ""String_Node_Str""+ bestIndex+ ""String_Node_Str""+ bestDistance+ ""String_Node_Str"");
  next2Last[nextIndex]=bestIndex;
  next2LastDistance[nextIndex]=bestDistance;
  if (bestIndex < 0) {
    return true;
  }
  if (last2Next[bestIndex] == -1) {
    last2Next[bestIndex]=nextIndex;
    return false;
  }
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + bestIndex + ""String_Node_Str"");
  last2Next[bestIndex]=-2;
  return true;
}"
23360,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23361,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23362,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23363,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23364,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23365,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23366,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23367,"/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      Log.w(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}","/** 
 * @see android.app.KeyguardManager#exitKeyguardSecurely
 */
public void verifyUnlock(WindowManagerPolicy.OnKeyguardExitResult callback){
synchronized (this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mUpdateMonitor.isDeviceProvisioned()) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"");
      callback.onKeyguardExitResult(false);
    }
 else     if (mExitSecureCallback != null) {
      callback.onKeyguardExitResult(false);
    }
 else     if (mExternallyEnabled) {
      if (mHidden) {
        if (isSecure()) {
          callback.onKeyguardExitResult(true);
        }
 else {
          mExitSecureCallback=callback;
          verifyUnlockLocked();
        }
      }
 else {
        Log.w(TAG,""String_Node_Str"");
        callback.onKeyguardExitResult(false);
      }
    }
 else {
      mExitSecureCallback=callback;
      verifyUnlockLocked();
    }
  }
}"
23368,"private ViewManager.ChildView createSurface(WebkitPlugin webkitPlugin,int x,int y,int width,int height){
  if (mWebView == null) {
    return null;
  }
  SurfaceDrawingModel embeddedSurface=webkitPlugin.getEmbeddedSurface();
  if (embeddedSurface == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return null;
  }
  View pluginView=embeddedSurface.getSurface();
  ViewManager.ChildView view=mWebView.mViewManager.createView();
  view.mView=pluginView;
  view.attachView(x,y,width,height);
  return view;
}","private ViewManager.ChildView createSurface(WebkitPlugin webkitPlugin,int x,int y,int width,int height){
  if (mWebView == null) {
    return null;
  }
  SurfaceDrawingModel embeddedSurface=webkitPlugin.getEmbeddedSurface();
  if (embeddedSurface == null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return null;
  }
  View pluginView=embeddedSurface.getSurface();
  pluginView.setWillNotDraw(false);
  ViewManager.ChildView view=mWebView.mViewManager.createView();
  view.mView=pluginView;
  view.attachView(x,y,width,height);
  return view;
}"
23369,"/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardShowing=keyguardIsShowingTq();
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardShowing);
  }
  if (keyguardShowing) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardShowing || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}","/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardActive=(screenIsOn ? mKeyguardMediator.isShowingAndNotHidden() : mKeyguardMediator.isShowing());
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardActive);
  }
  if (keyguardActive) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardActive || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}"
23370,"private void process(){
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  KeyEvent lastKey=null;
  long lastKeyTime=SystemClock.uptimeMillis();
  long nextKeyTime=lastKeyTime + LONG_WAIT;
  long downTime=0;
  int keyRepeatCount=0;
  boolean configChanged=false;
  while (true) {
    long curTime=SystemClock.uptimeMillis();
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + curTime + ""String_Node_Str""+ nextKeyTime);
    QueuedEvent ev=mQueue.getEvent((int)((!configChanged && curTime < nextKeyTime) ? (nextKeyTime - curTime) : 0));
    if (DEBUG_INPUT && ev != null)     Log.v(TAG,""String_Node_Str"" + ev.classType + ""String_Node_Str""+ ev.event);
    if (MEASURE_LATENCY) {
      lt.sample(""String_Node_Str"",System.nanoTime() - ev.whenNano);
    }
    if (lastKey != null && !mPolicy.allowKeyRepeat()) {
      lastKey=null;
      downTime=0;
      lastKeyTime=curTime;
      nextKeyTime=curTime + LONG_WAIT;
    }
    try {
      if (ev != null) {
        curTime=SystemClock.uptimeMillis();
        int eventType;
        if (ev.classType == RawInputEvent.CLASS_TOUCHSCREEN) {
          eventType=eventType((MotionEvent)ev.event);
        }
 else         if (ev.classType == RawInputEvent.CLASS_KEYBOARD || ev.classType == RawInputEvent.CLASS_TRACKBALL) {
          eventType=LocalPowerManager.BUTTON_EVENT;
        }
 else {
          eventType=LocalPowerManager.OTHER_EVENT;
        }
        try {
          if ((curTime - mLastBatteryStatsCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
            mLastBatteryStatsCallTime=curTime;
            mBatteryStats.noteInputEvent();
          }
        }
 catch (        RemoteException e) {
        }
        if (eventType != TOUCH_EVENT && eventType != LONG_TOUCH_EVENT && eventType != CHEEK_EVENT) {
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
 else         if (mLastTouchEventType != eventType || (curTime - mLastUserActivityCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
          mLastUserActivityCallTime=curTime;
          mLastTouchEventType=eventType;
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
switch (ev.classType) {
case RawInputEvent.CLASS_KEYBOARD:
          KeyEvent ke=(KeyEvent)ev.event;
        if (ke.isDown()) {
          lastKey=ke;
          downTime=curTime;
          keyRepeatCount=0;
          lastKeyTime=curTime;
          nextKeyTime=lastKeyTime + ViewConfiguration.getLongPressTimeout();
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
 else {
          lastKey=null;
          downTime=0;
          lastKeyTime=curTime;
          nextKeyTime=curTime + LONG_WAIT;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
      dispatchKey((KeyEvent)ev.event,0,0);
    mQueue.recycleEvent(ev);
  break;
case RawInputEvent.CLASS_TOUCHSCREEN:
dispatchPointer(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_TRACKBALL:
dispatchTrackball(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_CONFIGURATION_CHANGED:
configChanged=true;
break;
default :
mQueue.recycleEvent(ev);
break;
}
}
 else if (configChanged) {
configChanged=false;
sendNewConfiguration();
}
 else if (lastKey != null) {
curTime=SystemClock.uptimeMillis();
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + nextKeyTime + ""String_Node_Str""+ curTime);
if (curTime < nextKeyTime) {
continue;
}
lastKeyTime=nextKeyTime;
nextKeyTime=nextKeyTime + KEY_REPEAT_DELAY;
keyRepeatCount++;
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + keyRepeatCount + ""String_Node_Str""+ nextKeyTime);
KeyEvent newEvent;
if (downTime != 0 && (downTime + ViewConfiguration.getLongPressTimeout()) <= curTime) {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount,lastKey.getFlags() | KeyEvent.FLAG_LONG_PRESS);
downTime=0;
}
 else {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount);
}
dispatchKey(newEvent,0,0);
}
 else {
curTime=SystemClock.uptimeMillis();
lastKeyTime=curTime;
nextKeyTime=curTime + LONG_WAIT;
}
}
 catch (Exception e) {
Log.e(TAG,""String_Node_Str"" + e,e);
}
}
}","private void process(){
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  KeyEvent lastKey=null;
  long lastKeyTime=SystemClock.uptimeMillis();
  long nextKeyTime=lastKeyTime + LONG_WAIT;
  long downTime=0;
  int keyRepeatCount=0;
  boolean configChanged=false;
  while (true) {
    long curTime=SystemClock.uptimeMillis();
    if (DEBUG_INPUT)     Log.v(TAG,""String_Node_Str"" + curTime + ""String_Node_Str""+ nextKeyTime);
    QueuedEvent ev=mQueue.getEvent((int)((!configChanged && curTime < nextKeyTime) ? (nextKeyTime - curTime) : 0));
    if (DEBUG_INPUT && ev != null)     Log.v(TAG,""String_Node_Str"" + ev.classType + ""String_Node_Str""+ ev.event);
    if (MEASURE_LATENCY) {
      lt.sample(""String_Node_Str"",System.nanoTime() - ev.whenNano);
    }
    if (lastKey != null && !mPolicy.allowKeyRepeat()) {
      lastKey=null;
      downTime=0;
      lastKeyTime=curTime;
      nextKeyTime=curTime + LONG_WAIT;
    }
    try {
      if (ev != null) {
        curTime=SystemClock.uptimeMillis();
        int eventType;
        if (ev.classType == RawInputEvent.CLASS_TOUCHSCREEN) {
          eventType=eventType((MotionEvent)ev.event);
        }
 else         if (ev.classType == RawInputEvent.CLASS_KEYBOARD || ev.classType == RawInputEvent.CLASS_TRACKBALL) {
          eventType=LocalPowerManager.BUTTON_EVENT;
        }
 else {
          eventType=LocalPowerManager.OTHER_EVENT;
        }
        try {
          if ((curTime - mLastBatteryStatsCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
            mLastBatteryStatsCallTime=curTime;
            mBatteryStats.noteInputEvent();
          }
        }
 catch (        RemoteException e) {
        }
        if (ev.classType == RawInputEvent.CLASS_CONFIGURATION_CHANGED) {
        }
 else         if (eventType != TOUCH_EVENT && eventType != LONG_TOUCH_EVENT && eventType != CHEEK_EVENT) {
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
 else         if (mLastTouchEventType != eventType || (curTime - mLastUserActivityCallTime) >= MIN_TIME_BETWEEN_USERACTIVITIES) {
          mLastUserActivityCallTime=curTime;
          mLastTouchEventType=eventType;
          mPowerManager.userActivity(curTime,false,eventType,false);
        }
switch (ev.classType) {
case RawInputEvent.CLASS_KEYBOARD:
          KeyEvent ke=(KeyEvent)ev.event;
        if (ke.isDown()) {
          lastKey=ke;
          downTime=curTime;
          keyRepeatCount=0;
          lastKeyTime=curTime;
          nextKeyTime=lastKeyTime + ViewConfiguration.getLongPressTimeout();
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
 else {
          lastKey=null;
          downTime=0;
          lastKeyTime=curTime;
          nextKeyTime=curTime + LONG_WAIT;
          if (DEBUG_INPUT)           Log.v(TAG,""String_Node_Str"" + nextKeyTime);
        }
      dispatchKey((KeyEvent)ev.event,0,0);
    mQueue.recycleEvent(ev);
  break;
case RawInputEvent.CLASS_TOUCHSCREEN:
dispatchPointer(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_TRACKBALL:
dispatchTrackball(ev,(MotionEvent)ev.event,0,0);
break;
case RawInputEvent.CLASS_CONFIGURATION_CHANGED:
configChanged=true;
break;
default :
mQueue.recycleEvent(ev);
break;
}
}
 else if (configChanged) {
configChanged=false;
sendNewConfiguration();
}
 else if (lastKey != null) {
curTime=SystemClock.uptimeMillis();
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + nextKeyTime + ""String_Node_Str""+ curTime);
if (curTime < nextKeyTime) {
continue;
}
lastKeyTime=nextKeyTime;
nextKeyTime=nextKeyTime + KEY_REPEAT_DELAY;
keyRepeatCount++;
if (DEBUG_INPUT) Log.v(TAG,""String_Node_Str"" + keyRepeatCount + ""String_Node_Str""+ nextKeyTime);
KeyEvent newEvent;
if (downTime != 0 && (downTime + ViewConfiguration.getLongPressTimeout()) <= curTime) {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount,lastKey.getFlags() | KeyEvent.FLAG_LONG_PRESS);
downTime=0;
}
 else {
newEvent=KeyEvent.changeTimeRepeat(lastKey,curTime,keyRepeatCount);
}
dispatchKey(newEvent,0,0);
}
 else {
curTime=SystemClock.uptimeMillis();
lastKeyTime=curTime;
nextKeyTime=curTime + LONG_WAIT;
}
}
 catch (Exception e) {
Log.e(TAG,""String_Node_Str"" + e,e);
}
}
}"
23371,"/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardShowing=keyguardIsShowingTq();
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardShowing);
  }
  if (keyguardShowing) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardShowing || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}","/** 
 * {@inheritDoc} 
 */
public int interceptKeyTq(RawInputEvent event,boolean screenIsOn){
  int result=ACTION_PASS_TO_USER;
  final boolean isWakeKey=isWakeKeyTq(event);
  final boolean keyguardActive=(screenIsOn ? mKeyguardMediator.isShowingAndNotHidden() : mKeyguardMediator.isShowing());
  if (false) {
    Log.d(TAG,""String_Node_Str"" + event + ""String_Node_Str""+ event.keycode+ ""String_Node_Str""+ screenIsOn+ ""String_Node_Str""+ keyguardActive);
  }
  if (keyguardActive) {
    if (screenIsOn) {
      result|=ACTION_PASS_TO_USER;
    }
 else {
      result&=~ACTION_PASS_TO_USER;
      final boolean isKeyDown=(event.type == RawInputEvent.EV_KEY) && (event.value != 0);
      if (isWakeKey && isKeyDown) {
        if (!mKeyguardMediator.onWakeKeyWhenKeyguardShowingTq(event.keycode) && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
          if (isInCall()) {
            mKeyguardMediator.pokeWakelock();
          }
 else           if (isMusicActive()) {
            handleVolumeKey(AudioManager.STREAM_MUSIC,event.keycode);
          }
        }
      }
    }
  }
 else   if (!screenIsOn) {
    if (isInCall() && event.type == RawInputEvent.EV_KEY && (event.keycode == KeyEvent.KEYCODE_VOLUME_DOWN || event.keycode == KeyEvent.KEYCODE_VOLUME_UP)) {
      result&=~ACTION_PASS_TO_USER;
      handleVolumeKey(AudioManager.STREAM_VOICE_CALL,event.keycode);
    }
    if (isWakeKey) {
      result|=ACTION_POKE_USER_ACTIVITY;
      result&=~ACTION_PASS_TO_USER;
    }
  }
  int type=event.type;
  int code=event.keycode;
  boolean down=event.value != 0;
  if (type == RawInputEvent.EV_KEY) {
    if (code == KeyEvent.KEYCODE_ENDCALL || code == KeyEvent.KEYCODE_POWER) {
      if (down) {
        boolean handled=false;
        ITelephony phoneServ=getPhoneInterface();
        if (phoneServ != null) {
          try {
            if (code == KeyEvent.KEYCODE_ENDCALL) {
              handled=phoneServ.endCall();
            }
 else             if (code == KeyEvent.KEYCODE_POWER && phoneServ.isRinging()) {
              phoneServ.silenceRinger();
              handled=true;
            }
          }
 catch (          RemoteException ex) {
            Log.w(TAG,""String_Node_Str"" + ex);
          }
        }
 else {
          Log.w(TAG,""String_Node_Str"");
        }
        if ((handled && code != KeyEvent.KEYCODE_POWER) || !screenIsOn) {
          mShouldTurnOffOnKeyUp=false;
        }
 else {
          mShouldTurnOffOnKeyUp=true;
          mHandler.postDelayed(mPowerLongPress,ViewConfiguration.getGlobalActionKeyTimeout());
          result&=~ACTION_PASS_TO_USER;
        }
      }
 else {
        mHandler.removeCallbacks(mPowerLongPress);
        if (mShouldTurnOffOnKeyUp) {
          mShouldTurnOffOnKeyUp=false;
          boolean gohome=(mEndcallBehavior & ENDCALL_HOME) != 0;
          boolean sleeps=(mEndcallBehavior & ENDCALL_SLEEPS) != 0;
          if (keyguardActive || (sleeps && !gohome) || (gohome && !goHome() && sleeps)) {
            Log.d(TAG,""String_Node_Str"" + Integer.toHexString(mEndcallBehavior));
            result&=~ACTION_POKE_USER_ACTIVITY;
            result|=ACTION_GO_TO_SLEEP;
          }
          result&=~ACTION_PASS_TO_USER;
        }
      }
    }
 else     if (isMediaKey(code)) {
      if ((result & ACTION_PASS_TO_USER) == 0) {
        KeyEvent keyEvent=new KeyEvent(event.when,event.when,down ? KeyEvent.ACTION_DOWN : KeyEvent.ACTION_UP,code,0);
        mBroadcastWakeLock.acquire();
        mHandler.post(new PassHeadsetKey(keyEvent));
      }
    }
 else     if (code == KeyEvent.KEYCODE_CALL) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.answerRingingCall();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
 else     if ((code == KeyEvent.KEYCODE_VOLUME_UP) || (code == KeyEvent.KEYCODE_VOLUME_DOWN)) {
      if (down) {
        try {
          ITelephony phoneServ=getPhoneInterface();
          if (phoneServ != null) {
            if (phoneServ.isRinging()) {
              Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
              phoneServ.silenceRinger();
              result&=~ACTION_PASS_TO_USER;
            }
          }
 else {
            Log.w(TAG,""String_Node_Str"");
          }
        }
 catch (        RemoteException ex) {
          Log.w(TAG,""String_Node_Str"",ex);
        }
      }
    }
  }
  return result;
}"
23372,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (SDK_VERSION > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,SDK_VERSION);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > SDK_VERSION) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ SDK_VERSION+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < SDK_VERSION) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ SDK_VERSION+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (SDK_VERSION > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > SDK_VERSION) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ SDK_VERSION+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(SDK_CODENAME)) {
            if (SDK_CODENAME != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ SDK_CODENAME+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}"
23373,"void logTimeStat(String sql,long beginNanos){
  int samplePercent;
  long nanos=Debug.threadCpuTimeNanos() - beginNanos;
  if (nanos >= QUERY_LOG_TIME_IN_NANOS) {
    samplePercent=100;
  }
 else {
    samplePercent=(int)(100 * nanos / QUERY_LOG_TIME_IN_NANOS) + 1;
    if (mRandom.nextInt(100) < samplePercent)     return;
  }
  if (sql.length() > QUERY_LOG_SQL_LENGTH)   sql=sql.substring(0,QUERY_LOG_SQL_LENGTH);
  String blockingPackage=ActivityThread.currentPackageName();
  if (blockingPackage == null)   blockingPackage=""String_Node_Str"";
  int millis=(int)(nanos / 1000000);
  EventLog.writeEvent(EVENT_DB_OPERATION,mPath,sql,millis,blockingPackage,samplePercent);
}","void logTimeStat(String sql,long beginNanos){
  int samplePercent;
  long nanos=Debug.threadCpuTimeNanos() - beginNanos;
  if (nanos >= QUERY_LOG_TIME_IN_NANOS) {
    samplePercent=100;
  }
 else {
    samplePercent=(int)(100 * nanos / QUERY_LOG_TIME_IN_NANOS) + 1;
    if (mRandom.nextInt(100) >= samplePercent)     return;
  }
  if (sql.length() > QUERY_LOG_SQL_LENGTH)   sql=sql.substring(0,QUERY_LOG_SQL_LENGTH);
  String blockingPackage=ActivityThread.currentPackageName();
  if (blockingPackage == null)   blockingPackage=""String_Node_Str"";
  int millis=(int)(nanos / 1000000);
  EventLog.writeEvent(EVENT_DB_OPERATION,mPath,sql,millis,blockingPackage,samplePercent);
}"
23374,"NameValueCache(String versionSystemProperty,Uri uri){
  mVersionSystemProperty=versionSystemProperty;
  mUri=uri;
}","public NameValueCache(String versionSystemProperty,Uri uri){
  mVersionSystemProperty=versionSystemProperty;
  mUri=uri;
}"
23375,"public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.allDrawn=false;
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.waitingToHide=true;
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION) {
      RuntimeException e=new RuntimeException();
      if (!HIDE_STACK_CRAWLS)       e.fillInStackTrace();
      Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mNextAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested,e);
    }
    if (!mDisplayFrozen && mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
      if (wtoken.hiddenRequested != visible) {
        return;
      }
      wtoken.hiddenRequested=!visible;
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + wtoken);
      wtoken.setDummyAnimation();
      mOpeningApps.remove(wtoken);
      mClosingApps.remove(wtoken);
      wtoken.waitingToShow=wtoken.waitingToHide=false;
      wtoken.inPendingTransaction=true;
      if (visible) {
        mOpeningApps.add(wtoken);
        wtoken.startingDisplayed=false;
        wtoken.startingMoved=false;
        if (wtoken.hidden) {
          wtoken.allDrawn=false;
          wtoken.waitingToShow=true;
          if (wtoken.clientHidden) {
            wtoken.clientHidden=false;
            wtoken.sendAppVisibilityToClients();
          }
        }
      }
 else {
        mClosingApps.add(wtoken);
        if (!wtoken.hidden) {
          wtoken.waitingToHide=true;
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    setTokenVisibilityLocked(wtoken,null,visible,WindowManagerPolicy.TRANSIT_UNSET,true);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}"
23376,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}"
23377,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}"
23378,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}"
23379,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}"
23380,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
    mAveragedData[ioff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
    mAveragedData[ioff + MotionEvent.SAMPLE_SIZE]=rawData[ioff + MotionEvent.SAMPLE_SIZE];
  }
  return mAveragedData;
}"
23381,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}"
23382,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}"
23383,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}"
23384,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}"
23385,"public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false)) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}","public int relayoutWindow(Session session,IWindow client,WindowManager.LayoutParams attrs,int requestedWidth,int requestedHeight,int viewVisibility,boolean insetsPending,Rect outFrame,Rect outContentInsets,Rect outVisibleInsets,Surface outSurface){
  boolean displayed=false;
  boolean inTouchMode;
  Configuration newConfig=null;
  long origId=Binder.clearCallingIdentity();
synchronized (mWindowMap) {
    WindowState win=windowForClientLocked(session,client);
    if (win == null) {
      return 0;
    }
    win.mRequestedWidth=requestedWidth;
    win.mRequestedHeight=requestedHeight;
    if (attrs != null) {
      mPolicy.adjustWindowParamsLw(attrs);
    }
    int attrChanges=0;
    int flagChanges=0;
    if (attrs != null) {
      flagChanges=win.mAttrs.flags^=attrs.flags;
      attrChanges=win.mAttrs.copyFrom(attrs);
    }
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"");
    if ((attrChanges & WindowManager.LayoutParams.ALPHA_CHANGED) != 0) {
      win.mAlpha=attrs.alpha;
    }
    final boolean scaledWindow=((win.mAttrs.flags & WindowManager.LayoutParams.FLAG_SCALED) != 0);
    if (scaledWindow) {
      win.mHScale=(attrs.width != requestedWidth) ? (attrs.width / (float)requestedWidth) : 1.0f;
      win.mVScale=(attrs.height != requestedHeight) ? (attrs.height / (float)requestedHeight) : 1.0f;
    }
    boolean imMayMove=(flagChanges & (WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;
    boolean focusMayChange=win.mViewVisibility != viewVisibility || ((flagChanges & WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0) || (!win.mRelayoutCalled);
    boolean wallpaperMayMove=win.mViewVisibility != viewVisibility && (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0;
    win.mRelayoutCalled=true;
    final int oldVisibility=win.mViewVisibility;
    win.mViewVisibility=viewVisibility;
    if (viewVisibility == View.VISIBLE && (win.mAppToken == null || !win.mAppToken.clientHidden)) {
      displayed=!win.isVisibleLw();
      if (win.mExiting) {
        win.mExiting=false;
        win.mAnimation=null;
      }
      if (win.mDestroying) {
        win.mDestroying=false;
        mDestroySurface.remove(win);
      }
      if (oldVisibility == View.GONE) {
        win.mEnterAnimationPending=true;
      }
      if (displayed && win.mSurface != null && !win.mDrawPending && !win.mCommitDrawPending && !mDisplayFrozen) {
        applyEnterAnimationLocked(win);
      }
      if (displayed && (win.mAttrs.flags & WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON) != 0) {
        win.mTurnOnScreen=true;
      }
      if ((attrChanges & WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
        win.destroySurfaceLocked();
        displayed=true;
      }
      try {
        Surface surface=win.createSurfaceLocked();
        if (surface != null) {
          outSurface.copyFrom(surface);
          win.mReportDestroySurface=false;
          win.mSurfacePendingDestroy=false;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + outSurface + ""String_Node_Str"");
        }
 else {
          outSurface.release();
        }
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + client + ""String_Node_Str""+ win.mAttrs.getTitle()+ ""String_Node_Str"",e);
        Binder.restoreCallingIdentity(origId);
        return 0;
      }
      if (displayed) {
        focusMayChange=true;
      }
      if (win.mAttrs.type == TYPE_INPUT_METHOD && mInputMethodWindow == null) {
        mInputMethodWindow=win;
        imMayMove=true;
      }
    }
 else {
      win.mEnterAnimationPending=false;
      if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mExiting+ ""String_Node_Str""+ win.mSurfacePendingDestroy);
        if (!win.mExiting || win.mSurfacePendingDestroy) {
          int transit=WindowManagerPolicy.TRANSIT_EXIT;
          if (win.getAttrs().type == TYPE_APPLICATION_STARTING) {
            transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
          }
          if (!win.mSurfacePendingDestroy && win.isWinVisibleLw() && applyAnimationLocked(win,transit,false)) {
            focusMayChange=true;
            win.mExiting=true;
            mKeyWaiter.finishedKey(session,client,true,KeyWaiter.RETURN_NOTHING);
          }
 else           if (win.isAnimating()) {
            win.mExiting=true;
          }
 else           if (win == mWallpaperTarget) {
            win.mExiting=true;
            win.mAnimating=true;
          }
 else {
            if (mInputMethodWindow == win) {
              mInputMethodWindow=null;
            }
            win.destroySurfaceLocked();
          }
        }
      }
      if (win.mSurface == null || (win.getAttrs().flags & WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING) == 0 || win.mSurfacePendingDestroy) {
        win.mSurfacePendingDestroy=false;
        outSurface.release();
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
      }
 else       if (win.mSurface != null) {
        if (DEBUG_VISIBILITY)         Log.i(TAG,""String_Node_Str"" + win);
        win.mReportDestroySurface=true;
        outSurface.copyFrom(win.mSurface);
      }
    }
    if (focusMayChange) {
      if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
        imMayMove=false;
      }
    }
    boolean assignLayers=false;
    if (imMayMove) {
      if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
        assignLayers=true;
      }
    }
    if (wallpaperMayMove) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayers=true;
      }
    }
    mLayoutNeeded=true;
    win.mGivenInsetsPending=insetsPending;
    if (assignLayers) {
      assignLayersLocked();
    }
    newConfig=updateOrientationFromAppTokensLocked(null,null);
    performLayoutAndPlaceSurfacesLocked();
    if (displayed && win.mIsWallpaper) {
      updateWallpaperOffsetLocked(win,mDisplay.getWidth(),mDisplay.getHeight(),false);
    }
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
    outFrame.set(win.mFrame);
    outContentInsets.set(win.mContentInsets);
    outVisibleInsets.set(win.mVisibleInsets);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + client.asBinder() + ""String_Node_Str""+ requestedWidth+ ""String_Node_Str""+ requestedHeight+ ""String_Node_Str""+ viewVisibility+ ""String_Node_Str""+ outFrame+ ""String_Node_Str""+ outSurface);
    if (localLOGV || DEBUG_FOCUS)     Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ focusMayChange);
    inTouchMode=mInTouchMode;
  }
  if (newConfig != null) {
    sendNewConfiguration();
  }
  Binder.restoreCallingIdentity(origId);
  return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0) | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
}"
23386,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}"
23387,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}"
23388,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}"
23389,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}"
23390,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
23391,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}"
23392,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}"
23393,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}"
23394,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}"
23395,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
23396,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}"
23397,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}"
23398,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}"
23399,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}"
23400,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
23401,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}"
23402,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}"
23403,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}"
23404,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}"
23405,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
23406,"public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ATTACH:
{
      try {
        mConnection.attachEngine(this);
      }
 catch (      RemoteException e) {
        Log.w(TAG,""String_Node_Str"",e);
        return;
      }
      Engine engine=onCreateEngine();
      mEngine=engine;
      mActiveEngines.add(engine);
      engine.attach(this);
      return;
    }
case DO_DETACH:
{
    mActiveEngines.remove(mEngine);
    mEngine.detach();
    return;
  }
case DO_SET_DESIRED_SIZE:
{
  mEngine.doDesiredSizeChanged(message.arg1,message.arg2);
  return;
}
case MSG_UPDATE_SURFACE:
mEngine.updateSurface(true,false);
break;
case MSG_VISIBILITY_CHANGED:
if (DEBUG) Log.v(TAG,""String_Node_Str"" + mEngine + ""String_Node_Str""+ message.arg1);
mEngine.doVisibilityChanged(message.arg1 != 0);
break;
case MSG_WALLPAPER_OFFSETS:
{
mEngine.doOffsetsChanged();
}
break;
case MSG_WALLPAPER_COMMAND:
{
WallpaperCommand cmd=(WallpaperCommand)message.obj;
mEngine.doCommand(cmd);
}
break;
case MSG_WINDOW_RESIZED:
{
final boolean reportDraw=message.arg1 != 0;
mEngine.updateSurface(true,false);
if (reportDraw) {
try {
mEngine.mSession.finishDrawing(mEngine.mWindow);
}
 catch (RemoteException e) {
}
}
}
break;
case MSG_TOUCH_EVENT:
{
MotionEvent ev=(MotionEvent)message.obj;
synchronized (mEngine.mLock) {
if (mEngine.mPendingMove == ev) {
mEngine.mPendingMove=null;
}
}
if (DEBUG) Log.v(TAG,""String_Node_Str"" + ev);
mEngine.onTouchEvent(ev);
ev.recycle();
}
break;
default :
Log.w(TAG,""String_Node_Str"" + message.what);
}
}"
23407,"/** 
 * Called once to initialize the engine.  After returning, the engine's surface will be created by the framework.
 */
public void onCreate(SurfaceHolder surfaceHolder){
}","@Override public void onCreate(){
  super.onCreate();
}"
23408,"/** 
 * Called right before the engine is going away.  After this the surface will be destroyed and this Engine object is no longer valid.
 */
public void onDestroy(){
}","@Override public void onDestroy(){
  super.onDestroy();
  for (int i=0; i < mActiveEngines.size(); i++) {
    mActiveEngines.get(i).detach();
  }
  mActiveEngines.clear();
}"
23409,"void doVisibilityChanged(boolean visible){
  mVisible=visible;
  reportVisibility();
}","void doVisibilityChanged(boolean visible){
  if (!mDestroyed) {
    mVisible=visible;
    reportVisibility();
  }
}"
23410,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}","void detach(){
  if (mDestroyed) {
    return;
  }
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  unregisterReceiver(mReceiver);
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
23411,"private synchronized final void sendIntent(){
  Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  int state=0;
  int microphone=0;
  if ((mHeadsetState & BIT_HEADSET) != (mPrevHeadsetState & BIT_HEADSET)) {
    microphone=1;
    if ((mHeadsetState & BIT_HEADSET) != 0) {
      state=1;
    }
  }
 else   if ((mHeadsetState & BIT_HEADSET_NO_MIC) != (mPrevHeadsetState & BIT_HEADSET_NO_MIC)) {
    if ((mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      state=1;
    }
  }
  intent.putExtra(""String_Node_Str"",state);
  intent.putExtra(""String_Node_Str"",mHeadsetName);
  intent.putExtra(""String_Node_Str"",microphone);
  ActivityManagerNative.broadcastStickyIntent(intent,null);
}","private final void sendIntent(int headset){
  if ((mHeadsetState & headset) != (mPrevHeadsetState & headset)) {
    Intent intent=new Intent(Intent.ACTION_HEADSET_PLUG);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    int state=0;
    int microphone=0;
    if ((headset & HEADSETS_WITH_MIC) != 0) {
      microphone=1;
    }
    if ((mHeadsetState & headset) != 0) {
      state=1;
    }
    intent.putExtra(""String_Node_Str"",state);
    intent.putExtra(""String_Node_Str"",mHeadsetName);
    intent.putExtra(""String_Node_Str"",microphone);
    if (LOG)     Log.v(TAG,""String_Node_Str"" + state + ""String_Node_Str""+ mHeadsetName+ ""String_Node_Str""+ microphone);
    ActivityManagerNative.broadcastStickyIntent(intent,null);
  }
}"
23412,"@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntent();
    mPendingIntent=false;
  }
  mWakeLock.release();
}","@Override public void handleMessage(Message msg){
  if (mPendingIntent) {
    sendIntents();
    mPendingIntent=false;
  }
  mWakeLock.release();
}"
23413,"private synchronized final void update(String newName,int newState){
  int headsetState=newState & (BIT_HEADSET | BIT_HEADSET_NO_MIC);
  if (headsetState != mHeadsetState) {
    boolean isUnplug=false;
    if (((mHeadsetState & BIT_HEADSET) != 0 && (headsetState & BIT_HEADSET) == 0) || ((mHeadsetState & BIT_HEADSET_NO_MIC) != 0 && (headsetState & BIT_HEADSET_NO_MIC) == 0)) {
      isUnplug=true;
    }
    mHeadsetName=newName;
    mPrevHeadsetState=mHeadsetState;
    mHeadsetState=headsetState;
    mPendingIntent=true;
    if (isUnplug) {
      Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
      mContext.sendBroadcast(intent);
      mWakeLock.acquire();
      mHandler.sendEmptyMessageDelayed(0,1000);
    }
 else {
      sendIntent();
      mPendingIntent=false;
    }
  }
}","private synchronized final void update(String newName,int newState){
  int headsetState=newState & SUPPORTED_HEADSETS;
  int newOrOld=headsetState | mHeadsetState;
  if (mHeadsetState == headsetState || ((newOrOld & (newOrOld - 1)) != 0)) {
    return;
  }
  mHeadsetName=newName;
  mPrevHeadsetState=mHeadsetState;
  mHeadsetState=headsetState;
  mPendingIntent=true;
  if (headsetState == 0) {
    Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
    mContext.sendBroadcast(intent);
    mWakeLock.acquire();
    mHandler.sendEmptyMessageDelayed(0,1000);
  }
 else {
    sendIntents();
    mPendingIntent=false;
  }
}"
23414,"public void appendAndroidSpecificProperty(final String mimeType,ContentValues contentValues){
  List<String> rawValueList=new ArrayList<String>();
  rawValueList.add(mimeType);
  final List<String> columnNameList;
  if (!sAllowedAndroidPropertySet.contains(mimeType)) {
    return;
  }
  for (int i=1; i <= VCardConstants.MAX_DATA_COLUMN; i++) {
    String value=contentValues.getAsString(""String_Node_Str"" + i);
    if (value == null) {
      value=""String_Node_Str"";
    }
    rawValueList.add(value);
  }
  appendLineWithCharsetAndQPDetection(VCardConstants.PROPERTY_X_ANDROID_CUSTOM,rawValueList);
}","public void appendAndroidSpecificProperty(final String mimeType,ContentValues contentValues){
  if (!sAllowedAndroidPropertySet.contains(mimeType)) {
    return;
  }
  final List<String> rawValueList=new ArrayList<String>();
  for (int i=1; i <= VCardConstants.MAX_DATA_COLUMN; i++) {
    String value=contentValues.getAsString(""String_Node_Str"" + i);
    if (value == null) {
      value=""String_Node_Str"";
    }
    rawValueList.add(value);
  }
  boolean needCharset=(mShouldAppendCharsetParam && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  boolean reallyUseQuotedPrintable=(mShouldUseQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  mBuilder.append(VCardConstants.PROPERTY_X_ANDROID_CUSTOM);
  if (needCharset) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(mVCardCharsetParameter);
  }
  if (reallyUseQuotedPrintable) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(VCARD_PARAM_ENCODING_QP);
  }
  mBuilder.append(VCARD_DATA_SEPARATOR);
  mBuilder.append(mimeType);
  for (  String rawValue : rawValueList) {
    final String encodedValue;
    if (reallyUseQuotedPrintable) {
      encodedValue=encodeQuotedPrintable(rawValue);
    }
 else {
      encodedValue=escapeCharacters(rawValue);
    }
    mBuilder.append(VCARD_ITEM_SEPARATOR);
    mBuilder.append(encodedValue);
  }
  mBuilder.append(VCARD_END_OF_LINE);
}"
23415,"public void appendLine(final String propertyName,final List<String> parameterList,final List<String> rawValueList,final boolean needCharset,final boolean needQuotedPrintable){
  mBuilder.append(propertyName);
  if (parameterList != null && parameterList.size() > 0) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    appendTypeParameters(parameterList);
  }
  if (needCharset) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(mVCardCharsetParameter);
  }
  mBuilder.append(VCARD_DATA_SEPARATOR);
  boolean first=true;
  for (  String rawValue : rawValueList) {
    final String encodedValue;
    if (needQuotedPrintable) {
      mBuilder.append(VCARD_PARAM_SEPARATOR);
      mBuilder.append(VCARD_PARAM_ENCODING_QP);
      encodedValue=encodeQuotedPrintable(rawValue);
    }
 else {
      encodedValue=escapeCharacters(rawValue);
    }
    if (first) {
      first=false;
    }
 else {
      mBuilder.append(VCARD_ITEM_SEPARATOR);
    }
    mBuilder.append(encodedValue);
  }
  mBuilder.append(VCARD_END_OF_LINE);
}","public void appendLine(final String propertyName,final List<String> parameterList,final List<String> rawValueList,final boolean needCharset,final boolean needQuotedPrintable){
  mBuilder.append(propertyName);
  if (parameterList != null && parameterList.size() > 0) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    appendTypeParameters(parameterList);
  }
  if (needCharset) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(mVCardCharsetParameter);
  }
  if (needQuotedPrintable) {
    mBuilder.append(VCARD_PARAM_SEPARATOR);
    mBuilder.append(VCARD_PARAM_ENCODING_QP);
  }
  mBuilder.append(VCARD_DATA_SEPARATOR);
  boolean first=true;
  for (  String rawValue : rawValueList) {
    final String encodedValue;
    if (needQuotedPrintable) {
      encodedValue=encodeQuotedPrintable(rawValue);
    }
 else {
      encodedValue=escapeCharacters(rawValue);
    }
    if (first) {
      first=false;
    }
 else {
      mBuilder.append(VCARD_ITEM_SEPARATOR);
    }
    mBuilder.append(encodedValue);
  }
  mBuilder.append(VCARD_END_OF_LINE);
}"
23416,"public void appendLineWithCharsetAndQPDetection(final String propertyName,final List<String> parameterList,final List<String> rawValueList){
  boolean needCharset=false;
  boolean reallyUseQuotedPrintable=false;
  for (  String rawValue : rawValueList) {
    if (!needCharset && mShouldUseQuotedPrintable && !VCardUtils.containsOnlyPrintableAscii(rawValue)) {
      needCharset=true;
    }
    if (!reallyUseQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValue)) {
      reallyUseQuotedPrintable=true;
    }
    if (needCharset && reallyUseQuotedPrintable) {
      break;
    }
  }
  appendLine(propertyName,parameterList,rawValueList,needCharset,reallyUseQuotedPrintable);
}","public void appendLineWithCharsetAndQPDetection(final String propertyName,final List<String> parameterList,final List<String> rawValueList){
  boolean needCharset=(mShouldAppendCharsetParam && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  boolean reallyUseQuotedPrintable=(mShouldUseQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(rawValueList));
  appendLine(propertyName,parameterList,rawValueList,needCharset,reallyUseQuotedPrintable);
}"
23417,"/** 
 * TODO: Merge detector and parser mode.
 */
public VCardParser_V21(int parseType){
  super(parseType);
  if (parseType == VCardConfig.PARSE_TYPE_FOMA) {
    mNestCount=1;
  }
}","public VCardParser_V21(int parseType){
  super(parseType);
  if (parseType == VCardConfig.PARSE_TYPE_FOMA) {
    mNestCount=1;
  }
}"
23418,"public static boolean containsOnlyPrintableAscii(final String... values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!((asciiFirst <= c && c <= asciiLast) || c == '\r' || c == '\n')) {
        return false;
      }
    }
  }
  return true;
}","public static boolean containsOnlyPrintableAscii(final Collection<String> values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!((asciiFirst <= c && c <= asciiLast) || c == '\r' || c == '\n')) {
        return false;
      }
    }
  }
  return true;
}"
23419,"/** 
 * This is useful since vCard 3.0 often requires the (""X-"") properties and groups should contain only alphabets, digits, and hyphen. Note: It is already known some devices (wrongly) outputs properties with characters which should not be in the field. One example is ""X-GOOGLE TALK"". We accept such kind of input but must never output it unless the target is very specific to the device which is able to parse the malformed input. 
 */
public static boolean containsOnlyAlphaDigitHyphen(final String... values){
  if (values == null) {
    return true;
  }
  final int upperAlphabetFirst=0x41;
  final int upperAlphabetAfterLast=0x5b;
  final int lowerAlphabetFirst=0x61;
  final int lowerAlphabetAfterLast=0x7b;
  final int digitFirst=0x30;
  final int digitAfterLast=0x3A;
  final int hyphen='-';
  for (  final String str : values) {
    if (TextUtils.isEmpty(str)) {
      continue;
    }
    final int length=str.length();
    for (int i=0; i < length; i=str.offsetByCodePoints(i,1)) {
      int codepoint=str.codePointAt(i);
      if (!((lowerAlphabetFirst <= codepoint && codepoint < lowerAlphabetAfterLast) || (upperAlphabetFirst <= codepoint && codepoint < upperAlphabetAfterLast) || (digitFirst <= codepoint && codepoint < digitAfterLast)|| (codepoint == hyphen))) {
        return false;
      }
    }
  }
  return true;
}","public static boolean containsOnlyAlphaDigitHyphen(final Collection<String> values){
  if (values == null) {
    return true;
  }
  final int upperAlphabetFirst=0x41;
  final int upperAlphabetAfterLast=0x5b;
  final int lowerAlphabetFirst=0x61;
  final int lowerAlphabetAfterLast=0x7b;
  final int digitFirst=0x30;
  final int digitAfterLast=0x3A;
  final int hyphen='-';
  for (  final String str : values) {
    if (TextUtils.isEmpty(str)) {
      continue;
    }
    final int length=str.length();
    for (int i=0; i < length; i=str.offsetByCodePoints(i,1)) {
      int codepoint=str.codePointAt(i);
      if (!((lowerAlphabetFirst <= codepoint && codepoint < lowerAlphabetAfterLast) || (upperAlphabetFirst <= codepoint && codepoint < upperAlphabetAfterLast) || (digitFirst <= codepoint && codepoint < digitAfterLast)|| (codepoint == hyphen))) {
        return false;
      }
    }
  }
  return true;
}"
23420,"/** 
 * This is useful when checking the string should be encoded into quoted-printable or not, which is required by vCard 2.1. See the definition of ""7bit"" in vCard 2.1 spec for more information.
 */
public static boolean containsOnlyNonCrLfPrintableAscii(final String... values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!(asciiFirst <= c && c <= asciiLast)) {
        return false;
      }
    }
  }
  return true;
}","public static boolean containsOnlyNonCrLfPrintableAscii(final Collection<String> values){
  if (values == null) {
    return true;
  }
  final int asciiFirst=0x20;
  final int asciiLast=0x7E;
  for (  final String value : values) {
    if (TextUtils.isEmpty(value)) {
      continue;
    }
    final int length=value.length();
    for (int i=0; i < length; i=value.offsetByCodePoints(i,1)) {
      final int c=value.codePointAt(i);
      if (!(asciiFirst <= c && c <= asciiLast)) {
        return false;
      }
    }
  }
  return true;
}"
23421,"public void testContainsOnlyNonCrLfPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(builder.toString()));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
}","public void testContainsOnlyNonCrLfPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii((List<String>)null));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(builder.toString()));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
}"
23422,"public void testContainsOnlyAlphaDigitHyphen(){
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String)null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String[])null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  for (int i=0; i < 0x30; i++) {
    if (i == 0x2D) {
      continue;
    }
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x3A; i < 0x41; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x5B; i < 0x61; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x7B; i < 0x100; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
}","public void testContainsOnlyAlphaDigitHyphen(){
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String)null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((String[])null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen((List<String>)null));
  assertTrue(VCardUtils.containsOnlyAlphaDigitHyphen(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyNonCrLfPrintableAscii(""String_Node_Str""));
  for (int i=0; i < 0x30; i++) {
    if (i == 0x2D) {
      continue;
    }
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x3A; i < 0x41; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x5B; i < 0x61; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
  for (int i=0x7B; i < 0x100; i++) {
    assertFalse(VCardUtils.containsOnlyAlphaDigitHyphen(String.valueOf((char)i)));
  }
}"
23423,"public void testContainsOnlyPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyPrintableAscii(builder.toString()));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
}","public void testContainsOnlyPrintableAscii(){
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String)null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii((String[])null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii((List<String>)null));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  StringBuilder builder=new StringBuilder();
  for (int i=0x20; i < 0x7F; i++) {
    builder.append((char)i);
  }
  assertTrue(VCardUtils.containsOnlyPrintableAscii(builder.toString()));
  assertTrue(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
  assertFalse(VCardUtils.containsOnlyPrintableAscii(""String_Node_Str""));
}"
23424,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}"
23425,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}"
23426,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}"
23427,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}"
23428,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}"
23429,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}"
23430,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}"
23431,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}"
23432,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}"
23433,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}"
23434,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}"
23435,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}"
23436,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}"
23437,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}"
23438,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}"
23439,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}"
23440,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}"
23441,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}"
23442,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}"
23443,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}"
23444,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
23445,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
23446,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
23447,"public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowing() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}","public void screenOnStoppedLw(){
  if (!mKeyguardMediator.isShowingAndNotHidden() && mPowerManager.isScreenOn()) {
    long curTime=SystemClock.uptimeMillis();
    mPowerManager.userActivity(curTime,false,LocalPowerManager.OTHER_EVENT);
  }
}"
23448,"/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowing();
}","/** 
 * {@inheritDoc} 
 */
public boolean keyguardIsShowingTq(){
  return mKeyguardMediator.isShowingAndNotHidden();
}"
23449,"void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowing();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}","void showGlobalActionsDialog(){
  if (mGlobalActions == null) {
    mGlobalActions=new GlobalActions(mContext);
  }
  final boolean keyguardShowing=mKeyguardMediator.isShowingAndNotHidden();
  mGlobalActions.showDialog(keyguardShowing,isDeviceProvisioned());
  if (keyguardShowing) {
    mKeyguardMediator.pokeWakelock();
  }
}"
23450,"public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowing())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}","public boolean performHapticFeedbackLw(WindowState win,int effectId,boolean always){
  final boolean hapticsDisabled=Settings.System.getInt(mContext.getContentResolver(),Settings.System.HAPTIC_FEEDBACK_ENABLED,0) == 0;
  if (!always && (hapticsDisabled || mKeyguardMediator.isShowingAndNotHidden())) {
    return false;
  }
switch (effectId) {
case HapticFeedbackConstants.LONG_PRESS:
    mVibrator.vibrate(mLongPressVibePattern,-1);
  return true;
case HapticFeedbackConstants.VIRTUAL_KEY:
mVibrator.vibrate(mVirtualKeyVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_DISABLED:
mVibrator.vibrate(mSafeModeDisabledVibePattern,-1);
return true;
case HapticFeedbackConstants.SAFE_MODE_ENABLED:
mVibrator.vibrate(mSafeModeEnabledVibePattern,-1);
return true;
}
return false;
}"
23451,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (!mHideLockScreen && mKeyguardMediator.isShowing()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowingAndNotHidden()) {
  }
 else   if (!mHideLockScreen && mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          startDockOrHome();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    startDockOrHome();
  }
}"
23452,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
23453,"public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}","public boolean detectSafeMode(){
  try {
    int menuState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_MENU);
    int sState=mWindowManager.getKeycodeState(KeyEvent.KEYCODE_S);
    int dpadState=mWindowManager.getDPadKeycodeState(KeyEvent.KEYCODE_DPAD_CENTER);
    int trackballState=mWindowManager.getTrackballScancodeState(RawInputEvent.BTN_MOUSE);
    mSafeMode=menuState > 0 || sState > 0 || dpadState > 0 || trackballState > 0;
    performHapticFeedbackLw(null,mSafeMode ? HapticFeedbackConstants.SAFE_MODE_ENABLED : HapticFeedbackConstants.SAFE_MODE_DISABLED,true);
    if (mSafeMode) {
      Log.i(TAG,""String_Node_Str"" + menuState + ""String_Node_Str""+ sState+ ""String_Node_Str""+ dpadState+ ""String_Node_Str""+ trackballState+ ""String_Node_Str"");
    }
 else {
      Log.i(TAG,""String_Node_Str"");
    }
    return mSafeMode;
  }
 catch (  RemoteException e) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
23454,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}"
23455,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}"
23456,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}"
23457,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}"
23458,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}"
23459,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}"
23460,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}"
23461,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}"
23462,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}"
23463,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}"
23464,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}"
23465,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}"
23466,"/** 
 * Formats the data into a values array suitable for use with the Media Content Provider.
 * @return a map of values
 */
private ContentValues toValues(){
  ContentValues map=new ContentValues();
  map.put(MediaStore.MediaColumns.DATA,mPath);
  map.put(MediaStore.MediaColumns.TITLE,mTitle);
  map.put(MediaStore.MediaColumns.DATE_MODIFIED,mLastModified);
  map.put(MediaStore.MediaColumns.SIZE,mFileSize);
  map.put(MediaStore.MediaColumns.MIME_TYPE,mMimeType);
  if (MediaFile.isVideoFileType(mFileType)) {
    map.put(Video.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.DURATION,mDuration);
  }
 else   if (MediaFile.isImageFileType(mFileType)) {
  }
 else   if (MediaFile.isAudioFileType(mFileType)) {
    map.put(Audio.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.COMPOSER,mComposer);
    if (mYear != 0) {
      map.put(Audio.Media.YEAR,mYear);
    }
    map.put(Audio.Media.TRACK,mTrack);
    map.put(Audio.Media.DURATION,mDuration);
  }
  return map;
}","/** 
 * Formats the data into a values array suitable for use with the Media Content Provider.
 * @return a map of values
 */
private ContentValues toValues(){
  ContentValues map=new ContentValues();
  map.put(MediaStore.MediaColumns.DATA,mPath);
  map.put(MediaStore.MediaColumns.TITLE,mTitle);
  map.put(MediaStore.MediaColumns.DATE_MODIFIED,mLastModified);
  map.put(MediaStore.MediaColumns.SIZE,mFileSize);
  map.put(MediaStore.MediaColumns.MIME_TYPE,mMimeType);
  if (MediaFile.isVideoFileType(mFileType)) {
    map.put(Video.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Video.Media.DURATION,mDuration);
    map.put(Video.Media.DATE_TAKEN,mLastModified);
  }
 else   if (MediaFile.isImageFileType(mFileType)) {
    map.put(Images.Media.DATE_TAKEN,mLastModified);
  }
 else   if (MediaFile.isAudioFileType(mFileType)) {
    map.put(Audio.Media.ARTIST,(mArtist != null && mArtist.length() > 0 ? mArtist : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.ALBUM,(mAlbum != null && mAlbum.length() > 0 ? mAlbum : MediaFile.UNKNOWN_STRING));
    map.put(Audio.Media.COMPOSER,mComposer);
    if (mYear != 0) {
      map.put(Audio.Media.YEAR,mYear);
    }
    map.put(Audio.Media.TRACK,mTrack);
    map.put(Audio.Media.DURATION,mDuration);
  }
  return map;
}"
23467,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}"
23468,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}"
23469,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}"
23470,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}"
23471,"void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      performCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}","void performDisableActions(int net){
  int old=mDisabled;
  int diff=net ^ old;
  mDisabled=net;
  if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
    if ((net & StatusBarManager.DISABLE_EXPAND) != 0) {
      animateCollapse();
    }
  }
  if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
    if ((net & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
      Log.d(TAG,""String_Node_Str"");
      if (mTicking) {
        mNotificationIcons.setVisibility(View.INVISIBLE);
        mTicker.halt();
      }
 else {
        setNotificationIconVisibility(false,com.android.internal.R.anim.fade_out);
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
      if (!mExpandedVisible) {
        setNotificationIconVisibility(true,com.android.internal.R.anim.fade_in);
      }
    }
  }
}"
23472,"void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}","void performAddUpdateIcon(IBinder key,IconData data,NotificationData n) throws StatusBarException {
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + data + ""String_Node_Str""+ n+ ""String_Node_Str""+ key);
  }
  if (n != null) {
    StatusBarNotification notification=getNotification(key);
    NotificationData oldData=null;
    if (notification == null) {
      notification=new StatusBarNotification();
      notification.key=key;
      notification.data=n;
synchronized (mNotificationData) {
        mNotificationData.add(notification);
      }
      addNotificationView(notification);
      setAreThereNotifications();
    }
 else {
      oldData=notification.data;
      notification.data=n;
      updateNotificationView(notification,oldData);
    }
    if (n.tickerText != null && mStatusBarView.getWindowToken() != null && (oldData == null || oldData.tickerText == null || !CharSequences.equals(oldData.tickerText,n.tickerText))) {
      if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        mTicker.addEntry(n,StatusBarIcon.getIcon(mContext,data),n.tickerText);
      }
    }
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
  }
synchronized (mIconMap) {
    StatusBarIcon icon=mIconMap.get(key);
    if (icon == null) {
      LinearLayout v=n == null ? mStatusIcons : mNotificationIcons;
      icon=new StatusBarIcon(mContext,data,v);
      mIconMap.put(key,icon);
      mIconList.add(icon);
      if (n == null) {
        int slotIndex=getRightIconIndex(data.slot);
        StatusBarIcon[] rightIcons=mRightIcons;
        if (rightIcons[slotIndex] == null) {
          int pos=0;
          for (int i=mRightIcons.length - 1; i > slotIndex; i--) {
            StatusBarIcon ic=rightIcons[i];
            if (ic != null) {
              pos++;
            }
          }
          rightIcons[slotIndex]=icon;
          mStatusIcons.addView(icon.view,pos);
        }
 else {
          Log.e(TAG,""String_Node_Str"" + slotIndex + ""String_Node_Str""+ data.slot);
          mIconMap.remove(key);
          mIconList.remove(icon);
          return;
        }
      }
 else {
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
 else {
      if (n == null) {
        icon.update(mContext,data);
      }
 else {
        ViewGroup parent=(ViewGroup)icon.view.getParent();
        parent.removeView(icon.view);
        icon.update(mContext,data);
        int iconIndex=mNotificationData.getIconIndex(n);
        mNotificationIcons.addView(icon.view,iconIndex);
      }
    }
  }
}"
23473,"void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}","void performSetIconVisibility(IBinder key,boolean visible){
synchronized (mIconMap) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key + ""String_Node_Str""+ visible);
    }
    StatusBarIcon icon=mIconMap.get(key);
    icon.view.setVisibility(visible ? View.VISIBLE : View.GONE);
  }
}"
23474,"void performRemoveIcon(IBinder key){
synchronized (this) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}","void performRemoveIcon(IBinder key){
synchronized (this) {
    if (SPEW) {
      Log.d(TAG,""String_Node_Str"" + key);
    }
    StatusBarIcon icon=mIconMap.remove(key);
    mIconList.remove(icon);
    if (icon != null) {
      ViewGroup parent=(ViewGroup)icon.view.getParent();
      parent.removeView(icon.view);
      int slotIndex=getRightIconIndex(icon.mData.slot);
      if (slotIndex >= 0) {
        mRightIcons[slotIndex]=null;
      }
    }
    StatusBarNotification notification=getNotification(key);
    if (notification != null) {
      removeNotificationView(notification);
synchronized (mNotificationData) {
        mNotificationData.remove(notification);
      }
      setAreThereNotifications();
    }
  }
}"
23475,"/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}","/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticMiddleName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    return;
  }
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
  if (elems.get(0).length() > 0) {
    boolean onlyFirstElemIsNonEmpty=true;
    for (int i=1; i < size; i++) {
      if (elems.get(i).length() > 0) {
        onlyFirstElemIsNonEmpty=false;
        break;
      }
    }
    if (onlyFirstElemIsNonEmpty) {
      final String[] namesArray=elems.get(0).split(""String_Node_Str"");
      final int nameArrayLength=namesArray.length;
      if (nameArrayLength == 3) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticMiddleName=namesArray[1];
        mPhoneticGivenName=namesArray[2];
      }
 else       if (nameArrayLength == 2) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticGivenName=namesArray[1];
      }
 else {
        mPhoneticFullName=elems.get(0);
      }
      return;
    }
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}"
23476,"/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    StringBuilder builder=new StringBuilder();
    List<String> nameList;
switch (VCardConfig.getNameOrderType(mVCardType)) {
case VCardConfig.NAME_ORDER_JAPANESE:
      if (VCardUtils.containsOnlyPrintableAscii(mFamilyName) && VCardUtils.containsOnlyPrintableAscii(mGivenName)) {
        nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
      }
 else {
        nameList=Arrays.asList(mPrefix,mFamilyName,mMiddleName,mGivenName,mSuffix);
      }
    break;
case VCardConfig.NAME_ORDER_EUROPE:
  nameList=Arrays.asList(mPrefix,mMiddleName,mGivenName,mFamilyName,mSuffix);
break;
default :
nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
break;
}
boolean first=true;
for (String namePart : nameList) {
if (!TextUtils.isEmpty(namePart)) {
if (first) {
first=false;
}
 else {
builder.append(' ');
}
builder.append(namePart);
}
}
mDisplayName=builder.toString();
}
 else if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
}
 else if (mEmailList != null && mEmailList.size() > 0) {
mDisplayName=mEmailList.get(0).data;
}
 else if (mPhoneList != null && mPhoneList.size() > 0) {
mDisplayName=mPhoneList.get(0).data;
}
 else if (mPostalList != null && mPostalList.size() > 0) {
mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
}
if (mDisplayName == null) {
mDisplayName=""String_Node_Str"";
}
}","/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mFamilyName,mMiddleName,mGivenName,mPrefix,mSuffix);
  }
 else   if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
  }
 else   if (mEmailList != null && mEmailList.size() > 0) {
    mDisplayName=mEmailList.get(0).data;
  }
 else   if (mPhoneList != null && mPhoneList.size() > 0) {
    mDisplayName=mPhoneList.get(0).data;
  }
 else   if (mPostalList != null && mPostalList.size() > 0) {
    mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
  }
  if (mDisplayName == null) {
    mDisplayName=""String_Node_Str"";
  }
}"
23477,"/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!VCardUtils.containsOnlyPrintableAscii(propertyValue) && (!mIsV30 || !mUsesUtf8));
}","/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!(mIsV30 && mUsesUtf8) && !VCardUtils.containsOnlyPrintableAscii(propertyValue));
}"
23478,"private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(displayName));
}","private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
  final String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
  final String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(phoneticFamilyName)&& TextUtils.isEmpty(phoneticMiddleName)&& TextUtils.isEmpty(phoneticGivenName)&& TextUtils.isEmpty(displayName));
}"
23479,"private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    if (mIsV30) {
      builder.append(Constants.PROPERTY_FN);
      if (shouldAppendCharsetParameter(displayName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedDisplayName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      final String encodedSortString=escapeCharacters(sortString);
      if (shouldAppendCharsetParameter(encodedSortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedSortString);
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName);
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName);
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName);
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}","private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      if (shouldAppendCharsetParameter(sortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(sortString));
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
{
        boolean first=true;
        if (!TextUtils.isEmpty(encodedPhoneticFamilyName)) {
          builder.append(encodedPhoneticFamilyName);
          first=false;
        }
        if (!TextUtils.isEmpty(encodedPhoneticMiddleName)) {
          if (first) {
            first=false;
          }
 else {
            builder.append(' ');
          }
          builder.append(encodedPhoneticMiddleName);
        }
        if (!TextUtils.isEmpty(encodedPhoneticGivenName)) {
          if (!first) {
            builder.append(' ');
          }
          builder.append(encodedPhoneticGivenName);
        }
      }
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName));
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(phoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName));
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(phoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName));
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(phoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}"
23480,"public static boolean usesQuotedPrintable(int vcardType){
  return !isV30(vcardType);
}","public static boolean usesQuotedPrintable(final int vcardType){
  return !isV30(vcardType);
}"
23481,"public static int getVCardTypeFromString(String vcardTypeString){
  String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}","public static int getVCardTypeFromString(final String vcardTypeString){
  final String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}"
23482,"public static boolean usesAndroidSpecificProperty(int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}","public static boolean usesAndroidSpecificProperty(final int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}"
23483,"public static boolean appendTypeParamName(int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}","public static boolean appendTypeParamName(final int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}"
23484,"public static boolean refrainsQPToPrimaryProperties(int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}","public static boolean refrainsQPToPrimaryProperties(final int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}"
23485,"public static boolean isDoCoMo(int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}","public static boolean isDoCoMo(final int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}"
23486,"public static boolean usesShiftJis(int vcardType){
  return ((vcardType & FLAG_CHARSET_SHIFT_JIS) != 0);
}","public static boolean usesShiftJis(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_SHIFT_JIS);
}"
23487,"/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}","/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(final int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}"
23488,"public static boolean usesUtf8(int vcardType){
  return ((vcardType & FLAG_CHARSET_UTF8) != 0);
}","public static boolean usesUtf8(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_UTF8);
}"
23489,"public static boolean isV30(int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}","public static boolean isV30(final int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}"
23490,"public static int getNameOrderType(int vcardType){
  return vcardType & NAME_ORDER_MASK;
}","public static int getNameOrderType(final int vcardType){
  return vcardType & NAME_ORDER_MASK;
}"
23491,"public static boolean needsToConvertPhoneticString(int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}","public static boolean needsToConvertPhoneticString(final int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}"
23492,"public static boolean onlyOneNoteFieldIsAvailable(int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}","public static boolean onlyOneNoteFieldIsAvailable(final int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}"
23493,"public static boolean usesDefactProperty(int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}","public static boolean usesDefactProperty(final int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}"
23494,"/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}","/** 
 * Some Japanese mobile phones use this field for phonetic name, since vCard 2.1 does not have ""SORT-STRING"" type. Also, in some cases, the field has some ';'s in it. Assume the ';' means the same meaning in N property
 */
@SuppressWarnings(""String_Node_Str"") private void handlePhoneticNameFromSound(List<String> elems){
  if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticMiddleName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    return;
  }
  int size;
  if (elems == null || (size=elems.size()) < 1) {
    return;
  }
  if (size > 3) {
    size=3;
  }
  if (elems.get(0).length() > 0) {
    boolean onlyFirstElemIsNonEmpty=true;
    for (int i=1; i < size; i++) {
      if (elems.get(i).length() > 0) {
        onlyFirstElemIsNonEmpty=false;
        break;
      }
    }
    if (onlyFirstElemIsNonEmpty) {
      final String[] namesArray=elems.get(0).split(""String_Node_Str"");
      final int nameArrayLength=namesArray.length;
      if (nameArrayLength == 3) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticMiddleName=namesArray[1];
        mPhoneticGivenName=namesArray[2];
      }
 else       if (nameArrayLength == 2) {
        mPhoneticFamilyName=namesArray[0];
        mPhoneticGivenName=namesArray[1];
      }
 else {
        mPhoneticFullName=elems.get(0);
      }
      return;
    }
  }
switch (size) {
case 3:
    mPhoneticMiddleName=elems.get(2);
case 2:
  mPhoneticGivenName=elems.get(1);
default :
mPhoneticFamilyName=elems.get(0);
}
}"
23495,"/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    StringBuilder builder=new StringBuilder();
    List<String> nameList;
switch (VCardConfig.getNameOrderType(mVCardType)) {
case VCardConfig.NAME_ORDER_JAPANESE:
      if (VCardUtils.containsOnlyPrintableAscii(mFamilyName) && VCardUtils.containsOnlyPrintableAscii(mGivenName)) {
        nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
      }
 else {
        nameList=Arrays.asList(mPrefix,mFamilyName,mMiddleName,mGivenName,mSuffix);
      }
    break;
case VCardConfig.NAME_ORDER_EUROPE:
  nameList=Arrays.asList(mPrefix,mMiddleName,mGivenName,mFamilyName,mSuffix);
break;
default :
nameList=Arrays.asList(mPrefix,mGivenName,mMiddleName,mFamilyName,mSuffix);
break;
}
boolean first=true;
for (String namePart : nameList) {
if (!TextUtils.isEmpty(namePart)) {
if (first) {
first=false;
}
 else {
builder.append(' ');
}
builder.append(namePart);
}
}
mDisplayName=builder.toString();
}
 else if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
}
 else if (mEmailList != null && mEmailList.size() > 0) {
mDisplayName=mEmailList.get(0).data;
}
 else if (mPhoneList != null && mPhoneList.size() > 0) {
mDisplayName=mPhoneList.get(0).data;
}
 else if (mPostalList != null && mPostalList.size() > 0) {
mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
}
if (mDisplayName == null) {
mDisplayName=""String_Node_Str"";
}
}","/** 
 * Construct the display name. The constructed data must not be null.
 */
private void constructDisplayName(){
  if (!TextUtils.isEmpty(mFullName)) {
    mDisplayName=mFullName;
  }
 else   if (!(TextUtils.isEmpty(mFamilyName) && TextUtils.isEmpty(mGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mFamilyName,mMiddleName,mGivenName,mPrefix,mSuffix);
  }
 else   if (!(TextUtils.isEmpty(mPhoneticFamilyName) && TextUtils.isEmpty(mPhoneticGivenName))) {
    mDisplayName=VCardUtils.constructNameFromElements(mVCardType,mPhoneticFamilyName,mPhoneticMiddleName,mPhoneticGivenName);
  }
 else   if (mEmailList != null && mEmailList.size() > 0) {
    mDisplayName=mEmailList.get(0).data;
  }
 else   if (mPhoneList != null && mPhoneList.size() > 0) {
    mDisplayName=mPhoneList.get(0).data;
  }
 else   if (mPostalList != null && mPostalList.size() > 0) {
    mDisplayName=mPostalList.get(0).getFormattedAddress(mVCardType);
  }
  if (mDisplayName == null) {
    mDisplayName=""String_Node_Str"";
  }
}"
23496,"/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!VCardUtils.containsOnlyPrintableAscii(propertyValue) && (!mIsV30 || !mUsesUtf8));
}","/** 
 * Returns true when the property line should contain charset parameter information. This method may return true even when vCard version is 3.0. Strictly, adding charset information is invalid in VCard 3.0. However we'll add the info only when charset we use is not UTF-8 in vCard 3.0 format, since parser side may be able to use the charset via this field, though we may encounter another problem by adding it. e.g. Japanese mobile phones use Shift_Jis while RFC 2426 recommends UTF-8. By adding this field, parsers may be able to know this text is NOT UTF-8 but Shift_Jis.
 */
private boolean shouldAppendCharsetParameter(final String propertyValue){
  return (!(mIsV30 && mUsesUtf8) && !VCardUtils.containsOnlyPrintableAscii(propertyValue));
}"
23497,"private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(displayName));
}","private boolean containsNonEmptyName(ContentValues contentValues){
  final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=contentValues.getAsString(StructuredName.PREFIX);
  final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
  final String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
  final String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
  final String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
  final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
  return !(TextUtils.isEmpty(familyName) && TextUtils.isEmpty(middleName) && TextUtils.isEmpty(givenName)&& TextUtils.isEmpty(prefix)&& TextUtils.isEmpty(suffix)&& TextUtils.isEmpty(phoneticFamilyName)&& TextUtils.isEmpty(phoneticMiddleName)&& TextUtils.isEmpty(phoneticGivenName)&& TextUtils.isEmpty(displayName));
}"
23498,"private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    if (mIsV30) {
      builder.append(Constants.PROPERTY_FN);
      if (shouldAppendCharsetParameter(displayName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedDisplayName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      final String encodedSortString=escapeCharacters(sortString);
      if (shouldAppendCharsetParameter(encodedSortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedSortString);
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName);
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName);
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=!VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName);
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(encodedPhoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}","private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  ContentValues primaryContentValues=null;
  ContentValues subprimaryContentValues=null;
  for (  ContentValues contentValues : contentValuesList) {
    if (contentValues == null) {
      continue;
    }
    Integer isSuperPrimary=contentValues.getAsInteger(StructuredName.IS_SUPER_PRIMARY);
    if (isSuperPrimary != null && isSuperPrimary > 0) {
      primaryContentValues=contentValues;
      break;
    }
 else     if (primaryContentValues == null) {
      Integer isPrimary=contentValues.getAsInteger(StructuredName.IS_PRIMARY);
      if (isPrimary != null && isPrimary > 0 && containsNonEmptyName(contentValues)) {
        primaryContentValues=contentValues;
      }
 else       if (subprimaryContentValues == null && containsNonEmptyName(contentValues)) {
        subprimaryContentValues=contentValues;
      }
    }
  }
  if (primaryContentValues == null) {
    if (subprimaryContentValues != null) {
      primaryContentValues=subprimaryContentValues;
    }
 else {
      Log.e(LOG_TAG,""String_Node_Str"");
      primaryContentValues=new ContentValues();
    }
  }
  final String familyName=primaryContentValues.getAsString(StructuredName.FAMILY_NAME);
  final String middleName=primaryContentValues.getAsString(StructuredName.MIDDLE_NAME);
  final String givenName=primaryContentValues.getAsString(StructuredName.GIVEN_NAME);
  final String prefix=primaryContentValues.getAsString(StructuredName.PREFIX);
  final String suffix=primaryContentValues.getAsString(StructuredName.SUFFIX);
  final String displayName=primaryContentValues.getAsString(StructuredName.DISPLAY_NAME);
  if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
    final boolean shouldAppendCharsetParameterToName=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameters(Arrays.asList(familyName,givenName,middleName,prefix,suffix));
    final boolean reallyUseQuotedPrintableToName=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(familyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(givenName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(middleName)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(prefix)&& VCardUtils.containsOnlyNonCrLfPrintableAscii(suffix)));
    final String formattedName;
    if (!TextUtils.isEmpty(displayName)) {
      formattedName=displayName;
    }
 else {
      formattedName=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),familyName,middleName,givenName,prefix,suffix);
    }
    final boolean shouldAppendCharsetParameterToFN=!(mIsV30 && UTF_8.equalsIgnoreCase(mCharsetString)) && shouldAppendCharsetParameter(formattedName);
    final boolean reallyUseQuotedPrintableToFN=!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(formattedName);
    final String encodedFamily;
    final String encodedGiven;
    final String encodedMiddle;
    final String encodedPrefix;
    final String encodedSuffix;
    if (reallyUseQuotedPrintableToName) {
      encodedFamily=encodeQuotedPrintable(familyName);
      encodedGiven=encodeQuotedPrintable(givenName);
      encodedMiddle=encodeQuotedPrintable(middleName);
      encodedPrefix=encodeQuotedPrintable(prefix);
      encodedSuffix=encodeQuotedPrintable(suffix);
    }
 else {
      encodedFamily=escapeCharacters(familyName);
      encodedGiven=escapeCharacters(givenName);
      encodedMiddle=escapeCharacters(middleName);
      encodedPrefix=escapeCharacters(prefix);
      encodedSuffix=escapeCharacters(suffix);
    }
    final String encodedFormattedname=(reallyUseQuotedPrintableToFN ? encodeQuotedPrintable(formattedName) : escapeCharacters(formattedName));
    builder.append(Constants.PROPERTY_N);
    if (mIsDoCoMo) {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(formattedName);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
    }
 else {
      if (shouldAppendCharsetParameterToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintableToName) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
    }
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameterToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToFN) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedFormattedname);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (!TextUtils.isEmpty(displayName)) {
    final boolean reallyUseQuotedPrintableToDisplayName=(!mRefrainsQPToPrimaryProperties && !VCardUtils.containsOnlyNonCrLfPrintableAscii(displayName));
    final String encodedDisplayName=reallyUseQuotedPrintableToDisplayName ? encodeQuotedPrintable(displayName) : escapeCharacters(displayName);
    builder.append(Constants.PROPERTY_N);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    if (reallyUseQuotedPrintableToDisplayName) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(VCARD_PARAM_ENCODING_QP);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
    builder.append(Constants.PROPERTY_FN);
    if (shouldAppendCharsetParameter(displayName)) {
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(mVCardCharsetParameter);
    }
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(encodedDisplayName);
    builder.append(VCARD_END_OF_LINE);
  }
 else   if (mIsV30) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
    appendVCardLine(builder,Constants.PROPERTY_FN,""String_Node_Str"");
  }
 else   if (mIsDoCoMo) {
    appendVCardLine(builder,Constants.PROPERTY_N,""String_Node_Str"");
  }
  final String phoneticFamilyName;
  final String phoneticMiddleName;
  final String phoneticGivenName;
{
    String tmpPhoneticFamilyName=primaryContentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String tmpPhoneticMiddleName=primaryContentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String tmpPhoneticGivenName=primaryContentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (mNeedsToConvertPhoneticString) {
      phoneticFamilyName=VCardUtils.toHalfWidthString(tmpPhoneticFamilyName);
      phoneticMiddleName=VCardUtils.toHalfWidthString(tmpPhoneticMiddleName);
      phoneticGivenName=VCardUtils.toHalfWidthString(tmpPhoneticGivenName);
    }
 else {
      phoneticFamilyName=tmpPhoneticFamilyName;
      phoneticMiddleName=tmpPhoneticMiddleName;
      phoneticGivenName=tmpPhoneticGivenName;
    }
  }
  if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
    if (mIsV30) {
      final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
      builder.append(Constants.PROPERTY_SORT_STRING);
      if (shouldAppendCharsetParameter(sortString)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(sortString));
      builder.append(VCARD_END_OF_LINE);
    }
 else     if (mIsJapaneseMobilePhone) {
      builder.append(Constants.PROPERTY_SOUND);
      builder.append(VCARD_PARAM_SEPARATOR);
      builder.append(Constants.PARAM_TYPE_X_IRMC_N);
      boolean reallyUseQuotedPrintable=(!mRefrainsQPToPrimaryProperties && !(VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName) && VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName)));
      final String encodedPhoneticFamilyName;
      final String encodedPhoneticMiddleName;
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      if (shouldAppendCharsetParameters(Arrays.asList(encodedPhoneticFamilyName,encodedPhoneticMiddleName,encodedPhoneticGivenName))) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      builder.append(VCARD_DATA_SEPARATOR);
{
        boolean first=true;
        if (!TextUtils.isEmpty(encodedPhoneticFamilyName)) {
          builder.append(encodedPhoneticFamilyName);
          first=false;
        }
        if (!TextUtils.isEmpty(encodedPhoneticMiddleName)) {
          if (first) {
            first=false;
          }
 else {
            builder.append(' ');
          }
          builder.append(encodedPhoneticMiddleName);
        }
        if (!TextUtils.isEmpty(encodedPhoneticGivenName)) {
          if (!first) {
            builder.append(' ');
          }
          builder.append(encodedPhoneticGivenName);
        }
      }
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_END_OF_LINE);
    }
  }
 else   if (mIsDoCoMo) {
    builder.append(Constants.PROPERTY_SOUND);
    builder.append(VCARD_PARAM_SEPARATOR);
    builder.append(Constants.PARAM_TYPE_X_IRMC_N);
    builder.append(VCARD_DATA_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_ITEM_SEPARATOR);
    builder.append(VCARD_END_OF_LINE);
  }
  if (mUsesDefactProperty) {
    if (!TextUtils.isEmpty(phoneticGivenName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticGivenName));
      final String encodedPhoneticGivenName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticGivenName=encodeQuotedPrintable(phoneticGivenName);
      }
 else {
        encodedPhoneticGivenName=escapeCharacters(phoneticGivenName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_FIRST_NAME);
      if (shouldAppendCharsetParameter(phoneticGivenName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticGivenName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticMiddleName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticMiddleName));
      final String encodedPhoneticMiddleName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticMiddleName=encodeQuotedPrintable(phoneticMiddleName);
      }
 else {
        encodedPhoneticMiddleName=escapeCharacters(phoneticMiddleName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_MIDDLE_NAME);
      if (shouldAppendCharsetParameter(phoneticMiddleName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticMiddleName);
      builder.append(VCARD_END_OF_LINE);
    }
    if (!TextUtils.isEmpty(phoneticFamilyName)) {
      final boolean reallyUseQuotedPrintable=(mUsesQuotedPrintable && !VCardUtils.containsOnlyNonCrLfPrintableAscii(phoneticFamilyName));
      final String encodedPhoneticFamilyName;
      if (reallyUseQuotedPrintable) {
        encodedPhoneticFamilyName=encodeQuotedPrintable(phoneticFamilyName);
      }
 else {
        encodedPhoneticFamilyName=escapeCharacters(phoneticFamilyName);
      }
      builder.append(Constants.PROPERTY_X_PHONETIC_LAST_NAME);
      if (shouldAppendCharsetParameter(phoneticFamilyName)) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(mVCardCharsetParameter);
      }
      if (reallyUseQuotedPrintable) {
        builder.append(VCARD_PARAM_SEPARATOR);
        builder.append(VCARD_PARAM_ENCODING_QP);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedPhoneticFamilyName);
      builder.append(VCARD_END_OF_LINE);
    }
  }
}"
23499,"public static boolean usesQuotedPrintable(int vcardType){
  return !isV30(vcardType);
}","public static boolean usesQuotedPrintable(final int vcardType){
  return !isV30(vcardType);
}"
23500,"public static int getVCardTypeFromString(String vcardTypeString){
  String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}","public static int getVCardTypeFromString(final String vcardTypeString){
  final String loweredKey=vcardTypeString.toLowerCase();
  if (sVCardTypeMap.containsKey(loweredKey)) {
    return sVCardTypeMap.get(loweredKey);
  }
 else {
    Log.e(LOG_TAG,""String_Node_Str"" + vcardTypeString + ""String_Node_Str"");
    return VCARD_TYPE_DEFAULT;
  }
}"
23501,"public static boolean usesAndroidSpecificProperty(int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}","public static boolean usesAndroidSpecificProperty(final int vcardType){
  return ((vcardType & FLAG_USE_ANDROID_PROPERTY) != 0);
}"
23502,"public static boolean appendTypeParamName(int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}","public static boolean appendTypeParamName(final int vcardType){
  return (isV30(vcardType) || ((vcardType & FLAG_APPEND_TYPE_PARAM) != 0));
}"
23503,"public static boolean refrainsQPToPrimaryProperties(int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}","public static boolean refrainsQPToPrimaryProperties(final int vcardType){
  return (!usesQuotedPrintable(vcardType) || ((vcardType & FLAG_REFRAIN_QP_TO_PRIMARY_PROPERTIES) != 0));
}"
23504,"public static boolean isDoCoMo(int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}","public static boolean isDoCoMo(final int vcardType){
  return ((vcardType & FLAG_DOCOMO) != 0);
}"
23505,"public static boolean usesShiftJis(int vcardType){
  return ((vcardType & FLAG_CHARSET_SHIFT_JIS) != 0);
}","public static boolean usesShiftJis(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_SHIFT_JIS);
}"
23506,"/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}","/** 
 * @return true if the device is Japanese and some Japanese convension isapplied to creating ""formatted"" something like FORMATTED_ADDRESS.
 */
public static boolean isJapaneseDevice(final int vcardType){
  return sJapaneseMobileTypeSet.contains(vcardType);
}"
23507,"public static boolean usesUtf8(int vcardType){
  return ((vcardType & FLAG_CHARSET_UTF8) != 0);
}","public static boolean usesUtf8(final int vcardType){
  return ((vcardType & FLAG_CHARSET_MASK) == FLAG_CHARSET_UTF8);
}"
23508,"public static boolean isV30(int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}","public static boolean isV30(final int vcardType){
  return ((vcardType & FLAG_V30) != 0);
}"
23509,"public static int getNameOrderType(int vcardType){
  return vcardType & NAME_ORDER_MASK;
}","public static int getNameOrderType(final int vcardType){
  return vcardType & NAME_ORDER_MASK;
}"
23510,"public static boolean needsToConvertPhoneticString(int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}","public static boolean needsToConvertPhoneticString(final int vcardType){
  return ((vcardType & FLAG_CONVERT_PHONETIC_NAME_STRINGS) != 0);
}"
23511,"public static boolean onlyOneNoteFieldIsAvailable(int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}","public static boolean onlyOneNoteFieldIsAvailable(final int vcardType){
  return vcardType == VCARD_TYPE_DOCOMO;
}"
23512,"public static boolean usesDefactProperty(int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}","public static boolean usesDefactProperty(final int vcardType){
  return ((vcardType & FLAG_USE_DEFACT_PROPERTY) != 0);
}"
23513,"public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault){
synchronized (this) {
    if (mWallpaper != null) {
      return mWallpaper;
    }
    if (mDefaultWallpaper != null) {
      return mDefaultWallpaper;
    }
    mWallpaper=getCurrentWallpaperLocked(context);
    if (mWallpaper == null && returnDefault) {
      mDefaultWallpaper=getDefaultWallpaperLocked(context);
      return mDefaultWallpaper;
    }
    return mWallpaper;
  }
}","public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault){
synchronized (this) {
    if (mWallpaper != null) {
      return mWallpaper;
    }
    if (mDefaultWallpaper != null) {
      return mDefaultWallpaper;
    }
    mWallpaper=null;
    try {
      mWallpaper=getCurrentWallpaperLocked(context);
    }
 catch (    OutOfMemoryError e) {
      Log.w(TAG,""String_Node_Str"",e);
    }
    if (mWallpaper == null && returnDefault) {
      mDefaultWallpaper=getDefaultWallpaperLocked(context);
      return mDefaultWallpaper;
    }
    return mWallpaper;
  }
}"
23514,"private Bitmap getDefaultWallpaperLocked(Context context){
  try {
    InputStream is=context.getResources().openRawResource(com.android.internal.R.drawable.default_wallpaper);
    if (is != null) {
      int width=mService.getWidthHint();
      int height=mService.getHeightHint();
      if (width <= 0 || height <= 0) {
        Bitmap bm=BitmapFactory.decodeStream(is,null,null);
        try {
          is.close();
        }
 catch (        IOException e) {
        }
        if (bm != null) {
          bm.setDensity(DisplayMetrics.DENSITY_DEVICE);
        }
        return bm;
      }
      BitmapFactory.Options options=new BitmapFactory.Options();
      options.inDither=false;
      options.inPreferredConfig=Bitmap.Config.ARGB_8888;
      Bitmap bm=BitmapFactory.decodeStream(is,null,options);
      try {
        is.close();
      }
 catch (      IOException e) {
      }
      return generateBitmap(context,bm,width,height);
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}","private Bitmap getDefaultWallpaperLocked(Context context){
  try {
    InputStream is=context.getResources().openRawResource(com.android.internal.R.drawable.default_wallpaper);
    if (is != null) {
      int width=mService.getWidthHint();
      int height=mService.getHeightHint();
      if (width <= 0 || height <= 0) {
        Bitmap bm=BitmapFactory.decodeStream(is,null,null);
        try {
          is.close();
        }
 catch (        IOException e) {
        }
        if (bm != null) {
          bm.setDensity(DisplayMetrics.DENSITY_DEVICE);
        }
        return bm;
      }
      BitmapFactory.Options options=new BitmapFactory.Options();
      options.inDither=false;
      options.inPreferredConfig=Bitmap.Config.ARGB_8888;
      Bitmap bm=BitmapFactory.decodeStream(is,null,options);
      try {
        is.close();
      }
 catch (      IOException e) {
      }
      try {
        return generateBitmap(context,bm,width,height);
      }
 catch (      OutOfMemoryError e) {
        Log.w(TAG,""String_Node_Str"",e);
        return bm;
      }
    }
  }
 catch (  RemoteException e) {
  }
  return null;
}"
23515,"void drawFrame(){
  SurfaceHolder sh=getSurfaceHolder();
  Canvas c=sh.lockCanvas();
  if (c != null) {
    final Rect frame=sh.getSurfaceFrame();
synchronized (mLock) {
      final Drawable background=mBackground;
      final int dw=frame.width();
      final int dh=frame.height();
      final int bw=mBackground.getIntrinsicWidth();
      final int bh=mBackground.getIntrinsicHeight();
      final int availw=dw - bw;
      final int availh=dh - bh;
      int xPixels=availw < 0 ? (int)(availw * mXOffset + .5f) : (availw / 2);
      int yPixels=availh < 0 ? (int)(availh * mYOffset + .5f) : (availh / 2);
      c.translate(xPixels,yPixels);
      if (availw < 0 || availh < 0) {
        c.save(Canvas.CLIP_SAVE_FLAG);
        c.clipRect(0,0,bw,bh,Op.DIFFERENCE);
        c.drawColor(0xff000000);
        c.restore();
      }
      background.draw(c);
    }
    sh.unlockCanvasAndPost(c);
  }
}","void drawFrame(){
  SurfaceHolder sh=getSurfaceHolder();
  Canvas c=sh.lockCanvas();
  if (c != null) {
    final Rect frame=sh.getSurfaceFrame();
synchronized (mLock) {
      final Drawable background=mBackground;
      final int dw=frame.width();
      final int dh=frame.height();
      final int bw=background != null ? background.getIntrinsicWidth() : 0;
      final int bh=background != null ? background.getIntrinsicHeight() : 0;
      final int availw=dw - bw;
      final int availh=dh - bh;
      int xPixels=availw < 0 ? (int)(availw * mXOffset + .5f) : (availw / 2);
      int yPixels=availh < 0 ? (int)(availh * mYOffset + .5f) : (availh / 2);
      c.translate(xPixels,yPixels);
      if (availw < 0 || availh < 0) {
        c.save(Canvas.CLIP_SAVE_FLAG);
        c.clipRect(0,0,bw,bh,Op.DIFFERENCE);
        c.drawColor(0xff000000);
        c.restore();
      }
      if (background != null) {
        background.draw(c);
      }
    }
    sh.unlockCanvasAndPost(c);
  }
}"
23516,"void updateWallpaper(){
synchronized (mLock) {
    mBackground=mWallpaperManager.getFastDrawable();
  }
}","void updateWallpaper(){
synchronized (mLock) {
    try {
      mBackground=mWallpaperManager.getFastDrawable();
    }
 catch (    RuntimeException e) {
      Log.w(""String_Node_Str"",""String_Node_Str"",e);
    }
  }
}"
23517,"public int getMaxPacketSize(){
  return mMaxPacketSize - 6;
}","public int getMaxPacketSize(){
  return mMaxPacketSize - 6 - getHeaderLength();
}"
23518,"/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  ensureNotDone();
  if (mPrivateOutputOpen)   throw new IOException(""String_Node_Str"");
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,mMaxPacketSize - 6);
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}","/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  ensureNotDone();
  if (mPrivateOutputOpen)   throw new IOException(""String_Node_Str"");
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,getMaxPacketSize());
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}"
23519,"public int getMaxPacketSize(){
  return mMaxPacketLength - 6;
}","public int getMaxPacketSize(){
  return mMaxPacketLength - 6 - getHeaderLength();
}"
23520,"/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  if (mPrivateOutputOpen) {
    throw new IOException(""String_Node_Str"");
  }
  if (!mRequestFinished) {
    throw new IOException(""String_Node_Str"");
  }
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,mMaxPacketLength - 6);
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}","/** 
 * Open and return an output stream for a connection.
 * @return an output stream
 * @throws IOException if an I/O error occurs
 */
public OutputStream openOutputStream() throws IOException {
  ensureOpen();
  if (mPrivateOutputOpen) {
    throw new IOException(""String_Node_Str"");
  }
  if (!mRequestFinished) {
    throw new IOException(""String_Node_Str"");
  }
  if (mPrivateOutput == null) {
    mPrivateOutput=new PrivateOutputStream(this,getMaxPacketSize());
  }
  mPrivateOutputOpen=true;
  return mPrivateOutput;
}"
23521,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if (mGetOperation && type == ResponseCodes.OBEX_HTTP_OK) {
    finalBitSet=true;
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL)) {
        finalBitSet=true;
      }
 else       if (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL) {
        mRequestFinished=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
23522,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
    if ((request & 0x80) == 0) {
      finalBitSet=false;
    }
 else {
      finalBitSet=true;
      mRequestFinished=true;
    }
  }
 else   if ((request == 0x03) || (request == 0x83)) {
    mGetOperation=true;
    finalBitSet=false;
    if (request == 0x83) {
      mRequestFinished=true;
    }
  }
 else {
    throw new IOException(""String_Node_Str"");
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !mRequestFinished) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
}"
23523,"private final void handleReceiver(ReceiverData data){
  unscheduleGcIdler();
  String component=data.intent.getComponent().getClassName();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  IActivityManager mgr=ActivityManagerNative.getDefault();
  BroadcastReceiver receiver=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    data.intent.setExtrasClassLoader(cl);
    if (data.resultExtras != null) {
      data.resultExtras.setClassLoader(cl);
    }
    receiver=(BroadcastReceiver)cl.loadClass(component).newInstance();
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
  }
  try {
    Application app=packageInfo.makeApplication(false);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.intent + ""String_Node_Str""+ app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ packageInfo.getPackageName()+ ""String_Node_Str""+ data.intent.getComponent().toShortString()+ ""String_Node_Str""+ packageInfo.getAppDir());
    ApplicationContext context=(ApplicationContext)app.getBaseContext();
    receiver.setOrderedHint(true);
    receiver.setResult(data.resultCode,data.resultData,data.resultExtras);
    receiver.setOrderedHint(data.sync);
    receiver.onReceive(context.getReceiverRestrictedContext(),data.intent);
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    if (!mInstrumentation.onException(receiver,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (data.sync) {
      mgr.finishReceiver(mAppThread.asBinder(),receiver.getResultCode(),receiver.getResultData(),receiver.getResultExtras(false),receiver.getAbortBroadcast());
    }
 else {
      mgr.finishReceiver(mAppThread.asBinder(),0,null,null,false);
    }
  }
 catch (  RemoteException ex) {
  }
}","private final void handleReceiver(ReceiverData data){
  unscheduleGcIdler();
  String component=data.intent.getComponent().getClassName();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  IActivityManager mgr=ActivityManagerNative.getDefault();
  BroadcastReceiver receiver=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    data.intent.setExtrasClassLoader(cl);
    if (data.resultExtras != null) {
      data.resultExtras.setClassLoader(cl);
    }
    receiver=(BroadcastReceiver)cl.loadClass(component).newInstance();
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
  }
  try {
    Application app=packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.intent + ""String_Node_Str""+ app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ packageInfo.getPackageName()+ ""String_Node_Str""+ data.intent.getComponent().toShortString()+ ""String_Node_Str""+ packageInfo.getAppDir());
    ApplicationContext context=(ApplicationContext)app.getBaseContext();
    receiver.setOrderedHint(true);
    receiver.setResult(data.resultCode,data.resultData,data.resultExtras);
    receiver.setOrderedHint(data.sync);
    receiver.onReceive(context.getReceiverRestrictedContext(),data.intent);
  }
 catch (  Exception e) {
    try {
      mgr.finishReceiver(mAppThread.asBinder(),data.resultCode,data.resultData,data.resultExtras,data.resultAbort);
    }
 catch (    RemoteException ex) {
    }
    if (!mInstrumentation.onException(receiver,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (data.sync) {
      mgr.finishReceiver(mAppThread.asBinder(),receiver.getResultCode(),receiver.getResultData(),receiver.getResultExtras(false),receiver.getAbortBroadcast());
    }
 else {
      mgr.finishReceiver(mAppThread.asBinder(),0,null,null,false);
    }
  }
 catch (  RemoteException ex) {
  }
}"
23524,"private final void handleCreateService(CreateServiceData data){
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  Service service=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    service=(Service)cl.loadClass(data.info.name).newInstance();
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.info.name);
    ApplicationContext context=new ApplicationContext();
    context.init(packageInfo,null,this);
    Application app=packageInfo.makeApplication(false);
    context.setOuterContext(service);
    service.attach(context,this,data.info.name,data.token,app,ActivityManagerNative.getDefault());
    service.onCreate();
    mServices.put(data.token,service);
    try {
      ActivityManagerNative.getDefault().serviceDoneExecuting(data.token,0,0,0);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
}","private final void handleCreateService(CreateServiceData data){
  unscheduleGcIdler();
  PackageInfo packageInfo=getPackageInfoNoCheck(data.info.applicationInfo);
  Service service=null;
  try {
    java.lang.ClassLoader cl=packageInfo.getClassLoader();
    service=(Service)cl.loadClass(data.info.name).newInstance();
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + data.info.name);
    ApplicationContext context=new ApplicationContext();
    context.init(packageInfo,null,this);
    Application app=packageInfo.makeApplication(false,mInstrumentation);
    context.setOuterContext(service);
    service.attach(context,this,data.info.name,data.token,app,ActivityManagerNative.getDefault());
    service.onCreate();
    mServices.put(data.token,service);
    try {
      ActivityManagerNative.getDefault().serviceDoneExecuting(data.token,0,0,0);
    }
 catch (    RemoteException e) {
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(service,e)) {
      throw new RuntimeException(""String_Node_Str"" + data.info.name + ""String_Node_Str""+ e.toString(),e);
    }
  }
}"
23525,"private final void handleBindApplication(AppBindData data){
  mBoundApplication=data;
  mConfiguration=new Configuration(data.config);
  Process.setArgV0(data.processName);
  android.ddm.DdmHandleAppName.setAppName(data.processName);
  TimeZone.setDefault(null);
  Locale.setDefault(data.config.locale);
  Resources.getSystem().updateConfiguration(mConfiguration,null);
  data.info=getPackageInfoNoCheck(data.appInfo);
  if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
    Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
  }
  if (data.debugMode != IApplicationThread.DEBUG_OFF) {
    Debug.changeDebugPort(8100);
    if (data.debugMode == IApplicationThread.DEBUG_WAIT) {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
      IActivityManager mgr=ActivityManagerNative.getDefault();
      try {
        mgr.showWaitingForDebugger(mAppThread,true);
      }
 catch (      RemoteException ex) {
      }
      Debug.waitForDebugger();
      try {
        mgr.showWaitingForDebugger(mAppThread,false);
      }
 catch (      RemoteException ex) {
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
    }
  }
  if (data.instrumentationName != null) {
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(data.info,null,this);
    InstrumentationInfo ii=null;
    try {
      ii=appContext.getPackageManager().getInstrumentationInfo(data.instrumentationName,0);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName);
    }
    mInstrumentationAppDir=ii.sourceDir;
    mInstrumentationAppPackage=ii.packageName;
    mInstrumentedAppDir=data.info.getAppDir();
    ApplicationInfo instrApp=new ApplicationInfo();
    instrApp.packageName=ii.packageName;
    instrApp.sourceDir=ii.sourceDir;
    instrApp.publicSourceDir=ii.publicSourceDir;
    instrApp.dataDir=ii.dataDir;
    PackageInfo pi=getPackageInfo(instrApp,appContext.getClassLoader(),false,true);
    ApplicationContext instrContext=new ApplicationContext();
    instrContext.init(pi,null,this);
    try {
      java.lang.ClassLoader cl=instrContext.getClassLoader();
      mInstrumentation=(Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
    mInstrumentation.init(this,instrContext,appContext,new ComponentName(ii.packageName,ii.name),data.instrumentationWatcher);
    if (data.profileFile != null && !ii.handleProfiling) {
      data.handlingProfiling=true;
      File file=new File(data.profileFile);
      file.getParentFile().mkdirs();
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
    try {
      mInstrumentation.onCreate(data.instrumentationArgs);
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
  }
 else {
    mInstrumentation=new Instrumentation();
  }
  Application app=data.info.makeApplication(data.restrictedBackupMode);
  mInitialApplication=app;
  List<ProviderInfo> providers=data.providers;
  if (providers != null) {
    installContentProviders(app,providers);
  }
  try {
    mInstrumentation.callApplicationOnCreate(app);
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + app.getClass().getName() + ""String_Node_Str""+ e.toString(),e);
    }
  }
}","private final void handleBindApplication(AppBindData data){
  mBoundApplication=data;
  mConfiguration=new Configuration(data.config);
  Process.setArgV0(data.processName);
  android.ddm.DdmHandleAppName.setAppName(data.processName);
  TimeZone.setDefault(null);
  Locale.setDefault(data.config.locale);
  Resources.getSystem().updateConfiguration(mConfiguration,null);
  data.info=getPackageInfoNoCheck(data.appInfo);
  if ((data.appInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) {
    Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);
  }
  if (data.debugMode != IApplicationThread.DEBUG_OFF) {
    Debug.changeDebugPort(8100);
    if (data.debugMode == IApplicationThread.DEBUG_WAIT) {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
      IActivityManager mgr=ActivityManagerNative.getDefault();
      try {
        mgr.showWaitingForDebugger(mAppThread,true);
      }
 catch (      RemoteException ex) {
      }
      Debug.waitForDebugger();
      try {
        mgr.showWaitingForDebugger(mAppThread,false);
      }
 catch (      RemoteException ex) {
      }
    }
 else {
      Log.w(TAG,""String_Node_Str"" + data.info.getPackageName() + ""String_Node_Str"");
    }
  }
  if (data.instrumentationName != null) {
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(data.info,null,this);
    InstrumentationInfo ii=null;
    try {
      ii=appContext.getPackageManager().getInstrumentationInfo(data.instrumentationName,0);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    if (ii == null) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName);
    }
    mInstrumentationAppDir=ii.sourceDir;
    mInstrumentationAppPackage=ii.packageName;
    mInstrumentedAppDir=data.info.getAppDir();
    ApplicationInfo instrApp=new ApplicationInfo();
    instrApp.packageName=ii.packageName;
    instrApp.sourceDir=ii.sourceDir;
    instrApp.publicSourceDir=ii.publicSourceDir;
    instrApp.dataDir=ii.dataDir;
    PackageInfo pi=getPackageInfo(instrApp,appContext.getClassLoader(),false,true);
    ApplicationContext instrContext=new ApplicationContext();
    instrContext.init(pi,null,this);
    try {
      java.lang.ClassLoader cl=instrContext.getClassLoader();
      mInstrumentation=(Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance();
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
    mInstrumentation.init(this,instrContext,appContext,new ComponentName(ii.packageName,ii.name),data.instrumentationWatcher);
    if (data.profileFile != null && !ii.handleProfiling) {
      data.handlingProfiling=true;
      File file=new File(data.profileFile);
      file.getParentFile().mkdirs();
      Debug.startMethodTracing(file.toString(),8 * 1024 * 1024);
    }
    try {
      mInstrumentation.onCreate(data.instrumentationArgs);
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + data.instrumentationName + ""String_Node_Str""+ e.toString(),e);
    }
  }
 else {
    mInstrumentation=new Instrumentation();
  }
  Application app=data.info.makeApplication(data.restrictedBackupMode,null);
  mInitialApplication=app;
  List<ProviderInfo> providers=data.providers;
  if (providers != null) {
    installContentProviders(app,providers);
  }
  try {
    mInstrumentation.callApplicationOnCreate(app);
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + app.getClass().getName() + ""String_Node_Str""+ e.toString(),e);
    }
  }
}"
23526,"private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ApplicationContext appContext=new ApplicationContext();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}","private final Activity performLaunchActivity(ActivityRecord r,Intent customIntent){
  ActivityInfo aInfo=r.activityInfo;
  if (r.packageInfo == null) {
    r.packageInfo=getPackageInfo(aInfo.applicationInfo,Context.CONTEXT_INCLUDE_CODE);
  }
  ComponentName component=r.intent.getComponent();
  if (component == null) {
    component=r.intent.resolveActivity(mInitialApplication.getPackageManager());
    r.intent.setComponent(component);
  }
  if (r.activityInfo.targetActivity != null) {
    component=new ComponentName(r.activityInfo.packageName,r.activityInfo.targetActivity);
  }
  Activity activity=null;
  try {
    java.lang.ClassLoader cl=r.packageInfo.getClassLoader();
    activity=mInstrumentation.newActivity(cl,component.getClassName(),r.intent);
    r.intent.setExtrasClassLoader(cl);
    if (r.state != null) {
      r.state.setClassLoader(cl);
    }
  }
 catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  try {
    Application app=r.packageInfo.makeApplication(false,mInstrumentation);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    if (localLOGV)     Log.v(TAG,r + ""String_Node_Str"" + app+ ""String_Node_Str""+ app.getPackageName()+ ""String_Node_Str""+ r.packageInfo.getPackageName()+ ""String_Node_Str""+ r.intent.getComponent().toShortString()+ ""String_Node_Str""+ r.packageInfo.getAppDir());
    if (activity != null) {
      ApplicationContext appContext=new ApplicationContext();
      appContext.init(r.packageInfo,r.token,this);
      appContext.setOuterContext(activity);
      CharSequence title=r.activityInfo.loadLabel(appContext.getPackageManager());
      Configuration config=new Configuration(mConfiguration);
      if (DEBUG_CONFIGURATION)       Log.v(TAG,""String_Node_Str"" + r.activityInfo.name + ""String_Node_Str""+ config);
      activity.attach(appContext,this,getInstrumentation(),r.token,r.ident,app,r.intent,r.activityInfo,title,r.parent,r.embeddedID,r.lastNonConfigurationInstance,r.lastNonConfigurationChildInstances,config);
      if (customIntent != null) {
        activity.mIntent=customIntent;
      }
      r.lastNonConfigurationInstance=null;
      r.lastNonConfigurationChildInstances=null;
      activity.mStartedActivity=false;
      int theme=r.activityInfo.getThemeResource();
      if (theme != 0) {
        activity.setTheme(theme);
      }
      activity.mCalled=false;
      mInstrumentation.callActivityOnCreate(activity,r.state);
      if (!activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
      }
      r.activity=activity;
      r.stopped=true;
      if (!r.activity.mFinished) {
        activity.performStart();
        r.stopped=false;
      }
      if (!r.activity.mFinished) {
        if (r.state != null) {
          mInstrumentation.callActivityOnRestoreInstanceState(activity,r.state);
        }
      }
      if (!r.activity.mFinished) {
        activity.mCalled=false;
        mInstrumentation.callActivityOnPostCreate(activity,r.state);
        if (!activity.mCalled) {
          throw new SuperNotCalledException(""String_Node_Str"" + r.intent.getComponent().toShortString() + ""String_Node_Str"");
        }
      }
      r.state=null;
    }
    r.paused=true;
    mActivities.put(r.token,r);
  }
 catch (  SuperNotCalledException e) {
    throw e;
  }
catch (  Exception e) {
    if (!mInstrumentation.onException(activity,e)) {
      throw new RuntimeException(""String_Node_Str"" + component + ""String_Node_Str""+ e.toString(),e);
    }
  }
  return activity;
}"
23527,"public Application makeApplication(boolean forceDefaultAppClass){
  if (mApplication != null) {
    return mApplication;
  }
  Application app=null;
  String appClass=mApplicationInfo.className;
  if (forceDefaultAppClass || (appClass == null)) {
    appClass=""String_Node_Str"";
  }
  try {
    java.lang.ClassLoader cl=getClassLoader();
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(this,null,mActivityThread);
    app=mActivityThread.mInstrumentation.newApplication(cl,appClass,appContext);
    appContext.setOuterContext(app);
  }
 catch (  Exception e) {
    if (!mActivityThread.mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + appClass + ""String_Node_Str""+ e.toString(),e);
    }
  }
  mActivityThread.mAllApplications.add(app);
  return mApplication=app;
}","public Application makeApplication(boolean forceDefaultAppClass,Instrumentation instrumentation){
  if (mApplication != null) {
    return mApplication;
  }
  Application app=null;
  String appClass=mApplicationInfo.className;
  if (forceDefaultAppClass || (appClass == null)) {
    appClass=""String_Node_Str"";
  }
  try {
    java.lang.ClassLoader cl=getClassLoader();
    ApplicationContext appContext=new ApplicationContext();
    appContext.init(this,null,mActivityThread);
    app=mActivityThread.mInstrumentation.newApplication(cl,appClass,appContext);
    appContext.setOuterContext(app);
  }
 catch (  Exception e) {
    if (!mActivityThread.mInstrumentation.onException(app,e)) {
      throw new RuntimeException(""String_Node_Str"" + appClass + ""String_Node_Str""+ e.toString(),e);
    }
  }
  mActivityThread.mAllApplications.add(app);
  mApplication=app;
  if (instrumentation != null) {
    try {
      instrumentation.callApplicationOnCreate(app);
    }
 catch (    Exception e) {
      if (!instrumentation.onException(app,e)) {
        throw new RuntimeException(""String_Node_Str"" + app.getClass().getName() + ""String_Node_Str""+ e.toString(),e);
      }
    }
  }
  return app;
}"
23528,"public void start(GLThread thread) throws InterruptedException {
  GLThread oldThread=null;
synchronized (this) {
    mMostRecentGLThread=thread;
    oldThread=mMostRecentGLThread;
  }
  if (oldThread != null) {
synchronized (oldThread) {
      oldThread.notifyAll();
    }
  }
  sEglSemaphore.acquire();
}","public void start(GLThread thread) throws InterruptedException {
  GLThread oldThread=null;
synchronized (this) {
    oldThread=mMostRecentGLThread;
    mMostRecentGLThread=thread;
  }
  if (oldThread != null) {
synchronized (oldThread) {
      oldThread.notifyAll();
    }
  }
  sEglSemaphore.acquire();
}"
23529,"/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
  }
  return ted;
}","/** 
 * Calculate the message text encoding length, fragmentation, and other details.
 * @param force ignore (but still count) illegal characters if true
 * @return septet count, or -1 on failure
 */
public static TextEncodingDetails calcTextEncodingDetails(CharSequence msg,boolean force7BitEncoding){
  TextEncodingDetails ted;
  int septets=countAsciiSeptets(msg,force7BitEncoding);
  if (septets != -1 && septets <= SmsMessage.MAX_USER_DATA_SEPTETS) {
    ted=new TextEncodingDetails();
    ted.msgCount=1;
    ted.codeUnitCount=septets;
    ted.codeUnitsRemaining=SmsMessage.MAX_USER_DATA_SEPTETS - septets;
    ted.codeUnitSize=SmsMessage.ENCODING_7BIT;
  }
 else {
    ted=com.android.internal.telephony.gsm.SmsMessage.calculateLength(msg,force7BitEncoding);
    if (ted.msgCount == 1 && ted.codeUnitSize == SmsMessage.ENCODING_7BIT) {
      ted.codeUnitCount=msg.length();
      int octets=ted.codeUnitCount * 2;
      if (octets > MAX_USER_DATA_BYTES) {
        ted.msgCount=(octets / MAX_USER_DATA_BYTES_WITH_HEADER) + 1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES_WITH_HEADER - (octets % MAX_USER_DATA_BYTES_WITH_HEADER)) / 2;
      }
 else {
        ted.msgCount=1;
        ted.codeUnitsRemaining=(MAX_USER_DATA_BYTES - octets) / 2;
      }
      ted.codeUnitSize=ENCODING_16BIT;
    }
  }
  return ted;
}"
23530,"private boolean signaturesMatch(Signature[] storedSigs,Signature[] deviceSigs){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + storedSigs + ""String_Node_Str""+ deviceSigs);
  if ((storedSigs == null || storedSigs.length == 0) && (deviceSigs == null || deviceSigs.length == 0)) {
    return true;
  }
  if (storedSigs == null || deviceSigs == null) {
    return false;
  }
  int nStored=storedSigs.length;
  int nDevice=deviceSigs.length;
  for (int i=0; i < nStored; i++) {
    boolean match=false;
    for (int j=0; j < nDevice; j++) {
      if (storedSigs[i].equals(deviceSigs[j])) {
        match=true;
        break;
      }
    }
    if (!match) {
      return false;
    }
  }
  return true;
}","private boolean signaturesMatch(Signature[] storedSigs,PackageInfo target){
  if ((target.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + target.packageName + ""String_Node_Str"");
    return true;
  }
  Signature[] deviceSigs=target.signatures;
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + storedSigs + ""String_Node_Str""+ deviceSigs);
  if ((storedSigs == null || storedSigs.length == 0) && (deviceSigs == null || deviceSigs.length == 0)) {
    return true;
  }
  if (storedSigs == null || deviceSigs == null) {
    return false;
  }
  int nStored=storedSigs.length;
  int nDevice=deviceSigs.length;
  for (int i=0; i < nStored; i++) {
    boolean match=false;
    for (int j=0; j < nDevice; j++) {
      if (storedSigs[i].equals(deviceSigs[j])) {
        match=true;
        break;
      }
    }
    if (!match) {
      return false;
    }
  }
  return true;
}"
23531,"private void forceUserActivityLocked(){
  boolean savedActivityAllowed=mUserActivityAllowed;
  mUserActivityAllowed=true;
  userActivity(SystemClock.uptimeMillis(),false);
  mUserActivityAllowed=savedActivityAllowed;
}","private void forceUserActivityLocked(){
  mScreenBrightness.animating=false;
  boolean savedActivityAllowed=mUserActivityAllowed;
  mUserActivityAllowed=true;
  userActivity(SystemClock.uptimeMillis(),false);
  mUserActivityAllowed=savedActivityAllowed;
}"
23532,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}"
23533,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}"
23534,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}"
23535,"private VolumeStreamState(String settingName,int streamType){
  mVolumeIndexSettingName=settingName;
  mLastAudibleVolumeIndexSettingName=settingName + System.APPEND_FOR_LAST_AUDIBLE;
  mStreamType=streamType;
  final ContentResolver cr=mContentResolver;
  mIndexMax=MAX_STREAM_VOLUME[streamType];
  mIndex=Settings.System.getInt(cr,mVolumeIndexSettingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  mLastAudibleIndex=Settings.System.getInt(cr,mLastAudibleVolumeIndexSettingName,(mIndex > 0) ? mIndex : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  AudioSystem.initStreamVolume(streamType,0,mIndexMax);
  mIndexMax*=10;
  mIndex=getValidIndex(10 * mIndex);
  mLastAudibleIndex=getValidIndex(10 * mLastAudibleIndex);
  setStreamVolumeIndex(streamType,mIndex);
  mDeathHandlers=new ArrayList<VolumeDeathHandler>();
}","private VolumeStreamState(String settingName,int streamType){
  setVolumeIndexSettingName(settingName);
  mStreamType=streamType;
  final ContentResolver cr=mContentResolver;
  mIndexMax=MAX_STREAM_VOLUME[streamType];
  mIndex=Settings.System.getInt(cr,mVolumeIndexSettingName,AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  mLastAudibleIndex=Settings.System.getInt(cr,mLastAudibleVolumeIndexSettingName,(mIndex > 0) ? mIndex : AudioManager.DEFAULT_STREAM_VOLUME[streamType]);
  AudioSystem.initStreamVolume(streamType,0,mIndexMax);
  mIndexMax*=10;
  mIndex=getValidIndex(10 * mIndex);
  mLastAudibleIndex=getValidIndex(10 * mLastAudibleIndex);
  setStreamVolumeIndex(streamType,mIndex);
  mDeathHandlers=new ArrayList<VolumeDeathHandler>();
}"
23536,"@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],PERSIST_DELAY);
      }
    }
  }
}","@Override public void onChange(boolean selfChange){
  super.onChange(selfChange);
synchronized (mSettingsLock) {
    int ringerModeAffectedStreams=Settings.System.getInt(mContentResolver,Settings.System.MODE_RINGER_STREAMS_AFFECTED,0);
    if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
      mRingerModeAffectedStreams=ringerModeAffectedStreams;
      setRingerModeInt(getRingerMode(),false);
    }
    int notificationsUseRingVolume=Settings.System.getInt(mContentResolver,Settings.System.NOTIFICATIONS_USE_RING_VOLUME,1);
    if (notificationsUseRingVolume != mNotificationsUseRingVolume) {
      mNotificationsUseRingVolume=notificationsUseRingVolume;
      if (mNotificationsUseRingVolume == 1) {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_RING;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_RING]);
      }
 else {
        STREAM_VOLUME_ALIAS[AudioSystem.STREAM_NOTIFICATION]=AudioSystem.STREAM_NOTIFICATION;
        mStreamStates[AudioSystem.STREAM_NOTIFICATION].setVolumeIndexSettingName(System.VOLUME_SETTINGS[AudioSystem.STREAM_NOTIFICATION]);
        sendMsg(mAudioHandler,MSG_PERSIST_VOLUME,AudioSystem.STREAM_NOTIFICATION,SENDMSG_REPLACE,0,0,mStreamStates[AudioSystem.STREAM_NOTIFICATION],0);
      }
    }
  }
}"
23537,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}"
23538,"private void setScreenBrightnessMode(int mode){
  mAutoBrightessEnabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  mLightSensorBrightness=-1;
  if (mHasHardwareAutoBrightness) {
    mHardware.setAutoBrightness_UNCHECKED(mAutoBrightessEnabled);
    setBacklightBrightness((int)mScreenBrightness.curValue);
  }
 else {
    enableLightSensor(screenIsOn() && mAutoBrightessEnabled);
  }
}","private void setScreenBrightnessMode(int mode){
  boolean enabled=(mode == SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
  if (mAutoBrightessEnabled != enabled) {
    mAutoBrightessEnabled=enabled;
    mLightSensorBrightness=-1;
    if (mHasHardwareAutoBrightness) {
      mHardware.setAutoBrightness_UNCHECKED(enabled);
      if (screenIsOn()) {
        setBacklightBrightness((int)mScreenBrightness.curValue);
      }
    }
 else {
      enableLightSensor(screenIsOn() && enabled);
    }
  }
}"
23539,"public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mSuspending=false;
  mResuming=false;
}","public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mTargetA2dpState=-1;
}"
23540,"public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mResuming+ ""String_Node_Str""+ mSuspending);
  if (mResuming) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    if (mSuspending) {
      mResuming=true;
    }
  return true;
case BluetoothA2dp.STATE_CONNECTED:
mResuming=resumeSinkNative(path);
mAudioManager.setParameters(""String_Node_Str"");
return mResuming;
default :
return false;
}
}","public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_PLAYING;
  return checkSinkSuspendState(state.intValue());
}"
23541,"public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mSuspending+ ""String_Node_Str""+ mResuming);
  if (mSuspending) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    if (mResuming) {
      mSuspending=true;
    }
  return true;
case BluetoothA2dp.STATE_PLAYING:
mAudioManager.setParameters(""String_Node_Str"");
mSuspending=suspendSinkNative(path);
return mSuspending;
default :
return false;
}
}","public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_CONNECTED;
  return checkSinkSuspendState(state.intValue());
}"
23542,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state == BluetoothA2dp.STATE_DISCONNECTED) {
    mSuspending=false;
    mResuming=false;
  }
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    if (state == BluetoothA2dp.STATE_CONNECTED && prevState == BluetoothA2dp.STATE_PLAYING) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mSuspending) {
        mSuspending=false;
        if (mResuming) {
          mResuming=false;
          resumeSink(device);
        }
      }
    }
    if (state == BluetoothA2dp.STATE_PLAYING && prevState == BluetoothA2dp.STATE_CONNECTED) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mResuming) {
        mResuming=false;
        if (mSuspending) {
          mSuspending=false;
          suspendSink(device);
        }
      }
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
23543,"public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mSuspending=false;
  mResuming=false;
}","public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mTargetA2dpState=-1;
}"
23544,"public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mResuming+ ""String_Node_Str""+ mSuspending);
  if (mResuming) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    if (mSuspending) {
      mResuming=true;
    }
  return true;
case BluetoothA2dp.STATE_CONNECTED:
mResuming=resumeSinkNative(path);
mAudioManager.setParameters(""String_Node_Str"");
return mResuming;
default :
return false;
}
}","public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_PLAYING;
  return checkSinkSuspendState(state.intValue());
}"
23545,"public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mSuspending+ ""String_Node_Str""+ mResuming);
  if (mSuspending) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    if (mResuming) {
      mSuspending=true;
    }
  return true;
case BluetoothA2dp.STATE_PLAYING:
mAudioManager.setParameters(""String_Node_Str"");
mSuspending=suspendSinkNative(path);
return mSuspending;
default :
return false;
}
}","public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mTargetA2dpState);
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
  mTargetA2dpState=BluetoothA2dp.STATE_CONNECTED;
  return checkSinkSuspendState(state.intValue());
}"
23546,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state == BluetoothA2dp.STATE_DISCONNECTED) {
    mSuspending=false;
    mResuming=false;
  }
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    if (state == BluetoothA2dp.STATE_CONNECTED && prevState == BluetoothA2dp.STATE_PLAYING) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mSuspending) {
        mSuspending=false;
        if (mResuming) {
          mResuming=false;
          resumeSink(device);
        }
      }
    }
    if (state == BluetoothA2dp.STATE_PLAYING && prevState == BluetoothA2dp.STATE_CONNECTED) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mResuming) {
        mResuming=false;
        if (mSuspending) {
          mSuspending=false;
          suspendSink(device);
        }
      }
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    checkSinkSuspendState(state);
    mTargetA2dpState=-1;
    if (state == BluetoothA2dp.STATE_CONNECTING) {
      mAudioManager.setParameters(""String_Node_Str"");
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
23547,"@Override public void onReceive(Context context,Intent intent){
synchronized (mMethodMap) {
    buildInputMethodListLocked(mMethodList,mMethodMap);
    InputMethodInfo curIm=null;
    String curInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
    final int N=mMethodList.size();
    if (curInputMethodId != null) {
      for (int i=0; i < N; i++) {
        if (mMethodList.get(i).getId().equals(curInputMethodId)) {
          curIm=mMethodList.get(i);
        }
      }
    }
    boolean changed=false;
    Uri uri=intent.getData();
    String pkg=uri != null ? uri.getSchemeSpecificPart() : null;
    if (curIm != null && curIm.getPackageName().equals(pkg)) {
      ServiceInfo si=null;
      try {
        si=mContext.getPackageManager().getServiceInfo(curIm.getComponent(),0);
      }
 catch (      PackageManager.NameNotFoundException ex) {
      }
      if (si == null) {
        Log.i(TAG,""String_Node_Str"" + curInputMethodId);
        List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
        if (enabled != null && enabled.size() > 0) {
          changed=true;
          curIm=enabled.get(0);
          curInputMethodId=curIm.getId();
          Log.i(TAG,""String_Node_Str"" + curInputMethodId);
          Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
        }
 else         if (curIm != null) {
          changed=true;
          curIm=null;
          curInputMethodId=""String_Node_Str"";
          Log.i(TAG,""String_Node_Str"");
          Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
        }
      }
    }
 else     if (curIm == null) {
      List<InputMethodInfo> enabled=getEnabledInputMethodListLocked();
      if (enabled != null && enabled.size() > 0) {
        changed=true;
        curIm=enabled.get(0);
        curInputMethodId=curIm.getId();
        Log.i(TAG,""String_Node_Str"" + curInputMethodId);
        Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
      }
    }
    if (changed) {
      updateFromSettingsLocked();
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
synchronized (mMethodMap) {
    buildInputMethodListLocked(mMethodList,mMethodMap);
    InputMethodInfo curIm=null;
    String curInputMethodId=Settings.Secure.getString(context.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
    final int N=mMethodList.size();
    if (curInputMethodId != null) {
      for (int i=0; i < N; i++) {
        if (mMethodList.get(i).getId().equals(curInputMethodId)) {
          curIm=mMethodList.get(i);
        }
      }
    }
    boolean changed=false;
    Uri uri=intent.getData();
    String pkg=uri != null ? uri.getSchemeSpecificPart() : null;
    if (curIm != null && curIm.getPackageName().equals(pkg)) {
      ServiceInfo si=null;
      try {
        si=mContext.getPackageManager().getServiceInfo(curIm.getComponent(),0);
      }
 catch (      PackageManager.NameNotFoundException ex) {
      }
      if (si == null) {
        Log.i(TAG,""String_Node_Str"" + curInputMethodId);
        if (!chooseNewDefaultIME()) {
          changed=true;
          curIm=null;
          curInputMethodId=""String_Node_Str"";
          Log.i(TAG,""String_Node_Str"");
          Settings.Secure.putString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD,curInputMethodId);
        }
      }
    }
 else     if (curIm == null) {
      changed=chooseNewDefaultIME();
    }
    if (changed) {
      updateFromSettingsLocked();
    }
  }
}"
23548,"void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Log.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
}","void buildInputMethodListLocked(ArrayList<InputMethodInfo> list,HashMap<String,InputMethodInfo> map){
  list.clear();
  map.clear();
  PackageManager pm=mContext.getPackageManager();
  List<ResolveInfo> services=pm.queryIntentServices(new Intent(InputMethod.SERVICE_INTERFACE),PackageManager.GET_META_DATA);
  for (int i=0; i < services.size(); ++i) {
    ResolveInfo ri=services.get(i);
    ServiceInfo si=ri.serviceInfo;
    ComponentName compName=new ComponentName(si.packageName,si.name);
    if (!android.Manifest.permission.BIND_INPUT_METHOD.equals(si.permission)) {
      Log.w(TAG,""String_Node_Str"" + compName + ""String_Node_Str""+ android.Manifest.permission.BIND_INPUT_METHOD);
      continue;
    }
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + compName);
    try {
      InputMethodInfo p=new InputMethodInfo(mContext,ri);
      list.add(p);
      map.put(p.getId(),p);
      if (isSystemIme(p)) {
        setInputMethodEnabled(p.getId(),true);
      }
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"" + p);
      }
    }
 catch (    XmlPullParserException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
catch (    IOException e) {
      Log.w(TAG,""String_Node_Str"" + compName,e);
    }
  }
  String defaultIme=Settings.Secure.getString(mContext.getContentResolver(),Settings.Secure.DEFAULT_INPUT_METHOD);
  if (!map.containsKey(defaultIme)) {
    if (chooseNewDefaultIME()) {
      updateFromSettingsLocked();
    }
  }
}"
23549,"MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData;
  if (KeyInputQueue.BAD_TOUCH_HACK) {
    rawData=generateAveragedData(upOrDownPointer,lastNumPointers,nextNumPointers);
  }
 else {
    rawData=mLastData;
  }
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}","MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mSkipLastPointers) {
    mSkipLastPointers=false;
    mLastNumPointers=0;
  }
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData;
  if (KeyInputQueue.BAD_TOUCH_HACK) {
    rawData=generateAveragedData(upOrDownPointer,lastNumPointers,nextNumPointers);
  }
 else {
    rawData=mLastData;
  }
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}"
23550,"public void run(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Log.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          if (di.classes != 0) {
            mDevices.put(ev.deviceId,di);
            if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
              readVirtualKeys(di.name);
            }
            configChanged=true;
          }
 else {
            mIgnoredDevices.put(ev.deviceId,di);
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(di.id) + ""String_Node_Str""+ di.name);
          }
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          if (false) {
            Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          }
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else           if ((di=mIgnoredDevices.get(ev.deviceId)) != null) {
            mIgnoredDevices.remove(ev.deviceId);
          }
 else {
            Log.w(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
            continue;
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        if (di == null) {
          continue;
        }
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              if (BAD_TOUCH_HACK) {
                ms.dropBadPoint(di);
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && (ms.mLastNumPointers == 0 || ms.mSkipLastPointers)) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (DEBUG_POINTERS)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
 else {
                int num=ms.mNextNumPointers;
                if (num > InputDevice.MAX_POINTERS) {
                  num=InputDevice.MAX_POINTERS;
                }
                System.arraycopy(ms.mNextData,0,ms.mLastData,0,num * MotionEvent.NUM_SAMPLE_DATA);
                ms.mLastNumPointers=num;
                ms.mSkipLastPointers=true;
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}"
23551,"private void latch(){
  if ((mFlags & COLOR) != 0) {
    makeSpace(4);
    mVtxData[mVtxCount++]=mR;
    mVtxData[mVtxCount++]=mG;
    mVtxData[mVtxCount++]=mB;
    mVtxData[mVtxCount++]=mA;
  }
  if ((mFlags & NORMAL) != 0) {
    makeSpace(3);
    mVtxData[mVtxCount++]=mNX;
    mVtxData[mVtxCount++]=mNY;
    mVtxData[mVtxCount++]=mNZ;
  }
  if ((mFlags & TEXTURE_0) != 0) {
    makeSpace(2);
    mVtxData[mVtxCount++]=mS0;
    mVtxData[mVtxCount++]=mT0;
  }
}","private void latch(){
  if ((mFlags & COLOR) != 0) {
    makeSpace(4);
    mVtxData[mVtxCount++]=mR;
    mVtxData[mVtxCount++]=mG;
    mVtxData[mVtxCount++]=mB;
    mVtxData[mVtxCount++]=mA;
  }
  if ((mFlags & TEXTURE_0) != 0) {
    makeSpace(2);
    mVtxData[mVtxCount++]=mS0;
    mVtxData[mVtxCount++]=mT0;
  }
  if ((mFlags & NORMAL) != 0) {
    makeSpace(3);
    mVtxData[mVtxCount++]=mNX;
    mVtxData[mVtxCount++]=mNY;
    mVtxData[mVtxCount++]=mNZ;
  }
}"
23552,"void prepareTracking(int y){
  mTracking=true;
  mVelocityTracker=VelocityTracker.obtain();
  boolean opening=!mExpanded;
  if (!mExpanded) {
    mAnimAccel=2000.0f;
    mAnimVel=200;
    mAnimY=mStatusBarView.getHeight();
    updateExpandedViewPos((int)mAnimY);
    mAnimating=true;
    mAnimatingReveal=true;
    mHandler.removeMessages(MSG_ANIMATE);
    mHandler.removeMessages(MSG_ANIMATE_REVEAL);
    long now=SystemClock.uptimeMillis();
    mAnimLastTime=now;
    mCurAnimationTime=now + ANIM_FRAME_DURATION;
    mAnimating=true;
    mHandler.sendMessageAtTime(mHandler.obtainMessage(MSG_ANIMATE_REVEAL),mCurAnimationTime);
  }
 else {
    if (mAnimating) {
      mAnimating=false;
      mHandler.removeMessages(MSG_ANIMATE);
    }
  }
  if (opening) {
    makeExpandedVisible();
  }
 else {
    updateExpandedViewPos(y + mViewDelta);
  }
}","void prepareTracking(int y){
  mTracking=true;
  mVelocityTracker=VelocityTracker.obtain();
  boolean opening=!mExpanded;
  if (opening) {
    mAnimAccel=2000.0f;
    mAnimVel=200;
    mAnimY=mStatusBarView.getHeight();
    updateExpandedViewPos((int)mAnimY);
    mAnimating=true;
    mAnimatingReveal=true;
    mHandler.removeMessages(MSG_ANIMATE);
    mHandler.removeMessages(MSG_ANIMATE_REVEAL);
    long now=SystemClock.uptimeMillis();
    mAnimLastTime=now;
    mCurAnimationTime=now + ANIM_FRAME_DURATION;
    mAnimating=true;
    mHandler.sendMessageAtTime(mHandler.obtainMessage(MSG_ANIMATE_REVEAL),mCurAnimationTime);
    makeExpandedVisible();
  }
 else {
    if (mAnimating) {
      mAnimating=false;
      mHandler.removeMessages(MSG_ANIMATE);
    }
    updateExpandedViewPos(y + mViewDelta);
  }
}"
23553,"void animateCollapse(){
  if (SPEW)   Log.d(TAG,""String_Node_Str"" + mExpanded + ""String_Node_Str""+ mExpandedVisible);
  if (!mExpandedVisible) {
    return;
  }
  prepareTracking(mDisplay.getHeight() - 1);
  performFling(mDisplay.getHeight() - 1,-2000.0f,true);
}","void animateCollapse(){
  if (SPEW) {
    Log.d(TAG,""String_Node_Str"" + mExpanded + ""String_Node_Str""+ mExpandedVisible+ ""String_Node_Str""+ mAnimating+ ""String_Node_Str""+ mAnimVel);
  }
  if (!mExpandedVisible) {
    return;
  }
  if (mAnimating) {
    return;
  }
  int y=mDisplay.getHeight() - 1;
  prepareTracking(y);
  performFling(y,-2000.0f,true);
}"
23554,"@Override public boolean dispatchKeyEvent(KeyEvent event){
  boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_BACK:
    if (down) {
      StatusBarService.this.deactivate();
    }
  return true;
}
return super.dispatchKeyEvent(event);
}","@Override public boolean dispatchKeyEvent(KeyEvent event){
  boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
switch (event.getKeyCode()) {
case KeyEvent.KEYCODE_BACK:
    if (!down) {
      StatusBarService.this.deactivate();
    }
  return true;
}
return super.dispatchKeyEvent(event);
}"
23555,"/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}","/** 
 * Special hack for devices that have bad screen data: aggregate and compute averages of the coordinate data, to reduce the amount of jitter seen by applications.
 */
int[] generateAveragedData(int upOrDownPointer,int lastNumPointers,int nextNumPointers){
  final int numPointers=mLastNumPointers;
  final int[] rawData=mLastData;
  if (DEBUG_HACKS)   Log.v(""String_Node_Str"",""String_Node_Str"" + lastNumPointers + ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str""+ numPointers);
  for (int i=0; i < numPointers; i++) {
    final int ioff=i * MotionEvent.NUM_SAMPLE_DATA;
    final int p=mPointerIds[i];
    final int poff=p * MotionEvent.NUM_SAMPLE_DATA * HISTORY_SIZE;
    if (i == upOrDownPointer && lastNumPointers != nextNumPointers) {
      if (lastNumPointers < nextNumPointers) {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        if (DEBUG_HACKS)         Log.v(""String_Node_Str"",""String_Node_Str"" + upOrDownPointer + ""String_Node_Str""+ mPointerIds[i]);
      }
    }
 else {
      int end=mHistoryDataEnd[i];
      int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
      int oldX=mHistoryData[eoff + MotionEvent.SAMPLE_X];
      int oldY=mHistoryData[eoff + MotionEvent.SAMPLE_Y];
      int newX=rawData[ioff + MotionEvent.SAMPLE_X];
      int newY=rawData[ioff + MotionEvent.SAMPLE_Y];
      int dx=newX - oldX;
      int dy=newY - oldY;
      int delta=dx * dx + dy * dy;
      if (DEBUG_HACKS)       Log.v(""String_Node_Str"",""String_Node_Str"" + delta);
      if (delta >= (75 * 75)) {
        mHistoryDataStart[i]=0;
        mHistoryDataEnd[i]=0;
        System.arraycopy(rawData,ioff,mHistoryData,poff,MotionEvent.NUM_SAMPLE_DATA);
        System.arraycopy(rawData,ioff,mAveragedData,ioff,MotionEvent.NUM_SAMPLE_DATA);
        continue;
      }
 else {
        end++;
        if (end >= HISTORY_SIZE) {
          end-=HISTORY_SIZE;
        }
        mHistoryDataEnd[i]=end;
        int noff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
        mHistoryData[noff + MotionEvent.SAMPLE_X]=newX;
        mHistoryData[noff + MotionEvent.SAMPLE_Y]=newY;
        mHistoryData[noff + MotionEvent.SAMPLE_PRESSURE]=rawData[ioff + MotionEvent.SAMPLE_PRESSURE];
        int start=mHistoryDataStart[i];
        if (end == start) {
          start++;
          if (start >= HISTORY_SIZE) {
            start-=HISTORY_SIZE;
          }
          mHistoryDataStart[i]=start;
        }
      }
    }
    int start=mHistoryDataStart[i];
    int end=mHistoryDataEnd[i];
    int x=0, y=0;
    int totalPressure=0;
    while (start != end) {
      int soff=poff + (start * MotionEvent.NUM_SAMPLE_DATA);
      int pressure=mHistoryData[soff + MotionEvent.SAMPLE_PRESSURE];
      if (pressure <= 0)       pressure=1;
      x+=mHistoryData[soff + MotionEvent.SAMPLE_X] * pressure;
      y+=mHistoryData[soff + MotionEvent.SAMPLE_Y] * pressure;
      totalPressure+=pressure;
      start++;
      if (start >= HISTORY_SIZE)       start=0;
    }
    int eoff=poff + (end * MotionEvent.NUM_SAMPLE_DATA);
    int pressure=mHistoryData[eoff + MotionEvent.SAMPLE_PRESSURE];
    if (pressure <= 0)     pressure=1;
    x+=mHistoryData[eoff + MotionEvent.SAMPLE_X] * pressure;
    y+=mHistoryData[eoff + MotionEvent.SAMPLE_Y] * pressure;
    totalPressure+=pressure;
    x/=totalPressure;
    y/=totalPressure;
    if (DEBUG_HACKS)     Log.v(""String_Node_Str"",""String_Node_Str"" + totalPressure + ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str"");
    mAveragedData[ioff + MotionEvent.SAMPLE_X]=x;
    mAveragedData[ioff + MotionEvent.SAMPLE_Y]=y;
  }
  return mAveragedData;
}"
23556,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}"
23557,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}"
23558,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}"
23559,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}"
23560,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
23561,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}"
23562,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,height);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}"
23563,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,height);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int widthMode=MeasureSpec.getMode(widthMeasureSpec);
  int heightMode=MeasureSpec.getMode(heightMeasureSpec);
  int widthSize=MeasureSpec.getSize(widthMeasureSpec);
  int heightSize=MeasureSpec.getSize(heightMeasureSpec);
  int width;
  int height;
  BoringLayout.Metrics boring=UNKNOWN_BORING;
  BoringLayout.Metrics hintBoring=UNKNOWN_BORING;
  int des=-1;
  boolean fromexisting=false;
  if (widthMode == MeasureSpec.EXACTLY) {
    width=widthSize;
  }
 else {
    if (mLayout != null && mEllipsize == null) {
      des=desired(mLayout);
    }
    if (des < 0) {
      boring=BoringLayout.isBoring(mTransformed,mTextPaint,mBoring);
      if (boring != null) {
        mBoring=boring;
      }
    }
 else {
      fromexisting=true;
    }
    if (boring == null || boring == UNKNOWN_BORING) {
      if (des < 0) {
        des=(int)FloatMath.ceil(Layout.getDesiredWidth(mTransformed,mTextPaint));
      }
      width=des;
    }
 else {
      width=boring.width;
    }
    final Drawables dr=mDrawables;
    if (dr != null) {
      width=Math.max(width,dr.mDrawableWidthTop);
      width=Math.max(width,dr.mDrawableWidthBottom);
    }
    if (mHint != null) {
      int hintDes=-1;
      int hintWidth;
      if (mHintLayout != null && mEllipsize == null) {
        hintDes=desired(mHintLayout);
      }
      if (hintDes < 0) {
        hintBoring=BoringLayout.isBoring(mHint,mTextPaint,mHintBoring);
        if (hintBoring != null) {
          mHintBoring=hintBoring;
        }
      }
      if (hintBoring == null || hintBoring == UNKNOWN_BORING) {
        if (hintDes < 0) {
          hintDes=(int)FloatMath.ceil(Layout.getDesiredWidth(mHint,mTextPaint));
        }
        hintWidth=hintDes;
      }
 else {
        hintWidth=hintBoring.width;
      }
      if (hintWidth > width) {
        width=hintWidth;
      }
    }
    width+=getCompoundPaddingLeft() + getCompoundPaddingRight();
    if (mMaxWidthMode == EMS) {
      width=Math.min(width,mMaxWidth * getLineHeight());
    }
 else {
      width=Math.min(width,mMaxWidth);
    }
    if (mMinWidthMode == EMS) {
      width=Math.max(width,mMinWidth * getLineHeight());
    }
 else {
      width=Math.max(width,mMinWidth);
    }
    width=Math.max(width,getSuggestedMinimumWidth());
    if (widthMode == MeasureSpec.AT_MOST) {
      width=Math.min(widthSize,width);
    }
  }
  int want=width - getCompoundPaddingLeft() - getCompoundPaddingRight();
  int unpaddedWidth=want;
  int hintWant=want;
  if (mHorizontallyScrolling)   want=VERY_WIDE;
  int hintWidth=mHintLayout == null ? hintWant : mHintLayout.getWidth();
  if (mLayout == null) {
    makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
  }
 else   if ((mLayout.getWidth() != want) || (hintWidth != hintWant) || (mLayout.getEllipsizedWidth() != width - getCompoundPaddingLeft() - getCompoundPaddingRight())) {
    if (mHint == null && mEllipsize == null && want > mLayout.getWidth() && (mLayout instanceof BoringLayout || (fromexisting && des >= 0 && des <= want))) {
      mLayout.increaseWidthTo(want);
    }
 else {
      makeNewLayout(want,hintWant,boring,hintBoring,width - getCompoundPaddingLeft() - getCompoundPaddingRight(),false);
    }
  }
 else {
  }
  if (heightMode == MeasureSpec.EXACTLY) {
    height=heightSize;
    mDesiredHeightAtMeasure=-1;
  }
 else {
    int desired=getDesiredHeight();
    height=desired;
    mDesiredHeightAtMeasure=desired;
    if (heightMode == MeasureSpec.AT_MOST) {
      height=Math.min(desired,heightSize);
    }
  }
  int unpaddedHeight=height - getCompoundPaddingTop() - getCompoundPaddingBottom();
  if (mMaxMode == LINES && mLayout.getLineCount() > mMaximum) {
    unpaddedHeight=Math.min(unpaddedHeight,mLayout.getLineTop(mMaximum));
  }
  if (mMovement != null || mLayout.getWidth() > unpaddedWidth || mLayout.getHeight() > unpaddedHeight) {
    registerForPreDraw();
  }
 else {
    scrollTo(0,0);
  }
  setMeasuredDimension(width,height);
}"
23564,"void setTargetLocked(int target,int stepsToTarget,int initialValue,int nominalCurrentValue){
  if (!initialized) {
    initialized=true;
    curValue=(float)initialValue;
  }
  targetValue=target;
  delta=(targetValue - (nominalCurrentValue >= 0 ? nominalCurrentValue : curValue)) / stepsToTarget;
  if (mSpew) {
    String noticeMe=nominalCurrentValue == curValue ? ""String_Node_Str"" : ""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"" + mask + ""String_Node_Str""+ curValue+ ""String_Node_Str""+ targetValue+ ""String_Node_Str""+ delta+ ""String_Node_Str""+ nominalCurrentValue+ noticeMe);
  }
  animating=true;
}","boolean setTargetLocked(int target,int stepsToTarget,int initialValue,int nominalCurrentValue){
  if (!initialized) {
    initialized=true;
    curValue=(float)initialValue;
  }
 else   if (targetValue == target) {
    return false;
  }
  targetValue=target;
  delta=(targetValue - (nominalCurrentValue >= 0 ? nominalCurrentValue : curValue)) / stepsToTarget;
  if (mSpew) {
    String noticeMe=nominalCurrentValue == curValue ? ""String_Node_Str"" : ""String_Node_Str"";
    Log.i(TAG,""String_Node_Str"" + mask + ""String_Node_Str""+ curValue+ ""String_Node_Str""+ targetValue+ ""String_Node_Str""+ delta+ ""String_Node_Str""+ nominalCurrentValue+ noticeMe);
  }
  animating=true;
  return true;
}"
23565,"private void updateLightsLocked(int newState,int forceState){
  final int oldState=mPowerState;
  final int realDifference=(newState ^ oldState);
  final int difference=realDifference | forceState;
  if (difference == 0) {
    return;
  }
  int offMask=0;
  int dimMask=0;
  int onMask=0;
  int preferredBrightness=getPreferredBrightness();
  boolean startAnimation=false;
  if ((difference & KEYBOARD_BRIGHT_BIT) != 0) {
    if (ANIMATE_KEYBOARD_LIGHTS) {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        mKeyboardBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,preferredBrightness);
      }
 else {
        mKeyboardBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        offMask|=KEYBOARD_BRIGHT_BIT;
      }
 else {
        onMask|=KEYBOARD_BRIGHT_BIT;
      }
    }
  }
  if ((difference & BUTTON_BRIGHT_BIT) != 0) {
    if (ANIMATE_BUTTON_LIGHTS) {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        mButtonBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,preferredBrightness);
      }
 else {
        mButtonBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        offMask|=BUTTON_BRIGHT_BIT;
      }
 else {
        onMask|=BUTTON_BRIGHT_BIT;
      }
    }
  }
  if ((difference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
    if (ANIMATE_SCREEN_LIGHTS) {
      int nominalCurrentValue=-1;
      if ((realDifference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
switch (oldState & (SCREEN_BRIGHT_BIT | SCREEN_ON_BIT)) {
case SCREEN_BRIGHT_BIT | SCREEN_ON_BIT:
          nominalCurrentValue=preferredBrightness;
        break;
case SCREEN_ON_BIT:
      nominalCurrentValue=Power.BRIGHTNESS_DIM;
    break;
case 0:
  nominalCurrentValue=Power.BRIGHTNESS_OFF;
break;
case SCREEN_BRIGHT_BIT:
default :
nominalCurrentValue=(int)mScreenBrightness.curValue;
break;
}
}
int brightness=preferredBrightness;
int steps=ANIM_STEPS;
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
final float scale=1.5f;
float ratio=(((float)Power.BRIGHTNESS_DIM) / preferredBrightness);
if (ratio > 1.0f) ratio=1.0f;
if ((newState & SCREEN_ON_BIT) == 0) {
if ((oldState & SCREEN_BRIGHT_BIT) != 0) {
steps=ANIM_STEPS;
}
 else {
steps=(int)(ANIM_STEPS * ratio * scale);
}
brightness=Power.BRIGHTNESS_OFF;
}
 else {
if ((oldState & SCREEN_ON_BIT) != 0) {
steps=(int)(ANIM_STEPS * (1.0f - ratio) * scale);
}
 else {
steps=(int)(ANIM_STEPS * ratio);
}
if (mStayOnConditions != 0 && mBatteryService.isPowered(mStayOnConditions)) {
mScreenOffTime=SystemClock.elapsedRealtime();
}
brightness=Power.BRIGHTNESS_DIM;
}
}
long identity=Binder.clearCallingIdentity();
try {
mBatteryStats.noteScreenBrightness(brightness);
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(identity);
}
mScreenBrightness.setTargetLocked(brightness,steps,INITIAL_SCREEN_BRIGHTNESS,nominalCurrentValue);
startAnimation=true;
}
 else {
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
if ((newState & SCREEN_ON_BIT) == 0) {
offMask|=SCREEN_BRIGHT_BIT;
}
 else {
dimMask|=SCREEN_BRIGHT_BIT;
}
}
 else {
onMask|=SCREEN_BRIGHT_BIT;
}
}
}
if (startAnimation) {
if (mSpew) {
Log.i(TAG,""String_Node_Str"");
}
mHandler.removeCallbacks(mLightAnimator);
mHandler.post(mLightAnimator);
}
if (offMask != 0) {
setLightBrightness(offMask,Power.BRIGHTNESS_OFF);
}
if (dimMask != 0) {
int brightness=Power.BRIGHTNESS_DIM;
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(dimMask,brightness);
}
if (onMask != 0) {
int brightness=getPreferredBrightness();
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(onMask,brightness);
}
}","private void updateLightsLocked(int newState,int forceState){
  final int oldState=mPowerState;
  final int realDifference=(newState ^ oldState);
  final int difference=realDifference | forceState;
  if (difference == 0) {
    return;
  }
  int offMask=0;
  int dimMask=0;
  int onMask=0;
  int preferredBrightness=getPreferredBrightness();
  boolean startAnimation=false;
  if ((difference & KEYBOARD_BRIGHT_BIT) != 0) {
    if (ANIMATE_KEYBOARD_LIGHTS) {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        mKeyboardBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,preferredBrightness);
      }
 else {
        mKeyboardBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_KEYBOARD_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & KEYBOARD_BRIGHT_BIT) == 0) {
        offMask|=KEYBOARD_BRIGHT_BIT;
      }
 else {
        onMask|=KEYBOARD_BRIGHT_BIT;
      }
    }
  }
  if ((difference & BUTTON_BRIGHT_BIT) != 0) {
    if (ANIMATE_BUTTON_LIGHTS) {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        mButtonBrightness.setTargetLocked(Power.BRIGHTNESS_OFF,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,preferredBrightness);
      }
 else {
        mButtonBrightness.setTargetLocked(preferredBrightness,ANIM_STEPS,INITIAL_BUTTON_BRIGHTNESS,Power.BRIGHTNESS_OFF);
      }
      startAnimation=true;
    }
 else {
      if ((newState & BUTTON_BRIGHT_BIT) == 0) {
        offMask|=BUTTON_BRIGHT_BIT;
      }
 else {
        onMask|=BUTTON_BRIGHT_BIT;
      }
    }
  }
  if ((difference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
    if (ANIMATE_SCREEN_LIGHTS) {
      int nominalCurrentValue=-1;
      if ((realDifference & (SCREEN_ON_BIT | SCREEN_BRIGHT_BIT)) != 0) {
switch (oldState & (SCREEN_BRIGHT_BIT | SCREEN_ON_BIT)) {
case SCREEN_BRIGHT_BIT | SCREEN_ON_BIT:
          nominalCurrentValue=preferredBrightness;
        break;
case SCREEN_ON_BIT:
      nominalCurrentValue=Power.BRIGHTNESS_DIM;
    break;
case 0:
  nominalCurrentValue=Power.BRIGHTNESS_OFF;
break;
case SCREEN_BRIGHT_BIT:
default :
nominalCurrentValue=(int)mScreenBrightness.curValue;
break;
}
}
int brightness=preferredBrightness;
int steps=ANIM_STEPS;
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
final float scale=1.5f;
float ratio=(((float)Power.BRIGHTNESS_DIM) / preferredBrightness);
if (ratio > 1.0f) ratio=1.0f;
if ((newState & SCREEN_ON_BIT) == 0) {
if ((oldState & SCREEN_BRIGHT_BIT) != 0) {
steps=ANIM_STEPS;
}
 else {
steps=(int)(ANIM_STEPS * ratio * scale);
}
brightness=Power.BRIGHTNESS_OFF;
}
 else {
if ((oldState & SCREEN_ON_BIT) != 0) {
steps=(int)(ANIM_STEPS * (1.0f - ratio) * scale);
}
 else {
steps=(int)(ANIM_STEPS * ratio);
}
if (mStayOnConditions != 0 && mBatteryService.isPowered(mStayOnConditions)) {
mScreenOffTime=SystemClock.elapsedRealtime();
}
brightness=Power.BRIGHTNESS_DIM;
}
}
long identity=Binder.clearCallingIdentity();
try {
mBatteryStats.noteScreenBrightness(brightness);
}
 catch (RemoteException e) {
}
 finally {
Binder.restoreCallingIdentity(identity);
}
if (mScreenBrightness.setTargetLocked(brightness,steps,INITIAL_SCREEN_BRIGHTNESS,nominalCurrentValue)) {
startAnimation=true;
}
}
 else {
if ((newState & SCREEN_BRIGHT_BIT) == 0) {
if ((newState & SCREEN_ON_BIT) == 0) {
offMask|=SCREEN_BRIGHT_BIT;
}
 else {
dimMask|=SCREEN_BRIGHT_BIT;
}
}
 else {
onMask|=SCREEN_BRIGHT_BIT;
}
}
}
if (startAnimation) {
if (mSpew) {
Log.i(TAG,""String_Node_Str"");
}
mHandler.removeCallbacks(mLightAnimator);
mHandler.post(mLightAnimator);
}
if (offMask != 0) {
setLightBrightness(offMask,Power.BRIGHTNESS_OFF);
}
if (dimMask != 0) {
int brightness=Power.BRIGHTNESS_DIM;
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(dimMask,brightness);
}
if (onMask != 0) {
int brightness=getPreferredBrightness();
if ((newState & BATTERY_LOW_BIT) != 0 && brightness > Power.BRIGHTNESS_LOW_BATTERY) {
brightness=Power.BRIGHTNESS_LOW_BATTERY;
}
setLightBrightness(onMask,brightness);
}
}"
23566,"private final boolean bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean whileRestarting){
  if (r.app != null) {
    sendServiceArgsLocked(r,false);
    return true;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return true;
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  mRestartingServices.remove(r);
  final String appName=r.processName;
  ProcessRecord app=getProcessRecordLocked(appName,r.appInfo.uid);
  if (app != null && app.thread != null) {
    try {
      realStartServiceLocked(r,app);
      return true;
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + r.shortName,e);
    }
  }
  if (!mPendingServices.contains(r)) {
    if (startProcessLocked(appName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false) == null) {
      Log.w(TAG,""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"");
      bringDownServiceLocked(r,true);
      return false;
    }
    mPendingServices.add(r);
  }
  return true;
}","private final boolean bringUpServiceLocked(ServiceRecord r,int intentFlags,boolean whileRestarting){
  if (r.app != null && r.app.thread != null) {
    sendServiceArgsLocked(r,false);
    return true;
  }
  if (!whileRestarting && r.restartDelay > 0) {
    return true;
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  mRestartingServices.remove(r);
  final String appName=r.processName;
  ProcessRecord app=getProcessRecordLocked(appName,r.appInfo.uid);
  if (app != null && app.thread != null) {
    try {
      realStartServiceLocked(r,app);
      return true;
    }
 catch (    RemoteException e) {
      Log.w(TAG,""String_Node_Str"" + r.shortName,e);
    }
  }
  if (startProcessLocked(appName,r.appInfo,true,intentFlags,""String_Node_Str"",r.name,false) == null) {
    Log.w(TAG,""String_Node_Str"" + r.appInfo.packageName + ""String_Node_Str""+ r.appInfo.uid+ ""String_Node_Str""+ r.intent.getIntent()+ ""String_Node_Str"");
    bringDownServiceLocked(r,true);
    return false;
  }
  if (!mPendingServices.contains(r)) {
    mPendingServices.add(r);
  }
  return true;
}"
23567,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  mProcessesToGc.remove(app);
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}"
23568,"private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}","private final void appDiedLocked(ProcessRecord app,int pid,IApplicationThread thread){
  mProcDeaths[0]++;
  if (app.thread != null && app.thread.asBinder() == thread.asBinder()) {
    Log.i(TAG,""String_Node_Str"" + app.processName + ""String_Node_Str""+ pid+ ""String_Node_Str"");
    EventLog.writeEvent(LOG_AM_PROCESS_DIED,app.pid,app.processName);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + app + ""String_Node_Str""+ pid+ ""String_Node_Str""+ thread.asBinder());
    boolean doLowMem=app.instrumentationClass == null;
    handleAppDiedLocked(app,false);
    if (doLowMem) {
      boolean haveBg=false;
      int count=mLRUProcesses.size();
      int i;
      for (i=0; i < count; i++) {
        ProcessRecord rec=mLRUProcesses.get(i);
        if (rec.thread != null && rec.setAdj >= HIDDEN_APP_MIN_ADJ) {
          haveBg=true;
          break;
        }
      }
      if (!haveBg) {
        Log.i(TAG,""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_LOW_MEMORY,mLRUProcesses.size());
        long now=SystemClock.uptimeMillis();
        for (i=0; i < count; i++) {
          ProcessRecord rec=mLRUProcesses.get(i);
          if (rec != app && rec.thread != null && (rec.lastLowMemory + GC_MIN_INTERVAL) <= now) {
            if (rec.setAdj <= VISIBLE_APP_ADJ) {
              rec.lastRequestedGc=0;
            }
 else {
              rec.lastRequestedGc=rec.lastLowMemory;
            }
            rec.reportLowMemory=true;
            rec.lastLowMemory=now;
            mProcessesToGc.remove(rec);
            addProcessToGcListLocked(rec);
          }
        }
        scheduleAppGcsLocked();
      }
    }
  }
 else   if (Config.LOGD) {
    Log.d(TAG,""String_Node_Str"" + thread.asBinder());
  }
}"
23569,"public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
}","public BluetoothA2dpService(Context context,BluetoothService bluetoothService){
  mContext=context;
  mAudioManager=(AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
  mBluetoothService=bluetoothService;
  if (mBluetoothService == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (!initNative()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  mAdapter=BluetoothAdapter.getDefaultAdapter();
  mIntentFilter=new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
  mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
  mContext.registerReceiver(mReceiver,mIntentFilter);
  mAudioDevices=new HashMap<BluetoothDevice,Integer>();
  if (mBluetoothService.isEnabled())   onBluetoothEnable();
  mSuspending=false;
  mResuming=false;
}"
23570,"public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str"");
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    return true;
case BluetoothA2dp.STATE_CONNECTED:
  return resumeSinkNative(path);
default :
return false;
}
}","public synchronized boolean resumeSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mResuming+ ""String_Node_Str""+ mSuspending);
  if (mResuming) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_PLAYING:
    if (mSuspending) {
      mResuming=true;
    }
  return true;
case BluetoothA2dp.STATE_CONNECTED:
mResuming=resumeSinkNative(path);
mAudioManager.setParameters(""String_Node_Str"");
return mResuming;
default :
return false;
}
}"
23571,"private synchronized void onBluetoothEnable(){
  String devices=mBluetoothService.getProperty(""String_Node_Str"");
  mSinkCount=0;
  if (devices != null) {
    String[] paths=devices.split(""String_Node_Str"");
    for (    String path : paths) {
      String address=mBluetoothService.getAddressFromObjectPath(path);
      BluetoothDevice device=mAdapter.getRemoteDevice(address);
      ParcelUuid[] remoteUuids=mBluetoothService.getRemoteUuids(address);
      if (remoteUuids != null)       if (BluetoothUuid.containsAnyUuid(remoteUuids,new ParcelUuid[]{BluetoothUuid.AudioSink,BluetoothUuid.AdvAudioDist})) {
        addAudioSink(device);
      }
    }
  }
  mAudioManager.setParameters(BLUETOOTH_ENABLED + ""String_Node_Str"");
}","private synchronized void onBluetoothEnable(){
  String devices=mBluetoothService.getProperty(""String_Node_Str"");
  mSinkCount=0;
  if (devices != null) {
    String[] paths=devices.split(""String_Node_Str"");
    for (    String path : paths) {
      String address=mBluetoothService.getAddressFromObjectPath(path);
      BluetoothDevice device=mAdapter.getRemoteDevice(address);
      ParcelUuid[] remoteUuids=mBluetoothService.getRemoteUuids(address);
      if (remoteUuids != null)       if (BluetoothUuid.containsAnyUuid(remoteUuids,new ParcelUuid[]{BluetoothUuid.AudioSink,BluetoothUuid.AdvAudioDist})) {
        addAudioSink(device);
      }
    }
  }
  mAudioManager.setParameters(BLUETOOTH_ENABLED + ""String_Node_Str"");
  mAudioManager.setParameters(""String_Node_Str"");
}"
23572,"public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str"");
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    return true;
case BluetoothA2dp.STATE_PLAYING:
  return suspendSinkNative(path);
default :
return false;
}
}","public synchronized boolean suspendSink(BluetoothDevice device){
  mContext.enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,""String_Node_Str"");
  if (DBG)   log(""String_Node_Str"" + device + ""String_Node_Str""+ mSuspending+ ""String_Node_Str""+ mResuming);
  if (mSuspending) {
    return true;
  }
  if (device == null || mAudioDevices == null) {
    return false;
  }
  String path=mBluetoothService.getObjectPathFromAddress(device.getAddress());
  Integer state=mAudioDevices.get(device);
  if (path == null || state == null) {
    return false;
  }
switch (state.intValue()) {
case BluetoothA2dp.STATE_CONNECTED:
    if (mResuming) {
      mSuspending=true;
    }
  return true;
case BluetoothA2dp.STATE_PLAYING:
mAudioManager.setParameters(""String_Node_Str"");
mSuspending=suspendSinkNative(path);
return mSuspending;
default :
return false;
}
}"
23573,"private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}","private void handleSinkStateChange(BluetoothDevice device,int prevState,int state){
  if (state == BluetoothA2dp.STATE_DISCONNECTED) {
    mSuspending=false;
    mResuming=false;
  }
  if (state != prevState) {
    if (state == BluetoothA2dp.STATE_DISCONNECTED || state == BluetoothA2dp.STATE_DISCONNECTING) {
      if (prevState == BluetoothA2dp.STATE_CONNECTED || prevState == BluetoothA2dp.STATE_PLAYING) {
        Intent intent=new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
        mContext.sendBroadcast(intent);
      }
      mSinkCount--;
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      mSinkCount++;
    }
    mAudioDevices.put(device,state);
    if (state == BluetoothA2dp.STATE_CONNECTED && prevState == BluetoothA2dp.STATE_PLAYING) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mSuspending) {
        mSuspending=false;
        if (mResuming) {
          mResuming=false;
          resumeSink(device);
        }
      }
    }
    if (state == BluetoothA2dp.STATE_PLAYING && prevState == BluetoothA2dp.STATE_CONNECTED) {
      if (DBG)       log(""String_Node_Str"" + mSuspending + ""String_Node_Str""+ mResuming);
      if (mResuming) {
        mResuming=false;
        if (mSuspending) {
          mSuspending=false;
          suspendSink(device);
        }
      }
    }
    Intent intent=new Intent(BluetoothA2dp.ACTION_SINK_STATE_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_DEVICE,device);
    intent.putExtra(BluetoothA2dp.EXTRA_PREVIOUS_SINK_STATE,prevState);
    intent.putExtra(BluetoothA2dp.EXTRA_SINK_STATE,state);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    if (DBG)     log(""String_Node_Str"" + device + ""String_Node_Str""+ prevState+ ""String_Node_Str""+ state);
  }
}"
23574,"public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      mNetworkInfo.setIsAvailable(!unavailable);
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (state == Phone.DataState.CONNECTED) {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + mInterfaceName + ""String_Node_Str""+ intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY)+ ""String_Node_Str""+ mApnType);
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
          return;
        }
      }
 else {
        return;
      }
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + state+ ""String_Node_Str""+ mMobileDataState+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason)+ ""String_Node_Str""+ apnTypeList);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    break;
case CONNECTING:
  setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}","public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      mApnName=apnName;
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      mNetworkInfo.setIsAvailable(!unavailable);
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (state == Phone.DataState.CONNECTED) {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + mInterfaceName + ""String_Node_Str""+ intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY)+ ""String_Node_Str""+ mApnType);
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
          return;
        }
      }
 else {
        return;
      }
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + state+ ""String_Node_Str""+ mMobileDataState+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason)+ ""String_Node_Str""+ apnTypeList);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    break;
case CONNECTING:
  setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}"
23575,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
setDetailedState(DetailedState.CONNECTING,Phone.REASON_APN_CHANGED,null);
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_APN_KEY,mApnName);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}"
23576,"private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}","private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}"
23577,"/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}","/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}"
23578,"private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mCheckingDialog;
}","private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mCheckingDialog;
}"
23579,"/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.setOnDismissListener(this);
  return dialog;
}","/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.setOnDismissListener(this);
  return dialog;
}"
23580,"private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}"
23581,"private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}"
23582,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!getContext().getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}"
23583,"private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mSimUnlockProgressDialog;
}","private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mSimUnlockProgressDialog;
}"
23584,"private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}","private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}"
23585,"/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}","/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}"
23586,"private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}","private static void beginShutdownSequence(Context context){
synchronized (sIsStartedGuard) {
    sIsStarted=true;
  }
  ProgressDialog pd=new ProgressDialog(context);
  pd.setTitle(context.getText(com.android.internal.R.string.power_off));
  pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
  pd.setIndeterminate(true);
  pd.setCancelable(false);
  pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    pd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  pd.show();
  sInstance.mContext=context;
  sInstance.mHandler=new Handler(){
  }
;
  sInstance.start();
}"
23587,"/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}","/** 
 * Request a clean shutdown, waiting for subsystems to clean up their state etc.  Must be called from a Looper thread in which its UI is shown.
 * @param context Context used to display the shutdown progress dialog.
 */
public static void shutdown(final Context context,boolean confirm){
synchronized (sIsStartedGuard) {
    if (sIsStarted) {
      Log.d(TAG,""String_Node_Str"");
      return;
    }
  }
  Log.d(TAG,""String_Node_Str"");
  if (confirm) {
    final AlertDialog dialog=new AlertDialog.Builder(context).setIcon(android.R.drawable.ic_dialog_alert).setTitle(com.android.internal.R.string.power_off).setMessage(com.android.internal.R.string.shutdown_confirm).setPositiveButton(com.android.internal.R.string.yes,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int which){
        beginShutdownSequence(context);
      }
    }
).setNegativeButton(com.android.internal.R.string.no,null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!context.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      dialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
    dialog.show();
  }
 else {
    beginShutdownSequence(context);
  }
}"
23588,"void updatePlugged(){
  Intent powerIntent=mContext.registerReceiver(null,mBatteryStatusFilter);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}","void updatePlugged(Intent powerIntent){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}"
23589,"/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_POWER_CONNECTED);
  intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  context.registerReceiver(mPowerReceiver,intentFilter);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged();
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}","/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged(context.registerReceiver(null,mBatteryStatusFilter));
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}"
23590,"public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateKeepScreenOn();
  updateOrientationListenerLp();
}","public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  boolean watchBattery=mDockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;
  if (watchBattery != mRegisteredBatteryReceiver) {
    mRegisteredBatteryReceiver=watchBattery;
    if (watchBattery) {
      updatePlugged(mContext.registerReceiver(mBatteryReceiver,mBatteryStatusFilter));
    }
 else {
      mContext.unregisterReceiver(mBatteryReceiver);
    }
  }
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateDockKeepingScreenOn();
  updateOrientationListenerLp();
}"
23591,"private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mCheckingDialog;
}","private Dialog getProgressDialog(){
  if (mCheckingDialog == null) {
    mCheckingDialog=new ProgressDialog(mContext);
    mCheckingDialog.setMessage(mContext.getString(R.string.lockscreen_glogin_checking_password));
    mCheckingDialog.setIndeterminate(true);
    mCheckingDialog.setCancelable(false);
    mCheckingDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mCheckingDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mCheckingDialog;
}"
23592,"/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.setOnDismissListener(this);
  return dialog;
}","/** 
 * Create the global actions dialog.
 * @return A new dialog.
 */
private AlertDialog createDialog(){
  mSilentModeToggle=new ToggleAction(R.drawable.ic_lock_silent_mode,R.drawable.ic_lock_silent_mode_off,R.string.global_action_toggle_silent_mode,R.string.global_action_silent_mode_on_status,R.string.global_action_silent_mode_off_status){
    void onToggle(    boolean on){
      mAudioManager.setRingerMode(on ? AudioManager.RINGER_MODE_SILENT : AudioManager.RINGER_MODE_NORMAL);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mAirplaneModeOn=new ToggleAction(R.drawable.ic_lock_airplane_mode,R.drawable.ic_lock_airplane_mode_off,R.string.global_actions_toggle_airplane_mode,R.string.global_actions_airplane_mode_on_status,R.string.global_actions_airplane_mode_off_status){
    void onToggle(    boolean on){
      if (Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) {
        mIsWaitingForEcmExit=true;
        Intent ecmDialogIntent=new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS,null);
        ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(ecmDialogIntent);
      }
 else {
        changeAirplaneModeSystemSetting(on);
      }
    }
    @Override protected void changeStateFromPress(    boolean buttonOn){
      if (!(Boolean.parseBoolean(SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) {
        mState=buttonOn ? State.TurningOn : State.TurningOff;
        mAirplaneState=mState;
      }
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return false;
    }
  }
;
  mItems=Lists.newArrayList(mSilentModeToggle,mAirplaneModeOn,new SinglePressAction(com.android.internal.R.drawable.ic_lock_power_off,R.string.global_action_power_off){
    public void onPress(){
      ShutdownThread.shutdown(mContext,true);
    }
    public boolean showDuringKeyguard(){
      return true;
    }
    public boolean showBeforeProvisioning(){
      return true;
    }
  }
);
  mAdapter=new MyAdapter();
  final AlertDialog.Builder ab=new AlertDialog.Builder(mContext);
  ab.setAdapter(mAdapter,this).setInverseBackgroundForced(true).setTitle(R.string.global_actions);
  final AlertDialog dialog=ab.create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.setOnDismissListener(this);
  return dialog;
}"
23593,"private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showAlmostAtAccountLoginDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_failed_attempts_almost_glogin,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT,timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}"
23594,"private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  dialog.show();
}","private void showTimeoutDialog(){
  int timeoutInSeconds=(int)LockPatternUtils.FAILED_ATTEMPT_TIMEOUT_MS / 1000;
  String message=mContext.getString(R.string.lockscreen_too_many_failed_attempts_dialog_message,mUpdateMonitor.getFailedAttempts(),timeoutInSeconds);
  final AlertDialog dialog=new AlertDialog.Builder(mContext).setTitle(null).setMessage(message).setNeutralButton(R.string.ok,null).create();
  dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
  if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    dialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  dialog.show();
}"
23595,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  Context context=getContext();
  if (sStatusBar == null) {
    sStatusBar=(StatusBarManager)context.getSystemService(Context.STATUS_BAR_SERVICE);
  }
  setContentView(com.android.internal.R.layout.power_dialog);
  getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG);
  if (!getContext().getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
  setTitle(context.getText(R.string.power_dialog));
  mKeyguard=(Button)findViewById(R.id.keyguard);
  mPower=(Button)findViewById(R.id.off);
  mRadioPower=(Button)findViewById(R.id.radio_power);
  mSilent=(Button)findViewById(R.id.silent);
  if (mKeyguard != null) {
    mKeyguard.setOnKeyListener(this);
    mKeyguard.setOnClickListener(this);
  }
  if (mPower != null) {
    mPower.setOnClickListener(this);
  }
  if (mRadioPower != null) {
    mRadioPower.setOnClickListener(this);
  }
  if (mSilent != null) {
    mSilent.setOnClickListener(this);
    mSilent.setVisibility(View.GONE);
  }
  CharSequence text;
  text=context.getText(R.string.screen_lock);
  mKeyguard.setText(text);
  mKeyguard.requestFocus();
  try {
    ITelephony phone=ITelephony.Stub.asInterface(ServiceManager.checkService(""String_Node_Str""));
    if (phone != null) {
      text=phone.isRadioOn() ? context.getText(R.string.turn_off_radio) : context.getText(R.string.turn_on_radio);
    }
  }
 catch (  RemoteException ex) {
  }
  mRadioPower.setText(text);
}"
23596,"private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
  }
  return mSimUnlockProgressDialog;
}","private Dialog getSimUnlockProgressDialog(){
  if (mSimUnlockProgressDialog == null) {
    mSimUnlockProgressDialog=new ProgressDialog(mContext);
    mSimUnlockProgressDialog.setMessage(mContext.getString(R.string.lockscreen_sim_unlock_progress_dialog_message));
    mSimUnlockProgressDialog.setIndeterminate(true);
    mSimUnlockProgressDialog.setCancelable(false);
    mSimUnlockProgressDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
    if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_sf_slowBlur)) {
      mSimUnlockProgressDialog.getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND,WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
    }
  }
  return mSimUnlockProgressDialog;
}"
23597,"void updatePlugged(){
  Intent powerIntent=mContext.registerReceiver(null,mBatteryStatusFilter);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}","void updatePlugged(Intent powerIntent){
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + powerIntent.getExtras());
  if (powerIntent != null) {
    mPlugged=powerIntent.getIntExtra(BatteryManager.EXTRA_PLUGGED,0);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + mPlugged);
  }
}"
23598,"/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  IntentFilter intentFilter=new IntentFilter();
  intentFilter.addAction(Intent.ACTION_POWER_CONNECTED);
  intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED);
  context.registerReceiver(mPowerReceiver,intentFilter);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged();
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}","/** 
 * {@inheritDoc} 
 */
public void init(Context context,IWindowManager windowManager,LocalPowerManager powerManager){
  mContext=context;
  mWindowManager=windowManager;
  mPowerManager=powerManager;
  mKeyguardMediator=new KeyguardViewMediator(context,this,powerManager);
  mHandler=new Handler();
  mOrientationListener=new MyOrientationListener(mContext);
  SettingsObserver settingsObserver=new SettingsObserver(mHandler);
  settingsObserver.observe();
  mShortcutManager=new ShortcutManager(context,mHandler);
  mShortcutManager.observe();
  mHomeIntent=new Intent(Intent.ACTION_MAIN,null);
  mHomeIntent.addCategory(Intent.CATEGORY_HOME);
  mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mCarDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
  mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  mDeskDockIntent=new Intent(Intent.ACTION_MAIN,null);
  mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
  mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
  PowerManager pm=(PowerManager)context.getSystemService(Context.POWER_SERVICE);
  mBroadcastWakeLock=pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK,""String_Node_Str"");
  mDockWakeLock.setReferenceCounted(false);
  mEnableShiftMenuBugReports=""String_Node_Str"".equals(SystemProperties.get(""String_Node_Str""));
  mLidOpenRotation=readRotation(com.android.internal.R.integer.config_lidOpenRotation);
  mCarDockRotation=readRotation(com.android.internal.R.integer.config_carDockRotation);
  mDeskDockRotation=readRotation(com.android.internal.R.integer.config_deskDockRotation);
  mCarDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_carDockKeepsScreenOn);
  mDeskDockKeepsScreenOn=mContext.getResources().getInteger(com.android.internal.R.integer.config_deskDockKeepsScreenOn);
  mCarDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
  mDeskDockEnablesAccelerometer=mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
  mLidKeyboardAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
  mLidNavigationAccessibility=mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
  mBatteryStatusFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
  mPlugged=0;
  updatePlugged(context.registerReceiver(null,mBatteryStatusFilter));
  context.registerReceiver(mDockReceiver,new IntentFilter(Intent.ACTION_DOCK_EVENT));
  mVibrator=new Vibrator();
  mLongPressVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_longPressVibePattern);
  mVirtualKeyVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_virtualKeyVibePattern);
  mSafeModeDisabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeDisabledVibePattern);
  mSafeModeEnabledVibePattern=getLongIntArray(mContext.getResources(),com.android.internal.R.array.config_safeModeEnabledVibePattern);
}"
23599,"public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateKeepScreenOn();
  updateOrientationListenerLp();
}","public void onReceive(Context context,Intent intent){
  mDockState=intent.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
  boolean watchBattery=mDockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;
  if (watchBattery != mRegisteredBatteryReceiver) {
    mRegisteredBatteryReceiver=watchBattery;
    if (watchBattery) {
      updatePlugged(mContext.registerReceiver(mBatteryReceiver,mBatteryStatusFilter));
    }
 else {
      mContext.unregisterReceiver(mBatteryReceiver);
    }
  }
  updateRotation(Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
  updateDockKeepingScreenOn();
  updateOrientationListenerLp();
}"
23600,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}"
23601,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}"
23602,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}"
23603,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}"
23604,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
23605,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}"
23606,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}"
23607,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}"
23608,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}"
23609,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
23610,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}"
23611,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}"
23612,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}"
23613,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}"
23614,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}"
23615,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
23616,"final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      removeProviderLocked(provider);
    }
  }
}","final void completeRemoveProvider(IContentProvider provider){
  IBinder jBinder=provider.asBinder();
  String name=null;
synchronized (mProviderMap) {
    ProviderRefCount prc=mProviderRefCountMap.get(jBinder);
    if (prc != null && prc.count == 0) {
      mProviderRefCountMap.remove(jBinder);
      name=removeProviderLocked(provider);
    }
  }
  if (name != null) {
    try {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + name);
      ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),name);
    }
 catch (    RemoteException e) {
    }
  }
}"
23617,"public final void removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return;
  }
  IBinder providerBinder=provider.asBinder();
  boolean amRemoveFlag=false;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (!amRemoveFlag) {
        try {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + pr.mName);
          ActivityManagerNative.getDefault().removeContentProvider(getApplicationThread(),pr.mName);
          amRemoveFlag=true;
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
}","public final String removeProviderLocked(IContentProvider provider){
  if (provider == null) {
    return null;
  }
  IBinder providerBinder=provider.asBinder();
  String name=null;
  Iterator<ProviderRecord> iter=mProviderMap.values().iterator();
  while (iter.hasNext()) {
    ProviderRecord pr=iter.next();
    IBinder myBinder=pr.mProvider.asBinder();
    if (myBinder == providerBinder) {
      if (pr.mLocalProvider != null) {
        if (localLOGV)         Log.i(TAG,""String_Node_Str"");
        return name;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"");
      myBinder.unlinkToDeath(pr,0);
      iter.remove();
      if (name == null) {
        name=pr.mName;
      }
    }
  }
  return name;
}"
23618,"/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}","/** 
 * Main code for cleaning up a process when it has gone away.  This is called both as a result of the process dying, or directly when stopping  a process when running in single process mode.
 */
private final void cleanUpApplicationRecordLocked(ProcessRecord app,boolean restarting,int index){
  if (index >= 0) {
    mLRUProcesses.remove(index);
  }
  if (app.crashDialog != null) {
    app.crashDialog.dismiss();
    app.crashDialog=null;
  }
  if (app.anrDialog != null) {
    app.anrDialog.dismiss();
    app.anrDialog=null;
  }
  if (app.waitDialog != null) {
    app.waitDialog.dismiss();
    app.waitDialog=null;
  }
  app.crashing=false;
  app.notResponding=false;
  app.resetPackageList();
  app.thread=null;
  app.forcingToForeground=null;
  app.foregroundServices=false;
  killServicesLocked(app,true);
  boolean restart=false;
  int NL=mLaunchingProviders.size();
  if (!app.pubProviders.isEmpty()) {
    Iterator it=app.pubProviders.values().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.provider=null;
      cpr.app=null;
      int i=0;
      if (!app.bad) {
        for (; i < NL; i++) {
          if (mLaunchingProviders.get(i) == cpr) {
            restart=true;
            break;
          }
        }
      }
 else {
        i=NL;
      }
      if (i >= NL) {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
    app.pubProviders.clear();
  }
  for (int i=0; i < NL; i++) {
    ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
    if (cpr.launchingApp == app) {
      if (!app.bad) {
        restart=true;
      }
 else {
        removeDyingProviderLocked(app,cpr);
        NL=mLaunchingProviders.size();
      }
    }
  }
  if (!app.conProviders.isEmpty()) {
    Iterator it=app.conProviders.keySet().iterator();
    while (it.hasNext()) {
      ContentProviderRecord cpr=(ContentProviderRecord)it.next();
      cpr.clients.remove(app);
    }
    app.conProviders.clear();
  }
  if (false) {
    for (int i=0; i < NL; i++) {
      ContentProviderRecord cpr=(ContentProviderRecord)mLaunchingProviders.get(i);
      if (cpr.clients.size() <= 0 && cpr.externals <= 0) {
synchronized (cpr) {
          cpr.launchingApp=null;
          cpr.notifyAll();
        }
      }
    }
  }
  skipCurrentReceiverLocked(app);
  if (app.receivers.size() > 0) {
    Iterator<ReceiverList> it=app.receivers.iterator();
    while (it.hasNext()) {
      removeReceiverLocked(it.next());
    }
    app.receivers.clear();
  }
  if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
    if (DEBUG_BACKUP)     Log.d(TAG,""String_Node_Str"" + mBackupTarget.appInfo + ""String_Node_Str"");
    try {
      IBackupManager bm=IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
      bm.agentDisconnected(app.info.packageName);
    }
 catch (    RemoteException e) {
    }
  }
  if (restarting) {
    return;
  }
  if (!app.persistent) {
    if (DEBUG_PROCESSES)     Log.v(TAG,""String_Node_Str"" + app);
    mProcessNames.remove(app.processName,app.info.uid);
  }
 else   if (!app.removed) {
    app.thread=null;
    app.forcingToForeground=null;
    app.foregroundServices=false;
    if (mPersistentStartingProcesses.indexOf(app) < 0) {
      mPersistentStartingProcesses.add(app);
      restart=true;
    }
  }
  mProcessesOnHold.remove(app);
  if (app == mHomeProcess) {
    mHomeProcess=null;
  }
  if (restart) {
    mProcessNames.put(app.processName,app.info.uid,app);
    startProcessLocked(app,""String_Node_Str"",app.processName);
  }
 else   if (app.pid > 0 && app.pid != MY_PID) {
synchronized (mPidsSelfLocked) {
      mPidsSelfLocked.remove(app.pid);
      mHandler.removeMessages(PROC_START_TIMEOUT_MSG,app);
    }
    app.setPid(0);
  }
}"
23619,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      Integer cnt=r.conProviders.get(localCpr);
      if (cnt == null || cnt.intValue() <= 1) {
        localCpr.clients.remove(r);
        r.conProviders.remove(localCpr);
      }
 else {
        r.conProviders.put(localCpr,new Integer(cnt.intValue() - 1));
      }
    }
    updateOomAdjLocked();
  }
}"
23620,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        Integer cnt=r.conProviders.get(cpr);
        if (cnt == null) {
          r.conProviders.put(cpr,new Integer(1));
        }
 else {
          r.conProviders.put(cpr,new Integer(cnt.intValue() + 1));
        }
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
23621,"private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      if (cursor != null && cursor.getCount() == 1) {
        cursor.moveToFirst();
        return cursor.getString(2);
      }
 else {
        title=uri.getLastPathSegment();
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}","private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      try {
        if (cursor != null && cursor.getCount() == 1) {
          cursor.moveToFirst();
          return cursor.getString(2);
        }
 else {
          title=uri.getLastPathSegment();
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}"
23622,"public void destroy(){
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}","public void destroy(){
  nContextDeinitToClient();
  mMessageThread.mRun=false;
  nContextDestroy(mContext);
  mContext=0;
  nDeviceDestroy(mDev);
  mDev=0;
}"
23623,"public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
}","public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
  mMessageThread=new MessageThread(this);
  mMessageThread.start();
}"
23624,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}"
23625,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}"
23626,"public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          wtoken.allAppWindows.add(startingWindow);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}","public void setAppStartingWindow(IBinder token,String pkg,int theme,CharSequence nonLocalizedLabel,int labelRes,int icon,IBinder transferFrom,boolean createIfNeeded){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    if (DEBUG_STARTING_WINDOW)     Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str""+ pkg+ ""String_Node_Str""+ transferFrom);
    AppWindowToken wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Log.w(TAG,""String_Node_Str"" + token);
      return;
    }
    if (mDisplayFrozen) {
      return;
    }
    if (wtoken.startingData != null) {
      return;
    }
    if (transferFrom != null) {
      AppWindowToken ttoken=findAppWindowToken(transferFrom);
      if (ttoken != null) {
        WindowState startingWindow=ttoken.startingWindow;
        if (startingWindow != null) {
          if (mStartingIconInTransition) {
            mSkipAppTransitionAnimation=true;
          }
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          final long origId=Binder.clearCallingIdentity();
          wtoken.startingData=ttoken.startingData;
          wtoken.startingView=ttoken.startingView;
          wtoken.startingWindow=startingWindow;
          ttoken.startingData=null;
          ttoken.startingView=null;
          ttoken.startingWindow=null;
          ttoken.startingMoved=true;
          startingWindow.mToken=wtoken;
          startingWindow.mRootToken=wtoken;
          startingWindow.mAppToken=wtoken;
          if (DEBUG_WINDOW_MOVEMENT)           Log.v(TAG,""String_Node_Str"" + startingWindow);
          mWindows.remove(startingWindow);
          ttoken.windows.remove(startingWindow);
          ttoken.allAppWindows.remove(startingWindow);
          addWindowToListInOrderLocked(startingWindow,true);
          if (ttoken.allDrawn) {
            wtoken.allDrawn=true;
          }
          if (ttoken.firstWindowDrawn) {
            wtoken.firstWindowDrawn=true;
          }
          if (!ttoken.hidden) {
            wtoken.hidden=false;
            wtoken.hiddenRequested=false;
            wtoken.willBeHidden=false;
          }
          if (wtoken.clientHidden != ttoken.clientHidden) {
            wtoken.clientHidden=ttoken.clientHidden;
            wtoken.sendAppVisibilityToClients();
          }
          if (ttoken.animation != null) {
            wtoken.animation=ttoken.animation;
            wtoken.animating=ttoken.animating;
            wtoken.animLayerAdjustment=ttoken.animLayerAdjustment;
            ttoken.animation=null;
            ttoken.animLayerAdjustment=0;
            wtoken.updateLayers();
            ttoken.updateLayers();
          }
          updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
          mLayoutNeeded=true;
          performLayoutAndPlaceSurfacesLocked();
          Binder.restoreCallingIdentity(origId);
          return;
        }
 else         if (ttoken.startingData != null) {
          if (DEBUG_STARTING_WINDOW)           Log.v(TAG,""String_Node_Str"" + ttoken + ""String_Node_Str""+ wtoken);
          wtoken.startingData=ttoken.startingData;
          ttoken.startingData=null;
          ttoken.startingMoved=true;
          Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
          mH.sendMessageAtFrontOfQueue(m);
          return;
        }
      }
    }
    if (!createIfNeeded) {
      return;
    }
    if (theme != 0) {
      AttributeCache.Entry ent=AttributeCache.instance().get(pkg,theme,com.android.internal.R.styleable.Window);
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false)) {
        return;
      }
      if (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowShowWallpaper,false)) {
        return;
      }
    }
    mStartingIconInTransition=true;
    wtoken.startingData=new StartingData(pkg,theme,nonLocalizedLabel,labelRes,icon);
    Message m=mH.obtainMessage(H.ADD_STARTING,wtoken);
    mH.sendMessageAtFrontOfQueue(m);
  }
}"
23627,"@Override public void handleMessage(Message msg){
synchronized (this) {
    updateKeyguardLocked();
    Log.d(TAG,""String_Node_Str"" + mDockState);
    mPowerManager.userActivityWithForce(SystemClock.uptimeMillis(),false,true);
    Intent intent=new Intent(Intent.ACTION_DOCK_EVENT);
    intent.putExtra(Intent.EXTRA_DOCK_STATE,mDockState);
    mContext.sendStickyOrderedBroadcast(intent,mResultReceiver,null,Activity.RESULT_OK,null,null);
  }
}","@Override public void handleMessage(Message msg){
synchronized (this) {
    Log.i(TAG,""String_Node_Str"" + mDockState);
    if (Settings.Secure.getInt(mContext.getContentResolver(),Settings.Secure.DEVICE_PROVISIONED,0) == 0) {
      Log.i(TAG,""String_Node_Str"");
      return;
    }
    mPowerManager.userActivityWithForce(SystemClock.uptimeMillis(),false,true);
    Intent intent=new Intent(Intent.ACTION_DOCK_EVENT);
    intent.putExtra(Intent.EXTRA_DOCK_STATE,mDockState);
    mContext.sendStickyOrderedBroadcast(intent,mResultReceiver,null,Activity.RESULT_OK,null,null);
  }
}"
23628,"private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      if (cursor != null && cursor.getCount() == 1) {
        cursor.moveToFirst();
        return cursor.getString(2);
      }
 else {
        title=uri.getLastPathSegment();
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}","private static String getTitle(Context context,Uri uri,boolean followSettingsUri){
  Cursor cursor=null;
  ContentResolver res=context.getContentResolver();
  String title=null;
  if (uri != null) {
    String authority=uri.getAuthority();
    if (Settings.AUTHORITY.equals(authority)) {
      if (followSettingsUri) {
        Uri actualUri=RingtoneManager.getActualDefaultRingtoneUri(context,RingtoneManager.getDefaultType(uri));
        String actualTitle=getTitle(context,actualUri,false);
        title=context.getString(com.android.internal.R.string.ringtone_default_with_actual,actualTitle);
      }
    }
 else {
      if (DrmStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,DRM_COLUMNS,null,null,null);
      }
 else       if (MediaStore.AUTHORITY.equals(authority)) {
        cursor=res.query(uri,MEDIA_COLUMNS,null,null,null);
      }
      try {
        if (cursor != null && cursor.getCount() == 1) {
          cursor.moveToFirst();
          return cursor.getString(2);
        }
 else {
          title=uri.getLastPathSegment();
        }
      }
  finally {
        if (cursor != null) {
          cursor.close();
        }
      }
    }
  }
  if (title == null) {
    title=context.getString(com.android.internal.R.string.ringtone_unknown);
    if (title == null) {
      title=""String_Node_Str"";
    }
  }
  return title;
}"
23629,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}"
23630,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}"
23631,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}"
23632,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
23633,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}"
23634,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}"
23635,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}"
23636,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
23637,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
23638,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}"
23639,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  boolean hasSAMLAccount=false;
  if (hasAccount) {
    try {
      String[] features=new String[]{""String_Node_Str""};
      hasSAMLAccount=AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,null,null).getResult().length > 0;
    }
 catch (    Exception e) {
      hasSAMLAccount=true;
    }
  }
  mEnableFallback=hasAccount && !hasSAMLAccount;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}"
23640,"View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    return new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts(),mEnableFallback);
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}","View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    UnlockScreen view=new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    view.setEnableFallback(mEnableFallback);
    return view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}"
23641,"/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts,boolean enableFallback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mEnableFallback=enableFallback;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}","/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}"
23642,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}"
23643,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}"
23644,"/** 
 * Trigger a dialog that lists the various methods of interacting with the requested   {@link Contacts} entry. This may be based on available{@link Data} rows under that contact, and may also include socialstatus and presence details.
 * @param context The parent {@link Context} that may be used as theparent for this dialog.
 * @param target Specific {@link Rect} that this dialog should becentered around, in screen coordinates. In particular, if the dialog has a ""callout"" arrow, it will be pointed and centered around this  {@link Rect}.
 * @param lookupUri A {@link Contacts#CONTENT_LOOKUP_URI} style{@link Uri} that describes a specific contact to featurein this dialog.
 * @param mode Any of {@link #MODE_SMALL},   {@link #MODE_MEDIUM}, or  {@link #MODE_LARGE}, indicating the desired dialog size, when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-typesto exclude when showing this dialog. For example, when already viewing the contact details card, this can be used to omit the details entry from the dialog.
 */
public static void showQuickContact(Context context,Rect target,Uri lookupUri,int mode,String[] excludeMimes){
  final Intent intent=new Intent(ACTION_QUICK_CONTACT);
  intent.setData(lookupUri);
  intent.putExtra(EXTRA_TARGET_RECT,target);
  intent.putExtra(EXTRA_MODE,mode);
  intent.putExtra(EXTRA_EXCLUDE_MIMES,excludeMimes);
  intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
  context.startActivity(intent);
}","/** 
 * Trigger a dialog that lists the various methods of interacting with the requested   {@link Contacts} entry. This may be based on available{@link Data} rows under that contact, and may also include socialstatus and presence details.
 * @param context The parent {@link Context} that may be used as theparent for this dialog.
 * @param target Specific {@link Rect} that this dialog should becentered around, in screen coordinates. In particular, if the dialog has a ""callout"" arrow, it will be pointed and centered around this  {@link Rect}.
 * @param lookupUri A {@link ContactsContract.Contacts#CONTENT_LOOKUP_URI} style{@link Uri} that describes a specific contact to featurein this dialog.
 * @param mode Any of {@link #MODE_SMALL},   {@link #MODE_MEDIUM}, or  {@link #MODE_LARGE}, indicating the desired dialog size, when supported.
 * @param excludeMimes Optional list of {@link Data#MIMETYPE} MIME-typesto exclude when showing this dialog. For example, when already viewing the contact details card, this can be used to omit the details entry from the dialog.
 */
public static void showQuickContact(Context context,Rect target,Uri lookupUri,int mode,String[] excludeMimes){
  final Intent intent=new Intent(ACTION_QUICK_CONTACT);
  intent.setData(lookupUri);
  intent.putExtra(EXTRA_TARGET_RECT,target);
  intent.putExtra(EXTRA_MODE,mode);
  intent.putExtra(EXTRA_EXCLUDE_MIMES,excludeMimes);
  intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
  context.startActivity(intent);
}"
23645,"public void saveMiniThumbToFile(byte[] data,long id,long magic) throws IOException {
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    if (data != null) {
      if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {
        return;
      }
      mBuffer.clear();
      mBuffer.put((byte)1);
      mBuffer.putLong(magic);
      mBuffer.putInt(data.length);
      mBuffer.put(data);
      mBuffer.flip();
      lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,false);
      mChannel.write(mBuffer,pos);
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str"",ex);
    throw ex;
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
}","public synchronized void saveMiniThumbToFile(byte[] data,long id,long magic) throws IOException {
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    if (data != null) {
      if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {
        return;
      }
      mBuffer.clear();
      mBuffer.put((byte)1);
      mBuffer.putLong(magic);
      mBuffer.putInt(data.length);
      mBuffer.put(data);
      mBuffer.flip();
      lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,false);
      mChannel.write(mBuffer,pos);
    }
  }
 catch (  IOException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str"",ex);
    throw ex;
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
}"
23646,"/** 
 * We store different types of thumbnails in different files. To remain backward compatibility, we should hashcode of content://media/external/images/media remains the same.
 */
public static synchronized void reset(){
  sThumbFiles.clear();
}","/** 
 * We store different types of thumbnails in different files. To remain backward compatibility, we should hashcode of content://media/external/images/media remains the same.
 */
public static synchronized void reset(){
  for (  MiniThumbFile file : sThumbFiles.values()) {
    file.deactivate();
  }
  sThumbFiles.clear();
}"
23647,"/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}","/** 
 * Gallery app can use this method to retrieve mini-thumbnail. Full size images share the same IDs with their corresponding thumbnails.
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */
public synchronized byte[] getMiniThumbFromFile(long id,byte[] data){
  RandomAccessFile r=miniThumbDataFile();
  if (r == null)   return null;
  long pos=id * BYTES_PER_MINTHUMB;
  FileLock lock=null;
  try {
    mBuffer.clear();
    lock=mChannel.lock(pos,BYTES_PER_MINTHUMB,true);
    int size=mChannel.read(mBuffer,pos);
    if (size > 1 + 8 + 4) {
      mBuffer.position(0);
      byte flag=mBuffer.get();
      long magic=mBuffer.getLong();
      int length=mBuffer.getInt();
      if (size >= 1 + 8 + 4+ length && data.length >= length) {
        mBuffer.get(data,0,length);
        return data;
      }
    }
  }
 catch (  IOException ex) {
    Log.w(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex);
  }
catch (  RuntimeException ex) {
    Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
  }
 finally {
    try {
      if (lock != null)       lock.release();
    }
 catch (    IOException ex) {
    }
  }
  return null;
}"
23648,"public long getMagic(long id){
  RandomAccessFile r=miniThumbDataFile();
  if (r != null) {
    long pos=id * BYTES_PER_MINTHUMB;
    FileLock lock=null;
    try {
      mBuffer.clear();
      mBuffer.limit(1 + 8);
      lock=mChannel.lock(pos,1 + 8,true);
      if (mChannel.read(mBuffer,pos) == 9) {
        mBuffer.position(0);
        if (mBuffer.get() == 1) {
          return mBuffer.getLong();
        }
      }
    }
 catch (    IOException ex) {
      Log.v(TAG,""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
    }
 finally {
      try {
        if (lock != null)         lock.release();
      }
 catch (      IOException ex) {
      }
    }
  }
  return 0;
}","public synchronized long getMagic(long id){
  RandomAccessFile r=miniThumbDataFile();
  if (r != null) {
    long pos=id * BYTES_PER_MINTHUMB;
    FileLock lock=null;
    try {
      mBuffer.clear();
      mBuffer.limit(1 + 8);
      lock=mChannel.lock(pos,1 + 8,true);
      if (mChannel.read(mBuffer,pos) == 9) {
        mBuffer.position(0);
        if (mBuffer.get() == 1) {
          return mBuffer.getLong();
        }
      }
    }
 catch (    IOException ex) {
      Log.v(TAG,""String_Node_Str"",ex);
    }
catch (    RuntimeException ex) {
      Log.e(TAG,""String_Node_Str"" + id + ""String_Node_Str""+ ex.getClass());
    }
 finally {
      try {
        if (lock != null)         lock.release();
      }
 catch (      IOException ex) {
      }
    }
  }
  return 0;
}"
23649,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.isMusicActive();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
if (!mMediaServerOk) {
Log.e(TAG,""String_Node_Str"");
AudioSystem.isMusicActive();
sendMsg(mAudioHandler,MSG_MEDIA_SERVER_DIED,SHARED_MSG,SENDMSG_NOOP,0,0,null,500);
}
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
AudioSystem.setForceUse(AudioSystem.FOR_RECORD,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}"
23650,"/** 
 * Once we know that we have asked an application to put an activity in the resumed state (either by launching it or explicitly telling it), this function updates the rest of our state to match that fact.
 */
private final void completeResumeLocked(HistoryRecord next){
  next.idle=false;
  next.results=null;
  next.newIntents=null;
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
  msg.obj=next;
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
  if (false) {
    msg=mHandler.obtainMessage(IDLE_NOW_MSG);
    msg.obj=next;
    mHandler.sendMessage(msg);
  }
  reportResumedActivity(next);
  next.thumbnail=null;
  setFocusedActivityLocked(next);
  next.resumeKeyDispatchingLocked();
  ensureActivitiesVisibleLocked(null,0);
  mWindowManager.executeAppTransition();
  mNoAnimActivities.clear();
  if (next.app != null) {
synchronized (mProcessStatsThread) {
      next.cpuTimeAtResume=mProcessStats.getCpuTimeForPid(next.app.pid);
    }
  }
 else {
    next.cpuTimeAtResume=0;
  }
}","/** 
 * Once we know that we have asked an application to put an activity in the resumed state (either by launching it or explicitly telling it), this function updates the rest of our state to match that fact.
 */
private final void completeResumeLocked(HistoryRecord next){
  next.idle=false;
  next.results=null;
  next.newIntents=null;
  Message msg=mHandler.obtainMessage(IDLE_TIMEOUT_MSG);
  msg.obj=next;
  mHandler.sendMessageDelayed(msg,IDLE_TIMEOUT);
  if (false) {
    msg=mHandler.obtainMessage(IDLE_NOW_MSG);
    msg.obj=next;
    mHandler.sendMessage(msg);
  }
  reportResumedActivityLocked(next);
  next.thumbnail=null;
  setFocusedActivityLocked(next);
  next.resumeKeyDispatchingLocked();
  ensureActivitiesVisibleLocked(null,0);
  mWindowManager.executeAppTransition();
  mNoAnimActivities.clear();
  if (next.app != null) {
synchronized (mProcessStatsThread) {
      next.cpuTimeAtResume=mProcessStats.getCpuTimeForPid(next.app.pid);
    }
  }
 else {
    next.cpuTimeAtResume=0;
  }
}"
23651,"private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
  }
  return true;
}","private final boolean relaunchActivityLocked(HistoryRecord r,int changes,boolean andResume){
  List<ResultInfo> results=null;
  List<Intent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume);
  EventLog.writeEvent(andResume ? LOG_AM_RELAUNCH_RESUME_ACTIVITY : LOG_AM_RELAUNCH_ACTIVITY,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  try {
    if (DEBUG_SWITCH)     Log.i(TAG,""String_Node_Str"" + r);
    r.app.thread.scheduleRelaunchActivity(r,results,newIntents,changes,!andResume);
  }
 catch (  RemoteException e) {
    return false;
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    reportResumedActivityLocked(r);
  }
  return true;
}"
23652,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}"
23653,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}"
23654,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}"
23655,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
23656,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}"
23657,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}"
23658,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}"
23659,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
23660,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
23661,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}"
23662,"private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}","private boolean parseIntent(Resources res,XmlPullParser parser,AttributeSet attrs,int flags,IntentInfo outInfo,String[] outError,boolean isActivity) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestIntentFilter);
  int priority=sa.getInt(com.android.internal.R.styleable.AndroidManifestIntentFilter_priority,0);
  if (priority > 0 && isActivity && (flags & PARSE_IS_SYSTEM) == 0) {
    Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
    priority=0;
  }
  outInfo.setPriority(priority);
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestIntentFilter_label);
  if (v != null && (outInfo.labelRes=v.resourceId) == 0) {
    outInfo.nonLocalizedLabel=v.coerceToString();
  }
  outInfo.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestIntentFilter_icon,0);
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String nodeName=parser.getName();
    if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addAction(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      String value=attrs.getAttributeValue(ANDROID_RESOURCES,""String_Node_Str"");
      if (value == null || value == ""String_Node_Str"") {
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
      outInfo.addCategory(value);
    }
 else     if (nodeName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestData);
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_mimeType);
      if (str != null) {
        try {
          outInfo.addDataType(str);
        }
 catch (        IntentFilter.MalformedMimeTypeException e) {
          outError[0]=e.toString();
          sa.recycle();
          return false;
        }
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_scheme);
      if (str != null) {
        outInfo.addDataScheme(str);
      }
      String host=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_host);
      String port=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_port);
      if (host != null) {
        outInfo.addDataAuthority(host,port);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_path);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPrefix);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestData_pathPattern);
      if (str != null) {
        outInfo.addDataPath(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (!RIGID_PARSER) {
      Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  outInfo.hasDefault=outInfo.hasCategory(Intent.CATEGORY_DEFAULT);
  if (false) {
    String cats=""String_Node_Str"";
    Iterator<String> it=outInfo.categoriesIterator();
    while (it != null && it.hasNext()) {
      cats+=""String_Node_Str"" + it.next();
    }
    System.out.println(""String_Node_Str"" + outInfo.hasDefault + ""String_Node_Str""+ cats);
  }
  return true;
}"
23663,"private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseProviderTags(Resources res,XmlPullParser parser,AttributeSet attrs,Provider outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestGrantUriPermission);
      PatternMatcher pa=null;
      String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_path);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_LITERAL);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPrefix);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_PREFIX);
      }
      str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestGrantUriPermission_pathPattern);
      if (str != null) {
        pa=new PatternMatcher(str,PatternMatcher.PATTERN_SIMPLE_GLOB);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.uriPermissionPatterns == null) {
          outInfo.info.uriPermissionPatterns=new PatternMatcher[1];
          outInfo.info.uriPermissionPatterns[0]=pa;
        }
 else {
          final int N=outInfo.info.uriPermissionPatterns.length;
          PatternMatcher[] newp=new PatternMatcher[N + 1];
          System.arraycopy(outInfo.info.uriPermissionPatterns,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.uriPermissionPatterns=newp;
        }
        outInfo.info.grantUriPermissions=true;
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestPathPermission);
      PathPermission pa=null;
      String permission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_permission);
      String readPermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_readPermission);
      if (readPermission == null) {
        readPermission=permission;
      }
      String writePermission=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_writePermission);
      if (writePermission == null) {
        writePermission=permission;
      }
      boolean havePerm=false;
      if (readPermission != null) {
        readPermission=readPermission.intern();
        havePerm=true;
      }
      if (writePermission != null) {
        writePermission=readPermission.intern();
        havePerm=true;
      }
      if (!havePerm) {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      String path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_path);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_LITERAL,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPrefix);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_PREFIX,readPermission,writePermission);
      }
      path=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestPathPermission_pathPattern);
      if (path != null) {
        pa=new PathPermission(path,PatternMatcher.PATTERN_SIMPLE_GLOB,readPermission,writePermission);
      }
      sa.recycle();
      if (pa != null) {
        if (outInfo.info.pathPermissions == null) {
          outInfo.info.pathPermissions=new PathPermission[1];
          outInfo.info.pathPermissions[0]=pa;
        }
 else {
          final int N=outInfo.info.pathPermissions.length;
          PathPermission[] newp=new PathPermission[N + 1];
          System.arraycopy(outInfo.info.pathPermissions,0,newp,0,N);
          newp[N]=pa;
          outInfo.info.pathPermissions=newp;
        }
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        outError[0]=""String_Node_Str"";
        return false;
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return false;
    }
  }
  return true;
}"
23664,"private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}","private Service parseService(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestService);
  if (mParseServiceArgs == null) {
    mParseServiceArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestService_name,com.android.internal.R.styleable.AndroidManifestService_label,com.android.internal.R.styleable.AndroidManifestService_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestService_process,com.android.internal.R.styleable.AndroidManifestService_enabled);
    mParseServiceArgs.tag=""String_Node_Str"";
  }
  mParseServiceArgs.sa=sa;
  mParseServiceArgs.flags=flags;
  Service s=new Service(mParseServiceArgs,new ServiceInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestService_exported);
  if (setExported) {
    s.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestService_exported,false);
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestService_permission);
  if (str == null) {
    s.info.permission=owner.applicationInfo.permission;
  }
 else {
    s.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ServiceIntentInfo intent=new ServiceIntentInfo(s);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,false)) {
        return null;
      }
      s.intents.add(intent);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((s.metaData=parseMetaData(res,parser,attrs,s.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    s.info.exported=s.intents.size() > 0;
  }
  return s;
}"
23665,"private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tagName);
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}","private boolean parseApplication(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  final ApplicationInfo ai=owner.applicationInfo;
  final String pkgName=owner.applicationInfo.packageName;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestApplication);
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_name);
  if (name != null) {
    ai.className=buildClassName(pkgName,name,outError);
    if (ai.className == null) {
      sa.recycle();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return false;
    }
  }
  String manageSpaceActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_manageSpaceActivity);
  if (manageSpaceActivity != null) {
    ai.manageSpaceActivityName=buildClassName(pkgName,manageSpaceActivity,outError);
  }
  boolean allowBackup=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowBackup,true);
  if (allowBackup) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_BACKUP;
    String backupAgent=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_backupAgent);
    if (backupAgent != null) {
      ai.backupAgentName=buildClassName(pkgName,backupAgent,outError);
      if (false) {
        Log.v(TAG,""String_Node_Str"" + ai.backupAgentName + ""String_Node_Str""+ pkgName+ ""String_Node_Str""+ backupAgent);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_killAfterRestore,true)) {
        ai.flags|=ApplicationInfo.FLAG_KILL_AFTER_RESTORE;
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_restoreNeedsApplication,false)) {
        ai.flags|=ApplicationInfo.FLAG_RESTORE_NEEDS_APPLICATION;
      }
    }
  }
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestApplication_label);
  if (v != null && (ai.labelRes=v.resourceId) == 0) {
    ai.nonLocalizedLabel=v.coerceToString();
  }
  ai.icon=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_icon,0);
  ai.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_theme,0);
  ai.descriptionRes=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestApplication_description,0);
  if ((flags & PARSE_IS_SYSTEM) != 0) {
    if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_persistent,false)) {
      ai.flags|=ApplicationInfo.FLAG_PERSISTENT;
    }
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_debuggable,false)) {
    ai.flags|=ApplicationInfo.FLAG_DEBUGGABLE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_hasCode,true)) {
    ai.flags|=ApplicationInfo.FLAG_HAS_CODE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowTaskReparenting,false)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_allowClearUserData,true)) {
    ai.flags|=ApplicationInfo.FLAG_ALLOW_CLEAR_USER_DATA;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_testOnly,false)) {
    ai.flags|=ApplicationInfo.FLAG_TEST_ONLY;
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_permission);
  ai.permission=(str != null && str.length() > 0) ? str.intern() : null;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_taskAffinity);
  ai.taskAffinity=buildTaskAffinityName(ai.packageName,ai.packageName,str,outError);
  if (outError[0] == null) {
    ai.processName=buildProcessName(ai.packageName,null,sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestApplication_process),flags,mSeparateProcesses,outError);
    ai.enabled=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestApplication_enabled,true);
  }
  sa.recycle();
  if (outError[0] != null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
    return false;
  }
  final int innerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > innerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,false);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivity(owner,res,parser,attrs,flags,outError,true);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.receivers.add(a);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Service s=parseService(owner,res,parser,attrs,flags,outError);
      if (s == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.services.add(s);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Provider p=parseProvider(owner,res,parser,attrs,flags,outError);
      if (p == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.providers.add(p);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      Activity a=parseActivityAlias(owner,res,parser,attrs,flags,outError);
      if (a == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
      owner.activities.add(a);
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((owner.mAppMetaData=parseMetaData(res,parser,attrs,owner.mAppMetaData,outError)) == null) {
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesLibrary);
      String lname=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesLibrary_name);
      boolean req=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesLibrary_required,true);
      sa.recycle();
      if (lname != null) {
        if (req) {
          if (owner.usesLibraries == null) {
            owner.usesLibraries=new ArrayList<String>();
          }
          if (!owner.usesLibraries.contains(lname)) {
            owner.usesLibraries.add(lname.intern());
          }
        }
 else {
          if (owner.usesOptionalLibraries == null) {
            owner.usesOptionalLibraries=new ArrayList<String>();
          }
          if (!owner.usesOptionalLibraries.contains(lname)) {
            owner.usesOptionalLibraries.add(lname.intern());
          }
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tagName + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + tagName;
        mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
        return false;
      }
    }
  }
  return true;
}"
23666,"private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}","private boolean parseAllMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,String tag,Component outInfo,String[] outError) throws XmlPullParserException, IOException {
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      if ((outInfo.metaData=parseMetaData(res,parser,attrs,outInfo.metaData,outError)) == null) {
        return false;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + tag + ""String_Node_Str""+ parser.getName();
      return false;
    }
  }
  return true;
}"
23667,"private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
          Log.w(TAG,""String_Node_Str"");
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}","private Bundle parseMetaData(Resources res,XmlPullParser parser,AttributeSet attrs,Bundle data,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestMetaData);
  if (data == null) {
    data=new Bundle();
  }
  String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestMetaData_name);
  if (name == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  name=name.intern();
  TypedValue v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_resource);
  if (v != null && v.resourceId != 0) {
    data.putInt(name,v.resourceId);
  }
 else {
    v=sa.peekValue(com.android.internal.R.styleable.AndroidManifestMetaData_value);
    if (v != null) {
      if (v.type == TypedValue.TYPE_STRING) {
        CharSequence cs=v.coerceToString();
        data.putString(name,cs != null ? cs.toString().intern() : null);
      }
 else       if (v.type == TypedValue.TYPE_INT_BOOLEAN) {
        data.putBoolean(name,v.data != 0);
      }
 else       if (v.type >= TypedValue.TYPE_FIRST_INT && v.type <= TypedValue.TYPE_LAST_INT) {
        data.putInt(name,v.data);
      }
 else       if (v.type == TypedValue.TYPE_FLOAT) {
        data.putFloat(name,v.getFloat());
      }
 else {
        if (!RIGID_PARSER) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          outError[0]=""String_Node_Str"";
          data=null;
        }
      }
    }
 else {
      outError[0]=""String_Node_Str"";
      data=null;
    }
  }
  sa.recycle();
  XmlUtils.skipCurrentTag(parser);
  return data;
}"
23668,"private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      Log.i(TAG,""String_Node_Str"" + npi.name + ""String_Node_Str""+ pkg.packageName);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}","private Package parsePackage(Resources res,XmlResourceParser parser,int flags,String[] outError) throws XmlPullParserException, IOException {
  AttributeSet attrs=parser;
  mParseInstrumentationArgs=null;
  mParseActivityArgs=null;
  mParseServiceArgs=null;
  mParseProviderArgs=null;
  String pkgName=parsePackageName(parser,attrs,flags,outError);
  if (pkgName == null) {
    mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME;
    return null;
  }
  int type;
  final Package pkg=new Package(pkgName);
  boolean foundApp=false;
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifest);
  pkg.mVersionCode=sa.getInteger(com.android.internal.R.styleable.AndroidManifest_versionCode,0);
  pkg.mVersionName=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_versionName);
  if (pkg.mVersionName != null) {
    pkg.mVersionName=pkg.mVersionName.intern();
  }
  String str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifest_sharedUserId);
  if (str != null) {
    String nameError=validateName(str,true);
    if (nameError != null && !""String_Node_Str"".equals(pkgName)) {
      outError[0]=""String_Node_Str"" + str + ""String_Node_Str""+ nameError;
      mParseError=PackageManager.INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID;
      return null;
    }
    pkg.mSharedUserId=str.intern();
    pkg.mSharedUserLabel=sa.getResourceId(com.android.internal.R.styleable.AndroidManifest_sharedUserLabel,0);
  }
  sa.recycle();
  int supportsSmallScreens=1;
  int supportsNormalScreens=1;
  int supportsLargeScreens=1;
  int resizeable=1;
  int anyDensity=1;
  int outerDepth=parser.getDepth();
  while ((type=parser.next()) != parser.END_DOCUMENT && (type != parser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == parser.END_TAG || type == parser.TEXT) {
      continue;
    }
    String tagName=parser.getName();
    if (tagName.equals(""String_Node_Str"")) {
      if (foundApp) {
        if (RIGID_PARSER) {
          outError[0]=""String_Node_Str"";
          mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
          return null;
        }
 else {
          Log.w(TAG,""String_Node_Str"");
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
      }
      foundApp=true;
      if (!parseApplication(pkg,res,parser,attrs,flags,outError)) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionGroup(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermission(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parsePermissionTree(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesPermission);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesPermission_name);
      sa.recycle();
      if (name != null && !pkg.requestedPermissions.contains(name)) {
        pkg.requestedPermissions.add(name.intern());
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      ConfigurationInfo cPref=new ConfigurationInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesConfiguration);
      cPref.reqTouchScreen=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen,Configuration.TOUCHSCREEN_UNDEFINED);
      cPref.reqKeyboardType=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType,Configuration.KEYBOARD_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD;
      }
      cPref.reqNavigation=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation,Configuration.NAVIGATION_UNDEFINED);
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav,false)) {
        cPref.reqInputFeatures|=ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV;
      }
      sa.recycle();
      pkg.configPreferences.add(cPref);
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      FeatureInfo fi=new FeatureInfo();
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesFeature);
      fi.name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestUsesFeature_name);
      if (fi.name == null) {
        fi.reqGlEsVersion=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesFeature_glEsVersion,FeatureInfo.GL_ES_VERSION_UNDEFINED);
      }
      if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestUsesFeature_required,true)) {
        fi.flags|=FeatureInfo.FLAG_REQUIRED;
      }
      sa.recycle();
      if (pkg.reqFeatures == null) {
        pkg.reqFeatures=new ArrayList<FeatureInfo>();
      }
      pkg.reqFeatures.add(fi);
      if (fi.name == null) {
        ConfigurationInfo cPref=new ConfigurationInfo();
        cPref.reqGlEsVersion=fi.reqGlEsVersion;
        pkg.configPreferences.add(cPref);
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (mSdkVersion > 0) {
        sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestUsesSdk);
        int minVers=0;
        String minCode=null;
        int targetVers=0;
        String targetCode=null;
        TypedValue val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=minVers=val.data;
          }
        }
        val=sa.peekValue(com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion);
        if (val != null) {
          if (val.type == TypedValue.TYPE_STRING && val.string != null) {
            targetCode=minCode=val.string.toString();
          }
 else {
            targetVers=val.data;
          }
        }
        int maxVers=sa.getInt(com.android.internal.R.styleable.AndroidManifestUsesSdk_maxSdkVersion,mSdkVersion);
        sa.recycle();
        if (minCode != null) {
          if (!minCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + minCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
        }
 else         if (minVers > mSdkVersion) {
          outError[0]=""String_Node_Str"" + minVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
        if (targetCode != null) {
          if (!targetCode.equals(mSdkCodename)) {
            if (mSdkCodename != null) {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str""+ mSdkCodename+ ""String_Node_Str"";
            }
 else {
              outError[0]=""String_Node_Str"" + targetCode + ""String_Node_Str"";
            }
            mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
            return null;
          }
          pkg.applicationInfo.targetSdkVersion=android.os.Build.VERSION_CODES.CUR_DEVELOPMENT;
        }
 else {
          pkg.applicationInfo.targetSdkVersion=targetVers;
        }
        if (maxVers < mSdkVersion) {
          outError[0]=""String_Node_Str"" + maxVers + ""String_Node_Str""+ mSdkVersion+ ""String_Node_Str"";
          mParseError=PackageManager.INSTALL_FAILED_OLDER_SDK;
          return null;
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestSupportsScreens);
      supportsSmallScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens,supportsSmallScreens);
      supportsNormalScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens,supportsNormalScreens);
      supportsLargeScreens=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens,supportsLargeScreens);
      resizeable=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable,supportsLargeScreens);
      anyDensity=sa.getInteger(com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity,anyDensity);
      sa.recycle();
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestProtectedBroadcast);
      String name=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name);
      sa.recycle();
      if (name != null && (flags & PARSE_IS_SYSTEM) != 0) {
        if (pkg.protectedBroadcasts == null) {
          pkg.protectedBroadcasts=new ArrayList<String>();
        }
        if (!pkg.protectedBroadcasts.contains(name)) {
          pkg.protectedBroadcasts.add(name.intern());
        }
      }
      XmlUtils.skipCurrentTag(parser);
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      if (parseInstrumentation(pkg,res,parser,attrs,outError) == null) {
        return null;
      }
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
 else     if (RIGID_PARSER) {
      outError[0]=""String_Node_Str"" + parser.getName();
      mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
      return null;
    }
 else {
      Log.w(TAG,""String_Node_Str"" + parser.getName());
      XmlUtils.skipCurrentTag(parser);
      continue;
    }
  }
  if (!foundApp && pkg.instrumentation.size() == 0) {
    outError[0]=""String_Node_Str"";
    mParseError=PackageManager.INSTALL_PARSE_FAILED_MANIFEST_EMPTY;
  }
  final int NP=PackageParser.NEW_PERMISSIONS.length;
  StringBuilder implicitPerms=null;
  for (int ip=0; ip < NP; ip++) {
    final PackageParser.NewPermissionInfo npi=PackageParser.NEW_PERMISSIONS[ip];
    if (pkg.applicationInfo.targetSdkVersion >= npi.sdkVersion) {
      break;
    }
    if (!pkg.requestedPermissions.contains(npi.name)) {
      if (implicitPerms == null) {
        implicitPerms=new StringBuilder(128);
        implicitPerms.append(pkg.packageName);
        implicitPerms.append(""String_Node_Str"");
      }
 else {
        implicitPerms.append(' ');
      }
      implicitPerms.append(npi.name);
      pkg.requestedPermissions.add(npi.name);
    }
  }
  if (implicitPerms != null) {
    Log.i(TAG,implicitPerms.toString());
  }
  if (supportsSmallScreens < 0 || (supportsSmallScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS;
  }
  if (supportsNormalScreens != 0) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS;
  }
  if (supportsLargeScreens < 0 || (supportsLargeScreens > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS;
  }
  if (resizeable < 0 || (resizeable > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS;
  }
  if (anyDensity < 0 || (anyDensity > 0 && pkg.applicationInfo.targetSdkVersion >= android.os.Build.VERSION_CODES.DONUT)) {
    pkg.applicationInfo.flags|=ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
  }
  return pkg;
}"
23669,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + parser.getName());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.processName=target.info.processName;
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,true)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      outError[0]=""String_Node_Str"" + parser.getName();
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
23670,"private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivity(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError,boolean receiver) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivity);
  if (mParseActivityArgs == null) {
    mParseActivityArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivity_name,com.android.internal.R.styleable.AndroidManifestActivity_label,com.android.internal.R.styleable.AndroidManifestActivity_icon,mSeparateProcesses,com.android.internal.R.styleable.AndroidManifestActivity_process,com.android.internal.R.styleable.AndroidManifestActivity_enabled);
  }
  mParseActivityArgs.tag=receiver ? ""String_Node_Str"" : ""String_Node_Str"";
  mParseActivityArgs.sa=sa;
  mParseActivityArgs.flags=flags;
  Activity a=new Activity(mParseActivityArgs,new ActivityInfo());
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivity_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_exported,false);
  }
  a.info.theme=sa.getResourceId(com.android.internal.R.styleable.AndroidManifestActivity_theme,0);
  String str;
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_permission);
  if (str == null) {
    a.info.permission=owner.applicationInfo.permission;
  }
 else {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  str=sa.getNonResourceString(com.android.internal.R.styleable.AndroidManifestActivity_taskAffinity);
  a.info.taskAffinity=buildTaskAffinityName(owner.applicationInfo.packageName,owner.applicationInfo.taskAffinity,str,outError);
  a.info.flags=0;
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_multiprocess,false)) {
    a.info.flags|=ActivityInfo.FLAG_MULTIPROCESS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnTaskLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_TASK_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_clearTaskOnLaunch,false)) {
    a.info.flags|=ActivityInfo.FLAG_CLEAR_TASK_ON_LAUNCH;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_noHistory,false)) {
    a.info.flags|=ActivityInfo.FLAG_NO_HISTORY;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_alwaysRetainTaskState,false)) {
    a.info.flags|=ActivityInfo.FLAG_ALWAYS_RETAIN_TASK_STATE;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_stateNotNeeded,false)) {
    a.info.flags|=ActivityInfo.FLAG_STATE_NOT_NEEDED;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_excludeFromRecents,false)) {
    a.info.flags|=ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_allowTaskReparenting,(owner.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_TASK_REPARENTING) != 0)) {
    a.info.flags|=ActivityInfo.FLAG_ALLOW_TASK_REPARENTING;
  }
  if (sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivity_finishOnCloseSystemDialogs,false)) {
    a.info.flags|=ActivityInfo.FLAG_FINISH_ON_CLOSE_SYSTEM_DIALOGS;
  }
  if (!receiver) {
    a.info.launchMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_launchMode,ActivityInfo.LAUNCH_MULTIPLE);
    a.info.screenOrientation=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_screenOrientation,ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
    a.info.configChanges=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_configChanges,0);
    a.info.softInputMode=sa.getInt(com.android.internal.R.styleable.AndroidManifestActivity_windowSoftInputMode,0);
  }
 else {
    a.info.launchMode=ActivityInfo.LAUNCH_MULTIPLE;
    a.info.configChanges=0;
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,flags,intent,outError,!receiver)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Log.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Log.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str"");
        if (receiver) {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          Log.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
      if (receiver) {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
      }
      return null;
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}"
23671,"/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}","/** 
 * Convenience function to retrieve the bookmarked Intent for a particular shortcut key.
 * @param cr The ContentResolver to query.
 * @param shortcut The shortcut key.
 * @return Intent The bookmarked URL, or null if there is no bookmarkmatching the given shortcut.
 */
public static Intent getIntentForShortcut(ContentResolver cr,char shortcut){
  Intent intent=null;
  Cursor c=cr.query(CONTENT_URI,sIntentProjection,sShortcutSelection,new String[]{String.valueOf((int)shortcut)},ORDERING);
  try {
    while (intent == null && c.moveToNext()) {
      try {
        String intentURI=c.getString(c.getColumnIndexOrThrow(INTENT));
        intent=Intent.getIntent(intentURI);
      }
 catch (      java.net.URISyntaxException e) {
      }
catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
  finally {
    if (c != null)     c.close();
  }
  return intent;
}"
23672,"/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  boolean hasSAMLAccount=false;
  if (hasAccount) {
    try {
      String[] features=new String[]{""String_Node_Str""};
      hasSAMLAccount=AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,null,null).getResult().length > 0;
    }
 catch (    Exception e) {
      hasSAMLAccount=true;
    }
  }
  mEnableFallback=hasAccount && !hasSAMLAccount;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}","/** 
 * @param context Used to inflate, and create views.
 * @param updateMonitor Knows the state of the world, and passed along to eachscreen so they can use the knowledge, and also register for callbacks on dynamic information.
 * @param lockPatternUtils Used to look up state of lock pattern.
 */
public LockPatternKeyguardView(Context context,KeyguardUpdateMonitor updateMonitor,LockPatternUtils lockPatternUtils,KeyguardWindowController controller){
  super(context);
  final boolean hasAccount=AccountManager.get(context).getAccounts().length > 0;
  if (hasAccount) {
    String[] features=new String[]{""String_Node_Str""};
    AccountManager.get(context).getAccountsByTypeAndFeatures(""String_Node_Str"",features,this,null);
  }
  mEnableFallback=false;
  mRequiresSim=TextUtils.isEmpty(SystemProperties.get(""String_Node_Str""));
  mUpdateMonitor=updateMonitor;
  mLockPatternUtils=lockPatternUtils;
  mWindowController=controller;
  mMode=getInitialMode();
  mKeyguardScreenCallback=new KeyguardScreenCallback(){
    public void goToLockScreen(){
      mForgotPattern=false;
      if (mIsVerifyUnlockOnly) {
        mIsVerifyUnlockOnly=false;
        getCallback().keyguardDone(false);
      }
 else {
        updateScreen(Mode.LockScreen);
      }
    }
    public void goToUnlockScreen(){
      final IccCard.State simState=mUpdateMonitor.getSimState();
      if (stuckOnLockScreenBecauseSimMissing() || (simState == IccCard.State.PUK_REQUIRED)) {
        return;
      }
      if (!isSecure()) {
        getCallback().keyguardDone(true);
      }
 else {
        updateScreen(Mode.UnlockScreen);
      }
    }
    public void forgotPattern(    boolean isForgotten){
      if (mEnableFallback) {
        mForgotPattern=isForgotten;
        updateScreen(Mode.UnlockScreen);
      }
    }
    public boolean isSecure(){
      return LockPatternKeyguardView.this.isSecure();
    }
    public boolean isVerifyUnlockOnly(){
      return mIsVerifyUnlockOnly;
    }
    public void recreateMe(){
      recreateScreens();
    }
    public void takeEmergencyCallAction(){
      Intent intent=new Intent(ACTION_EMERGENCY_DIAL);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
      getContext().startActivity(intent);
    }
    public void pokeWakelock(){
      getCallback().pokeWakelock();
    }
    public void pokeWakelock(    int millis){
      getCallback().pokeWakelock(millis);
    }
    public void keyguardDone(    boolean authenticated){
      getCallback().keyguardDone(authenticated);
    }
    public void keyguardDoneDrawing(){
    }
    public void reportFailedPatternAttempt(){
      mUpdateMonitor.reportFailedAttempt();
      final int failedAttempts=mUpdateMonitor.getFailedAttempts();
      if (mEnableFallback && failedAttempts == (LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET - LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT)) {
        showAlmostAtAccountLoginDialog();
      }
 else       if (mEnableFallback && failedAttempts >= LockPatternUtils.FAILED_ATTEMPTS_BEFORE_RESET) {
        mLockPatternUtils.setPermanentlyLocked(true);
        updateScreen(mMode);
      }
 else       if ((failedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT) == 0) {
        showTimeoutDialog();
      }
    }
    public boolean doesFallbackUnlockScreenExist(){
      return mEnableFallback;
    }
  }
;
  setFocusableInTouchMode(true);
  setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
  if (false) {
    final BitmapDrawable drawable=(BitmapDrawable)context.getWallpaper();
    setBackgroundDrawable(new FastBitmapDrawable(drawable.getBitmap()));
  }
  mLockScreen=createLockScreen();
  addView(mLockScreen);
  final UnlockMode unlockMode=getUnlockMode();
  mUnlockScreen=createUnlockScreenFor(unlockMode);
  mUnlockScreenMode=unlockMode;
  addView(mUnlockScreen);
  updateScreen(mMode);
}"
23673,"View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    return new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts(),mEnableFallback);
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}","View createUnlockScreenFor(UnlockMode unlockMode){
  if (unlockMode == UnlockMode.Pattern) {
    UnlockScreen view=new UnlockScreen(mContext,mLockPatternUtils,mUpdateMonitor,mKeyguardScreenCallback,mUpdateMonitor.getFailedAttempts());
    view.setEnableFallback(mEnableFallback);
    return view;
  }
 else   if (unlockMode == UnlockMode.SimPin) {
    return new SimUnlockScreen(mContext,mUpdateMonitor,mKeyguardScreenCallback);
  }
 else   if (unlockMode == UnlockMode.Account) {
    try {
      return new AccountUnlockScreen(mContext,mKeyguardScreenCallback,mLockPatternUtils);
    }
 catch (    IllegalStateException e) {
      Log.i(TAG,""String_Node_Str"" + ""String_Node_Str"");
      return createUnlockScreenFor(UnlockMode.Pattern);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + unlockMode);
  }
}"
23674,"/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts,boolean enableFallback){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mEnableFallback=enableFallback;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}","/** 
 * @param context The context.
 * @param lockPatternUtils Used to lookup lock pattern settings.
 * @param updateMonitor Used to lookup state affecting keyguard.
 * @param callback Used to notify the manager when we're done, etc.
 * @param totalFailedAttempts The current number of failed attempts.
 * @param enableFallback True if a backup unlock option is available when the user has forgottentheir pattern (e.g they have a google account so we can show them the account based backup option).
 */
UnlockScreen(Context context,LockPatternUtils lockPatternUtils,KeyguardUpdateMonitor updateMonitor,KeyguardScreenCallback callback,int totalFailedAttempts){
  super(context);
  mLockPatternUtils=lockPatternUtils;
  mUpdateMonitor=updateMonitor;
  mCallback=callback;
  mTotalFailedPatternAttempts=totalFailedAttempts;
  mFailedPatternAttemptsSinceLastTimeout=totalFailedAttempts % LockPatternUtils.FAILED_ATTEMPTS_BEFORE_TIMEOUT;
  if (mUpdateMonitor.isInPortrait()) {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_portrait,this,true);
  }
 else {
    LayoutInflater.from(context).inflate(R.layout.keyguard_screen_unlock_landscape,this,true);
  }
  mCarrier=(TextView)findViewById(R.id.carrier);
  mCenterDot=(TextView)findViewById(R.id.centerDot);
  mDate=(TextView)findViewById(R.id.date);
  mTime=(TextView)findViewById(R.id.time);
  mCenterDot.setText(""String_Node_Str"");
  refreshTimeAndDateDisplay();
  mStatus1=(TextView)findViewById(R.id.status1);
  mStatusSep=(TextView)findViewById(R.id.statusSep);
  mStatus2=(TextView)findViewById(R.id.status2);
  resetStatusInfo();
  mLockPatternView=(LockPatternView)findViewById(R.id.lockPattern);
  mFooterNormal=(ViewGroup)findViewById(R.id.footerNormal);
  mFooterForgotPattern=(ViewGroup)findViewById(R.id.footerForgotPattern);
  final OnClickListener emergencyClick=new OnClickListener(){
    public void onClick(    View v){
      mCallback.takeEmergencyCallAction();
    }
  }
;
  Button emergencyAlone=(Button)findViewById(R.id.emergencyCallAlone);
  emergencyAlone.setFocusable(false);
  emergencyAlone.setOnClickListener(emergencyClick);
  Button emergencyTogether=(Button)findViewById(R.id.emergencyCallTogether);
  emergencyTogether.setFocusable(false);
  emergencyTogether.setOnClickListener(emergencyClick);
  mForgotPatternButton=(Button)findViewById(R.id.forgotPattern);
  mForgotPatternButton.setText(R.string.lockscreen_forgot_pattern_button_text);
  mForgotPatternButton.setOnClickListener(new OnClickListener(){
    public void onClick(    View v){
      mCallback.forgotPattern(true);
    }
  }
);
  setDefaultTouchRecepient(mLockPatternView);
  mLockPatternView.setSaveEnabled(false);
  mLockPatternView.setFocusable(false);
  mLockPatternView.setOnPatternListener(new UnlockPatternListener());
  mLockPatternView.setInStealthMode(!mLockPatternUtils.isVisiblePatternEnabled());
  mLockPatternView.setTactileFeedbackEnabled(mLockPatternUtils.isTactileFeedbackEnabled());
  updateFooter(FooterMode.Normal);
  mCreatedInPortrait=updateMonitor.isInPortrait();
  updateMonitor.registerInfoCallback(this);
  updateMonitor.registerSimStateCallback(this);
  updateMonitor.registerConfigurationChangeCallback(this);
  setFocusableInTouchMode(true);
  mCarrier.setText(LockScreen.getCarrierString(mUpdateMonitor.getTelephonyPlmn(),mUpdateMonitor.getTelephonySpn()));
}"
23675,"/** 
 * Plays a sound effect (Key clicks, lid open/close...)
 * @param effectType The type of sound effect. One of{@link #FX_KEY_CLICK},  {@link #FX_FOCUS_NAVIGATION_UP},  {@link #FX_FOCUS_NAVIGATION_DOWN},  {@link #FX_FOCUS_NAVIGATION_LEFT},  {@link #FX_FOCUS_NAVIGATION_RIGHT},  {@link #FX_KEYPRESS_STANDARD},  {@link #FX_KEYPRESS_SPACEBAR},  {@link #FX_KEYPRESS_DELETE},  {@link #FX_KEYPRESS_RETURN},
 * @param volume Sound effect volumeNOTE: This version is for applications that have their own settings panel for enabling and controlling volume.
 */
public void playSoundEffect(int effectType,float volume){
  if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
    return;
  }
  IAudioService service=getService();
  try {
    service.playSoundEffectVolume(effectType,volume);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}","/** 
 * Plays a sound effect (Key clicks, lid open/close...)
 * @param effectType The type of sound effect. One of{@link #FX_KEY_CLICK},  {@link #FX_FOCUS_NAVIGATION_UP},  {@link #FX_FOCUS_NAVIGATION_DOWN},  {@link #FX_FOCUS_NAVIGATION_LEFT},  {@link #FX_FOCUS_NAVIGATION_RIGHT},  {@link #FX_KEYPRESS_STANDARD},  {@link #FX_KEYPRESS_SPACEBAR},  {@link #FX_KEYPRESS_DELETE},  {@link #FX_KEYPRESS_RETURN},
 * @param volume Sound effect volume.The volume value is a raw scalar so UI controls should be scaled logarithmically. If a volume of -1 is specified, the AudioManager.STREAM_MUSIC stream volume minus 3dB will be used. NOTE: This version is for applications that have their own settings panel for enabling and controlling volume.
 */
public void playSoundEffect(int effectType,float volume){
  if (effectType < 0 || effectType >= NUM_SOUND_EFFECTS) {
    return;
  }
  IAudioService service=getService();
  try {
    service.playSoundEffectVolume(effectType,volume);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"" + e);
  }
}"
23676,"private void playSoundEffect(int effectType,int volume){
synchronized (mSoundEffectsLock) {
    if (mSoundPool == null) {
      return;
    }
    if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
      float v=(float)volume / 1000.0f;
      mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1],v,v,0,0,1.0f);
    }
 else {
      MediaPlayer mediaPlayer=new MediaPlayer();
      if (mediaPlayer != null) {
        try {
          String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
          mediaPlayer.setDataSource(filePath);
          mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
          mediaPlayer.prepare();
          mediaPlayer.setOnCompletionListener(new OnCompletionListener(){
            public void onCompletion(            MediaPlayer mp){
              cleanupPlayer(mp);
            }
          }
);
          mediaPlayer.setOnErrorListener(new OnErrorListener(){
            public boolean onError(            MediaPlayer mp,            int what,            int extra){
              cleanupPlayer(mp);
              return true;
            }
          }
);
          mediaPlayer.start();
        }
 catch (        IOException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalArgumentException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalStateException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
      }
    }
  }
}","private void playSoundEffect(int effectType,int volume){
synchronized (mSoundEffectsLock) {
    if (mSoundPool == null) {
      return;
    }
    float volFloat;
    if (volume < 0) {
      float dBPerStep=(float)((0.5 * 100) / MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]);
      int musicVolIndex=(mStreamStates[AudioSystem.STREAM_MUSIC].mIndex + 5) / 10;
      float musicVoldB=dBPerStep * (musicVolIndex - MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC]);
      volFloat=(float)Math.pow(10,(musicVoldB - 3) / 20);
    }
 else {
      volFloat=(float)volume / 1000.0f;
    }
    if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
      mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1],volFloat,volFloat,0,0,1.0f);
    }
 else {
      MediaPlayer mediaPlayer=new MediaPlayer();
      if (mediaPlayer != null) {
        try {
          String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effectType][0]];
          mediaPlayer.setDataSource(filePath);
          mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
          mediaPlayer.prepare();
          mediaPlayer.setVolume(volFloat,volFloat);
          mediaPlayer.setOnCompletionListener(new OnCompletionListener(){
            public void onCompletion(            MediaPlayer mp){
              cleanupPlayer(mp);
            }
          }
);
          mediaPlayer.setOnErrorListener(new OnErrorListener(){
            public boolean onError(            MediaPlayer mp,            int what,            int extra){
              cleanupPlayer(mp);
              return true;
            }
          }
);
          mediaPlayer.start();
        }
 catch (        IOException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalArgumentException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
catch (        IllegalStateException ex) {
          Log.w(TAG,""String_Node_Str"" + ex);
        }
      }
    }
  }
}"
23677,"/** 
 * Loads samples into the soundpool. This method must be called at when sound effects are enabled
 */
public boolean loadSoundEffects(){
synchronized (mSoundEffectsLock) {
    mSoundPool=new SoundPool(NUM_SOUNDPOOL_CHANNELS,AudioSystem.STREAM_SYSTEM,0);
    if (mSoundPool == null) {
      return false;
    }
    int[] poolId=new int[SOUND_EFFECT_FILES.length];
    for (int fileIdx=0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
      poolId[fileIdx]=-1;
    }
    for (int effect=0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
      if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
        continue;
      }
      if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
        String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
        int sampleId=mSoundPool.load(filePath,0);
        SOUND_EFFECT_FILES_MAP[effect][1]=sampleId;
        poolId[SOUND_EFFECT_FILES_MAP[effect][0]]=sampleId;
        if (sampleId <= 0) {
          Log.w(TAG,""String_Node_Str"" + filePath);
        }
      }
 else {
        SOUND_EFFECT_FILES_MAP[effect][1]=poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
      }
    }
  }
  return true;
}","/** 
 * Loads samples into the soundpool. This method must be called at when sound effects are enabled
 */
public boolean loadSoundEffects(){
synchronized (mSoundEffectsLock) {
    if (mSoundPool != null) {
      return true;
    }
    mSoundPool=new SoundPool(NUM_SOUNDPOOL_CHANNELS,AudioSystem.STREAM_SYSTEM,0);
    if (mSoundPool == null) {
      return false;
    }
    int[] poolId=new int[SOUND_EFFECT_FILES.length];
    for (int fileIdx=0; fileIdx < SOUND_EFFECT_FILES.length; fileIdx++) {
      poolId[fileIdx]=-1;
    }
    for (int effect=0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
      if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
        continue;
      }
      if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
        String filePath=Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES[SOUND_EFFECT_FILES_MAP[effect][0]];
        int sampleId=mSoundPool.load(filePath,0);
        SOUND_EFFECT_FILES_MAP[effect][1]=sampleId;
        poolId[SOUND_EFFECT_FILES_MAP[effect][0]]=sampleId;
        if (sampleId <= 0) {
          Log.w(TAG,""String_Node_Str"" + filePath);
        }
      }
 else {
        SOUND_EFFECT_FILES_MAP[effect][1]=poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
      }
    }
  }
  return true;
}"
23678,"/** 
 * @see AudioManager#playSoundEffect(int,float) 
 */
public void playSoundEffectVolume(int effectType,float volume){
  sendMsg(mAudioHandler,MSG_PLAY_SOUND_EFFECT,SHARED_MSG,SENDMSG_NOOP,effectType,(int)(volume * 1000),null,0);
}","/** 
 * @see AudioManager#playSoundEffect(int,float) 
 */
public void playSoundEffectVolume(int effectType,float volume){
  loadSoundEffects();
  sendMsg(mAudioHandler,MSG_PLAY_SOUND_EFFECT,SHARED_MSG,SENDMSG_NOOP,effectType,(int)(volume * 1000),null,0);
}"
23679,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}"
23680,"/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      pi.activities=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      pi.receivers=new ActivityInfo[N];
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      pi.services=new ServiceInfo[N];
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      pi.providers=new ProviderInfo[N];
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}","/** 
 * Generate and return the   {@link PackageInfo} for a parsed package.
 * @param p the parsed package.
 * @param flags indicating which optional information is included.
 */
public static PackageInfo generatePackageInfo(PackageParser.Package p,int gids[],int flags){
  PackageInfo pi=new PackageInfo();
  pi.packageName=p.packageName;
  pi.versionCode=p.mVersionCode;
  pi.versionName=p.mVersionName;
  pi.sharedUserId=p.mSharedUserId;
  pi.sharedUserLabel=p.mSharedUserLabel;
  pi.applicationInfo=p.applicationInfo;
  if ((flags & PackageManager.GET_GIDS) != 0) {
    pi.gids=gids;
  }
  if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
    int N=p.configPreferences.size();
    if (N > 0) {
      pi.configPreferences=new ConfigurationInfo[N];
      p.configPreferences.toArray(pi.configPreferences);
    }
    N=p.reqFeatures != null ? p.reqFeatures.size() : 0;
    if (N > 0) {
      pi.reqFeatures=new FeatureInfo[N];
      p.reqFeatures.toArray(pi.reqFeatures);
    }
  }
  if ((flags & PackageManager.GET_ACTIVITIES) != 0) {
    int N=p.activities.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.activities=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.activities.get(i).info.enabled)           num++;
        }
        pi.activities=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.activities.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.activities[i]=generateActivityInfo(p.activities.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_RECEIVERS) != 0) {
    int N=p.receivers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.receivers=new ActivityInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.receivers.get(i).info.enabled)           num++;
        }
        pi.receivers=new ActivityInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Activity activity=p.receivers.get(i);
        if (activity.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.receivers[i]=generateActivityInfo(p.receivers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_SERVICES) != 0) {
    int N=p.services.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.services=new ServiceInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.services.get(i).info.enabled)           num++;
        }
        pi.services=new ServiceInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Service service=p.services.get(i);
        if (service.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.services[i]=generateServiceInfo(p.services.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_PROVIDERS) != 0) {
    int N=p.providers.size();
    if (N > 0) {
      if ((flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
        pi.providers=new ProviderInfo[N];
      }
 else {
        int num=0;
        for (int i=0; i < N; i++) {
          if (p.providers.get(i).info.enabled)           num++;
        }
        pi.providers=new ProviderInfo[num];
      }
      for (int i=0; i < N; i++) {
        final Provider provider=p.providers.get(i);
        if (provider.info.enabled || (flags & PackageManager.GET_DISABLED_COMPONENTS) != 0) {
          pi.providers[i]=generateProviderInfo(p.providers.get(i),flags);
        }
      }
    }
  }
  if ((flags & PackageManager.GET_INSTRUMENTATION) != 0) {
    int N=p.instrumentation.size();
    if (N > 0) {
      pi.instrumentation=new InstrumentationInfo[N];
      for (int i=0; i < N; i++) {
        pi.instrumentation[i]=generateInstrumentationInfo(p.instrumentation.get(i),flags);
      }
    }
  }
  if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
    int N=p.permissions.size();
    if (N > 0) {
      pi.permissions=new PermissionInfo[N];
      for (int i=0; i < N; i++) {
        pi.permissions[i]=generatePermissionInfo(p.permissions.get(i),flags);
      }
    }
    N=p.requestedPermissions.size();
    if (N > 0) {
      pi.requestedPermissions=new String[N];
      for (int i=0; i < N; i++) {
        pi.requestedPermissions[i]=p.requestedPermissions.get(i);
      }
    }
  }
  if ((flags & PackageManager.GET_SIGNATURES) != 0) {
    if (p.mSignatures != null) {
      int N=p.mSignatures.length;
      if (N > 0) {
        pi.signatures=new Signature[N];
        System.arraycopy(p.mSignatures,0,pi.signatures,0,N);
      }
    }
  }
  return pi;
}"
23681,"public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}","public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mTextPaint.setCompatibilityScaling(getResources().getCompatibilityInfo().applicationScale);
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mHighlightPaint.setCompatibilityScaling(getResources().getCompatibilityInfo().applicationScale);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}"
23682,"public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.release();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}","public void die(boolean immediate){
  if (immediate) {
    doDie();
  }
 else {
    sendEmptyMessage(DIE);
  }
}"
23683,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}"
23684,"int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}","int adjustWallpaperWindowsLocked(){
  int changed=0;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  WindowState topCurW=null;
  int topCurI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
      if (topCurW == null) {
        topCurW=w;
        topCurI=i;
      }
      continue;
    }
    topCurW=null;
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        topCurW=null;
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && ((w.mAppToken != null && w.mAppToken.animation != null) || w.mAnimation != null)) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return 0;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && oldW != null) {
      boolean oldAnim=oldW.mAnimation != null || (oldW.mAppToken != null && oldW.mAppToken.animation != null);
      boolean foundAnim=foundW.mAnimation != null || (foundW.mAppToken != null && foundW.mAppToken.animation != null);
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundAnim + ""String_Node_Str""+ oldAnim);
      }
      if (foundAnim && oldAnim) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken != null && foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else   if (mLowerWallpaperTarget != null) {
    boolean lowerAnimating=mLowerWallpaperTarget.mAnimation != null || (mLowerWallpaperTarget.mAppToken != null && mLowerWallpaperTarget.mAppToken.animation != null);
    boolean upperAnimating=mUpperWallpaperTarget.mAnimation != null || (mUpperWallpaperTarget.mAppToken != null && mUpperWallpaperTarget.mAppToken.animation != null);
    if (!lowerAnimating || !upperAnimating) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=isWallpaperVisible(foundW);
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    final int maxLayer=mPolicy.getMaxWallpaperLayer() * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mBaseLayer < maxLayer && wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
 else {
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"");
  }
  if (foundW == null && topCurW != null) {
    foundW=topCurW;
    foundI=topCurI + 1;
  }
 else {
    foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  }
  if (visible) {
    mLastWallpaperX=mWallpaperTarget.mWallpaperX;
    mLastWallpaperY=mWallpaperTarget.mWallpaperY;
  }
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    if (token.hidden == visible) {
      changed|=ADJUST_WALLPAPER_VISIBILITY_CHANGED;
      token.hidden=!visible;
      mLayoutNeeded=true;
    }
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(wallpaper,dw,dh,false);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        if (DEBUG_WINDOW_MOVEMENT)         Log.v(TAG,""String_Node_Str"" + oldIndex + ""String_Node_Str""+ wallpaper);
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER || DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed|=ADJUST_WALLPAPER_LAYERS_CHANGED;
    }
  }
  return changed;
}"
23685,"/** 
 * Called when the system is mostly done booting to dentermine whether the system should go into safe mode.
 */
public boolean detectSafeMode();","/** 
 * Called when the system is mostly done booting to determine whether the system should go into safe mode.
 */
public boolean detectSafeMode();"
23686,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}"
23687,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}"
23688,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}"
23689,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}"
23690,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDisplayedLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDisplayedLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDisplayedLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}"
23691,"Element(){
  super(null);
  mID=0;
  mSize=0;
}","Element(RenderScript rs,int count){
  super(rs);
  mSize=0;
  mEntries=new Entry[count];
}"
23692,"public Element create(){
  Element e=new Element();
  e.mEntries=new Entry[mEntryCount];
  java.lang.System.arraycopy(mEntries,0,e.mEntries,0,mEntryCount);
  e.init(mRS);
  return e;
}","public Element create(){
  Element e=new Element(mRS,mEntryCount);
  java.lang.System.arraycopy(mEntries,0,e.mEntries,0,mEntryCount);
  e.init();
  return e;
}"
23693,"void init(RenderScript rs){
  mRS=rs;
  internalCreate(mRS,this);
}","void init(){
  internalCreate(mRS,this);
}"
23694,"static void initPredefined(RenderScript rs){
  USER_U8.mEntries=new Entry[1];
  USER_U8.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,8,null);
  USER_U8.init(rs);
  USER_I8.mEntries=new Entry[1];
  USER_I8.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,8,null);
  USER_I8.init(rs);
  USER_U16.mEntries=new Entry[1];
  USER_U16.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,16,null);
  USER_U16.init(rs);
  USER_I16.mEntries=new Entry[1];
  USER_I16.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,16,null);
  USER_I16.init(rs);
  USER_U32.mEntries=new Entry[1];
  USER_U32.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.USER,false,32,null);
  USER_U32.init(rs);
  USER_I32.mEntries=new Entry[1];
  USER_I32.mEntries[0]=new Entry(DataType.SIGNED,DataKind.USER,false,32,null);
  USER_I32.init(rs);
  USER_FLOAT.mEntries=new Entry[1];
  USER_FLOAT.mEntries[0]=new Entry(DataType.FLOAT,DataKind.USER,false,32,null);
  USER_FLOAT.init(rs);
  A_8.mEntries=new Entry[1];
  A_8.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,8,""String_Node_Str"");
  A_8.init(rs);
  RGB_565.mEntries=new Entry[3];
  RGB_565.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,5,""String_Node_Str"");
  RGB_565.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,6,""String_Node_Str"");
  RGB_565.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,5,""String_Node_Str"");
  RGB_565.init(rs);
  RGB_888.mEntries=new Entry[3];
  RGB_888.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,8,""String_Node_Str"");
  RGB_888.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,8,""String_Node_Str"");
  RGB_888.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,8,""String_Node_Str"");
  RGB_888.init(rs);
  RGBA_5551.mEntries=new Entry[4];
  RGBA_5551.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,5,""String_Node_Str"");
  RGBA_5551.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,1,""String_Node_Str"");
  RGBA_5551.init(rs);
  RGBA_4444.mEntries=new Entry[4];
  RGBA_4444.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,4,""String_Node_Str"");
  RGBA_4444.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,4,""String_Node_Str"");
  RGBA_4444.init(rs);
  RGBA_8888.mEntries=new Entry[4];
  RGBA_8888.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.RED,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[1]=new Entry(DataType.UNSIGNED,DataKind.GREEN,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[2]=new Entry(DataType.UNSIGNED,DataKind.BLUE,true,8,""String_Node_Str"");
  RGBA_8888.mEntries[3]=new Entry(DataType.UNSIGNED,DataKind.ALPHA,true,8,""String_Node_Str"");
  RGBA_8888.init(rs);
  INDEX_16.mEntries=new Entry[1];
  INDEX_16.mEntries[0]=new Entry(DataType.UNSIGNED,DataKind.INDEX,false,16,""String_Node_Str"");
  INDEX_16.init(rs);
  XY_F32.mEntries=new Entry[2];
  XY_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  XY_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  XY_F32.init(rs);
  XYZ_F32.mEntries=new Entry[3];
  XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  XYZ_F32.init(rs);
  ST_XY_F32.mEntries=new Entry[4];
  ST_XY_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  ST_XY_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  ST_XY_F32.init(rs);
  ST_XYZ_F32.mEntries=new Entry[5];
  ST_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  ST_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  ST_XYZ_F32.init(rs);
  NORM_XYZ_F32.mEntries=new Entry[6];
  NORM_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.NX,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.NY,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.NZ,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  NORM_XYZ_F32.mEntries[5]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  NORM_XYZ_F32.init(rs);
  NORM_ST_XYZ_F32.mEntries=new Entry[8];
  NORM_ST_XYZ_F32.mEntries[0]=new Entry(DataType.FLOAT,DataKind.NX,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[1]=new Entry(DataType.FLOAT,DataKind.NY,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[2]=new Entry(DataType.FLOAT,DataKind.NZ,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[3]=new Entry(DataType.FLOAT,DataKind.S,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[4]=new Entry(DataType.FLOAT,DataKind.T,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[5]=new Entry(DataType.FLOAT,DataKind.X,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[6]=new Entry(DataType.FLOAT,DataKind.Y,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.mEntries[7]=new Entry(DataType.FLOAT,DataKind.Z,false,32,""String_Node_Str"");
  NORM_ST_XYZ_F32.init(rs);
  rs.nInitElements(A_8.mID,RGBA_4444.mID,RGBA_8888.mID,RGB_565.mID);
}","static void initPredefined(RenderScript rs){
  rs.nInitElements(A_8(rs).mID,RGBA_4444(rs).mID,RGBA_8888(rs).mID,RGB_565(rs).mID);
}"
23695,"public MatrixAllocation(RenderScript rs){
  mModel=new Matrix();
  mProjection=new Matrix();
  mTexture=new Matrix();
  mAlloc=Allocation.createSized(rs,Element.USER_FLOAT,48);
  mAlloc.subData1D(MODELVIEW_OFFSET,16,mModel.mMat);
  mAlloc.subData1D(PROJECTION_OFFSET,16,mProjection.mMat);
  mAlloc.subData1D(TEXTURE_OFFSET,16,mTexture.mMat);
}","public MatrixAllocation(RenderScript rs){
  mModel=new Matrix();
  mProjection=new Matrix();
  mTexture=new Matrix();
  mAlloc=Allocation.createSized(rs,Element.USER_F32(rs),48);
  mAlloc.subData1D(MODELVIEW_OFFSET,16,mModel.mMat);
  mAlloc.subData1D(PROJECTION_OFFSET,16,mProjection.mMat);
  mAlloc.subData1D(TEXTURE_OFFSET,16,mTexture.mMat);
}"
23696,"public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  if (!mElementsInitialized) {
    Element.initPredefined(this);
    mElementsInitialized=true;
  }
}","public RenderScript(Surface sur,boolean useDepth,boolean forceSW){
  mSurface=sur;
  mDev=nDeviceCreate();
  if (forceSW) {
    nDeviceSetConfig(mDev,0,1);
  }
  mContext=nContextCreate(mDev,mSurface,0,useDepth);
  Element.initPredefined(this);
}"
23697,"public SimpleMesh create(){
  Element.Builder b=new Element.Builder(mRS);
  int floatCount=mVtxSize;
  if (mVtxSize == 2) {
    b.addFloatXY();
  }
 else {
    b.addFloatXYZ();
  }
  if (mTex) {
    floatCount+=2;
    b.addFloatST();
  }
  if (mNorm) {
    floatCount+=3;
    b.addFloatNorm();
  }
  mElement=b.create();
  Builder smb=new Builder(mRS);
  smb.addVertexType(mElement,mVtxCount / floatCount);
  smb.setIndexType(Element.INDEX_16,mIndexCount);
  smb.setPrimitive(Primitive.TRIANGLE);
  SimpleMesh sm=smb.create();
  Allocation vertexAlloc=sm.createVertexAllocation(0);
  Allocation indexAlloc=sm.createIndexAllocation();
  sm.bindVertexAllocation(vertexAlloc,0);
  sm.bindIndexAllocation(indexAlloc);
  vertexAlloc.data(mVtxData);
  vertexAlloc.uploadToBufferObject();
  indexAlloc.data(mIndexData);
  indexAlloc.uploadToBufferObject();
  return sm;
}","public SimpleMesh create(){
  Element.Builder b=new Element.Builder(mRS);
  int floatCount=mVtxSize;
  if (mVtxSize == 2) {
    b.addFloatXY();
  }
 else {
    b.addFloatXYZ();
  }
  if (mTex) {
    floatCount+=2;
    b.addFloatST();
  }
  if (mNorm) {
    floatCount+=3;
    b.addFloatNorm();
  }
  mElement=b.create();
  Builder smb=new Builder(mRS);
  smb.addVertexType(mElement,mVtxCount / floatCount);
  smb.setIndexType(Element.INDEX_16(mRS),mIndexCount);
  smb.setPrimitive(Primitive.TRIANGLE);
  SimpleMesh sm=smb.create();
  Allocation vertexAlloc=sm.createVertexAllocation(0);
  Allocation indexAlloc=sm.createIndexAllocation();
  sm.bindVertexAllocation(vertexAlloc,0);
  sm.bindIndexAllocation(indexAlloc);
  vertexAlloc.data(mVtxData);
  vertexAlloc.uploadToBufferObject();
  indexAlloc.data(mIndexData);
  indexAlloc.uploadToBufferObject();
  return sm;
}"
23698,"public void add(Dimension d,int value){
  if (mEntries.length >= mEntryCount) {
    Entry[] en=new Entry[mEntryCount + 8];
    System.arraycopy(mEntries,0,en,0,mEntries.length);
    mEntries=en;
  }
  mEntries[mEntryCount]=new Entry();
  mEntries[mEntryCount].mDim=d;
  mEntries[mEntryCount].mValue=value;
  mEntryCount++;
}","public void add(Dimension d,int value){
  if (value < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (mEntries.length >= mEntryCount) {
    Entry[] en=new Entry[mEntryCount + 8];
    System.arraycopy(mEntries,0,en,0,mEntries.length);
    mEntries=en;
  }
  mEntries[mEntryCount]=new Entry();
  mEntries[mEntryCount].mDim=d;
  mEntries[mEntryCount].mValue=value;
  mEntryCount++;
}"
23699,"public Builder(RenderScript rs,Element e){
  mRS=rs;
  mEntries=new Entry[4];
  mElement=e;
}","public Builder(RenderScript rs,Element e){
  if (e.mID == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mRS=rs;
  mEntries=new Entry[4];
  mElement=e;
}"
23700,"private void loadImages(){
  mBufferIDs=new int[13];
  mImages=new Allocation[13];
  mAllocIDs=Allocation.createSized(mRS,Element.USER_FLOAT,mBufferIDs.length);
  Element ie=Element.RGB_565;
  mImages[0]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p01,ie,true);
  mImages[1]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p02,ie,true);
  mImages[2]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p03,ie,true);
  mImages[3]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p04,ie,true);
  mImages[4]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p05,ie,true);
  mImages[5]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p06,ie,true);
  mImages[6]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p07,ie,true);
  mImages[7]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p08,ie,true);
  mImages[8]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p09,ie,true);
  mImages[9]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p10,ie,true);
  mImages[10]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p11,ie,true);
  mImages[11]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p12,ie,true);
  mImages[12]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p13,ie,true);
  int black[]=new int[1024];
  for (int ct=0; ct < mImages.length; ct++) {
    Allocation.Adapter2D a=mImages[ct].createAdapter2D();
    int size=512;
    int mip=0;
    while (size >= 2) {
      a.subData(0,0,2,size,black);
      a.subData(size - 2,0,2,size,black);
      a.subData(0,0,size,2,black);
      a.subData(0,size - 2,size,2,black);
      size>>=1;
      mip++;
      a.setConstraint(Dimension.LOD,mip);
    }
    mImages[ct].uploadToTexture(1);
    mBufferIDs[ct]=mImages[ct].getID();
  }
  mAllocIDs.data(mBufferIDs);
}","private void loadImages(){
  mBufferIDs=new int[13];
  mImages=new Allocation[13];
  mAllocIDs=Allocation.createSized(mRS,Element.USER_F32(mRS),mBufferIDs.length);
  Element ie=Element.RGB_565(mRS);
  mImages[0]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p01,ie,true);
  mImages[1]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p02,ie,true);
  mImages[2]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p03,ie,true);
  mImages[3]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p04,ie,true);
  mImages[4]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p05,ie,true);
  mImages[5]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p06,ie,true);
  mImages[6]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p07,ie,true);
  mImages[7]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p08,ie,true);
  mImages[8]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p09,ie,true);
  mImages[9]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p10,ie,true);
  mImages[10]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p11,ie,true);
  mImages[11]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p12,ie,true);
  mImages[12]=Allocation.createFromBitmapResourceBoxed(mRS,mRes,R.drawable.p13,ie,true);
  int black[]=new int[1024];
  for (int ct=0; ct < mImages.length; ct++) {
    Allocation.Adapter2D a=mImages[ct].createAdapter2D();
    int size=512;
    int mip=0;
    while (size >= 2) {
      a.subData(0,0,2,size,black);
      a.subData(size - 2,0,2,size,black);
      a.subData(0,0,size,2,black);
      a.subData(0,size - 2,size,2,black);
      size>>=1;
      mip++;
      a.setConstraint(Dimension.LOD,mip);
    }
    mImages[ct].uploadToTexture(1);
    mBufferIDs[ct]=mImages[ct].getID();
  }
  mAllocIDs.data(mBufferIDs);
}"
23701,"private void initState(){
  mBufferState=new int[10];
  mAllocState=Allocation.createSized(mRS,Element.USER_FLOAT,mBufferState.length);
  mBufferState[STATE_LAST_FOCUS]=-1;
  mAllocState.data(mBufferState);
}","private void initState(){
  mBufferState=new int[10];
  mAllocState=Allocation.createSized(mRS,Element.USER_F32(mRS),mBufferState.length);
  mBufferState[STATE_LAST_FOCUS]=-1;
  mAllocState.data(mBufferState);
}"
23702,"private void initRS(){
  mFSM=new FilmStripMesh();
  mMesh=mFSM.init(mRS);
  mMesh.setName(""String_Node_Str"");
  initPFS();
  initPF();
  initPV();
  Log.e(""String_Node_Str"",""String_Node_Str"");
  mStripPositionType=Type.createFromClass(mRS,StripPosition.class,1);
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.filmstrip);
  sb.setRoot(true);
  sb.setType(mStripPositionType,""String_Node_Str"",1);
  mScriptStrip=sb.create();
  mScriptStrip.setClearColor(0.0f,0.0f,0.0f,1.0f);
  mAllocPos=Allocation.createTyped(mRS,mStripPositionType);
  loadImages();
  initState();
  mPVA=new ProgramVertex.MatrixAllocation(mRS);
  mPVBackground.bindAllocation(mPVA);
  mPVImages.bindAllocation(mPVA);
  mPVA.setupProjectionNormalized(320,480);
  mScriptStrip.bindAllocation(mAllocIDs,0);
  mScriptStrip.bindAllocation(mAllocPos,1);
  mScriptStrip.bindAllocation(mAllocState,2);
  mScriptStrip.bindAllocation(mPVA.mAlloc,3);
  mAllocOffsets=Allocation.createSized(mRS,Element.USER_I32,mFSM.mTriangleOffsets.length);
  mAllocOffsets.data(mFSM.mTriangleOffsets);
  mScriptStrip.bindAllocation(mAllocOffsets,4);
  mAllocOffsetsTex=Allocation.createSized(mRS,Element.USER_FLOAT,mFSM.mTriangleOffsetsTex.length);
  mAllocOffsetsTex.data(mFSM.mTriangleOffsetsTex);
  mScriptStrip.bindAllocation(mAllocOffsetsTex,5);
  setFilmStripPosition(0,0);
  mRS.contextBindRootScript(mScriptStrip);
}","private void initRS(){
  mFSM=new FilmStripMesh();
  mMesh=mFSM.init(mRS);
  mMesh.setName(""String_Node_Str"");
  initPFS();
  initPF();
  initPV();
  Log.e(""String_Node_Str"",""String_Node_Str"");
  mStripPositionType=Type.createFromClass(mRS,StripPosition.class,1);
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.filmstrip);
  sb.setRoot(true);
  sb.setType(mStripPositionType,""String_Node_Str"",1);
  mScriptStrip=sb.create();
  mScriptStrip.setClearColor(0.0f,0.0f,0.0f,1.0f);
  mAllocPos=Allocation.createTyped(mRS,mStripPositionType);
  loadImages();
  initState();
  mPVA=new ProgramVertex.MatrixAllocation(mRS);
  mPVBackground.bindAllocation(mPVA);
  mPVImages.bindAllocation(mPVA);
  mPVA.setupProjectionNormalized(320,480);
  mScriptStrip.bindAllocation(mAllocIDs,0);
  mScriptStrip.bindAllocation(mAllocPos,1);
  mScriptStrip.bindAllocation(mAllocState,2);
  mScriptStrip.bindAllocation(mPVA.mAlloc,3);
  mAllocOffsets=Allocation.createSized(mRS,Element.USER_I32(mRS),mFSM.mTriangleOffsets.length);
  mAllocOffsets.data(mFSM.mTriangleOffsets);
  mScriptStrip.bindAllocation(mAllocOffsets,4);
  mAllocOffsetsTex=Allocation.createSized(mRS,Element.USER_F32(mRS),mFSM.mTriangleOffsetsTex.length);
  mAllocOffsetsTex.data(mFSM.mTriangleOffsetsTex);
  mScriptStrip.bindAllocation(mAllocOffsetsTex,5);
  setFilmStripPosition(0,0);
  mRS.contextBindRootScript(mScriptStrip);
}"
23703,"private void initNamed(){
  Sampler.Builder sb=new Sampler.Builder(mRS);
  sb.setMin(Sampler.Value.LINEAR);
  sb.setMag(Sampler.Value.LINEAR);
  sb.setWrapS(Sampler.Value.CLAMP);
  sb.setWrapT(Sampler.Value.CLAMP);
  mSampler=sb.create();
  sb.setMin(Sampler.Value.NEAREST);
  sb.setMag(Sampler.Value.NEAREST);
  mSamplerText=sb.create();
  ProgramFragment.Builder bf=new ProgramFragment.Builder(mRS,null,null);
  bf.setTexEnable(true,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFImages=bf.create();
  mPFImages.setName(""String_Node_Str"");
  mPFImages.bindSampler(mSampler,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFText=bf.create();
  mPFText.setName(""String_Node_Str"");
  mPFText.bindSampler(mSamplerText,0);
  ProgramStore.Builder bs=new ProgramStore.Builder(mRS,null,null);
  bs.setDepthFunc(ProgramStore.DepthFunc.LESS);
  bs.setDitherEnable(false);
  bs.setDepthMask(true);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSBackground=bs.create();
  mPSBackground.setName(""String_Node_Str"");
  bs.setDepthFunc(ProgramStore.DepthFunc.ALWAYS);
  bs.setDepthMask(false);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSText=bs.create();
  mPSText.setName(""String_Node_Str"");
  mPVAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVAlloc.setupProjectionNormalized(mWidth,mHeight);
  ProgramVertex.Builder pvb=new ProgramVertex.Builder(mRS,null,null);
  mPV=pvb.create();
  mPV.setName(""String_Node_Str"");
  mPV.bindAllocation(mPVAlloc);
  mPVOrthoAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVOrthoAlloc.setupOrthoWindow(mWidth,mHeight);
  pvb.setTextureMatrixEnable(true);
  mPVOrtho=pvb.create();
  mPVOrtho.setName(""String_Node_Str"");
  mPVOrtho.bindAllocation(mPVOrthoAlloc);
  mRS.contextBindProgramVertex(mPV);
  mAllocScratchBuf=new int[32];
  mAllocScratch=Allocation.createSized(mRS,Element.USER_I32,mAllocScratchBuf.length);
  mAllocScratch.data(mAllocScratchBuf);
  Log.e(""String_Node_Str"",""String_Node_Str"");
{
    mIcons=new Allocation[29];
    mAllocIconIDBuf=new int[mIcons.length];
    mAllocIconID=Allocation.createSized(mRS,Element.USER_I32,mAllocIconIDBuf.length);
    mLabels=new Allocation[29];
    mAllocLabelIDBuf=new int[mLabels.length];
    mAllocLabelID=Allocation.createSized(mRS,Element.USER_I32,mLabels.length);
    Element ie8888=Element.RGBA_8888;
    mIcons[0]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.browser,ie8888,true);
    mIcons[1]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.market,ie8888,true);
    mIcons[2]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.photos,ie8888,true);
    mIcons[3]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.settings,ie8888,true);
    mIcons[4]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.calendar,ie8888,true);
    mIcons[5]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g1155,ie8888,true);
    mIcons[6]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g2140,ie8888,true);
    mIcons[7]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.maps,ie8888,true);
    mIcons[8]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path431,ie8888,true);
    mIcons[9]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path676,ie8888,true);
    mIcons[10]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path754,ie8888,true);
    mIcons[11]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path815,ie8888,true);
    mIcons[12]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1920,ie8888,true);
    mIcons[13]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1927,ie8888,true);
    mIcons[14]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3099,ie8888,true);
    mIcons[15]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3950,ie8888,true);
    mIcons[16]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path4481,ie8888,true);
    mIcons[17]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path5168,ie8888,true);
    mIcons[18]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.polygon2408,ie8888,true);
    mLabels[0]=makeTextBitmap(""String_Node_Str"");
    mLabels[1]=makeTextBitmap(""String_Node_Str"");
    mLabels[2]=makeTextBitmap(""String_Node_Str"");
    mLabels[3]=makeTextBitmap(""String_Node_Str"");
    mLabels[4]=makeTextBitmap(""String_Node_Str"");
    mLabels[5]=makeTextBitmap(""String_Node_Str"");
    mLabels[6]=makeTextBitmap(""String_Node_Str"");
    mLabels[7]=makeTextBitmap(""String_Node_Str"");
    mLabels[8]=makeTextBitmap(""String_Node_Str"");
    mLabels[9]=makeTextBitmap(""String_Node_Str"");
    mLabels[10]=makeTextBitmap(""String_Node_Str"");
    mLabels[11]=makeTextBitmap(""String_Node_Str"");
    mLabels[12]=makeTextBitmap(""String_Node_Str"");
    mLabels[13]=makeTextBitmap(""String_Node_Str"");
    mLabels[14]=makeTextBitmap(""String_Node_Str"");
    mLabels[15]=makeTextBitmap(""String_Node_Str"");
    mLabels[16]=makeTextBitmap(""String_Node_Str"");
    mLabels[17]=makeTextBitmap(""String_Node_Str"");
    mLabels[18]=makeTextBitmap(""String_Node_Str"");
    mIcons[19]=mIcons[0];
    mIcons[20]=mIcons[1];
    mIcons[21]=mIcons[2];
    mIcons[22]=mIcons[3];
    mIcons[23]=mIcons[4];
    mIcons[24]=mIcons[5];
    mIcons[25]=mIcons[6];
    mIcons[26]=mIcons[7];
    mIcons[27]=mIcons[8];
    mIcons[28]=mIcons[9];
    mLabels[19]=mLabels[0];
    mLabels[20]=mLabels[1];
    mLabels[21]=mLabels[2];
    mLabels[22]=mLabels[3];
    mLabels[23]=mLabels[4];
    mLabels[24]=mLabels[5];
    mLabels[25]=mLabels[6];
    mLabels[26]=mLabels[7];
    mLabels[27]=mLabels[8];
    mLabels[28]=mLabels[9];
    for (int ct=0; ct < mIcons.length; ct++) {
      mIcons[ct].uploadToTexture(0);
      mLabels[ct].uploadToTexture(0);
      mAllocIconIDBuf[ct]=mIcons[ct].getID();
      mAllocLabelIDBuf[ct]=mLabels[ct].getID();
    }
    mAllocIconID.data(mAllocIconIDBuf);
    mAllocLabelID.data(mAllocLabelIDBuf);
  }
}","private void initNamed(){
  Sampler.Builder sb=new Sampler.Builder(mRS);
  sb.setMin(Sampler.Value.LINEAR);
  sb.setMag(Sampler.Value.LINEAR);
  sb.setWrapS(Sampler.Value.CLAMP);
  sb.setWrapT(Sampler.Value.CLAMP);
  mSampler=sb.create();
  sb.setMin(Sampler.Value.NEAREST);
  sb.setMag(Sampler.Value.NEAREST);
  mSamplerText=sb.create();
  ProgramFragment.Builder bf=new ProgramFragment.Builder(mRS,null,null);
  bf.setTexEnable(true,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFImages=bf.create();
  mPFImages.setName(""String_Node_Str"");
  mPFImages.bindSampler(mSampler,0);
  bf.setTexEnvMode(ProgramFragment.EnvMode.MODULATE,0);
  mPFText=bf.create();
  mPFText.setName(""String_Node_Str"");
  mPFText.bindSampler(mSamplerText,0);
  ProgramStore.Builder bs=new ProgramStore.Builder(mRS,null,null);
  bs.setDepthFunc(ProgramStore.DepthFunc.LESS);
  bs.setDitherEnable(false);
  bs.setDepthMask(true);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSBackground=bs.create();
  mPSBackground.setName(""String_Node_Str"");
  bs.setDepthFunc(ProgramStore.DepthFunc.ALWAYS);
  bs.setDepthMask(false);
  bs.setBlendFunc(ProgramStore.BlendSrcFunc.SRC_ALPHA,ProgramStore.BlendDstFunc.ONE_MINUS_SRC_ALPHA);
  mPSText=bs.create();
  mPSText.setName(""String_Node_Str"");
  mPVAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVAlloc.setupProjectionNormalized(mWidth,mHeight);
  ProgramVertex.Builder pvb=new ProgramVertex.Builder(mRS,null,null);
  mPV=pvb.create();
  mPV.setName(""String_Node_Str"");
  mPV.bindAllocation(mPVAlloc);
  mPVOrthoAlloc=new ProgramVertex.MatrixAllocation(mRS);
  mPVOrthoAlloc.setupOrthoWindow(mWidth,mHeight);
  pvb.setTextureMatrixEnable(true);
  mPVOrtho=pvb.create();
  mPVOrtho.setName(""String_Node_Str"");
  mPVOrtho.bindAllocation(mPVOrthoAlloc);
  mRS.contextBindProgramVertex(mPV);
  mAllocScratchBuf=new int[32];
  mAllocScratch=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocScratchBuf.length);
  mAllocScratch.data(mAllocScratchBuf);
  Log.e(""String_Node_Str"",""String_Node_Str"");
{
    mIcons=new Allocation[29];
    mAllocIconIDBuf=new int[mIcons.length];
    mAllocIconID=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocIconIDBuf.length);
    mLabels=new Allocation[29];
    mAllocLabelIDBuf=new int[mLabels.length];
    mAllocLabelID=Allocation.createSized(mRS,Element.USER_I32(mRS),mLabels.length);
    Element ie8888=Element.RGBA_8888(mRS);
    mIcons[0]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.browser,ie8888,true);
    mIcons[1]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.market,ie8888,true);
    mIcons[2]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.photos,ie8888,true);
    mIcons[3]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.settings,ie8888,true);
    mIcons[4]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.calendar,ie8888,true);
    mIcons[5]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g1155,ie8888,true);
    mIcons[6]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.g2140,ie8888,true);
    mIcons[7]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.maps,ie8888,true);
    mIcons[8]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path431,ie8888,true);
    mIcons[9]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path676,ie8888,true);
    mIcons[10]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path754,ie8888,true);
    mIcons[11]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path815,ie8888,true);
    mIcons[12]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1920,ie8888,true);
    mIcons[13]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path1927,ie8888,true);
    mIcons[14]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3099,ie8888,true);
    mIcons[15]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path3950,ie8888,true);
    mIcons[16]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path4481,ie8888,true);
    mIcons[17]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.path5168,ie8888,true);
    mIcons[18]=Allocation.createFromBitmapResource(mRS,mRes,R.raw.polygon2408,ie8888,true);
    mLabels[0]=makeTextBitmap(""String_Node_Str"");
    mLabels[1]=makeTextBitmap(""String_Node_Str"");
    mLabels[2]=makeTextBitmap(""String_Node_Str"");
    mLabels[3]=makeTextBitmap(""String_Node_Str"");
    mLabels[4]=makeTextBitmap(""String_Node_Str"");
    mLabels[5]=makeTextBitmap(""String_Node_Str"");
    mLabels[6]=makeTextBitmap(""String_Node_Str"");
    mLabels[7]=makeTextBitmap(""String_Node_Str"");
    mLabels[8]=makeTextBitmap(""String_Node_Str"");
    mLabels[9]=makeTextBitmap(""String_Node_Str"");
    mLabels[10]=makeTextBitmap(""String_Node_Str"");
    mLabels[11]=makeTextBitmap(""String_Node_Str"");
    mLabels[12]=makeTextBitmap(""String_Node_Str"");
    mLabels[13]=makeTextBitmap(""String_Node_Str"");
    mLabels[14]=makeTextBitmap(""String_Node_Str"");
    mLabels[15]=makeTextBitmap(""String_Node_Str"");
    mLabels[16]=makeTextBitmap(""String_Node_Str"");
    mLabels[17]=makeTextBitmap(""String_Node_Str"");
    mLabels[18]=makeTextBitmap(""String_Node_Str"");
    mIcons[19]=mIcons[0];
    mIcons[20]=mIcons[1];
    mIcons[21]=mIcons[2];
    mIcons[22]=mIcons[3];
    mIcons[23]=mIcons[4];
    mIcons[24]=mIcons[5];
    mIcons[25]=mIcons[6];
    mIcons[26]=mIcons[7];
    mIcons[27]=mIcons[8];
    mIcons[28]=mIcons[9];
    mLabels[19]=mLabels[0];
    mLabels[20]=mLabels[1];
    mLabels[21]=mLabels[2];
    mLabels[22]=mLabels[3];
    mLabels[23]=mLabels[4];
    mLabels[24]=mLabels[5];
    mLabels[25]=mLabels[6];
    mLabels[26]=mLabels[7];
    mLabels[27]=mLabels[8];
    mLabels[28]=mLabels[9];
    for (int ct=0; ct < mIcons.length; ct++) {
      mIcons[ct].uploadToTexture(0);
      mLabels[ct].uploadToTexture(0);
      mAllocIconIDBuf[ct]=mIcons[ct].getID();
      mAllocLabelIDBuf[ct]=mLabels[ct].getID();
    }
    mAllocIconID.data(mAllocIconIDBuf);
    mAllocLabelID.data(mAllocLabelIDBuf);
  }
}"
23704,"private void initRS(){
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.rollo);
  sb.setRoot(true);
  mScript=sb.create();
  mScript.setClearColor(0.0f,0.0f,0.0f,0.0f);
  mAllocStateBuf=new int[]{0,0,0,8,0,0,-1,0,mAllocIconIDBuf.length,0,0};
  mAllocState=Allocation.createSized(mRS,Element.USER_I32,mAllocStateBuf.length);
  mScript.bindAllocation(mAllocState,0);
  mScript.bindAllocation(mAllocIconID,1);
  mScript.bindAllocation(mAllocScratch,2);
  mScript.bindAllocation(mAllocLabelID,3);
  setPosition(0);
  setZoom(1);
  mRS.contextBindRootScript(mScript);
}","private void initRS(){
  ScriptC.Builder sb=new ScriptC.Builder(mRS);
  sb.setScript(mRes,R.raw.rollo);
  sb.setRoot(true);
  mScript=sb.create();
  mScript.setClearColor(0.0f,0.0f,0.0f,0.0f);
  mAllocStateBuf=new int[]{0,0,0,8,0,0,-1,0,mAllocIconIDBuf.length,0,0};
  mAllocState=Allocation.createSized(mRS,Element.USER_I32(mRS),mAllocStateBuf.length);
  mScript.bindAllocation(mAllocState,0);
  mScript.bindAllocation(mAllocIconID,1);
  mScript.bindAllocation(mAllocScratch,2);
  mScript.bindAllocation(mAllocLabelID,3);
  setPosition(0);
  setZoom(1);
  mRS.contextBindRootScript(mScript);
}"
23705,"Allocation makeTextBitmap(String t){
  Bitmap b=Bitmap.createBitmap(128,32,Bitmap.Config.ARGB_8888);
  Canvas c=new Canvas(b);
  Paint p=new Paint();
  p.setTypeface(Typeface.DEFAULT_BOLD);
  p.setTextSize(20);
  p.setColor(0xffffffff);
  c.drawText(t,2,26,p);
  return Allocation.createFromBitmap(mRS,b,Element.RGBA_8888,true);
}","Allocation makeTextBitmap(String t){
  Bitmap b=Bitmap.createBitmap(128,32,Bitmap.Config.ARGB_8888);
  Canvas c=new Canvas(b);
  Paint p=new Paint();
  p.setTypeface(Typeface.DEFAULT_BOLD);
  p.setTextSize(20);
  p.setColor(0xffffffff);
  c.drawText(t,2,26,p);
  return Allocation.createFromBitmap(mRS,b,Element.RGBA_8888(mRS),true);
}"
23706,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}"
23707,"/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length <= ND) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length <= NS) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}","/** 
 * Add a new movement to the batch of movements in this event.  The input data must contain (NUM_SAMPLE_DATA *   {@link #getPointerCount()}) samples of data.
 * @param eventTime The time stamp for this data.
 * @param inData The actual data.
 * @param metaState Meta key state.
 * @hide
 */
public final void addBatch(long eventTime,float[] inData,int metaState){
  float[] data=mDataSamples;
  long[] times=mTimeSamples;
  final int NP=mNumPointers;
  final int NS=mNumSamples;
  final int NI=NP * NS;
  final int ND=NI * NUM_SAMPLE_DATA;
  if (data.length < (ND + (NP * NUM_SAMPLE_DATA))) {
    final int NEW_ND=ND + (NP * (BASE_AVAIL_SAMPLES * NUM_SAMPLE_DATA));
    float[] newData=new float[NEW_ND];
    System.arraycopy(data,0,newData,0,ND);
    mDataSamples=data=newData;
  }
  if (times.length < (NS + 1)) {
    final int NEW_NS=NS + BASE_AVAIL_SAMPLES;
    long[] newHistoryTimes=new long[NEW_NS];
    System.arraycopy(times,0,newHistoryTimes,0,NS);
    mTimeSamples=times=newHistoryTimes;
  }
  times[NS]=times[0];
  times[0]=eventTime;
  System.arraycopy(data,0,data,ND,mNumPointers * NUM_SAMPLE_DATA);
  System.arraycopy(inData,0,data,0,mNumPointers * NUM_SAMPLE_DATA);
  mNumSamples=NS + 1;
  mRawX=inData[SAMPLE_X];
  mRawY=inData[SAMPLE_Y];
  mMetaState|=metaState;
  if (DEBUG_POINTERS) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    for (int i=0; i < mNumPointers; i++) {
      sb.append(""String_Node_Str"");
      sb.append(mPointerIdentifiers[i]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_X]);
      sb.append(""String_Node_Str"");
      sb.append(mDataSamples[(i * NUM_SAMPLE_DATA) + SAMPLE_Y]);
      sb.append(""String_Node_Str"");
    }
    Log.v(""String_Node_Str"",sb.toString());
  }
}"
23708,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    boolean forceHiding=false;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      boolean focusMayChange=false;
      boolean wallpaperForceHidingChanged=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              if (DEBUG_WALLPAPER)               Log.v(TAG,""String_Node_Str"" + w);
              wallpaperMayChange=true;
            }
          }
          boolean wasAnimating=w.mAnimating;
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          if (wasAnimating && !w.mAnimating && mWallpaperTarget == w) {
            wallpaperMayChange=true;
          }
          if (mPolicy.doesForceHide(w,attrs)) {
            if (!wasAnimating && animating) {
              wallpaperForceHidingChanged=true;
              focusMayChange=true;
            }
 else             if (w.isReadyForDisplay() && w.mAnimation == null) {
              forceHiding=true;
            }
          }
 else           if (mPolicy.canBeForceHidden(w,attrs)) {
            boolean changed;
            if (forceHiding) {
              changed=w.hideLw(false,false);
            }
 else {
              changed=w.showLw(false,false);
              if (changed && wallpaperForceHidingChanged && w.isReadyForDisplay()) {
                Animation a=mPolicy.createForceHideEnterAnimation();
                if (a != null) {
                  w.setAnimation(a);
                }
              }
            }
            if (changed && (attrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDrawnLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDrawnLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDrawnLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDrawnLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_UNSET;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_UNSET;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          WindowState oldWallpaper=mWallpaperTarget;
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          LayoutParams animLp=null;
          AppWindowToken animToken=null;
          int bestAnimLayer=-1;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          int foundWallpapers=0;
          final int NC=mClosingApps.size();
          NN=NC + mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken;
            int mode;
            if (i < NC) {
              wtoken=mClosingApps.get(i);
              mode=1;
            }
 else {
              wtoken=mOpeningApps.get(i - NC);
              mode=2;
            }
            if (mLowerWallpaperTarget != null) {
              if (mLowerWallpaperTarget.mAppToken == wtoken || mUpperWallpaperTarget.mAppToken == wtoken) {
                foundWallpapers|=mode;
              }
            }
            if (wtoken.appFullscreen) {
              WindowState ws=wtoken.findMainWindow();
              if (ws != null) {
                if ((ws.mAttrs.flags & FLAG_COMPATIBLE_WINDOW) != 0) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=Integer.MAX_VALUE;
                }
 else                 if (ws.mLayer > bestAnimLayer) {
                  animLp=ws.mAttrs;
                  animToken=ws.mAppToken;
                  bestAnimLayer=ws.mLayer;
                }
              }
            }
          }
          if (foundWallpapers == 3) {
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
              transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_OPEN;
            break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
          transit=WindowManagerPolicy.TRANSIT_WALLPAPER_INTRA_CLOSE;
        break;
    }
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (oldWallpaper != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_CLOSE;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
 else   if (mWallpaperTarget != null) {
    transit=WindowManagerPolicy.TRANSIT_WALLPAPER_OPEN;
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + transit);
  }
  if ((transit & WindowManagerPolicy.TRANSIT_ENTER_MASK) != 0) {
    mLastEnterAnimToken=animToken;
    mLastEnterAnimParams=animLp;
  }
 else   if (mLastEnterAnimParams != null) {
    animLp=mLastEnterAnimParams;
    mLastEnterAnimToken=null;
    mLastEnterAnimParams=null;
  }
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,animLp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mNextAppTransitionPackage=null;
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  focusMayChange=false;
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
int adjResult=0;
if (wallpaperForceHidingChanged) {
WindowState oldWallpaper=mWallpaperTarget;
adjResult=adjustWallpaperWindowsLocked();
wallpaperMayChange=false;
if (false) Log.v(TAG,""String_Node_Str"" + oldWallpaper + ""String_Node_Str""+ mWallpaperTarget);
if (mLowerWallpaperTarget == null) {
  forceHiding=false;
  for (i=N - 1; i >= 0; i--) {
    WindowState w=(WindowState)mWindows.get(i);
    if (w.mSurface != null) {
      final WindowManager.LayoutParams attrs=w.mAttrs;
      if (mPolicy.doesForceHide(w,attrs)) {
        forceHiding=true;
      }
 else       if (mPolicy.canBeForceHidden(w,attrs)) {
        if (!w.mAnimating) {
          w.clearAnimation();
        }
      }
    }
  }
}
}
if (wallpaperMayChange) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
adjResult=adjustWallpaperWindowsLocked();
}
if ((adjResult & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
assignLayersLocked();
}
 else if ((adjResult & ADJUST_WALLPAPER_VISIBILITY_CHANGED) != 0) {
if (DEBUG_WALLPAPER) Log.v(TAG,""String_Node_Str"");
restart=true;
mLayoutNeeded=true;
}
if (focusMayChange) {
if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES)) {
  restart=true;
  adjResult=0;
}
}
if (mLayoutNeeded) {
restart=true;
performLayoutLockedInner();
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top);
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height());
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (mDisplayFrozen) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
      w.mOrientationChanging=true;
      if (mWindowsFreezingScreen) {
        mWindowsFreezingScreen=true;
        mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        mH.sendMessageDelayed(mH.obtainMessage(H.WINDOW_FREEZE_TIMEOUT),2000);
      }
    }
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden || !w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer+ ""String_Node_Str""+ (w.mDsDx * w.mHScale)+ ""String_Node_Str""+ (w.mDtDx * w.mVScale)+ ""String_Node_Str""+ (w.mDsDy * w.mHScale)+ ""String_Node_Str""+ (w.mDtDy * w.mVScale)+ ""String_Node_Str"");
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=canBeSeen && w.isOpaqueDrawn();
if (opaqueDrawn && w.isFullscreen(dw,dh)) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.mFrame);
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
token.animation=null;
token.animating=false;
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
if (mLastEnterAnimToken == token) {
mLastEnterAnimToken=null;
mLastEnterAnimParams=null;
}
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked() != 0;
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
if (mTurnOnScreen) {
mPowerManager.userActivity(SystemClock.uptimeMillis(),false,LocalPowerManager.BUTTON_EVENT,true);
mTurnOnScreen=false;
}
}"
23709,"public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDisplayedLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}","public void performEnableScreen(){
synchronized (mWindowMap) {
    if (mDisplayEnabled) {
      return;
    }
    if (!mSystemBooted) {
      return;
    }
    final int N=mWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=(WindowState)mWindows.get(i);
      if (w.isVisibleLw() && !w.isDrawnLw()) {
        return;
      }
    }
    mDisplayEnabled=true;
    if (false) {
      Log.i(TAG,""String_Node_Str"");
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      this.dump(null,pw,null);
      Log.i(TAG,sw.toString());
    }
    try {
      IBinder surfaceFlinger=ServiceManager.getService(""String_Node_Str"");
      if (surfaceFlinger != null) {
        Parcel data=Parcel.obtain();
        data.writeInterfaceToken(""String_Node_Str"");
        surfaceFlinger.transact(IBinder.FIRST_CALL_TRANSACTION,data,null,0);
        data.recycle();
      }
    }
 catch (    RemoteException ex) {
      Log.e(TAG,""String_Node_Str"");
    }
  }
  mPolicy.enableScreenAfterBoot();
  setRotationUnchecked(WindowManagerPolicy.USE_LAST_ROTATION,false,mLastRotationFlags | Surface.FLAGS_ORIENTATION_ANIMATION_DISABLE);
}"
23710,"private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || !win.mPolicyVisibility || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}","private final void performLayoutLockedInner(){
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int repeats=0;
  int i;
  while (mLayoutNeeded) {
    mPolicy.beginLayoutLw(dw,dh);
    int topAttached=-1;
    for (i=N - 1; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      final AppWindowToken atoken=win.mAppToken;
      final boolean gone=win.mViewVisibility == View.GONE || !win.mRelayoutCalled || win.mRootToken.hidden || (atoken != null && atoken.hiddenRequested) || win.mAttachedHidden || win.mExiting || win.mDestroying;
      if (!gone || !win.mHaveFrame) {
        if (!win.mLayoutAttached) {
          mPolicy.layoutWindowLw(win,win.mAttrs,null);
        }
 else {
          if (topAttached < 0)           topAttached=i;
        }
      }
    }
    for (i=topAttached; i >= 0; i--) {
      WindowState win=(WindowState)mWindows.get(i);
      if (win.mLayoutAttached) {
        if ((win.mViewVisibility != View.GONE && win.mRelayoutCalled) || !win.mHaveFrame) {
          mPolicy.layoutWindowLw(win,win.mAttrs,win.mAttachedWindow);
        }
      }
    }
    int changes=mPolicy.finishLayoutLw();
    if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) {
      if ((adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
        assignLayersLocked();
      }
    }
    if (changes == 0) {
      mLayoutNeeded=false;
    }
 else     if (repeats > 2) {
      Log.w(TAG,""String_Node_Str"");
      mLayoutNeeded=false;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mLayoutNeeded=true;
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
 else {
      repeats++;
      if ((changes & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
        Configuration newConfig=updateOrientationFromAppTokensLocked(null,null);
        if (newConfig != null) {
          mH.sendEmptyMessage(H.COMPUTE_AND_SEND_NEW_CONFIGURATION);
        }
      }
    }
  }
}"
23711,"void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDisplayedLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDisplayedLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDisplayedLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}","void updateReportedVisibilityLocked(){
  if (appToken == null) {
    return;
  }
  int numInteresting=0;
  int numVisible=0;
  boolean nowGone=true;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this);
  final int N=allAppWindows.size();
  for (int i=0; i < N; i++) {
    WindowState win=allAppWindows.get(i);
    if (win == startingWindow || win.mAppFreezing) {
      continue;
    }
    if (DEBUG_VISIBILITY) {
      Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ win.isDrawnLw()+ ""String_Node_Str""+ win.isAnimating());
      if (!win.isDrawnLw()) {
        Log.v(TAG,""String_Node_Str"" + win.mSurface + ""String_Node_Str""+ win.mPolicyVisibility+ ""String_Node_Str""+ win.mDrawPending+ ""String_Node_Str""+ win.mCommitDrawPending+ ""String_Node_Str""+ win.mAttachedHidden+ ""String_Node_Str""+ (win.mAppToken != null ? win.mAppToken.hiddenRequested : false)+ ""String_Node_Str""+ win.mAnimating);
      }
    }
    numInteresting++;
    if (win.isDrawnLw()) {
      if (!win.isAnimating()) {
        numVisible++;
      }
      nowGone=false;
    }
 else     if (win.isAnimating()) {
      nowGone=false;
    }
  }
  boolean nowVisible=numInteresting > 0 && numVisible >= numInteresting;
  if (DEBUG_VISIBILITY)   Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ numVisible);
  if (nowVisible != reportedVisible) {
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ nowVisible);
    reportedVisible=nowVisible;
    Message m=mH.obtainMessage(H.REPORT_APPLICATION_TOKEN_WINDOWS,nowVisible ? 1 : 0,nowGone ? 1 : 0,this);
    mH.sendMessage(m);
  }
}"
23712,"/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}","/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  if (!c.isNull(HEADER_PRESENCE_STATUS_COLUMN_INDEX)) {
    int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
    mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
    mPresenceView.setVisibility(View.VISIBLE);
  }
 else {
    mPresenceView.setVisibility(View.GONE);
  }
}"
23713,"final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        ViewManager wm=a.getWindowManager();
        View decor=r.window.getDecorView();
        wm.updateViewLayout(decor,l);
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}","final void handleResumeActivity(IBinder token,boolean clearHide,boolean isForward){
  unscheduleGcIdler();
  ActivityRecord r=performResumeActivity(token,clearHide);
  if (r != null) {
    final Activity a=r.activity;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ a.mStartedActivity+ ""String_Node_Str""+ r.hideForNow+ ""String_Node_Str""+ a.mFinished);
    final int forwardBit=isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;
    if (r.window == null && !a.mFinished && !a.mStartedActivity) {
      r.window=r.activity.getWindow();
      View decor=r.window.getDecorView();
      decor.setVisibility(View.INVISIBLE);
      ViewManager wm=a.getWindowManager();
      WindowManager.LayoutParams l=r.window.getAttributes();
      a.mDecor=decor;
      l.type=WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
      l.softInputMode|=forwardBit;
      if (a.mVisibleFromClient) {
        a.mWindowAdded=true;
        wm.addView(decor,l);
      }
    }
 else     if (a.mStartedActivity) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str"");
      r.hideForNow=true;
    }
    if (!r.activity.mFinished && !a.mStartedActivity && r.activity.mDecor != null && !r.hideForNow) {
      if (r.newConfig != null) {
        performConfigurationChanged(r.activity,r.newConfig);
        r.newConfig=null;
      }
      if (localLOGV)       Log.v(TAG,""String_Node_Str"" + r + ""String_Node_Str""+ isForward);
      WindowManager.LayoutParams l=r.window.getAttributes();
      if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) {
        l.softInputMode=(l.softInputMode & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit;
        if (r.activity.mVisibleFromClient) {
          ViewManager wm=a.getWindowManager();
          View decor=r.window.getDecorView();
          wm.updateViewLayout(decor,l);
        }
      }
      r.activity.mVisibleFromServer=true;
      mNumVisibleActivities++;
      if (r.activity.mVisibleFromClient) {
        r.activity.makeVisible();
      }
    }
    r.nextIdle=mNewActivities;
    mNewActivities=r;
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r);
    Looper.myQueue().addIdleHandler(new Idler());
  }
 else {
    try {
      ActivityManagerNative.getDefault().finishActivity(token,Activity.RESULT_CANCELED,null);
    }
 catch (    RemoteException ex) {
    }
  }
}"
23714,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
  }
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(""String_Node_Str"");
    }
 catch (    RemoteException e) {
    }
  }
}"
23715,"/** 
 * Creates a centered bitmap of the desired size.
 * @param source
 * @param recycle whether we want to recycle the input
 */
public static Bitmap extractMiniThumb(Bitmap source,int width,int height,boolean recycle){
  if (source == null) {
    return null;
  }
  float scale;
  if (source.getWidth() < source.getHeight()) {
    scale=width / (float)source.getWidth();
  }
 else {
    scale=height / (float)source.getHeight();
  }
  Matrix matrix=new Matrix();
  matrix.setScale(scale,scale);
  Bitmap miniThumbnail=transform(matrix,source,width,height,false,recycle);
  return miniThumbnail;
}","/** 
 * Creates a centered bitmap of the desired size.
 * @param source
 * @param recycle whether we want to recycle the input
 */
public static Bitmap extractMiniThumb(Bitmap source,int width,int height,boolean recycle){
  if (source == null) {
    return null;
  }
  float scale;
  if (source.getWidth() < source.getHeight()) {
    scale=width / (float)source.getWidth();
  }
 else {
    scale=height / (float)source.getHeight();
  }
  Matrix matrix=new Matrix();
  matrix.setScale(scale,scale);
  Bitmap miniThumbnail=transform(matrix,source,width,height,true,recycle);
  return miniThumbnail;
}"
23716,"public PackageInfo(ActivityThread activityThread,String name,Context systemContext){
  mActivityThread=activityThread;
  mApplicationInfo=new ApplicationInfo();
  mApplicationInfo.packageName=name;
  mPackageName=name;
  mAppDir=null;
  mResDir=null;
  mSharedLibraries=null;
  mDataDir=null;
  mDataDirFile=null;
  mBaseClassLoader=null;
  mSecurityViolation=false;
  mIncludeCode=true;
  mClassLoader=systemContext.getClassLoader();
  mResources=systemContext.getResources();
  mCompatibilityInfo=new CompatibilityInfo(mApplicationInfo);
}","public PackageInfo(ActivityThread activityThread,String name,Context systemContext,ApplicationInfo info){
  mActivityThread=activityThread;
  mApplicationInfo=info != null ? info : new ApplicationInfo();
  mApplicationInfo.packageName=name;
  mPackageName=name;
  mAppDir=null;
  mResDir=null;
  mSharedLibraries=null;
  mDataDir=null;
  mDataDirFile=null;
  mBaseClassLoader=null;
  mSecurityViolation=false;
  mIncludeCode=true;
  mClassLoader=systemContext.getClassLoader();
  mResources=systemContext.getResources();
  mCompatibilityInfo=new CompatibilityInfo(mApplicationInfo);
}"
23717,"public ApplicationContext getSystemContext(){
synchronized (this) {
    if (mSystemContext == null) {
      ApplicationContext context=ApplicationContext.createSystemContext(this);
      PackageInfo info=new PackageInfo(this,""String_Node_Str"",context);
      context.init(info,null,this);
      context.getResources().updateConfiguration(getConfiguration(),getDisplayMetricsLocked(false));
      mSystemContext=context;
    }
  }
  return mSystemContext;
}","public ApplicationContext getSystemContext(){
synchronized (this) {
    if (mSystemContext == null) {
      ApplicationContext context=ApplicationContext.createSystemContext(this);
      PackageInfo info=new PackageInfo(this,""String_Node_Str"",context,null);
      context.init(info,null,this);
      context.getResources().updateConfiguration(getConfiguration(),getDisplayMetricsLocked(false));
      mSystemContext=context;
    }
  }
  return mSystemContext;
}"
23718,"public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","public static void setSystemProcess(){
  try {
    ActivityManagerService m=mSelf;
    ServiceManager.addService(""String_Node_Str"",m);
    ServiceManager.addService(""String_Node_Str"",new MemBinder(m));
    if (MONITOR_CPU_USAGE) {
      ServiceManager.addService(""String_Node_Str"",new CpuBinder(m));
    }
    ServiceManager.addService(""String_Node_Str"",new BroadcastsBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ServicesBinder(m));
    ServiceManager.addService(""String_Node_Str"",new SendersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new ProvidersBinder(m));
    ServiceManager.addService(""String_Node_Str"",new PermissionController(m));
    ApplicationInfo info=mSelf.mContext.getPackageManager().getApplicationInfo(""String_Node_Str"",STOCK_PM_FLAGS);
    mSystemThread.installSystemApplicationInfo(info);
synchronized (mSelf) {
      ProcessRecord app=mSelf.newProcessRecordLocked(mSystemThread.getApplicationThread(),info,info.processName);
      app.persistent=true;
      app.pid=Process.myPid();
      app.maxAdj=SYSTEM_ADJ;
      mSelf.mProcessNames.put(app.processName,app.info.uid,app);
synchronized (mSelf.mPidsSelfLocked) {
        mSelf.mPidsSelfLocked.put(app.pid,app);
      }
      mSelf.updateLRUListLocked(app,true);
    }
  }
 catch (  PackageManager.NameNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}"
23719,"/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}","/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || TextUtils.isEmpty(from.getString()) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}"
23720,"private void updateAnimation(){
  final long millisSoFar=currentAnimationTimeMillis() - mAnimationStartTime;
  final long millisLeft=mAnimationDuration - millisSoFar;
  final int totalDeltaX=mAnimatingDeltaXStart - mAnimatingDeltaXEnd;
  final boolean goingRight=totalDeltaX < 0;
  if (DBG)   log(""String_Node_Str"" + millisLeft);
  if (millisLeft <= 0) {
    reset();
    return;
  }
  float interpolation=mInterpolator.getInterpolation((float)millisSoFar / mAnimationDuration);
  final int dx=(int)(totalDeltaX * (1 - interpolation));
  mRotaryOffsetX=mAnimatingDeltaXEnd + dx;
  if (mDimplesOfFling > 0) {
    if (!goingRight && mRotaryOffsetX < 3 * mDimpleSpacing) {
      mRotaryOffsetX+=mDimplesOfFling * mDimpleSpacing;
    }
 else     if (goingRight && mRotaryOffsetX > 3 * mDimpleSpacing) {
      mRotaryOffsetX-=mDimplesOfFling * mDimpleSpacing;
    }
  }
  invalidate();
}","private void updateAnimation(){
  final long millisSoFar=currentAnimationTimeMillis() - mAnimationStartTime;
  final long millisLeft=mAnimationDuration - millisSoFar;
  final int totalDeltaX=mAnimatingDeltaXStart - mAnimatingDeltaXEnd;
  final boolean goingRight=totalDeltaX < 0;
  if (DBG)   log(""String_Node_Str"" + millisLeft);
  if (millisLeft <= 0) {
    reset();
    return;
  }
  float interpolation=mInterpolator.getInterpolation((float)millisSoFar / mAnimationDuration);
  final int dx=(int)(totalDeltaX * (1 - interpolation));
  mRotaryOffsetX=mAnimatingDeltaXEnd + dx;
  if (mDimplesOfFling > 0) {
    if (!goingRight && mRotaryOffsetX < -3 * mDimpleSpacing) {
      mRotaryOffsetX+=mDimplesOfFling * mDimpleSpacing;
    }
 else     if (goingRight && mRotaryOffsetX > 3 * mDimpleSpacing) {
      mRotaryOffsetX-=mDimplesOfFling * mDimpleSpacing;
    }
  }
  invalidate();
}"
23721,"/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
  }
}","/** 
 * Handle message sent by   {@link #showLocked}.
 * @see #SHOW
 */
private void handleShow(){
synchronized (KeyguardViewMediator.this) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    if (!mSystemReady)     return;
    mRealPowerManager.enableUserActivity(false);
    mKeyguardViewManager.show();
    mShowing=true;
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(""String_Node_Str"");
    }
 catch (    RemoteException e) {
    }
  }
}"
23722,"/** 
 * Tests international matching issues for the PHONE_NUMBERS_EQUAL function.
 * @throws Exception
 */
@SmallTest public void testPhoneNumbersEqualInternationl() throws Exception {
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
}","/** 
 * Tests international matching issues for the PHONE_NUMBERS_EQUAL function.
 * @throws Exception
 */
@SmallTest public void testPhoneNumbersEqualInternationl() throws Exception {
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"");
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
  assertPhoneNumberEqual(""String_Node_Str"",""String_Node_Str"",false);
  assertPhoneNumberNotEqual(""String_Node_Str"",""String_Node_Str"",true);
}"
23723,"private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  int i=0;
  while (i < N) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.get(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null && N > 0) {
        i++;
        continue;
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      i++;
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
  if (i == N) {
    r.pendingStarts.clear();
  }
 else {
    while (i > 0) {
      i--;
      r.pendingStarts.remove(i);
    }
  }
}","private final void sendServiceArgsLocked(ServiceRecord r,boolean oomAdjusted){
  final int N=r.pendingStarts.size();
  if (N == 0) {
    return;
  }
  int i=0;
  while (i < N) {
    try {
      ServiceRecord.StartItem si=r.pendingStarts.get(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ si.intent);
      if (si.intent == null && N > 1) {
        i++;
        continue;
      }
      bumpServiceExecutingLocked(r);
      if (!oomAdjusted) {
        oomAdjusted=true;
        updateOomAdjLocked(r.app);
      }
      int flags=0;
      if (si.deliveryCount > 0) {
        flags|=Service.START_FLAG_RETRY;
      }
      if (si.doneExecutingCount > 0) {
        flags|=Service.START_FLAG_REDELIVERY;
      }
      r.app.thread.scheduleServiceArgs(r,si.id,flags,si.intent);
      si.deliveredTime=SystemClock.uptimeMillis();
      r.deliveredStarts.add(si);
      si.deliveryCount++;
      i++;
    }
 catch (    RemoteException e) {
      break;
    }
catch (    Exception e) {
      Log.w(TAG,""String_Node_Str"",e);
      break;
    }
  }
  if (i == N) {
    r.pendingStarts.clear();
  }
 else {
    while (i > 0) {
      i--;
      r.pendingStarts.remove(i);
    }
  }
}"
23724,"/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
try {
int addressType=checkAddressType(addr[i].getString());
temp=EncodedStringValue.copy(addr[i]);
if (PDU_PHONE_NUMBER_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_PHONE_NUMBER_ADDRESS_TYPE.getBytes());
}
 else if (PDU_IPV4_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_IPV4_ADDRESS_TYPE.getBytes());
}
 else if (PDU_IPV6_ADDRESS_TYPE == addressType) {
temp.appendTextString(STRING_IPV6_ADDRESS_TYPE.getBytes());
}
}
 catch (NullPointerException e) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
appendEncodedString(from);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}","/** 
 * Append header to mMessage.
 */
private int appendHeader(int field){
switch (field) {
case PduHeaders.MMS_VERSION:
    appendOctet(field);
  int version=mPduHeader.getOctet(field);
if (0 == version) {
  appendShortInteger(PduHeaders.CURRENT_MMS_VERSION);
}
 else {
  appendShortInteger(version);
}
break;
case PduHeaders.MESSAGE_ID:
case PduHeaders.TRANSACTION_ID:
byte[] textString=mPduHeader.getTextString(field);
if (null == textString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendTextString(textString);
break;
case PduHeaders.TO:
case PduHeaders.BCC:
case PduHeaders.CC:
EncodedStringValue[] addr=mPduHeader.getEncodedStringValues(field);
if (null == addr) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
EncodedStringValue temp;
for (int i=0; i < addr.length; i++) {
temp=appendAddressType(addr[i]);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendOctet(field);
appendEncodedString(temp);
}
break;
case PduHeaders.FROM:
appendOctet(field);
EncodedStringValue from=mPduHeader.getEncodedStringValue(field);
if ((from == null) || new String(from.getTextString()).equals(PduHeaders.FROM_INSERT_ADDRESS_TOKEN_STR)) {
append(1);
append(PduHeaders.FROM_INSERT_ADDRESS_TOKEN);
}
 else {
mStack.newbuf();
PositionMarker fstart=mStack.mark();
append(PduHeaders.FROM_ADDRESS_PRESENT_TOKEN);
temp=appendAddressType(from);
if (temp == null) {
return PDU_COMPOSE_CONTENT_ERROR;
}
appendEncodedString(temp);
int flen=fstart.getLength();
mStack.pop();
appendValueLength(flen);
mStack.copy();
}
break;
case PduHeaders.READ_STATUS:
case PduHeaders.STATUS:
case PduHeaders.REPORT_ALLOWED:
case PduHeaders.PRIORITY:
case PduHeaders.DELIVERY_REPORT:
case PduHeaders.READ_REPORT:
int octet=mPduHeader.getOctet(field);
if (0 == octet) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendOctet(octet);
break;
case PduHeaders.DATE:
long date=mPduHeader.getLongInteger(field);
if (-1 == date) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendDateValue(date);
break;
case PduHeaders.SUBJECT:
EncodedStringValue enString=mPduHeader.getEncodedStringValue(field);
if (null == enString) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
appendEncodedString(enString);
break;
case PduHeaders.MESSAGE_CLASS:
byte[] messageClass=mPduHeader.getTextString(field);
if (null == messageClass) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_ADVERTISEMENT_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_ADVERTISEMENT);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_AUTO_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_AUTO);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_PERSONAL);
}
 else if (Arrays.equals(messageClass,PduHeaders.MESSAGE_CLASS_INFORMATIONAL_STR.getBytes())) {
appendOctet(PduHeaders.MESSAGE_CLASS_INFORMATIONAL);
}
 else {
appendTextString(messageClass);
}
break;
case PduHeaders.EXPIRY:
long expiry=mPduHeader.getLongInteger(field);
if (-1 == expiry) {
return PDU_COMPOSE_FIELD_NOT_SET;
}
appendOctet(field);
mStack.newbuf();
PositionMarker expiryStart=mStack.mark();
append(PduHeaders.VALUE_RELATIVE_TOKEN);
appendLongInteger(expiry);
int expiryLength=expiryStart.getLength();
mStack.pop();
appendValueLength(expiryLength);
mStack.copy();
break;
default :
return PDU_COMPOSE_FIELD_NOT_SUPPORTED;
}
return PDU_COMPOSE_SUCCESS;
}"
23725,"/** 
 * @return whether the descendant of this scroll view is within deltapixels of being on the screen.
 */
private boolean isWithinDeltaOfScreen(View descendant,int delta){
  descendant.getDrawingRect(mTempRect);
  offsetDescendantRectToMyCoords(descendant,mTempRect);
  return (mTempRect.bottom + delta) >= getScrollY() && (mTempRect.top - delta) <= (getScrollY() + getHeight());
}","/** 
 * @return whether the descendant of this scroll view is within deltapixels of being on the screen.
 */
private boolean isWithinDeltaOfScreen(View descendant,int delta,int height){
  descendant.getDrawingRect(mTempRect);
  offsetDescendantRectToMyCoords(descendant,mTempRect);
  return (mTempRect.bottom + delta) >= getScrollY() && (mTempRect.top - delta) <= (getScrollY() + height);
}"
23726,"/** 
 * @return whether the descendant of this scroll view is scrolled offscreen.
 */
private boolean isOffScreen(View descendant){
  return !isWithinDeltaOfScreen(descendant,0);
}","/** 
 * @return whether the descendant of this scroll view is scrolled offscreen.
 */
private boolean isOffScreen(View descendant){
  return !isWithinDeltaOfScreen(descendant,0,getHeight());
}"
23727,"@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  View currentFocused=findFocus();
  if (null == currentFocused || this == currentFocused)   return;
  final int maxJump=mBottom - mTop;
  if (isWithinDeltaOfScreen(currentFocused,maxJump)) {
    currentFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(currentFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
  }
}","@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){
  super.onSizeChanged(w,h,oldw,oldh);
  View currentFocused=findFocus();
  if (null == currentFocused || this == currentFocused)   return;
  if (isWithinDeltaOfScreen(currentFocused,0,oldh)) {
    currentFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(currentFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
  }
}"
23728,"/** 
 * Handle scrolling in response to an up or down arrow click.
 * @param direction The direction corresponding to the arrow key that waspressed
 * @return True if we consumed the event, false otherwise
 */
public boolean arrowScroll(int direction){
  View currentFocused=findFocus();
  if (currentFocused == this)   currentFocused=null;
  View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,direction);
  final int maxJump=getMaxScrollAmount();
  if (nextFocused != null && isWithinDeltaOfScreen(nextFocused,maxJump)) {
    nextFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(nextFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
    nextFocused.requestFocus(direction);
  }
 else {
    int scrollDelta=maxJump;
    if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
      scrollDelta=getScrollY();
    }
 else     if (direction == View.FOCUS_DOWN) {
      if (getChildCount() > 0) {
        int daBottom=getChildAt(0).getBottom();
        int screenBottom=getScrollY() + getHeight();
        if (daBottom - screenBottom < maxJump) {
          scrollDelta=daBottom - screenBottom;
        }
      }
    }
    if (scrollDelta == 0) {
      return false;
    }
    doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
  }
  if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
    final int descendantFocusability=getDescendantFocusability();
    setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
    requestFocus();
    setDescendantFocusability(descendantFocusability);
  }
  return true;
}","/** 
 * Handle scrolling in response to an up or down arrow click.
 * @param direction The direction corresponding to the arrow key that waspressed
 * @return True if we consumed the event, false otherwise
 */
public boolean arrowScroll(int direction){
  View currentFocused=findFocus();
  if (currentFocused == this)   currentFocused=null;
  View nextFocused=FocusFinder.getInstance().findNextFocus(this,currentFocused,direction);
  final int maxJump=getMaxScrollAmount();
  if (nextFocused != null && isWithinDeltaOfScreen(nextFocused,maxJump,getHeight())) {
    nextFocused.getDrawingRect(mTempRect);
    offsetDescendantRectToMyCoords(nextFocused,mTempRect);
    int scrollDelta=computeScrollDeltaToGetChildRectOnScreen(mTempRect);
    doScrollY(scrollDelta);
    nextFocused.requestFocus(direction);
  }
 else {
    int scrollDelta=maxJump;
    if (direction == View.FOCUS_UP && getScrollY() < scrollDelta) {
      scrollDelta=getScrollY();
    }
 else     if (direction == View.FOCUS_DOWN) {
      if (getChildCount() > 0) {
        int daBottom=getChildAt(0).getBottom();
        int screenBottom=getScrollY() + getHeight();
        if (daBottom - screenBottom < maxJump) {
          scrollDelta=daBottom - screenBottom;
        }
      }
    }
    if (scrollDelta == 0) {
      return false;
    }
    doScrollY(direction == View.FOCUS_DOWN ? scrollDelta : -scrollDelta);
  }
  if (currentFocused != null && currentFocused.isFocused() && isOffScreen(currentFocused)) {
    final int descendantFocusability=getDescendantFocusability();
    setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
    requestFocus();
    setDescendantFocusability(descendantFocusability);
  }
  return true;
}"
23729,"/** 
 * Report a click from an in app search result back to global search for shortcutting porpoises.
 * @param c The cursor that is pointing to the clicked position.
 * @param intent The intent that will be launched for the click.
 */
private void reportInAppClickToGlobalSearch(Cursor c,Intent intent){
  Uri uri=getClickReportingUri();
  final ContentValues cv=new ContentValues();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_QUERY,mUserQuery);
  final ComponentName source=mSearchable.getSearchActivity();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_COMPONENT,source.flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_ACTION,intent.getAction());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_DATA,intent.getDataString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_COMPONENT_NAME,intent.getStringExtra(SearchManager.COMPONENT_NAME_KEY));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_1,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_1)));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_2,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_2)));
  cv.put(SearchManager.SUGGEST_COLUMN_FORMAT,getColumnString(c,SearchManager.SUGGEST_COLUMN_FORMAT));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_1,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_1));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_2,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_2));
  cv.put(SearchManager.SUGGEST_COLUMN_QUERY,getColumnString(c,SearchManager.SUGGEST_COLUMN_QUERY));
  cv.put(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,getColumnString(c,SearchManager.SUGGEST_COLUMN_SHORTCUT_ID));
  mContext.getContentResolver().insert(uri,cv);
}","/** 
 * Report a click from an in app search result back to global search for shortcutting porpoises.
 * @param c The cursor that is pointing to the clicked position.
 * @param intent The intent that will be launched for the click.
 */
private void reportInAppClickToGlobalSearch(Cursor c,Intent intent){
  Uri uri=getClickReportingUri();
  final ContentValues cv=new ContentValues();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_QUERY,mUserQuery);
  final ComponentName source=mSearchable.getSearchActivity();
  cv.put(SearchManager.SEARCH_CLICK_REPORT_COLUMN_COMPONENT,source.flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_ACTION,intent.getAction());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_DATA,intent.getDataString());
  cv.put(SearchManager.SUGGEST_COLUMN_INTENT_COMPONENT_NAME,intent.getComponent().flattenToShortString());
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_1,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_1)));
  cv.put(SearchManager.SUGGEST_COLUMN_ICON_2,wrapIconForPackage(mSearchable.getSuggestPackage(),getColumnString(c,SearchManager.SUGGEST_COLUMN_ICON_2)));
  cv.put(SearchManager.SUGGEST_COLUMN_FORMAT,getColumnString(c,SearchManager.SUGGEST_COLUMN_FORMAT));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_1,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_1));
  cv.put(SearchManager.SUGGEST_COLUMN_TEXT_2,getColumnString(c,SearchManager.SUGGEST_COLUMN_TEXT_2));
  cv.put(SearchManager.SUGGEST_COLUMN_QUERY,getColumnString(c,SearchManager.SUGGEST_COLUMN_QUERY));
  cv.put(SearchManager.SUGGEST_COLUMN_SHORTCUT_ID,getColumnString(c,SearchManager.SUGGEST_COLUMN_SHORTCUT_ID));
  mContext.getContentResolver().insert(uri,cv);
}"
23730,"public static Intent getIntentOld(String uri) throws URISyntaxException {
  Intent intent;
  int i=uri.lastIndexOf('#');
  if (i >= 0) {
    Uri data=null;
    String action=null;
    if (i > 0) {
      data=Uri.parse(uri.substring(0,i));
    }
    i++;
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      i+=7;
      int j=uri.indexOf(')',i);
      action=uri.substring(i,j);
      i=j + 1;
    }
    intent=new Intent(action,data);
    if (uri.regionMatches(i,""String_Node_Str"",0,11)) {
      i+=11;
      int j=uri.indexOf(')',i);
      while (i < j) {
        int sep=uri.indexOf('!',i);
        if (sep < 0)         sep=j;
        if (i < sep) {
          intent.addCategory(uri.substring(i,sep));
        }
        i=sep + 1;
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,5)) {
      i+=5;
      int j=uri.indexOf(')',i);
      intent.mType=uri.substring(i,j);
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,12)) {
      i+=12;
      int j=uri.indexOf(')',i);
      intent.mFlags=Integer.decode(uri.substring(i,j)).intValue();
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,10)) {
      i+=10;
      int j=uri.indexOf(')',i);
      int sep=uri.indexOf('!',i);
      if (sep >= 0 && sep < j) {
        String pkg=uri.substring(i,sep);
        String cls=uri.substring(sep + 1,j);
        intent.mComponent=new ComponentName(pkg,cls);
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      i+=7;
      final int closeParen=uri.indexOf(')',i);
      if (closeParen == -1)       throw new URISyntaxException(uri,""String_Node_Str"",i);
      while (i < closeParen) {
        int j=uri.indexOf('=',i);
        if (j <= i + 1 || i >= closeParen) {
          throw new URISyntaxException(uri,""String_Node_Str"",i);
        }
        char type=uri.charAt(i);
        i++;
        String key=uri.substring(i,j);
        i=j + 1;
        j=uri.indexOf('!',i);
        if (j == -1 || j >= closeParen)         j=closeParen;
        if (i >= j)         throw new URISyntaxException(uri,""String_Node_Str"",i);
        String value=uri.substring(i,j);
        i=j;
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        try {
switch (type) {
case 'S':
            intent.mExtras.putString(key,Uri.decode(value));
          break;
case 'B':
        intent.mExtras.putBoolean(key,Boolean.parseBoolean(value));
      break;
case 'b':
    intent.mExtras.putByte(key,Byte.parseByte(value));
  break;
case 'c':
intent.mExtras.putChar(key,Uri.decode(value).charAt(0));
break;
case 'd':
intent.mExtras.putDouble(key,Double.parseDouble(value));
break;
case 'f':
intent.mExtras.putFloat(key,Float.parseFloat(value));
break;
case 'i':
intent.mExtras.putInt(key,Integer.parseInt(value));
break;
case 'l':
intent.mExtras.putLong(key,Long.parseLong(value));
break;
case 's':
intent.mExtras.putShort(key,Short.parseShort(value));
break;
default :
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
}
 catch (NumberFormatException e) {
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
char ch=uri.charAt(i);
if (ch == ')') break;
if (ch != '!') throw new URISyntaxException(uri,""String_Node_Str"",i);
i++;
}
}
if (intent.mAction == null) {
intent.mAction=ACTION_VIEW;
}
}
 else {
intent=new Intent(ACTION_VIEW,Uri.parse(uri));
}
return intent;
}","public static Intent getIntentOld(String uri) throws URISyntaxException {
  Intent intent;
  int i=uri.lastIndexOf('#');
  if (i >= 0) {
    String action=null;
    final int intentFragmentStart=i;
    boolean isIntentFragment=false;
    i++;
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      isIntentFragment=true;
      i+=7;
      int j=uri.indexOf(')',i);
      action=uri.substring(i,j);
      i=j + 1;
    }
    intent=new Intent(action);
    if (uri.regionMatches(i,""String_Node_Str"",0,11)) {
      isIntentFragment=true;
      i+=11;
      int j=uri.indexOf(')',i);
      while (i < j) {
        int sep=uri.indexOf('!',i);
        if (sep < 0)         sep=j;
        if (i < sep) {
          intent.addCategory(uri.substring(i,sep));
        }
        i=sep + 1;
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,5)) {
      isIntentFragment=true;
      i+=5;
      int j=uri.indexOf(')',i);
      intent.mType=uri.substring(i,j);
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,12)) {
      isIntentFragment=true;
      i+=12;
      int j=uri.indexOf(')',i);
      intent.mFlags=Integer.decode(uri.substring(i,j)).intValue();
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,10)) {
      isIntentFragment=true;
      i+=10;
      int j=uri.indexOf(')',i);
      int sep=uri.indexOf('!',i);
      if (sep >= 0 && sep < j) {
        String pkg=uri.substring(i,sep);
        String cls=uri.substring(sep + 1,j);
        intent.mComponent=new ComponentName(pkg,cls);
      }
      i=j + 1;
    }
    if (uri.regionMatches(i,""String_Node_Str"",0,7)) {
      isIntentFragment=true;
      i+=7;
      final int closeParen=uri.indexOf(')',i);
      if (closeParen == -1)       throw new URISyntaxException(uri,""String_Node_Str"",i);
      while (i < closeParen) {
        int j=uri.indexOf('=',i);
        if (j <= i + 1 || i >= closeParen) {
          throw new URISyntaxException(uri,""String_Node_Str"",i);
        }
        char type=uri.charAt(i);
        i++;
        String key=uri.substring(i,j);
        i=j + 1;
        j=uri.indexOf('!',i);
        if (j == -1 || j >= closeParen)         j=closeParen;
        if (i >= j)         throw new URISyntaxException(uri,""String_Node_Str"",i);
        String value=uri.substring(i,j);
        i=j;
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        try {
switch (type) {
case 'S':
            intent.mExtras.putString(key,Uri.decode(value));
          break;
case 'B':
        intent.mExtras.putBoolean(key,Boolean.parseBoolean(value));
      break;
case 'b':
    intent.mExtras.putByte(key,Byte.parseByte(value));
  break;
case 'c':
intent.mExtras.putChar(key,Uri.decode(value).charAt(0));
break;
case 'd':
intent.mExtras.putDouble(key,Double.parseDouble(value));
break;
case 'f':
intent.mExtras.putFloat(key,Float.parseFloat(value));
break;
case 'i':
intent.mExtras.putInt(key,Integer.parseInt(value));
break;
case 'l':
intent.mExtras.putLong(key,Long.parseLong(value));
break;
case 's':
intent.mExtras.putShort(key,Short.parseShort(value));
break;
default :
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
}
 catch (NumberFormatException e) {
throw new URISyntaxException(uri,""String_Node_Str"",i);
}
char ch=uri.charAt(i);
if (ch == ')') break;
if (ch != '!') throw new URISyntaxException(uri,""String_Node_Str"",i);
i++;
}
}
if (isIntentFragment) {
intent.mData=Uri.parse(uri.substring(0,intentFragmentStart));
}
 else {
intent.mData=Uri.parse(uri);
}
if (intent.mAction == null) {
intent.mAction=ACTION_VIEW;
}
}
 else {
intent=new Intent(ACTION_VIEW,Uri.parse(uri));
}
return intent;
}"
23731,"/** 
 * Create an intent from a URI.  This URI may encode the action, category, and other intent fields, if it was returned by  {@link #toUri}.  If the Intent was not generate by toUri(), its data will be the entire URI and its action will be ACTION_VIEW. <p>The URI given here must not be relative -- that is, it must include the scheme and full path.
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or
 * @return Intent The newly created Intent object.
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntaxit bad (as parsed by the Uri class) or the Intent data within the URI is invalid.
 * @see #toUri
 */
public static Intent parseUri(String uri,int flags) throws URISyntaxException {
  int i=0;
  try {
    if ((flags & URI_INTENT_SCHEME) != 0) {
      if (!uri.startsWith(""String_Node_Str"")) {
        Intent intent=new Intent(ACTION_VIEW);
        try {
          intent.setData(Uri.parse(uri));
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
        return intent;
      }
    }
    i=uri.lastIndexOf(""String_Node_Str"");
    if (i == -1)     return new Intent(ACTION_VIEW,Uri.parse(uri));
    if (!uri.startsWith(""String_Node_Str"",i))     return getIntentOld(uri);
    Intent intent=new Intent(ACTION_VIEW);
    String data=i >= 0 ? uri.substring(0,i) : null;
    String scheme=null;
    i+=""String_Node_Str"".length();
    while (!uri.startsWith(""String_Node_Str"",i)) {
      int eq=uri.indexOf('=',i);
      int semi=uri.indexOf(';',eq);
      String value=Uri.decode(uri.substring(eq + 1,semi));
      if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mAction=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.addCategory(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mType=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mFlags=Integer.decode(value).intValue();
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mPackage=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mComponent=ComponentName.unflattenFromString(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        scheme=value;
      }
 else {
        String key=Uri.decode(uri.substring(i + 2,eq));
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        Bundle b=intent.mExtras;
        if (uri.startsWith(""String_Node_Str"",i))         b.putString(key,value);
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putBoolean(key,Boolean.parseBoolean(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putByte(key,Byte.parseByte(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putChar(key,value.charAt(0));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putDouble(key,Double.parseDouble(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putFloat(key,Float.parseFloat(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putInt(key,Integer.parseInt(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putLong(key,Long.parseLong(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putShort(key,Short.parseShort(value));
 else         throw new URISyntaxException(uri,""String_Node_Str"",i);
      }
      i=semi + 1;
    }
    if (data != null) {
      if (data.startsWith(""String_Node_Str"")) {
        data=data.substring(7);
        if (scheme != null) {
          data=scheme + ':' + data;
        }
      }
      if (data.length() > 0) {
        try {
          intent.mData=Uri.parse(data);
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
      }
    }
    return intent;
  }
 catch (  IndexOutOfBoundsException e) {
    throw new URISyntaxException(uri,""String_Node_Str"",i);
  }
}","/** 
 * Create an intent from a URI.  This URI may encode the action, category, and other intent fields, if it was returned by  {@link #toUri}.  If the Intent was not generate by toUri(), its data will be the entire URI and its action will be ACTION_VIEW. <p>The URI given here must not be relative -- that is, it must include the scheme and full path.
 * @param uri The URI to turn into an Intent.
 * @param flags Additional processing flags.  Either 0 or{@link #URI_INTENT_SCHEME}.
 * @return Intent The newly created Intent object.
 * @throws URISyntaxException Throws URISyntaxError if the basic URI syntaxit bad (as parsed by the Uri class) or the Intent data within the URI is invalid.
 * @see #toUri
 */
public static Intent parseUri(String uri,int flags) throws URISyntaxException {
  int i=0;
  try {
    if ((flags & URI_INTENT_SCHEME) != 0) {
      if (!uri.startsWith(""String_Node_Str"")) {
        Intent intent=new Intent(ACTION_VIEW);
        try {
          intent.setData(Uri.parse(uri));
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
        return intent;
      }
    }
    i=uri.lastIndexOf(""String_Node_Str"");
    if (i == -1)     return new Intent(ACTION_VIEW,Uri.parse(uri));
    if (!uri.startsWith(""String_Node_Str"",i))     return getIntentOld(uri);
    Intent intent=new Intent(ACTION_VIEW);
    String data=i >= 0 ? uri.substring(0,i) : null;
    String scheme=null;
    i+=""String_Node_Str"".length();
    while (!uri.startsWith(""String_Node_Str"",i)) {
      int eq=uri.indexOf('=',i);
      int semi=uri.indexOf(';',eq);
      String value=Uri.decode(uri.substring(eq + 1,semi));
      if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mAction=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.addCategory(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mType=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mFlags=Integer.decode(value).intValue();
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mPackage=value;
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        intent.mComponent=ComponentName.unflattenFromString(value);
      }
 else       if (uri.startsWith(""String_Node_Str"",i)) {
        scheme=value;
      }
 else {
        String key=Uri.decode(uri.substring(i + 2,eq));
        if (intent.mExtras == null)         intent.mExtras=new Bundle();
        Bundle b=intent.mExtras;
        if (uri.startsWith(""String_Node_Str"",i))         b.putString(key,value);
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putBoolean(key,Boolean.parseBoolean(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putByte(key,Byte.parseByte(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putChar(key,value.charAt(0));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putDouble(key,Double.parseDouble(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putFloat(key,Float.parseFloat(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putInt(key,Integer.parseInt(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putLong(key,Long.parseLong(value));
 else         if (uri.startsWith(""String_Node_Str"",i))         b.putShort(key,Short.parseShort(value));
 else         throw new URISyntaxException(uri,""String_Node_Str"",i);
      }
      i=semi + 1;
    }
    if (data != null) {
      if (data.startsWith(""String_Node_Str"")) {
        data=data.substring(7);
        if (scheme != null) {
          data=scheme + ':' + data;
        }
      }
      if (data.length() > 0) {
        try {
          intent.mData=Uri.parse(data);
        }
 catch (        IllegalArgumentException e) {
          throw new URISyntaxException(uri,e.getMessage());
        }
      }
    }
    return intent;
  }
 catch (  IndexOutOfBoundsException e) {
    throw new URISyntaxException(uri,""String_Node_Str"",i);
  }
}"
23732,"private void updateStatusLines(){
  if (!mStatus.showStatusLines()) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}","private void updateStatusLines(){
  if (!mStatus.showStatusLines() || (mCharging == null && mNextAlarm == null)) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}"
23733,"private void updateStatusLines(){
  if (!mStatus.showStatusLines()) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}","private void updateStatusLines(){
  if (!mStatus.showStatusLines() || (mCharging == null && mNextAlarm == null)) {
    mStatus1.setVisibility(View.INVISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
  }
 else   if (mCharging != null && mNextAlarm == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
  }
 else   if (mNextAlarm != null && mCharging == null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.INVISIBLE);
    mStatus1.setText(mNextAlarm);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
 else   if (mCharging != null && mNextAlarm != null) {
    mStatus1.setVisibility(View.VISIBLE);
    mStatus2.setVisibility(View.VISIBLE);
    mStatus1.setText(mCharging);
    mStatus1.setCompoundDrawablesWithIntrinsicBounds(mChargingIcon,null,null,null);
    mStatus2.setText(mNextAlarm);
    mStatus2.setCompoundDrawablesWithIntrinsicBounds(mAlarmIcon,null,null,null);
  }
}"
23734,"void onPropertyChanged(String[] propValues){
  if (mBluetoothService.isAdapterPropertiesEmpty()) {
    mBluetoothService.getAllProperties();
  }
  String name=propValues[0];
  if (name.equals(""String_Node_Str"")) {
    Intent intent=new Intent(BluetoothDevice.ACTION_NAME_CHANGED);
    intent.putExtra(BluetoothDevice.EXTRA_NAME,propValues[1]);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    String pairable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    String discoverable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    if (pairable == null || discoverable == null)     return;
    int mode=BluetoothService.bluezStringToScanMode(pairable.equals(""String_Node_Str""),discoverable.equals(""String_Node_Str""));
    if (mode >= 0) {
      Intent intent=new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
      intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE,mode);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    }
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    Intent intent;
    if (propValues[1].equals(""String_Node_Str"")) {
      mBluetoothService.setIsDiscovering(true);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
    }
 else {
      mBluetoothService.cancelDiscovery();
      mBluetoothService.setIsDiscovering(false);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    }
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    String value=null;
    int len=Integer.valueOf(propValues[1]);
    if (len > 0) {
      StringBuilder str=new StringBuilder();
      for (int i=2; i < propValues.length; i++) {
        str.append(propValues[i]);
        str.append(""String_Node_Str"");
      }
      value=str.toString();
    }
    mBluetoothService.setProperty(name,value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    if (propValues[1].equals(""String_Node_Str""))     onRestartRequired();
  }
}","void onPropertyChanged(String[] propValues){
  if (mBluetoothService.isAdapterPropertiesEmpty()) {
    mBluetoothService.getAllProperties();
  }
  String name=propValues[0];
  if (name.equals(""String_Node_Str"")) {
    Intent intent=new Intent(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED);
    intent.putExtra(BluetoothAdapter.EXTRA_LOCAL_NAME,propValues[1]);
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")) {
    String pairable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    String discoverable=name.equals(""String_Node_Str"") ? propValues[1] : mBluetoothService.getProperty(""String_Node_Str"");
    if (pairable == null || discoverable == null)     return;
    int mode=BluetoothService.bluezStringToScanMode(pairable.equals(""String_Node_Str""),discoverable.equals(""String_Node_Str""));
    if (mode >= 0) {
      Intent intent=new Intent(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED);
      intent.putExtra(BluetoothAdapter.EXTRA_SCAN_MODE,mode);
      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
      mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    }
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    Intent intent;
    if (propValues[1].equals(""String_Node_Str"")) {
      mBluetoothService.setIsDiscovering(true);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_STARTED);
    }
 else {
      mBluetoothService.cancelDiscovery();
      mBluetoothService.setIsDiscovering(false);
      intent=new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
    }
    mContext.sendBroadcast(intent,BLUETOOTH_PERM);
    mBluetoothService.setProperty(name,propValues[1]);
  }
 else   if (name.equals(""String_Node_Str"")) {
    String value=null;
    int len=Integer.valueOf(propValues[1]);
    if (len > 0) {
      StringBuilder str=new StringBuilder();
      for (int i=2; i < propValues.length; i++) {
        str.append(propValues[i]);
        str.append(""String_Node_Str"");
      }
      value=str.toString();
    }
    mBluetoothService.setProperty(name,value);
  }
 else   if (name.equals(""String_Node_Str"")) {
    if (propValues[1].equals(""String_Node_Str""))     onRestartRequired();
  }
}"
23735,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      setDisplayName((String)cookie,null);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    setDisplayName((String)cookie,null);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      String phoneNumber=(String)cookie;
      setDisplayName(phoneNumber,null);
      mPhotoView.assignContactFromPhone(phoneNumber,true);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    String emailAddress=(String)cookie;
    setDisplayName(emailAddress,null);
    mPhotoView.assignContactFromEmail(emailAddress,true);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}"
23736,"private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 2))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}","private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (nextNonPwCharIndex > (currPwIndex + 1)) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}"
23737,"boolean update(DriverCall dc){
  CdmaCall newParent;
  boolean changed=false;
  boolean wasConnectingInOrOut=isConnectingInOrOut();
  boolean wasHolding=(getState() == CdmaCall.State.HOLDING);
  newParent=parentFromDCState(dc.state);
  if (!equalsHandlesNulls(address,dc.number)) {
    if (Phone.DEBUG_PHONE)     log(""String_Node_Str"");
    address=dc.number;
    changed=true;
  }
  if (TextUtils.isEmpty(dc.name)) {
    if (!TextUtils.isEmpty(cnapName)) {
      changed=true;
      cnapName=""String_Node_Str"";
    }
  }
 else   if (!dc.name.equals(cnapName)) {
    changed=true;
    cnapName=dc.name;
  }
  log(""String_Node_Str"" + cnapName);
  cnapNamePresentation=dc.namePresentation;
  numberPresentation=dc.numberPresentation;
  if (newParent != parent) {
    if (parent != null) {
      parent.detach(this);
    }
    newParent.attach(this,dc);
    parent=newParent;
    changed=true;
  }
 else {
    boolean parentStateChange;
    parentStateChange=parent.update(this,dc);
    changed=changed || parentStateChange;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + parent + ""String_Node_Str""+ (newParent != parent)+ ""String_Node_Str""+ wasConnectingInOrOut+ ""String_Node_Str""+ wasHolding+ ""String_Node_Str""+ isConnectingInOrOut()+ ""String_Node_Str""+ changed);
  if (wasConnectingInOrOut && !isConnectingInOrOut()) {
    onConnectedInOrOut();
  }
  if (changed && !wasHolding && (getState() == CdmaCall.State.HOLDING)) {
    onStartedHolding();
  }
  return changed;
}","boolean update(DriverCall dc){
  CdmaCall newParent;
  boolean changed=false;
  boolean wasConnectingInOrOut=isConnectingInOrOut();
  boolean wasHolding=(getState() == CdmaCall.State.HOLDING);
  newParent=parentFromDCState(dc.state);
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + parent + ""String_Node_Str""+ newParent);
  if (!equalsHandlesNulls(address,dc.number)) {
    if (Phone.DEBUG_PHONE)     log(""String_Node_Str"");
    address=dc.number;
    changed=true;
  }
  if (TextUtils.isEmpty(dc.name)) {
    if (!TextUtils.isEmpty(cnapName)) {
      changed=true;
      cnapName=""String_Node_Str"";
    }
  }
 else   if (!dc.name.equals(cnapName)) {
    changed=true;
    cnapName=dc.name;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + cnapName);
  cnapNamePresentation=dc.namePresentation;
  numberPresentation=dc.numberPresentation;
  if (newParent != parent) {
    if (parent != null) {
      parent.detach(this);
    }
    newParent.attach(this,dc);
    parent=newParent;
    changed=true;
  }
 else {
    boolean parentStateChange;
    parentStateChange=parent.update(this,dc);
    changed=changed || parentStateChange;
  }
  if (Phone.DEBUG_PHONE)   log(""String_Node_Str"" + wasConnectingInOrOut + ""String_Node_Str""+ wasHolding+ ""String_Node_Str""+ isConnectingInOrOut()+ ""String_Node_Str""+ changed);
  if (wasConnectingInOrOut && !isConnectingInOrOut()) {
    onConnectedInOrOut();
  }
  if (changed && !wasHolding && (getState() == CdmaCall.State.HOLDING)) {
    onStartedHolding();
  }
  return changed;
}"
23738,"/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 2)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}","/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 1)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}"
23739,"/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param conatctUri Either a {Contacts.CONTENT_URI} or {Contacts.CONTENT_LOOKUP_URI}style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}","/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param contactUri Either a {@link Contacts#CONTENT_URI} or{@link Contacts#CONTENT_LOOKUP_URI} style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}"
23740,"/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}"
23741,"public void onClick(View v){
  final Rect target=getTargetRect(v);
  if (mContactUri != null) {
    trigger(mContactUri,target);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}","public void onClick(View v){
  if (mContactUri != null) {
    final ContentResolver resolver=getContext().getContentResolver();
    final Uri lookupUri=Contacts.getLookupUri(resolver,mContactUri);
    trigger(lookupUri);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,mContactEmail,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,mContactPhone,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}"
23742,"/** 
 * Set the fasttrack window mode. Options are   {@link Intents.MODE_SMALL},  {@link Intents.MODE_MEDIUM},   {@link Intents.MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}","/** 
 * Set the fasttrack window mode. Options are   {@link FastTrack#MODE_SMALL},  {@link FastTrack#MODE_MEDIUM},   {@link FastTrack#MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}"
23743,"public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,Intents.MODE_MEDIUM);
  a.recycle();
  init();
}","public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,FastTrack.MODE_MEDIUM);
  a.recycle();
  init();
}"
23744,"/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}"
23745,"private void trigger(Uri contactUri,Rect target){
  Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,contactUri);
  intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
  intent.putExtra(Intents.EXTRA_MODE,mMode);
  mContext.startActivity(intent);
}","private void trigger(Uri lookupUri){
  FastTrack.showFastTrack(getContext(),this,lookupUri,mMode,mExcludeMimes);
}"
23746,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri contactUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
case TOKEN_PHONE_LOOKUP:
{
      if (cursor != null && cursor.moveToFirst()) {
        long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
        String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
        contactUri=Contacts.getLookupUri(contactId,lookupKey);
      }
      break;
    }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
  trigger=true;
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
    contactUri=Contacts.getLookupUri(contactId,lookupKey);
  }
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
if (contactUri != null) {
mContactUri=contactUri;
if (trigger && cookie != null) {
trigger(contactUri,(Rect)cookie);
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri lookupUri=null;
  Uri createUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
    createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
      lookupUri=Contacts.getLookupUri(contactId,lookupKey);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
trigger=true;
createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_EMAIL_LOOKUP:
{
if (cursor != null && cursor.moveToFirst()) {
long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
lookupUri=Contacts.getLookupUri(contactId,lookupKey);
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
mContactUri=lookupUri;
if (trigger && lookupUri != null) {
trigger(lookupUri);
}
 else if (createUri != null) {
final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,createUri);
getContext().startActivity(intent);
}
}"
23747,"/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param conatctUri Either a {Contacts.CONTENT_URI} or {Contacts.CONTENT_LOOKUP_URI}style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}","/** 
 * Assign the contact uri that this fasttrack badge should be associated with. Note that this is only used for displaying the fasttrack window and won't bind the contact's photo for you.
 * @param contactUri Either a {@link Contacts#CONTENT_URI} or{@link Contacts#CONTENT_LOOKUP_URI} style URI.
 */
public void assignContactUri(Uri contactUri){
  mContactUri=contactUri;
}"
23748,"/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on a phone number. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the phone number.
 * @param phoneNumber The phone number of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromPhone(String phoneNumber,boolean lazyLookup){
  mContactPhone=phoneNumber;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,null,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}"
23749,"public void onClick(View v){
  final Rect target=getTargetRect(v);
  if (mContactUri != null) {
    trigger(mContactUri,target);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,target,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}","public void onClick(View v){
  if (mContactUri != null) {
    final ContentResolver resolver=getContext().getContentResolver();
    final Uri lookupUri=Contacts.getLookupUri(resolver,mContactUri);
    trigger(lookupUri);
  }
 else   if (mContactEmail != null) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP_AND_TRIGGER,mContactEmail,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else   if (mContactPhone != null) {
    mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP_AND_TRIGGER,mContactPhone,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,mContactPhone),PHONE_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    return;
  }
}"
23750,"/** 
 * Set the fasttrack window mode. Options are   {@link Intents.MODE_SMALL},  {@link Intents.MODE_MEDIUM},   {@link Intents.MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}","/** 
 * Set the fasttrack window mode. Options are   {@link FastTrack#MODE_SMALL},  {@link FastTrack#MODE_MEDIUM},   {@link FastTrack#MODE_LARGE}.
 * @param size
 */
public void setMode(int size){
  mMode=size;
}"
23751,"public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,Intents.MODE_MEDIUM);
  a.recycle();
  init();
}","public FasttrackBadgeWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.FasttrackBadgeWidget,defStyle,0);
  mMode=a.getInt(com.android.internal.R.styleable.FasttrackBadgeWidget_fasttrackWindowSize,FastTrack.MODE_MEDIUM);
  a.recycle();
  init();
}"
23752,"/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
}","/** 
 * Assign a contact based on an email address. This should only be used when the contact's URI is not available, as an extra query will have to be performed to lookup the URI based on the email.
 * @param emailAddress The email address of the contact.
 * @param lazyLookup If this is true, the lookup query will not be performeduntil this view is clicked.
 */
public void assignContactFromEmail(String emailAddress,boolean lazyLookup){
  mContactEmail=emailAddress;
  if (!lazyLookup) {
    mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,null,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(mContactEmail)),EMAIL_LOOKUP_PROJECTION,null,null,null);
  }
 else {
    mContactUri=null;
  }
}"
23753,"private void trigger(Uri contactUri,Rect target){
  Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,contactUri);
  intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
  intent.putExtra(Intents.EXTRA_MODE,mMode);
  mContext.startActivity(intent);
}","private void trigger(Uri lookupUri){
  FastTrack.showFastTrack(getContext(),this,lookupUri,mMode,mExcludeMimes);
}"
23754,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri contactUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
case TOKEN_PHONE_LOOKUP:
{
      if (cursor != null && cursor.moveToFirst()) {
        long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
        String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
        contactUri=Contacts.getLookupUri(contactId,lookupKey);
      }
      break;
    }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
  trigger=true;
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
    contactUri=Contacts.getLookupUri(contactId,lookupKey);
  }
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
if (contactUri != null) {
mContactUri=contactUri;
if (trigger && cookie != null) {
trigger(contactUri,(Rect)cookie);
}
}
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  Uri lookupUri=null;
  Uri createUri=null;
  boolean trigger=false;
  try {
switch (token) {
case TOKEN_PHONE_LOOKUP_AND_TRIGGER:
      trigger=true;
    createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_STRING_COLUMN_INDEX);
      lookupUri=Contacts.getLookupUri(contactId,lookupKey);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP_AND_TRIGGER:
trigger=true;
createUri=Uri.fromParts(""String_Node_Str"",(String)cookie,null);
case TOKEN_EMAIL_LOOKUP:
{
if (cursor != null && cursor.moveToFirst()) {
long contactId=cursor.getLong(EMAIL_ID_COLUMN_INDEX);
String lookupKey=cursor.getString(EMAIL_LOOKUP_STRING_COLUMN_INDEX);
lookupUri=Contacts.getLookupUri(contactId,lookupKey);
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
mContactUri=lookupUri;
if (trigger && lookupUri != null) {
trigger(lookupUri);
}
 else if (createUri != null) {
final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,createUri);
getContext().startActivity(intent);
}
}"
23755,"boolean isInProximity(double latitude,double longitude){
  Location loc=new Location(""String_Node_Str"");
  loc.setLatitude(latitude);
  loc.setLongitude(longitude);
  double radius=loc.distanceTo(mLocation);
  return radius <= mRadius;
}","boolean isInProximity(double latitude,double longitude,float accuracy){
  Location loc=new Location(""String_Node_Str"");
  loc.setLatitude(latitude);
  loc.setLongitude(longitude);
  double radius=loc.distanceTo(mLocation);
  return radius <= Math.max(mRadius,accuracy);
}"
23756,"public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}","public void onLocationChanged(Location loc){
  if (loc.getProvider().equals(LocationManager.GPS_PROVIDER)) {
    isGpsAvailable=true;
  }
  if (isGpsAvailable && loc.getProvider().equals(LocationManager.NETWORK_PROVIDER)) {
    return;
  }
  long now=System.currentTimeMillis();
  double latitude=loc.getLatitude();
  double longitude=loc.getLongitude();
  float accuracy=loc.getAccuracy();
  ArrayList<PendingIntent> intentsToRemove=null;
  for (  ProximityAlert alert : mProximityAlerts.values()) {
    PendingIntent intent=alert.getIntent();
    long expiration=alert.getExpiration();
    if ((expiration == -1) || (now <= expiration)) {
      boolean entered=mProximitiesEntered.contains(alert);
      boolean inProximity=alert.isInProximity(latitude,longitude,accuracy);
      if (!entered && inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.add(alert);
        Intent enteredIntent=new Intent();
        enteredIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,true);
        try {
synchronized (this) {
            intent.send(mContext,0,enteredIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
 else       if (entered && !inProximity) {
        if (LOCAL_LOGV) {
          Log.v(TAG,""String_Node_Str"");
        }
        mProximitiesEntered.remove(alert);
        Intent exitedIntent=new Intent();
        exitedIntent.putExtra(LocationManager.KEY_PROXIMITY_ENTERING,false);
        try {
synchronized (this) {
            intent.send(mContext,0,exitedIntent,this,mLocationHandler);
            incrementPendingBroadcasts();
          }
        }
 catch (        PendingIntent.CanceledException e) {
          if (LOCAL_LOGV) {
            Log.v(TAG,""String_Node_Str"" + alert,e);
          }
          if (intentsToRemove == null) {
            intentsToRemove=new ArrayList<PendingIntent>();
          }
          intentsToRemove.add(intent);
        }
      }
    }
 else {
      if (LOCAL_LOGV) {
        Log.v(TAG,""String_Node_Str"" + alert);
      }
      if (intentsToRemove == null) {
        intentsToRemove=new ArrayList<PendingIntent>();
      }
      intentsToRemove.add(alert.getIntent());
    }
  }
  if (intentsToRemove != null) {
    for (    PendingIntent i : intentsToRemove) {
      mProximityAlerts.remove(i);
      ProximityAlert alert=mProximityAlerts.get(i);
      mProximitiesEntered.remove(alert);
    }
  }
}"
23757,"private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_PANEL,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}","private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}"
23758,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
23759,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}"
23760,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}"
23761,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}"
23762,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}"
23763,"protected void onLooperPrepared(){
  mDidSetup=true;
  mLooperTid=Process.myTid();
}","protected void onLooperPrepared(){
synchronized (HandlerThreadTest.this) {
    mDidSetup=true;
    mLooperTid=Process.myTid();
    HandlerThreadTest.this.notify();
  }
}"
23764,"@MediumTest public void testHandlerThread() throws Exception {
  HandlerThread th1=new HandlerThread(""String_Node_Str""){
    protected void onLooperPrepared(){
      mDidSetup=true;
      mLooperTid=Process.myTid();
    }
  }
;
  assertFalse(th1.isAlive());
  assertNull(th1.getLooper());
  th1.start();
  assertTrue(th1.isAlive());
  assertNotNull(th1.getLooper());
  assertNotSame(Process.myTid(),mLooperTid);
  assertTrue(mDidSetup);
  final Handler h1=new Handler(th1.getLooper()){
    public void handleMessage(    Message msg){
      assertEquals(TEST_WHAT,msg.what);
      assertEquals(mLooperTid,Process.myTid());
      mGotMessageWhat=msg.what;
      mGotMessage=true;
synchronized (this) {
        notifyAll();
      }
    }
  }
;
  Message msg=h1.obtainMessage(TEST_WHAT);
synchronized (h1) {
    h1.sendMessage(msg);
    try {
      h1.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(mGotMessage);
  assertEquals(TEST_WHAT,mGotMessageWhat);
}","@MediumTest public void testHandlerThread() throws Exception {
  HandlerThread th1=new HandlerThread(""String_Node_Str""){
    protected void onLooperPrepared(){
synchronized (HandlerThreadTest.this) {
        mDidSetup=true;
        mLooperTid=Process.myTid();
        HandlerThreadTest.this.notify();
      }
    }
  }
;
  assertFalse(th1.isAlive());
  assertNull(th1.getLooper());
  th1.start();
  assertTrue(th1.isAlive());
  assertNotNull(th1.getLooper());
synchronized (this) {
    while (!mDidSetup) {
      try {
        wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  assertNotSame(-1,mLooperTid);
  assertNotSame(Process.myTid(),mLooperTid);
  final Handler h1=new Handler(th1.getLooper()){
    public void handleMessage(    Message msg){
      assertEquals(TEST_WHAT,msg.what);
      assertEquals(mLooperTid,Process.myTid());
      mGotMessageWhat=msg.what;
      mGotMessage=true;
synchronized (this) {
        notifyAll();
      }
    }
  }
;
  Message msg=h1.obtainMessage(TEST_WHAT);
synchronized (h1) {
    h1.sendMessage(msg);
    try {
      h1.wait();
    }
 catch (    InterruptedException e) {
    }
  }
  assertTrue(mGotMessage);
  assertEquals(TEST_WHAT,mGotMessageWhat);
}"
23765,"public void onClick(View view){
  if (mContactUri == null) {
    return;
  }
switch (view.getId()) {
case R.id.star:
{
      final ContentValues values=new ContentValues(1);
      values.put(Contacts.STARRED,mStarredView.isChecked());
      mContentResolver.update(mContactUri,values,null,null);
      break;
    }
case R.id.photo:
{
    final Intent intent=new Intent(Intents.SHOW_OR_CREATE_CONTACT,mContactUri);
    final Rect target=getTargetRect(view);
    intent.putExtra(Intents.EXTRA_TARGET_RECT,target);
    intent.putExtra(Intents.EXTRA_MODE,Intents.MODE_SMALL);
    if (mExcludeMimes != null) {
      intent.putExtra(Intents.EXTRA_EXCLUDE_MIMES,mExcludeMimes);
    }
    mContext.startActivity(intent);
    break;
  }
}
}","public void onClick(View view){
  if (mContactUri == null) {
    return;
  }
  if (view.getId() == R.id.star) {
    final ContentValues values=new ContentValues(1);
    values.put(Contacts.STARRED,mStarredView.isChecked());
    mContentResolver.update(mContactUri,values,null,null);
  }
}"
23766,"/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}","/** 
 * Bind the contact details provided by the given   {@link Cursor}.
 */
protected void bindContactInfo(Cursor c){
  if (c == null || !c.moveToFirst())   return;
  final String displayName=c.getString(HEADER_DISPLAY_NAME_COLUMN_INDEX);
  final long contactId=c.getLong(HEADER_CONTACT_ID_COLUMN_INDEX);
  final String lookupKey=c.getString(HEADER_LOOKUP_KEY_COLUMN_INDEX);
  final String phoneticName=null;
  this.setDisplayName(displayName,null);
  final boolean starred=c.getInt(HEADER_STARRED_COLUMN_INDEX) != 0;
  mStarredView.setChecked(starred);
  Bitmap photoBitmap=loadContactPhoto(c.getLong(HEADER_PHOTO_ID_COLUMN_INDEX),null);
  if (photoBitmap == null) {
    photoBitmap=loadPlaceholderPhoto(null);
  }
  mPhotoView.setImageBitmap(photoBitmap);
  mPhotoView.assignContactUri(Contacts.getLookupUri(contactId,lookupKey));
  int presence=c.getInt(HEADER_PRESENCE_STATUS_COLUMN_INDEX);
  mPresenceView.setImageResource(Presence.getPresenceIconResourceId(presence));
}"
23767,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  Cursor c=null;
  try {
    c=mContentResolver.query(Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,Uri.encode(number)),PHONE_LOOKUP_PROJECTION,null,null,null);
    if (c != null && c.moveToFirst()) {
      long contactId=c.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      bindFromContactId(contactId);
    }
 else {
      setDisplayName(number,null);
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param number The phone number used to do a reverse lookup inthe contacts database. If more than one contact contains this phone number, one of them will be chosen to bind to.
 */
public void bindFromPhoneNumber(String number){
  mQueryHandler.startQuery(TOKEN_PHONE_LOOKUP,number,Uri.withAppendedPath(PhoneLookup.CONTENT_FILTER_URI,number),PHONE_LOOKUP_PROJECTION,null,null,null);
}"
23768,"/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  Cursor c=null;
  try {
    c=mContentResolver.query(Uri.withAppendedPath(Email.CONTENT_FILTER_EMAIL_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
    if (c != null && c.moveToFirst()) {
      long contactId=c.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      bindFromContactId(contactId);
    }
 else {
      setDisplayName(emailAddress,null);
    }
  }
  finally {
    if (c != null) {
      c.close();
    }
  }
}","/** 
 * Convenience method for binding all available data from an existing contact.
 * @param emailAddress The email address used to do a reverse lookup inthe contacts database. If more than one contact contains this email address, one of them will be chosen to bind to.
 */
public void bindFromEmail(String emailAddress){
  mQueryHandler.startQuery(TOKEN_EMAIL_LOOKUP,emailAddress,Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI,Uri.encode(emailAddress)),EMAIL_LOOKUP_PROJECTION,null,null,null);
}"
23769,"public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mDisplayNameView.setOnLongClickListener(this);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(ImageView)findViewById(R.id.photo);
  mPhotoView.setOnClickListener(this);
  mPhotoView.setOnLongClickListener(this);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}","public ContactHeaderWidget(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mContentResolver=mContext.getContentResolver();
  LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  inflater.inflate(R.layout.contact_header,this);
  mDisplayNameView=(TextView)findViewById(R.id.name);
  mDisplayNameView.setOnLongClickListener(this);
  mPhoneticNameView=(TextView)findViewById(R.id.phonetic_name);
  mStarredView=(CheckBox)findViewById(R.id.star);
  mStarredView.setOnClickListener(this);
  mPhotoView=(FasttrackBadgeWidget)findViewById(R.id.photo);
  mPhotoView.setOnLongClickListener(this);
  mPresenceView=(ImageView)findViewById(R.id.presence);
  mStatusView=(TextView)findViewById(R.id.status);
  long now=SystemClock.elapsedRealtime();
  int num=(int)now & 0xf;
  if (num < 9) {
    mNoPhotoResource=R.drawable.ic_contact_picture;
  }
 else   if (num < 14) {
    mNoPhotoResource=R.drawable.ic_contact_picture_2;
  }
 else {
    mNoPhotoResource=R.drawable.ic_contact_picture_3;
  }
  mQueryHandler=new QueryHandler(mContentResolver);
}"
23770,"@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
    if (token == TOKEN_CONTACT_INFO) {
      bindContactInfo(cursor);
      invalidate();
    }
 else     if (token == TOKEN_SOCIAL) {
      bindSocial(cursor);
      invalidate();
    }
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override protected void onQueryComplete(int token,Object cookie,Cursor cursor){
  try {
switch (token) {
case TOKEN_CONTACT_INFO:
{
        bindContactInfo(cursor);
        invalidate();
        break;
      }
case TOKEN_SOCIAL:
{
      bindSocial(cursor);
      invalidate();
      break;
    }
case TOKEN_PHONE_LOOKUP:
{
    if (cursor != null && cursor.moveToFirst()) {
      long contactId=cursor.getLong(PHONE_LOOKUP_CONTACT_ID_COLUMN_INDEX);
      String lookupKey=cursor.getString(PHONE_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
      bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
    }
 else {
      setDisplayName((String)cookie,null);
    }
    break;
  }
case TOKEN_EMAIL_LOOKUP:
{
  if (cursor != null && cursor.moveToFirst()) {
    long contactId=cursor.getLong(EMAIL_LOOKUP_CONTACT_ID_COLUMN_INDEX);
    String lookupKey=cursor.getString(EMAIL_LOOKUP_CONTACT_LOOKUP_KEY_COLUMN_INDEX);
    bindFromContactUri(Contacts.getLookupUri(contactId,lookupKey));
  }
 else {
    setDisplayName((String)cookie,null);
  }
  break;
}
case TOKEN_LOOKUP_CONTACT_FOR_SOCIAL_QUERY:
{
if (cursor != null && cursor.moveToFirst()) {
  long contactId=cursor.getLong(CONTACT_LOOKUP_ID_COLUMN_INDEX);
  startSocialQuery(ContentUris.withAppendedId(Activities.CONTENT_CONTACT_STATUS_URI,contactId));
}
}
}
}
  finally {
if (cursor != null) {
cursor.close();
}
}
}"
23771,"private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_PANEL,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}","private void openPanel(PanelFeatureState st,KeyEvent event){
  if (st.isOpen) {
    return;
  }
  Callback cb=getCallback();
  if ((cb != null) && (!cb.onMenuOpened(st.featureId,st.menu))) {
    closePanel(st,true);
    return;
  }
  final WindowManager wm=getWindowManager();
  if (wm == null) {
    return;
  }
  if (!preparePanel(st,event)) {
    return;
  }
  if (st.decorView == null || st.refreshDecorView) {
    if (st.decorView == null) {
      if (!initializePanelDecor(st) || (st.decorView == null))       return;
    }
 else     if (st.refreshDecorView && (st.decorView.getChildCount() > 0)) {
      st.decorView.removeAllViews();
    }
    if (!initializePanelContent(st) || (st.shownPanelView == null)) {
      return;
    }
    ViewGroup.LayoutParams lp=st.shownPanelView.getLayoutParams();
    if (lp == null) {
      lp=new ViewGroup.LayoutParams(WRAP_CONTENT,WRAP_CONTENT);
    }
    int backgroundResId;
    if (lp.width == ViewGroup.LayoutParams.FILL_PARENT) {
      backgroundResId=st.fullBackground;
    }
 else {
      backgroundResId=st.background;
    }
    st.decorView.setWindowBackground(getContext().getResources().getDrawable(backgroundResId));
    st.decorView.addView(st.shownPanelView,lp);
    if (!st.shownPanelView.hasFocus()) {
      st.shownPanelView.requestFocus();
    }
  }
  st.isOpen=true;
  st.isHandled=false;
  WindowManager.LayoutParams lp=new WindowManager.LayoutParams(WRAP_CONTENT,WRAP_CONTENT,st.x,st.y,WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG,WindowManager.LayoutParams.FLAG_DITHER | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,st.decorView.mDefaultOpacity);
  lp.gravity=st.gravity;
  lp.windowAnimations=st.windowAnimations;
  wm.addView(st.decorView,lp);
}"
23772,"/** 
 * Sets the setting for when the vibrate type should vibrate.
 * @param vibrateType The type of vibrate. One of{@link #VIBRATE_TYPE_NOTIFICATION} or{@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of{@link #VIBRATE_SETTING_ON},  {@link #VIBRATE_SETTING_OFF}, or  {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 */
public void setVibrateSetting(int vibrateType,int vibrateSetting){
  IAudioService service=getService();
  try {
    service.setVibrateSetting(vibrateType,vibrateSetting);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the setting for when the vibrate type should vibrate. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param vibrateType The type of vibrate. One of{@link #VIBRATE_TYPE_NOTIFICATION} or{@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of{@link #VIBRATE_SETTING_ON},  {@link #VIBRATE_SETTING_OFF}, or  {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 */
public void setVibrateSetting(int vibrateType,int vibrateSetting){
  IAudioService service=getService();
  try {
    service.setVibrateSetting(vibrateType,vibrateSetting);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23773,"/** 
 * Adjusts the volume of a particular stream by one step in a direction.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustStreamVolume(streamType,direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of a particular stream by one step in a direction. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},  {@link #STREAM_SYSTEM},   {@link #STREAM_RING},   {@link #STREAM_MUSIC} or{@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustStreamVolume(int streamType,int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustStreamVolume(streamType,direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23774,"/** 
 * Mute or unmute an audio stream. <p> The mute command is protected against client process death: if a process with an active mute request on a stream dies, this stream will be unmuted automatically. <p> The mute requests for a given stream are cumulative: the AudioManager can receive several mute requests from one or more clients and the stream will be unmuted only when the same number of unmute requests are received. <p> For a better user experience, applications MUST unmute a muted stream in onPause() and mute is again in onResume() if appropriate.
 * @param streamType The stream to be muted/unmuted.
 * @param state The required mute state: true for mute ON, false for mute OFF
 */
public void setStreamMute(int streamType,boolean state){
  IAudioService service=getService();
  try {
    service.setStreamMute(streamType,state,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Mute or unmute an audio stream. <p> The mute command is protected against client process death: if a process with an active mute request on a stream dies, this stream will be unmuted automatically. <p> The mute requests for a given stream are cumulative: the AudioManager can receive several mute requests from one or more clients and the stream will be unmuted only when the same number of unmute requests are received. <p> For a better user experience, applications MUST unmute a muted stream in onPause() and mute is again in onResume() if appropriate. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param streamType The stream to be muted/unmuted.
 * @param state The required mute state: true for mute ON, false for mute OFF
 */
public void setStreamMute(int streamType,boolean state){
  IAudioService service=getService();
  try {
    service.setStreamMute(streamType,state,mICallBack);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23775,"/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream, or the given fallback stream. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param suggestedStreamType The stream type that will be used if thereisn't a relevant stream.  {@link #USE_DEFAULT_STREAM_TYPE} is valid here.
 * @param flags One or more flags.
 * @see #adjustVolume(int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustSuggestedStreamVolume(int direction,int suggestedStreamType,int flags){
  IAudioService service=getService();
  try {
    service.adjustSuggestedStreamVolume(direction,suggestedStreamType,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23776,"/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustVolume(direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Adjusts the volume of the most relevant stream. For example, if a call is active, it will have the highest priority regardless of if the in-call screen is showing. Another example, if music is playing in the background and a call is not active, the music stream will be adjusted. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param direction The direction to adjust the volume. One of{@link #ADJUST_LOWER},   {@link #ADJUST_RAISE}, or  {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustSuggestedStreamVolume(int,int,int)
 * @see #adjustStreamVolume(int,int,int)
 * @see #setStreamVolume(int,int,int)
 */
public void adjustVolume(int direction,int flags){
  IAudioService service=getService();
  try {
    service.adjustVolume(direction,flags);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23777,"/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Request use of Bluetooth SCO headset for communications. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23778,"/** 
 * Sets the microphone mute on or off.
 * @param on set <var>true</var> to mute the microphone;<var>false</var> to turn mute off
 */
public void setMicrophoneMute(boolean on){
  AudioSystem.muteMicrophone(on);
}","/** 
 * Sets the microphone mute on or off. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to mute the microphone;<var>false</var> to turn mute off
 */
public void setMicrophoneMute(boolean on){
  AudioSystem.muteMicrophone(on);
}"
23779,"/** 
 * Sets the audio mode.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the audio mode. <p> The audio mode encompasses audio routing AND the behavior of the telephony layer. Therefore this method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application. In particular, the   {@link #MODE_IN_CALL} mode should only be used by the telephonyapplication when it places a phone call, as it will cause signals from the radio layer to feed the platform mixer.
 * @param mode  the requested audio mode (NORMAL, RINGTONE, or IN_CALL).Informs the HAL about the current audio state so that it can route the audio appropriately.
 */
public void setMode(int mode){
  IAudioService service=getService();
  try {
    service.setMode(mode);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23780,"/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","/** 
 * Sets the speakerphone on or off. <p> This method should only be used by applications that replace the platform-wide management of audio settings or the main telephony application.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23781,"protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          if (mIsEcmTimerCanceled) {
            handleEcmTimer(phone.RESTART_ECM_TIMER);
          }
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        connections[i]=new CdmaConnection(phone.getContext(),dc,this,i);
        if (connections[i].getCall() == ringingCall) {
          newRinging=connections[i];
        }
 else {
          Log.i(LOG_TAG,""String_Node_Str"" + dc);
          if (dc.state != DriverCall.State.ALERTING && dc.state != DriverCall.State.DIALING) {
            connections[i].connectTime=System.currentTimeMillis();
          }
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      if (mIsEcmTimerCanceled) {
        handleEcmTimer(phone.RESTART_ECM_TIMER);
      }
 else {
        mIsInEmergencyCall=false;
      }
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      boolean changed;
      changed=conn.update(dc);
      hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInEcm) {
      pendingCallInEcm=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}","protected void handlePollCalls(AsyncResult ar){
  List polledCalls;
  if (ar.exception == null) {
    polledCalls=(List)ar.result;
  }
 else   if (isCommandExceptionRadioNotAvailable(ar.exception)) {
    polledCalls=new ArrayList();
  }
 else {
    pollCallsAfterDelay();
    return;
  }
  Connection newRinging=null;
  boolean hasNonHangupStateChanged=false;
  boolean needsPollDelay=false;
  boolean unknownConnectionAppeared=false;
  for (int i=0, curDC=0, dcSize=polledCalls.size(); i < connections.length; i++) {
    CdmaConnection conn=connections[i];
    DriverCall dc=null;
    if (curDC < dcSize) {
      dc=(DriverCall)polledCalls.get(curDC);
      if (dc.index == i + 1) {
        curDC++;
      }
 else {
        dc=null;
      }
    }
    if (DBG_POLL)     log(""String_Node_Str"" + i + ""String_Node_Str""+ conn+ ""String_Node_Str""+ dc);
    if (conn == null && dc != null) {
      if (pendingMO != null && pendingMO.compareTo(dc)) {
        if (DBG_POLL)         log(""String_Node_Str"" + pendingMO);
        connections[i]=pendingMO;
        pendingMO.index=i;
        pendingMO.update(dc);
        pendingMO=null;
        if (hangupPendingMO) {
          hangupPendingMO=false;
          if (mIsEcmTimerCanceled) {
            handleEcmTimer(phone.RESTART_ECM_TIMER);
          }
          try {
            if (Phone.DEBUG_PHONE)             log(""String_Node_Str"" + i);
            hangup(connections[i]);
          }
 catch (          CallStateException ex) {
            Log.e(LOG_TAG,""String_Node_Str"");
          }
          return;
        }
      }
 else {
        if (Phone.DEBUG_PHONE) {
          log(""String_Node_Str"" + pendingMO + dc);
        }
        newRinging=checkMtFindNewRinging(dc,i);
        if (newRinging == null) {
          unknownConnectionAppeared=true;
        }
      }
      hasNonHangupStateChanged=true;
    }
 else     if (conn != null && dc == null) {
      int count=foregroundCall.connections.size();
      if (count == 0) {
        droppedDuringPoll.add(conn);
      }
 else {
        for (int n=0; n < count; n++) {
          CdmaConnection cn=(CdmaConnection)foregroundCall.connections.get(n);
          droppedDuringPoll.add(cn);
        }
      }
      foregroundCall.setGeneric(false);
      if (mIsEcmTimerCanceled) {
        handleEcmTimer(phone.RESTART_ECM_TIMER);
      }
 else {
        mIsInEmergencyCall=false;
      }
      connections[i]=null;
    }
 else     if (conn != null && dc != null) {
      if (conn.isIncoming != dc.isMT) {
        if (dc.isMT == true) {
          droppedDuringPoll.add(conn);
          newRinging=checkMtFindNewRinging(dc,i);
          if (newRinging == null) {
            unknownConnectionAppeared=true;
          }
        }
 else {
          Log.e(LOG_TAG,""String_Node_Str"" + dc);
        }
      }
 else {
        boolean changed;
        changed=conn.update(dc);
        hasNonHangupStateChanged=hasNonHangupStateChanged || changed;
      }
    }
    if (REPEAT_POLLING) {
      if (dc != null) {
        if ((dc.state == DriverCall.State.DIALING) || (dc.state == DriverCall.State.ALERTING) || (dc.state == DriverCall.State.INCOMING)|| (dc.state == DriverCall.State.WAITING)) {
          needsPollDelay=true;
        }
      }
    }
  }
  if (pendingMO != null) {
    Log.d(LOG_TAG,""String_Node_Str"" + foregroundCall.getState());
    droppedDuringPoll.add(pendingMO);
    pendingMO=null;
    hangupPendingMO=false;
    if (pendingCallInEcm) {
      pendingCallInEcm=false;
    }
  }
  if (newRinging != null) {
    phone.notifyNewRingingConnection(newRinging);
  }
  for (int i=droppedDuringPoll.size() - 1; i >= 0; i--) {
    CdmaConnection conn=droppedDuringPoll.get(i);
    if (conn.isIncoming() && conn.getConnectTime() == 0) {
      Connection.DisconnectCause cause;
      if (conn.cause == Connection.DisconnectCause.LOCAL) {
        cause=Connection.DisconnectCause.INCOMING_REJECTED;
      }
 else {
        cause=Connection.DisconnectCause.INCOMING_MISSED;
      }
      if (Phone.DEBUG_PHONE) {
        log(""String_Node_Str"" + conn.cause);
        log(""String_Node_Str"" + cause);
      }
      droppedDuringPoll.remove(i);
      conn.onDisconnect(cause);
    }
 else     if (conn.cause == Connection.DisconnectCause.LOCAL) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.LOCAL);
    }
 else     if (conn.cause == Connection.DisconnectCause.INVALID_NUMBER) {
      droppedDuringPoll.remove(i);
      conn.onDisconnect(Connection.DisconnectCause.INVALID_NUMBER);
    }
  }
  if (droppedDuringPoll.size() > 0) {
    cm.getLastCallFailCause(obtainNoPollCompleteMessage(EVENT_GET_LAST_CALL_FAIL_CAUSE));
  }
  if (needsPollDelay) {
    pollCallsAfterDelay();
  }
  if (newRinging != null || hasNonHangupStateChanged) {
    internalClearDisconnected();
  }
  updatePhoneState();
  if (unknownConnectionAppeared) {
    phone.notifyUnknownConnection();
  }
  if (hasNonHangupStateChanged || newRinging != null) {
    phone.notifyPreciseCallStateChanged();
  }
}"
23782,"private void updatePhoneState(){
  Phone.State oldState=state;
  if (ringingCall.isRinging()) {
    state=Phone.State.RINGING;
  }
 else   if (pendingMO != null || !(foregroundCall.isIdle() && backgroundCall.isIdle())) {
    state=Phone.State.OFFHOOK;
  }
 else {
    state=Phone.State.IDLE;
  }
  if (state == Phone.State.IDLE && oldState != state) {
    voiceCallEndedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
 else   if (oldState == Phone.State.IDLE && oldState != state) {
    voiceCallStartedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
  if (state != oldState) {
    phone.notifyPhoneStateChanged();
  }
}","private void updatePhoneState(){
  Phone.State oldState=state;
  if (ringingCall.isRinging()) {
    state=Phone.State.RINGING;
  }
 else   if (pendingMO != null || !(foregroundCall.isIdle() && backgroundCall.isIdle())) {
    state=Phone.State.OFFHOOK;
  }
 else {
    state=Phone.State.IDLE;
  }
  if (state == Phone.State.IDLE && oldState != state) {
    voiceCallEndedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
 else   if (oldState == Phone.State.IDLE && oldState != state) {
    voiceCallStartedRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
  }
  if (Phone.DEBUG_PHONE) {
    log(""String_Node_Str"" + oldState + state);
  }
  if (state != oldState) {
    phone.notifyPhoneStateChanged();
  }
}"
23783,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
23784,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}"
23785,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}"
23786,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}"
23787,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}"
23788,"/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Sends a reply to the client. If the reply is a OBEX_HTTP_CONTINUE, it will wait for a response from the client before ending.
 * @param type the response code to send back to the client
 * @return <code>true</code> if the final bit was not set on the reply;<code>false</code> if no reply was received because the operation ended, an abort was received, or the final bit was set in the reply
 * @throws IOException if an IO error occurs
 */
public synchronized boolean sendReply(int type) throws IOException {
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  int bytesReceived;
  long id=mListener.getConnectionId();
  if (id == -1) {
    replyHeader.mConnectionID=null;
  }
 else {
    replyHeader.mConnectionID=ObexHelper.convertToByteArray(id);
  }
  byte[] headerArray=ObexHelper.createHeader(replyHeader,true);
  int bodyLength=-1;
  int orginalBodyLength=-1;
  if (mPrivateOutput != null) {
    bodyLength=mPrivateOutput.size();
    orginalBodyLength=bodyLength;
  }
  if ((ObexHelper.BASE_PACKET_LENGTH + headerArray.length) > mMaxPacketLength) {
    int end=0;
    int start=0;
    while (end != headerArray.length) {
      end=ObexHelper.findHeaderEnd(headerArray,start,mMaxPacketLength - ObexHelper.BASE_PACKET_LENGTH);
      if (end == -1) {
        mClosed=true;
        if (mPrivateInput != null) {
          mPrivateInput.close();
        }
        if (mPrivateOutput != null) {
          mPrivateOutput.close();
        }
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        throw new IOException(""String_Node_Str"");
      }
      byte[] sendHeader=new byte[end - start];
      System.arraycopy(headerArray,start,sendHeader,0,sendHeader.length);
      mParent.sendResponse(type,sendHeader);
      start=end;
    }
    if (bodyLength > 0) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    out.write(headerArray);
  }
  if ((finalBitSet) || (headerArray.length < (mMaxPacketLength - 20))) {
    if (bodyLength > 0) {
      if (bodyLength > (mMaxPacketLength - headerArray.length - 6)) {
        bodyLength=mMaxPacketLength - headerArray.length - 6;
      }
      byte[] body=mPrivateOutput.readBytes(bodyLength);
      if ((finalBitSet) || (mPrivateOutput.isClosed())) {
        out.write(0x49);
      }
 else {
        out.write(0x48);
      }
      bodyLength+=3;
      out.write((byte)(bodyLength >> 8));
      out.write((byte)bodyLength);
      out.write(body);
    }
  }
  if ((finalBitSet) && (type == ResponseCodes.OBEX_HTTP_OK) && (orginalBodyLength <= 0)) {
    out.write(0x49);
    orginalBodyLength=3;
    out.write((byte)(orginalBodyLength >> 8));
    out.write((byte)orginalBodyLength);
  }
  mResponseSize=3;
  mParent.sendResponse(type,out.toByteArray());
  if (type == ResponseCodes.OBEX_HTTP_CONTINUE) {
    int headerID=mInput.read();
    int length=mInput.read();
    length=(length << 8) + mInput.read();
    if ((headerID != ObexHelper.OBEX_OPCODE_PUT) && (headerID != ObexHelper.OBEX_OPCODE_PUT_FINAL) && (headerID != ObexHelper.OBEX_OPCODE_GET)&& (headerID != ObexHelper.OBEX_OPCODE_GET_FINAL)) {
      if (length > 3) {
        byte[] temp=new byte[length];
        bytesReceived=mInput.read(temp);
        while (bytesReceived != length) {
          bytesReceived+=mInput.read(temp,bytesReceived,length - bytesReceived);
        }
      }
      if (headerID == ObexHelper.OBEX_OPCODE_ABORT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_OK,null);
        mClosed=true;
        isAborted=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
 else {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_BAD_REQUEST,null);
        mClosed=true;
        mExceptionString=""String_Node_Str"";
        throw new IOException(""String_Node_Str"");
      }
    }
 else {
      if ((headerID == ObexHelper.OBEX_OPCODE_PUT_FINAL) || (headerID == ObexHelper.OBEX_OPCODE_GET_FINAL)) {
        finalBitSet=true;
      }
      if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
        throw new IOException(""String_Node_Str"");
      }
      if (length > 3) {
        byte[] data=new byte[length - 3];
        bytesReceived=mInput.read(data);
        while (bytesReceived != data.length) {
          bytesReceived+=mInput.read(data,bytesReceived,data.length - bytesReceived);
        }
        byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
        if (body != null) {
          mHasBody=true;
        }
        if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
          mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
        }
 else {
          mListener.setConnectionId(1);
        }
        if (requestHeader.mAuthResp != null) {
          if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
            mExceptionString=""String_Node_Str"";
            mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
            mClosed=true;
            requestHeader.mAuthResp=null;
            return false;
          }
          requestHeader.mAuthResp=null;
        }
        if (requestHeader.mAuthChall != null) {
          mParent.handleAuthChall(requestHeader);
          replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
          System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
          requestHeader.mAuthResp=null;
          requestHeader.mAuthChall=null;
        }
        if (body != null) {
          mPrivateInput.writeBytes(body,1);
        }
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
23789,"/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(0);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}","/** 
 * Creates new ServerOperation
 * @param p the parent that created this object
 * @param in the input stream to read from
 * @param out the output stream to write to
 * @param request the initial request that was received from the client
 * @param maxSize the max packet size that the client will accept
 * @param listen the listener that is responding to the request
 * @throws IOException if an IO error occurs
 */
public ServerOperation(ServerSession p,InputStream in,int request,int maxSize,ServerRequestHandler listen) throws IOException {
  isAborted=false;
  mParent=p;
  mInput=in;
  mMaxPacketLength=maxSize;
  mClosed=false;
  requestHeader=new HeaderSet();
  replyHeader=new HeaderSet();
  mPrivateInput=new PrivateInputStream(this);
  mResponseSize=3;
  mListener=listen;
  mRequestFinished=false;
  mPrivateOutputOpen=false;
  mHasBody=false;
  int bytesReceived;
  if ((request == 0x02) || (request == 0x82)) {
    mGetOperation=false;
  }
 else {
    mGetOperation=true;
  }
  if ((request & 0x80) == 0) {
    finalBitSet=false;
  }
 else {
    finalBitSet=true;
    mRequestFinished=true;
  }
  int length=in.read();
  length=(length << 8) + in.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    mParent.sendResponse(ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE,null);
    throw new IOException(""String_Node_Str"");
  }
  if (length > 3) {
    byte[] data=new byte[length - 3];
    bytesReceived=in.read(data);
    while (bytesReceived != data.length) {
      bytesReceived+=in.read(data,bytesReceived,data.length - bytesReceived);
    }
    byte[] body=ObexHelper.updateHeaderSet(requestHeader,data);
    if (body != null) {
      mHasBody=true;
    }
    if (mListener.getConnectionId() != -1 && requestHeader.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(requestHeader.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (requestHeader.mAuthResp != null) {
      if (!mParent.handleAuthResp(requestHeader.mAuthResp)) {
        mExceptionString=""String_Node_Str"";
        mParent.sendResponse(ResponseCodes.OBEX_HTTP_UNAUTHORIZED,null);
        mClosed=true;
        requestHeader.mAuthResp=null;
        return;
      }
    }
    if (requestHeader.mAuthChall != null) {
      mParent.handleAuthChall(requestHeader);
      replyHeader.mAuthResp=new byte[requestHeader.mAuthResp.length];
      System.arraycopy(requestHeader.mAuthResp,0,replyHeader.mAuthResp,0,replyHeader.mAuthResp.length);
      requestHeader.mAuthResp=null;
      requestHeader.mAuthChall=null;
    }
    if (body != null) {
      mPrivateInput.writeBytes(body,1);
    }
 else {
      while ((!mGetOperation) && (!finalBitSet)) {
        sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
        if (mPrivateInput.available() > 0) {
          break;
        }
      }
    }
  }
  while ((!mGetOperation) && (!finalBitSet) && (mPrivateInput.available() == 0)) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
    if (mPrivateInput.available() > 0) {
      break;
    }
  }
  while (mGetOperation && !finalBitSet) {
    sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
  }
  if (finalBitSet && mGetOperation) {
    mRequestFinished=true;
  }
}"
23790,"/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}","/** 
 * Handles a connect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleConnectRequest() throws IOException {
  int packetLength;
  @SuppressWarnings(""String_Node_Str"") int version;
  @SuppressWarnings(""String_Node_Str"") int flags;
  int totalLength=7;
  byte[] head=null;
  int code=-1;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  int bytesReceived;
  packetLength=mInput.read();
  packetLength=(packetLength << 8) + mInput.read();
  version=mInput.read();
  flags=mInput.read();
  mMaxPacketLength=mInput.read();
  mMaxPacketLength=(mMaxPacketLength << 8) + mInput.read();
  if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    mMaxPacketLength=ObexHelper.MAX_PACKET_SIZE_INT;
  }
  if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=7;
  }
 else {
    if (packetLength > 7) {
      byte[] headers=new byte[packetLength - 7];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      try {
        code=mListener.onConnect(request,reply);
        code=validateResponseCode(code);
        if (reply.nonce != null) {
          mChallengeDigest=new byte[16];
          System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
        }
 else {
          mChallengeDigest=null;
        }
        long id=mListener.getConnectionId();
        if (id == -1) {
          reply.mConnectionID=null;
        }
 else {
          reply.mConnectionID=ObexHelper.convertToByteArray(id);
        }
        head=ObexHelper.createHeader(reply,false);
        totalLength+=head.length;
        if (totalLength > mMaxPacketLength) {
          totalLength=7;
          head=null;
          code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        totalLength=7;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] length=ObexHelper.convertToByteArray(totalLength);
  byte[] sendData=new byte[totalLength];
  sendData[0]=(byte)code;
  sendData[1]=length[2];
  sendData[2]=length[3];
  sendData[3]=(byte)0x10;
  sendData[4]=(byte)0x00;
  sendData[5]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT >> 8);
  sendData[6]=(byte)(ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
  if (head != null) {
    System.arraycopy(head,0,sendData,7,head.length);
  }
  mOutput.write(sendData);
  mOutput.flush();
}"
23791,"/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(-1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a SETPATH request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleSetPathRequest() throws IOException {
  int length;
  int flags;
  @SuppressWarnings(""String_Node_Str"") int constants;
  int totalLength=3;
  byte[] head=null;
  int code=-1;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  flags=mInput.read();
  constants=mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 5) {
      byte[] headers=new byte[length - 5];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
      if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
        mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
      }
 else {
        mListener.setConnectionId(1);
      }
      if (request.mAuthResp != null) {
        if (!handleAuthResp(request.mAuthResp)) {
          code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
          mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
        }
        request.mAuthResp=null;
      }
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        reply.mAuthResp=new byte[request.mAuthResp.length];
        System.arraycopy(request.mAuthResp,0,reply.mAuthResp,0,reply.mAuthResp.length);
        request.mAuthChall=null;
        request.mAuthResp=null;
      }
      boolean backup=false;
      boolean create=true;
      if (!((flags & 1) == 0)) {
        backup=true;
      }
      if ((flags & 2) == 0) {
        create=false;
      }
      try {
        code=mListener.onSetPath(request,reply,backup,create);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      code=validateResponseCode(code);
      if (reply.nonce != null) {
        mChallengeDigest=new byte[16];
        System.arraycopy(reply.nonce,0,mChallengeDigest,0,16);
      }
 else {
        mChallengeDigest=null;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData=new byte[totalLength];
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}"
23792,"/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}","/** 
 * Handles a disconnect request from a client. This method will read the rest of the request from the client. Assuming the request is valid, it will create a <code>HeaderSet</code> object to pass to the <code>ServerRequestHandler</code> object. After the handler processes the request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */
private void handleDisconnectRequest() throws IOException {
  int length;
  int code=ResponseCodes.OBEX_HTTP_OK;
  int totalLength=3;
  byte[] head=null;
  int bytesReceived;
  HeaderSet request=new HeaderSet();
  HeaderSet reply=new HeaderSet();
  length=mInput.read();
  length=(length << 8) + mInput.read();
  if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
    code=ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    totalLength=3;
  }
 else {
    if (length > 3) {
      byte[] headers=new byte[length - 3];
      bytesReceived=mInput.read(headers);
      while (bytesReceived != headers.length) {
        bytesReceived+=mInput.read(headers,bytesReceived,headers.length - bytesReceived);
      }
      ObexHelper.updateHeaderSet(request,headers);
    }
    if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
      mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
    }
 else {
      mListener.setConnectionId(1);
    }
    if (request.mAuthResp != null) {
      if (!handleAuthResp(request.mAuthResp)) {
        code=ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
        mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte)0x01,request.mAuthResp));
      }
      request.mAuthResp=null;
    }
    if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
      if (request.mAuthChall != null) {
        handleAuthChall(request);
        request.mAuthChall=null;
      }
      try {
        mListener.onDisconnect(request,reply);
      }
 catch (      Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR,null);
        return;
      }
      long id=mListener.getConnectionId();
      if (id == -1) {
        reply.mConnectionID=null;
      }
 else {
        reply.mConnectionID=ObexHelper.convertToByteArray(id);
      }
      head=ObexHelper.createHeader(reply,false);
      totalLength+=head.length;
      if (totalLength > mMaxPacketLength) {
        totalLength=3;
        head=null;
        code=ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
      }
    }
  }
  byte[] replyData;
  if (head != null) {
    replyData=new byte[3 + head.length];
  }
 else {
    replyData=new byte[3];
  }
  replyData[0]=(byte)code;
  replyData[1]=(byte)(totalLength >> 8);
  replyData[2]=(byte)totalLength;
  if (head != null) {
    System.arraycopy(head,0,replyData,3,head.length);
  }
  mOutput.write(replyData);
  mOutput.flush();
}"
23793,"@Override public boolean onTouchEvent(MotionEvent event){
  if (!mIsUserSeekable || !isEnabled()) {
    return false;
  }
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    setPressed(true);
  onStartTrackingTouch();
trackTouchEvent(event);
break;
case MotionEvent.ACTION_MOVE:
trackTouchEvent(event);
attemptClaimDrag();
break;
case MotionEvent.ACTION_UP:
trackTouchEvent(event);
onStopTrackingTouch();
setPressed(false);
break;
case MotionEvent.ACTION_CANCEL:
onStopTrackingTouch();
setPressed(false);
break;
}
return true;
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (!mIsUserSeekable || !isEnabled()) {
    return false;
  }
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    setPressed(true);
  onStartTrackingTouch();
trackTouchEvent(event);
break;
case MotionEvent.ACTION_MOVE:
trackTouchEvent(event);
attemptClaimDrag();
break;
case MotionEvent.ACTION_UP:
trackTouchEvent(event);
onStopTrackingTouch();
setPressed(false);
invalidate();
break;
case MotionEvent.ACTION_CANCEL:
onStopTrackingTouch();
setPressed(false);
invalidate();
break;
}
return true;
}"
23794,"public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}","public TextView(Context context,AttributeSet attrs,int defStyle){
  super(context,attrs,defStyle);
  mText=""String_Node_Str"";
  mTextPaint=new TextPaint(Paint.ANTI_ALIAS_FLAG);
  mTextPaint.density=getResources().getDisplayMetrics().density;
  mHighlightPaint=new Paint(Paint.ANTI_ALIAS_FLAG);
  mMovement=getDefaultMovementMethod();
  mTransformation=null;
  TypedArray a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.TextView,defStyle,0);
  int textColorHighlight=0;
  ColorStateList textColor=null;
  ColorStateList textColorHint=null;
  ColorStateList textColorLink=null;
  int textSize=15;
  int typefaceIndex=-1;
  int styleIndex=-1;
  TypedArray appearance=null;
  int ap=a.getResourceId(com.android.internal.R.styleable.TextView_textAppearance,-1);
  if (ap != -1) {
    appearance=context.obtainStyledAttributes(ap,com.android.internal.R.styleable.TextAppearance);
  }
  if (appearance != null) {
    int n=appearance.getIndexCount();
    for (int i=0; i < n; i++) {
      int attr=appearance.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
        textColorHighlight=appearance.getColor(attr,textColorHighlight);
      break;
case com.android.internal.R.styleable.TextAppearance_textColor:
    textColor=appearance.getColorStateList(attr);
  break;
case com.android.internal.R.styleable.TextAppearance_textColorHint:
textColorHint=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textColorLink:
textColorLink=appearance.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextAppearance_textSize:
textSize=appearance.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextAppearance_typeface:
typefaceIndex=appearance.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextAppearance_textStyle:
styleIndex=appearance.getInt(attr,-1);
break;
}
}
appearance.recycle();
}
boolean editable=getDefaultEditable();
CharSequence inputMethod=null;
int numeric=0;
CharSequence digits=null;
boolean phone=false;
boolean autotext=false;
int autocap=-1;
int buffertype=0;
boolean selectallonfocus=false;
Drawable drawableLeft=null, drawableTop=null, drawableRight=null, drawableBottom=null;
int drawablePadding=0;
int ellipsize=-1;
boolean singleLine=false;
int maxlength=-1;
CharSequence text=""String_Node_Str"";
CharSequence hint=null;
int shadowcolor=0;
float dx=0, dy=0, r=0;
boolean password=false;
int inputType=EditorInfo.TYPE_NULL;
int n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.TextView_editable:
editable=a.getBoolean(attr,editable);
break;
case com.android.internal.R.styleable.TextView_inputMethod:
inputMethod=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_numeric:
numeric=a.getInt(attr,numeric);
break;
case com.android.internal.R.styleable.TextView_digits:
digits=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_phoneNumber:
phone=a.getBoolean(attr,phone);
break;
case com.android.internal.R.styleable.TextView_autoText:
autotext=a.getBoolean(attr,autotext);
break;
case com.android.internal.R.styleable.TextView_capitalize:
autocap=a.getInt(attr,autocap);
break;
case com.android.internal.R.styleable.TextView_bufferType:
buffertype=a.getInt(attr,buffertype);
break;
case com.android.internal.R.styleable.TextView_selectAllOnFocus:
selectallonfocus=a.getBoolean(attr,selectallonfocus);
break;
case com.android.internal.R.styleable.TextView_autoLink:
mAutoLinkMask=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_linksClickable:
mLinksClickable=a.getBoolean(attr,true);
break;
case com.android.internal.R.styleable.TextView_drawableLeft:
drawableLeft=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableTop:
drawableTop=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableRight:
drawableRight=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawableBottom:
drawableBottom=a.getDrawable(attr);
break;
case com.android.internal.R.styleable.TextView_drawablePadding:
drawablePadding=a.getDimensionPixelSize(attr,drawablePadding);
break;
case com.android.internal.R.styleable.TextView_maxLines:
setMaxLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxHeight:
setMaxHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_lines:
setLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_height:
setHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minLines:
setMinLines(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minHeight:
setMinHeight(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxEms:
setMaxEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_maxWidth:
setMaxWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_ems:
setEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_width:
setWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minEms:
setMinEms(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_minWidth:
setMinWidth(a.getDimensionPixelSize(attr,-1));
break;
case com.android.internal.R.styleable.TextView_gravity:
setGravity(a.getInt(attr,-1));
break;
case com.android.internal.R.styleable.TextView_hint:
hint=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_text:
text=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_scrollHorizontally:
if (a.getBoolean(attr,false)) {
setHorizontallyScrolling(true);
}
break;
case com.android.internal.R.styleable.TextView_singleLine:
singleLine=a.getBoolean(attr,singleLine);
break;
case com.android.internal.R.styleable.TextView_ellipsize:
ellipsize=a.getInt(attr,ellipsize);
break;
case com.android.internal.R.styleable.TextView_marqueeRepeatLimit:
setMarqueeRepeatLimit(a.getInt(attr,mMarqueeRepeatLimit));
break;
case com.android.internal.R.styleable.TextView_includeFontPadding:
if (!a.getBoolean(attr,true)) {
setIncludeFontPadding(false);
}
break;
case com.android.internal.R.styleable.TextView_cursorVisible:
if (!a.getBoolean(attr,true)) {
setCursorVisible(false);
}
break;
case com.android.internal.R.styleable.TextView_maxLength:
maxlength=a.getInt(attr,-1);
break;
case com.android.internal.R.styleable.TextView_textScaleX:
setTextScaleX(a.getFloat(attr,1.0f));
break;
case com.android.internal.R.styleable.TextView_freezesText:
mFreezesText=a.getBoolean(attr,false);
break;
case com.android.internal.R.styleable.TextView_shadowColor:
shadowcolor=a.getInt(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDx:
dx=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowDy:
dy=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_shadowRadius:
r=a.getFloat(attr,0);
break;
case com.android.internal.R.styleable.TextView_enabled:
setEnabled(a.getBoolean(attr,isEnabled()));
break;
case com.android.internal.R.styleable.TextView_textColorHighlight:
textColorHighlight=a.getColor(attr,textColorHighlight);
break;
case com.android.internal.R.styleable.TextView_textColor:
textColor=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorHint:
textColorHint=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textColorLink:
textColorLink=a.getColorStateList(attr);
break;
case com.android.internal.R.styleable.TextView_textSize:
textSize=a.getDimensionPixelSize(attr,textSize);
break;
case com.android.internal.R.styleable.TextView_typeface:
typefaceIndex=a.getInt(attr,typefaceIndex);
break;
case com.android.internal.R.styleable.TextView_textStyle:
styleIndex=a.getInt(attr,styleIndex);
break;
case com.android.internal.R.styleable.TextView_password:
password=a.getBoolean(attr,password);
break;
case com.android.internal.R.styleable.TextView_lineSpacingExtra:
mSpacingAdd=a.getDimensionPixelSize(attr,(int)mSpacingAdd);
break;
case com.android.internal.R.styleable.TextView_lineSpacingMultiplier:
mSpacingMult=a.getFloat(attr,mSpacingMult);
break;
case com.android.internal.R.styleable.TextView_inputType:
inputType=a.getInt(attr,mInputType);
break;
case com.android.internal.R.styleable.TextView_imeOptions:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeOptions=a.getInt(attr,mInputContentType.imeOptions);
break;
case com.android.internal.R.styleable.TextView_imeActionLabel:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionLabel=a.getText(attr);
break;
case com.android.internal.R.styleable.TextView_imeActionId:
if (mInputContentType == null) {
mInputContentType=new InputContentType();
}
mInputContentType.imeActionId=a.getInt(attr,mInputContentType.imeActionId);
break;
case com.android.internal.R.styleable.TextView_privateImeOptions:
setPrivateImeOptions(a.getString(attr));
break;
case com.android.internal.R.styleable.TextView_editorExtras:
try {
setInputExtras(a.getResourceId(attr,0));
}
 catch (XmlPullParserException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
catch (IOException e) {
Log.w(""String_Node_Str"",""String_Node_Str"",e);
}
break;
}
}
a.recycle();
BufferType bufferType=BufferType.EDITABLE;
if ((inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
password=true;
}
if (inputMethod != null) {
Class c;
try {
c=Class.forName(inputMethod.toString());
}
 catch (ClassNotFoundException ex) {
throw new RuntimeException(ex);
}
try {
mInput=(KeyListener)c.newInstance();
}
 catch (InstantiationException ex) {
throw new RuntimeException(ex);
}
catch (IllegalAccessException ex) {
throw new RuntimeException(ex);
}
try {
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : mInput.getInputType();
}
 catch (IncompatibleClassChangeError e) {
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
}
 else if (digits != null) {
mInput=DigitsKeyListener.getInstance(digits.toString());
mInputType=inputType != EditorInfo.TYPE_NULL ? inputType : EditorInfo.TYPE_CLASS_TEXT;
}
 else if (inputType != EditorInfo.TYPE_NULL) {
setInputType(inputType,true);
singleLine=(inputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE)) != (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE);
}
 else if (phone) {
mInput=DialerKeyListener.getInstance();
mInputType=inputType=EditorInfo.TYPE_CLASS_PHONE;
}
 else if (numeric != 0) {
mInput=DigitsKeyListener.getInstance((numeric & SIGNED) != 0,(numeric & DECIMAL) != 0);
inputType=EditorInfo.TYPE_CLASS_NUMBER;
if ((numeric & SIGNED) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_SIGNED;
}
if ((numeric & DECIMAL) != 0) {
inputType|=EditorInfo.TYPE_NUMBER_FLAG_DECIMAL;
}
mInputType=inputType;
}
 else if (autotext || autocap != -1) {
TextKeyListener.Capitalize cap;
inputType=EditorInfo.TYPE_CLASS_TEXT;
if (!singleLine) {
inputType|=EditorInfo.TYPE_TEXT_FLAG_MULTI_LINE;
}
switch (autocap) {
case 1:
cap=TextKeyListener.Capitalize.SENTENCES;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES;
break;
case 2:
cap=TextKeyListener.Capitalize.WORDS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS;
break;
case 3:
cap=TextKeyListener.Capitalize.CHARACTERS;
inputType|=EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS;
break;
default :
cap=TextKeyListener.Capitalize.NONE;
break;
}
mInput=TextKeyListener.getInstance(autotext,cap);
mInputType=inputType;
}
 else if (editable) {
mInput=TextKeyListener.getInstance();
mInputType=EditorInfo.TYPE_CLASS_TEXT;
}
 else {
mInput=null;
switch (buffertype) {
case 0:
bufferType=BufferType.NORMAL;
break;
case 1:
bufferType=BufferType.SPANNABLE;
break;
case 2:
bufferType=BufferType.EDITABLE;
break;
}
}
if (password && (mInputType & EditorInfo.TYPE_MASK_CLASS) == EditorInfo.TYPE_CLASS_TEXT) {
mInputType=(mInputType & ~(EditorInfo.TYPE_MASK_VARIATION)) | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD;
}
if (selectallonfocus) {
mSelectAllOnFocus=true;
if (bufferType == BufferType.NORMAL) bufferType=BufferType.SPANNABLE;
}
setCompoundDrawablesWithIntrinsicBounds(drawableLeft,drawableTop,drawableRight,drawableBottom);
setCompoundDrawablePadding(drawablePadding);
if (singleLine) {
setSingleLine();
if (mInput == null && ellipsize < 0) {
ellipsize=3;
}
}
switch (ellipsize) {
case 1:
setEllipsize(TextUtils.TruncateAt.START);
break;
case 2:
setEllipsize(TextUtils.TruncateAt.MIDDLE);
break;
case 3:
setEllipsize(TextUtils.TruncateAt.END);
break;
case 4:
setHorizontalFadingEdgeEnabled(true);
setEllipsize(TextUtils.TruncateAt.MARQUEE);
break;
}
setTextColor(textColor != null ? textColor : ColorStateList.valueOf(0xFF000000));
setHintTextColor(textColorHint);
setLinkTextColor(textColorLink);
if (textColorHighlight != 0) {
setHighlightColor(textColorHighlight);
}
setRawTextSize(textSize);
if (password) {
setTransformationMethod(PasswordTransformationMethod.getInstance());
typefaceIndex=MONOSPACE;
}
 else if ((mInputType & (EditorInfo.TYPE_MASK_CLASS | EditorInfo.TYPE_MASK_VARIATION)) == (EditorInfo.TYPE_CLASS_TEXT | EditorInfo.TYPE_TEXT_VARIATION_PASSWORD)) {
typefaceIndex=MONOSPACE;
}
setTypefaceByIndex(typefaceIndex,styleIndex);
if (shadowcolor != 0) {
setShadowLayer(r,dx,dy,shadowcolor);
}
if (maxlength >= 0) {
setFilters(new InputFilter[]{new InputFilter.LengthFilter(maxlength)});
}
 else {
setFilters(NO_FILTERS);
}
setText(text,bufferType);
if (hint != null) setHint(hint);
a=context.obtainStyledAttributes(attrs,com.android.internal.R.styleable.View,defStyle,0);
boolean focusable=mMovement != null || mInput != null;
boolean clickable=focusable;
boolean longClickable=focusable;
n=a.getIndexCount();
for (int i=0; i < n; i++) {
int attr=a.getIndex(i);
switch (attr) {
case com.android.internal.R.styleable.View_focusable:
focusable=a.getBoolean(attr,focusable);
break;
case com.android.internal.R.styleable.View_clickable:
clickable=a.getBoolean(attr,clickable);
break;
case com.android.internal.R.styleable.View_longClickable:
longClickable=a.getBoolean(attr,longClickable);
break;
}
}
a.recycle();
setFocusable(focusable);
setClickable(clickable);
setLongClickable(longClickable);
}"
23795,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion == 38) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=39;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}"
23796,"/** 
 * @see AudioManager#setBluetoothScoOn() 
 */
public void setBluetoothScoOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_BT_SCO);
    mForcedUseForComm=AudioSystem.FORCE_BT_SCO;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}","/** 
 * @see AudioManager#setBluetoothScoOn() 
 */
public void setBluetoothScoOn(boolean on){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_BT_SCO);
    mForcedUseForComm=AudioSystem.FORCE_BT_SCO;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    AudioSystem.setForceUse(AudioSystem.FOR_RECORD,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}"
23797,"/** 
 * @see AudioManager#setSpeakerphoneOn() 
 */
public void setSpeakerphoneOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
    mForcedUseForComm=AudioSystem.FORCE_SPEAKER;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}","/** 
 * @see AudioManager#setSpeakerphoneOn() 
 */
public void setSpeakerphoneOn(boolean on){
  if (!checkAudioSettingsPermission(""String_Node_Str"")) {
    return;
  }
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
    mForcedUseForComm=AudioSystem.FORCE_SPEAKER;
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
    mForcedUseForComm=AudioSystem.FORCE_NONE;
  }
}"
23798,"void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.clear();
    mCreated=false;
  }
}","void detach(){
  mDestroyed=true;
  if (mVisible) {
    mVisible=false;
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + this);
    onVisibilityChanged(false);
  }
  if (mDestroyReportNeeded) {
    mDestroyReportNeeded=false;
    SurfaceHolder.Callback callbacks[];
synchronized (mSurfaceHolder.mCallbacks) {
      callbacks=new SurfaceHolder.Callback[mSurfaceHolder.mCallbacks.size()];
      mSurfaceHolder.mCallbacks.toArray(callbacks);
    }
    for (    SurfaceHolder.Callback c : callbacks) {
      c.surfaceDestroyed(mSurfaceHolder);
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
    onSurfaceDestroyed(mSurfaceHolder);
  }
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + this);
  onDestroy();
  if (mCreated) {
    try {
      mSession.remove(mWindow);
    }
 catch (    RemoteException e) {
    }
    mSurfaceHolder.mSurface.release();
    mCreated=false;
  }
}"
23799,"void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.FILL_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.FILL_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}","void updateSurface(boolean forceRelayout,boolean forceReport){
  if (mDestroyed) {
    Log.w(TAG,""String_Node_Str"");
  }
  int myWidth=mSurfaceHolder.getRequestedWidth();
  if (myWidth <= 0)   myWidth=ViewGroup.LayoutParams.FILL_PARENT;
  int myHeight=mSurfaceHolder.getRequestedHeight();
  if (myHeight <= 0)   myHeight=ViewGroup.LayoutParams.FILL_PARENT;
  final boolean creating=!mCreated;
  final boolean formatChanged=mFormat != mSurfaceHolder.getRequestedFormat();
  boolean sizeChanged=mWidth != myWidth || mHeight != myHeight;
  final boolean typeChanged=mType != mSurfaceHolder.getRequestedType();
  final boolean flagsChanged=mCurWindowFlags != mWindowFlags;
  if (forceRelayout || creating || formatChanged|| sizeChanged|| typeChanged|| flagsChanged) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + creating + ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged);
    try {
      mWidth=myWidth;
      mHeight=myHeight;
      mFormat=mSurfaceHolder.getRequestedFormat();
      mType=mSurfaceHolder.getRequestedType();
      mLayout.x=0;
      mLayout.y=0;
      mLayout.width=myWidth;
      mLayout.height=myHeight;
      mLayout.format=mFormat;
      mCurWindowFlags=mWindowFlags;
      mLayout.flags=mWindowFlags | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
      mLayout.memoryType=mType;
      mLayout.token=mWindowToken;
      if (!mCreated) {
        mLayout.type=mIWallpaperEngine.mWindowType;
        mLayout.gravity=Gravity.LEFT | Gravity.TOP;
        mLayout.setTitle(WallpaperService.this.getClass().getName());
        mLayout.windowAnimations=com.android.internal.R.style.Animation_Wallpaper;
        mSession.add(mWindow,mLayout,View.VISIBLE,mContentInsets);
      }
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
      final int relayoutResult=mSession.relayout(mWindow,mLayout,mWidth,mHeight,View.VISIBLE,false,mWinFrame,mContentInsets,mVisibleInsets,mSurfaceHolder.mSurface);
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mSurfaceHolder.mSurface + ""String_Node_Str""+ mWinFrame);
      int w=mWinFrame.width();
      if (mCurWidth != w) {
        sizeChanged=true;
        mCurWidth=w;
      }
      int h=mWinFrame.height();
      if (mCurHeight != h) {
        sizeChanged=true;
        mCurHeight=h;
      }
      mSurfaceHolder.mSurfaceLock.unlock();
      try {
        mDestroyReportNeeded=true;
        SurfaceHolder.Callback callbacks[]=null;
synchronized (mSurfaceHolder.mCallbacks) {
          final int N=mSurfaceHolder.mCallbacks.size();
          if (N > 0) {
            callbacks=new SurfaceHolder.Callback[N];
            mSurfaceHolder.mCallbacks.toArray(callbacks);
          }
        }
        if (!mCreated) {
          mIsCreating=true;
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ this);
          onSurfaceCreated(mSurfaceHolder);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
        }
        if (forceReport || creating || formatChanged|| sizeChanged) {
          if (DEBUG) {
            RuntimeException e=new RuntimeException();
            e.fillInStackTrace();
            Log.w(TAG,""String_Node_Str"" + forceReport + ""String_Node_Str""+ creating+ ""String_Node_Str""+ formatChanged+ ""String_Node_Str""+ sizeChanged,e);
          }
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mSurfaceHolder + ""String_Node_Str""+ mFormat+ ""String_Node_Str""+ mCurWidth+ ""String_Node_Str""+ mCurHeight+ ""String_Node_Str""+ this);
          onSurfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,mFormat,mCurWidth,mCurHeight);
            }
          }
        }
      }
  finally {
        mIsCreating=false;
        mCreated=true;
        if (creating || (relayoutResult & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
          mSession.finishDrawing(mWindow);
        }
      }
    }
 catch (    RemoteException ex) {
    }
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + mLayout.x + ""String_Node_Str""+ mLayout.y+ ""String_Node_Str""+ mLayout.width+ ""String_Node_Str""+ mLayout.height);
  }
}"
23800,private native void release();,"/** 
 * Release the local reference to the server-side surface. @hide 
 */
public native void release();"
23801,"public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.clear();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}","public void die(boolean immediate){
  checkThread();
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
synchronized (this) {
    if (mAdded && !mFirst) {
      int viewVisibility=mView.getVisibility();
      boolean viewVisibilityChanged=mViewVisibility != viewVisibility;
      if (mWindowAttributesChanged || viewVisibilityChanged) {
        try {
          if ((relayoutWindow(mWindowAttributes,viewVisibility,false) & WindowManagerImpl.RELAYOUT_FIRST_TIME) != 0) {
            sWindowSession.finishDrawing(mWindow);
          }
        }
 catch (        RemoteException e) {
        }
      }
      mSurface.release();
    }
    if (mAdded) {
      mAdded=false;
      if (immediate) {
        dispatchDetachedFromWindow();
      }
 else       if (mView != null) {
        sendEmptyMessage(DIE);
      }
    }
  }
}"
23802,"void dispatchDetachedFromWindow(){
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
  if (mView != null) {
    mView.dispatchDetachedFromWindow();
  }
  mView=null;
  mAttachInfo.mRootView=null;
  mAttachInfo.mSurface=null;
  if (mUseGL) {
    destroyGL();
  }
  mSurface.clear();
  try {
    sWindowSession.remove(mWindow);
  }
 catch (  RemoteException e) {
  }
}","void dispatchDetachedFromWindow(){
  if (Config.LOGV)   Log.v(""String_Node_Str"",""String_Node_Str"" + this + ""String_Node_Str""+ mSurface);
  if (mView != null) {
    mView.dispatchDetachedFromWindow();
  }
  mView=null;
  mAttachInfo.mRootView=null;
  mAttachInfo.mSurface=null;
  if (mUseGL) {
    destroyGL();
  }
  mSurface.release();
  try {
    sWindowSession.remove(mWindow);
  }
 catch (  RemoteException e) {
  }
}"
23803,"public void onTerminate(){
  if (mWriter != null) {
    try {
      mWriter.flush();
      if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
        ((FileOutputStream)mOutputStream).getFD().sync();
      }
    }
 catch (    IOException e) {
      Log.d(LOG_TAG,""String_Node_Str"" + e.getMessage());
    }
 finally {
      try {
        mWriter.close();
      }
 catch (      IOException e) {
      }
    }
  }
}","public void onTerminate(){
  mOnTerminateIsCalled=true;
  if (mWriter != null) {
    try {
      mWriter.flush();
      if (mOutputStream != null && mOutputStream instanceof FileOutputStream) {
        ((FileOutputStream)mOutputStream).getFD().sync();
      }
    }
 catch (    IOException e) {
      Log.d(LOG_TAG,""String_Node_Str"" + e.getMessage());
    }
 finally {
      try {
        mWriter.close();
      }
 catch (      IOException e) {
      }
    }
  }
}"
23804,"private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  for (  ContentValues contentValues : contentValuesList) {
    final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix=contentValues.getAsString(StructuredName.PREFIX);
    final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
      final String encodedFamily=escapeCharacters(familyName);
      final String encodedGiven=escapeCharacters(givenName);
      final String encodedMiddle=escapeCharacters(middleName);
      final String encodedPrefix=escapeCharacters(prefix);
      final String encodedSuffix=escapeCharacters(suffix);
      builder.append(VCARD_PROPERTY_NAME);
      if (!(VCardUtils.containsOnlyAscii(familyName) && VCardUtils.containsOnlyAscii(givenName) && VCardUtils.containsOnlyAscii(middleName)&& VCardUtils.containsOnlyAscii(prefix)&& VCardUtils.containsOnlyAscii(suffix))) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
      builder.append(VCARD_COL_SEPARATOR);
      final String encodedFullname=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),encodedFamily,encodedMiddle,encodedGiven,encodedPrefix,encodedSuffix);
      builder.append(VCARD_PROPERTY_FULL_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      if (!VCardUtils.containsOnlyAscii(encodedFullname)) {
        builder.append(mVCardAttributeCharset);
        builder.append(VCARD_DATA_SEPARATOR);
      }
      builder.append(encodedFullname);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (!TextUtils.isEmpty(displayName)) {
      builder.append(VCARD_PROPERTY_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(mVCardAttributeCharset);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(displayName));
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (mIsDoCoMo) {
      appendVCardLine(builder,VCARD_PROPERTY_NAME,""String_Node_Str"");
    }
    String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
      if (mIsJapaneseMobilePhone) {
        phoneticFamilyName=VCardUtils.toHalfWidthString(phoneticFamilyName);
        phoneticMiddleName=VCardUtils.toHalfWidthString(phoneticMiddleName);
        phoneticGivenName=VCardUtils.toHalfWidthString(phoneticGivenName);
      }
      if (mIsV30) {
        final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
        builder.append(VCARD_PROPERTY_SORT_STRING);
        if (!VCardUtils.containsOnlyAscii(sortString)) {
          builder.append(VCARD_ATTR_SEPARATOR);
          builder.append(mVCardAttributeCharset);
        }
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(sortString);
        builder.append(VCARD_COL_SEPARATOR);
      }
 else {
        builder.append(VCARD_PROPERTY_SOUND);
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(Constants.ATTR_TYPE_X_IRMC_N);
        builder.append(VCARD_ATTR_SEPARATOR);
        if (!(VCardUtils.containsOnlyAscii(phoneticFamilyName) && VCardUtils.containsOnlyAscii(phoneticMiddleName) && VCardUtils.containsOnlyAscii(phoneticGivenName))) {
          builder.append(mVCardAttributeCharset);
          builder.append(VCARD_DATA_SEPARATOR);
        }
        builder.append(escapeCharacters(phoneticFamilyName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticMiddleName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticGivenName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_COL_SEPARATOR);
        if (mUsesAndroidProperty) {
          final String phoneticName=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
          builder.append(VCARD_PROPERTY_X_PHONETIC_NAME);
          if (!VCardUtils.containsOnlyAscii(phoneticName)) {
            builder.append(VCARD_ATTR_SEPARATOR);
            builder.append(mVCardAttributeCharset);
          }
          builder.append(VCARD_DATA_SEPARATOR);
          builder.append(phoneticName);
          builder.append(VCARD_COL_SEPARATOR);
        }
      }
    }
 else     if (mIsDoCoMo) {
      builder.append(VCARD_PROPERTY_SOUND);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(Constants.ATTR_TYPE_X_IRMC_N);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
    if (mUsesDefactProperty) {
      if (!TextUtils.isEmpty(phoneticGivenName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_FIRST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticGivenName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticMiddleName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_MIDDLE_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticMiddleName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticFamilyName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_LAST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticFamilyName);
        builder.append(VCARD_COL_SEPARATOR);
      }
    }
  }
}","private void appendStructuredNamesInternal(final StringBuilder builder,final List<ContentValues> contentValuesList){
  for (  ContentValues contentValues : contentValuesList) {
    final String familyName=contentValues.getAsString(StructuredName.FAMILY_NAME);
    final String middleName=contentValues.getAsString(StructuredName.MIDDLE_NAME);
    final String givenName=contentValues.getAsString(StructuredName.GIVEN_NAME);
    final String prefix=contentValues.getAsString(StructuredName.PREFIX);
    final String suffix=contentValues.getAsString(StructuredName.SUFFIX);
    final String displayName=contentValues.getAsString(StructuredName.DISPLAY_NAME);
    if (!TextUtils.isEmpty(familyName) || !TextUtils.isEmpty(givenName)) {
      final String encodedFamily=escapeCharacters(familyName);
      final String encodedGiven=escapeCharacters(givenName);
      final String encodedMiddle=escapeCharacters(middleName);
      final String encodedPrefix=escapeCharacters(prefix);
      final String encodedSuffix=escapeCharacters(suffix);
      builder.append(VCARD_PROPERTY_NAME);
      if (!(VCardUtils.containsOnlyAscii(familyName) && VCardUtils.containsOnlyAscii(givenName) && VCardUtils.containsOnlyAscii(middleName)&& VCardUtils.containsOnlyAscii(prefix)&& VCardUtils.containsOnlyAscii(suffix))) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFamily);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedGiven);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedMiddle);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedPrefix);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(encodedSuffix);
      builder.append(VCARD_COL_SEPARATOR);
      final String encodedFullname=VCardUtils.constructNameFromElements(VCardConfig.getNameOrderType(mVCardType),encodedFamily,encodedMiddle,encodedGiven,encodedPrefix,encodedSuffix);
      builder.append(VCARD_PROPERTY_FULL_NAME);
      if (!VCardUtils.containsOnlyAscii(encodedFullname)) {
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(mVCardAttributeCharset);
      }
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(encodedFullname);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (!TextUtils.isEmpty(displayName)) {
      builder.append(VCARD_PROPERTY_NAME);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(mVCardAttributeCharset);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(escapeCharacters(displayName));
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
 else     if (mIsDoCoMo) {
      appendVCardLine(builder,VCARD_PROPERTY_NAME,""String_Node_Str"");
    }
    String phoneticFamilyName=contentValues.getAsString(StructuredName.PHONETIC_FAMILY_NAME);
    String phoneticMiddleName=contentValues.getAsString(StructuredName.PHONETIC_MIDDLE_NAME);
    String phoneticGivenName=contentValues.getAsString(StructuredName.PHONETIC_GIVEN_NAME);
    if (!(TextUtils.isEmpty(phoneticFamilyName) && TextUtils.isEmpty(phoneticMiddleName) && TextUtils.isEmpty(phoneticGivenName))) {
      if (mIsJapaneseMobilePhone) {
        phoneticFamilyName=VCardUtils.toHalfWidthString(phoneticFamilyName);
        phoneticMiddleName=VCardUtils.toHalfWidthString(phoneticMiddleName);
        phoneticGivenName=VCardUtils.toHalfWidthString(phoneticGivenName);
      }
      if (mIsV30) {
        final String sortString=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
        builder.append(VCARD_PROPERTY_SORT_STRING);
        if (!VCardUtils.containsOnlyAscii(sortString)) {
          builder.append(VCARD_ATTR_SEPARATOR);
          builder.append(mVCardAttributeCharset);
        }
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(sortString);
        builder.append(VCARD_COL_SEPARATOR);
      }
 else {
        builder.append(VCARD_PROPERTY_SOUND);
        builder.append(VCARD_ATTR_SEPARATOR);
        builder.append(Constants.ATTR_TYPE_X_IRMC_N);
        builder.append(VCARD_ATTR_SEPARATOR);
        if (!(VCardUtils.containsOnlyAscii(phoneticFamilyName) && VCardUtils.containsOnlyAscii(phoneticMiddleName) && VCardUtils.containsOnlyAscii(phoneticGivenName))) {
          builder.append(mVCardAttributeCharset);
          builder.append(VCARD_DATA_SEPARATOR);
        }
        builder.append(escapeCharacters(phoneticFamilyName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticMiddleName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(escapeCharacters(phoneticGivenName));
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_ITEM_SEPARATOR);
        builder.append(VCARD_COL_SEPARATOR);
        if (mUsesAndroidProperty) {
          final String phoneticName=VCardUtils.constructNameFromElements(mVCardType,phoneticFamilyName,phoneticMiddleName,phoneticGivenName);
          builder.append(VCARD_PROPERTY_X_PHONETIC_NAME);
          if (!VCardUtils.containsOnlyAscii(phoneticName)) {
            builder.append(VCARD_ATTR_SEPARATOR);
            builder.append(mVCardAttributeCharset);
          }
          builder.append(VCARD_DATA_SEPARATOR);
          builder.append(phoneticName);
          builder.append(VCARD_COL_SEPARATOR);
        }
      }
    }
 else     if (mIsDoCoMo) {
      builder.append(VCARD_PROPERTY_SOUND);
      builder.append(VCARD_ATTR_SEPARATOR);
      builder.append(Constants.ATTR_TYPE_X_IRMC_N);
      builder.append(VCARD_DATA_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_ITEM_SEPARATOR);
      builder.append(VCARD_COL_SEPARATOR);
    }
    if (mUsesDefactProperty) {
      if (!TextUtils.isEmpty(phoneticGivenName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_FIRST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticGivenName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticMiddleName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_MIDDLE_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticMiddleName);
        builder.append(VCARD_COL_SEPARATOR);
      }
      if (!TextUtils.isEmpty(phoneticFamilyName)) {
        builder.append(VCARD_PROPERTY_X_PHONETIC_LAST_NAME);
        builder.append(VCARD_DATA_SEPARATOR);
        builder.append(phoneticFamilyName);
        builder.append(VCARD_COL_SEPARATOR);
      }
    }
  }
}"
23805,"private void appendVCardEmailLine(StringBuilder builder,int type,String label,String data){
  builder.append(VCARD_PROPERTY_EMAIL);
  builder.append(VCARD_ATTR_SEPARATOR);
switch (type) {
case Email.TYPE_CUSTOM:
    if (label.equals(android.provider.Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME)) {
      builder.append(Constants.ATTR_TYPE_CELL);
    }
 else     if (mUsesAndroidProperty && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
      builder.append(""String_Node_Str"");
      builder.append(label);
    }
 else {
      builder.append(Constants.ATTR_TYPE_INTERNET);
    }
  break;
case Email.TYPE_HOME:
builder.append(Constants.ATTR_TYPE_HOME);
break;
case Email.TYPE_WORK:
builder.append(Constants.ATTR_TYPE_WORK);
break;
case Email.TYPE_OTHER:
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + type);
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
}
builder.append(VCARD_DATA_SEPARATOR);
builder.append(data);
builder.append(VCARD_COL_SEPARATOR);
}","private void appendVCardEmailLine(StringBuilder builder,int type,String label,String data){
  builder.append(VCARD_PROPERTY_EMAIL);
  builder.append(VCARD_ATTR_SEPARATOR);
switch (type) {
case Email.TYPE_CUSTOM:
    if (label.equals(android.provider.Contacts.ContactMethodsColumns.MOBILE_EMAIL_TYPE_NAME)) {
      builder.append(Constants.ATTR_TYPE_CELL);
    }
 else     if (mUsesAndroidProperty && VCardUtils.containsOnlyAlphaDigitHyphen(label)) {
      builder.append(""String_Node_Str"");
      builder.append(label);
    }
 else {
      builder.append(Constants.ATTR_TYPE_INTERNET);
    }
  break;
case Email.TYPE_HOME:
builder.append(Constants.ATTR_TYPE_HOME);
break;
case Email.TYPE_WORK:
builder.append(Constants.ATTR_TYPE_WORK);
break;
case Email.TYPE_OTHER:
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
case Email.TYPE_MOBILE:
builder.append(Constants.ATTR_TYPE_CELL);
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + type);
builder.append(Constants.ATTR_TYPE_INTERNET);
break;
}
builder.append(VCARD_DATA_SEPARATOR);
builder.append(data);
builder.append(VCARD_COL_SEPARATOR);
}"
23806,"@Override protected void handleAgent(String propertyValue) throws VCardException {
  throw new VCardException(""String_Node_Str"");
}","@Override protected void handleAgent(String propertyValue){
  if (!mEmittedAgentWarning) {
    Log.w(LOG_TAG,""String_Node_Str"");
    mEmittedAgentWarning=true;
  }
}"
23807,"/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (localLOGV)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (localLOGV)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.appInfo.processName == r.info.processName) {
      if (localLOGV)       Log.v(TAG,""String_Node_Str"");
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}","/** 
 * Drop a content provider from a ProcessRecord's bookkeeping
 * @param cpr
 */
public void removeContentProvider(IApplicationThread caller,String name){
synchronized (this) {
    ContentProviderRecord cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr == null) {
      if (DEBUG_PROVIDER)       Log.v(TAG,name + ""String_Node_Str"");
      return;
    }
    final ProcessRecord r=getRecordForAppLocked(caller);
    if (r == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ name);
    }
    ContentProviderRecord localCpr=(ContentProviderRecord)mProvidersByClass.get(cpr.info.name);
    if (DEBUG_PROVIDER)     Log.v(TAG,""String_Node_Str"" + r.info.processName + ""String_Node_Str""+ localCpr.appInfo.processName);
    if (localCpr.app == r) {
      Log.w(TAG,""String_Node_Str"" + cpr.info.name + ""String_Node_Str""+ r.processName);
      return;
    }
 else {
      localCpr.clients.remove(r);
      r.conProviders.remove(localCpr);
    }
    updateOomAdjLocked();
  }
}"
23808,"private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(LOG_AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.deliveredStarts.clear();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        Log.i(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + r.shortName);
  }
}","private final void bringDownServiceLocked(ServiceRecord r,boolean force){
  if (!force && r.startRequested) {
    return;
  }
  if (r.connections.size() > 0) {
    if (!force) {
      Iterator<ConnectionRecord> it=r.connections.values().iterator();
      while (it.hasNext()) {
        ConnectionRecord cr=it.next();
        if ((cr.flags & Context.BIND_AUTO_CREATE) != 0) {
          return;
        }
      }
    }
    Iterator<ConnectionRecord> it=r.connections.values().iterator();
    while (it.hasNext()) {
      ConnectionRecord c=it.next();
      try {
        c.conn.connected(r.name,null);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ c.conn.asBinder()+ ""String_Node_Str""+ c.binding.client.processName+ ""String_Node_Str"",e);
      }
    }
  }
  if (r.bindings.size() > 0 && r.app != null && r.app.thread != null) {
    Iterator<IntentBindRecord> it=r.bindings.values().iterator();
    while (it.hasNext()) {
      IntentBindRecord ibr=it.next();
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + ibr + ""String_Node_Str""+ ibr.hasBound);
      if (r.app != null && r.app.thread != null && ibr.hasBound) {
        try {
          bumpServiceExecutingLocked(r);
          updateOomAdjLocked(r.app);
          ibr.hasBound=false;
          r.app.thread.scheduleUnbindService(r,ibr.intent.getIntent());
        }
 catch (        Exception e) {
          Log.w(TAG,""String_Node_Str"" + r.shortName,e);
          serviceDoneExecutingLocked(r,true);
        }
      }
    }
  }
  if (DEBUG_SERVICE)   Log.v(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ r.intent);
  EventLog.writeEvent(LOG_AM_DESTROY_SERVICE,System.identityHashCode(r),r.shortName,(r.app != null) ? r.app.pid : -1);
  mServices.remove(r.name);
  mServicesByIntent.remove(r.intent);
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + r.shortName);
  r.totalRestartCount=0;
  unscheduleServiceRestartLocked(r);
  int N=mPendingServices.size();
  for (int i=0; i < N; i++) {
    if (mPendingServices.get(i) == r) {
      mPendingServices.remove(i);
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
      i--;
      N--;
    }
  }
  r.cancelNotification();
  r.isForeground=false;
  r.foregroundId=0;
  r.foregroundNoti=null;
  r.deliveredStarts.clear();
  r.pendingStarts.clear();
  if (r.app != null) {
synchronized (r.stats.getBatteryStats()) {
      r.stats.stopLaunchedLocked();
    }
    r.app.services.remove(r);
    if (r.app.thread != null) {
      try {
        if (DEBUG_SERVICE)         Log.v(TAG,""String_Node_Str"" + r.shortName);
        bumpServiceExecutingLocked(r);
        mStoppingServices.add(r);
        updateOomAdjLocked(r.app);
        r.app.thread.scheduleStopService(r);
      }
 catch (      Exception e) {
        Log.w(TAG,""String_Node_Str"" + r.shortName,e);
        serviceDoneExecutingLocked(r,true);
      }
      updateServiceForegroundLocked(r.app,false);
    }
 else {
      if (DEBUG_SERVICE)       Log.v(TAG,""String_Node_Str"" + r.shortName);
    }
  }
 else {
    if (DEBUG_SERVICE)     Log.v(TAG,""String_Node_Str"" + r.shortName);
  }
}"
23809,"private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (false) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
        if (false) {
          final ContentProviderRecord rec=(ContentProviderRecord)mLaunchingProviders.get(i);
          if (rec.info.name.equals(cpr.info.name)) {
            cpr=rec;
            break;
          }
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}","private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller,String name){
  ContentProviderRecord cpr;
  ProviderInfo cpi=null;
synchronized (this) {
    ProcessRecord r=null;
    if (caller != null) {
      r=getRecordForAppLocked(caller);
      if (r == null) {
        throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ name);
      }
    }
    cpr=(ContentProviderRecord)mProvidersByName.get(name);
    if (cpr != null) {
      cpi=cpr.info;
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      if (r != null && cpr.canRunHere(r)) {
        if (cpr.provider != null) {
          cpr=new ContentProviderRecord(cpr);
        }
        return cpr;
      }
      final long origId=Binder.clearCallingIdentity();
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
      if (cpr.app != null) {
        updateOomAdjLocked(cpr.app);
      }
      Binder.restoreCallingIdentity(origId);
    }
 else {
      try {
        cpi=ActivityThread.getPackageManager().resolveContentProvider(name,STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
      }
 catch (      RemoteException ex) {
      }
      if (cpi == null) {
        return null;
      }
      if (checkContentProviderPermissionLocked(cpi,r,-1) != null) {
        return new ContentProviderHolder(cpi,cpi.readPermission != null ? cpi.readPermission : cpi.writePermission);
      }
      cpr=(ContentProviderRecord)mProvidersByClass.get(cpi.name);
      final boolean firstClass=cpr == null;
      if (firstClass) {
        try {
          ApplicationInfo ai=ActivityThread.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName,STOCK_PM_FLAGS);
          if (ai == null) {
            Log.w(TAG,""String_Node_Str"" + cpi.name);
            return null;
          }
          cpr=new ContentProviderRecord(cpi,ai);
        }
 catch (        RemoteException ex) {
        }
      }
      if (r != null && cpr.canRunHere(r)) {
        return cpr;
      }
      if (DEBUG_PROVIDER) {
        RuntimeException e=new RuntimeException(""String_Node_Str"");
        Log.w(TAG,""String_Node_Str"" + r.info.uid + ""String_Node_Str""+ cpr.appInfo.uid+ ""String_Node_Str""+ cpr.info.name,e);
      }
      final int N=mLaunchingProviders.size();
      int i;
      for (i=0; i < N; i++) {
        if (mLaunchingProviders.get(i) == cpr) {
          break;
        }
      }
      if (i >= N) {
        final long origId=Binder.clearCallingIdentity();
        ProcessRecord proc=startProcessLocked(cpi.processName,cpr.appInfo,false,0,""String_Node_Str"",new ComponentName(cpi.applicationInfo.packageName,cpi.name),false);
        if (proc == null) {
          Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
          return null;
        }
        cpr.launchingApp=proc;
        mLaunchingProviders.add(cpr);
        Binder.restoreCallingIdentity(origId);
      }
      if (firstClass) {
        mProvidersByClass.put(cpi.name,cpr);
      }
      mProvidersByName.put(name,cpr);
      if (r != null) {
        if (DEBUG_PROVIDER)         Log.v(TAG,""String_Node_Str"" + r.processName + ""String_Node_Str""+ cpr.info.processName);
        r.conProviders.add(cpr);
        cpr.clients.add(r);
      }
 else {
        cpr.externals++;
      }
    }
  }
synchronized (cpr) {
    while (cpr.provider == null) {
      if (cpr.launchingApp == null) {
        Log.w(TAG,""String_Node_Str"" + cpi.applicationInfo.packageName + ""String_Node_Str""+ cpi.applicationInfo.uid+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        EventLog.writeEvent(LOG_AM_PROVIDER_LOST_PROCESS,cpi.applicationInfo.packageName,cpi.applicationInfo.uid,name);
        return null;
      }
      try {
        cpr.wait();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
  return cpr;
}"
23810,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}"
23811,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}"
23812,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}"
23813,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}"
23814,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}"
23815,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}"
23816,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}"
23817,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}"
23818,"Globals(){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}"
23819,"static void initGlobals(Looper looper){
synchronized (mSync) {
    if (sGlobals == null) {
      sGlobals=new Globals();
    }
  }
}","static void initGlobals(Looper looper){
synchronized (mSync) {
    if (sGlobals == null) {
      sGlobals=new Globals(looper);
    }
  }
}"
23820,"Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}","Globals(Looper looper){
  IBinder b=ServiceManager.getService(Context.WALLPAPER_SERVICE);
  mService=IWallpaperManager.Stub.asInterface(b);
  mHandler=new Handler(looper){
    @Override public void handleMessage(    Message msg){
switch (msg.what) {
case MSG_CLEAR_WALLPAPER:
synchronized (this) {
          mWallpaper=null;
        }
      break;
  }
}
}
;
}"
23821,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}"
23822,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}"
23823,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}"
23824,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}"
23825,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}"
23826,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}"
23827,"private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      mWindows.add(index,win);
      index++;
      added=true;
    }
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    mWindows.add(index,win);
    index++;
  }
  return index;
}","private final int reAddWindowLocked(int index,WindowState win){
  final int NCW=win.mChildWindows.size();
  boolean added=false;
  for (int j=0; j < NCW; j++) {
    WindowState cwin=(WindowState)win.mChildWindows.get(j);
    if (!added && cwin.mSubLayer >= 0) {
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
      mWindows.add(index,win);
      index++;
      added=true;
    }
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ cwin);
    mWindows.add(index,cwin);
    index++;
  }
  if (!added) {
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + index + ""String_Node_Str""+ win);
    mWindows.add(index,win);
    index++;
  }
  return index;
}"
23828,"Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
  }
  if (config != null) {
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
  }
  return config;
}","Configuration updateOrientationFromAppTokensUnchecked(Configuration currentConfig,IBinder freezeThisOneIfNeeded){
  Configuration config;
synchronized (mWindowMap) {
    config=updateOrientationFromAppTokensLocked(currentConfig,freezeThisOneIfNeeded);
    if (config != null) {
      mLayoutNeeded=true;
      performLayoutAndPlaceSurfacesLocked();
    }
  }
  return config;
}"
23829,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      final int N=mWindows.size();
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionRunning=true;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          if (mToTopApps.size() > 0) {
            NN=mAppTokens.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mAppTokens.get(i);
              if (wtoken.sendingToTop) {
                wtoken.sendingToTop=false;
                moveAppWindowsLocked(wtoken,NN,false);
              }
            }
            mToTopApps.clear();
          }
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToHide=false;
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
mToBottomApps.clear();
rebuildAppWindowListLocked();
restart=true;
moveInputMethodWindowsIfNeededLocked(false);
wallpaperMayChange=true;
mLayoutNeeded=true;
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
if (mLayoutNeeded) {
  performLayoutLockedInner();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
final int N=mWindows.size();
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
boolean needRelayout=false;
if (!animating && mAppTransitionRunning) {
mAppTransitionRunning=false;
needRelayout=true;
rebuildAppWindowListLocked();
mToBottomApps.clear();
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
needRelayout=adjustWallpaperWindowsLocked();
}
if (needRelayout) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}"
23830,"private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      mWindows.remove(win.mChildWindows.get(j));
    }
  }
  return NW > 0;
}","private boolean tmpRemoveAppWindowsLocked(WindowToken token){
  final int NW=token.windows.size();
  for (int i=0; i < NW; i++) {
    WindowState win=token.windows.get(i);
    if (DEBUG_WINDOW_MOVEMENT)     Log.v(TAG,""String_Node_Str"" + win);
    mWindows.remove(win);
    int j=win.mChildWindows.size();
    while (j > 0) {
      j--;
      WindowState cwin=(WindowState)win.mChildWindows.get(j);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + cwin);
      mWindows.remove(cwin);
    }
  }
  return NW > 0;
}"
23831,"private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}","private void removeWindowInnerLocked(Session session,WindowState win){
  mKeyWaiter.finishedKey(session,win.mClient,true,KeyWaiter.RETURN_NOTHING);
  mKeyWaiter.releasePendingPointerLocked(win.mSession);
  mKeyWaiter.releasePendingTrackballLocked(win.mSession);
  win.mRemoved=true;
  if (mInputMethodTarget == win) {
    moveInputMethodWindowsIfNeededLocked(false);
  }
  if (false) {
    RuntimeException e=new RuntimeException(""String_Node_Str"");
    e.fillInStackTrace();
    Log.w(TAG,""String_Node_Str"" + win,e);
  }
  mPolicy.removeWindowLw(win);
  win.removeLocked();
  mWindowMap.remove(win.mClient.asBinder());
  mWindows.remove(win);
  if (mInputMethodWindow == win) {
    mInputMethodWindow=null;
  }
 else   if (win.mAttrs.type == TYPE_INPUT_METHOD_DIALOG) {
    mInputMethodDialogs.remove(win);
  }
  final WindowToken token=win.mToken;
  final AppWindowToken atoken=win.mAppToken;
  token.windows.remove(win);
  if (atoken != null) {
    atoken.allAppWindows.remove(win);
  }
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + win + ""String_Node_Str""+ token.windows.size());
  if (token.windows.size() == 0) {
    if (!token.explicit) {
      mTokenMap.remove(token.token);
      mTokenList.remove(token);
    }
 else     if (atoken != null) {
      atoken.firstWindowDrawn=false;
    }
  }
  if (atoken != null) {
    if (atoken.startingWindow == win) {
      atoken.startingWindow=null;
    }
 else     if (atoken.allAppWindows.size() == 0 && atoken.startingData != null) {
      atoken.startingData=null;
    }
 else     if (atoken.allAppWindows.size() == 1 && atoken.startingView != null) {
      if (DEBUG_STARTING_WINDOW) {
        Log.v(TAG,""String_Node_Str"" + token + ""String_Node_Str"");
      }
      Message m=mH.obtainMessage(H.REMOVE_STARTING,atoken);
      mH.sendMessage(m);
    }
  }
  if (win.mAttrs.type == TYPE_WALLPAPER || (win.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
    adjustWallpaperWindowsLocked();
  }
  if (!mInLayout) {
    assignLayersLocked();
    mLayoutNeeded=true;
    performLayoutAndPlaceSurfacesLocked();
    if (win.mAppToken != null) {
      win.mAppToken.updateReportedVisibilityLocked();
    }
  }
}"
23832,"final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      mWindows.remove(i);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    AppWindowToken wt=mAppTokens.get(j);
    final int NTW=wt.windows.size();
    for (int k=0; k < NTW; k++) {
      WindowState win=wt.windows.get(k);
      final int NC=win.mChildWindows.size();
      int c;
      for (c=0; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        if (cwin.mSubLayer >= 0) {
          break;
        }
        mWindows.add(i,cwin);
        i++;
      }
      mWindows.add(i,win);
      i++;
      for (; c < NC; c++) {
        WindowState cwin=(WindowState)win.mChildWindows.get(c);
        mWindows.add(i,cwin);
        i++;
      }
    }
  }
}","final void rebuildAppWindowListLocked(){
  int NW=mWindows.size();
  int i;
  i=0;
  while (i < NW) {
    if (((WindowState)mWindows.get(i)).mAppToken != null) {
      WindowState win=(WindowState)mWindows.remove(i);
      if (DEBUG_WINDOW_MOVEMENT)       Log.v(TAG,""String_Node_Str"" + win);
      NW--;
      continue;
    }
    i++;
  }
  int NT=mExitingAppTokens.size();
  i=0;
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mExitingAppTokens.get(j));
  }
  NT=mAppTokens.size();
  for (int j=0; j < NT; j++) {
    i=reAddAppWindowsLocked(i,mAppTokens.get(j));
  }
}"
23833,"public Connection dial(String dialString) throws CallStateException {
  String newDialString=PhoneNumberUtils.stripSeparators(dialString);
  if (!mCT.foregroundCall.isIdle()) {
    FeatureCode fc=FeatureCode.newFromDialString(newDialString,this);
    if (fc != null) {
      fc.processCode();
      return null;
    }
  }
  return mCT.dial(newDialString);
}","public Connection dial(String dialString) throws CallStateException {
  String newDialString=PhoneNumberUtils.stripSeparators(dialString);
  return mCT.dial(newDialString);
}"
23834,"InputBindResult startInputInnerLocked(){
  if (mCurMethodId == null) {
    return mNoBinding;
  }
  if (!mSystemReady) {
    return new InputBindResult(null,mCurId,mCurSeq);
  }
  InputMethodInfo info=mMethodMap.get(mCurMethodId);
  if (info == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  unbindCurrentMethodLocked(false);
  mCurIntent=new Intent(InputMethod.SERVICE_INTERFACE);
  mCurIntent.setComponent(info.getComponent());
  if (mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE)) {
    mLastBindTime=SystemClock.uptimeMillis();
    mHaveConnection=true;
    mCurId=info.getId();
    mCurToken=new Binder();
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
    }
 catch (    RemoteException e) {
    }
    return new InputBindResult(null,mCurId,mCurSeq);
  }
 else {
    mCurIntent=null;
    Log.w(TAG,""String_Node_Str"" + mCurIntent);
  }
  return null;
}","InputBindResult startInputInnerLocked(){
  if (mCurMethodId == null) {
    return mNoBinding;
  }
  if (!mSystemReady) {
    return new InputBindResult(null,mCurMethodId,mCurSeq);
  }
  InputMethodInfo info=mMethodMap.get(mCurMethodId);
  if (info == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + mCurMethodId);
  }
  unbindCurrentMethodLocked(false);
  mCurIntent=new Intent(InputMethod.SERVICE_INTERFACE);
  mCurIntent.setComponent(info.getComponent());
  if (mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE)) {
    mLastBindTime=SystemClock.uptimeMillis();
    mHaveConnection=true;
    mCurId=info.getId();
    mCurToken=new Binder();
    try {
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      mIWindowManager.addWindowToken(mCurToken,WindowManager.LayoutParams.TYPE_INPUT_METHOD);
    }
 catch (    RemoteException e) {
    }
    return new InputBindResult(null,mCurId,mCurSeq);
  }
 else {
    mCurIntent=null;
    Log.w(TAG,""String_Node_Str"" + mCurIntent);
  }
  return null;
}"
23835,"public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mMethodMap) {
    if (mCurIntent != null && name.equals(mCurIntent.getComponent())) {
      mCurMethod=IInputMethod.Stub.asInterface(service);
      if (mCurClient != null) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + mCurToken);
        executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_ATTACH_TOKEN,mCurMethod,mCurToken));
        if (mCurClient != null) {
          if (DEBUG)           Log.v(TAG,""String_Node_Str"" + mCurClient);
          executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_CREATE_SESSION,mCurMethod,new MethodCallback(mCurMethod)));
        }
      }
    }
  }
}","public void onServiceConnected(ComponentName name,IBinder service){
synchronized (mMethodMap) {
    if (mCurIntent != null && name.equals(mCurIntent.getComponent())) {
      mCurMethod=IInputMethod.Stub.asInterface(service);
      if (mCurToken == null) {
        Log.w(TAG,""String_Node_Str"");
        unbindCurrentMethodLocked(false);
        return;
      }
      if (DEBUG)       Log.v(TAG,""String_Node_Str"" + mCurToken);
      executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_ATTACH_TOKEN,mCurMethod,mCurToken));
      if (mCurClient != null) {
        if (DEBUG)         Log.v(TAG,""String_Node_Str"" + mCurClient);
        executeOrSendMessage(mCurMethod,mCaller.obtainMessageOO(MSG_CREATE_SESSION,mCurMethod,new MethodCallback(mCurMethod)));
      }
    }
  }
}"
23836,"boolean showCurrentInputLocked(int flags,ResultReceiver resultReceiver){
  mShowRequested=true;
  if ((flags & InputMethodManager.SHOW_IMPLICIT) == 0) {
    mShowExplicitlyRequested=true;
  }
  if ((flags & InputMethodManager.SHOW_FORCED) != 0) {
    mShowExplicitlyRequested=true;
    mShowForced=true;
  }
  boolean res=false;
  if (mCurMethod != null) {
    executeOrSendMessage(mCurMethod,mCaller.obtainMessageIOO(MSG_SHOW_SOFT_INPUT,getImeShowFlags(),mCurMethod,resultReceiver));
    mInputShown=true;
    res=true;
  }
 else   if (mHaveConnection && SystemClock.uptimeMillis() < (mLastBindTime + TIME_TO_RECONNECT)) {
    EventLog.writeEvent(LOG_IMF_FORCE_RECONNECT_IME,mCurMethodId,SystemClock.uptimeMillis() - mLastBindTime,1);
    mContext.unbindService(this);
    mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE);
  }
  return res;
}","boolean showCurrentInputLocked(int flags,ResultReceiver resultReceiver){
  mShowRequested=true;
  if ((flags & InputMethodManager.SHOW_IMPLICIT) == 0) {
    mShowExplicitlyRequested=true;
  }
  if ((flags & InputMethodManager.SHOW_FORCED) != 0) {
    mShowExplicitlyRequested=true;
    mShowForced=true;
  }
  if (!mSystemReady) {
    return false;
  }
  boolean res=false;
  if (mCurMethod != null) {
    executeOrSendMessage(mCurMethod,mCaller.obtainMessageIOO(MSG_SHOW_SOFT_INPUT,getImeShowFlags(),mCurMethod,resultReceiver));
    mInputShown=true;
    res=true;
  }
 else   if (mHaveConnection && SystemClock.uptimeMillis() < (mLastBindTime + TIME_TO_RECONNECT)) {
    EventLog.writeEvent(LOG_IMF_FORCE_RECONNECT_IME,mCurMethodId,SystemClock.uptimeMillis() - mLastBindTime,1);
    mContext.unbindService(this);
    mContext.bindService(mCurIntent,this,Context.BIND_AUTO_CREATE);
  }
  return res;
}"
23837,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
  IInputMethod method;
  ClientState client;
  final Printer p=new PrintWriterPrinter(pw);
synchronized (mMethodMap) {
    p.println(""String_Node_Str"");
    int N=mMethodList.size();
    p.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      InputMethodInfo info=mMethodList.get(i);
      p.println(""String_Node_Str"" + i + ""String_Node_Str"");
      info.dump(p,""String_Node_Str"");
    }
    p.println(""String_Node_Str"");
    for (    ClientState ci : mClients.values()) {
      p.println(""String_Node_Str"" + ci + ""String_Node_Str"");
      p.println(""String_Node_Str"" + ci.client);
      p.println(""String_Node_Str"" + ci.inputContext);
      p.println(""String_Node_Str"" + ci.sessionRequested);
      p.println(""String_Node_Str"" + ci.curSession);
    }
    p.println(""String_Node_Str"" + mInputMethodIcon);
    p.println(""String_Node_Str"" + mInputMethodData);
    p.println(""String_Node_Str"" + mCurMethodId);
    client=mCurClient;
    p.println(""String_Node_Str"" + client + ""String_Node_Str""+ mCurSeq);
    p.println(""String_Node_Str"" + mCurFocusedWindow);
    p.println(""String_Node_Str"" + mCurId + ""String_Node_Str""+ mHaveConnection+ ""String_Node_Str""+ mBoundToMethod);
    p.println(""String_Node_Str"" + mCurToken);
    p.println(""String_Node_Str"" + mCurIntent);
    method=mCurMethod;
    p.println(""String_Node_Str"" + mCurMethod);
    p.println(""String_Node_Str"" + mEnabledSession);
    p.println(""String_Node_Str"" + mShowRequested + ""String_Node_Str""+ mShowExplicitlyRequested+ ""String_Node_Str""+ mShowForced+ ""String_Node_Str""+ mInputShown);
    p.println(""String_Node_Str"" + mScreenOn);
  }
  if (client != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      client.client.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
  if (method != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      method.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid());
    return;
  }
  IInputMethod method;
  ClientState client;
  final Printer p=new PrintWriterPrinter(pw);
synchronized (mMethodMap) {
    p.println(""String_Node_Str"");
    int N=mMethodList.size();
    p.println(""String_Node_Str"");
    for (int i=0; i < N; i++) {
      InputMethodInfo info=mMethodList.get(i);
      p.println(""String_Node_Str"" + i + ""String_Node_Str"");
      info.dump(p,""String_Node_Str"");
    }
    p.println(""String_Node_Str"");
    for (    ClientState ci : mClients.values()) {
      p.println(""String_Node_Str"" + ci + ""String_Node_Str"");
      p.println(""String_Node_Str"" + ci.client);
      p.println(""String_Node_Str"" + ci.inputContext);
      p.println(""String_Node_Str"" + ci.sessionRequested);
      p.println(""String_Node_Str"" + ci.curSession);
    }
    p.println(""String_Node_Str"" + mInputMethodIcon);
    p.println(""String_Node_Str"" + mInputMethodData);
    p.println(""String_Node_Str"" + mCurMethodId);
    client=mCurClient;
    p.println(""String_Node_Str"" + client + ""String_Node_Str""+ mCurSeq);
    p.println(""String_Node_Str"" + mCurFocusedWindow);
    p.println(""String_Node_Str"" + mCurId + ""String_Node_Str""+ mHaveConnection+ ""String_Node_Str""+ mBoundToMethod);
    p.println(""String_Node_Str"" + mCurToken);
    p.println(""String_Node_Str"" + mCurIntent);
    method=mCurMethod;
    p.println(""String_Node_Str"" + mCurMethod);
    p.println(""String_Node_Str"" + mEnabledSession);
    p.println(""String_Node_Str"" + mShowRequested + ""String_Node_Str""+ mShowExplicitlyRequested+ ""String_Node_Str""+ mShowForced+ ""String_Node_Str""+ mInputShown);
    p.println(""String_Node_Str"" + mSystemReady + ""String_Node_Str""+ mScreenOn);
  }
  if (client != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      client.client.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
  if (method != null) {
    p.println(""String_Node_Str"");
    pw.flush();
    try {
      method.asBinder().dump(fd,args);
    }
 catch (    RemoteException e) {
      p.println(""String_Node_Str"" + e);
    }
  }
}"
23838,"public void systemReady(){
synchronized (mMethodMap) {
    if (!mSystemReady) {
      mSystemReady=true;
      startInputInnerLocked();
    }
  }
}","public void systemReady(){
synchronized (mMethodMap) {
    if (!mSystemReady) {
      mSystemReady=true;
      try {
        startInputInnerLocked();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"",e);
      }
    }
  }
}"
23839,"/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations;
  }
}","/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations < 0 ? 0 : unreadConversations;
  }
}"
23840,"/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  if (unreadConversations == null) {
    return 0;
  }
 else {
    return unreadConversations < 0 ? 0 : unreadConversations;
  }
}","/** 
 * Returns the number of unread conversation with a given label. 
 */
public int getNumUnreadConversations(long labelId){
  Integer unreadConversations=getLabelIdValues(labelId).getAsInteger(LabelColumns.NUM_UNREAD_CONVERSATIONS);
  int result=0;
  if (unreadConversations != null) {
    result=unreadConversations < 0 ? 0 : unreadConversations;
  }
  return result;
}"
23841,"/** 
 * Compare the IMSI to the one stored in the login service's database.  If they differ, erase all passwords and authtokens (and store the new IMSI).
 */
@Override public void onReceive(Context context,Intent intent){
  String imsi=((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE)).getSubscriberId();
  if (TextUtils.isEmpty(imsi))   return;
  String storedImsi=getMetaValue(""String_Node_Str"");
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + imsi + ""String_Node_Str""+ storedImsi);
  }
  if (!imsi.equals(storedImsi) && !""String_Node_Str"".equals(storedImsi)) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"");
    }
    SQLiteDatabase db=mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + TABLE_AUTHTOKENS);
      db.execSQL(""String_Node_Str"" + TABLE_ACCOUNTS + ""String_Node_Str""+ ACCOUNTS_PASSWORD+ ""String_Node_Str"");
      sendAccountsChangedBroadcast();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  setMetaValue(""String_Node_Str"",imsi);
}","/** 
 * Compare the IMSI to the one stored in the login service's database.  If they differ, erase all passwords and authtokens (and store the new IMSI).
 */
@Override public void onReceive(Context context,Intent intent){
  String imsi=((TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE)).getSubscriberId();
  if (TextUtils.isEmpty(imsi))   return;
  String storedImsi=getMetaValue(""String_Node_Str"");
  if (Log.isLoggable(TAG,Log.VERBOSE)) {
    Log.v(TAG,""String_Node_Str"" + imsi + ""String_Node_Str""+ storedImsi);
  }
  if (!imsi.equals(storedImsi) && !TextUtils.isEmpty(storedImsi)) {
    if (Log.isLoggable(TAG,Log.VERBOSE)) {
      Log.v(TAG,""String_Node_Str"");
    }
    SQLiteDatabase db=mOpenHelper.getWritableDatabase();
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + TABLE_AUTHTOKENS);
      db.execSQL(""String_Node_Str"" + TABLE_ACCOUNTS + ""String_Node_Str""+ ACCOUNTS_PASSWORD+ ""String_Node_Str"");
      sendAccountsChangedBroadcast();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
  }
  setMetaValue(""String_Node_Str"",imsi);
}"
23842,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
if (cdmaForSubscriptionInfoReadyRegistrants != null) {
cdmaForSubscriptionInfoReadyRegistrants.notifyRegistrants();
}
if (!mIsMinInfoReady) {
mIsMinInfoReady=true;
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
case EVENT_SET_RADIO_POWER_OFF:
synchronized (this) {
if (mPendingRadioPowerOffAfterDataOff) {
if (DBG) log(""String_Node_Str"");
cm.setRadioPower(false,null);
mPendingRadioPowerOffAfterDataOff=false;
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
if (cdmaForSubscriptionInfoReadyRegistrants != null) {
cdmaForSubscriptionInfoReadyRegistrants.notifyRegistrants();
}
if (!mIsMinInfoReady) {
mIsMinInfoReady=true;
}
phone.getIccCard().broadcastIccStateChangedIntent(IccCard.INTENT_VALUE_ICC_IMSI,null);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
case EVENT_SET_RADIO_POWER_OFF:
synchronized (this) {
if (mPendingRadioPowerOffAfterDataOff) {
if (DBG) log(""String_Node_Str"");
cm.setRadioPower(false,null);
mPendingRadioPowerOffAfterDataOff=false;
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}"
23843,"/** 
 * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
 * @param max the upper range of this progress bar
 * @see #getMax()
 * @see #setProgress(int) 
 * @see #setSecondaryProgress(int) 
 */
@android.view.RemotableViewMethod public synchronized void setMax(int max){
  if (max < 0) {
    max=0;
  }
  if (max != mMax) {
    mMax=max;
    postInvalidate();
    if (mProgress > max) {
      mProgress=max;
    }
  }
}","/** 
 * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
 * @param max the upper range of this progress bar
 * @see #getMax()
 * @see #setProgress(int) 
 * @see #setSecondaryProgress(int) 
 */
@android.view.RemotableViewMethod public synchronized void setMax(int max){
  if (max < 0) {
    max=0;
  }
  if (max != mMax) {
    mMax=max;
    postInvalidate();
    if (mProgress > max) {
      mProgress=max;
      refreshProgress(R.id.progress,mProgress,false);
    }
  }
}"
23844,"public void executeMessage(Message message){
switch (message.what) {
case DO_ON_ACCESSIBILITY_EVENT:
    AccessibilityEvent event=(AccessibilityEvent)message.obj;
  mTarget.onAccessibilityEvent(event);
event.recycle();
return;
case DO_ON_INTERRUPT:
mTarget.onInterrupt();
return;
case DO_SET_SET_CONNECTION:
mConnection=((IAccessibilityServiceConnection)message.obj);
mTarget.onServiceConnected();
return;
default :
Log.w(LOG_TAG,""String_Node_Str"" + message.what);
}
}","public void executeMessage(Message message){
switch (message.what) {
case DO_ON_ACCESSIBILITY_EVENT:
    AccessibilityEvent event=(AccessibilityEvent)message.obj;
  if (event != null) {
    mTarget.onAccessibilityEvent(event);
    event.recycle();
  }
return;
case DO_ON_INTERRUPT:
mTarget.onInterrupt();
return;
case DO_SET_SET_CONNECTION:
mConnection=((IAccessibilityServiceConnection)message.obj);
mTarget.onServiceConnected();
return;
default :
Log.w(LOG_TAG,""String_Node_Str"" + message.what);
}
}"
23845,public abstract Handler getHandler();,"public Handler getHandler(){
  return this;
}"
23846,"/** 
 * Constructs a PhoneBase in normal (non-unit test) mode.
 * @param context Context object from hosting application
 * @param notifier An instance of DefaultPhoneNotifier,unless unit testing.
 * @param unitTestMode when true, prevents notificationsof state change events
 */
protected PhoneBase(PhoneNotifier notifier,Context context,boolean unitTestMode){
  this.mNotifier=notifier;
  this.mContext=context;
  mLooper=Looper.myLooper();
  setPropertiesByCarrier();
  setUnitTestMode(unitTestMode);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  mDnsCheckDisabled=sp.getBoolean(DNS_SERVER_CHECK_DISABLED_KEY,false);
}","/** 
 * Constructs a PhoneBase in normal (non-unit test) mode.
 * @param context Context object from hosting application
 * @param notifier An instance of DefaultPhoneNotifier,unless unit testing.
 * @param unitTestMode when true, prevents notificationsof state change events
 */
protected PhoneBase(PhoneNotifier notifier,Context context,CommandsInterface ci,boolean unitTestMode){
  this.mNotifier=notifier;
  this.mContext=context;
  mLooper=Looper.myLooper();
  mCM=ci;
  setPropertiesByCarrier();
  setUnitTestMode(unitTestMode);
  SharedPreferences sp=PreferenceManager.getDefaultSharedPreferences(context);
  mDnsCheckDisabled=sp.getBoolean(DNS_SERVER_CHECK_DISABLED_KEY,false);
  mCM.setOnCallRing(this,EVENT_CALL_RING,null);
  mDoesRilSendMultipleCallRing=SystemProperties.getBoolean(TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING,true);
  Log.d(LOG_TAG,""String_Node_Str"" + mDoesRilSendMultipleCallRing);
  mCallRingDelay=SystemProperties.getInt(TelephonyProperties.PROPERTY_CALL_RING_DELAY,3000);
  Log.d(LOG_TAG,""String_Node_Str"" + mCallRingDelay);
}"
23847,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      boolean wallpaperMayChange=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          if (w.commitFinishDrawingLocked(currentTime)) {
            if ((w.mAttrs.flags & WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER) != 0) {
              wallpaperMayChange=true;
            }
          }
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          wallpaperMayChange=false;
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
if (wallpaperMayChange) {
if (adjustWallpaperWindowsLocked()) {
  assignLayersLocked();
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}"
23848,"boolean adjustWallpaperWindowsLocked(){
  boolean changed=false;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
      if (!w.mAppToken.appFullscreen) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && !w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mAppToken != null && w.mAppToken.animation != null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_NONE) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && foundW.mAppToken != null && oldW != null && oldW.mAppToken != null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundW.mAppToken.animation + ""String_Node_Str""+ oldW.mAppToken.animation);
      }
      if (foundW.mAppToken.animation != null && oldW.mAppToken.animation != null) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=!foundW.mObscured;
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
  foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(mWallpaperTarget,wallpaper,dw,dh);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed=true;
    }
  }
  return changed;
}","boolean adjustWallpaperWindowsLocked(){
  boolean changed=false;
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final ArrayList localmWindows=mWindows;
  int N=localmWindows.size();
  WindowState w=null;
  WindowState foundW=null;
  int foundI=0;
  int i=N;
  while (i > 0) {
    i--;
    w=(WindowState)localmWindows.get(i);
    if (w.mAppToken != null) {
      if (w.mAppToken.hidden && w.mAppToken.animation == null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
      if (!w.mAppToken.appFullscreen) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w);
        continue;
      }
    }
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isReadyForDisplay()+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending);
    if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0 && w.isReadyForDisplay() && (mWallpaperTarget == w || (!w.mDrawPending && !w.mCommitDrawPending))) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w);
      foundW=w;
      foundI=i;
      if (w == mWallpaperTarget && w.mAppToken != null && w.mAppToken.animation != null) {
        if (DEBUG_WALLPAPER)         Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
        continue;
      }
      break;
    }
  }
  if (mNextAppTransition != WindowManagerPolicy.TRANSIT_NONE) {
    if (mWallpaperTarget != null && mWallpaperTarget.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
    if (foundW != null && foundW.mAppToken != null) {
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"");
      return false;
    }
  }
  if (mWallpaperTarget != foundW) {
    if (DEBUG_WALLPAPER) {
      Log.v(TAG,""String_Node_Str"" + foundW + ""String_Node_Str""+ mWallpaperTarget);
    }
    mLowerWallpaperTarget=null;
    mUpperWallpaperTarget=null;
    WindowState oldW=mWallpaperTarget;
    mWallpaperTarget=foundW;
    if (foundW != null && foundW.mAppToken != null && oldW != null && oldW.mAppToken != null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"" + foundW.mAppToken.animation + ""String_Node_Str""+ oldW.mAppToken.animation);
      }
      if (foundW.mAppToken.animation != null && oldW.mAppToken.animation != null) {
        int oldI=localmWindows.indexOf(oldW);
        if (DEBUG_WALLPAPER) {
          Log.v(TAG,""String_Node_Str"" + foundI + ""String_Node_Str""+ oldI);
        }
        if (oldI >= 0) {
          if (DEBUG_WALLPAPER) {
            Log.v(TAG,""String_Node_Str"" + oldI + ""String_Node_Str""+ oldW+ ""String_Node_Str""+ foundI+ ""String_Node_Str""+ foundW);
          }
          if (foundW.mAppToken.hiddenRequested) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mWallpaperTarget=oldW;
          }
          if (foundI > oldI) {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=foundW;
            mLowerWallpaperTarget=oldW;
            foundW=oldW;
            foundI=oldI;
          }
 else {
            if (DEBUG_WALLPAPER) {
              Log.v(TAG,""String_Node_Str"");
            }
            mUpperWallpaperTarget=oldW;
            mLowerWallpaperTarget=foundW;
          }
        }
      }
    }
  }
 else {
    if (mLowerWallpaperTarget == null || mLowerWallpaperTarget.mAppToken.animation == null || mUpperWallpaperTarget == null || mUpperWallpaperTarget.mAppToken.animation == null) {
      if (DEBUG_WALLPAPER) {
        Log.v(TAG,""String_Node_Str"");
      }
      mLowerWallpaperTarget=null;
      mUpperWallpaperTarget=null;
    }
  }
  boolean visible=foundW != null;
  if (visible) {
    visible=!foundW.mObscured;
    if (DEBUG_WALLPAPER)     Log.v(TAG,""String_Node_Str"" + visible);
    mWallpaperAnimLayerAdjustment=(mLowerWallpaperTarget == null && foundW.mAppToken != null) ? foundW.mAppToken.animLayerAdjustment : 0;
    while (foundI > 0) {
      WindowState wb=(WindowState)localmWindows.get(foundI - 1);
      if (wb.mAttachedWindow != foundW && (wb.mAttrs.type != TYPE_APPLICATION_STARTING || wb.mToken != foundW.mToken)) {
        break;
      }
      foundW=wb;
      foundI--;
    }
  }
  foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
  int curTokenIndex=mWallpaperTokens.size();
  while (curTokenIndex > 0) {
    curTokenIndex--;
    WindowToken token=mWallpaperTokens.get(curTokenIndex);
    int curWallpaperIndex=token.windows.size();
    while (curWallpaperIndex > 0) {
      curWallpaperIndex--;
      WindowState wallpaper=token.windows.get(curWallpaperIndex);
      if (visible) {
        updateWallpaperOffsetLocked(mWallpaperTarget,wallpaper,dw,dh);
      }
      if (wallpaper.mWallpaperVisible != visible) {
        wallpaper.mWallpaperVisible=visible;
        try {
          if (DEBUG_VISIBILITY || DEBUG_WALLPAPER)           Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ visible);
          wallpaper.mClient.dispatchAppVisibility(visible);
        }
 catch (        RemoteException e) {
        }
      }
      wallpaper.mAnimLayer=wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
      if (DEBUG_LAYERS || DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ wallpaper.mAnimLayer);
      if (wallpaper == foundW) {
        foundI--;
        foundW=foundI > 0 ? (WindowState)localmWindows.get(foundI - 1) : null;
        continue;
      }
      int oldIndex=localmWindows.indexOf(wallpaper);
      if (oldIndex >= 0) {
        localmWindows.remove(oldIndex);
        if (oldIndex < foundI) {
          foundI--;
        }
      }
      if (DEBUG_WALLPAPER)       Log.v(TAG,""String_Node_Str"" + wallpaper + ""String_Node_Str""+ oldIndex+ ""String_Node_Str""+ foundI);
      localmWindows.add(foundI,wallpaper);
      changed=true;
    }
  }
  return changed;
}"
23849,"void commitFinishDrawingLocked(long currentTime){
  if (!mCommitDrawPending) {
    return;
  }
  mCommitDrawPending=false;
  mReadyToShow=true;
  final boolean starting=mAttrs.type == TYPE_APPLICATION_STARTING;
  final AppWindowToken atoken=mAppToken;
  if (atoken == null || atoken.allDrawn || starting) {
    performShowLocked();
  }
}","boolean commitFinishDrawingLocked(long currentTime){
  if (!mCommitDrawPending) {
    return false;
  }
  mCommitDrawPending=false;
  mReadyToShow=true;
  final boolean starting=mAttrs.type == TYPE_APPLICATION_STARTING;
  final AppWindowToken atoken=mAppToken;
  if (atoken == null || atoken.allDrawn || starting) {
    performShowLocked();
  }
  return true;
}"
23850,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}"
23851,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}"
23852,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}"
23853,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}"
23854,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}"
23855,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}"
23856,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}"
23857,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}"
23858,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}"
23859,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}"
23860,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}"
23861,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}"
23862,"public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    proxy.updateNetworkState(mNetworkState);
  }
}","public void installLocationProvider(String name,ILocationProvider provider){
  if (mContext.checkCallingOrSelfPermission(INSTALL_LOCATION_PROVIDER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mLock) {
    LocationProviderProxy oldProvider=mProvidersByName.get(name);
    if (oldProvider != null) {
      if (oldProvider.isDead()) {
        Log.d(TAG,""String_Node_Str"");
        removeProvider(oldProvider);
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
    }
    LocationProviderProxy proxy=new LocationProviderProxy(name,provider);
    addProvider(proxy);
    updateProvidersLocked();
    if (LocationManager.NETWORK_PROVIDER.equals(name)) {
      mNetworkLocationProvider=proxy;
    }
    proxy.updateNetworkState(mNetworkState);
  }
}"
23863,"public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    long identity=Binder.clearCallingIdentity();
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    updateProvidersLocked();
    Binder.restoreCallingIdentity(identity);
  }
}","public void addTestProvider(String name,boolean requiresNetwork,boolean requiresSatellite,boolean requiresCell,boolean hasMonetaryCost,boolean supportsAltitude,boolean supportsSpeed,boolean supportsBearing,int powerRequirement,int accuracy){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider provider=new MockProvider(name,this,requiresNetwork,requiresSatellite,requiresCell,hasMonetaryCost,supportsAltitude,supportsSpeed,supportsBearing,powerRequirement,accuracy);
    if (LocationManager.GPS_PROVIDER.equals(name) || LocationManager.NETWORK_PROVIDER.equals(name)) {
      LocationProviderProxy proxy=mProvidersByName.get(name);
      if (proxy != null) {
        proxy.enableLocationTracking(false);
        removeProvider(proxy);
      }
    }
    if (mProvidersByName.get(name) != null) {
      throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    addProvider(new LocationProviderProxy(name,provider));
    mMockProviders.put(name,provider);
    mLastKnownLocation.put(name,null);
    updateProvidersLocked();
  }
}"
23864,"public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    updateProvidersLocked();
  }
}","public void removeTestProvider(String provider){
  checkMockPermissionsSafe();
synchronized (mLock) {
    MockProvider mockProvider=mMockProviders.get(provider);
    if (mockProvider == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + provider + ""String_Node_Str"");
    }
    removeProvider(mProvidersByName.get(provider));
    mMockProviders.remove(mockProvider);
    if (LocationManager.GPS_PROVIDER.equals(provider) && mGpsLocationProvider != null) {
      addProvider(mGpsLocationProvider);
    }
 else     if (LocationManager.NETWORK_PROVIDER.equals(provider) && mNetworkLocationProvider != null) {
      addProvider(mNetworkLocationProvider);
    }
    mLastKnownLocation.put(provider,null);
    updateProvidersLocked();
  }
}"
23865,"private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
  }
  updateProvidersLocked();
}","private void _loadProvidersLocked(){
  if (GpsLocationProvider.isSupported()) {
    GpsLocationProvider provider=new GpsLocationProvider(mContext,this);
    mGpsStatusProvider=provider.getGpsStatusProvider();
    LocationProviderProxy proxy=new LocationProviderProxy(LocationManager.GPS_PROVIDER,provider);
    addProvider(proxy);
    mGpsLocationProvider=proxy;
  }
  updateProvidersLocked();
}"
23866,"@Override public boolean onTouchEvent(MotionEvent motionEvent){
  if (!mInputEnabled || !isEnabled()) {
    return false;
  }
  final float x=motionEvent.getX();
  final float y=motionEvent.getY();
  Cell hitCell;
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    resetPattern();
  hitCell=detectAndAddHit(x,y);
if (hitCell != null && mOnPatternListener != null) {
  mPatternInProgress=true;
  mPatternDisplayMode=DisplayMode.Correct;
  mOnPatternListener.onPatternStart();
}
 else if (mOnPatternListener != null) {
  mPatternInProgress=false;
  mOnPatternListener.onPatternCleared();
}
if (hitCell != null) {
final float startX=getCenterXForColumn(hitCell.column);
final float startY=getCenterYForRow(hitCell.row);
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidate((int)(startX - widthOffset),(int)(startY - heightOffset),(int)(startX + widthOffset),(int)(startY + heightOffset));
}
mInProgressX=x;
mInProgressY=y;
if (PROFILE_DRAWING) {
if (!mDrawingProfilingStarted) {
Debug.startMethodTracing(""String_Node_Str"");
mDrawingProfilingStarted=true;
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mPattern.isEmpty() && mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternDetected(mPattern);
invalidate();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
case MotionEvent.ACTION_MOVE:
final int patternSizePreHitDetect=mPattern.size();
hitCell=detectAndAddHit(x,y);
final int patternSize=mPattern.size();
if (hitCell != null && (mOnPatternListener != null) && (patternSize == 1)) {
mPatternInProgress=true;
mOnPatternListener.onPatternStart();
}
final float dx=Math.abs(x - mInProgressX);
final float dy=Math.abs(y - mInProgressY);
if (dx + dy > mSquareWidth * 0.01f) {
float oldX=mInProgressX;
float oldY=mInProgressY;
mInProgressX=x;
mInProgressY=y;
if (mPatternInProgress) {
final ArrayList<Cell> pattern=mPattern;
final float radius=mSquareWidth * mDiameterFactor * 0.5f;
Cell cell=pattern.get(patternSize - 1);
float startX=getCenterXForColumn(cell.column);
float startY=getCenterYForRow(cell.row);
float left;
float top;
float right;
float bottom;
final Rect invalidateRect=mInvalidate;
if (startX < x) {
left=startX;
right=x;
}
 else {
left=x;
right=startX;
}
if (startY < y) {
top=startY;
bottom=y;
}
 else {
top=y;
bottom=startY;
}
invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (hitCell != null) {
startX=getCenterXForColumn(hitCell.column);
startY=getCenterYForRow(hitCell.row);
if (patternSize >= 2) {
hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
oldX=getCenterXForColumn(hitCell.column);
oldY=getCenterYForRow(hitCell.row);
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
}
 else {
left=right=startX;
top=bottom=startY;
}
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
}
invalidate(invalidateRect);
}
 else {
invalidate();
}
}
return true;
case MotionEvent.ACTION_CANCEL:
resetPattern();
if (mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternCleared();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
}
return false;
}","@Override public boolean onTouchEvent(MotionEvent motionEvent){
  if (!mInputEnabled || !isEnabled()) {
    return false;
  }
  final float x=motionEvent.getX();
  final float y=motionEvent.getY();
  Cell hitCell;
switch (motionEvent.getAction()) {
case MotionEvent.ACTION_DOWN:
    resetPattern();
  hitCell=detectAndAddHit(x,y);
if (hitCell != null && mOnPatternListener != null) {
  mPatternInProgress=true;
  mPatternDisplayMode=DisplayMode.Correct;
  mOnPatternListener.onPatternStart();
}
 else if (mOnPatternListener != null) {
  mPatternInProgress=false;
  mOnPatternListener.onPatternCleared();
}
if (hitCell != null) {
final float startX=getCenterXForColumn(hitCell.column);
final float startY=getCenterYForRow(hitCell.row);
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidate((int)(startX - widthOffset),(int)(startY - heightOffset),(int)(startX + widthOffset),(int)(startY + heightOffset));
}
mInProgressX=x;
mInProgressY=y;
if (PROFILE_DRAWING) {
if (!mDrawingProfilingStarted) {
Debug.startMethodTracing(""String_Node_Str"");
mDrawingProfilingStarted=true;
}
}
return true;
case MotionEvent.ACTION_UP:
if (!mPattern.isEmpty() && mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternDetected(mPattern);
invalidate();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
case MotionEvent.ACTION_MOVE:
final int patternSizePreHitDetect=mPattern.size();
hitCell=detectAndAddHit(x,y);
final int patternSize=mPattern.size();
if (hitCell != null && (mOnPatternListener != null) && (patternSize == 1)) {
mPatternInProgress=true;
mOnPatternListener.onPatternStart();
}
final float dx=Math.abs(x - mInProgressX);
final float dy=Math.abs(y - mInProgressY);
if (dx + dy > mSquareWidth * 0.01f) {
float oldX=mInProgressX;
float oldY=mInProgressY;
mInProgressX=x;
mInProgressY=y;
if (mPatternInProgress) {
if (mPattern.isEmpty()) return false;
final ArrayList<Cell> pattern=mPattern;
final float radius=mSquareWidth * mDiameterFactor * 0.5f;
Cell cell=pattern.get(patternSize - 1);
float startX=getCenterXForColumn(cell.column);
float startY=getCenterYForRow(cell.row);
float left;
float top;
float right;
float bottom;
final Rect invalidateRect=mInvalidate;
if (startX < x) {
left=startX;
right=x;
}
 else {
left=x;
right=startX;
}
if (startY < y) {
top=startY;
bottom=y;
}
 else {
top=y;
bottom=startY;
}
invalidateRect.set((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
invalidateRect.union((int)(left - radius),(int)(top - radius),(int)(right + radius),(int)(bottom + radius));
if (hitCell != null) {
startX=getCenterXForColumn(hitCell.column);
startY=getCenterYForRow(hitCell.row);
if (patternSize >= 2) {
hitCell=pattern.get(patternSize - 1 - (patternSize - patternSizePreHitDetect));
oldX=getCenterXForColumn(hitCell.column);
oldY=getCenterYForRow(hitCell.row);
if (startX < oldX) {
left=startX;
right=oldX;
}
 else {
left=oldX;
right=startX;
}
if (startY < oldY) {
top=startY;
bottom=oldY;
}
 else {
top=oldY;
bottom=startY;
}
}
 else {
left=right=startX;
top=bottom=startY;
}
final float widthOffset=mSquareWidth / 2f;
final float heightOffset=mSquareHeight / 2f;
invalidateRect.set((int)(left - widthOffset),(int)(top - heightOffset),(int)(right + widthOffset),(int)(bottom + heightOffset));
}
invalidate(invalidateRect);
}
 else {
invalidate();
}
}
return true;
case MotionEvent.ACTION_CANCEL:
resetPattern();
if (mOnPatternListener != null) {
mPatternInProgress=false;
mOnPatternListener.onPatternCleared();
}
if (PROFILE_DRAWING) {
if (mDrawingProfilingStarted) {
Debug.stopMethodTracing();
mDrawingProfilingStarted=false;
}
}
return true;
}
return false;
}"
23867,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          adjustWallpaperWindowsLocked();
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"" + mWallpaperTarget + ""String_Node_Str""+ mLowerWallpaperTarget+ ""String_Node_Str""+ mUpperWallpaperTarget);
          if (mLowerWallpaperTarget != null) {
            int found=0;
            NN=mOpeningApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mOpeningApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=1;
              }
            }
            NN=mClosingApps.size();
            for (i=0; i < NN; i++) {
              AppWindowToken wtoken=mClosingApps.get(i);
              if (mLowerWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
              if (mUpperWallpaperTarget.mAppToken == wtoken) {
                found|=2;
              }
            }
            if (found == 3) {
              if (DEBUG_APP_TRANSITIONS)               Log.v(TAG,""String_Node_Str"");
switch (transit) {
case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_OPEN:
case WindowManagerPolicy.TRANSIT_TASK_TO_FRONT:
                transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_OPEN;
              break;
case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_CLOSE:
case WindowManagerPolicy.TRANSIT_TASK_TO_BACK:
            transit=WindowManagerPolicy.TRANSIT_WALLPAPER_ACTIVITY_CLOSE;
          break;
      }
      if (DEBUG_APP_TRANSITIONS)       Log.v(TAG,""String_Node_Str"" + transit);
    }
  }
  WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
  NN=mOpeningApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mOpeningApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.reportedVisible=false;
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,true,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.showAllWindowsLocked();
  }
  NN=mClosingApps.size();
  for (i=0; i < NN; i++) {
    AppWindowToken wtoken=mClosingApps.get(i);
    if (DEBUG_APP_TRANSITIONS)     Log.v(TAG,""String_Node_Str"" + wtoken);
    wtoken.inPendingTransaction=false;
    wtoken.animation=null;
    setTokenVisibilityLocked(wtoken,lp,false,transit,false);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
  }
  mOpeningApps.clear();
  mClosingApps.clear();
  mLayoutNeeded=true;
  if (!moveInputMethodWindowsIfNeededLocked(true)) {
    assignLayersLocked();
  }
  performLayoutLockedInner();
  updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
  restart=true;
}
}
}
 while (restart);
final boolean someoneLosingFocus=mLosingFocus.size() != 0;
boolean obscured=false;
boolean blurring=false;
boolean dimming=false;
boolean covered=false;
boolean syswin=false;
boolean backgroundFillerShown=false;
for (i=N - 1; i >= 0; i--) {
WindowState w=(WindowState)mWindows.get(i);
boolean displayed=false;
final WindowManager.LayoutParams attrs=w.mAttrs;
final int attrFlags=attrs.flags;
if (w.mSurface != null) {
w.computeShownFrameLocked();
if (localLOGV) Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
boolean resize;
int width, height;
if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
  resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
  width=w.mRequestedWidth;
  height=w.mRequestedHeight;
  w.mLastRequestedWidth=width;
  w.mLastRequestedHeight=height;
  w.mLastShownFrame.set(w.mShownFrame);
  try {
    w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
  }
 catch (  RuntimeException e) {
    Log.w(TAG,""String_Node_Str"" + w,e);
    if (!recoveringMemory) {
      reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
    }
  }
}
 else {
  resize=!w.mLastShownFrame.equals(w.mShownFrame);
  width=w.mShownFrame.width();
  height=w.mShownFrame.height();
  w.mLastShownFrame.set(w.mShownFrame);
  if (resize) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
  }
}
if (resize) {
  if (width < 1)   width=1;
  if (height < 1)   height=1;
  if (w.mSurface != null) {
    try {
      w.mSurface.setSize(width,height);
      w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
    }
 catch (    RuntimeException e) {
      Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
}
if (!w.mAppFreezing) {
  w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
  w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
  if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
    w.mLastFrame.set(w.mFrame);
    w.mLastContentInsets.set(w.mContentInsets);
    w.mLastVisibleInsets.set(w.mVisibleInsets);
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mDrawPending=true;
      w.mCommitDrawPending=false;
      w.mReadyToShow=false;
      if (w.mAppToken != null) {
        w.mAppToken.allDrawn=false;
      }
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
    mResizingWindows.add(w);
  }
 else   if (w.mOrientationChanging) {
    if (!w.mDrawPending && !w.mCommitDrawPending) {
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
      w.mOrientationChanging=false;
    }
  }
}
if (w.mAttachedHidden) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (!w.isReadyForDisplay()) {
  if (!w.mLastHidden) {
    w.mLastHidden=true;
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (w.mSurface != null) {
      try {
        w.mSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.w(TAG,""String_Node_Str"" + w);
      }
    }
    mKeyWaiter.releasePendingPointerLocked(w.mSession);
  }
  if (w.mOrientationChanging) {
    w.mOrientationChanging=false;
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + w);
  }
}
 else if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
  displayed=true;
  w.mLastAlpha=w.mShownAlpha;
  w.mLastLayer=w.mAnimLayer;
  w.mLastDsDx=w.mDsDx;
  w.mLastDtDx=w.mDtDx;
  w.mLastDsDy=w.mDsDy;
  w.mLastDtDy=w.mDtDy;
  w.mLastHScale=w.mHScale;
  w.mLastVScale=w.mVScale;
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
  if (w.mSurface != null) {
    try {
      w.mSurface.setAlpha(w.mShownAlpha);
      w.mSurface.setLayer(w.mAnimLayer);
      w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + w,e);
      if (!recoveringMemory) {
        reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
      }
    }
  }
  if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
    if (DEBUG_VISIBILITY)     Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
    if (showSurfaceRobustlyLocked(w)) {
      w.mHasDrawn=true;
      w.mLastHidden=false;
    }
 else {
      w.mOrientationChanging=false;
    }
  }
  if (w.mSurface != null) {
    w.mToken.hasVisible=true;
  }
}
 else {
  displayed=true;
}
if (displayed) {
  if (!covered) {
    if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
      covered=true;
    }
  }
  if (w.mOrientationChanging) {
    if (w.mDrawPending || w.mCommitDrawPending) {
      orientationChangeComplete=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
 else {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Log.v(TAG,""String_Node_Str"" + w);
    }
  }
  w.mToken.hasVisible=true;
}
}
 else if (w.mOrientationChanging) {
if (DEBUG_ORIENTATION) Log.v(TAG,""String_Node_Str"" + w);
w.mOrientationChanging=false;
}
final boolean canBeSeen=w.isDisplayedLw();
if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
focusDisplayed=true;
}
final boolean obscuredChanged=w.mObscured != obscured;
if (!(w.mObscured=obscured)) {
if (w.mSurface != null) {
  if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
    holdScreen=w.mSession;
  }
  if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
    screenBrightness=w.mAttrs.screenBrightness;
  }
  if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
    syswin=true;
  }
}
boolean opaqueDrawn=w.isOpaqueDrawn();
if ((opaqueDrawn && w.isFullscreen(dw,dh)) || attrs.type == TYPE_WALLPAPER) {
  obscured=true;
}
 else if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
  if (SHOW_TRANSACTIONS)   Log.d(TAG,""String_Node_Str"");
  obscured=true;
  if (mBackgroundFillerSurface == null) {
    try {
      mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
    }
 catch (    Exception e) {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
  try {
    mBackgroundFillerSurface.setPosition(0,0);
    mBackgroundFillerSurface.setSize(dw,dh);
    mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
    mBackgroundFillerSurface.show();
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"");
  }
  backgroundFillerShown=true;
  mBackgroundFillerShown=true;
}
 else if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
  if (localLOGV)   Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
  if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
    if (!dimming) {
      dimming=true;
      if (mDimAnimator == null) {
        mDimAnimator=new DimAnimator(mFxSession);
      }
      mDimAnimator.show(dw,dh);
    }
    mDimAnimator.updateParameters(w,currentTime);
  }
  if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
    if (!blurring) {
      blurring=true;
      mBlurShown=true;
      if (mBlurSurface == null) {
        if (SHOW_TRANSACTIONS)         Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
        try {
          mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
        }
 catch (        Exception e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
      if (mBlurSurface != null) {
        mBlurSurface.setPosition(0,0);
        mBlurSurface.setSize(dw,dh);
        try {
          mBlurSurface.show();
        }
 catch (        RuntimeException e) {
          Log.w(TAG,""String_Node_Str"",e);
        }
      }
    }
    mBlurSurface.setLayer(w.mAnimLayer - 2);
  }
}
}
if (obscuredChanged && mWallpaperTarget == w) {
updateWallpaperVisibilityLocked();
}
}
if (backgroundFillerShown == false && mBackgroundFillerShown) {
mBackgroundFillerShown=false;
if (SHOW_TRANSACTIONS) Log.d(TAG,""String_Node_Str"");
try {
mBackgroundFillerSurface.hide();
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
}
if (mDimAnimator != null && mDimAnimator.mDimShown) {
animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
}
if (!blurring && mBlurShown) {
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
try {
mBlurSurface.hide();
}
 catch (IllegalArgumentException e) {
Log.w(TAG,""String_Node_Str"");
}
mBlurShown=false;
}
if (SHOW_TRANSACTIONS) Log.i(TAG,""String_Node_Str"");
}
 catch (RuntimeException e) {
Log.e(TAG,""String_Node_Str"",e);
}
Surface.closeTransaction();
if (DEBUG_ORIENTATION && mDisplayFrozen) Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
if (orientationChangeComplete) {
if (mWindowsFreezingScreen) {
mWindowsFreezingScreen=false;
mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
}
if (mAppsFreezingScreen == 0) {
stopFreezingDisplayLocked();
}
}
i=mResizingWindows.size();
if (i > 0) {
do {
i--;
WindowState win=mResizingWindows.get(i);
try {
win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
win.mContentInsetsChanged=false;
win.mVisibleInsetsChanged=false;
}
 catch (RemoteException e) {
win.mOrientationChanging=false;
}
}
 while (i > 0);
mResizingWindows.clear();
}
boolean wallpaperDestroyed=false;
i=mDestroySurface.size();
if (i > 0) {
do {
i--;
WindowState win=mDestroySurface.get(i);
win.mDestroying=false;
if (mInputMethodWindow == win) {
mInputMethodWindow=null;
}
if (win == mWallpaperTarget) {
wallpaperDestroyed=true;
}
win.destroySurfaceLocked();
}
 while (i > 0);
mDestroySurface.clear();
}
for (i=mExitingTokens.size() - 1; i >= 0; i--) {
WindowToken token=mExitingTokens.get(i);
if (!token.hasVisible) {
mExitingTokens.remove(i);
if (token.windowType == TYPE_WALLPAPER) {
mWallpaperTokens.remove(token);
}
}
}
for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
AppWindowToken token=mExitingAppTokens.get(i);
if (!token.hasVisible && !mClosingApps.contains(token)) {
mAppTokens.remove(token);
mExitingAppTokens.remove(i);
}
}
if (focusDisplayed) {
mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
}
if (wallpaperDestroyed) {
wallpaperDestroyed=adjustWallpaperWindowsLocked();
}
if (wallpaperDestroyed) {
requestAnimationLocked(0);
}
 else if (animating) {
requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
}
mQueue.setHoldScreenLocked(holdScreen != null);
if (screenBrightness < 0 || screenBrightness > 1.0f) {
mPowerManager.setScreenBrightnessOverride(-1);
}
 else {
mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
}
if (holdScreen != mHoldingScreenOn) {
mHoldingScreenOn=holdScreen;
Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
mH.sendMessage(m);
}
}"
23868,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}"
23869,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}"
23870,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}"
23871,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}"
23872,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}"
23873,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}"
23874,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}"
23875,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}"
23876,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}"
23877,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}"
23878,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}"
23879,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}"
23880,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}"
23881,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}"
23882,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}"
23883,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}"
23884,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user. IMPORTANT: as this is called from network thread, can't call native directly
 */
public boolean handleSslErrorRequest(SslError error){
  if (DebugFlags.LOAD_LISTENER) {
    Log.v(LOGTAG,""String_Node_Str"" + url() + ""String_Node_Str""+ error.getPrimaryError()+ ""String_Node_Str""+ error.getCertificate());
  }
  if (Network.getInstance(mContext).checkSslPrefTable(this,error)) {
    return true;
  }
  if (isSynchronous()) {
    mRequestHandle.handleSslErrorResponse(false);
    return true;
  }
  sendMessageInternal(obtainMessage(MSG_SSL_ERROR,error));
  if (!mCancelled) {
    mSslErrorRequestHandle=mRequestHandle;
  }
  return !mCancelled;
}"
23885,"/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0));
}","/** 
 * Cancel this request and all pending requests for the WebView that had the error.
 */
public void cancel(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,0,0,mLoaderQueue.poll()));
}"
23886,"/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(boolean proceed){
  LoadListener loader=mLoaderQueue.poll();
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=loader.sslError().getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}","/** 
 * Handles SSL error(s) on the way down from the user.
 */
synchronized void handleSslErrorResponse(LoadListener loader,SslError error,boolean proceed){
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Assert.assertNotNull(loader);
    Assert.assertNotNull(error);
  }
  if (DebugFlags.SSL_ERROR_HANDLER) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + proceed + ""String_Node_Str""+ loader.url());
  }
  if (!loader.cancelled()) {
    if (proceed) {
      int primary=error.getPrimaryError();
      String host=loader.host();
      if (DebugFlags.SSL_ERROR_HANDLER) {
        Assert.assertTrue(host != null && primary != 0);
      }
      boolean hasKey=mSslPrefTable.containsKey(host);
      if (!hasKey || primary > mSslPrefTable.getInt(host)) {
        mSslPrefTable.putInt(host,primary);
      }
    }
    loader.handleSslErrorResponse(proceed);
  }
}"
23887,"/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}","/** 
 * Restores this handler's state from a map.
 * @return True iff succeeds.
 */
synchronized boolean restoreState(Bundle inState){
  boolean success=(inState != null);
  if (success) {
    success=inState.containsKey(""String_Node_Str"");
    if (success) {
      mSslPrefTable=inState.getBundle(""String_Node_Str"");
    }
  }
  return success;
}"
23888,"/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0));
}","/** 
 * Proceed with the SSL certificate.
 */
public void proceed(){
  sendMessage(obtainMessage(HANDLE_RESPONSE,1,0,mLoaderQueue.poll()));
}"
23889,"/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}","/** 
 * Saves this handler's state into a map.
 * @return True iff succeeds.
 */
synchronized boolean saveState(Bundle outState){
  boolean success=(outState != null);
  if (success) {
    outState.putBundle(""String_Node_Str"",mSslPrefTable);
  }
  return success;
}"
23890,"/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    int primary=error.getPrimaryError();
    String host=loader.host();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertTrue(host != null && primary != 0);
    }
    if (mSslPrefTable.containsKey(host)) {
      if (primary <= mSslPrefTable.getInt(host)) {
        handleSslErrorResponse(true);
        return true;
      }
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}","/** 
 * Processes the next loader in the queue.
 * @return True iff should proceed to processing thefollowing loader in the queue
 */
private synchronized boolean processNextLoader(){
  LoadListener loader=mLoaderQueue.peek();
  if (loader != null) {
    if (loader.cancelled()) {
      mLoaderQueue.remove(loader);
      return true;
    }
    SslError error=loader.sslError();
    if (DebugFlags.SSL_ERROR_HANDLER) {
      Assert.assertNotNull(error);
    }
    if (checkSslPrefTable(loader,error)) {
      mLoaderQueue.remove(loader);
      return true;
    }
    CallbackProxy proxy=loader.getFrame().getCallbackProxy();
    proxy.onReceivedSslError(this,error);
  }
  return false;
}"
23891,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    handleSslErrorResponse(msg.arg1 == 1);
  fastProcessQueuedSslErrors();
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case HANDLE_RESPONSE:
    LoadListener loader=(LoadListener)msg.obj;
  handleSslErrorResponse(loader,loader.sslError(),msg.arg1 == 1);
fastProcessQueuedSslErrors();
break;
}
}"
23892,"/** 
 * This function checks if there is a plus sign (+) in the passed-in dialing number. If there is, it processes the plus sign based on the default telephone numbering plan of the system when the phone is activated and the current telephone numbering plan of the system that the phone is camped on. Currently, we only support the case that the default and current telephone numbering plans are North American Numbering Plan(NANP). The passed-in dialStr should only contain the valid format as described below, 1) the 1st character in the dialStr should be one of the really dialable characters listed below ISO-LATIN characters 0-9, *, # , + 2) the dialStr should already strip out the separator characters, every character in the dialStr should be one of the non separator characters listed below ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE Otherwise, this function returns the dial string passed in This API is for CDMA only
 * @hide TODO: pending API Council approval
 */
public static String cdmaCheckAndProcessPlusCode(String dialStr){
  if (!TextUtils.isEmpty(dialStr)) {
    if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
      return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr,getFormatTypeForLocale(Locale.getDefault()));
    }
  }
  return dialStr;
}","/** 
 * This function checks if there is a plus sign (+) in the passed-in dialing number. If there is, it processes the plus sign based on the default telephone numbering plan of the system when the phone is activated and the current telephone numbering plan of the system that the phone is camped on. Currently, we only support the case that the default and current telephone numbering plans are North American Numbering Plan(NANP). The passed-in dialStr should only contain the valid format as described below, 1) the 1st character in the dialStr should be one of the really dialable characters listed below ISO-LATIN characters 0-9, *, # , + 2) the dialStr should already strip out the separator characters, every character in the dialStr should be one of the non separator characters listed below ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE Otherwise, this function returns the dial string passed in
 * @param dialStr the original dial string
 * @return the converted dial string if the current/default countries belong to NANP,and if there is the ""+"" in the original dial string. Otherwise, the original dial string returns. This API is for CDMA only
 * @hide TODO: pending API Council approval
 */
public static String cdmaCheckAndProcessPlusCode(String dialStr){
  if (!TextUtils.isEmpty(dialStr)) {
    if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
      String currIso=SystemProperties.get(PROPERTY_OPERATOR_ISO_COUNTRY,""String_Node_Str"");
      String defaultIso=SystemProperties.get(PROPERTY_ICC_OPERATOR_ISO_COUNTRY,""String_Node_Str"");
      if (!TextUtils.isEmpty(currIso) && !TextUtils.isEmpty(defaultIso)) {
        return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr,getFormatTypeFromCountryCode(currIso),getFormatTypeFromCountryCode(defaultIso));
      }
    }
  }
  return dialStr;
}"
23893,"/** 
 * This function handles the plus code conversion within NANP CDMA network If the number format is 1)+NANP or +1NANP,remove +, 2)+non-NANP Numbers,replace + with the current IDP
 */
private static String processPlusCodeWithinNanp(String networkDialStr){
  String retStr=networkDialStr;
  if (DBG)   log(""String_Node_Str"" + networkDialStr);
  if (networkDialStr != null & networkDialStr.charAt(0) == PLUS_SIGN_CHAR && networkDialStr.length() > 1) {
    String newStr=networkDialStr.substring(1);
    if (isNanp(newStr) || isOneNanp(newStr)) {
      retStr=newStr;
    }
 else {
      String idpStr=getDefaultIdp();
      retStr=networkDialStr.replaceFirst(""String_Node_Str"",idpStr);
    }
  }
  if (DBG)   log(""String_Node_Str"" + retStr);
  return retStr;
}","/** 
 * This function handles the plus code conversion within NANP CDMA network If the number format is 1)+1NANP,remove +, 2)other than +1NANP, any + numbers,replace + with the current IDP
 */
private static String processPlusCodeWithinNanp(String networkDialStr){
  String retStr=networkDialStr;
  if (DBG)   log(""String_Node_Str"" + networkDialStr);
  if (networkDialStr != null & networkDialStr.charAt(0) == PLUS_SIGN_CHAR && networkDialStr.length() > 1) {
    String newStr=networkDialStr.substring(1);
    if (isOneNanp(newStr)) {
      retStr=newStr;
    }
 else {
      String idpStr=getDefaultIdp();
      retStr=networkDialStr.replaceFirst(""String_Node_Str"",idpStr);
    }
  }
  if (DBG)   log(""String_Node_Str"" + retStr);
  return retStr;
}"
23894,"/** 
 * Returns the phone number formatting type for the given locale.
 * @param locale The locale of interest, usually {@link Locale#getDefault()}
 * @return the formatting type for the given locale, or FORMAT_UNKNOWN if the formattingrules are not known for the given locale
 */
public static int getFormatTypeForLocale(Locale locale){
  String country=locale.getCountry();
  int length=NANP_COUNTRIES.length;
  for (int i=0; i < length; i++) {
    if (NANP_COUNTRIES[i].equals(country)) {
      return FORMAT_NANP;
    }
  }
  if (locale.equals(Locale.JAPAN)) {
    return FORMAT_JAPAN;
  }
  return FORMAT_UNKNOWN;
}","/** 
 * Returns the phone number formatting type for the given locale.
 * @param locale The locale of interest, usually {@link Locale#getDefault()}
 * @return the formatting type for the given locale, or FORMAT_UNKNOWN if the formattingrules are not known for the given locale
 */
public static int getFormatTypeForLocale(Locale locale){
  String country=locale.getCountry();
  return getFormatTypeFromCountryCode(country);
}"
23895,"/** 
 * This function should be called from checkAndProcessPlusCode only And it is used for test purpose also. It checks the dial string by looping through the network portion, post dial portion 1, post dial porting 2, etc. If there is any plus sign, then process the plus sign. Currently, this function supports the plus sign conversion within NANP only. Specifically, it handles the plus sign in the following ways: 1)+NANP or +1NANP,remove +, e.g. +8475797000 is converted to 8475797000, +18475797000 is converted to 18475797000, 2)+non-NANP Numbers,replace + with the current NANP IDP, e.g, +11875767800 is converted to 01111875767800 3)+NANP in post dial string(s), e.g. 8475797000;+8475231753 is converted to 8475797000;8475231753 This function returns the original dial string if locale/numbering plan aren't supported.
 * @hide
 */
public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr,int numFormat){
  String retStr=dialStr;
  if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
    String postDialStr=null;
    String tempDialStr=dialStr;
    retStr=null;
    if (DBG)     log(""String_Node_Str"" + dialStr);
    do {
      String networkDialStr;
      if (numFormat != FORMAT_NANP) {
        Log.e(""String_Node_Str"",dialStr);
        return dialStr;
      }
 else {
        networkDialStr=extractNetworkPortion(tempDialStr);
        networkDialStr=processPlusCodeWithinNanp(networkDialStr);
      }
      if (!TextUtils.isEmpty(networkDialStr)) {
        if (retStr == null) {
          retStr=networkDialStr;
        }
 else {
          retStr=retStr.concat(networkDialStr);
        }
      }
 else {
        Log.e(""String_Node_Str"",networkDialStr);
        return dialStr;
      }
      postDialStr=extractPostDialPortion(tempDialStr);
      if (!TextUtils.isEmpty(postDialStr)) {
        int dialableIndex=findDialableIndexFromPostDialStr(postDialStr);
        if (dialableIndex >= 1) {
          retStr=appendPwCharBackToOrigDialStr(dialableIndex,retStr,postDialStr);
          tempDialStr=postDialStr.substring(dialableIndex);
        }
 else {
          if (dialableIndex < 0) {
            postDialStr=""String_Node_Str"";
          }
          Log.e(""String_Node_Str"",postDialStr);
        }
      }
      if (DBG)       log(""String_Node_Str"" + postDialStr);
    }
 while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
  }
  return retStr;
}","/** 
 * This function should be called from checkAndProcessPlusCode only And it is used for test purpose also. It checks the dial string by looping through the network portion, post dial portion 1, post dial porting 2, etc. If there is any plus sign, then process the plus sign. Currently, this function supports the plus sign conversion within NANP only. Specifically, it handles the plus sign in the following ways: 1)+1NANP,remove +, e.g. +18475797000 is converted to 18475797000, 2)+NANP or +non-NANP Numbers,replace + with the current NANP IDP, e.g, +8475797000 is converted to 0118475797000, +11875767800 is converted to 01111875767800 3)+1NANP in post dial string(s), e.g. 8475797000;+18475231753 is converted to 8475797000;18475231753
 * @param dialStr the original dial string
 * @param currFormat the numbering system of the current country that the phone is camped on
 * @param defaultFormat the numbering system of the country that the phone is activated on
 * @return the converted dial string if the current/default countries belong to NANP,and if there is the ""+"" in the original dial string. Otherwise, the original dial string returns.
 * @hide
 */
public static String cdmaCheckAndProcessPlusCodeByNumberFormat(String dialStr,int currFormat,int defaultFormt){
  String retStr=dialStr;
  if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
    if ((currFormat == defaultFormt) && (currFormat == FORMAT_NANP)) {
      String postDialStr=null;
      String tempDialStr=dialStr;
      retStr=null;
      if (DBG)       log(""String_Node_Str"" + dialStr);
      do {
        String networkDialStr;
        networkDialStr=extractNetworkPortion(tempDialStr);
        networkDialStr=processPlusCodeWithinNanp(networkDialStr);
        if (!TextUtils.isEmpty(networkDialStr)) {
          if (retStr == null) {
            retStr=networkDialStr;
          }
 else {
            retStr=retStr.concat(networkDialStr);
          }
        }
 else {
          Log.e(""String_Node_Str"",networkDialStr);
          return dialStr;
        }
        postDialStr=extractPostDialPortion(tempDialStr);
        if (!TextUtils.isEmpty(postDialStr)) {
          int dialableIndex=findDialableIndexFromPostDialStr(postDialStr);
          if (dialableIndex >= 1) {
            retStr=appendPwCharBackToOrigDialStr(dialableIndex,retStr,postDialStr);
            tempDialStr=postDialStr.substring(dialableIndex);
          }
 else {
            if (dialableIndex < 0) {
              postDialStr=""String_Node_Str"";
            }
            Log.e(""String_Node_Str"",postDialStr);
          }
        }
        if (DBG)         log(""String_Node_Str"" + postDialStr);
      }
 while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
    }
 else {
      Log.e(""String_Node_Str"",dialStr);
    }
  }
  return retStr;
}"
23896,"@SmallTest public void testCheckAndProcessPlusCodeByNumberFormat(){
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN));
}","@SmallTest public void testCheckAndProcessPlusCodeByNumberFormat(){
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_NANP));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_NANP,PhoneNumberUtils.FORMAT_UNKNOWN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_JAPAN,PhoneNumberUtils.FORMAT_JAPAN));
  assertEquals(""String_Node_Str"",PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat(""String_Node_Str"",PhoneNumberUtils.FORMAT_UNKNOWN,PhoneNumberUtils.FORMAT_UNKNOWN));
}"
23897,"@Override public EGLConfig chooseConfig(EGL10 egl,EGLDisplay display,EGLConfig[] configs){
  EGLConfig closestConfig=null;
  int closestDistance=1000;
  for (  EGLConfig config : configs) {
    int r=findConfigAttrib(egl,display,config,EGL10.EGL_RED_SIZE,0);
    int g=findConfigAttrib(egl,display,config,EGL10.EGL_GREEN_SIZE,0);
    int b=findConfigAttrib(egl,display,config,EGL10.EGL_BLUE_SIZE,0);
    int a=findConfigAttrib(egl,display,config,EGL10.EGL_ALPHA_SIZE,0);
    int d=findConfigAttrib(egl,display,config,EGL10.EGL_DEPTH_SIZE,0);
    int s=findConfigAttrib(egl,display,config,EGL10.EGL_STENCIL_SIZE,0);
    int distance=Math.abs(r - mRedSize) + Math.abs(g - mGreenSize) + Math.abs(b - mBlueSize)+ Math.abs(a - mAlphaSize)+ Math.abs(d - mDepthSize)+ Math.abs(s - mStencilSize);
    if (distance < closestDistance) {
      closestDistance=distance;
      closestConfig=config;
    }
  }
  return closestConfig;
}","@Override public EGLConfig chooseConfig(EGL10 egl,EGLDisplay display,EGLConfig[] configs){
  EGLConfig closestConfig=null;
  int closestDistance=1000;
  for (  EGLConfig config : configs) {
    int d=findConfigAttrib(egl,display,config,EGL10.EGL_DEPTH_SIZE,0);
    int s=findConfigAttrib(egl,display,config,EGL10.EGL_STENCIL_SIZE,0);
    if (d >= mDepthSize && s >= mStencilSize) {
      int r=findConfigAttrib(egl,display,config,EGL10.EGL_RED_SIZE,0);
      int g=findConfigAttrib(egl,display,config,EGL10.EGL_GREEN_SIZE,0);
      int b=findConfigAttrib(egl,display,config,EGL10.EGL_BLUE_SIZE,0);
      int a=findConfigAttrib(egl,display,config,EGL10.EGL_ALPHA_SIZE,0);
      int distance=Math.abs(r - mRedSize) + Math.abs(g - mGreenSize) + Math.abs(b - mBlueSize)+ Math.abs(a - mAlphaSize);
      if (distance < closestDistance) {
        closestDistance=distance;
        closestConfig=config;
      }
    }
  }
  return closestConfig;
}"
23898,"/** 
 * Ensure that a network route exists to deliver traffic to the specified host via the mobile data network.
 * @param hostAddress the IP address of the host to which the route is desired,in network byte order.
 * @return {@code true} on success, {@code false} on failure
 */
@Override public boolean requestRouteToHost(int hostAddress){
  if (mInterfaceName != null && hostAddress != -1) {
    if (DBG) {
      Log.d(TAG,""String_Node_Str"" + Integer.toHexString(hostAddress));
    }
    return NetworkUtils.addHostRoute(mInterfaceName,hostAddress) == 0;
  }
 else {
    return false;
  }
}","/** 
 * Ensure that a network route exists to deliver traffic to the specified host via the mobile data network.
 * @param hostAddress the IP address of the host to which the route is desired,in network byte order.
 * @return {@code true} on success, {@code false} on failure
 */
@Override public boolean requestRouteToHost(int hostAddress){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + Integer.toHexString(hostAddress) + ""String_Node_Str""+ mApnType+ ""String_Node_Str""+ mInterfaceName+ ""String_Node_Str"");
  }
  if (mInterfaceName != null && hostAddress != -1) {
    return NetworkUtils.addHostRoute(mInterfaceName,hostAddress) == 0;
  }
 else {
    return false;
  }
}"
23899,"public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + intent.getAction()+ ""String_Node_Str""+ state+ ""String_Node_Str""+ unavailable+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason));
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (mInterfaceName == null && state == Phone.DataState.CONNECTED) {
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
 else           if (state == Phone.DataState.DISCONNECTED) {
            mInterfaceName=null;
          }
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return;
      }
      mNetworkInfo.setIsAvailable(!unavailable);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    mInterfaceName=null;
  mDefaultGatewayAddr=0;
break;
case CONNECTING:
setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}","public void onReceive(Context context,Intent intent){
synchronized (this) {
    if (intent.getAction().equals(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED)) {
      Phone.DataState state=getMobileDataState(intent);
      String reason=intent.getStringExtra(Phone.STATE_CHANGE_REASON_KEY);
      String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
      String apnTypeList=intent.getStringExtra(Phone.DATA_APN_TYPES_KEY);
      boolean unavailable=intent.getBooleanExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
      if (DBG)       Log.d(TAG,mApnType + ""String_Node_Str"" + intent.getAction()+ ""String_Node_Str""+ state+ ""String_Node_Str""+ mMobileDataState+ ""String_Node_Str""+ unavailable+ ""String_Node_Str""+ (reason == null ? ""String_Node_Str"" : reason));
      if (isApnTypeIncluded(apnTypeList)) {
        if (mEnabled == false) {
          if (state == Phone.DataState.CONNECTED) {
            if (DBG)             Log.d(TAG,""String_Node_Str"" + mInterfaceName + ""String_Node_Str""+ intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY)+ ""String_Node_Str""+ mApnType);
            mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
          }
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return;
        }
      }
 else {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return;
      }
      mNetworkInfo.setIsAvailable(!unavailable);
      if (mMobileDataState != state) {
        mMobileDataState=state;
switch (state) {
case DISCONNECTED:
          if (isTeardownRequested()) {
            mEnabled=false;
            setTeardownRequested(false);
          }
        setDetailedState(DetailedState.DISCONNECTED,reason,apnName);
      if (mInterfaceName != null) {
        NetworkUtils.resetConnections(mInterfaceName);
      }
    if (DBG)     Log.d(TAG,""String_Node_Str"" + mApnType + ""String_Node_Str"");
  mInterfaceName=null;
mDefaultGatewayAddr=0;
break;
case CONNECTING:
setDetailedState(DetailedState.CONNECTING,reason,apnName);
break;
case SUSPENDED:
setDetailedState(DetailedState.SUSPENDED,reason,apnName);
break;
case CONNECTED:
mInterfaceName=intent.getStringExtra(Phone.DATA_IFACE_NAME_KEY);
if (mInterfaceName == null) {
Log.d(TAG,""String_Node_Str"");
}
setDetailedState(DetailedState.CONNECTED,reason,apnName);
break;
}
}
}
 else if (intent.getAction().equals(TelephonyIntents.ACTION_DATA_CONNECTION_FAILED)) {
mEnabled=false;
String reason=intent.getStringExtra(Phone.FAILURE_REASON_KEY);
String apnName=intent.getStringExtra(Phone.DATA_APN_KEY);
if (DBG) Log.d(TAG,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ reason == null ? ""String_Node_Str"" : ""String_Node_Str"" + reason + ""String_Node_Str"");
setDetailedState(DetailedState.FAILED,reason,apnName);
}
TelephonyManager tm=TelephonyManager.getDefault();
setRoamingStatus(tm.isNetworkRoaming());
setSubtype(tm.getNetworkType(),tm.getNetworkTypeName());
}
}"
23900,"/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}","/** 
 * Re-enable mobile data connectivity after a   {@link #teardown()}.
 */
public boolean reconnect(){
  setTeardownRequested(false);
switch (setEnableApn(mApnType,true)) {
case Phone.APN_ALREADY_ACTIVE:
    mEnabled=true;
  mMobileDataState=Phone.DataState.CONNECTING;
Intent intent=new Intent(TelephonyIntents.ACTION_ANY_DATA_CONNECTION_STATE_CHANGED);
intent.putExtra(Phone.STATE_KEY,Phone.DataState.CONNECTED.toString());
intent.putExtra(Phone.STATE_CHANGE_REASON_KEY,Phone.REASON_APN_CHANGED);
intent.putExtra(Phone.DATA_APN_TYPES_KEY,mApnType);
intent.putExtra(Phone.DATA_IFACE_NAME_KEY,mInterfaceName);
intent.putExtra(Phone.NETWORK_UNAVAILABLE_KEY,false);
if (mStateReceiver != null) mStateReceiver.onReceive(mContext,intent);
break;
case Phone.APN_REQUEST_STARTED:
mEnabled=true;
break;
case Phone.APN_REQUEST_FAILED:
if (mPhoneService == null && mApnType == Phone.APN_TYPE_DEFAULT) {
return false;
}
case Phone.APN_TYPE_NOT_AVAILABLE:
mEnabled=false;
break;
default :
Log.e(TAG,""String_Node_Str"");
mEnabled=false;
break;
}
return mEnabled;
}"
23901,"private int getNumConnectedNetworks(){
  int numConnectedNets=0;
  for (  NetworkStateTracker nt : mNetTrackers) {
    if (nt.getNetworkInfo().isConnected() && !nt.isTeardownRequested()) {
      ++numConnectedNets;
    }
  }
  return numConnectedNets;
}","private int getNumConnectedNetworks(){
  int numConnectedNets=0;
  for (  NetworkStateTracker nt : mNetTrackers) {
    if (nt.getNetworkInfo().isConnected() && !nt.isTeardownRequested()) {
      ++numConnectedNets;
    }
  }
  if (DBG)   Log.d(TAG,""String_Node_Str"" + numConnectedNets);
  return numConnectedNets;
}"
23902,"/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName());
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    if (DBG)     Log.d(TAG,""String_Node_Str"");
    if (mActiveDefaultNetwork == prevNetType) {
      mActiveDefaultNetwork=-1;
    }
    int newType=-1;
    int newPriority=-1;
    for (int checkType=0; checkType <= ConnectivityManager.MAX_NETWORK_TYPE; checkType++) {
      if (checkType == prevNetType) {
        continue;
      }
      if (mNetAttributes[checkType].isDefault()) {
        if (checkType == mNetworkPreference) {
          newType=checkType;
          break;
        }
        if (mRadioAttributes[mNetAttributes[checkType].mRadio].mPriority > newPriority) {
          newType=checkType;
          newPriority=mRadioAttributes[mNetAttributes[newType].mRadio].mPriority;
        }
      }
    }
    if (newType != -1) {
      newNet=mNetTrackers[newType];
      if (newNet.isAvailable()) {
        NetworkInfo switchTo=newNet.getNetworkInfo();
        switchTo.setFailover(true);
        if (!switchTo.isConnectedOrConnecting()) {
          newNet.reconnect();
        }
        if (DBG) {
          if (switchTo.isConnected()) {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
 else {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
        }
        intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
      }
 else {
        newNet.reconnect();
      }
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange();
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName() + (newNet == null || !newNet.isAvailable() ? ""String_Node_Str"" : ""String_Node_Str"" + newNet.getNetworkInfo().getTypeName()));
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected())   sendConnectedBroadcast(newNet.getNetworkInfo());
}","/** 
 * Handle a   {@code DISCONNECTED} event. If this pertains to the non-activenetwork, we ignore it. If it is for the active network, we send out a broadcast. But first, we check whether it might be possible to connect to a different network.
 * @param info the {@code NetworkInfo} for the network
 */
private void handleDisconnect(NetworkInfo info){
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName());
  int prevNetType=info.getType();
  mNetTrackers[prevNetType].setTeardownRequested(false);
  if (!mNetAttributes[prevNetType].isDefault()) {
    List pids=mNetRequestersPids[prevNetType];
    for (int i=0; i < pids.size(); i++) {
      Integer pid=(Integer)pids.get(i);
      reassessPidDns(pid.intValue(),false);
    }
  }
  Intent intent=new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
  intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO,info);
  if (info.isFailover()) {
    intent.putExtra(ConnectivityManager.EXTRA_IS_FAILOVER,true);
    info.setFailover(false);
  }
  if (info.getReason() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_REASON,info.getReason());
  }
  if (info.getExtraInfo() != null) {
    intent.putExtra(ConnectivityManager.EXTRA_EXTRA_INFO,info.getExtraInfo());
  }
  NetworkStateTracker newNet=null;
  if (mNetAttributes[prevNetType].isDefault()) {
    if (DBG)     Log.d(TAG,""String_Node_Str"");
    if (mActiveDefaultNetwork == prevNetType) {
      mActiveDefaultNetwork=-1;
    }
    int newType=-1;
    int newPriority=-1;
    for (int checkType=0; checkType <= ConnectivityManager.MAX_NETWORK_TYPE; checkType++) {
      if (checkType == prevNetType) {
        continue;
      }
      if (mNetAttributes[checkType].isDefault()) {
        if (checkType == mNetworkPreference) {
          newType=checkType;
          break;
        }
        if (mRadioAttributes[mNetAttributes[checkType].mRadio].mPriority > newPriority) {
          newType=checkType;
          newPriority=mRadioAttributes[mNetAttributes[newType].mRadio].mPriority;
        }
      }
    }
    if (newType != -1) {
      newNet=mNetTrackers[newType];
      if (newNet.isAvailable()) {
        NetworkInfo switchTo=newNet.getNetworkInfo();
        switchTo.setFailover(true);
        if (!switchTo.isConnectedOrConnecting() || newNet.isTeardownRequested()) {
          newNet.reconnect();
        }
        if (DBG) {
          if (switchTo.isConnected()) {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
 else {
            Log.v(TAG,""String_Node_Str"" + switchTo.getTypeName());
          }
        }
        intent.putExtra(ConnectivityManager.EXTRA_OTHER_NETWORK_INFO,switchTo);
      }
 else {
        newNet.reconnect();
      }
    }
 else {
      intent.putExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,true);
    }
  }
  handleConnectivityChange();
  if (DBG)   Log.v(TAG,""String_Node_Str"" + info.getTypeName() + (newNet == null || !newNet.isAvailable() ? ""String_Node_Str"" : ""String_Node_Str"" + newNet.getNetworkInfo().getTypeName()));
  sendStickyBroadcast(intent);
  if (newNet != null && newNet.getNetworkInfo().isConnected())   sendConnectedBroadcast(newNet.getNetworkInfo());
}"
23903,"public int startUsingNetworkFeature(int networkType,String feature,IBinder binder){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + networkType + ""String_Node_Str""+ feature);
  }
  enforceChangePermission();
  if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
    return Phone.APN_REQUEST_FAILED;
  }
synchronized (mFeatureUsers) {
    mFeatureUsers.add(new FeatureUser(networkType,feature,binder));
  }
  int usedNetworkType=networkType;
  if (networkType == ConnectivityManager.TYPE_MOBILE) {
    if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_MMS)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_MMS;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_SUPL)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_SUPL;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_DUN)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_DUN;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_HIPRI)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_HIPRI;
    }
  }
  NetworkStateTracker network=mNetTrackers[usedNetworkType];
  if (network != null) {
    if (usedNetworkType != networkType) {
      Integer currentPid=new Integer(getCallingPid());
      NetworkStateTracker radio=mNetTrackers[networkType];
      NetworkInfo ni=network.getNetworkInfo();
      if (ni.isAvailable() == false) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_TYPE_NOT_AVAILABLE;
      }
      if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
        mNetRequestersPids[usedNetworkType].add(currentPid);
      }
      if (ni.isConnectedOrConnecting() == true) {
        if (ni.isConnected() == true) {
          handleDnsConfigurationChange();
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return Phone.APN_ALREADY_ACTIVE;
        }
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_REQUEST_STARTED;
      }
      if (mHandler.hasMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio) || radio.getNetworkInfo().isConnectedOrConnecting()) {
        mHandler.removeMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio);
        mHandler.sendMessageDelayed(mHandler.obtainMessage(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio),getRestoreDefaultNetworkDelay());
      }
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      network.reconnect();
      return Phone.APN_REQUEST_STARTED;
    }
 else {
      return network.startUsingNetworkFeature(feature,getCallingPid(),getCallingUid());
    }
  }
  return Phone.APN_TYPE_NOT_AVAILABLE;
}","public int startUsingNetworkFeature(int networkType,String feature,IBinder binder){
  if (DBG) {
    Log.d(TAG,""String_Node_Str"" + networkType + ""String_Node_Str""+ feature);
  }
  enforceChangePermission();
  if (!ConnectivityManager.isNetworkTypeValid(networkType)) {
    return Phone.APN_REQUEST_FAILED;
  }
synchronized (mFeatureUsers) {
    mFeatureUsers.add(new FeatureUser(networkType,feature,binder));
  }
  int usedNetworkType=networkType;
  if (networkType == ConnectivityManager.TYPE_MOBILE) {
    if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_MMS)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_MMS;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_SUPL)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_SUPL;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_DUN)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_DUN;
    }
 else     if (TextUtils.equals(feature,Phone.FEATURE_ENABLE_HIPRI)) {
      usedNetworkType=ConnectivityManager.TYPE_MOBILE_HIPRI;
    }
  }
  NetworkStateTracker network=mNetTrackers[usedNetworkType];
  if (network != null) {
    if (usedNetworkType != networkType) {
      Integer currentPid=new Integer(getCallingPid());
      NetworkStateTracker radio=mNetTrackers[networkType];
      NetworkInfo ni=network.getNetworkInfo();
      if (ni.isAvailable() == false) {
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_TYPE_NOT_AVAILABLE;
      }
      if (!mNetRequestersPids[usedNetworkType].contains(currentPid)) {
        mNetRequestersPids[usedNetworkType].add(currentPid);
      }
      if ((ni.isConnectedOrConnecting() == true) && !network.isTeardownRequested()) {
        if (ni.isConnected() == true) {
          handleDnsConfigurationChange();
          if (DBG)           Log.d(TAG,""String_Node_Str"");
          return Phone.APN_ALREADY_ACTIVE;
        }
        if (DBG)         Log.d(TAG,""String_Node_Str"");
        return Phone.APN_REQUEST_STARTED;
      }
      if (mHandler.hasMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio) || radio.getNetworkInfo().isConnectedOrConnecting()) {
        mHandler.removeMessages(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio);
        mHandler.sendMessageDelayed(mHandler.obtainMessage(NetworkStateTracker.EVENT_RESTORE_DEFAULT_NETWORK,radio),getRestoreDefaultNetworkDelay());
      }
      if (DBG)       Log.d(TAG,""String_Node_Str"");
      network.reconnect();
      return Phone.APN_REQUEST_STARTED;
    }
 else {
      return network.startUsingNetworkFeature(feature,getCallingPid(),getCallingUid());
    }
  }
  return Phone.APN_TYPE_NOT_AVAILABLE;
}"
23904,"protected synchronized void setEnabled(int id,boolean enable){
  if (DBG)   Log.d(LOG_TAG,""String_Node_Str"" + id + ""String_Node_Str""+ enable+ ')');
  if (dataEnabled[id] != enable) {
    dataEnabled[id]=enable;
    if (enable) {
      enabledCount++;
    }
 else {
      enabledCount--;
    }
    if (enabledCount == 0) {
      setPrivateDataEnabled(false);
    }
 else     if (enabledCount == 1) {
      setPrivateDataEnabled(true);
    }
  }
}","protected synchronized void setEnabled(int id,boolean enable){
  if (DBG)   Log.d(LOG_TAG,""String_Node_Str"" + id + ""String_Node_Str""+ enable+ ')');
  if (dataEnabled[id] != enable) {
    dataEnabled[id]=enable;
    if (enable) {
      enabledCount++;
      if (enabledCount == 1) {
        setPrivateDataEnabled(true);
      }
    }
 else {
      enabledCount--;
      if (enabledCount == 0) {
        setPrivateDataEnabled(false);
      }
    }
  }
}"
23905,"private boolean onModifiedTouchEvent(MotionEvent me){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  int action=me.getAction();
  long eventTime=me.getEventTime();
  int keyIndex=getKeyIndices(touchX,touchY,null);
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
repeatKey();
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
if (keyIndex != mRepeatKeyIndex) {
mHandler.removeMessages(MSG_REPEAT);
mRepeatKeyIndex=NOT_A_KEY;
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_UP:
mHandler.removeMessages(MSG_SHOW_PREVIEW);
mHandler.removeMessages(MSG_REPEAT);
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}","private boolean onModifiedTouchEvent(MotionEvent me){
  int touchX=(int)me.getX() - mPaddingLeft;
  int touchY=(int)me.getY() + mVerticalCorrection - mPaddingTop;
  int action=me.getAction();
  long eventTime=me.getEventTime();
  int keyIndex=getKeyIndices(touchX,touchY,null);
  if (mGestureDetector.onTouchEvent(me)) {
    showPreview(NOT_A_KEY);
    mHandler.removeMessages(MSG_REPEAT);
    mHandler.removeMessages(MSG_LONGPRESS);
    return true;
  }
  if (mMiniKeyboardOnScreen) {
    return true;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mAbortKey=false;
  mStartX=touchX;
mStartY=touchY;
mLastCodeX=touchX;
mLastCodeY=touchY;
mLastKeyTime=0;
mCurrentKeyTime=0;
mLastKey=NOT_A_KEY;
mCurrentKey=keyIndex;
mDownTime=me.getEventTime();
mLastMoveTime=mDownTime;
checkMultiTap(eventTime,keyIndex);
mKeyboardActionListener.onPress(keyIndex != NOT_A_KEY ? mKeys[keyIndex].codes[0] : 0);
if (mCurrentKey >= 0 && mKeys[mCurrentKey].repeatable) {
mRepeatKeyIndex=mCurrentKey;
repeatKey();
Message msg=mHandler.obtainMessage(MSG_REPEAT);
mHandler.sendMessageDelayed(msg,REPEAT_START_DELAY);
}
if (mCurrentKey != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
showPreview(keyIndex);
break;
case MotionEvent.ACTION_MOVE:
boolean continueLongPress=false;
if (keyIndex != NOT_A_KEY) {
if (mCurrentKey == NOT_A_KEY) {
mCurrentKey=keyIndex;
mCurrentKeyTime=eventTime - mDownTime;
}
 else {
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
continueLongPress=true;
}
 else if (mRepeatKeyIndex == NOT_A_KEY) {
resetMultiTap();
mLastKey=mCurrentKey;
mLastCodeX=mLastX;
mLastCodeY=mLastY;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
}
}
if (!continueLongPress) {
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex != NOT_A_KEY) {
Message msg=mHandler.obtainMessage(MSG_LONGPRESS,me);
mHandler.sendMessageDelayed(msg,LONGPRESS_TIMEOUT);
}
}
showPreview(mCurrentKey);
break;
case MotionEvent.ACTION_UP:
mHandler.removeMessages(MSG_SHOW_PREVIEW);
mHandler.removeMessages(MSG_REPEAT);
mHandler.removeMessages(MSG_LONGPRESS);
if (keyIndex == mCurrentKey) {
mCurrentKeyTime+=eventTime - mLastMoveTime;
}
 else {
resetMultiTap();
mLastKey=mCurrentKey;
mLastKeyTime=mCurrentKeyTime + eventTime - mLastMoveTime;
mCurrentKey=keyIndex;
mCurrentKeyTime=0;
}
if (mCurrentKeyTime < mLastKeyTime && mLastKey != NOT_A_KEY) {
mCurrentKey=mLastKey;
touchX=mLastCodeX;
touchY=mLastCodeY;
}
showPreview(NOT_A_KEY);
Arrays.fill(mKeyIndices,NOT_A_KEY);
if (mRepeatKeyIndex == NOT_A_KEY && !mMiniKeyboardOnScreen && !mAbortKey) {
detectAndSendKey(touchX,touchY,eventTime);
}
invalidateKey(keyIndex);
mRepeatKeyIndex=NOT_A_KEY;
break;
}
mLastX=touchX;
mLastY=touchY;
return true;
}"
23906,"@Override public boolean onTouchEvent(MotionEvent me){
  int pointerCount=me.getPointerCount();
  boolean result=false;
  if (pointerCount != mOldPointerCount) {
    long now=me.getEventTime();
    if (pointerCount == 1) {
      MotionEvent down=MotionEvent.obtain(now,now,MotionEvent.ACTION_DOWN,me.getX(),me.getY(),me.getMetaState());
      result=onModifiedTouchEvent(down);
      down.recycle();
    }
 else {
      MotionEvent up=MotionEvent.obtain(now,now,MotionEvent.ACTION_UP,mOldPointerX,mOldPointerY,me.getMetaState());
      result=onModifiedTouchEvent(up);
      up.recycle();
    }
  }
 else {
    if (pointerCount == 1) {
      mOldPointerX=me.getX();
      mOldPointerY=me.getY();
      result=onModifiedTouchEvent(me);
    }
 else {
      result=true;
    }
  }
  mOldPointerCount=pointerCount;
  return result;
}","@Override public boolean onTouchEvent(MotionEvent me){
  int pointerCount=me.getPointerCount();
  boolean result=false;
  if (pointerCount != mOldPointerCount) {
    long now=me.getEventTime();
    if (pointerCount == 1) {
      MotionEvent down=MotionEvent.obtain(now,now,MotionEvent.ACTION_DOWN,me.getX(),me.getY(),me.getMetaState());
      result=onModifiedTouchEvent(down);
      down.recycle();
      if (me.getAction() == MotionEvent.ACTION_UP) {
        result=onModifiedTouchEvent(me);
      }
    }
 else {
      MotionEvent up=MotionEvent.obtain(now,now,MotionEvent.ACTION_UP,mOldPointerX,mOldPointerY,me.getMetaState());
      result=onModifiedTouchEvent(up);
      up.recycle();
    }
  }
 else {
    if (pointerCount == 1) {
      mOldPointerX=me.getX();
      mOldPointerY=me.getY();
      result=onModifiedTouchEvent(me);
    }
 else {
      result=true;
    }
  }
  mOldPointerCount=pointerCount;
  return result;
}"
23907,"public void run(){
  long sent, received;
  long preTxPkts=-1, preRxPkts=-1;
  Activity newActivity;
  preTxPkts=txPkts;
  preRxPkts=rxPkts;
  if (netstat != null) {
    try {
      txPkts=netstat.getMobileTxPackets();
      rxPkts=netstat.getMobileRxPackets();
    }
 catch (    RemoteException e) {
      txPkts=0;
      rxPkts=0;
    }
    if (netStatPollEnabled && (preTxPkts > 0 || preRxPkts > 0)) {
      sent=txPkts - preTxPkts;
      received=rxPkts - preRxPkts;
      if (sent > 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAINANDOUT;
      }
 else       if (sent > 0 && received == 0) {
        if (phone.getState() == Phone.State.IDLE) {
          sentSinceLastRecv+=sent;
        }
 else {
          sentSinceLastRecv=0;
        }
        newActivity=Activity.DATAOUT;
      }
 else       if (sent == 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAIN;
      }
 else       if (sent == 0 && received == 0) {
        newActivity=Activity.NONE;
      }
 else {
        sentSinceLastRecv=0;
        newActivity=Activity.NONE;
      }
      if (activity != newActivity) {
        activity=newActivity;
        phone.notifyDataActivity();
      }
    }
    if (sentSinceLastRecv >= NUMBER_SENT_PACKETS_OF_HANG) {
      if (mNoRecvPollCount == 0) {
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET_COUNTDOWN_TRIGGERED,sentSinceLastRecv);
      }
      if (mNoRecvPollCount < NO_RECV_POLL_LIMIT) {
        mNoRecvPollCount++;
        netStatPollPeriod=POLL_NETSTAT_SLOW_MILLIS;
      }
 else {
        if (DBG)         log(""String_Node_Str"" + String.valueOf(sentSinceLastRecv) + ""String_Node_Str"");
        netStatPollEnabled=false;
        stopNetStatPoll();
        restartRadio();
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET,NO_RECV_POLL_LIMIT);
      }
    }
 else {
      mNoRecvPollCount=0;
      netStatPollPeriod=POLL_NETSTAT_MILLIS;
    }
    if (netStatPollEnabled) {
      mDataConnectionTracker.postDelayed(this,netStatPollPeriod);
    }
  }
}","public void run(){
  long sent, received;
  long preTxPkts=-1, preRxPkts=-1;
  Activity newActivity;
  preTxPkts=txPkts;
  preRxPkts=rxPkts;
  if (netstat != null) {
    try {
      txPkts=netstat.getMobileTxPackets();
      rxPkts=netstat.getMobileRxPackets();
    }
 catch (    RemoteException e) {
      txPkts=0;
      rxPkts=0;
    }
    if (netStatPollEnabled && (preTxPkts > 0 || preRxPkts > 0)) {
      sent=txPkts - preTxPkts;
      received=rxPkts - preRxPkts;
      if (sent > 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAINANDOUT;
      }
 else       if (sent > 0 && received == 0) {
        if (phone.getState() == Phone.State.IDLE) {
          sentSinceLastRecv+=sent;
        }
 else {
          sentSinceLastRecv=0;
        }
        newActivity=Activity.DATAOUT;
      }
 else       if (sent == 0 && received > 0) {
        sentSinceLastRecv=0;
        newActivity=Activity.DATAIN;
      }
 else       if (sent == 0 && received == 0) {
        newActivity=(activity == Activity.DORMANT) ? activity : Activity.NONE;
      }
 else {
        sentSinceLastRecv=0;
        newActivity=(activity == Activity.DORMANT) ? activity : Activity.NONE;
      }
      if (activity != newActivity) {
        activity=newActivity;
        phone.notifyDataActivity();
      }
    }
    if (sentSinceLastRecv >= NUMBER_SENT_PACKETS_OF_HANG) {
      if (mNoRecvPollCount == 0) {
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET_COUNTDOWN_TRIGGERED,sentSinceLastRecv);
      }
      if (mNoRecvPollCount < NO_RECV_POLL_LIMIT) {
        mNoRecvPollCount++;
        netStatPollPeriod=POLL_NETSTAT_SLOW_MILLIS;
      }
 else {
        if (DBG)         log(""String_Node_Str"" + String.valueOf(sentSinceLastRecv) + ""String_Node_Str"");
        netStatPollEnabled=false;
        stopNetStatPoll();
        restartRadio();
        EventLog.writeEvent(TelephonyEventLog.EVENT_LOG_RADIO_RESET,NO_RECV_POLL_LIMIT);
      }
    }
 else {
      mNoRecvPollCount=0;
      netStatPollPeriod=POLL_NETSTAT_MILLIS;
    }
    if (netStatPollEnabled) {
      mDataConnectionTracker.postDelayed(this,netStatPollPeriod);
    }
  }
}"
23908,"public void runTest(TestResult testResult){
  mTestResult=testResult;
  for (  TestListener testListener : mTestListeners) {
    mTestResult.addListener(testListener);
  }
  Context testContext=mInstrumentation.getContext();
  for (  TestCase testCase : mTestCases) {
    setContextIfAndroidTestCase(testCase,mContext,testContext);
    setInstrumentationIfInstrumentationTestCase(testCase,mInstrumentation);
    testCase.run(mTestResult);
  }
}","public void runTest(TestResult testResult){
  mTestResult=testResult;
  for (  TestListener testListener : mTestListeners) {
    mTestResult.addListener(testListener);
  }
  Context testContext=mInstrumentation == null ? mContext : mInstrumentation.getContext();
  for (  TestCase testCase : mTestCases) {
    setContextIfAndroidTestCase(testCase,mContext,testContext);
    setInstrumentationIfInstrumentationTestCase(testCase,mInstrumentation);
    testCase.run(mTestResult);
  }
}"
23909,"/** 
 * parseCookie() parses the cookieString which is a comma-separated list of one or more cookies in the format of ""NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure httponly"" to a list of Cookies. Here is a sample: IGDND=1, IGPC=ET=UB8TSNwtDmQ:AF=0; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/ig; domain=.google.com, =, PREF=ID=408909b1b304593d:TM=1156459854:LM=1156459854:S=V-vCAU6Sh-gobCfO; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com which contains 3 cookies IGDND, IGPC, PREF and an empty cookie
 * @param host The default host
 * @param path The default path
 * @param cookieString The string coming from ""Set-Cookie:""
 * @return A list of Cookies
 */
private ArrayList<Cookie> parseCookie(String host,String path,String cookieString){
  ArrayList<Cookie> ret=new ArrayList<Cookie>();
  int index=0;
  int length=cookieString.length();
  while (true) {
    Cookie cookie=null;
    if (index < 0 || index >= length) {
      break;
    }
    if (cookieString.charAt(index) == WHITE_SPACE) {
      index++;
      continue;
    }
    int semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    int equalIndex=cookieString.indexOf(EQUAL,index);
    if (equalIndex == -1) {
      break;
    }
    if (semicolonIndex > -1 && semicolonIndex < equalIndex) {
      break;
    }
    cookie=new Cookie(host,path);
    cookie.name=cookieString.substring(index,equalIndex);
    if (cookieString.charAt(equalIndex + 1) == QUOTATION) {
      index=cookieString.indexOf(QUOTATION,equalIndex + 2);
      if (index == -1) {
        break;
      }
    }
    semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    if (semicolonIndex == -1) {
      semicolonIndex=length;
    }
    if (semicolonIndex - equalIndex > MAX_COOKIE_LENGTH) {
      cookie.value=cookieString.substring(equalIndex + 1,equalIndex + MAX_COOKIE_LENGTH);
    }
 else     if (equalIndex + 1 == semicolonIndex || semicolonIndex < equalIndex) {
      cookie.value=""String_Node_Str"";
    }
 else {
      cookie.value=cookieString.substring(equalIndex + 1,semicolonIndex);
    }
    index=semicolonIndex;
    while (true) {
      if (index < 0 || index >= length) {
        break;
      }
      if (cookieString.charAt(index) == WHITE_SPACE || cookieString.charAt(index) == SEMICOLON) {
        index++;
        continue;
      }
      if (cookieString.charAt(index) == COMMA) {
        index++;
        break;
      }
      if (length - index > SECURE_LENGTH && cookieString.substring(index,index + SECURE_LENGTH).equalsIgnoreCase(SECURE)) {
        index+=SECURE_LENGTH;
        cookie.secure=true;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      if (length - index > HTTP_ONLY_LENGTH && cookieString.substring(index,index + HTTP_ONLY_LENGTH).equalsIgnoreCase(HTTP_ONLY)) {
        index+=HTTP_ONLY_LENGTH;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      equalIndex=cookieString.indexOf(EQUAL,index);
      if (equalIndex > 0) {
        String name=cookieString.substring(index,equalIndex).toLowerCase();
        if (name.equals(EXPIRES)) {
          int comaIndex=cookieString.indexOf(COMMA,equalIndex);
          if ((comaIndex != -1) && (comaIndex - equalIndex <= 10)) {
            index=comaIndex + 1;
          }
        }
        semicolonIndex=cookieString.indexOf(SEMICOLON,index);
        int commaIndex=cookieString.indexOf(COMMA,index);
        if (semicolonIndex == -1 && commaIndex == -1) {
          index=length;
        }
 else         if (semicolonIndex == -1) {
          index=commaIndex;
        }
 else         if (commaIndex == -1) {
          index=semicolonIndex;
        }
 else {
          index=Math.min(semicolonIndex,commaIndex);
        }
        String value=cookieString.substring(equalIndex + 1,index);
        if (value.length() > 2 && value.charAt(0) == QUOTATION) {
          int endQuote=value.indexOf(QUOTATION,1);
          if (endQuote > 0) {
            value=value.substring(1,endQuote);
          }
        }
        if (name.equals(EXPIRES)) {
          try {
            cookie.expires=HttpDateTime.parse(value);
          }
 catch (          IllegalArgumentException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(MAX_AGE)) {
          try {
            cookie.expires=System.currentTimeMillis() + 1000 * Long.parseLong(value);
          }
 catch (          NumberFormatException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(PATH)) {
          if (value.length() > 0) {
            cookie.path=value;
          }
        }
 else         if (name.equals(DOMAIN)) {
          int lastPeriod=value.lastIndexOf(PERIOD);
          if (lastPeriod == 0) {
            cookie.domain=null;
            continue;
          }
          try {
            Integer.parseInt(value.substring(lastPeriod + 1));
            if (!value.equals(host)) {
              cookie.domain=null;
            }
            continue;
          }
 catch (          NumberFormatException ex) {
          }
          value=value.toLowerCase();
          if (value.charAt(0) != PERIOD) {
            value=PERIOD + value;
            lastPeriod++;
          }
          if (host.endsWith(value.substring(1))) {
            int len=value.length();
            int hostLen=host.length();
            if (hostLen > (len - 1) && host.charAt(hostLen - len) != PERIOD) {
              cookie.domain=null;
              continue;
            }
            if ((len == lastPeriod + 3) && (len >= 6 && len <= 8)) {
              String s=value.substring(1,lastPeriod);
              if (Arrays.binarySearch(BAD_COUNTRY_2LDS,s) >= 0) {
                cookie.domain=null;
                continue;
              }
            }
            cookie.domain=value;
          }
 else {
            cookie.domain=null;
          }
        }
      }
 else {
        index=length;
      }
    }
    if (cookie != null && cookie.domain != null) {
      ret.add(cookie);
    }
  }
  return ret;
}","/** 
 * parseCookie() parses the cookieString which is a comma-separated list of one or more cookies in the format of ""NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure httponly"" to a list of Cookies. Here is a sample: IGDND=1, IGPC=ET=UB8TSNwtDmQ:AF=0; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/ig; domain=.google.com, =, PREF=ID=408909b1b304593d:TM=1156459854:LM=1156459854:S=V-vCAU6Sh-gobCfO; expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.com which contains 3 cookies IGDND, IGPC, PREF and an empty cookie
 * @param host The default host
 * @param path The default path
 * @param cookieString The string coming from ""Set-Cookie:""
 * @return A list of Cookies
 */
private ArrayList<Cookie> parseCookie(String host,String path,String cookieString){
  ArrayList<Cookie> ret=new ArrayList<Cookie>();
  int index=0;
  int length=cookieString.length();
  while (true) {
    Cookie cookie=null;
    if (index < 0 || index >= length) {
      break;
    }
    if (cookieString.charAt(index) == WHITE_SPACE) {
      index++;
      continue;
    }
    int semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    int equalIndex=cookieString.indexOf(EQUAL,index);
    if (equalIndex == -1) {
      break;
    }
    if (semicolonIndex > -1 && semicolonIndex < equalIndex) {
      break;
    }
    cookie=new Cookie(host,path);
    cookie.name=cookieString.substring(index,equalIndex);
    if (cookieString.charAt(equalIndex + 1) == QUOTATION) {
      index=cookieString.indexOf(QUOTATION,equalIndex + 2);
      if (index == -1) {
        break;
      }
    }
    semicolonIndex=cookieString.indexOf(SEMICOLON,index);
    if (semicolonIndex == -1) {
      semicolonIndex=length;
    }
    if (semicolonIndex - equalIndex > MAX_COOKIE_LENGTH) {
      cookie.value=cookieString.substring(equalIndex + 1,equalIndex + MAX_COOKIE_LENGTH);
    }
 else     if (equalIndex + 1 == semicolonIndex || semicolonIndex < equalIndex) {
      cookie.value=""String_Node_Str"";
    }
 else {
      cookie.value=cookieString.substring(equalIndex + 1,semicolonIndex);
    }
    index=semicolonIndex;
    while (true) {
      if (index < 0 || index >= length) {
        break;
      }
      if (cookieString.charAt(index) == WHITE_SPACE || cookieString.charAt(index) == SEMICOLON) {
        index++;
        continue;
      }
      if (cookieString.charAt(index) == COMMA) {
        index++;
        break;
      }
      if (length - index >= SECURE_LENGTH && cookieString.substring(index,index + SECURE_LENGTH).equalsIgnoreCase(SECURE)) {
        index+=SECURE_LENGTH;
        cookie.secure=true;
        if (index == length)         break;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      if (length - index >= HTTP_ONLY_LENGTH && cookieString.substring(index,index + HTTP_ONLY_LENGTH).equalsIgnoreCase(HTTP_ONLY)) {
        index+=HTTP_ONLY_LENGTH;
        if (index == length)         break;
        if (cookieString.charAt(index) == EQUAL)         index++;
        continue;
      }
      equalIndex=cookieString.indexOf(EQUAL,index);
      if (equalIndex > 0) {
        String name=cookieString.substring(index,equalIndex).toLowerCase();
        if (name.equals(EXPIRES)) {
          int comaIndex=cookieString.indexOf(COMMA,equalIndex);
          if ((comaIndex != -1) && (comaIndex - equalIndex <= 10)) {
            index=comaIndex + 1;
          }
        }
        semicolonIndex=cookieString.indexOf(SEMICOLON,index);
        int commaIndex=cookieString.indexOf(COMMA,index);
        if (semicolonIndex == -1 && commaIndex == -1) {
          index=length;
        }
 else         if (semicolonIndex == -1) {
          index=commaIndex;
        }
 else         if (commaIndex == -1) {
          index=semicolonIndex;
        }
 else {
          index=Math.min(semicolonIndex,commaIndex);
        }
        String value=cookieString.substring(equalIndex + 1,index);
        if (value.length() > 2 && value.charAt(0) == QUOTATION) {
          int endQuote=value.indexOf(QUOTATION,1);
          if (endQuote > 0) {
            value=value.substring(1,endQuote);
          }
        }
        if (name.equals(EXPIRES)) {
          try {
            cookie.expires=HttpDateTime.parse(value);
          }
 catch (          IllegalArgumentException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(MAX_AGE)) {
          try {
            cookie.expires=System.currentTimeMillis() + 1000 * Long.parseLong(value);
          }
 catch (          NumberFormatException ex) {
            Log.e(LOGTAG,""String_Node_Str"" + value);
          }
        }
 else         if (name.equals(PATH)) {
          if (value.length() > 0) {
            cookie.path=value;
          }
        }
 else         if (name.equals(DOMAIN)) {
          int lastPeriod=value.lastIndexOf(PERIOD);
          if (lastPeriod == 0) {
            cookie.domain=null;
            continue;
          }
          try {
            Integer.parseInt(value.substring(lastPeriod + 1));
            if (!value.equals(host)) {
              cookie.domain=null;
            }
            continue;
          }
 catch (          NumberFormatException ex) {
          }
          value=value.toLowerCase();
          if (value.charAt(0) != PERIOD) {
            value=PERIOD + value;
            lastPeriod++;
          }
          if (host.endsWith(value.substring(1))) {
            int len=value.length();
            int hostLen=host.length();
            if (hostLen > (len - 1) && host.charAt(hostLen - len) != PERIOD) {
              cookie.domain=null;
              continue;
            }
            if ((len == lastPeriod + 3) && (len >= 6 && len <= 8)) {
              String s=value.substring(1,lastPeriod);
              if (Arrays.binarySearch(BAD_COUNTRY_2LDS,s) >= 0) {
                cookie.domain=null;
                continue;
              }
            }
            cookie.domain=value;
          }
 else {
            cookie.domain=null;
          }
        }
      }
 else {
        index=length;
      }
    }
    if (cookie != null && cookie.domain != null) {
      ret.add(cookie);
    }
  }
  return ret;
}"
23910,"public void onSensorChanged(SensorEvent event){
  long milliseconds=event.timestamp / 1000000;
  if (event.values[0] == 0.0) {
    goToSleep(milliseconds);
  }
 else {
    userActivity(milliseconds,false);
  }
}","public void onSensorChanged(SensorEvent event){
  long milliseconds=event.timestamp / 1000000;
  if (event.values[0] == 0.0) {
    goToSleep(milliseconds);
  }
 else {
synchronized (mLocks) {
      boolean savedActivityAllowed=mUserActivityAllowed;
      mUserActivityAllowed=true;
      userActivity(milliseconds,false);
      mUserActivityAllowed=savedActivityAllowed;
    }
  }
}"
23911,"MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData=mLastData;
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[i + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}","MotionEvent generateAbsMotion(InputDevice device,long curTime,long curTimeNano,Display display,int orientation,int metaState){
  if (mNextNumPointers <= 0 && mLastNumPointers <= 0) {
    return null;
  }
  final int lastNumPointers=mLastNumPointers;
  final int nextNumPointers=mNextNumPointers;
  if (mNextNumPointers > MAX_POINTERS) {
    Log.w(""String_Node_Str"",""String_Node_Str"" + mNextNumPointers + ""String_Node_Str""+ MAX_POINTERS);
    mNextNumPointers=MAX_POINTERS;
  }
  int upOrDownPointer=updatePointerIdentifiers();
  final float[] reportData=mReportData;
  final int[] rawData=mLastData;
  final int numPointers=mLastNumPointers;
  if (DEBUG_POINTERS)   Log.v(""String_Node_Str"",""String_Node_Str"" + numPointers + ""String_Node_Str""+ lastNumPointers+ ""String_Node_Str""+ nextNumPointers+ ""String_Node_Str"");
  for (int i=0; i < numPointers; i++) {
    final int pos=i * MotionEvent.NUM_SAMPLE_DATA;
    reportData[pos + MotionEvent.SAMPLE_X]=rawData[pos + MotionEvent.SAMPLE_X];
    reportData[pos + MotionEvent.SAMPLE_Y]=rawData[pos + MotionEvent.SAMPLE_Y];
    reportData[pos + MotionEvent.SAMPLE_PRESSURE]=rawData[pos + MotionEvent.SAMPLE_PRESSURE];
    reportData[pos + MotionEvent.SAMPLE_SIZE]=rawData[pos + MotionEvent.SAMPLE_SIZE];
  }
  int action;
  int edgeFlags=0;
  if (nextNumPointers != lastNumPointers) {
    if (nextNumPointers > lastNumPointers) {
      if (lastNumPointers == 0) {
        action=MotionEvent.ACTION_DOWN;
        mDownTime=curTime;
      }
 else {
        action=MotionEvent.ACTION_POINTER_DOWN | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
 else {
      if (numPointers == 1) {
        action=MotionEvent.ACTION_UP;
      }
 else {
        action=MotionEvent.ACTION_POINTER_UP | (upOrDownPointer << MotionEvent.ACTION_POINTER_ID_SHIFT);
      }
    }
    currentMove=null;
  }
 else {
    action=MotionEvent.ACTION_MOVE;
  }
  final int dispW=display.getWidth() - 1;
  final int dispH=display.getHeight() - 1;
  int w=dispW;
  int h=dispH;
  if (orientation == Surface.ROTATION_90 || orientation == Surface.ROTATION_270) {
    int tmp=w;
    w=h;
    h=tmp;
  }
  final AbsoluteInfo absX=device.absX;
  final AbsoluteInfo absY=device.absY;
  final AbsoluteInfo absPressure=device.absPressure;
  final AbsoluteInfo absSize=device.absSize;
  for (int i=0; i < numPointers; i++) {
    final int j=i * MotionEvent.NUM_SAMPLE_DATA;
    if (absX != null) {
      reportData[j + MotionEvent.SAMPLE_X]=((reportData[j + MotionEvent.SAMPLE_X] - absX.minValue) / absX.range) * w;
    }
    if (absY != null) {
      reportData[j + MotionEvent.SAMPLE_Y]=((reportData[j + MotionEvent.SAMPLE_Y] - absY.minValue) / absY.range) * h;
    }
    if (absPressure != null) {
      reportData[j + MotionEvent.SAMPLE_PRESSURE]=((reportData[j + MotionEvent.SAMPLE_PRESSURE] - absPressure.minValue) / (float)absPressure.range);
    }
    if (absSize != null) {
      reportData[j + MotionEvent.SAMPLE_SIZE]=((reportData[j + MotionEvent.SAMPLE_SIZE] - absSize.minValue) / (float)absSize.range);
    }
switch (orientation) {
case Surface.ROTATION_90:
{
        final float temp=reportData[j + MotionEvent.SAMPLE_X];
        reportData[j + MotionEvent.SAMPLE_X]=reportData[j + MotionEvent.SAMPLE_Y];
        reportData[j + MotionEvent.SAMPLE_Y]=w - temp;
        break;
      }
case Surface.ROTATION_180:
{
      reportData[j + MotionEvent.SAMPLE_X]=w - reportData[j + MotionEvent.SAMPLE_X];
      reportData[j + MotionEvent.SAMPLE_Y]=h - reportData[j + MotionEvent.SAMPLE_Y];
      break;
    }
case Surface.ROTATION_270:
{
    final float temp=reportData[j + MotionEvent.SAMPLE_X];
    reportData[j + MotionEvent.SAMPLE_X]=h - reportData[j + MotionEvent.SAMPLE_Y];
    reportData[j + MotionEvent.SAMPLE_Y]=temp;
    break;
  }
}
}
if (action == MotionEvent.ACTION_DOWN) {
if (reportData[MotionEvent.SAMPLE_X] <= 0) {
edgeFlags|=MotionEvent.EDGE_LEFT;
}
 else if (reportData[MotionEvent.SAMPLE_X] >= dispW) {
edgeFlags|=MotionEvent.EDGE_RIGHT;
}
if (reportData[MotionEvent.SAMPLE_Y] <= 0) {
edgeFlags|=MotionEvent.EDGE_TOP;
}
 else if (reportData[MotionEvent.SAMPLE_Y] >= dispH) {
edgeFlags|=MotionEvent.EDGE_BOTTOM;
}
}
if (currentMove != null) {
if (false) Log.i(""String_Node_Str"",""String_Node_Str"" + reportData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ reportData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ currentMove);
currentMove.addBatch(curTime,reportData,metaState);
if (WindowManagerPolicy.WATCH_POINTER) {
Log.i(""String_Node_Str"",""String_Node_Str"" + currentMove);
}
return null;
}
MotionEvent me=MotionEvent.obtainNano(mDownTime,curTime,curTimeNano,action,numPointers,mPointerIds,reportData,metaState,xPrecision,yPrecision,device.id,edgeFlags);
if (action == MotionEvent.ACTION_MOVE) {
currentMove=me;
}
if (nextNumPointers < lastNumPointers) {
removeOldPointer(upOrDownPointer);
}
return me;
}"
23912,"public void run(){
  Log.d(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          mDevices.put(ev.deviceId,di);
          if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
            readVirtualKeys(di.name);
          }
          configChanged=true;
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else {
            Log.w(TAG,""String_Node_Str"" + ev.deviceId);
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (di == null) {
        continue;
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_2 && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[1]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.mAbs.mNextData[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.mAbs.mNextData[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[(di.mAbs.mDown[0] ? MotionEvent.NUM_SAMPLE_DATA : 0) + MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[(di.mAbs.mDown[0] ? MotionEvent.NUM_SAMPLE_DATA : 0) + MotionEvent.SAMPLE_Y]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0])                 ms.mNextNumPointers++;
                if (ms.mDown[1])                 ms.mNextNumPointers++;
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}","public void run(){
  Log.d(TAG,""String_Node_Str"");
  android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_URGENT_DISPLAY);
  RawInputEvent ev=new RawInputEvent();
  while (true) {
    try {
      InputDevice di;
      readEvent(ev);
      boolean send=false;
      boolean configChanged=false;
      if (false) {
        Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId) + ""String_Node_Str""+ Integer.toHexString(ev.type)+ ""String_Node_Str""+ ev.scancode+ ""String_Node_Str""+ ev.keycode+ ""String_Node_Str""+ ev.value);
      }
      if (ev.type == RawInputEvent.EV_DEVICE_ADDED) {
synchronized (mFirst) {
          di=newInputDevice(ev.deviceId);
          mDevices.put(ev.deviceId,di);
          if ((di.classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
            readVirtualKeys(di.name);
          }
          configChanged=true;
        }
      }
 else       if (ev.type == RawInputEvent.EV_DEVICE_REMOVED) {
synchronized (mFirst) {
          Log.i(TAG,""String_Node_Str"" + Integer.toHexString(ev.deviceId));
          di=mDevices.get(ev.deviceId);
          if (di != null) {
            mDevices.delete(ev.deviceId);
            configChanged=true;
          }
 else {
            Log.w(TAG,""String_Node_Str"" + ev.deviceId);
          }
        }
      }
 else {
        di=getInputDevice(ev.deviceId);
        send=preprocessEvent(di,ev);
        if (ev.type == RawInputEvent.EV_KEY) {
          di.mMetaKeysState=makeMetaState(ev.keycode,ev.value != 0,di.mMetaKeysState);
          mHaveGlobalMetaState=false;
        }
      }
      if (di == null) {
        continue;
      }
      if (configChanged) {
synchronized (mFirst) {
          addLocked(di,System.nanoTime(),0,RawInputEvent.CLASS_CONFIGURATION_CHANGED,null);
        }
      }
      if (!send) {
        continue;
      }
synchronized (mFirst) {
        final long curTime=SystemClock.uptimeMillis();
        final long curTimeNano=System.nanoTime();
        final int classes=di.classes;
        final int type=ev.type;
        final int scancode=ev.scancode;
        send=false;
        if (type == RawInputEvent.EV_KEY && (classes & RawInputEvent.CLASS_KEYBOARD) != 0 && (scancode < RawInputEvent.BTN_FIRST || scancode > RawInputEvent.BTN_LAST)) {
          boolean down;
          if (ev.value != 0) {
            down=true;
            di.mKeyDownTime=curTime;
          }
 else {
            down=false;
          }
          int keycode=rotateKeyCodeLocked(ev.keycode);
          addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_KEYBOARD,newKeyEvent(di,di.mKeyDownTime,curTime,down,keycode,0,scancode,((ev.flags & WindowManagerPolicy.FLAG_WOKE_HERE) != 0) ? KeyEvent.FLAG_WOKE_HERE : 0));
        }
 else         if (ev.type == RawInputEvent.EV_KEY) {
          if (ev.scancode == RawInputEvent.BTN_TOUCH && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[0]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_2 && (classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
            di.mAbs.changed=true;
            di.mAbs.mDown[1]=ev.value != 0;
          }
 else           if (ev.scancode == RawInputEvent.BTN_MOUSE && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
            di.mRel.changed=true;
            di.mRel.mNextNumPointers=ev.value != 0 ? 1 : 0;
            send=true;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN_MT) != 0) {
          if (ev.scancode == RawInputEvent.ABS_MT_TOUCH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_X) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_X]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_POSITION_Y) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_Y]=ev.value;
            if (DEBUG_POINTERS)             Log.v(TAG,""String_Node_Str"" + di.mAbs.mAddingPointerOffset + ""String_Node_Str""+ ev.value);
          }
 else           if (ev.scancode == RawInputEvent.ABS_MT_WIDTH_MAJOR) {
            di.mAbs.changed=true;
            di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_ABS && (classes & RawInputEvent.CLASS_TOUCHSCREEN) != 0) {
          if (ev.scancode == RawInputEvent.ABS_X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_Y]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_PRESSURE) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_PRESSURE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_PRESSURE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_TOOL_WIDTH) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.SAMPLE_SIZE]=ev.value;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_SIZE]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0X) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_X]=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.ABS_HAT0Y) {
            di.mAbs.changed=true;
            di.curTouchVals[MotionEvent.NUM_SAMPLE_DATA + MotionEvent.SAMPLE_Y]=ev.value;
          }
        }
 else         if (ev.type == RawInputEvent.EV_REL && (classes & RawInputEvent.CLASS_TRACKBALL) != 0) {
          if (ev.scancode == RawInputEvent.REL_X) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_X]+=ev.value;
          }
 else           if (ev.scancode == RawInputEvent.REL_Y) {
            di.mRel.changed=true;
            di.mRel.mNextData[MotionEvent.SAMPLE_Y]+=ev.value;
          }
        }
        if (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_MT_REPORT && di.mAbs != null) {
          di.mAbs.changed=true;
          if (di.mAbs.mNextData[MotionEvent.SAMPLE_PRESSURE] > 0) {
            if (di.mAbs.mNextData[di.mAbs.mAddingPointerOffset + MotionEvent.SAMPLE_PRESSURE] != 0) {
              final int num=di.mAbs.mNextNumPointers + 1;
              di.mAbs.mNextNumPointers=num;
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"" + num + ""String_Node_Str"");
              final int newOffset=(num <= InputDevice.MAX_POINTERS) ? (num * MotionEvent.NUM_SAMPLE_DATA) : (InputDevice.MAX_POINTERS * MotionEvent.NUM_SAMPLE_DATA);
              di.mAbs.mAddingPointerOffset=newOffset;
              di.mAbs.mNextData[newOffset + MotionEvent.SAMPLE_PRESSURE]=0;
            }
 else {
              if (DEBUG_POINTERS)               Log.v(TAG,""String_Node_Str"");
            }
          }
        }
 else         if (send || (ev.type == RawInputEvent.EV_SYN && ev.scancode == RawInputEvent.SYN_REPORT)) {
          if (mDisplay != null) {
            if (!mHaveGlobalMetaState) {
              computeGlobalMetaStateLocked();
            }
            MotionEvent me;
            InputDevice.MotionState ms=di.mAbs;
            if (ms.changed) {
              ms.changed=false;
              if ((classes & (RawInputEvent.CLASS_TOUCHSCREEN | RawInputEvent.CLASS_TOUCHSCREEN_MT)) == RawInputEvent.CLASS_TOUCHSCREEN) {
                ms.mNextNumPointers=0;
                if (ms.mDown[0]) {
                  System.arraycopy(di.curTouchVals,0,ms.mNextData,0,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
                if (ms.mDown[1]) {
                  System.arraycopy(di.curTouchVals,MotionEvent.NUM_SAMPLE_DATA,ms.mNextData,ms.mNextNumPointers * MotionEvent.NUM_SAMPLE_DATA,MotionEvent.NUM_SAMPLE_DATA);
                  ms.mNextNumPointers++;
                }
              }
              boolean doMotion=!monitorVirtualKey(di,ev,curTime,curTimeNano);
              if (doMotion && ms.mNextNumPointers > 0 && ms.mLastNumPointers == 0) {
                doMotion=!generateVirtualKeyDown(di,ev,curTime,curTimeNano);
              }
              if (doMotion) {
                do {
                  me=ms.generateAbsMotion(di,curTime,curTimeNano,mDisplay,mOrientation,mGlobalMetaState);
                  if (false)                   Log.v(TAG,""String_Node_Str"" + di.mAbs.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mAbs.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
                  if (me != null) {
                    if (WindowManagerPolicy.WATCH_POINTER) {
                      Log.i(TAG,""String_Node_Str"" + me);
                    }
                    addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TOUCHSCREEN,me);
                  }
                }
 while (ms.hasMore());
              }
              ms.finish();
            }
            ms=di.mRel;
            if (ms.changed) {
              ms.changed=false;
              me=ms.generateRelMotion(di,curTime,curTimeNano,mOrientation,mGlobalMetaState);
              if (false)               Log.v(TAG,""String_Node_Str"" + di.mRel.mNextData[MotionEvent.SAMPLE_X] + ""String_Node_Str""+ di.mRel.mNextData[MotionEvent.SAMPLE_Y]+ ""String_Node_Str""+ me);
              if (me != null) {
                addLocked(di,curTimeNano,ev.flags,RawInputEvent.CLASS_TRACKBALL,me);
              }
              ms.finish();
            }
          }
        }
      }
    }
 catch (    RuntimeException exc) {
      Log.e(TAG,""String_Node_Str"",exc);
    }
  }
}"
23913,"/** 
 * This is the internal entry point for handling Activity.finish().
 * @param token The Binder token referencing the Activity we want to finish.
 * @param resultCode Result code, if any, from this Activity.
 * @param resultData Result data (Intent), if any, from this Activity.
 * @result Returns true if the activity successfully finished, or false if it is still running.
 */
public final boolean finishActivity(IBinder token,int resultCode,Intent resultData){
  if (resultData != null && resultData.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (mController != null) {
      HistoryRecord next=topRunningActivityLocked(token,0);
      if (next != null) {
        boolean resumeOK=true;
        try {
          resumeOK=mController.activityResuming(next.packageName);
        }
 catch (        RemoteException e) {
          mController=null;
        }
        if (!resumeOK) {
          return false;
        }
      }
    }
    final long origId=Binder.clearCallingIdentity();
    boolean res=requestFinishActivityLocked(token,resultCode,resultData,""String_Node_Str"");
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","/** 
 * This is the internal entry point for handling Activity.finish().
 * @param token The Binder token referencing the Activity we want to finish.
 * @param resultCode Result code, if any, from this Activity.
 * @param resultData Result data (Intent), if any, from this Activity.
 * @return Returns true if the activity successfully finished, or false if it is still running.
 */
public final boolean finishActivity(IBinder token,int resultCode,Intent resultData){
  if (resultData != null && resultData.hasFileDescriptors() == true) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    if (mController != null) {
      HistoryRecord next=topRunningActivityLocked(token,0);
      if (next != null) {
        boolean resumeOK=true;
        try {
          resumeOK=mController.activityResuming(next.packageName);
        }
 catch (        RemoteException e) {
          mController=null;
        }
        if (!resumeOK) {
          return false;
        }
      }
    }
    final long origId=Binder.clearCallingIdentity();
    boolean res=requestFinishActivityLocked(token,resultCode,resultData,""String_Node_Str"");
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}"
23914,"/** 
 * Unlocks Wifi Multicast, restoring the filter of packets not addressed specifically to this device and saving power. If this MulticastLock is reference-counted, each call to  {@code release} will decrement the reference count, and themulticast packets will only stop being received when the reference count reaches zero.  If the reference count goes below zero (that is, if  {@code release} is called a greater number of times than{@link #acquire}), an exception is thrown. If this MulticastLock is not reference-counted, the first call to  {@code release} (after the radio was multicast locked using{@linke #acquire}) will unlock the multicast, and subsequent calls will be ignored. Note that if any other Wifi Multicast Locks are still outstanding this   {@code release} call will not have an immediate effect.  Onlywhen all applications have released all their Multicast Locks will the Multicast filter be turned back on. Also note that when an app exits or crashes all of its Multicast Locks will be automatically released.
 */
public void release(){
synchronized (mBinder) {
    if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
      try {
        mService.releaseMulticastLock();
synchronized (WifiManager.this) {
          mActiveLockCount--;
        }
      }
 catch (      RemoteException ignore) {
      }
      mHeld=false;
    }
    if (mRefCount < 0) {
      throw new RuntimeException(""String_Node_Str"" + mTag);
    }
  }
}","/** 
 * Unlocks Wifi Multicast, restoring the filter of packets not addressed specifically to this device and saving power. If this MulticastLock is reference-counted, each call to  {@code release} will decrement the reference count, and themulticast packets will only stop being received when the reference count reaches zero.  If the reference count goes below zero (that is, if  {@code release} is called a greater number of times than{@link #acquire}), an exception is thrown. If this MulticastLock is not reference-counted, the first call to  {@code release} (after the radio was multicast locked using{@link #acquire}) will unlock the multicast, and subsequent calls will be ignored. Note that if any other Wifi Multicast Locks are still outstanding this   {@code release} call will not have an immediate effect.  Onlywhen all applications have released all their Multicast Locks will the Multicast filter be turned back on. Also note that when an app exits or crashes all of its Multicast Locks will be automatically released.
 */
public void release(){
synchronized (mBinder) {
    if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
      try {
        mService.releaseMulticastLock();
synchronized (WifiManager.this) {
          mActiveLockCount--;
        }
      }
 catch (      RemoteException ignore) {
      }
      mHeld=false;
    }
    if (mRefCount < 0) {
      throw new RuntimeException(""String_Node_Str"" + mTag);
    }
  }
}"
23915,"void readStateFromFileLocked(File file){
  FileInputStream stream=null;
  boolean success=false;
  try {
    stream=new FileInputStream(file);
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(stream,null);
    int type;
    int providerIndex=0;
    HashMap<Integer,Provider> loadedProviders=new HashMap<Integer,Provider>();
    do {
      type=parser.next();
      if (type == XmlPullParser.START_TAG) {
        String tag=parser.getName();
        if (""String_Node_Str"".equals(tag)) {
          String pkg=parser.getAttributeValue(null,""String_Node_Str"");
          String cl=parser.getAttributeValue(null,""String_Node_Str"");
          Provider p=lookupProviderLocked(new ComponentName(pkg,cl));
          if (p == null && mSafeMode) {
            p=new Provider();
            p.info=new AppWidgetProviderInfo();
            p.info.provider=new ComponentName(pkg,cl);
            p.zombie=true;
            mInstalledProviders.add(p);
          }
          if (p != null) {
            loadedProviders.put(providerIndex,p);
          }
          providerIndex++;
        }
 else         if (""String_Node_Str"".equals(tag)) {
          Host host=new Host();
          host.packageName=parser.getAttributeValue(null,""String_Node_Str"");
          try {
            host.uid=getUidForPackage(host.packageName);
          }
 catch (          PackageManager.NameNotFoundException ex) {
            host.zombie=true;
          }
          if (!host.zombie || mSafeMode) {
            host.hostId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
            mHosts.add(host);
          }
        }
 else         if (""String_Node_Str"".equals(tag)) {
          AppWidgetId id=new AppWidgetId();
          id.appWidgetId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          if (id.appWidgetId >= mNextAppWidgetId) {
            mNextAppWidgetId=id.appWidgetId + 1;
          }
          String providerString=parser.getAttributeValue(null,""String_Node_Str"");
          if (providerString != null) {
            int pIndex=Integer.parseInt(providerString,16);
            id.provider=loadedProviders.get(pIndex);
            if (false) {
              Log.d(TAG,""String_Node_Str"" + id.appWidgetId + ""String_Node_Str""+ pIndex+ ""String_Node_Str""+ id.provider);
            }
            if (id.provider == null) {
              continue;
            }
          }
          int hIndex=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          id.host=mHosts.get(hIndex);
          if (id.host == null) {
            continue;
          }
          if (id.provider != null) {
            id.provider.instances.add(id);
          }
          id.host.instances.add(id);
          mAppWidgetIds.add(id);
        }
      }
    }
 while (type != XmlPullParser.END_DOCUMENT);
    success=true;
  }
 catch (  NullPointerException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  NumberFormatException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IndexOutOfBoundsException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
  try {
    if (stream != null) {
      stream.close();
    }
  }
 catch (  IOException e) {
  }
  if (success) {
    final int N=mHosts.size();
    for (int i=0; i < N; i++) {
      pruneHostLocked(mHosts.get(i));
    }
  }
 else {
    mAppWidgetIds.clear();
    mHosts.clear();
    final int N=mInstalledProviders.size();
    for (int i=0; i < N; i++) {
      mInstalledProviders.get(i).instances.clear();
    }
  }
}","void readStateFromFileLocked(File file){
  FileInputStream stream=null;
  boolean success=false;
  try {
    stream=new FileInputStream(file);
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(stream,null);
    int type;
    int providerIndex=0;
    HashMap<Integer,Provider> loadedProviders=new HashMap<Integer,Provider>();
    do {
      type=parser.next();
      if (type == XmlPullParser.START_TAG) {
        String tag=parser.getName();
        if (""String_Node_Str"".equals(tag)) {
          String pkg=parser.getAttributeValue(null,""String_Node_Str"");
          String cl=parser.getAttributeValue(null,""String_Node_Str"");
          Provider p=lookupProviderLocked(new ComponentName(pkg,cl));
          if (p == null && mSafeMode) {
            p=new Provider();
            p.info=new AppWidgetProviderInfo();
            p.info.provider=new ComponentName(pkg,cl);
            p.zombie=true;
            mInstalledProviders.add(p);
          }
          if (p != null) {
            loadedProviders.put(providerIndex,p);
          }
          providerIndex++;
        }
 else         if (""String_Node_Str"".equals(tag)) {
          Host host=new Host();
          host.packageName=parser.getAttributeValue(null,""String_Node_Str"");
          try {
            host.uid=getUidForPackage(host.packageName);
          }
 catch (          PackageManager.NameNotFoundException ex) {
            host.zombie=true;
          }
          if (!host.zombie || mSafeMode) {
            host.hostId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
            mHosts.add(host);
          }
        }
 else         if (""String_Node_Str"".equals(tag)) {
          AppWidgetId id=new AppWidgetId();
          id.appWidgetId=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          if (id.appWidgetId >= mNextAppWidgetId) {
            mNextAppWidgetId=id.appWidgetId + 1;
          }
          String providerString=parser.getAttributeValue(null,""String_Node_Str"");
          if (providerString != null) {
            int pIndex=Integer.parseInt(providerString,16);
            id.provider=loadedProviders.get(pIndex);
            if (false) {
              Log.d(TAG,""String_Node_Str"" + id.appWidgetId + ""String_Node_Str""+ pIndex+ ""String_Node_Str""+ id.provider);
            }
            if (id.provider == null) {
              continue;
            }
          }
          int hIndex=Integer.parseInt(parser.getAttributeValue(null,""String_Node_Str""),16);
          id.host=mHosts.get(hIndex);
          if (id.host == null) {
            continue;
          }
          if (id.provider != null) {
            id.provider.instances.add(id);
          }
          id.host.instances.add(id);
          mAppWidgetIds.add(id);
        }
      }
    }
 while (type != XmlPullParser.END_DOCUMENT);
    success=true;
  }
 catch (  NullPointerException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  NumberFormatException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  XmlPullParserException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IOException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
catch (  IndexOutOfBoundsException e) {
    Log.w(TAG,""String_Node_Str"" + file,e);
  }
  try {
    if (stream != null) {
      stream.close();
    }
  }
 catch (  IOException e) {
  }
  if (success) {
    for (int i=mHosts.size() - 1; i >= 0; i--) {
      pruneHostLocked(mHosts.get(i));
    }
  }
 else {
    mAppWidgetIds.clear();
    mHosts.clear();
    final int N=mInstalledProviders.size();
    for (int i=0; i < N; i++) {
      mInstalledProviders.get(i).instances.clear();
    }
  }
}"
23916,"/** 
 * True if c is ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE   
 */
public final static boolean isNonSeparator(char c){
  return (c >= '0' && c <= '9') || c == '*' || c == '#' || c == '+' || c == WILD || c == WAIT || c == PAUSE;
}","private static boolean isNonSeparator(String address){
  for (int i=0, count=address.length(); i < count; i++) {
    if (!isNonSeparator(address.charAt(i))) {
      return false;
    }
  }
  return true;
}"
23917,"private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 1))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}","private static char findPOrWCharToAppend(String phoneNumber,int currPwIndex,int nextNonPwCharIndex){
  char c=phoneNumber.charAt(currPwIndex);
  char ret;
  ret=(isPause(c)) ? PhoneNumberUtils.PAUSE : PhoneNumberUtils.WAIT;
  if (isPause(c) && (nextNonPwCharIndex > (currPwIndex + 2))) {
    ret=PhoneNumberUtils.WAIT;
  }
  return ret;
}"
23918,"private static int findNextPCharOrNonPOrNonWCharIndex(String phoneNumber,int currIndex){
  boolean wMatched=false;
  int index=currIndex + 1;
  int length=phoneNumber.length();
  while (index < length) {
    char cNext=phoneNumber.charAt(index);
    if (isWait(cNext)) {
      wMatched=true;
    }
    if (!isWait(cNext) && !isPause(cNext)) {
      break;
    }
    index++;
  }
  if ((index < length) && (index > (currIndex + 1)) && ((wMatched == false) && isPause(phoneNumber.charAt(currIndex)))) {
    return (currIndex + 1);
  }
  return index;
}","private static int findNextPCharOrNonPOrNonWCharIndex(String phoneNumber,int currIndex){
  boolean wMatched=isWait(phoneNumber.charAt(currIndex));
  int index=currIndex + 1;
  int length=phoneNumber.length();
  while (index < length) {
    char cNext=phoneNumber.charAt(index);
    if (isWait(cNext)) {
      wMatched=true;
    }
    if (!isWait(cNext) && !isPause(cNext)) {
      break;
    }
    index++;
  }
  if ((index < length) && (index > (currIndex + 1)) && ((wMatched == false) && isPause(phoneNumber.charAt(currIndex)))) {
    return (currIndex + 1);
  }
  return index;
}"
23919,"/** 
 * format orignal dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (PhoneNumberUtils.isDialable(c)) {
      if (c == '+') {
        String ps=null;
        SystemProperties.get(TelephonyProperties.PROPERTY_IDP_STRING,ps);
        if (TextUtils.isEmpty(ps)) {
          ps=""String_Node_Str"";
        }
        ret.append(ps);
      }
 else {
        ret.append(c);
      }
    }
 else     if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 1)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return ret.toString();
}","/** 
 * format original dial string 1) convert international dialing prefix ""+"" to string specified per region 2) handle corner cases for PAUSE/WAIT dialing: If PAUSE/WAIT sequence at the end, ignore them. If consecutive PAUSE/WAIT sequence in the middle of the string, and if there is any WAIT in PAUSE/WAIT sequence, treat them like WAIT.
 */
public static String formatDialString(String phoneNumber){
  if (phoneNumber == null) {
    return null;
  }
  int length=phoneNumber.length();
  StringBuilder ret=new StringBuilder();
  char c;
  int currIndex=0;
  while (currIndex < length) {
    c=phoneNumber.charAt(currIndex);
    if (isPause(c) || isWait(c)) {
      if (currIndex < length - 1) {
        int nextIndex=findNextPCharOrNonPOrNonWCharIndex(phoneNumber,currIndex);
        if (nextIndex < length) {
          char pC=findPOrWCharToAppend(phoneNumber,currIndex,nextIndex);
          ret.append(pC);
          if (nextIndex > (currIndex + 2)) {
            currIndex=nextIndex - 1;
          }
        }
 else         if (nextIndex == length) {
          currIndex=length - 1;
        }
      }
    }
 else {
      ret.append(c);
    }
    currIndex++;
  }
  return PhoneNumberUtils.cdmaCheckAndProcessPlusCode(ret.toString());
}"
23920,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Debug.MemoryInfo memInfo=new Debug.MemoryInfo();
  Debug.getMemoryInfo(memInfo);
  final int nativeShared=memInfo.nativeSharedDirty;
  final int dalvikShared=memInfo.dalvikSharedDirty;
  final int otherShared=memInfo.otherSharedDirty;
  final int nativePrivate=memInfo.nativePrivateDirty;
  final int dalvikPrivate=memInfo.dalvikPrivateDirty;
  final int otherPrivate=memInfo.otherPrivateDirty;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootInstanceCount();
  long appContextInstanceCount=ApplicationContext.getInstanceCount();
  long activityInstanceCount=Activity.getInstanceCount();
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  int openSslSocketCount=OpenSSLSocketImpl.getInstanceCount();
  long sqliteAllocated=SQLiteDebug.getHeapAllocatedSize() / 1024;
  SQLiteDebug.PagerStats stats=new SQLiteDebug.PagerStats();
  SQLiteDebug.getPagerStats(stats);
  boolean doCheckinFormat=false;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg))       doCheckinFormat=true;
    }
  }
  if (doCheckinFormat) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    pw.print(',');
    pw.print(nativeShared);
    pw.print(',');
    pw.print(dalvikShared);
    pw.print(',');
    pw.print(otherShared);
    pw.print(',');
    pw.print(nativeShared + dalvikShared + otherShared);
    pw.print(',');
    pw.print(nativePrivate);
    pw.print(',');
    pw.print(dalvikPrivate);
    pw.print(',');
    pw.print(otherPrivate);
    pw.print(',');
    pw.print(nativePrivate + dalvikPrivate + otherPrivate);
    pw.print(',');
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(sqliteAllocated);
    pw.print(',');
    pw.print(stats.databaseBytes / 1024);
    pw.print(',');
    pw.print(stats.numPagers);
    pw.print(',');
    pw.print((stats.totalBytes - stats.referencedBytes) / 1024);
    pw.print(',');
    pw.print(stats.referencedBytes / 1024);
    pw.print('\n');
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeMax,dalvikMax,""String_Node_Str"",nativeMax + dalvikMax);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeAllocated,dalvikAllocated,""String_Node_Str"",nativeAllocated + dalvikAllocated);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeFree,dalvikFree,""String_Node_Str"",nativeFree + dalvikFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.dalvikPss,memInfo.otherPss,memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeShared,dalvikShared,otherShared,nativeShared + dalvikShared + otherShared);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativePrivate,dalvikPrivate,otherPrivate,nativePrivate + dalvikPrivate + otherPrivate);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",sqliteAllocated,""String_Node_Str"",stats.databaseBytes / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.numPagers,""String_Node_Str"",(stats.totalBytes - stats.referencedBytes) / 1024);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.referencedBytes / 1024);
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  long nativeMax=Debug.getNativeHeapSize() / 1024;
  long nativeAllocated=Debug.getNativeHeapAllocatedSize() / 1024;
  long nativeFree=Debug.getNativeHeapFreeSize() / 1024;
  Debug.MemoryInfo memInfo=new Debug.MemoryInfo();
  Debug.getMemoryInfo(memInfo);
  final int nativeShared=memInfo.nativeSharedDirty;
  final int dalvikShared=memInfo.dalvikSharedDirty;
  final int otherShared=memInfo.otherSharedDirty;
  final int nativePrivate=memInfo.nativePrivateDirty;
  final int dalvikPrivate=memInfo.dalvikPrivateDirty;
  final int otherPrivate=memInfo.otherPrivateDirty;
  Runtime runtime=Runtime.getRuntime();
  long dalvikMax=runtime.totalMemory() / 1024;
  long dalvikFree=runtime.freeMemory() / 1024;
  long dalvikAllocated=dalvikMax - dalvikFree;
  long viewInstanceCount=ViewDebug.getViewInstanceCount();
  long viewRootInstanceCount=ViewDebug.getViewRootInstanceCount();
  long appContextInstanceCount=ApplicationContext.getInstanceCount();
  long activityInstanceCount=Activity.getInstanceCount();
  int globalAssetCount=AssetManager.getGlobalAssetCount();
  int globalAssetManagerCount=AssetManager.getGlobalAssetManagerCount();
  int binderLocalObjectCount=Debug.getBinderLocalObjectCount();
  int binderProxyObjectCount=Debug.getBinderProxyObjectCount();
  int binderDeathObjectCount=Debug.getBinderDeathObjectCount();
  int openSslSocketCount=OpenSSLSocketImpl.getInstanceCount();
  long sqliteAllocated=SQLiteDebug.getHeapAllocatedSize() / 1024;
  SQLiteDebug.PagerStats stats=new SQLiteDebug.PagerStats();
  SQLiteDebug.getPagerStats(stats);
  boolean doCheckinFormat=false;
  if (args != null) {
    for (    String arg : args) {
      if (""String_Node_Str"".equals(arg))       doCheckinFormat=true;
    }
  }
  if (doCheckinFormat) {
    String processName=(mBoundApplication != null) ? mBoundApplication.processName : ""String_Node_Str"";
    pw.print(ACTIVITY_THREAD_CHECKIN_VERSION);
    pw.print(',');
    pw.print(Process.myPid());
    pw.print(',');
    pw.print(processName);
    pw.print(',');
    pw.print(nativeMax);
    pw.print(',');
    pw.print(dalvikMax);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeMax + dalvikMax);
    pw.print(',');
    pw.print(nativeAllocated);
    pw.print(',');
    pw.print(dalvikAllocated);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeAllocated + dalvikAllocated);
    pw.print(',');
    pw.print(nativeFree);
    pw.print(',');
    pw.print(dalvikFree);
    pw.print(',');
    pw.print(""String_Node_Str"");
    pw.print(nativeFree + dalvikFree);
    pw.print(',');
    pw.print(memInfo.nativePss);
    pw.print(',');
    pw.print(memInfo.dalvikPss);
    pw.print(',');
    pw.print(memInfo.otherPss);
    pw.print(',');
    pw.print(memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
    pw.print(',');
    pw.print(nativeShared);
    pw.print(',');
    pw.print(dalvikShared);
    pw.print(',');
    pw.print(otherShared);
    pw.print(',');
    pw.print(nativeShared + dalvikShared + otherShared);
    pw.print(',');
    pw.print(nativePrivate);
    pw.print(',');
    pw.print(dalvikPrivate);
    pw.print(',');
    pw.print(otherPrivate);
    pw.print(',');
    pw.print(nativePrivate + dalvikPrivate + otherPrivate);
    pw.print(',');
    pw.print(viewInstanceCount);
    pw.print(',');
    pw.print(viewRootInstanceCount);
    pw.print(',');
    pw.print(appContextInstanceCount);
    pw.print(',');
    pw.print(activityInstanceCount);
    pw.print(',');
    pw.print(globalAssetCount);
    pw.print(',');
    pw.print(globalAssetManagerCount);
    pw.print(',');
    pw.print(binderLocalObjectCount);
    pw.print(',');
    pw.print(binderProxyObjectCount);
    pw.print(',');
    pw.print(binderDeathObjectCount);
    pw.print(',');
    pw.print(openSslSocketCount);
    pw.print(',');
    pw.print(sqliteAllocated);
    pw.print(',');
    pw.print(stats.databaseBytes / 1024);
    pw.print(',');
    pw.print(stats.numPagers);
    pw.print(',');
    pw.print((stats.totalBytes - stats.referencedBytes) / 1024);
    pw.print(',');
    pw.print(stats.referencedBytes / 1024);
    pw.print('\n');
    return;
  }
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeMax,dalvikMax,""String_Node_Str"",nativeMax + dalvikMax);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeAllocated,dalvikAllocated,""String_Node_Str"",nativeAllocated + dalvikAllocated);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeFree,dalvikFree,""String_Node_Str"",nativeFree + dalvikFree);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",memInfo.nativePss,memInfo.dalvikPss,memInfo.otherPss,memInfo.nativePss + memInfo.dalvikPss + memInfo.otherPss);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativeShared,dalvikShared,otherShared,nativeShared + dalvikShared + otherShared);
  printRow(pw,HEAP_COLUMN,""String_Node_Str"",nativePrivate,dalvikPrivate,otherPrivate,nativePrivate + dalvikPrivate + otherPrivate);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",viewInstanceCount,""String_Node_Str"",viewRootInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",appContextInstanceCount,""String_Node_Str"",activityInstanceCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",globalAssetCount,""String_Node_Str"",globalAssetManagerCount);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",binderLocalObjectCount,""String_Node_Str"",binderProxyObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",binderDeathObjectCount);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",openSslSocketCount);
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",sqliteAllocated,""String_Node_Str"",stats.databaseBytes / 1024);
  printRow(pw,TWO_COUNT_COLUMNS,""String_Node_Str"",stats.numPagers,""String_Node_Str"",(stats.totalBytes - stats.referencedBytes) / 1024);
  printRow(pw,ONE_COUNT_COLUMN,""String_Node_Str"",stats.referencedBytes / 1024);
  String assetAlloc=AssetManager.getAssetAllocations();
  if (assetAlloc != null) {
    pw.println(""String_Node_Str"");
    pw.println(""String_Node_Str"");
    pw.print(assetAlloc);
  }
}"
23921,"private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  if (mBatteryLevel == 0 && isPowered(0xffffffff)) {
    ShutdownThread.shutdown(mContext,false);
  }
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}","private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  shutdownIfNoPower();
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}"
23922,"/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapter().getCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}","/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapterCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}"
23923,"/** 
 * Returns a Locale instance describing the language currently being used by the TTS engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Localeinstance, or null is the TTS engine has failed.
 */
public Locale getLanguage(){
synchronized (mStartLock) {
    if (!mStarted) {
      return null;
    }
    try {
      String[] locStrings=mITts.getLanguage();
      if (locStrings.length == 3) {
        return new Locale(locStrings[0],locStrings[1],locStrings[2]);
      }
 else {
        return null;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
    return null;
  }
}","/** 
 * Returns a Locale instance describing the language currently being used by the TTS engine.
 * @return language, country (if any) and variant (if any) used by the engine stored in a Localeinstance, or null is the TTS engine has failed.
 */
public Locale getLanguage(){
synchronized (mStartLock) {
    if (!mStarted) {
      return null;
    }
    try {
      String[] locStrings=mITts.getLanguage();
      if ((locStrings != null) && (locStrings.length == 3)) {
        return new Locale(locStrings[0],locStrings[1],locStrings[2]);
      }
 else {
        return null;
      }
    }
 catch (    RemoteException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    NullPointerException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
catch (    IllegalStateException e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
      e.printStackTrace();
      mStarted=false;
      initTts();
    }
    return null;
  }
}"
23924,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      try {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
 catch (      NullPointerException e) {
        Log.v(""String_Node_Str"",""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}"
23925,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally, except those intended to be synthesized to file.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        try {
          result=sNativeSynth.stop();
        }
 catch (        NullPointerException e1) {
          result=TextToSpeech.ERROR;
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}"
23926,"@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  stopAll(""String_Node_Str"");
  cleanUpPlayer();
  if (sNativeSynth != null) {
    sNativeSynth.shutdown();
  }
  sNativeSynth=null;
  mCallbacks.kill();
}"
23927,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
 catch (          NullPointerException e) {
            Log.v(""String_Node_Str"",""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23928,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          try {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
 catch (          NullPointerException e) {
            Log.v(""String_Node_Str"",""String_Node_Str"");
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23929,"/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapter().getCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}","/** 
 * {@link AutoCompleteTextView#onKeyPreIme(int,KeyEvent)}) dismisses the drop-down on BACK, so we must override this method to modify the BACK behavior.
 */
@Override public boolean onKeyPreIme(int keyCode,KeyEvent event){
  if (mSearchDialog.mSearchable == null) {
    return false;
  }
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
    if (mSearchDialog.backToPreviousComponent()) {
      return true;
    }
    if (isInputMethodNotNeeded() || (isEmpty() && getDropDownChildCount() >= getAdapterCount())) {
      mSearchDialog.cancel();
      return true;
    }
    return false;
  }
  return false;
}"
23930,"synchronized int getSocketError(){
  for (  DaemonProxy s : mDaemonList) {
switch (getResultFromSocket(s)) {
case 0:
      return 0;
case AUTH_ERROR_CODE:
    return VpnManager.VPN_ERROR_AUTH;
case CHALLENGE_ERROR_CODE:
  return VpnManager.VPN_ERROR_CHALLENGE;
case REMOTE_HUNG_UP_ERROR_CODE:
return VpnManager.VPN_ERROR_REMOTE_HUNG_UP;
default :
return VpnManager.VPN_ERROR_CONNECTION_FAILED;
}
}
return 0;
}","synchronized int getSocketError(){
  for (  DaemonProxy s : mDaemonList) {
switch (getResultFromSocket(s)) {
case 0:
      continue;
case AUTH_ERROR_CODE:
    return VpnManager.VPN_ERROR_AUTH;
case CHALLENGE_ERROR_CODE:
  return VpnManager.VPN_ERROR_CHALLENGE;
case REMOTE_HUNG_UP_ERROR_CODE:
return VpnManager.VPN_ERROR_REMOTE_HUNG_UP;
default :
return VpnManager.VPN_ERROR_CONNECTION_FAILED;
}
}
return 0;
}"
23931,"public void setFilename(String filename){
  mFilename=filename;
}","public void setFilename(String filename){
  if (mFilename == null || !mFilename.equals(filename)) {
    mFilename=filename;
    mCachedAttributes=null;
  }
}"
23932,"static public Allocation createSized(RenderScript rs,Element e,int count){
  int id;
  if (e.mIsPredefined) {
    id=rs.nAllocationCreatePredefSized(e.mPredefinedID,count);
  }
 else {
    id=rs.nAllocationCreateSized(e.mID,count);
  }
  return new Allocation(id,rs);
}","static public Allocation createSized(RenderScript rs,Element e,int count) throws IllegalArgumentException {
  int id;
  if (e.mIsPredefined) {
    id=rs.nAllocationCreatePredefSized(e.mPredefinedID,count);
  }
 else {
    id=rs.nAllocationCreateSized(e.mID,count);
    if (id == 0) {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
  return new Allocation(id,rs);
}"
23933,"static public Allocation createTyped(RenderScript rs,Type type){
  int id=rs.nAllocationCreateTyped(type.mID);
  return new Allocation(id,rs);
}","static public Allocation createTyped(RenderScript rs,Type type) throws IllegalArgumentException {
  if (type.mID == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  int id=rs.nAllocationCreateTyped(type.mID);
  return new Allocation(id,rs);
}"
23934,"BaseObj(RenderScript rs){
  mRS=rs;
  mID=0;
}","BaseObj(RenderScript rs){
  mRS=rs;
  mID=0;
  mDestroyed=false;
}"
23935,"protected void finalize() throws Throwable {
  if (mID != 0) {
    Log.v(RenderScript.LOG_TAG,""String_Node_Str"");
  }
  super.finalize();
}","protected void finalize() throws Throwable {
  if (!mDestroyed) {
    Log.v(RenderScript.LOG_TAG,""String_Node_Str"");
  }
  super.finalize();
}"
23936,"public void destroy() throws IllegalStateException {
  if (mIsPredefined) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mRS.nElementDestroy(mID);
  mID=0;
}","public void destroy() throws IllegalStateException {
  if (mIsPredefined) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nElementDestroy(mID);
}"
23937,"static synchronized Element internalCreate(RenderScript rs,Builder b){
  rs.nElementBegin();
  for (int ct=0; ct < b.mEntryCount; ct++) {
    Entry en=b.mEntries[ct];
    if (en.mElement != null) {
      rs.nElementAddPredefined(en.mElement.mPredefinedID);
    }
 else {
      int norm=0;
      if (en.mIsNormalized) {
        norm=1;
      }
      rs.nElementAdd(en.mType.mID,en.mKind.mID,norm,en.mBits);
    }
  }
  int id=rs.nElementCreate();
  return new Element(id,rs);
}","static synchronized Element internalCreate(RenderScript rs,Builder b){
  rs.nElementBegin();
  for (int ct=0; ct < b.mEntryCount; ct++) {
    Entry en=b.mEntries[ct];
    if (en.mElement != null) {
      rs.nElementAddPredefined(en.mElement.mPredefinedID);
    }
 else {
      int norm=0;
      if (en.mIsNormalized) {
        norm=1;
      }
      rs.nElementAdd(en.mKind.mID,en.mType.mID,norm,en.mBits);
    }
  }
  int id=rs.nElementCreate();
  return new Element(id,rs);
}"
23938,"public void destroy(){
  mRS.nProgramFragmentStoreDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nProgramFragmentStoreDestroy(mID);
}"
23939,"public void destroy(){
  mRS.nProgramFragmentStoreDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nProgramFragmentStoreDestroy(mID);
}"
23940,"public void destroy(){
  mRS.nScriptDestroy(mID);
  mID=0;
}","public void destroy(){
  if (mDestroyed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  mDestroyed=true;
  mRS.nScriptDestroy(mID);
}"
23941,"private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPerms(deletedPs);
    }
    mSettings.writeLP();
  }
}","private void removePackageDataLI(PackageParser.Package p,PackageRemovedInfo outInfo,int flags){
  String packageName=p.packageName;
  if (outInfo != null) {
    outInfo.removedPackage=packageName;
  }
  removePackageLI(p,true);
  PackageSetting deletedPs;
synchronized (mPackages) {
    deletedPs=mSettings.mPackages.get(packageName);
  }
  if ((flags & PackageManager.DONT_DELETE_DATA) == 0) {
    if (mInstaller != null) {
      int retCode=mInstaller.remove(packageName);
      if (retCode < 0) {
        Log.w(TAG,""String_Node_Str"" + packageName + ""String_Node_Str""+ retCode);
      }
    }
 else {
      PackageParser.Package pkg=mPackages.get(packageName);
      File dataDir=new File(pkg.applicationInfo.dataDir);
      dataDir.delete();
    }
synchronized (mPackages) {
      if (outInfo != null) {
        outInfo.removedUid=mSettings.removePackageLP(packageName);
      }
    }
  }
synchronized (mPackages) {
    if ((deletedPs != null) && (deletedPs.sharedUser != null)) {
      mSettings.updateSharedUserPermsLP(deletedPs,mGlobalGids);
    }
    mSettings.writeLP();
  }
}"
23942,"private void handleExitEmergencyCallbackMode(Message msg){
  Log.d(LOG_TAG,""String_Node_Str"");
  AsyncResult ar=(AsyncResult)msg.obj;
  h.removeCallbacks(mExitEcmRunnable);
  if (mECMExitRespRegistrant != null) {
    mECMExitRespRegistrant.notifyRegistrant(ar);
  }
  if (ar.exception == null) {
    if (mIsPhoneInECMState) {
      mIsPhoneInECMState=false;
      setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE,""String_Node_Str"");
    }
    sendEmergencyCallbackModeChange();
  }
}","private void handleExitEmergencyCallbackMode(Message msg){
  Log.d(LOG_TAG,""String_Node_Str"");
  AsyncResult ar=(AsyncResult)msg.obj;
  h.removeCallbacks(mExitEcmRunnable);
  if (mECMExitRespRegistrant != null) {
    mECMExitRespRegistrant.notifyRegistrant(ar);
  }
  if (ar.exception == null) {
    if (mIsPhoneInECMState) {
      mIsPhoneInECMState=false;
      setSystemProperty(TelephonyProperties.PROPERTY_INECM_MODE,""String_Node_Str"");
    }
    sendEmergencyCallbackModeChange();
    mDataConnection.setDataEnabled(true);
  }
}"
23943,"private void removeMulticasterLocked(int i,int uid){
  Multicaster removed=mMulticasters.remove(i);
  if (removed != null) {
    removed.unlinkDeathRecipient();
  }
  if (mMulticasters.size() == 0) {
    WifiNative.startPacketFiltering();
  }
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastDisabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}","private void removeMulticasterLocked(int i,int uid){
  Multicaster removed=mMulticasters.remove(i);
  if (removed != null) {
    removed.unlinkDeathRecipient();
  }
  if (mMulticasters.size() == 0) {
synchronized (mWifiStateTracker) {
      WifiNative.startPacketFiltering();
    }
  }
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastDisabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
23944,"public void acquireMulticastLock(IBinder binder,String tag){
  enforceMulticastChangePermission();
synchronized (mMulticasters) {
    mMulticastEnabled++;
    mMulticasters.add(new Multicaster(tag,binder));
    WifiNative.stopPacketFiltering();
  }
  int uid=Binder.getCallingUid();
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastEnabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}","public void acquireMulticastLock(IBinder binder,String tag){
  enforceMulticastChangePermission();
synchronized (mMulticasters) {
    mMulticastEnabled++;
    mMulticasters.add(new Multicaster(tag,binder));
synchronized (mWifiStateTracker) {
      WifiNative.stopPacketFiltering();
    }
  }
  int uid=Binder.getCallingUid();
  Long ident=Binder.clearCallingIdentity();
  try {
    mBatteryStats.noteWifiMulticastEnabled(uid);
  }
 catch (  RemoteException e) {
  }
 finally {
    Binder.restoreCallingIdentity(ident);
  }
}"
23945,"@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}","@Override public void onUpgrade(SQLiteDatabase db,int oldVersion,int currentVersion){
  Log.w(TAG,""String_Node_Str"" + oldVersion + ""String_Node_Str""+ currentVersion);
  int upgradeVersion=oldVersion;
  if (upgradeVersion == 20) {
    loadVibrateSetting(db,true);
    if (Config.LOGD)     Log.d(TAG,""String_Node_Str"");
    upgradeVersion=21;
  }
  if (upgradeVersion < 22) {
    upgradeVersion=22;
    upgradeLockPatternLocation(db);
  }
  if (upgradeVersion < 23) {
    db.execSQL(""String_Node_Str"");
    upgradeVersion=23;
  }
  if (upgradeVersion == 23) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=24;
  }
  if (upgradeVersion == 24) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + ConnectivityManager.DEFAULT_NETWORK_PREFERENCE + ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=25;
  }
  if (upgradeVersion == 25) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=26;
  }
  if (upgradeVersion == 26) {
    db.beginTransaction();
    try {
      createSecureTable(db);
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=27;
  }
  if (upgradeVersion == 27) {
    SQLiteStatement insertStmt=null;
    SQLiteStatement deleteStmt=null;
    db.beginTransaction();
    try {
      insertStmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      deleteStmt=db.compileStatement(""String_Node_Str"");
      String[] settingsToMove={Settings.Secure.ADB_ENABLED,Settings.Secure.ANDROID_ID,Settings.Secure.BLUETOOTH_ON,Settings.Secure.DATA_ROAMING,Settings.Secure.DEVICE_PROVISIONED,Settings.Secure.HTTP_PROXY,Settings.Secure.INSTALL_NON_MARKET_APPS,Settings.Secure.LOCATION_PROVIDERS_ALLOWED,Settings.Secure.LOGGING_ID,Settings.Secure.NETWORK_PREFERENCE,Settings.Secure.PARENTAL_CONTROL_ENABLED,Settings.Secure.PARENTAL_CONTROL_LAST_UPDATE,Settings.Secure.PARENTAL_CONTROL_REDIRECT_URL,Settings.Secure.SETTINGS_CLASSNAME,Settings.Secure.USB_MASS_STORAGE_ENABLED,Settings.Secure.USE_GOOGLE_MAIL,Settings.Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,Settings.Secure.WIFI_NETWORKS_AVAILABLE_REPEAT_DELAY,Settings.Secure.WIFI_NUM_OPEN_NETWORKS_KEPT,Settings.Secure.WIFI_ON,Settings.Secure.WIFI_WATCHDOG_ACCEPTABLE_PACKET_LOSS_PERCENTAGE,Settings.Secure.WIFI_WATCHDOG_AP_COUNT,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_ENABLED,Settings.Secure.WIFI_WATCHDOG_BACKGROUND_CHECK_TIMEOUT_MS,Settings.Secure.WIFI_WATCHDOG_INITIAL_IGNORED_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_MAX_AP_CHECKS,Settings.Secure.WIFI_WATCHDOG_ON,Settings.Secure.WIFI_WATCHDOG_PING_COUNT,Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS};
      for (      String setting : settingsToMove) {
        insertStmt.bindString(1,setting);
        insertStmt.execute();
        deleteStmt.bindString(1,setting);
        deleteStmt.execute();
      }
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
      if (insertStmt != null) {
        insertStmt.close();
      }
      if (deleteStmt != null) {
        deleteStmt.close();
      }
    }
    upgradeVersion=28;
  }
  if (upgradeVersion == 28 || upgradeVersion == 29) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=30;
  }
  if (upgradeVersion == 30) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=31;
  }
  if (upgradeVersion == 31) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.WINDOW_ANIMATION_SCALE + ""String_Node_Str"");
      db.execSQL(""String_Node_Str"" + Settings.System.TRANSITION_ANIMATION_SCALE + ""String_Node_Str"");
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadDefaultAnimationSettings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=32;
  }
  if (upgradeVersion == 32) {
    String wifiWatchList=SystemProperties.get(""String_Node_Str"");
    if (!TextUtils.isEmpty(wifiWatchList)) {
      db.beginTransaction();
      try {
        db.execSQL(""String_Node_Str"" + Settings.Secure.WIFI_WATCHDOG_WATCH_LIST + ""String_Node_Str""+ wifiWatchList+ ""String_Node_Str"");
        db.setTransactionSuccessful();
      }
  finally {
        db.endTransaction();
      }
    }
    upgradeVersion=33;
  }
  if (upgradeVersion == 33) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=34;
  }
  if (upgradeVersion == 34) {
    db.beginTransaction();
    try {
      String value=mContext.getResources().getBoolean(R.bool.assisted_gps_enabled) ? ""String_Node_Str"" : ""String_Node_Str"";
      db.execSQL(""String_Node_Str"" + Settings.Secure.ASSISTED_GPS_ENABLED + ""String_Node_Str""+ value+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=35;
  }
  if (upgradeVersion == 35) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadSecure35Settings(stmt);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=36;
  }
  if (upgradeVersion == 36) {
    db.beginTransaction();
    try {
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str"");
      int newValue=(1 << AudioManager.STREAM_RING) | (1 << AudioManager.STREAM_NOTIFICATION) | (1 << AudioManager.STREAM_SYSTEM)| (1 << AudioManager.STREAM_SYSTEM_ENFORCED);
      db.execSQL(""String_Node_Str"" + Settings.System.MODE_RINGER_STREAMS_AFFECTED + ""String_Node_Str""+ String.valueOf(newValue)+ ""String_Node_Str"");
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=37;
  }
  if (upgradeVersion == 37) {
    db.beginTransaction();
    try {
      SQLiteStatement stmt=db.compileStatement(""String_Node_Str"" + ""String_Node_Str"");
      loadStringSetting(stmt,Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS,R.string.airplane_mode_toggleable_radios);
      stmt.close();
      db.setTransactionSuccessful();
    }
  finally {
      db.endTransaction();
    }
    upgradeVersion=38;
  }
  if (upgradeVersion != currentVersion) {
    Log.w(TAG,""String_Node_Str"" + upgradeVersion + ""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    db.execSQL(""String_Node_Str"");
    onCreate(db);
  }
}"
23946,"public void data(float[] d){
  mRS.nAdapter1DData(mID,d);
}","public void data(float[] d){
  mRS.nAdapter2DData(mID,d);
}"
23947,"public void destroy(){
  mRS.nAdapter1DDestroy(mID);
  mID=0;
}","public void destroy(){
  mRS.nAdapter2DDestroy(mID);
  mID=0;
}"
23948,"public void setConstraint(Dimension dim,int value){
  mRS.nAdapter1DSetConstraint(mID,dim.mID,value);
}","public void setConstraint(Dimension dim,int value){
  mRS.nAdapter2DSetConstraint(mID,dim.mID,value);
}"
23949,"public void subData(int off,int count,float[] d){
  mRS.nAdapter1DSubData(mID,off,count,d);
}","public void subData(int xoff,int yoff,int w,int h,float[] d){
  mRS.nAdapter2DSubData(mID,xoff,yoff,w,h,d);
}"
23950,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}"
23951,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}"
23952,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}"
23953,"@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}"
23954,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23955,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23956,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}"
23957,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}"
23958,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}"
23959,"@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}"
23960,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23961,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23962,"public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}","public void run(){
  boolean synthAvailable=false;
  String utteranceId=""String_Node_Str"";
  Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
  try {
    synthAvailable=synthesizerLock.tryLock();
    if (!synthAvailable) {
      Thread.sleep(100);
      Thread synth=(new Thread(new SynthThread()));
      synth.start();
      return;
    }
    String language=""String_Node_Str"";
    String country=""String_Node_Str"";
    String variant=""String_Node_Str"";
    String speechRate=""String_Node_Str"";
    if (speechItem.mParams != null) {
      for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
        String param=speechItem.mParams.get(i);
        if (param != null) {
          if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
            speechRate=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
            language=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
            country=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
            variant=speechItem.mParams.get(i + 1);
          }
 else           if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
            utteranceId=speechItem.mParams.get(i + 1);
          }
        }
      }
    }
    if (mKillList.get(speechItem) == null) {
      if (language.length() > 0) {
        setLanguage(""String_Node_Str"",language,country,variant);
      }
      if (speechRate.length() > 0) {
        setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
      }
      if (!sIsKillingSynth) {
        sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
      }
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (utteranceId.length() > 0) {
      dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
    }
    if (synthAvailable) {
      synthesizerLock.unlock();
    }
    processSpeechQueue();
  }
}"
23963,"/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        result=sNativeSynth.stop();
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}","/** 
 * Stops all speech output and removes any utterances still in the queue globally.
 */
private int stopAll(String callingApp){
  int result=TextToSpeech.ERROR;
  boolean speechQueueAvailable=false;
  try {
    speechQueueAvailable=speechQueueLock.tryLock(SPEECHQUEUELOCK_TIMEOUT,TimeUnit.MILLISECONDS);
    if (speechQueueAvailable) {
      for (int i=mSpeechQueue.size() - 1; i > -1; i--) {
        if (mSpeechQueue.get(i).mType != SpeechItem.TEXT_TO_FILE) {
          mSpeechQueue.remove(i);
        }
      }
      if ((mCurrentSpeechItem != null) && ((mCurrentSpeechItem.mType != SpeechItem.TEXT_TO_FILE) || mCurrentSpeechItem.mCallingApp.equals(callingApp))) {
        if (sIsKillingSynth) {
          Log.v(""String_Node_Str"",""String_Node_Str"");
          result=TextToSpeech.ERROR;
        }
 else {
          result=sNativeSynth.stop();
        }
        mKillList.put(mCurrentSpeechItem,true);
        if (mPlayer != null) {
          try {
            mPlayer.stop();
          }
 catch (          IllegalStateException e) {
          }
        }
        mIsSpeaking=false;
        mCurrentSpeechItem=null;
      }
 else {
        result=TextToSpeech.SUCCESS;
      }
      Log.i(""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (speechQueueAvailable) {
      speechQueueLock.unlock();
    }
    return result;
  }
}"
23964,"@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}","@Override public void onCreate(){
  super.onCreate();
  Log.i(""String_Node_Str"",""String_Node_Str"");
  mResolver=getContentResolver();
  String soLibPath=""String_Node_Str"";
  if (sNativeSynth == null) {
    sNativeSynth=new SynthProxy(soLibPath);
    sIsKillingSynth=false;
  }
  mSelf=this;
  mIsSpeaking=false;
  mEarcons=new HashMap<String,SoundResource>();
  mUtterances=new HashMap<String,SoundResource>();
  mCallbacksMap=new HashMap<String,android.speech.tts.ITtsCallback>();
  mSpeechQueue=new ArrayList<SpeechItem>();
  mPlayer=null;
  mCurrentSpeechItem=null;
  mKillList=new HashMap<SpeechItem,Boolean>();
  setDefaultSettings();
}"
23965,"@Override public void onDestroy(){
  super.onDestroy();
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}","@Override public void onDestroy(){
  super.onDestroy();
  sIsKillingSynth=true;
  Log.i(""String_Node_Str"",""String_Node_Str"");
  cleanUpPlayer();
  sNativeSynth.shutdown();
  sNativeSynth=null;
  mCallbacks.kill();
}"
23966,"private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void synthToFileInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      Log.i(""String_Node_Str"",""String_Node_Str"" + speechItem.mFilename);
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.synthesizeToFile(speechItem.mText,speechItem.mFilename);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23967,"private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          sNativeSynth.speak(speechItem.mText,streamType);
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}","private void speakInternalOnly(final SpeechItem speechItem){
class SynthThread implements Runnable {
    public void run(){
      boolean synthAvailable=false;
      String utteranceId=""String_Node_Str"";
      try {
        synthAvailable=synthesizerLock.tryLock();
        if (!synthAvailable) {
          Thread.sleep(100);
          Thread synth=(new Thread(new SynthThread()));
          synth.start();
          return;
        }
        int streamType=DEFAULT_STREAM_TYPE;
        String language=""String_Node_Str"";
        String country=""String_Node_Str"";
        String variant=""String_Node_Str"";
        String speechRate=""String_Node_Str"";
        if (speechItem.mParams != null) {
          for (int i=0; i < speechItem.mParams.size() - 1; i=i + 2) {
            String param=speechItem.mParams.get(i);
            if (param != null) {
              if (param.equals(TextToSpeech.Engine.KEY_PARAM_RATE)) {
                speechRate=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_LANGUAGE)) {
                language=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_COUNTRY)) {
                country=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_VARIANT)) {
                variant=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID)) {
                utteranceId=speechItem.mParams.get(i + 1);
              }
 else               if (param.equals(TextToSpeech.Engine.KEY_PARAM_STREAM)) {
                try {
                  streamType=Integer.parseInt(speechItem.mParams.get(i + 1));
                }
 catch (                NumberFormatException e) {
                  streamType=DEFAULT_STREAM_TYPE;
                }
              }
            }
          }
        }
        if (mKillList.get(speechItem) == null) {
          if (language.length() > 0) {
            setLanguage(""String_Node_Str"",language,country,variant);
          }
          if (speechRate.length() > 0) {
            setSpeechRate(""String_Node_Str"",Integer.parseInt(speechRate));
          }
          if (!sIsKillingSynth) {
            sNativeSynth.speak(speechItem.mText,streamType);
          }
        }
      }
 catch (      InterruptedException e) {
        Log.e(""String_Node_Str"",""String_Node_Str"");
        e.printStackTrace();
      }
 finally {
        if (utteranceId.length() > 0) {
          dispatchUtteranceCompletedCallback(utteranceId,speechItem.mCallingApp);
        }
        if (synthAvailable) {
          synthesizerLock.unlock();
        }
        processSpeechQueue();
      }
    }
  }
  Thread synth=(new Thread(new SynthThread()));
  synth.start();
}"
23968,"private static Integer signalParamHash(int signalType,int alertPitch,int signal){
  if ((signalType < 0) || (signalType > 256) || (alertPitch > 256)|| (alertPitch < 0)|| (signal > 256)|| (signal < 0)) {
    return new Integer(CDMA_INVALID_TONE);
  }
  return new Integer(signalType * 256 * 256 + alertPitch * 256 + signal);
}","private static Integer signalParamHash(int signalType,int alertPitch,int signal){
  if ((signalType < 0) || (signalType > 256) || (alertPitch > 256)|| (alertPitch < 0)|| (signal > 256)|| (signal < 0)) {
    return new Integer(CDMA_INVALID_TONE);
  }
  if (signalType != IS95_CONST_IR_SIGNAL_IS54B) {
    alertPitch=TAPIAMSSCDMA_SIGNAL_PITCH_UNKNOWN;
  }
  return new Integer(signalType * 256 * 256 + alertPitch * 256 + signal);
}"
23969,"/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user.
 */
public void handleSslErrorRequest(SslError error){
  int primaryError=error.getPrimaryError();
  if (Config.LOGV) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + primaryError + ""String_Node_Str""+ error.getCertificate());
  }
  eventsReceived[TEST_SSL_CERTIFICATE_ERROR]=true;
  if (notExpecting[TEST_SSL_CERTIFICATE_ERROR]) {
    expectDetails.append(""String_Node_Str"" + ""String_Node_Str"");
    expectDetails.append(""String_Node_Str"");
  }
  if (expectSslErrors != -1) {
    if (expectSslErrors == primaryError) {
      expectSslErrors=-1;
    }
 else {
      expectDetails.append(""String_Node_Str"" + expectSslErrors + ""String_Node_Str""+ primaryError);
      expectDetails.append(""String_Node_Str"");
    }
  }
  if (expectSslErrors == -1)   expects[TEST_SSL_CERTIFICATE_ERROR]=false;
}","/** 
 * SSL certificate error callback. Handles SSL error(s) on the way up to the user.
 */
public boolean handleSslErrorRequest(SslError error){
  int primaryError=error.getPrimaryError();
  if (Config.LOGV) {
    Log.v(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + primaryError + ""String_Node_Str""+ error.getCertificate());
  }
  eventsReceived[TEST_SSL_CERTIFICATE_ERROR]=true;
  if (notExpecting[TEST_SSL_CERTIFICATE_ERROR]) {
    expectDetails.append(""String_Node_Str"" + ""String_Node_Str"");
    expectDetails.append(""String_Node_Str"");
  }
  if (expectSslErrors != -1) {
    if (expectSslErrors == primaryError) {
      expectSslErrors=-1;
    }
 else {
      expectDetails.append(""String_Node_Str"" + expectSslErrors + ""String_Node_Str""+ primaryError);
      expectDetails.append(""String_Node_Str"");
    }
  }
  if (expectSslErrors == -1)   expects[TEST_SSL_CERTIFICATE_ERROR]=false;
  return false;
}"
23970,"private void setContentScrollBy(int cx,int cy,boolean animate){
  if (mDrawHistory) {
    return;
  }
  cx=contentToView(cx);
  cy=contentToView(cy);
  if (mHeightCanMeasure) {
    if (cy != 0) {
      Rect tempRect=new Rect();
      calcOurVisibleRect(tempRect);
      tempRect.offset(cx,cy);
      requestRectangleOnScreen(tempRect);
    }
    if (cy == 0 && cx != 0) {
      pinScrollBy(cx,0,animate,0);
    }
  }
 else {
    pinScrollBy(cx,cy,animate,0);
  }
}","private boolean setContentScrollBy(int cx,int cy,boolean animate){
  if (mDrawHistory) {
    return false;
  }
  cx=contentToView(cx);
  cy=contentToView(cy);
  if (mHeightCanMeasure) {
    if (cy != 0) {
      Rect tempRect=new Rect();
      calcOurVisibleRect(tempRect);
      tempRect.offset(cx,cy);
      requestRectangleOnScreen(tempRect);
    }
    return cy == 0 && cx != 0 && pinScrollBy(cx,0,animate,0);
  }
 else {
    return pinScrollBy(cx,cy,animate,0);
  }
}"
23971,"@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
try {
mHomeSystemId=sid.length > 0 ? Integer.parseInt(sid[0]) : 0;
}
 catch (NumberFormatException e) {
mHomeSystemId=0;
}
}
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
try {
mHomeNetworkId=nid.length > 0 ? Integer.parseInt(nid[0]) : 0;
}
 catch (NumberFormatException e) {
mHomeNetworkId=0;
}
}
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}","@Override public void handleMessage(Message msg){
  AsyncResult ar;
  int[] ints;
  String[] strings;
switch (msg.what) {
case EVENT_RADIO_AVAILABLE:
    break;
case EVENT_RUIM_READY:
  isSubscriptionFromRuim=true;
if (mNeedToRegForRuimLoaded) {
  phone.mRuimRecords.registerForRecordsLoaded(this,EVENT_RUIM_RECORDS_LOADED,null);
  mNeedToRegForRuimLoaded=false;
}
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
if (DBG) log(""String_Node_Str"");
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_NV_READY:
isSubscriptionFromRuim=false;
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
pollState();
queueNextSignalStrengthPoll();
break;
case EVENT_RADIO_STATE_CHANGED:
setPowerStateToDesired();
pollState();
break;
case EVENT_NETWORK_STATE_CHANGED_CDMA:
pollState();
break;
case EVENT_GET_SIGNAL_STRENGTH:
if (!(cm.getRadioState().isOn()) || (cm.getRadioState().isGsm())) {
return;
}
ar=(AsyncResult)msg.obj;
onSignalStrengthResult(ar);
queueNextSignalStrengthPoll();
break;
case EVENT_GET_LOC_DONE_CDMA:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String states[]=(String[])ar.result;
int baseStationId=-1;
int baseStationLongitude=-1;
int baseStationLatitude=-1;
int baseStationData[]={-1,-1,-1};
if (states.length == 3) {
for (int i=0; i < states.length; i++) {
try {
if (states[i] != null && states[i].length() > 0) {
baseStationData[i]=Integer.parseInt(states[i],16);
}
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
}
if (cellLoc.getBaseStationId() != baseStationData[0] || cellLoc.getBaseStationLatitude() != baseStationData[1] || cellLoc.getBaseStationLongitude() != baseStationData[2]) {
cellLoc.setCellLocationData(baseStationData[0],baseStationData[1],baseStationData[2]);
phone.notifyLocationChanged();
}
}
if (ar.userObj != null) {
AsyncResult.forMessage(((Message)ar.userObj)).exception=ar.exception;
((Message)ar.userObj).sendToTarget();
}
break;
case EVENT_POLL_STATE_REGISTRATION_CDMA:
case EVENT_POLL_STATE_OPERATOR_CDMA:
ar=(AsyncResult)msg.obj;
handlePollStateResult(msg.what,ar);
break;
case EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
String cdmaSubscription[]=(String[])ar.result;
if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
mMdn=cdmaSubscription[0];
if (cdmaSubscription[1] != null) {
String[] sid=cdmaSubscription[1].split(""String_Node_Str"");
mHomeSystemId=new int[sid.length];
for (int i=0; i < sid.length; i++) {
try {
mHomeSystemId[i]=Integer.parseInt(sid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[1]);
if (cdmaSubscription[2] != null) {
String[] nid=cdmaSubscription[2].split(""String_Node_Str"");
mHomeNetworkId=new int[nid.length];
for (int i=0; i < nid.length; i++) {
try {
mHomeNetworkId[i]=Integer.parseInt(nid[i]);
}
 catch (NumberFormatException ex) {
Log.e(LOG_TAG,""String_Node_Str"",ex);
}
}
}
Log.d(LOG_TAG,""String_Node_Str"" + cdmaSubscription[2]);
mMin=cdmaSubscription[3];
mPrlVersion=cdmaSubscription[4];
Log.d(LOG_TAG,""String_Node_Str"" + mMdn);
}
 else {
Log.w(LOG_TAG,""String_Node_Str"" + cdmaSubscription.length);
}
}
break;
case EVENT_POLL_SIGNAL_STRENGTH:
cm.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
break;
case EVENT_NITZ_TIME:
ar=(AsyncResult)msg.obj;
String nitzString=(String)((Object[])ar.result)[0];
long nitzReceiveTime=((Long)((Object[])ar.result)[1]).longValue();
setTimeFromNITZString(nitzString,nitzReceiveTime);
break;
case EVENT_SIGNAL_STRENGTH_UPDATE:
ar=(AsyncResult)msg.obj;
dontPollSignalStrength=true;
onSignalStrengthResult(ar);
break;
case EVENT_RUIM_RECORDS_LOADED:
updateSpnDisplay();
break;
case EVENT_LOCATION_UPDATES_ENABLED:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
getLacAndCid(null);
}
break;
case EVENT_ERI_FILE_LOADED:
if (DBG) log(""String_Node_Str"");
pollState();
break;
case EVENT_OTA_PROVISION_STATUS_CHANGE:
ar=(AsyncResult)msg.obj;
if (ar.exception == null) {
ints=(int[])ar.result;
int otaStatus=ints[0];
if (otaStatus == phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
Log.d(LOG_TAG,""String_Node_Str"");
cm.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
}
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + msg.what);
break;
}
}"
23972,"/** 
 * Handle the result of one of the pollState()-related requests
 */
@Override protected void handlePollStateResult(int what,AsyncResult ar){
  int ints[];
  String states[];
  if (ar.userObj != pollingContext)   return;
  if (ar.exception != null) {
    CommandException.Error err=null;
    if (ar.exception instanceof CommandException) {
      err=((CommandException)(ar.exception)).getCommandError();
    }
    if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
      cancelPollState();
      return;
    }
    if (!cm.getRadioState().isOn()) {
      cancelPollState();
      return;
    }
    if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW && err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
      Log.e(LOG_TAG,""String_Node_Str"",ar.exception);
    }
  }
 else   try {
switch (what) {
case EVENT_POLL_STATE_REGISTRATION_CDMA:
      states=(String[])ar.result;
    int registrationState=4;
  int radioTechnology=-1;
int baseStationId=-1;
int baseStationLatitude=-1;
int baseStationLongitude=-1;
int cssIndicator=0;
int systemId=0;
int networkId=0;
int roamingIndicator=-1;
int systemIsInPrl=0;
int defaultRoamingIndicator=0;
int reasonForDenial=0;
if (states.length == 14) {
try {
registrationState=Integer.parseInt(states[0]);
radioTechnology=Integer.parseInt(states[3]);
baseStationId=Integer.parseInt(states[4]);
baseStationLatitude=Integer.parseInt(states[5],16);
baseStationLongitude=Integer.parseInt(states[6],16);
cssIndicator=Integer.parseInt(states[7]);
systemId=Integer.parseInt(states[8]);
networkId=Integer.parseInt(states[9]);
roamingIndicator=Integer.parseInt(states[10]);
systemIsInPrl=Integer.parseInt(states[11]);
defaultRoamingIndicator=Integer.parseInt(states[12]);
reasonForDenial=Integer.parseInt(states[13]);
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
 else {
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + states.length);
}
mRegistrationState=registrationState;
mCdmaRoaming=regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
newSS.setState(regCodeToServiceState(registrationState));
this.newCdmaDataConnectionState=radioTechnologyToDataServiceState(radioTechnology);
newSS.setRadioTechnology(radioTechnology);
newNetworkType=radioTechnology;
newSS.setCssIndicator(cssIndicator);
newSS.setSystemAndNetworkId(systemId,networkId);
mRoamingIndicator=roamingIndicator;
mIsInPrl=(systemIsInPrl == 0) ? false : true;
mDefaultRoamingIndicator=defaultRoamingIndicator;
newCellLoc.setCellLocationData(baseStationId,baseStationLatitude,baseStationLongitude,systemId,networkId);
if (reasonForDenial == 0) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_GEN;
}
 else if (reasonForDenial == 1) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_AUTH;
}
 else {
mRegistrationDeniedReason=""String_Node_Str"";
}
if (mRegistrationState == 3) {
if (DBG) log(""String_Node_Str"" + mRegistrationDeniedReason);
}
break;
case EVENT_POLL_STATE_OPERATOR_CDMA:
String opNames[]=(String[])ar.result;
if (opNames != null && opNames.length >= 3) {
if (cm.getRadioState().isNVReady()) {
newSS.setOperatorName(null,opNames[1],opNames[2]);
}
 else {
newSS.setOperatorName(opNames[0],opNames[1],opNames[2]);
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"");
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"");
break;
}
}
 catch (RuntimeException ex) {
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"",ex);
}
pollingContext[0]--;
if (pollingContext[0] == 0) {
boolean namMatch=false;
if ((mHomeSystemId != 0) && (mHomeSystemId == newSS.getSystemId())) {
namMatch=true;
}
if (isSubscriptionFromRuim) {
newSS.setRoaming(isRoamingBetweenOperators(mCdmaRoaming,newSS));
}
 else {
newSS.setRoaming(mCdmaRoaming);
}
if (mIsInPrl) {
if (namMatch && (mRoamingIndicator <= 2)) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
}
 else {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
}
 else {
if (mRegistrationState == 5) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else {
}
}
newSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
if (DBG) {
log(""String_Node_Str"" + newSS.getCdmaRoamingIndicator() + ""String_Node_Str""+ mCdmaRoaming+ ""String_Node_Str""+ namMatch+ ""String_Node_Str""+ mIsInPrl+ ""String_Node_Str""+ mRoamingIndicator+ ""String_Node_Str""+ mDefaultRoamingIndicator);
}
pollStateDone();
}
}","/** 
 * Handle the result of one of the pollState()-related requests
 */
@Override protected void handlePollStateResult(int what,AsyncResult ar){
  int ints[];
  String states[];
  if (ar.userObj != pollingContext)   return;
  if (ar.exception != null) {
    CommandException.Error err=null;
    if (ar.exception instanceof CommandException) {
      err=((CommandException)(ar.exception)).getCommandError();
    }
    if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
      cancelPollState();
      return;
    }
    if (!cm.getRadioState().isOn()) {
      cancelPollState();
      return;
    }
    if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW && err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
      Log.e(LOG_TAG,""String_Node_Str"",ar.exception);
    }
  }
 else   try {
switch (what) {
case EVENT_POLL_STATE_REGISTRATION_CDMA:
      states=(String[])ar.result;
    int registrationState=4;
  int radioTechnology=-1;
int baseStationId=-1;
int baseStationLatitude=-1;
int baseStationLongitude=-1;
int cssIndicator=0;
int systemId=0;
int networkId=0;
int roamingIndicator=-1;
int systemIsInPrl=0;
int defaultRoamingIndicator=0;
int reasonForDenial=0;
if (states.length == 14) {
try {
registrationState=Integer.parseInt(states[0]);
radioTechnology=Integer.parseInt(states[3]);
baseStationId=Integer.parseInt(states[4]);
baseStationLatitude=Integer.parseInt(states[5],16);
baseStationLongitude=Integer.parseInt(states[6],16);
cssIndicator=Integer.parseInt(states[7]);
systemId=Integer.parseInt(states[8]);
networkId=Integer.parseInt(states[9]);
roamingIndicator=Integer.parseInt(states[10]);
systemIsInPrl=Integer.parseInt(states[11]);
defaultRoamingIndicator=Integer.parseInt(states[12]);
reasonForDenial=Integer.parseInt(states[13]);
}
 catch (NumberFormatException ex) {
Log.w(LOG_TAG,""String_Node_Str"" + ex);
}
}
 else {
throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + states.length);
}
mRegistrationState=registrationState;
mCdmaRoaming=regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
newSS.setState(regCodeToServiceState(registrationState));
this.newCdmaDataConnectionState=radioTechnologyToDataServiceState(radioTechnology);
newSS.setRadioTechnology(radioTechnology);
newNetworkType=radioTechnology;
newSS.setCssIndicator(cssIndicator);
newSS.setSystemAndNetworkId(systemId,networkId);
mRoamingIndicator=roamingIndicator;
mIsInPrl=(systemIsInPrl == 0) ? false : true;
mDefaultRoamingIndicator=defaultRoamingIndicator;
newCellLoc.setCellLocationData(baseStationId,baseStationLatitude,baseStationLongitude,systemId,networkId);
if (reasonForDenial == 0) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_GEN;
}
 else if (reasonForDenial == 1) {
mRegistrationDeniedReason=ServiceStateTracker.REGISTRATION_DENIED_AUTH;
}
 else {
mRegistrationDeniedReason=""String_Node_Str"";
}
if (mRegistrationState == 3) {
if (DBG) log(""String_Node_Str"" + mRegistrationDeniedReason);
}
break;
case EVENT_POLL_STATE_OPERATOR_CDMA:
String opNames[]=(String[])ar.result;
if (opNames != null && opNames.length >= 3) {
if (cm.getRadioState().isNVReady()) {
newSS.setOperatorName(null,opNames[1],opNames[2]);
}
 else {
newSS.setOperatorName(opNames[0],opNames[1],opNames[2]);
}
}
 else {
Log.w(LOG_TAG,""String_Node_Str"");
}
break;
default :
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"");
break;
}
}
 catch (RuntimeException ex) {
Log.e(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"",ex);
}
pollingContext[0]--;
if (pollingContext[0] == 0) {
boolean namMatch=false;
if (!isSidsAllZeros() && isHomeSid(newSS.getSystemId())) {
namMatch=true;
}
if (isSubscriptionFromRuim) {
newSS.setRoaming(isRoamingBetweenOperators(mCdmaRoaming,newSS));
}
 else {
newSS.setRoaming(mCdmaRoaming);
}
newSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
boolean isPrlLoaded=true;
if (TextUtils.isEmpty(mPrlVersion)) {
isPrlLoaded=false;
}
if (!isPrlLoaded) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else if (!isSidsAllZeros()) {
if (!namMatch && !mIsInPrl) {
newSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
}
 else if (namMatch && !mIsInPrl) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
}
 else if (!namMatch && mIsInPrl) {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
 else {
if ((mRoamingIndicator <= 2)) {
newSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
}
 else {
newSS.setCdmaRoamingIndicator(mRoamingIndicator);
}
}
}
if (DBG) {
log(""String_Node_Str"" + newSS.getCdmaRoamingIndicator() + ""String_Node_Str""+ mCdmaRoaming+ ""String_Node_Str""+ isPrlLoaded+ ""String_Node_Str""+ namMatch+ ""String_Node_Str""+ mIsInPrl+ ""String_Node_Str""+ mRoamingIndicator+ ""String_Node_Str""+ mDefaultRoamingIndicator);
}
pollStateDone();
}
}"
23973,"public void setImageMatrix(Matrix matrix){
  if (matrix != null && matrix.isIdentity()) {
    matrix=null;
  }
  if (matrix == null && !mMatrix.isIdentity() || matrix != null && !mMatrix.equals(matrix)) {
    mMatrix.set(matrix);
    invalidate();
  }
}","public void setImageMatrix(Matrix matrix){
  if (matrix != null && matrix.isIdentity()) {
    matrix=null;
  }
  if (matrix == null && !mMatrix.isIdentity() || matrix != null && !mMatrix.equals(matrix)) {
    mMatrix.set(matrix);
    configureBounds();
    invalidate();
  }
}"
23974,"/** 
 * Handle   {@link #MSG_BATTERY_UPDATE}
 */
private void handleBatteryUpdate(int pluggedInStatus,int batteryLevel){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final boolean pluggedIn=isPluggedIn(pluggedInStatus);
  if (isBatteryUpdateInteresting(pluggedIn,batteryLevel)) {
    mBatteryLevel=batteryLevel;
    mDevicePluggedIn=pluggedIn;
    for (int i=0; i < mInfoCallbacks.size(); i++) {
      mInfoCallbacks.get(i).onRefreshBatteryInfo(shouldShowBatteryInfo(),pluggedIn,batteryLevel);
    }
  }
  if (batteryLevel == 0 && pluggedInStatus != BATTERY_STATUS_CHARGING && pluggedInStatus != BATTERY_STATUS_UNKNOWN) {
    ShutdownThread.shutdown(mContext,false);
  }
}","/** 
 * Handle   {@link #MSG_BATTERY_UPDATE}
 */
private void handleBatteryUpdate(int pluggedInStatus,int batteryLevel){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"");
  final boolean pluggedIn=isPluggedIn(pluggedInStatus);
  if (isBatteryUpdateInteresting(pluggedIn,batteryLevel)) {
    mBatteryLevel=batteryLevel;
    mDevicePluggedIn=pluggedIn;
    for (int i=0; i < mInfoCallbacks.size(); i++) {
      mInfoCallbacks.get(i).onRefreshBatteryInfo(shouldShowBatteryInfo(),pluggedIn,batteryLevel);
    }
  }
}"
23975,"/** 
 * Performs   {@link AccessibilityService}s delayed notification. The delay is configurable and denotes the period after the last event before notifying the service.
 * @param event The event.
 * @param isDefault True to notify default listeners, not default services.
 */
private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event,boolean isDefault){
  for (int i=0, count=mServices.size(); i < count; i++) {
    Service service=mServices.get(i);
    if (service.mIsDefault == isDefault) {
      if (canDispathEventLocked(service,event,mHandledFeedbackTypes)) {
        mHandledFeedbackTypes|=service.mFeedbackType;
        notifyAccessibilityServiceDelayedLocked(service,event);
      }
    }
  }
}","/** 
 * Performs   {@link AccessibilityService}s delayed notification. The delay is configurable and denotes the period after the last event before notifying the service.
 * @param event The event.
 * @param isDefault True to notify default listeners, not default services.
 */
private void notifyAccessibilityServicesDelayedLocked(AccessibilityEvent event,boolean isDefault){
  try {
    for (int i=0, count=mServices.size(); i < count; i++) {
      Service service=mServices.get(i);
      if (service.mIsDefault == isDefault) {
        if (canDispathEventLocked(service,event,mHandledFeedbackTypes)) {
          mHandledFeedbackTypes|=service.mFeedbackType;
          notifyAccessibilityServiceDelayedLocked(service,event);
        }
      }
    }
  }
 catch (  IndexOutOfBoundsException oobe) {
    return;
  }
}"
23976,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
sendCloseSystemWindows();
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}"
23977,"static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    Intent intent=new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    if (reason != null) {
      intent.putExtra(SYSTEM_DIALOG_REASON_KEY,reason);
    }
    context.sendBroadcast(intent);
  }
}","static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(reason);
    }
 catch (    RemoteException e) {
    }
  }
}"
23978,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      sendCloseSystemWindows();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  return true;
}"
23979,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          mContext.startActivity(mHomeIntent);
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}"
23980,"public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}"
23981,"/** 
 * Checks whether the speakerphone is on or off.
 * @return true if speakerphone is on, false if it's off
 */
public boolean isSpeakerphoneOn(){
  if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_SPEAKER) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether the speakerphone is on or off.
 * @return true if speakerphone is on, false if it's off
 */
public boolean isSpeakerphoneOn(){
  IAudioService service=getService();
  try {
    return service.isSpeakerphoneOn();
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}"
23982,"/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_BT_SCO);
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
  }
}","/** 
 * Request use of Bluetooth SCO headset for communications.
 * @param on set <var>true</var> to use bluetooth SCO for communications;<var>false</var> to not use bluetooth SCO for communications
 */
public void setBluetoothScoOn(boolean on){
  IAudioService service=getService();
  try {
    service.setBluetoothScoOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23983,"/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  if (on) {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_SPEAKER);
  }
 else {
    AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
  }
}","/** 
 * Sets the speakerphone on or off.
 * @param on set <var>true</var> to turn on speakerphone;<var>false</var> to turn it off
 */
public void setSpeakerphoneOn(boolean on){
  IAudioService service=getService();
  try {
    service.setSpeakerphoneOn(on);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
23984,"/** 
 * Checks whether communications use Bluetooth SCO.
 * @return true if SCO is used for communications;false if otherwise
 */
public boolean isBluetoothScoOn(){
  if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Checks whether communications use Bluetooth SCO.
 * @return true if SCO is used for communications;false if otherwise
 */
public boolean isBluetoothScoOn(){
  IAudioService service=getService();
  try {
    return service.isBluetoothScoOn();
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
    return false;
  }
}"
23985,"/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.SINK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION);
  context.registerReceiver(mReceiver,intentFilter);
}","/** 
 * @hide 
 */
public AudioService(Context context){
  mContext=context;
  mContentResolver=context.getContentResolver();
  mVolumePanel=new VolumePanel(context,this);
  mSettingsObserver=new SettingsObserver();
  mMode=AudioSystem.MODE_NORMAL;
  mHeadsetState=0;
  mForcedUseForComm=AudioSystem.FORCE_NONE;
  createAudioSystemThread();
  readPersistedSettings();
  createStreamStates();
  mMediaServerOk=true;
  AudioSystem.setErrorCallback(mAudioSystemCallback);
  loadSoundEffects();
  IntentFilter intentFilter=new IntentFilter(Intent.ACTION_HEADSET_PLUG);
  intentFilter.addAction(BluetoothA2dp.SINK_STATE_CHANGED_ACTION);
  intentFilter.addAction(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION);
  context.registerReceiver(mReceiver,intentFilter);
}"
23986,"@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.SINK_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothA2dp.SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothA2dp.STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
    }
  }
 else   if (action.equals(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothIntent.HEADSET_AUDIO_STATE,BluetoothHeadset.STATE_ERROR);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothHeadset.AUDIO_STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
    }
 else     if (state == BluetoothHeadset.AUDIO_STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_AVAILABLE,address);
    }
  }
 else   if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
    int state=intent.getIntExtra(""String_Node_Str"",0);
    if ((state & BIT_HEADSET) == 0 && (mHeadsetState & BIT_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_HEADSET) != 0 && (mHeadsetState & BIT_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_HEADSET_NO_MIC) == 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_HEADSET_NO_MIC) != 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_TTY) == 0 && (mHeadsetState & BIT_TTY) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_TTY) != 0 && (mHeadsetState & BIT_TTY) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_FM_HEADSET) == 0 && (mHeadsetState & BIT_FM_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_FM_HEADSET) != 0 && (mHeadsetState & BIT_FM_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    if ((state & BIT_FM_SPEAKER) == 0 && (mHeadsetState & BIT_FM_SPEAKER) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
    }
 else     if ((state & BIT_FM_SPEAKER) != 0 && (mHeadsetState & BIT_FM_SPEAKER) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
    }
    mHeadsetState=state;
  }
}","@Override public void onReceive(Context context,Intent intent){
  String action=intent.getAction();
  if (action.equals(BluetoothA2dp.SINK_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothA2dp.SINK_STATE,BluetoothA2dp.STATE_DISCONNECTED);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothA2dp.STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    }
 else     if (state == BluetoothA2dp.STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,AudioSystem.DEVICE_STATE_AVAILABLE,address);
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP),address);
    }
  }
 else   if (action.equals(BluetoothIntent.HEADSET_AUDIO_STATE_CHANGED_ACTION)) {
    int state=intent.getIntExtra(BluetoothIntent.HEADSET_AUDIO_STATE,BluetoothHeadset.STATE_ERROR);
    String address=intent.getStringExtra(BluetoothIntent.ADDRESS);
    if (state == BluetoothHeadset.AUDIO_STATE_DISCONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_UNAVAILABLE,address);
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO);
    }
 else     if (state == BluetoothHeadset.AUDIO_STATE_CONNECTED) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO,AudioSystem.DEVICE_STATE_AVAILABLE,address);
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_BLUETOOTH_SCO),address);
    }
  }
 else   if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
    int state=intent.getIntExtra(""String_Node_Str"",0);
    if ((state & BIT_HEADSET) == 0 && (mHeadsetState & BIT_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADSET);
    }
 else     if ((state & BIT_HEADSET) != 0 && (mHeadsetState & BIT_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADSET,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADSET),""String_Node_Str"");
    }
    if ((state & BIT_HEADSET_NO_MIC) == 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE);
    }
 else     if ((state & BIT_HEADSET_NO_MIC) != 0 && (mHeadsetState & BIT_HEADSET_NO_MIC) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_WIRED_HEADPHONE),""String_Node_Str"");
    }
    if ((state & BIT_TTY) == 0 && (mHeadsetState & BIT_TTY) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_TTY);
    }
 else     if ((state & BIT_TTY) != 0 && (mHeadsetState & BIT_TTY) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_TTY,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_TTY),""String_Node_Str"");
    }
    if ((state & BIT_FM_HEADSET) == 0 && (mHeadsetState & BIT_FM_HEADSET) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_HEADPHONE);
    }
 else     if ((state & BIT_FM_HEADSET) != 0 && (mHeadsetState & BIT_FM_HEADSET) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_HEADPHONE,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_FM_HEADPHONE),""String_Node_Str"");
    }
    if ((state & BIT_FM_SPEAKER) == 0 && (mHeadsetState & BIT_FM_SPEAKER) != 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_UNAVAILABLE,""String_Node_Str"");
      mConnectedDevices.remove(AudioSystem.DEVICE_OUT_FM_SPEAKER);
    }
 else     if ((state & BIT_FM_SPEAKER) != 0 && (mHeadsetState & BIT_FM_SPEAKER) == 0) {
      AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_FM_SPEAKER,AudioSystem.DEVICE_STATE_AVAILABLE,""String_Node_Str"");
      mConnectedDevices.put(new Integer(AudioSystem.DEVICE_OUT_FM_SPEAKER),""String_Node_Str"");
    }
    mHeadsetState=state;
  }
}"
23987,"@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.getMode();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerMode(mRingerMode);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}","@Override public void handleMessage(Message msg){
  int baseMsgWhat=getMsgBase(msg.what);
switch (baseMsgWhat) {
case MSG_SET_SYSTEM_VOLUME:
    setSystemVolume((VolumeStreamState)msg.obj);
  break;
case MSG_PERSIST_VOLUME:
persistVolume((VolumeStreamState)msg.obj);
break;
case MSG_PERSIST_RINGER_MODE:
persistRingerMode();
break;
case MSG_PERSIST_VIBRATE_SETTING:
persistVibrateSetting();
break;
case MSG_MEDIA_SERVER_DIED:
Log.e(TAG,""String_Node_Str"");
mMediaServerOk=false;
AudioSystem.isMusicActive();
break;
case MSG_MEDIA_SERVER_STARTED:
Log.e(TAG,""String_Node_Str"");
Set set=mConnectedDevices.entrySet();
Iterator i=set.iterator();
while (i.hasNext()) {
Map.Entry device=(Map.Entry)i.next();
AudioSystem.setDeviceConnectionState(((Integer)device.getKey()).intValue(),AudioSystem.DEVICE_STATE_AVAILABLE,(String)device.getValue());
}
AudioSystem.setPhoneState(mMode);
AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,mForcedUseForComm);
int numStreamTypes=AudioSystem.getNumStreamTypes();
for (int streamType=numStreamTypes - 1; streamType >= 0; streamType--) {
int index;
VolumeStreamState streamState=mStreamStates[streamType];
AudioSystem.initStreamVolume(streamType,0,(streamState.mIndexMax + 5) / 10);
if (streamState.muteCount() == 0) {
index=streamState.mIndex;
}
 else {
index=0;
}
setStreamVolumeIndex(streamType,index);
}
setRingerModeInt(getRingerMode(),false);
mMediaServerOk=true;
break;
case MSG_PLAY_SOUND_EFFECT:
playSoundEffect(msg.arg1,msg.arg2);
break;
}
}"
23988,"@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
sendCloseSystemWindows();
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}","@Override public void handleMessage(Message msg){
switch (msg.what) {
case MSG_MENU_LONG_PRESS:
{
      if (mPanelChordingKey == 0)       return;
      mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_MENU_LONG_PRESS_COMPLETE);
      break;
    }
case MSG_CALL_LONG_PRESS:
{
    if (!mKeycodeCallTimeoutActive)     return;
    mKeycodeMenuTimeoutHandler.sendEmptyMessage(MSG_CALL_LONG_PRESS_COMPLETE);
    break;
  }
case MSG_CAMERA_LONG_PRESS:
{
  if (!mKeycodeCameraTimeoutActive)   return;
  Message newMessage=Message.obtain(msg);
  newMessage.what=MSG_CAMERA_LONG_PRESS_COMPLETE;
  mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
  break;
}
case MSG_SEARCH_LONG_PRESS:
{
if (!mSearchKeyDownReceived) return;
Message newMessage=Message.obtain(msg);
newMessage.what=MSG_SEARCH_LONG_PRESS_COMPLETE;
mKeycodeMenuTimeoutHandler.sendMessage(newMessage);
break;
}
case MSG_MENU_LONG_PRESS_COMPLETE:
{
if (mPanelChordingKey == 0) return;
mPanelChordingKey=0;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
InputMethodManager imm=(InputMethodManager)getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
if (imm != null) {
imm.toggleSoftInput(InputMethodManager.SHOW_FORCED,0);
}
}
break;
case MSG_CALL_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCallTimeoutActive) return;
mKeycodeCallTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_VOICE_COMMAND);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
}
 catch (ActivityNotFoundException e) {
startCallActivity();
}
}
break;
case MSG_CAMERA_LONG_PRESS_COMPLETE:
{
if (!mKeycodeCameraTimeoutActive) return;
mKeycodeCameraTimeoutActive=false;
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
sendCloseSystemWindows();
Intent intent=new Intent(Intent.ACTION_CAMERA_BUTTON,null);
intent.putExtra(Intent.EXTRA_KEY_EVENT,(KeyEvent)msg.obj);
getContext().sendOrderedBroadcast(intent,null);
}
break;
case MSG_SEARCH_LONG_PRESS_COMPLETE:
{
if (getKeyguardManager().inKeyguardRestrictedInputMode() || !mSearchKeyDownReceived) {
mSearchKeyDownReceived=false;
return;
}
mDecor.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
Intent intent=new Intent(Intent.ACTION_SEARCH_LONG_PRESS);
intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
try {
sendCloseSystemWindows();
getContext().startActivity(intent);
mSearchKeyDownReceived=false;
}
 catch (ActivityNotFoundException e) {
}
}
break;
}
}"
23989,"static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    Intent intent=new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    if (reason != null) {
      intent.putExtra(SYSTEM_DIALOG_REASON_KEY,reason);
    }
    context.sendBroadcast(intent);
  }
}","static void sendCloseSystemWindows(Context context,String reason){
  if (ActivityManagerNative.isSystemReady()) {
    try {
      ActivityManagerNative.getDefault().closeSystemDialogs(reason);
    }
 catch (    RemoteException e) {
    }
  }
}"
23990,"/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  sendCloseSystemWindows();
  return true;
}","/** 
 * goes to the home screen
 * @return whether it did anything
 */
boolean goHome(){
  if (false) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
      sendCloseSystemWindows();
      int result=ActivityManagerNative.getDefault().startActivity(null,mHomeIntent,mHomeIntent.resolveTypeIfNeeded(mContext.getContentResolver()),null,0,null,null,0,true,false);
      if (result == IActivityManager.START_RETURN_INTENT_TO_CALLER) {
        return false;
      }
    }
 catch (    RemoteException ex) {
    }
  }
  return true;
}"
23991,"/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          mContext.startActivity(mHomeIntent);
          sendCloseSystemWindows();
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","/** 
 * A home key -> launch home action was detected.  Take the appropriate action given the situation with the keyguard.
 */
void launchHomeFromHotKey(){
  if (mKeyguardMediator.isShowing()) {
  }
 else   if (mKeyguardMediator.isInputRestricted()) {
    mKeyguardMediator.verifyUnlock(new OnKeyguardExitResult(){
      public void onKeyguardExitResult(      boolean success){
        if (success) {
          try {
            ActivityManagerNative.getDefault().stopAppSwitches();
          }
 catch (          RemoteException e) {
          }
          sendCloseSystemWindows();
          mContext.startActivity(mHomeIntent);
        }
      }
    }
);
  }
 else {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}"
23992,"public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    mContext.startActivity(mHomeIntent);
    sendCloseSystemWindows();
  }
}","public void onKeyguardExitResult(boolean success){
  if (success) {
    try {
      ActivityManagerNative.getDefault().stopAppSwitches();
    }
 catch (    RemoteException e) {
    }
    sendCloseSystemWindows();
    mContext.startActivity(mHomeIntent);
  }
}"
23993,"private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}","private synchronized final void update(){
  native_update();
  boolean logOutlier=false;
  long dischargeDuration=0;
  if (mBatteryLevel == 0 && isPowered(0xffffffff)) {
    ShutdownThread.shutdown(mContext,false);
  }
  mBatteryLevelCritical=mBatteryLevel <= CRITICAL_BATTERY_LEVEL;
  if (mAcOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_AC;
  }
 else   if (mUsbOnline) {
    mPlugType=BatteryManager.BATTERY_PLUGGED_USB;
  }
 else {
    mPlugType=BATTERY_PLUGGED_NONE;
  }
  if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mBatteryLevel != mLastBatteryLevel || mPlugType != mLastPlugType || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
    if (mPlugType != mLastPlugType) {
      if (mLastPlugType == BATTERY_PLUGGED_NONE) {
        if (mDischargeStartTime != 0 && mDischargeStartLevel != mBatteryLevel) {
          dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
          logOutlier=true;
          EventLog.writeEvent(LOG_BATTERY_DISCHARGE_STATUS,dischargeDuration,mDischargeStartLevel,mBatteryLevel);
          mDischargeStartTime=0;
        }
      }
 else       if (mPlugType == BATTERY_PLUGGED_NONE) {
        mDischargeStartTime=SystemClock.elapsedRealtime();
        mDischargeStartLevel=mBatteryLevel;
      }
    }
    if (mBatteryStatus != mLastBatteryStatus || mBatteryHealth != mLastBatteryHealth || mBatteryPresent != mLastBatteryPresent || mPlugType != mLastPlugType) {
      EventLog.writeEvent(LOG_BATTERY_STATUS,mBatteryStatus,mBatteryHealth,mBatteryPresent ? 1 : 0,mPlugType,mBatteryTechnology);
    }
    if (mBatteryLevel != mLastBatteryLevel || mBatteryVoltage != mLastBatteryVoltage || mBatteryTemperature != mLastBatteryTemperature) {
      EventLog.writeEvent(LOG_BATTERY_LEVEL,mBatteryLevel,mBatteryVoltage,mBatteryTemperature);
    }
    if (mBatteryLevel != mLastBatteryLevel && mPlugType == BATTERY_PLUGGED_NONE) {
      try {
        mBatteryStats.recordCurrentLevel(mBatteryLevel);
      }
 catch (      RemoteException e) {
      }
    }
    if (mBatteryLevelCritical && !mLastBatteryLevelCritical && mPlugType == BATTERY_PLUGGED_NONE) {
      dischargeDuration=SystemClock.elapsedRealtime() - mDischargeStartTime;
      logOutlier=true;
    }
    Intent statusIntent=new Intent();
    statusIntent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    if (mPlugType != 0 && mLastPlugType == 0) {
      statusIntent.setAction(Intent.ACTION_POWER_CONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mPlugType == 0 && mLastPlugType != 0) {
      statusIntent.setAction(Intent.ACTION_POWER_DISCONNECTED);
      mContext.sendBroadcast(statusIntent);
    }
    final boolean plugged=mPlugType != BATTERY_PLUGGED_NONE;
    final boolean oldPlugged=mLastPlugType != BATTERY_PLUGGED_NONE;
    final boolean sendBatteryLow=!plugged && mBatteryStatus != BatteryManager.BATTERY_STATUS_UNKNOWN && mBatteryLevel < BATTERY_LEVEL_WARNING && (oldPlugged || mLastBatteryLevel >= BATTERY_LEVEL_WARNING);
    mLastBatteryStatus=mBatteryStatus;
    mLastBatteryHealth=mBatteryHealth;
    mLastBatteryPresent=mBatteryPresent;
    mLastBatteryLevel=mBatteryLevel;
    mLastPlugType=mPlugType;
    mLastBatteryVoltage=mBatteryVoltage;
    mLastBatteryTemperature=mBatteryTemperature;
    mLastBatteryLevelCritical=mBatteryLevelCritical;
    sendIntent();
    if (sendBatteryLow) {
      mSentLowBatteryBroadcast=true;
      statusIntent.setAction(Intent.ACTION_BATTERY_LOW);
      mContext.sendBroadcast(statusIntent);
    }
 else     if (mSentLowBatteryBroadcast && mLastBatteryLevel >= BATTERY_LEVEL_CLOSE_WARNING) {
      mSentLowBatteryBroadcast=false;
      statusIntent.setAction(Intent.ACTION_BATTERY_OKAY);
      mContext.sendBroadcast(statusIntent);
    }
    if (logOutlier && dischargeDuration != 0) {
      logOutlier(dischargeDuration);
    }
  }
}"
23994,"public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      Uri[] grantedUriPermissions=data.createTypedArray(Uri.CREATOR);
      int grantedMode=data.readInt();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      boolean onlyIfNeeded=data.readInt() != 0;
      boolean debug=data.readInt() != 0;
      int result=startActivity(app,intent,resolvedType,grantedUriPermissions,grantedMode,resultTo,resultWho,requestCode,onlyIfNeeded,debug);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder callingActivity=data.readStrongBinder();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    boolean result=startNextMatchingActivity(callingActivity,intent);
    reply.writeNoException();
    reply.writeInt(result ? 1 : 0);
    return true;
  }
case FINISH_ACTIVITY_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder token=data.readStrongBinder();
  Intent resultData=null;
  int resultCode=data.readInt();
  if (data.readInt() != 0) {
    resultData=Intent.CREATOR.createFromParcel(data);
  }
  boolean res=finishActivity(token,resultCode,resultData);
  reply.writeNoException();
  reply.writeInt(res ? 1 : 0);
  return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
Intent intent=registerReceiver(app,rec,filter,perm);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String perm=data.readString();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perm,serialized,sticky);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
unbroadcastIntent(app,intent);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort);
}
reply.writeNoException();
return true;
}
case SET_PERSISTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isPersistent=data.readInt() != 0;
if (token != null) {
setPersistent(token,isPersistent);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
if (token != null) {
activityIdle(token);
}
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
activityPaused(token,map);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,thumbnail,description);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
IBinder receiverBinder=data.readStrongBinder();
IThumbnailReceiver receiver=receiverBinder != null ? IThumbnailReceiver.Stub.asInterface(receiverBinder) : null;
List list=getTasks(maxNum,fl,receiver);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=(ActivityManager.RunningTaskInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=(ActivityManager.RunningServiceInfo)list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToFront(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskToBack(task);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case FINISH_OTHER_INSTANCES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName className=ComponentName.readFromParcel(data);
finishOtherInstances(token,className);
reply.writeNoException();
return true;
}
case REPORT_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bitmap thumbnail=data.readInt() != 0 ? Bitmap.CREATOR.createFromParcel(data) : null;
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
reportThumbnail(token,thumbnail,description);
reply.writeNoException();
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
ContentProviderHolder cph=getContentProvider(app,name);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
removeContentProvider(app,name);
reply.writeNoException();
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
ComponentName cn=startService(app,service,resolvedType);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int res=stopService(app,service,resolvedType);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
boolean isForeground=data.readInt() != 0;
setServiceForeground(className,token,isForeground);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
serviceDoneExecuting(token);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
boolean res=startInstrumentation(className,profileFile,fl,arguments,w);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent requestIntent=data.readInt() != 0 ? Intent.CREATOR.createFromParcel(data) : null;
String requestResolvedType=data.readString();
int fl=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntent,requestResolvedType,fl);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int res=checkUriPermission(uri,pid,uid,mode);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
boolean res=clearApplicationUserData(packageName,observer);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
grantUriPermission(app,targetPkg,uri,mode);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
revokeUriPermission(app,uri,mode);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GOING_TO_SLEEP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
goingToSleep();
reply.writeNoException();
return true;
}
case WAKING_UP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
wakingUp();
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
noteWakeupAlarm(is);
reply.writeNoException();
return true;
}
case KILL_PIDS_FOR_MEMORY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
boolean res=killPidsForMemory(pids);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int pss=data.readInt();
reportPss(app,pss);
reply.writeNoException();
return true;
}
case START_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String cls=data.readString();
String action=data.readString();
String indata=data.readString();
startRunning(pkg,cls,action,indata);
reply.writeNoException();
return true;
}
case SYSTEM_READY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
systemReady();
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_ERROR_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int fl=data.readInt();
String tag=data.readString();
String shortMsg=data.readString();
String longMsg=data.readString();
byte[] crashData=data.createByteArray();
int res=handleApplicationError(app,fl,tag,shortMsg,longMsg,crashData);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case RESTART_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
restartPackage(packageName);
reply.writeNoException();
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
boolean start=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? data.readFileDescriptor() : null;
boolean res=profileControl(process,start,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder binder=peekService(service,resolvedType);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case REGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
registerActivityWatcher(watcher);
return true;
}
case UNREGISTER_ACTIVITY_WATCHER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityWatcher watcher=IActivityWatcher.Stub.asInterface(data.readStrongBinder());
unregisterActivityWatcher(watcher);
return true;
}
case START_ACTIVITY_IN_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
boolean onlyIfNeeded=data.readInt() != 0;
int result=startActivityInPackage(uid,intent,resolvedType,resultTo,resultWho,requestCode,onlyIfNeeded);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case KILL_APPLICATION_WITH_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int uid=data.readInt();
killApplicationWithUid(pkg,uid);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}"
23995,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          moveInputMethodWindowsIfNeededLocked(true);
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          if (!moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked();
          }
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}"
23996,"private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          moveInputMethodWindowsIfNeededLocked(true);
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}","private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory){
  final long currentTime=SystemClock.uptimeMillis();
  final int dw=mDisplay.getWidth();
  final int dh=mDisplay.getHeight();
  final int N=mWindows.size();
  int i;
  performLayoutLockedInner();
  if (mFxSession == null) {
    mFxSession=new SurfaceSession();
  }
  if (SHOW_TRANSACTIONS)   Log.i(TAG,""String_Node_Str"");
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    mExitingTokens.get(i).hasVisible=false;
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    mExitingAppTokens.get(i).hasVisible=false;
  }
  boolean orientationChangeComplete=true;
  Session holdScreen=null;
  float screenBrightness=-1;
  boolean focusDisplayed=false;
  boolean animating=false;
  Surface.openTransaction();
  try {
    boolean restart;
    do {
      final int transactionSequence=++mTransactionSequence;
      boolean tokensAnimating=false;
      final int NAT=mAppTokens.size();
      for (i=0; i < NAT; i++) {
        if (mAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      final int NEAT=mExitingAppTokens.size();
      for (i=0; i < NEAT; i++) {
        if (mExitingAppTokens.get(i).stepAnimationLocked(currentTime,dw,dh)) {
          tokensAnimating=true;
        }
      }
      animating=tokensAnimating;
      restart=false;
      boolean tokenMayBeDrawn=false;
      mPolicy.beginAnimationLw(dw,dh);
      for (i=N - 1; i >= 0; i--) {
        WindowState w=(WindowState)mWindows.get(i);
        final WindowManager.LayoutParams attrs=w.mAttrs;
        if (w.mSurface != null) {
          w.commitFinishDrawingLocked(currentTime);
          if (w.stepAnimationLocked(currentTime,dw,dh)) {
            animating=true;
          }
          mPolicy.animatingWindowLw(w,attrs);
        }
        final AppWindowToken atoken=w.mAppToken;
        if (atoken != null && (!atoken.allDrawn || atoken.freezingScreen)) {
          if (atoken.lastTransactionSequence != transactionSequence) {
            atoken.lastTransactionSequence=transactionSequence;
            atoken.numInterestingWindows=atoken.numDrawnWindows=0;
            atoken.startingDisplayed=false;
          }
          if ((w.isOnScreen() || w.mAttrs.type == WindowManager.LayoutParams.TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
              Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.isDisplayedLw()+ ""String_Node_Str""+ w.isAnimating());
              if (!w.isDisplayedLw()) {
                Log.v(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mPolicyVisibility+ ""String_Node_Str""+ w.mDrawPending+ ""String_Node_Str""+ w.mCommitDrawPending+ ""String_Node_Str""+ w.mAttachedHidden+ ""String_Node_Str""+ atoken.hiddenRequested+ ""String_Node_Str""+ w.mAnimating);
              }
            }
            if (w != atoken.startingWindow) {
              if (!atoken.freezingScreen || !w.mAppFreezing) {
                atoken.numInterestingWindows++;
                if (w.isDisplayedLw()) {
                  atoken.numDrawnWindows++;
                  if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)                   Log.v(TAG,""String_Node_Str"" + atoken + ""String_Node_Str""+ atoken.freezingScreen+ ""String_Node_Str""+ w.mAppFreezing);
                  tokenMayBeDrawn=true;
                }
              }
            }
 else             if (w.isDisplayedLw()) {
              atoken.startingDisplayed=true;
            }
          }
        }
 else         if (w.mReadyToShow) {
          w.performShowLocked();
        }
      }
      if (mPolicy.finishAnimationLw()) {
        restart=true;
      }
      if (tokenMayBeDrawn) {
        final int NT=mTokenList.size();
        for (i=0; i < NT; i++) {
          AppWindowToken wtoken=mTokenList.get(i).appWindowToken;
          if (wtoken == null) {
            continue;
          }
          if (wtoken.freezingScreen) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.showAllWindowsLocked();
              unsetAppFreezingScreenLocked(wtoken,false,true);
              orientationChangeComplete=true;
            }
          }
 else           if (!wtoken.allDrawn) {
            int numInteresting=wtoken.numInterestingWindows;
            if (numInteresting > 0 && wtoken.numDrawnWindows >= numInteresting) {
              if (DEBUG_VISIBILITY)               Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ numInteresting+ ""String_Node_Str""+ wtoken.numDrawnWindows);
              wtoken.allDrawn=true;
              restart=true;
              if (!mOpeningApps.contains(wtoken)) {
                wtoken.showAllWindowsLocked();
              }
            }
          }
        }
      }
      if (mAppTransitionReady) {
        int NN=mOpeningApps.size();
        boolean goodToGo=true;
        if (DEBUG_APP_TRANSITIONS)         Log.v(TAG,""String_Node_Str"" + NN + ""String_Node_Str""+ mDisplayFrozen+ ""String_Node_Str""+ mAppTransitionTimeout+ ""String_Node_Str"");
        if (!mDisplayFrozen && !mAppTransitionTimeout) {
          for (i=0; i < NN && goodToGo; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.allDrawn+ ""String_Node_Str""+ wtoken.startingDisplayed);
            if (!wtoken.allDrawn && !wtoken.startingDisplayed && !wtoken.startingMoved) {
              goodToGo=false;
            }
          }
        }
        if (goodToGo) {
          if (DEBUG_APP_TRANSITIONS)           Log.v(TAG,""String_Node_Str"");
          int transit=mNextAppTransition;
          if (mSkipAppTransitionAnimation) {
            transit=WindowManagerPolicy.TRANSIT_NONE;
          }
          mNextAppTransition=WindowManagerPolicy.TRANSIT_NONE;
          mAppTransitionReady=false;
          mAppTransitionTimeout=false;
          mStartingIconInTransition=false;
          mSkipAppTransitionAnimation=false;
          mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
          WindowManager.LayoutParams lp=findAnimations(mAppTokens,mOpeningApps,mClosingApps);
          NN=mOpeningApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mOpeningApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.reportedVisible=false;
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,true,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.showAllWindowsLocked();
          }
          NN=mClosingApps.size();
          for (i=0; i < NN; i++) {
            AppWindowToken wtoken=mClosingApps.get(i);
            if (DEBUG_APP_TRANSITIONS)             Log.v(TAG,""String_Node_Str"" + wtoken);
            wtoken.inPendingTransaction=false;
            setTokenVisibilityLocked(wtoken,lp,false,transit,false);
            wtoken.updateReportedVisibilityLocked();
            wtoken.allDrawn=true;
          }
          mOpeningApps.clear();
          mClosingApps.clear();
          mLayoutNeeded=true;
          if (!moveInputMethodWindowsIfNeededLocked(true)) {
            assignLayersLocked();
          }
          performLayoutLockedInner();
          updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES);
          restart=true;
        }
      }
    }
 while (restart);
    final boolean someoneLosingFocus=mLosingFocus.size() != 0;
    boolean obscured=false;
    boolean blurring=false;
    boolean dimming=false;
    boolean covered=false;
    boolean syswin=false;
    boolean backgroundFillerShown=false;
    for (i=N - 1; i >= 0; i--) {
      WindowState w=(WindowState)mWindows.get(i);
      boolean displayed=false;
      final WindowManager.LayoutParams attrs=w.mAttrs;
      final int attrFlags=attrs.flags;
      if (w.mSurface != null) {
        w.computeShownFrameLocked();
        if (localLOGV)         Log.v(TAG,""String_Node_Str"" + i + ""String_Node_Str""+ w.mSurface+ ""String_Node_Str""+ w.mShownFrame+ ""String_Node_Str""+ w.mLastShownFrame);
        boolean resize;
        int width, height;
        if ((w.mAttrs.flags & w.mAttrs.FLAG_SCALED) != 0) {
          resize=w.mLastRequestedWidth != w.mRequestedWidth || w.mLastRequestedHeight != w.mRequestedHeight;
          width=w.mRequestedWidth;
          height=w.mRequestedHeight;
          w.mLastRequestedWidth=width;
          w.mLastRequestedHeight=height;
          w.mLastShownFrame.set(w.mShownFrame);
          try {
            w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
          }
 catch (          RuntimeException e) {
            Log.w(TAG,""String_Node_Str"" + w,e);
            if (!recoveringMemory) {
              reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
            }
          }
        }
 else {
          resize=!w.mLastShownFrame.equals(w.mShownFrame);
          width=w.mShownFrame.width();
          height=w.mShownFrame.height();
          w.mLastShownFrame.set(w.mShownFrame);
          if (resize) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str""+ w.mShownFrame.width()+ ""String_Node_Str""+ w.mShownFrame.height()+ ""String_Node_Str"");
          }
        }
        if (resize) {
          if (width < 1)           width=1;
          if (height < 1)           height=1;
          if (w.mSurface != null) {
            try {
              w.mSurface.setSize(width,height);
              w.mSurface.setPosition(w.mShownFrame.left,w.mShownFrame.top);
            }
 catch (            RuntimeException e) {
              Log.e(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ w.mShownFrame.left+ ""String_Node_Str""+ w.mShownFrame.top+ ""String_Node_Str"",e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
        }
        if (!w.mAppFreezing) {
          w.mContentInsetsChanged=!w.mLastContentInsets.equals(w.mContentInsets);
          w.mVisibleInsetsChanged=!w.mLastVisibleInsets.equals(w.mVisibleInsets);
          if (!w.mLastFrame.equals(w.mFrame) || w.mContentInsetsChanged || w.mVisibleInsetsChanged) {
            w.mLastFrame.set(w.mFrame);
            w.mLastContentInsets.set(w.mContentInsets);
            w.mLastVisibleInsets.set(w.mVisibleInsets);
            if (w.mOrientationChanging) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mDrawPending=true;
              w.mCommitDrawPending=false;
              w.mReadyToShow=false;
              if (w.mAppToken != null) {
                w.mAppToken.allDrawn=false;
              }
            }
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mFrame);
            mResizingWindows.add(w);
          }
 else           if (w.mOrientationChanging) {
            if (!w.mDrawPending && !w.mCommitDrawPending) {
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mSurface);
              w.mOrientationChanging=false;
            }
          }
        }
        if (w.mAttachedHidden) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (!w.isReadyForDisplay()) {
          if (!w.mLastHidden) {
            w.mLastHidden=true;
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (w.mSurface != null) {
              try {
                w.mSurface.hide();
              }
 catch (              RuntimeException e) {
                Log.w(TAG,""String_Node_Str"" + w);
              }
            }
            mKeyWaiter.releasePendingPointerLocked(w.mSession);
          }
          if (w.mOrientationChanging) {
            w.mOrientationChanging=false;
            if (DEBUG_ORIENTATION)             Log.v(TAG,""String_Node_Str"" + w);
          }
        }
 else         if (w.mLastLayer != w.mAnimLayer || w.mLastAlpha != w.mShownAlpha || w.mLastDsDx != w.mDsDx || w.mLastDtDx != w.mDtDx || w.mLastDsDy != w.mDsDy || w.mLastDtDy != w.mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || w.mLastHidden) {
          displayed=true;
          w.mLastAlpha=w.mShownAlpha;
          w.mLastLayer=w.mAnimLayer;
          w.mLastDsDx=w.mDsDx;
          w.mLastDtDx=w.mDtDx;
          w.mLastDsDy=w.mDsDy;
          w.mLastDtDy=w.mDtDy;
          w.mLastHScale=w.mHScale;
          w.mLastVScale=w.mVScale;
          if (SHOW_TRANSACTIONS)           Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str""+ w.mShownAlpha+ ""String_Node_Str""+ w.mAnimLayer);
          if (w.mSurface != null) {
            try {
              w.mSurface.setAlpha(w.mShownAlpha);
              w.mSurface.setLayer(w.mAnimLayer);
              w.mSurface.setMatrix(w.mDsDx * w.mHScale,w.mDtDx * w.mVScale,w.mDsDy * w.mHScale,w.mDtDy * w.mVScale);
            }
 catch (            RuntimeException e) {
              Log.w(TAG,""String_Node_Str"" + w,e);
              if (!recoveringMemory) {
                reclaimSomeSurfaceMemoryLocked(w,""String_Node_Str"");
              }
            }
          }
          if (w.mLastHidden && !w.mDrawPending && !w.mCommitDrawPending&& !w.mReadyToShow) {
            if (SHOW_TRANSACTIONS)             Log.i(TAG,""String_Node_Str"" + w.mSurface + ""String_Node_Str"");
            if (DEBUG_VISIBILITY)             Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str"");
            if (showSurfaceRobustlyLocked(w)) {
              w.mHasDrawn=true;
              w.mLastHidden=false;
            }
 else {
              w.mOrientationChanging=false;
            }
          }
          if (w.mSurface != null) {
            w.mToken.hasVisible=true;
          }
        }
 else {
          displayed=true;
        }
        if (displayed) {
          if (!covered) {
            if (attrs.width == LayoutParams.FILL_PARENT && attrs.height == LayoutParams.FILL_PARENT) {
              covered=true;
            }
          }
          if (w.mOrientationChanging) {
            if (w.mDrawPending || w.mCommitDrawPending) {
              orientationChangeComplete=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
 else {
              w.mOrientationChanging=false;
              if (DEBUG_ORIENTATION)               Log.v(TAG,""String_Node_Str"" + w);
            }
          }
          w.mToken.hasVisible=true;
        }
      }
 else       if (w.mOrientationChanging) {
        if (DEBUG_ORIENTATION)         Log.v(TAG,""String_Node_Str"" + w);
        w.mOrientationChanging=false;
      }
      final boolean canBeSeen=w.isDisplayedLw();
      if (someoneLosingFocus && w == mCurrentFocus && canBeSeen) {
        focusDisplayed=true;
      }
      if (!obscured) {
        if (w.mSurface != null) {
          if ((attrFlags & FLAG_KEEP_SCREEN_ON) != 0) {
            holdScreen=w.mSession;
          }
          if (!syswin && w.mAttrs.screenBrightness >= 0 && screenBrightness < 0) {
            screenBrightness=w.mAttrs.screenBrightness;
          }
          if (attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_DIALOG || attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD || attrs.type == WindowManager.LayoutParams.TYPE_SYSTEM_ERROR) {
            syswin=true;
          }
        }
        boolean opaqueDrawn=w.isOpaqueDrawn();
        if (opaqueDrawn && w.isFullscreen(dw,dh)) {
          obscured=true;
        }
 else         if (opaqueDrawn && w.needsBackgroundFiller(dw,dh)) {
          if (SHOW_TRANSACTIONS)           Log.d(TAG,""String_Node_Str"");
          obscured=true;
          if (mBackgroundFillerSurface == null) {
            try {
              mBackgroundFillerSurface=new Surface(mFxSession,0,0,dw,dh,PixelFormat.OPAQUE,Surface.FX_SURFACE_NORMAL);
            }
 catch (            Exception e) {
              Log.e(TAG,""String_Node_Str"",e);
            }
          }
          try {
            mBackgroundFillerSurface.setPosition(0,0);
            mBackgroundFillerSurface.setSize(dw,dh);
            mBackgroundFillerSurface.setLayer(w.mAnimLayer - 1);
            mBackgroundFillerSurface.show();
          }
 catch (          RuntimeException e) {
            Log.e(TAG,""String_Node_Str"");
          }
          backgroundFillerShown=true;
          mBackgroundFillerShown=true;
        }
 else         if (canBeSeen && !obscured && (attrFlags & FLAG_BLUR_BEHIND | FLAG_DIM_BEHIND) != 0) {
          if (localLOGV)           Log.v(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ blurring+ ""String_Node_Str""+ obscured+ ""String_Node_Str""+ displayed);
          if ((attrFlags & FLAG_DIM_BEHIND) != 0) {
            if (!dimming) {
              dimming=true;
              if (mDimAnimator == null) {
                mDimAnimator=new DimAnimator(mFxSession);
              }
              mDimAnimator.show(dw,dh);
            }
            mDimAnimator.updateParameters(w,currentTime);
          }
          if ((attrFlags & FLAG_BLUR_BEHIND) != 0) {
            if (!blurring) {
              blurring=true;
              mBlurShown=true;
              if (mBlurSurface == null) {
                if (SHOW_TRANSACTIONS)                 Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
                try {
                  mBlurSurface=new Surface(mFxSession,0,-1,16,16,PixelFormat.OPAQUE,Surface.FX_SURFACE_BLUR);
                }
 catch (                Exception e) {
                  Log.e(TAG,""String_Node_Str"",e);
                }
              }
              if (SHOW_TRANSACTIONS)               Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str""+ dw+ ""String_Node_Str""+ dh+ ""String_Node_Str""+ (w.mAnimLayer - 1));
              if (mBlurSurface != null) {
                mBlurSurface.setPosition(0,0);
                mBlurSurface.setSize(dw,dh);
                try {
                  mBlurSurface.show();
                }
 catch (                RuntimeException e) {
                  Log.w(TAG,""String_Node_Str"",e);
                }
              }
            }
            mBlurSurface.setLayer(w.mAnimLayer - 2);
          }
        }
      }
    }
    if (backgroundFillerShown == false && mBackgroundFillerShown) {
      mBackgroundFillerShown=false;
      if (SHOW_TRANSACTIONS)       Log.d(TAG,""String_Node_Str"");
      try {
        mBackgroundFillerSurface.hide();
      }
 catch (      RuntimeException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
    }
    if (mDimAnimator != null && mDimAnimator.mDimShown) {
      animating|=mDimAnimator.updateSurface(dimming,currentTime,mDisplayFrozen);
    }
    if (!blurring && mBlurShown) {
      if (SHOW_TRANSACTIONS)       Log.i(TAG,""String_Node_Str"" + mBlurSurface + ""String_Node_Str"");
      try {
        mBlurSurface.hide();
      }
 catch (      IllegalArgumentException e) {
        Log.w(TAG,""String_Node_Str"");
      }
      mBlurShown=false;
    }
    if (SHOW_TRANSACTIONS)     Log.i(TAG,""String_Node_Str"");
  }
 catch (  RuntimeException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  Surface.closeTransaction();
  if (DEBUG_ORIENTATION && mDisplayFrozen)   Log.v(TAG,""String_Node_Str"" + orientationChangeComplete);
  if (orientationChangeComplete) {
    if (mWindowsFreezingScreen) {
      mWindowsFreezingScreen=false;
      mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    }
    if (mAppsFreezingScreen == 0) {
      stopFreezingDisplayLocked();
    }
  }
  i=mResizingWindows.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mResizingWindows.get(i);
      try {
        win.mClient.resized(win.mFrame.width(),win.mFrame.height(),win.mLastContentInsets,win.mLastVisibleInsets,win.mDrawPending);
        win.mContentInsetsChanged=false;
        win.mVisibleInsetsChanged=false;
      }
 catch (      RemoteException e) {
        win.mOrientationChanging=false;
      }
    }
 while (i > 0);
    mResizingWindows.clear();
  }
  i=mDestroySurface.size();
  if (i > 0) {
    do {
      i--;
      WindowState win=mDestroySurface.get(i);
      win.mDestroying=false;
      if (mInputMethodWindow == win) {
        mInputMethodWindow=null;
      }
      win.destroySurfaceLocked();
    }
 while (i > 0);
    mDestroySurface.clear();
  }
  for (i=mExitingTokens.size() - 1; i >= 0; i--) {
    WindowToken token=mExitingTokens.get(i);
    if (!token.hasVisible) {
      mExitingTokens.remove(i);
    }
  }
  for (i=mExitingAppTokens.size() - 1; i >= 0; i--) {
    AppWindowToken token=mExitingAppTokens.get(i);
    if (!token.hasVisible && !mClosingApps.contains(token)) {
      mAppTokens.remove(token);
      mExitingAppTokens.remove(i);
    }
  }
  if (focusDisplayed) {
    mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
  }
  if (animating) {
    requestAnimationLocked(currentTime + (1000 / 60) - SystemClock.uptimeMillis());
  }
  mQueue.setHoldScreenLocked(holdScreen != null);
  if (screenBrightness < 0 || screenBrightness > 1.0f) {
    mPowerManager.setScreenBrightnessOverride(-1);
  }
 else {
    mPowerManager.setScreenBrightnessOverride((int)(screenBrightness * Power.BRIGHTNESS_ON));
  }
  if (holdScreen != mHoldingScreenOn) {
    mHoldingScreenOn=holdScreen;
    Message m=mH.obtainMessage(H.HOLD_SCREEN_CHANGED,holdScreen);
    mH.sendMessage(m);
  }
}"
23997,"final void handleConfigurationChanged(Configuration config){
synchronized (mRelaunchingActivities) {
    if (mPendingConfiguration != null) {
      config=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  ArrayList<ComponentCallbacks> callbacks=new ArrayList<ComponentCallbacks>();
synchronized (mPackages) {
    if (mConfiguration == null) {
      mConfiguration=new Configuration();
    }
    mConfiguration.updateFrom(config);
    DisplayMetrics dm=getDisplayMetricsLocked(true);
    if (config.locale != null) {
      Locale.setDefault(config.locale);
    }
    Resources.updateSystemConfiguration(config,null);
    ApplicationContext.ApplicationPackageManager.configurationChanged();
{
      Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
      while (it.hasNext()) {
        WeakReference<Resources> v=it.next();
        Resources r=v.get();
        if (r != null) {
          r.updateConfiguration(config,dm);
        }
 else {
          it.remove();
        }
      }
    }
    callbacks=collectComponentCallbacksLocked(false,config);
  }
  final int N=callbacks.size();
  for (int i=0; i < N; i++) {
    performConfigurationChanged(callbacks.get(i),config);
  }
}","final void handleConfigurationChanged(Configuration config){
synchronized (mRelaunchingActivities) {
    if (mPendingConfiguration != null) {
      config=mPendingConfiguration;
      mPendingConfiguration=null;
    }
  }
  ArrayList<ComponentCallbacks> callbacks=new ArrayList<ComponentCallbacks>();
synchronized (mPackages) {
    if (mConfiguration == null) {
      mConfiguration=new Configuration();
    }
    mConfiguration.updateFrom(config);
    DisplayMetrics dm=getDisplayMetricsLocked(true);
    if (config.locale != null) {
      Locale.setDefault(config.locale);
    }
    Resources.updateSystemConfiguration(config,dm);
    ApplicationContext.ApplicationPackageManager.configurationChanged();
{
      Iterator<WeakReference<Resources>> it=mActiveResources.values().iterator();
      while (it.hasNext()) {
        WeakReference<Resources> v=it.next();
        Resources r=v.get();
        if (r != null) {
          r.updateConfiguration(config,dm);
        }
 else {
          it.remove();
        }
      }
    }
    callbacks=collectComponentCallbacksLocked(false,config);
  }
  final int N=callbacks.size();
  for (int i=0; i < N; i++) {
    performConfigurationChanged(callbacks.get(i),config);
  }
}"
23998,"private Object responseCdmaCallWaiting(Parcel p){
  CdmaCallWaitingNotification notification=new CdmaCallWaitingNotification();
  notification.number=p.readString();
  notification.numberPresentation=p.readInt();
  notification.name=p.readString();
  notification.namePresentation=notification.numberPresentation;
  notification.isPresent=p.readInt();
  notification.signalType=p.readInt();
  notification.alertPitch=p.readInt();
  notification.signal=p.readInt();
  return notification;
}","private Object responseCdmaCallWaiting(Parcel p){
  CdmaCallWaitingNotification notification=new CdmaCallWaitingNotification();
  notification.number=p.readString();
  notification.numberPresentation=notification.presentationFromCLIP(p.readInt());
  notification.name=p.readString();
  notification.namePresentation=notification.numberPresentation;
  notification.isPresent=p.readInt();
  notification.signalType=p.readInt();
  notification.alertPitch=p.readInt();
  notification.signal=p.readInt();
  return notification;
}"
23999,"private void processUnsolicited(Parcel p){
  int response;
  Object ret;
  response=p.readInt();
  try {
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
      ret=responseVoid(p);
    break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
  ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
ret=responseInts(p);
break;
case RIL_UNSOL_ON_USSD:
ret=responseStrings(p);
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
ret=responseString(p);
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
ret=responseSignalStrength(p);
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
ret=responseDataCallList(p);
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
ret=responseSuppServiceNotification(p);
break;
case RIL_UNSOL_STK_SESSION_END:
ret=responseVoid(p);
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
ret=responseString(p);
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
ret=responseString(p);
break;
case RIL_UNSOL_STK_CALL_SETUP:
ret=responseInts(p);
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_SIM_REFRESH:
ret=responseInts(p);
break;
case RIL_UNSOL_CALL_RING:
ret=responseCallRing(p);
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
ret=responseInts(p);
break;
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
ret=responseCdmaSms(p);
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
ret=responseVoid(p);
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
ret=responseCdmaCallWaiting(p);
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
ret=responseInts(p);
break;
case RIL_UNSOL_CDMA_INFO_REC:
ret=responseCdmaInformationRecord(p);
break;
case RIL_UNSOL_OEM_HOOK_RAW:
ret=responseRaw(p);
break;
default :
throw new RuntimeException(""String_Node_Str"" + response);
}
}
 catch (Throwable tr) {
Log.e(LOG_TAG,""String_Node_Str"" + response + ""String_Node_Str""+ tr.toString());
return;
}
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
setRadioStateFromRILInt(p.readInt());
if (RILJ_LOGD) unsljLogMore(response,mState.toString());
break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mCallStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
{
if (RILJ_LOGD) unsljLog(response);
String a[]=new String[2];
a[1]=(String)ret;
SmsMessage sms;
sms=SmsMessage.newFromCMT(a);
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
}
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSmsStatusRegistrant != null) {
mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
if (RILJ_LOGD) unsljLogRet(response,ret);
int[] smsIndex=(int[])ret;
if (smsIndex.length == 1) {
if (mSmsOnSimRegistrant != null) {
mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null,smsIndex,null));
}
}
 else {
if (RILJ_LOGD) riljLog(""String_Node_Str"" + smsIndex.length);
}
break;
case RIL_UNSOL_ON_USSD:
String[] resp=(String[])ret;
if (resp.length < 2) {
resp=new String[2];
resp[0]=((String[])ret)[0];
resp[1]=null;
}
if (RILJ_LOGD) unsljLogMore(response,resp[0]);
if (mUSSDRegistrant != null) {
mUSSDRegistrant.notifyRegistrant(new AsyncResult(null,resp,null));
}
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
if (RILJ_LOGD) unsljLogRet(response,ret);
long nitzReceiveTime=p.readLong();
Object[] result=new Object[2];
result[0]=ret;
result[1]=Long.valueOf(nitzReceiveTime);
if (mNITZTimeRegistrant != null) {
mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null,result,null));
}
 else {
mLastNITZTimeInfo=result;
}
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
if (RILJ_LOGV) unsljLogvRet(response,ret);
if (mSignalStrengthRegistrant != null) {
mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
if (RILJ_LOGD) unsljLogRet(response,ret);
mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSsnRegistrant != null) {
mSsnRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_SESSION_END:
if (RILJ_LOGD) unsljLog(response);
if (mStkSessionEndRegistrant != null) {
mStkSessionEndRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkProCmdRegistrant != null) {
mStkProCmdRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkEventRegistrant != null) {
mStkEventRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_CALL_SETUP:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkCallSetUpRegistrant != null) {
mStkCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_SIM_REFRESH:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mIccRefreshRegistrant != null) {
mIccRefreshRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CALL_RING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mRingRegistrant != null) {
mRingRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
if (RILJ_LOGD) unsljLogvRet(response,ret);
if (mRestrictedStateRegistrant != null) {
mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
if (RILJ_LOGD) unsljLog(response);
if (mIccStatusChangedRegistrants != null) {
mIccStatusChangedRegistrants.notifyRegistrants();
}
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
if (RILJ_LOGD) unsljLog(response);
SmsMessage sms=(SmsMessage)ret;
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
if (RILJ_LOGD) unsljLog(response);
if (mGsmBroadcastSmsRegistrant != null) {
mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
if (RILJ_LOGD) unsljLog(response);
if (mEmergencyCallbackModeRegistrant != null) {
mEmergencyCallbackModeRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
if (RILJ_LOGD) unsljLog(response);
if (mCallWaitingInfoRegistrants != null) {
mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mOtaProvisionRegistrants != null) {
mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_INFO_REC:
ArrayList<CdmaInformationRecords> listInfoRecs;
try {
listInfoRecs=(ArrayList<CdmaInformationRecords>)ret;
}
 catch (ClassCastException e) {
Log.e(LOG_TAG,""String_Node_Str"",e);
break;
}
for (CdmaInformationRecords rec : listInfoRecs) {
if (RILJ_LOGD) unsljLogRet(response,rec);
notifyRegistrantsCdmaInfoRec(rec);
}
break;
case RIL_UNSOL_OEM_HOOK_RAW:
if (RILJ_LOGD) unsljLogvRet(response,IccUtils.bytesToHexString((byte[])ret));
if (mUnsolOemHookRawRegistrant != null) {
mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
}
}","private void processUnsolicited(Parcel p){
  int response;
  Object ret;
  response=p.readInt();
  try {
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
      ret=responseVoid(p);
    break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
  ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
ret=responseString(p);
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
ret=responseInts(p);
break;
case RIL_UNSOL_ON_USSD:
ret=responseStrings(p);
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
ret=responseString(p);
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
ret=responseSignalStrength(p);
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
ret=responseDataCallList(p);
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
ret=responseSuppServiceNotification(p);
break;
case RIL_UNSOL_STK_SESSION_END:
ret=responseVoid(p);
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
ret=responseString(p);
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
ret=responseString(p);
break;
case RIL_UNSOL_STK_CALL_SETUP:
ret=responseInts(p);
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_SIM_REFRESH:
ret=responseInts(p);
break;
case RIL_UNSOL_CALL_RING:
ret=responseCallRing(p);
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
ret=responseInts(p);
break;
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
ret=responseVoid(p);
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
ret=responseCdmaSms(p);
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
ret=responseString(p);
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
ret=responseVoid(p);
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
ret=responseVoid(p);
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
ret=responseCdmaCallWaiting(p);
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
ret=responseInts(p);
break;
case RIL_UNSOL_CDMA_INFO_REC:
ret=responseCdmaInformationRecord(p);
break;
case RIL_UNSOL_OEM_HOOK_RAW:
ret=responseRaw(p);
break;
default :
throw new RuntimeException(""String_Node_Str"" + response);
}
}
 catch (Throwable tr) {
Log.e(LOG_TAG,""String_Node_Str"" + response + ""String_Node_Str""+ tr.toString());
return;
}
switch (response) {
case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
setRadioStateFromRILInt(p.readInt());
if (RILJ_LOGD) unsljLogMore(response,mState.toString());
break;
case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mCallStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED:
if (RILJ_LOGD) unsljLog(response);
mNetworkStateRegistrants.notifyRegistrants(new AsyncResult(null,null,null));
break;
case RIL_UNSOL_RESPONSE_NEW_SMS:
{
if (RILJ_LOGD) unsljLog(response);
String a[]=new String[2];
a[1]=(String)ret;
SmsMessage sms;
sms=SmsMessage.newFromCMT(a);
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
}
case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSmsStatusRegistrant != null) {
mSmsStatusRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM:
if (RILJ_LOGD) unsljLogRet(response,ret);
int[] smsIndex=(int[])ret;
if (smsIndex.length == 1) {
if (mSmsOnSimRegistrant != null) {
mSmsOnSimRegistrant.notifyRegistrant(new AsyncResult(null,smsIndex,null));
}
}
 else {
if (RILJ_LOGD) riljLog(""String_Node_Str"" + smsIndex.length);
}
break;
case RIL_UNSOL_ON_USSD:
String[] resp=(String[])ret;
if (resp.length < 2) {
resp=new String[2];
resp[0]=((String[])ret)[0];
resp[1]=null;
}
if (RILJ_LOGD) unsljLogMore(response,resp[0]);
if (mUSSDRegistrant != null) {
mUSSDRegistrant.notifyRegistrant(new AsyncResult(null,resp,null));
}
break;
case RIL_UNSOL_NITZ_TIME_RECEIVED:
if (RILJ_LOGD) unsljLogRet(response,ret);
long nitzReceiveTime=p.readLong();
Object[] result=new Object[2];
result[0]=ret;
result[1]=Long.valueOf(nitzReceiveTime);
if (mNITZTimeRegistrant != null) {
mNITZTimeRegistrant.notifyRegistrant(new AsyncResult(null,result,null));
}
 else {
mLastNITZTimeInfo=result;
}
break;
case RIL_UNSOL_SIGNAL_STRENGTH:
if (RILJ_LOGV) unsljLogvRet(response,ret);
if (mSignalStrengthRegistrant != null) {
mSignalStrengthRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_DATA_CALL_LIST_CHANGED:
if (RILJ_LOGD) unsljLogRet(response,ret);
mDataConnectionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
break;
case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mSsnRegistrant != null) {
mSsnRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_SESSION_END:
if (RILJ_LOGD) unsljLog(response);
if (mStkSessionEndRegistrant != null) {
mStkSessionEndRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_PROACTIVE_COMMAND:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkProCmdRegistrant != null) {
mStkProCmdRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_EVENT_NOTIFY:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkEventRegistrant != null) {
mStkEventRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_STK_CALL_SETUP:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mStkCallSetUpRegistrant != null) {
mStkCallSetUpRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_SIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_SIM_REFRESH:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mIccRefreshRegistrant != null) {
mIccRefreshRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CALL_RING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mRingRegistrant != null) {
mRingRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_RESTRICTED_STATE_CHANGED:
if (RILJ_LOGD) unsljLogvRet(response,ret);
if (mRestrictedStateRegistrant != null) {
mRestrictedStateRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED:
if (RILJ_LOGD) unsljLog(response);
if (mIccStatusChangedRegistrants != null) {
mIccStatusChangedRegistrants.notifyRegistrants();
}
break;
case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS:
if (RILJ_LOGD) unsljLog(response);
SmsMessage sms=(SmsMessage)ret;
if (mSMSRegistrant != null) {
mSMSRegistrant.notifyRegistrant(new AsyncResult(null,sms,null));
}
break;
case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS:
if (RILJ_LOGD) unsljLog(response);
if (mGsmBroadcastSmsRegistrant != null) {
mGsmBroadcastSmsRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL:
if (RILJ_LOGD) unsljLog(response);
if (mIccSmsFullRegistrant != null) {
mIccSmsFullRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE:
if (RILJ_LOGD) unsljLog(response);
if (mEmergencyCallbackModeRegistrant != null) {
mEmergencyCallbackModeRegistrant.notifyRegistrant();
}
break;
case RIL_UNSOL_CDMA_CALL_WAITING:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mCallWaitingInfoRegistrants != null) {
mCallWaitingInfoRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS:
if (RILJ_LOGD) unsljLogRet(response,ret);
if (mOtaProvisionRegistrants != null) {
mOtaProvisionRegistrants.notifyRegistrants(new AsyncResult(null,ret,null));
}
break;
case RIL_UNSOL_CDMA_INFO_REC:
ArrayList<CdmaInformationRecords> listInfoRecs;
try {
listInfoRecs=(ArrayList<CdmaInformationRecords>)ret;
}
 catch (ClassCastException e) {
Log.e(LOG_TAG,""String_Node_Str"",e);
break;
}
for (CdmaInformationRecords rec : listInfoRecs) {
if (RILJ_LOGD) unsljLogRet(response,rec);
notifyRegistrantsCdmaInfoRec(rec);
}
break;
case RIL_UNSOL_OEM_HOOK_RAW:
if (RILJ_LOGD) unsljLogvRet(response,IccUtils.bytesToHexString((byte[])ret));
if (mUnsolOemHookRawRegistrant != null) {
mUnsolOemHookRawRegistrant.notifyRegistrant(new AsyncResult(null,ret,null));
}
break;
}
}"
24000,"/** 
 * Create a new MotionEvent, copying from an existing one.
 */
static public MotionEvent obtain(MotionEvent o){
  MotionEvent ev=obtain();
  ev.mDeviceId=o.mDeviceId;
  ev.mEdgeFlags=o.mEdgeFlags;
  ev.mDownTime=o.mDownTime;
  ev.mEventTimeNano=o.mEventTimeNano;
  ev.mAction=o.mAction;
  ev.mNumPointers=o.mNumPointers;
  ev.mRawX=o.mRawX;
  ev.mRawY=o.mRawY;
  ev.mMetaState=o.mMetaState;
  ev.mXPrecision=o.mXPrecision;
  ev.mYPrecision=o.mYPrecision;
  final int NT=ev.mNumSamples=o.mNumSamples;
  if (ev.mTimeSamples.length < NT) {
    System.arraycopy(o.mTimeSamples,0,ev.mTimeSamples,0,NT);
  }
 else {
    ev.mTimeSamples=(long[])o.mTimeSamples.clone();
  }
  final int NS=(ev.mNumPointers=o.mNumPointers) * NT;
  if (ev.mStateSamples.length < NS) {
    System.arraycopy(o.mStateSamples,0,ev.mStateSamples,0,NS);
  }
 else {
    ev.mStateSamples=(int[])o.mStateSamples.clone();
  }
  final int ND=NS * NUM_SAMPLE_DATA;
  if (ev.mDataSamples.length < ND) {
    System.arraycopy(o.mDataSamples,0,ev.mDataSamples,0,ND);
  }
 else {
    ev.mDataSamples=(float[])o.mDataSamples.clone();
  }
  return ev;
}","/** 
 * Create a new MotionEvent, copying from an existing one.
 */
static public MotionEvent obtain(MotionEvent o){
  MotionEvent ev=obtain();
  ev.mDeviceId=o.mDeviceId;
  ev.mEdgeFlags=o.mEdgeFlags;
  ev.mDownTime=o.mDownTime;
  ev.mEventTimeNano=o.mEventTimeNano;
  ev.mAction=o.mAction;
  ev.mNumPointers=o.mNumPointers;
  ev.mRawX=o.mRawX;
  ev.mRawY=o.mRawY;
  ev.mMetaState=o.mMetaState;
  ev.mXPrecision=o.mXPrecision;
  ev.mYPrecision=o.mYPrecision;
  final int NT=ev.mNumSamples=o.mNumSamples;
  if (ev.mTimeSamples.length >= NT) {
    System.arraycopy(o.mTimeSamples,0,ev.mTimeSamples,0,NT);
  }
 else {
    ev.mTimeSamples=(long[])o.mTimeSamples.clone();
  }
  final int NS=(ev.mNumPointers=o.mNumPointers) * NT;
  if (ev.mStateSamples.length < NS) {
    System.arraycopy(o.mStateSamples,0,ev.mStateSamples,0,NS);
  }
 else {
    ev.mStateSamples=(int[])o.mStateSamples.clone();
  }
  final int ND=NS * NUM_SAMPLE_DATA;
  if (ev.mDataSamples.length < ND) {
    System.arraycopy(o.mDataSamples,0,ev.mDataSamples,0,ND);
  }
 else {
    ev.mDataSamples=(float[])o.mDataSamples.clone();
  }
  return ev;
}"
