record_number,buggy_code,fixed_code
80001,"/** 
 * Get the timestamp for the beginning of query execution. 
 * @return java.sql.Timestamp	The timestamp for the beginning of query execution.
 */
public Timestamp getBeginExecutionTimestamp(){
  return beginExecutionTimestamp;
}","/** 
 * Get the timestamp for the beginning of query execution. 
 * @return java.sql.Timestamp	The timestamp for the beginning of query execution.
 */
public Timestamp getBeginExecutionTimestamp(){
  return beginExecutionTimestamp == null ? null : (Timestamp)beginExecutionTimestamp.clone();
}"
80002,"/** 
 * Checks whether a data type is supported for <code>setObject(int, Object, int)</code> and <code>setObject(int, Object, int, int)</code>.
 * @param dataType the data type to check
 * @exception SqlException if the type is not supported
 */
public void checkForSupportedDataType(int dataType) throws SqlException {
switch (dataType) {
case java.sql.Types.ARRAY:
case java.sql.Types.DATALINK:
case JDBC40Translation.NCHAR:
case JDBC40Translation.NCLOB:
case JDBC40Translation.NVARCHAR:
case JDBC40Translation.LONGNVARCHAR:
case java.sql.Types.REF:
case JDBC40Translation.REF_CURSOR:
case JDBC40Translation.ROWID:
case JDBC40Translation.SQLXML:
case java.sql.Types.STRUCT:
    throw new SqlException(logWriter_,new ClientMessageId(SQLState.DATA_TYPE_NOT_SUPPORTED),Types.getTypeString(dataType));
}
}","/** 
 * Checks whether a data type is supported for <code>setObject(int, Object, int)</code> and <code>setObject(int, Object, int, int)</code>.
 * @param dataType the data type to check
 * @exception SqlException if the type is not supported
 */
public void checkForSupportedDataType(int dataType) throws SqlException {
switch (dataType) {
case java.sql.Types.ARRAY:
case java.sql.Types.DATALINK:
case java.sql.Types.DISTINCT:
case JDBC40Translation.NCHAR:
case JDBC40Translation.NCLOB:
case JDBC40Translation.NVARCHAR:
case JDBC40Translation.LONGNVARCHAR:
case java.sql.Types.NULL:
case java.sql.Types.OTHER:
case java.sql.Types.REF:
case JDBC40Translation.REF_CURSOR:
case JDBC40Translation.ROWID:
case JDBC40Translation.SQLXML:
case java.sql.Types.STRUCT:
    throw new SqlException(logWriter_,new ClientMessageId(SQLState.DATA_TYPE_NOT_SUPPORTED),Types.getTypeString(dataType));
}
}"
80003,"public void registerOutParameter(String parameterName,SQLType sqlType,String typeName) throws SQLException {
  try {
synchronized (connection_) {
      if (agent_.loggingEnabled()) {
        agent_.logWriter_.traceEntry(this,""String_Node_Str"",parameterName,sqlType,typeName);
      }
      checkForClosedStatement();
      registerOutParameter(parameterName,Utils42.getTypeAsInt(agent_,sqlType),typeName);
    }
  }
 catch (  SqlException se) {
    throw se.getSQLException();
  }
}","public void registerOutParameter(String parameterName,SQLType sqlType,String typeName) throws SQLException {
synchronized (connection_) {
    if (agent_.loggingEnabled()) {
      agent_.logWriter_.traceEntry(this,""String_Node_Str"",parameterName,sqlType,typeName);
    }
    checkStatus();
    registerOutParameter(parameterName,Utils42.getTypeAsInt(agent_,sqlType),typeName);
  }
}"
80004,"public void setObject(String parameterName,Object x,SQLType sqlType,int scaleOrLength) throws SQLException {
  try {
synchronized (connection_) {
      if (agent_.loggingEnabled()) {
        agent_.logWriter_.traceEntry(this,""String_Node_Str"",parameterName,x,sqlType,scaleOrLength);
      }
      checkForClosedStatement();
      setObject(parameterName,x,Utils42.getTypeAsInt(agent_,sqlType),scaleOrLength);
    }
  }
 catch (  SqlException se) {
    throw se.getSQLException();
  }
}","public void setObject(String parameterName,Object x,SQLType sqlType,int scaleOrLength) throws SQLException {
synchronized (connection_) {
    if (agent_.loggingEnabled()) {
      agent_.logWriter_.traceEntry(this,""String_Node_Str"",parameterName,x,sqlType,scaleOrLength);
    }
    checkStatus();
    setObject(parameterName,x,Utils42.getTypeAsInt(agent_,sqlType),scaleOrLength);
  }
}"
80005,"public boolean acceptsURL(String url) throws java.sql.SQLException {
  try {
    java.util.StringTokenizer urlTokenizer=new java.util.StringTokenizer(url,""String_Node_Str"",true);
    int protocol=tokenizeProtocol(url,urlTokenizer);
    return protocol != 0;
  }
 catch (  SqlException se) {
    throw se.getSQLException();
  }
}","public boolean acceptsURL(String url) throws java.sql.SQLException {
  checkURLNotNull(url);
  try {
    java.util.StringTokenizer urlTokenizer=new java.util.StringTokenizer(url,""String_Node_Str"",true);
    int protocol=tokenizeProtocol(url,urlTokenizer);
    return protocol != 0;
  }
 catch (  SqlException se) {
    throw se.getSQLException();
  }
}"
80006,"public java.sql.Connection connect(String url,java.util.Properties properties) throws java.sql.SQLException {
  org.apache.derby.client.net.NetConnection conn;
  try {
    if (exceptionsOnLoadDriver__ != null) {
      throw exceptionsOnLoadDriver__;
    }
    if (properties == null) {
      properties=new java.util.Properties();
    }
    java.util.StringTokenizer urlTokenizer=new java.util.StringTokenizer(url,""String_Node_Str"",true);
    int protocol=tokenizeProtocol(url,urlTokenizer);
    if (protocol == 0) {
      return null;
    }
    String slashOrNull=null;
    if (protocol == DERBY_REMOTE_PROTOCOL) {
      try {
        slashOrNull=urlTokenizer.nextToken(""String_Node_Str"");
      }
 catch (      java.util.NoSuchElementException e) {
        throw new SqlException(null,new ClientMessageId(SQLState.MALFORMED_URL),url,e);
      }
    }
    String server=tokenizeServerName(urlTokenizer,url);
    int port=tokenizeOptionalPortNumber(urlTokenizer,url);
    if (port == 0) {
      port=ClientBaseDataSourceRoot.propertyDefault_portNumber;
    }
    String database=tokenizeDatabase(urlTokenizer,url);
    java.util.Properties augmentedProperties=tokenizeURLProperties(url,properties);
    database=appendDatabaseAttributes(database,augmentedProperties);
    int traceLevel;
    try {
      traceLevel=ClientBaseDataSourceRoot.getTraceLevel(augmentedProperties);
    }
 catch (    java.lang.NumberFormatException e) {
      throw new SqlException(null,new ClientMessageId(SQLState.TRACELEVEL_FORMAT_INVALID),e);
    }
    org.apache.derby.client.am.LogWriter dncLogWriter=ClientBaseDataSourceRoot.computeDncLogWriterForNewConnection(java.sql.DriverManager.getLogWriter(),ClientBaseDataSourceRoot.getTraceDirectory(augmentedProperties),ClientBaseDataSourceRoot.getTraceFile(augmentedProperties),ClientBaseDataSourceRoot.getTraceFileAppend(augmentedProperties),traceLevel,""String_Node_Str"",traceFileSuffixIndex_++);
    conn=(org.apache.derby.client.net.NetConnection)getFactory().newNetConnection((org.apache.derby.client.net.NetLogWriter)dncLogWriter,java.sql.DriverManager.getLoginTimeout(),server,port,database,augmentedProperties);
  }
 catch (  SqlException se) {
    throw se.getSQLException();
  }
  if (conn.isConnectionNull())   return null;
  return conn;
}","public java.sql.Connection connect(String url,java.util.Properties properties) throws java.sql.SQLException {
  org.apache.derby.client.net.NetConnection conn;
  checkURLNotNull(url);
  try {
    if (exceptionsOnLoadDriver__ != null) {
      throw exceptionsOnLoadDriver__;
    }
    if (properties == null) {
      properties=new java.util.Properties();
    }
    java.util.StringTokenizer urlTokenizer=new java.util.StringTokenizer(url,""String_Node_Str"",true);
    int protocol=tokenizeProtocol(url,urlTokenizer);
    if (protocol == 0) {
      return null;
    }
    String slashOrNull=null;
    if (protocol == DERBY_REMOTE_PROTOCOL) {
      try {
        slashOrNull=urlTokenizer.nextToken(""String_Node_Str"");
      }
 catch (      java.util.NoSuchElementException e) {
        throw new SqlException(null,new ClientMessageId(SQLState.MALFORMED_URL),url,e);
      }
    }
    String server=tokenizeServerName(urlTokenizer,url);
    int port=tokenizeOptionalPortNumber(urlTokenizer,url);
    if (port == 0) {
      port=ClientBaseDataSourceRoot.propertyDefault_portNumber;
    }
    String database=tokenizeDatabase(urlTokenizer,url);
    java.util.Properties augmentedProperties=tokenizeURLProperties(url,properties);
    database=appendDatabaseAttributes(database,augmentedProperties);
    int traceLevel;
    try {
      traceLevel=ClientBaseDataSourceRoot.getTraceLevel(augmentedProperties);
    }
 catch (    java.lang.NumberFormatException e) {
      throw new SqlException(null,new ClientMessageId(SQLState.TRACELEVEL_FORMAT_INVALID),e);
    }
    org.apache.derby.client.am.LogWriter dncLogWriter=ClientBaseDataSourceRoot.computeDncLogWriterForNewConnection(java.sql.DriverManager.getLogWriter(),ClientBaseDataSourceRoot.getTraceDirectory(augmentedProperties),ClientBaseDataSourceRoot.getTraceFile(augmentedProperties),ClientBaseDataSourceRoot.getTraceFileAppend(augmentedProperties),traceLevel,""String_Node_Str"",traceFileSuffixIndex_++);
    conn=(org.apache.derby.client.net.NetConnection)getFactory().newNetConnection((org.apache.derby.client.net.NetLogWriter)dncLogWriter,java.sql.DriverManager.getLoginTimeout(),server,port,database,augmentedProperties);
  }
 catch (  SqlException se) {
    throw se.getSQLException();
  }
  if (conn.isConnectionNull())   return null;
  return conn;
}"
80007,"/** 
 * Checks whether a data type is supported for <code>setObject(int, Object, int)</code> and <code>setObject(int, Object, int, int)</code>.
 * @param dataType the data type to check
 * @exception SQLException if the type is not supported
 */
public void checkForSupportedDataType(int dataType) throws SQLException {
switch (dataType) {
case Types.ARRAY:
case Types.DATALINK:
case JDBC40Translation.NCHAR:
case JDBC40Translation.NCLOB:
case JDBC40Translation.NVARCHAR:
case JDBC40Translation.LONGNVARCHAR:
case Types.REF:
case JDBC40Translation.REF_CURSOR:
case JDBC40Translation.ROWID:
case JDBC40Translation.SQLXML:
case Types.STRUCT:
    throw newSQLException(SQLState.DATA_TYPE_NOT_SUPPORTED,Util.typeName(dataType));
}
}","/** 
 * Checks whether a data type is supported for <code>setObject(int, Object, int)</code> and <code>setObject(int, Object, int, int)</code>.
 * @param dataType the data type to check
 * @exception SQLException if the type is not supported
 */
public void checkForSupportedDataType(int dataType) throws SQLException {
switch (dataType) {
case Types.ARRAY:
case Types.DATALINK:
case Types.DISTINCT:
case JDBC40Translation.NCHAR:
case JDBC40Translation.NCLOB:
case JDBC40Translation.NVARCHAR:
case JDBC40Translation.LONGNVARCHAR:
case Types.NULL:
case Types.OTHER:
case Types.REF:
case JDBC40Translation.REF_CURSOR:
case JDBC40Translation.ROWID:
case JDBC40Translation.SQLXML:
case Types.STRUCT:
    throw newSQLException(SQLState.DATA_TYPE_NOT_SUPPORTED,Util.typeName(dataType));
}
}"
80008,"public static boolean embeddedDriverAcceptsURL(String url){
  return !url.startsWith(Attribute.JCC_PROTOCOL) && !url.startsWith(Attribute.DNC_PROTOCOL) && (url.startsWith(Attribute.PROTOCOL) || url.equals(Attribute.SQLJ_NESTED));
}","public static boolean embeddedDriverAcceptsURL(String url) throws SQLException {
  if (url == null) {
    throw Util.generateCsSQLException(SQLState.MALFORMED_URL,""String_Node_Str"");
  }
  return !url.startsWith(Attribute.JCC_PROTOCOL) && !url.startsWith(Attribute.DNC_PROTOCOL) && (url.startsWith(Attribute.PROTOCOL) || url.equals(Attribute.SQLJ_NESTED));
}"
80009,"public boolean acceptsURL(String url){
  return active && embeddedDriverAcceptsURL(url);
}","public boolean acceptsURL(String url) throws SQLException {
  return active && embeddedDriverAcceptsURL(url);
}"
80010,"public boolean acceptsURL(String url){
  return driver.acceptsURL(url);
}","public boolean acceptsURL(String url) throws SQLException {
  return driver.acceptsURL(url);
}"
80011,"/** 
 * Does the driver accept the passed in JDBC URL
 * @param url JDBC URL to check.
 * @return True if it supports it, false otherwise.
 * @see java.sql.Driver#acceptsURL(String)
 */
public boolean acceptsURL(String url);","/** 
 * Does the driver accept the passed in JDBC URL
 * @param url JDBC URL to check.
 * @return True if it supports it, false otherwise.
 * @see java.sql.Driver#acceptsURL(String)
 */
public boolean acceptsURL(String url) throws SQLException ;"
80012,"/** 
 * This method is overriden on JVM 8 
 */
protected java.sql.BatchUpdateException newBatchUpdateException(String message,String sqlState,int errorCode,long[] updateCounts){
  return new java.sql.BatchUpdateException(message,sqlState,errorCode,Utils.squashLongs(updateCounts));
}","/** 
 * This method is overriden on JVM 8 
 */
protected java.sql.BatchUpdateException newBatchUpdateException(String message,String sqlState,int errorCode,long[] updateCounts,SqlException cause){
  java.sql.BatchUpdateException bue=new java.sql.BatchUpdateException(message,sqlState,errorCode,Utils.squashLongs(updateCounts));
  if (cause != null) {
    bue.initCause(cause);
  }
  return bue;
}"
80013,"/** 
 * This method is overriden on JVM 8 to take advantage of long update counts 
 */
protected java.sql.BatchUpdateException newBatchUpdateException(String message,String sqlState,int errorCode,long[] updateCounts){
  return new java.sql.BatchUpdateException(message,sqlState,errorCode,updateCounts,null);
}","/** 
 * This method is overriden on JVM 8 to take advantage of long update counts 
 */
protected java.sql.BatchUpdateException newBatchUpdateException(String message,String sqlState,int errorCode,long[] updateCounts,SqlException cause){
  return new java.sql.BatchUpdateException(message,sqlState,errorCode,updateCounts,cause);
}"
80014,"/** 
 * JDBC 4.2 Submit a batch of commands to the database for execution. This method is optional. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
public long[] executeLargeBatch() throws SQLException {
  checkExecStatus();
synchronized (getConnectionSynchronization()) {
    setupContextStack();
    int i=0;
    clearResultSets();
    Vector stmts=batchStatements;
    batchStatements=null;
    int size;
    if (stmts == null)     size=0;
 else     size=stmts.size();
    long[] returnUpdateCountForBatch=new long[size];
    SQLException sqle;
    try {
      for (; i < size; i++) {
        InterruptStatus.throwIf(lcc);
        if (executeBatchElement(stmts.get(i)))         throw newSQLException(SQLState.RESULTSET_RETURN_NOT_ALLOWED);
        returnUpdateCountForBatch[i]=getLargeUpdateCount();
      }
      InterruptStatus.restoreIntrFlagIfSeen(lcc);
      return returnUpdateCountForBatch;
    }
 catch (    StandardException se) {
      sqle=handleException(se);
    }
catch (    SQLException sqle2) {
      sqle=sqle2;
    }
 finally {
      restoreContextStack();
    }
    long[] successfulUpdateCount=new long[i];
    System.arraycopy(returnUpdateCountForBatch,0,successfulUpdateCount,0,i);
    SQLException batch=Util.newBatchUpdateException(sqle.getMessage(),sqle.getSQLState(),sqle.getErrorCode(),successfulUpdateCount);
    batch.setNextException(sqle);
    batch.initCause(sqle);
    throw batch;
  }
}","/** 
 * JDBC 4.2 Submit a batch of commands to the database for execution. This method is optional. For use with statements which may touch more than Integer.MAX_VALUE rows.
 */
public long[] executeLargeBatch() throws SQLException {
  checkExecStatus();
synchronized (getConnectionSynchronization()) {
    setupContextStack();
    int i=0;
    clearResultSets();
    Vector stmts=batchStatements;
    batchStatements=null;
    int size;
    if (stmts == null)     size=0;
 else     size=stmts.size();
    long[] returnUpdateCountForBatch=new long[size];
    SQLException sqle;
    try {
      for (; i < size; i++) {
        InterruptStatus.throwIf(lcc);
        if (executeBatchElement(stmts.get(i)))         throw newSQLException(SQLState.RESULTSET_RETURN_NOT_ALLOWED);
        returnUpdateCountForBatch[i]=getLargeUpdateCount();
      }
      InterruptStatus.restoreIntrFlagIfSeen(lcc);
      return returnUpdateCountForBatch;
    }
 catch (    StandardException se) {
      sqle=handleException(se);
    }
catch (    SQLException sqle2) {
      sqle=sqle2;
    }
 finally {
      restoreContextStack();
    }
    long[] successfulUpdateCount=new long[i];
    System.arraycopy(returnUpdateCountForBatch,0,successfulUpdateCount,0,i);
    SQLException batch=Util.newBatchUpdateException(sqle.getMessage(),sqle.getSQLState(),sqle.getErrorCode(),successfulUpdateCount,sqle);
    throw batch;
  }
}"
80015,"/** 
 * Create the correct BatchUpdateException depending on whether this is Java 8 or lower 
 */
static SQLException newBatchUpdateException(String message,String sqlState,int errorCode,long[] updateCounts){
  if (JVMInfo.JDK_ID >= JVMInfo.J2SE_18) {
    try {
      Constructor constructor=BatchUpdateException.class.getConstructor(new Class[]{String.class,String.class,Integer.TYPE,updateCounts.getClass(),Throwable.class});
      return (BatchUpdateException)constructor.newInstance(new Object[]{message,sqlState,new Integer(errorCode),updateCounts,(Throwable)null});
    }
 catch (    Exception e) {
      logError(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
    }
  }
  return new BatchUpdateException(message,sqlState,errorCode,squashLongs(updateCounts));
}","/** 
 * Create the correct BatchUpdateException depending on whether this is Java 8 or lower 
 */
static SQLException newBatchUpdateException(String message,String sqlState,int errorCode,long[] updateCounts,Throwable cause){
  if (JVMInfo.JDK_ID >= JVMInfo.J2SE_18) {
    try {
      Constructor constructor=BatchUpdateException.class.getConstructor(new Class[]{String.class,String.class,Integer.TYPE,updateCounts.getClass(),Throwable.class});
      return (BatchUpdateException)constructor.newInstance(new Object[]{message,sqlState,new Integer(errorCode),updateCounts,cause});
    }
 catch (    Exception e) {
      logError(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"",e);
    }
  }
  BatchUpdateException batch=new BatchUpdateException(message,sqlState,errorCode,squashLongs(updateCounts));
  if (cause instanceof SQLException) {
    batch.setNextException((SQLException)cause);
  }
  batch.initCause(cause);
  return batch;
}"
80016,"/** 
 * Add result columns for a Derby-style Table Function
 */
private void createResultColumnsForTableFunction(TypeDescriptor td) throws StandardException {
  String[] columnNames=td.getRowColumnNames();
  TypeDescriptor[] types=td.getRowTypes();
  for (int i=0; i < columnNames.length; i++) {
    resultColumns.addColumn(exposedName,columnNames[i],DataTypeDescriptor.getType(types[i]));
  }
}","/** 
 * Add result columns for a Derby-style Table Function
 */
private void createResultColumnsForTableFunction(TypeDescriptor td) throws StandardException {
  String[] columnNames=td.getRowColumnNames();
  TypeDescriptor[] types=td.getRowTypes();
  for (int i=0; i < columnNames.length; i++) {
    String columnName=columnNames[i];
    DataTypeDescriptor dtd=DataTypeDescriptor.getType(types[i]);
    ResultColumn rc=resultColumns.addColumn(exposedName,columnName,dtd);
    ColumnDescriptor coldesc=new ColumnDescriptor(columnName,i + 1,dtd,(DataValueDescriptor)null,(DefaultInfo)null,(UUID)null,(UUID)null,0L,0L,0L);
    rc.setColumnDescriptor(null,coldesc);
  }
}"
80017,"/** 
 * Add a column to the list given a tablename, columnname, and datatype.
 */
public void addColumn(TableName tableName,String columnName,DataTypeDescriptor dts) throws StandardException {
  ValueNode bcn=(ValueNode)getNodeFactory().getNode(C_NodeTypes.BASE_COLUMN_NODE,columnName,tableName,dts,getContextManager());
  ResultColumn rc=(ResultColumn)getNodeFactory().getNode(C_NodeTypes.RESULT_COLUMN,columnName,bcn,getContextManager());
  rc.setType(dts);
  addResultColumn(rc);
}","/** 
 * Add a column to the list given a tablename, columnname, and datatype. Return the just-added column.
 */
public ResultColumn addColumn(TableName tableName,String columnName,DataTypeDescriptor dts) throws StandardException {
  ValueNode bcn=(ValueNode)getNodeFactory().getNode(C_NodeTypes.BASE_COLUMN_NODE,columnName,tableName,dts,getContextManager());
  ResultColumn rc=(ResultColumn)getNodeFactory().getNode(C_NodeTypes.RESULT_COLUMN,columnName,bcn,getContextManager());
  rc.setType(dts);
  addResultColumn(rc);
  return rc;
}"
80018,"/** 
 * <p> Miscellaneous bugs. </p>
 */
private void miscBugs() throws Exception {
  derby_4092();
  derby_5779();
}","/** 
 * <p> Miscellaneous bugs. </p>
 */
private void miscBugs() throws Exception {
  derby_4092();
  derby_5779();
  derby_6040();
}"
80019,"/** 
 * <p> Generate the trailing routine arguments into a varargs array and push that array onto the stack. </p>
 */
private void generateVarargs(ExpressionClassBuilder acb,MethodBuilder mb) throws StandardException {
  Class[] parameterTypes=((Method)method).getParameterTypes();
  int firstVarargIdx=parameterTypes.length - 1;
  Class varargType=parameterTypes[firstVarargIdx].getComponentType();
  int varargCount=methodParms.length - firstVarargIdx;
  if (varargCount < 0) {
    varargCount=0;
  }
  LocalField arrayField=acb.newFieldDeclaration(Modifier.PRIVATE,varargType.getName() + ""String_Node_Str"");
  MethodBuilder cb=acb.getConstructor();
  cb.pushNewArray(varargType.getName(),varargCount);
  cb.setField(arrayField);
  for (int i=0; i < varargCount; i++) {
    mb.getField(arrayField);
    generateAndCastOneParameter(acb,mb,i + firstVarargIdx,methodParameterTypes[firstVarargIdx]);
    mb.setArrayElement(i);
  }
  mb.getField(arrayField);
}","/** 
 * <p> Generate the trailing routine arguments into a varargs array and push that array onto the stack. </p>
 */
private void generateVarargs(ExpressionClassBuilder acb,MethodBuilder mb) throws StandardException {
  int firstVarargIdx=getFirstVarargIdx();
  String arrayType=methodParameterTypes[firstVarargIdx];
  String cellType=stripOneArrayLevel(arrayType);
  String varargType=cellType;
  if (routineInfo != null) {
    if (routineInfo.getParameterModes()[firstVarargIdx] != JDBC30Translation.PARAMETER_MODE_IN) {
      varargType=stripOneArrayLevel(varargType);
    }
  }
  int varargCount=methodParms.length - firstVarargIdx;
  if (varargCount < 0) {
    varargCount=0;
  }
  LocalField arrayField=acb.newFieldDeclaration(Modifier.PRIVATE,arrayType);
  MethodBuilder cb=acb.getConstructor();
  cb.pushNewArray(cellType,varargCount);
  cb.setField(arrayField);
  for (int i=0; i < varargCount; i++) {
    mb.getField(arrayField);
    generateAndCastOneParameter(acb,mb,i + firstVarargIdx,cellType);
    mb.setArrayElement(i);
  }
  mb.getField(arrayField);
}"
80020,"/** 
 * Build parameters for error message and throw the exception when there is no matching signature found.
 * @param receiverTypeName	Type name for receiver
 * @param parmTypeNames		Type names for parameters as object types
 * @param primParmTypeNames	Type names for parameters as primitive types
 * @exception StandardException		Thrown on error
 */
void throwNoMethodFound(String receiverTypeName,String[] parmTypeNames,String[] primParmTypeNames) throws StandardException {
  StringBuffer parmTypes=new StringBuffer();
  for (int i=0; i < parmTypeNames.length; i++) {
    if (i != 0)     parmTypes.append(""String_Node_Str"");
    parmTypes.append((parmTypeNames[i].length() != 0 ? parmTypeNames[i] : ""String_Node_Str""));
    if ((primParmTypeNames != null) && !primParmTypeNames[i].equals(parmTypeNames[i]))     parmTypes.append(""String_Node_Str"" + primParmTypeNames[i] + ""String_Node_Str"");
  }
  throw StandardException.newException(SQLState.LANG_NO_METHOD_FOUND,receiverTypeName,methodName,parmTypes);
}","/** 
 * Build parameters for error message and throw the exception when there is no matching signature found.
 * @param receiverTypeName	Type name for receiver
 * @param parmTypeNames		Type names for parameters as object types
 * @param primParmTypeNames	Type names for parameters as primitive types
 * @exception StandardException		Thrown on error
 */
void throwNoMethodFound(String receiverTypeName,String[] parmTypeNames,String[] primParmTypeNames) throws StandardException {
  StringBuffer parmTypes=new StringBuffer();
  boolean hasVarargs=hasVarargs();
  int firstVarargIdx=getFirstVarargIdx();
  int paramCount=signature.length;
  for (int i=0; i < paramCount; i++) {
    if (i != 0) {
      parmTypes.append(""String_Node_Str"");
    }
    boolean isVararg=isVararg(i);
    String parmType=parmTypeNames[i];
    if (parmTypeNames[i].length() == 0) {
      parmType=""String_Node_Str"";
    }
 else     if (isVararg) {
      parmType=getVarargTypeName(parmType);
    }
    parmTypes.append(parmType);
    if ((primParmTypeNames != null) && !primParmTypeNames[i].equals(parmTypeNames[i])) {
      String primTypeName=primParmTypeNames[i];
      if (isVararg) {
        primTypeName=getVarargTypeName(primTypeName);
      }
      parmTypes.append(""String_Node_Str"" + primTypeName + ""String_Node_Str"");
    }
  }
  throw StandardException.newException(SQLState.LANG_NO_METHOD_FOUND,receiverTypeName,methodName,parmTypes);
}"
80021,"/** 
 * <p> Get the offset into the routine arguments corresponding to the index of the invocation parameter. The two indexes may be different in the case of varargs methods. There may be more invocation args than declared routine args. For a varargs routine, all of the trailing invocation parameters correspond to the last argument declared by the CREATE FUNCTION/PROCEDURE statement. </p>
 */
protected int getRoutineArgIdx(int invocationArgIdx){
  if (routineInfo == null) {
    return invocationArgIdx;
  }
  if (!routineInfo.hasVarargs()) {
    return invocationArgIdx;
  }
  int firstVarargIdx=routineInfo.getParameterCount() - 1;
  return (firstVarargIdx < invocationArgIdx) ? firstVarargIdx : invocationArgIdx;
}","protected int getRoutineArgIdx(RoutineAliasInfo rai,int invocationArgIdx){
  if (!rai.hasVarargs()) {
    return invocationArgIdx;
  }
  int firstVarargIdx=rai.getParameterCount() - 1;
  return (firstVarargIdx < invocationArgIdx) ? firstVarargIdx : invocationArgIdx;
}"
80022,"protected void resolveMethodCall(String javaClassName,boolean staticMethod) throws StandardException {
  if (routineInfo == null && !internalCall) {
    if ((getCompilerContext().getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0) {
      throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,javaClassName + (staticMethod ? ""String_Node_Str"" : ""String_Node_Str"") + methodName);
    }
  }
  int count=signature.length;
  ClassInspector classInspector=getClassFactory().getClassInspector();
  String[] parmTypeNames;
  String[] primParmTypeNames=null;
  boolean[] isParam=getIsParam();
  boolean hasDynamicResultSets=hasVarargs() ? false : (routineInfo != null) && (count != 0) && (count != methodParms.length);
  int signatureOffset=methodName.indexOf('(');
  if (signatureOffset != -1) {
    parmTypeNames=parseValidateSignature(methodName,signatureOffset,hasDynamicResultSets);
    methodName=methodName.substring(0,signatureOffset);
    hasDynamicResultSets=false;
  }
 else {
    parmTypeNames=getObjectSignature();
  }
  if (hasVarargs()) {
    parmTypeNames[count - 1]=parmTypeNames[count - 1] + ""String_Node_Str"";
  }
  try {
    method=classInspector.findPublicMethod(javaClassName,methodName,parmTypeNames,null,isParam,staticMethod,hasDynamicResultSets,hasVarargs());
    if (signatureOffset == -1 && routineInfo == null) {
      if (method == null) {
        primParmTypeNames=getPrimitiveSignature(false);
        method=classInspector.findPublicMethod(javaClassName,methodName,parmTypeNames,primParmTypeNames,isParam,staticMethod,hasDynamicResultSets,hasVarargs());
      }
    }
  }
 catch (  ClassNotFoundException e) {
    method=null;
  }
  if (method == null) {
    throwNoMethodFound(javaClassName,parmTypeNames,primParmTypeNames);
  }
  String typeName=classInspector.getType(method);
  actualMethodReturnType=typeName;
  if (routineInfo == null) {
    if (typeName.equals(""String_Node_Str"")) {
      if (!forCallStatement)       throw StandardException.newException(SQLState.LANG_VOID_METHOD_CALL);
    }
  }
 else {
    String promoteName=null;
    TypeDescriptorImpl returnType=(TypeDescriptorImpl)routineInfo.getReturnType();
    String requiredType;
    if (returnType == null) {
      requiredType=""String_Node_Str"";
    }
 else {
      TypeId returnTypeId=TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
      if (returnType.isRowMultiSet() && (routineInfo.getParameterStyle() == RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET)) {
        requiredType=ResultSet.class.getName();
      }
 else       if (returnType.getTypeId().userType()) {
        requiredType=((UserDefinedTypeIdImpl)returnType.getTypeId()).getClassName();
      }
 else {
        requiredType=returnTypeId.getCorrespondingJavaTypeName();
        if (!requiredType.equals(typeName)) {
switch (returnType.getJDBCTypeId()) {
case java.sql.Types.BOOLEAN:
case java.sql.Types.SMALLINT:
case java.sql.Types.INTEGER:
case java.sql.Types.BIGINT:
case java.sql.Types.REAL:
case java.sql.Types.DOUBLE:
            TypeCompiler tc=getTypeCompiler(returnTypeId);
          requiredType=tc.getCorrespondingPrimitiveTypeName();
        if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0) {
          promoteName=returnTypeId.getCorrespondingJavaTypeName();
        }
      break;
  }
}
}
}
boolean foundCorrectType;
if (ResultSet.class.getName().equals(requiredType)) {
try {
Class actualType=classInspector.getClass(typeName);
foundCorrectType=ResultSet.class.isAssignableFrom(actualType);
}
 catch (ClassNotFoundException cnfe) {
foundCorrectType=false;
}
}
 else {
foundCorrectType=requiredType.equals(typeName);
}
if (!foundCorrectType) {
throwNoMethodFound(requiredType + ""String_Node_Str"" + javaClassName,parmTypeNames,primParmTypeNames);
}
if (promoteName != null) typeName=promoteName;
if (routineInfo.getReturnType() != null) setCollationType(routineInfo.getReturnType().getCollationType());
}
setJavaTypeName(typeName);
methodParameterTypes=classInspector.getParameterTypes(method);
for (int i=0; i < methodParameterTypes.length; i++) {
String methodParameter=methodParameterTypes[i];
if (routineInfo != null) {
if (i < routineInfo.getParameterCount()) {
int parameterMode=routineInfo.getParameterModes()[i];
switch (parameterMode) {
case JDBC30Translation.PARAMETER_MODE_IN:
  break;
case JDBC30Translation.PARAMETER_MODE_IN_OUT:
methodParameter=methodParameter.substring(0,methodParameter.length() - 2);
break;
case JDBC30Translation.PARAMETER_MODE_OUT:
continue;
}
}
}
if (ClassInspector.primitiveType(methodParameter)) methodParms[i].castToPrimitive(true);
}
if (someParametersAreNull()) {
setNullParameterInfo(methodParameterTypes);
}
DataTypeDescriptor dts=DataTypeDescriptor.getSQLDataTypeDescriptor(typeName);
if (getCompilerContext().getReturnParameterFlag()) {
getCompilerContext().getParameterTypes()[0]=dts;
}
}","protected void resolveMethodCall(String javaClassName,boolean staticMethod) throws StandardException {
  if (routineInfo == null && !internalCall) {
    if ((getCompilerContext().getReliability() & CompilerContext.INTERNAL_SQL_ILLEGAL) != 0) {
      throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,javaClassName + (staticMethod ? ""String_Node_Str"" : ""String_Node_Str"") + methodName);
    }
  }
  int count=signature.length;
  ClassInspector classInspector=getClassFactory().getClassInspector();
  String[] parmTypeNames;
  String[] primParmTypeNames=null;
  boolean[] isParam=getIsParam();
  boolean hasDynamicResultSets=hasVarargs() ? false : (routineInfo != null) && (count != 0) && (count != methodParms.length);
  int signatureOffset=methodName.indexOf('(');
  if (signatureOffset != -1) {
    parmTypeNames=parseValidateSignature(methodName,signatureOffset,hasDynamicResultSets);
    methodName=methodName.substring(0,signatureOffset);
    hasDynamicResultSets=false;
  }
 else {
    parmTypeNames=getObjectSignature();
  }
  if (hasVarargs()) {
    parmTypeNames[count - 1]=parmTypeNames[count - 1] + ""String_Node_Str"";
  }
  try {
    method=classInspector.findPublicMethod(javaClassName,methodName,parmTypeNames,null,isParam,staticMethod,hasDynamicResultSets,hasVarargs());
    if (signatureOffset == -1 && routineInfo == null) {
      if (method == null) {
        primParmTypeNames=getPrimitiveSignature(false);
        method=classInspector.findPublicMethod(javaClassName,methodName,parmTypeNames,primParmTypeNames,isParam,staticMethod,hasDynamicResultSets,hasVarargs());
      }
    }
  }
 catch (  ClassNotFoundException e) {
    method=null;
  }
  if (method == null) {
    throwNoMethodFound(javaClassName,parmTypeNames,primParmTypeNames);
  }
  String typeName=classInspector.getType(method);
  actualMethodReturnType=typeName;
  if (routineInfo == null) {
    if (typeName.equals(""String_Node_Str"")) {
      if (!forCallStatement)       throw StandardException.newException(SQLState.LANG_VOID_METHOD_CALL);
    }
  }
 else {
    String promoteName=null;
    TypeDescriptorImpl returnType=(TypeDescriptorImpl)routineInfo.getReturnType();
    String requiredType;
    if (returnType == null) {
      requiredType=""String_Node_Str"";
    }
 else {
      TypeId returnTypeId=TypeId.getBuiltInTypeId(returnType.getJDBCTypeId());
      if (returnType.isRowMultiSet() && (routineInfo.getParameterStyle() == RoutineAliasInfo.PS_DERBY_JDBC_RESULT_SET)) {
        requiredType=ResultSet.class.getName();
      }
 else       if (returnType.getTypeId().userType()) {
        requiredType=((UserDefinedTypeIdImpl)returnType.getTypeId()).getClassName();
      }
 else {
        requiredType=returnTypeId.getCorrespondingJavaTypeName();
        if (!requiredType.equals(typeName)) {
switch (returnType.getJDBCTypeId()) {
case java.sql.Types.BOOLEAN:
case java.sql.Types.SMALLINT:
case java.sql.Types.INTEGER:
case java.sql.Types.BIGINT:
case java.sql.Types.REAL:
case java.sql.Types.DOUBLE:
            TypeCompiler tc=getTypeCompiler(returnTypeId);
          requiredType=tc.getCorrespondingPrimitiveTypeName();
        if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0) {
          promoteName=returnTypeId.getCorrespondingJavaTypeName();
        }
      break;
  }
}
}
}
boolean foundCorrectType;
if (ResultSet.class.getName().equals(requiredType)) {
try {
Class actualType=classInspector.getClass(typeName);
foundCorrectType=ResultSet.class.isAssignableFrom(actualType);
}
 catch (ClassNotFoundException cnfe) {
foundCorrectType=false;
}
}
 else {
foundCorrectType=requiredType.equals(typeName);
}
if (!foundCorrectType) {
throwNoMethodFound(requiredType + ""String_Node_Str"" + javaClassName,parmTypeNames,primParmTypeNames);
}
if (promoteName != null) typeName=promoteName;
if (routineInfo.getReturnType() != null) setCollationType(routineInfo.getReturnType().getCollationType());
}
setJavaTypeName(typeName);
methodParameterTypes=classInspector.getParameterTypes(method);
String methodParameter=null;
for (int i=0; i < methodParameterTypes.length; i++) {
methodParameter=methodParameterTypes[i];
if (routineInfo != null) {
if (i < routineInfo.getParameterCount()) {
int parameterMode=routineInfo.getParameterModes()[getRoutineArgIdx(i)];
switch (parameterMode) {
case JDBC30Translation.PARAMETER_MODE_IN:
  break;
case JDBC30Translation.PARAMETER_MODE_IN_OUT:
methodParameter=stripOneArrayLevel(methodParameter);
break;
case JDBC30Translation.PARAMETER_MODE_OUT:
continue;
}
}
}
if (hasVarargs() && (i >= getFirstVarargIdx())) {
methodParameter=stripOneArrayLevel(methodParameter);
}
if (ClassInspector.primitiveType(methodParameter)) {
if (i < methodParms.length) {
methodParms[i].castToPrimitive(true);
}
}
}
if (hasVarargs()) {
int firstVarargIdx=getFirstVarargIdx();
int trailingVarargCount=methodParms.length - firstVarargIdx;
for (int i=1; i < trailingVarargCount; i++) {
if (ClassInspector.primitiveType(methodParameter)) {
methodParms[i + firstVarargIdx].castToPrimitive(true);
}
}
}
if (someParametersAreNull()) {
setNullParameterInfo(methodParameterTypes);
}
DataTypeDescriptor dts=DataTypeDescriptor.getSQLDataTypeDescriptor(typeName);
if (getCompilerContext().getReturnParameterFlag()) {
getCompilerContext().getParameterTypes()[0]=dts;
}
}"
80023,"/** 
 * Resolve a routine. Obtain a list of routines from the data dictionary of the correct type (functions or procedures) and name. Pick the best routine from the list. Currently only a single routine with a given type and name is allowed, thus if changes are made to support overloaded routines, careful code inspection and testing will be required.
 * @param fromList
 * @param subqueryList
 * @param aggregateVector
 * @param sd
 * @throws StandardException
 */
private void resolveRoutine(FromList fromList,SubqueryList subqueryList,Vector aggregateVector,SchemaDescriptor sd) throws StandardException {
  if (sd.getUUID() != null) {
    java.util.List list=getDataDictionary().getRoutineList(sd.getUUID().toString(),methodName,forCallStatement ? AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR);
    for (int i=list.size() - 1; i >= 0; i--) {
      AliasDescriptor proc=(AliasDescriptor)list.get(i);
      RoutineAliasInfo routineInfo=(RoutineAliasInfo)proc.getAliasInfo();
      int parameterCount=routineInfo.getParameterCount();
      boolean hasVarargs=routineInfo.hasVarargs();
      if (hasVarargs) {
        if (methodParms.length < (parameterCount - 1)) {
          continue;
        }
      }
 else       if (parameterCount != methodParms.length) {
        continue;
      }
      TypeDescriptor[] parameterTypes=routineInfo.getParameterTypes();
      int sigParameterCount=parameterCount;
      if (routineInfo.getMaxDynamicResultSets() > 0) {
        sigParameterCount++;
      }
      signature=new JSQLType[sigParameterCount];
      for (int p=0; p < parameterCount; p++) {
        TypeDescriptor td=parameterTypes[p];
        TypeId typeId=TypeId.getTypeId(td);
        TypeId parameterTypeId=typeId;
        int parameterMode=routineInfo.getParameterModes()[p];
        if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
          String arrayType;
switch (typeId.getJDBCTypeId()) {
case java.sql.Types.BOOLEAN:
case java.sql.Types.SMALLINT:
case java.sql.Types.INTEGER:
case java.sql.Types.BIGINT:
case java.sql.Types.REAL:
case java.sql.Types.DOUBLE:
            arrayType=getTypeCompiler(typeId).getCorrespondingPrimitiveTypeName().concat(""String_Node_Str"");
          break;
default :
        arrayType=typeId.getCorrespondingJavaTypeName().concat(""String_Node_Str"");
      break;
  }
  typeId=TypeId.getUserDefinedTypeId(arrayType);
}
DataTypeDescriptor methoddtd=new DataTypeDescriptor(typeId,td.getPrecision(),td.getScale(),td.isNullable(),td.getMaximumWidth());
signature[p]=new JSQLType(methoddtd);
DataTypeDescriptor paramdtd=new DataTypeDescriptor(parameterTypeId,td.getPrecision(),td.getScale(),td.isNullable(),td.getMaximumWidth());
if (hasVarargs && (p == parameterCount - 1)) {
  for (int idx=p; idx < methodParms.length; idx++) {
    coerceMethodParameter(fromList,subqueryList,aggregateVector,parameterCount,paramdtd,parameterTypeId,parameterMode,idx);
  }
}
 else {
  coerceMethodParameter(fromList,subqueryList,aggregateVector,parameterCount,paramdtd,parameterTypeId,parameterMode,p);
}
}
if (sigParameterCount != parameterCount) {
DataTypeDescriptor dtd=new DataTypeDescriptor(TypeId.getUserDefinedTypeId(""String_Node_Str""),0,0,false,-1);
signature[parameterCount]=new JSQLType(dtd);
}
this.routineInfo=routineInfo;
ad=proc;
if (sd.isSystemSchema() && (routineInfo.getReturnType() == null) && routineInfo.getSQLAllowed() != RoutineAliasInfo.NO_SQL) {
isSystemCode=true;
}
routineDefiner=sd.getAuthorizationId();
break;
}
}
if ((ad == null) && (methodParms.length == 1)) {
ad=AggregateNode.resolveAggregate(getDataDictionary(),sd,methodName);
}
}","/** 
 * Resolve a routine. Obtain a list of routines from the data dictionary of the correct type (functions or procedures) and name. Pick the best routine from the list. Currently only a single routine with a given type and name is allowed, thus if changes are made to support overloaded routines, careful code inspection and testing will be required.
 * @param fromList
 * @param subqueryList
 * @param aggregateVector
 * @param sd
 * @throws StandardException
 */
private void resolveRoutine(FromList fromList,SubqueryList subqueryList,Vector aggregateVector,SchemaDescriptor sd) throws StandardException {
  if (sd.getUUID() != null) {
    java.util.List list=getDataDictionary().getRoutineList(sd.getUUID().toString(),methodName,forCallStatement ? AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR : AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR);
    for (int i=list.size() - 1; i >= 0; i--) {
      AliasDescriptor proc=(AliasDescriptor)list.get(i);
      RoutineAliasInfo routineInfo=(RoutineAliasInfo)proc.getAliasInfo();
      int parameterCount=routineInfo.getParameterCount();
      boolean hasVarargs=routineInfo.hasVarargs();
      if (hasVarargs) {
        if (methodParms.length < (parameterCount - 1)) {
          continue;
        }
      }
 else       if (parameterCount != methodParms.length) {
        continue;
      }
      TypeDescriptor[] parameterTypes=routineInfo.getParameterTypes();
      int sigParameterCount=parameterCount;
      if (routineInfo.getMaxDynamicResultSets() > 0) {
        sigParameterCount++;
      }
      signature=new JSQLType[sigParameterCount];
      for (int p=0; p < parameterCount; p++) {
        TypeDescriptor td=parameterTypes[p];
        TypeId typeId=TypeId.getTypeId(td);
        TypeId parameterTypeId=typeId;
        int parameterMode=routineInfo.getParameterModes()[getRoutineArgIdx(routineInfo,p)];
        if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
          String arrayType;
switch (typeId.getJDBCTypeId()) {
case java.sql.Types.BOOLEAN:
case java.sql.Types.SMALLINT:
case java.sql.Types.INTEGER:
case java.sql.Types.BIGINT:
case java.sql.Types.REAL:
case java.sql.Types.DOUBLE:
            arrayType=getTypeCompiler(typeId).getCorrespondingPrimitiveTypeName().concat(""String_Node_Str"");
          break;
default :
        arrayType=typeId.getCorrespondingJavaTypeName().concat(""String_Node_Str"");
      break;
  }
  typeId=TypeId.getUserDefinedTypeId(arrayType);
}
DataTypeDescriptor methoddtd=new DataTypeDescriptor(typeId,td.getPrecision(),td.getScale(),td.isNullable(),td.getMaximumWidth());
signature[p]=new JSQLType(methoddtd);
DataTypeDescriptor paramdtd=new DataTypeDescriptor(parameterTypeId,td.getPrecision(),td.getScale(),td.isNullable(),td.getMaximumWidth());
if (hasVarargs && (p == parameterCount - 1)) {
  for (int idx=p; idx < methodParms.length; idx++) {
    coerceMethodParameter(fromList,subqueryList,aggregateVector,methodParms.length,paramdtd,parameterTypeId,parameterMode,idx);
  }
}
 else {
  coerceMethodParameter(fromList,subqueryList,aggregateVector,methodParms.length,paramdtd,parameterTypeId,parameterMode,p);
}
}
if (sigParameterCount != parameterCount) {
DataTypeDescriptor dtd=new DataTypeDescriptor(TypeId.getUserDefinedTypeId(""String_Node_Str""),0,0,false,-1);
signature[parameterCount]=new JSQLType(dtd);
}
this.routineInfo=routineInfo;
ad=proc;
if (sd.isSystemSchema() && (routineInfo.getReturnType() == null) && routineInfo.getSQLAllowed() != RoutineAliasInfo.NO_SQL) {
isSystemCode=true;
}
routineDefiner=sd.getAuthorizationId();
break;
}
}
if ((ad == null) && (methodParms.length == 1)) {
ad=AggregateNode.resolveAggregate(getDataDictionary(),sd,methodName);
}
}"
80024,"/** 
 * Do code generation for this method call
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
public void generateExpression(ExpressionClassBuilder acb,MethodBuilder mb) throws StandardException {
  if (routineInfo != null) {
    if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)     returnsNullOnNullState=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
  }
  if (returnsNullOnNullState != null) {
    mb.push(false);
    mb.setField(returnsNullOnNullState);
    mb.pushThis();
  }
  int nargs=generateParameters(acb,mb);
  LocalField functionEntrySQLAllowed=null;
  if (routineInfo != null) {
    short sqlAllowed=routineInfo.getSQLAllowed();
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      int sqlOperation;
      if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)       sqlOperation=Authorizer.SQL_SELECT_OP;
 else       if (sqlAllowed == RoutineAliasInfo.MODIFIES_SQL_DATA)       sqlOperation=Authorizer.SQL_WRITE_OP;
 else       sqlOperation=Authorizer.SQL_ARBITARY_OP;
      generateAuthorizeCheck((ActivationClassBuilder)acb,mb,sqlOperation);
    }
    int statmentContextReferences=isSystemCode ? 2 : 1;
    boolean isFunction=routineInfo.getReturnType() != null;
    if (isFunction)     statmentContextReferences++;
    if (statmentContextReferences != 0) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      for (int scc=1; scc < statmentContextReferences; scc++)       mb.dup();
    }
    if (isSystemCode) {
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
    }
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      generateSetupNestedSessionContext((ActivationClassBuilder)acb,mb,routineInfo.hasDefinersRights(),routineDefiner);
    }
    if (isFunction) {
      functionEntrySQLAllowed=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.setField(functionEntrySQLAllowed);
    }
    mb.push(sqlAllowed);
    mb.push(false);
    mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
  }
  if (routineInfo != null && !hasVarargs()) {
    int compiledResultSets=methodParameterTypes.length - methodParms.length;
    if (compiledResultSets != 0) {
      int maxDynamicResults=routineInfo.getMaxDynamicResultSets();
      if (maxDynamicResults > 0) {
        MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
        gdr.push(maxDynamicResults);
        gdr.methodReturn();
        gdr.complete();
      }
      MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
      MethodBuilder cons=acb.getConstructor();
{
        LocalField procedureResultSetsHolder=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
        gdr.getField(procedureResultSetsHolder);
        cons.pushNewArray(""String_Node_Str"",compiledResultSets);
        cons.setField(procedureResultSetsHolder);
        for (int i=0; i < compiledResultSets; i++) {
          mb.pushNewArray(""String_Node_Str"",1);
          mb.dup();
          mb.getField(procedureResultSetsHolder);
          mb.swap();
          mb.setArrayElement(i);
        }
      }
      gdr.methodReturn();
      gdr.complete();
      nargs+=compiledResultSets;
    }
  }
  String javaReturnType=getJavaTypeName();
  MethodBuilder mbnc=null;
  MethodBuilder mbcm=mb;
  if (returnsNullOnNullState != null) {
    mbnc=acb.newGeneratedFun(javaReturnType,Modifier.PRIVATE,methodParameterTypes);
    Class[] throwsSet=((java.lang.reflect.Method)method).getExceptionTypes();
    for (int te=0; te < throwsSet.length; te++) {
      mbnc.addThrownException(throwsSet[te].getName());
    }
    mbnc.getField(returnsNullOnNullState);
    mbnc.conditionalIf();
    mbnc.pushNull(javaReturnType);
    mbnc.startElseCode();
    if (!actualMethodReturnType.equals(javaReturnType))     mbnc.pushNewStart(javaReturnType);
    for (int pa=0; pa < nargs; pa++) {
      mbnc.getParameter(pa);
    }
    mbcm=mbnc;
  }
  mbcm.callMethod(VMOpcode.INVOKESTATIC,method.getDeclaringClass().getName(),methodName,actualMethodReturnType,nargs);
  if (returnsNullOnNullState != null) {
    if (!actualMethodReturnType.equals(javaReturnType)) {
      if (actualMethodReturnType.equals(""String_Node_Str"") && javaReturnType.equals(""String_Node_Str""))       mbnc.upCast(""String_Node_Str"");
      mbnc.pushNewComplete(1);
    }
    mbnc.completeConditional();
    mbnc.methodReturn();
    mbnc.complete();
    mb.callMethod(VMOpcode.INVOKEVIRTUAL,acb.getClassBuilder().getFullName(),mbnc.getName(),javaReturnType,nargs);
    mbnc=null;
  }
  if (routineInfo != null) {
    if (functionEntrySQLAllowed != null) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.getField(functionEntrySQLAllowed);
      mb.push(true);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
    }
    if (outParamArrays != null) {
      MethodBuilder constructor=acb.getConstructor();
      acb.pushThisAsActivation(constructor);
      constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      int[] parameterModes=routineInfo.getParameterModes();
      for (int i=0; i < outParamArrays.length; i++) {
        int parameterMode=parameterModes[i];
        if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
          ValueNode sqlParamNode=((SQLToJavaValueNode)methodParms[i]).getSQLValueNode();
          int applicationParameterNumber=applicationParameterNumbers[i];
          constructor.dup();
          constructor.push(applicationParameterNumber);
          constructor.push(parameterMode);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
          LocalField lf=outParamArrays[i];
          mb.dup();
          mb.push(applicationParameterNumber);
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.DataValueDescriptor,1);
          DataTypeDescriptor paramdtd=sqlParamNode.getTypeServices();
          boolean isNumericType=paramdtd.getTypeId().isNumericTypeId();
          boolean isAnsiUDT=paramdtd.getTypeId().getBaseTypeId().isAnsiUDT();
          boolean isPrimitive=((java.lang.reflect.Method)method).getParameterTypes()[i].getComponentType().isPrimitive();
          if (isNumericType) {
            if (!isPrimitive)             mb.cast(ClassName.NumberDataValue);
          }
 else           if (paramdtd.getTypeId().isBooleanTypeId()) {
            if (!isPrimitive)             mb.cast(ClassName.BooleanDataValue);
          }
          if (paramdtd.getTypeId().variableLength()) {
            mb.dup();
          }
          mb.getField(lf);
          mb.getArrayElement(0);
          if (isNumericType && !isPrimitive) {
            mb.upCast(""String_Node_Str"");
          }
          if (isAnsiUDT) {
            mb.upCast(""String_Node_Str"");
          }
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",1);
          if (paramdtd.getTypeId().variableLength()) {
            mb.push(isNumericType ? paramdtd.getPrecision() : paramdtd.getMaximumWidth());
            mb.push(paramdtd.getScale());
            mb.push(isNumericType);
            mb.callMethod(VMOpcode.INVOKEINTERFACE,ClassName.VariableSizeDataValue,""String_Node_Str"",""String_Node_Str"",3);
          }
        }
      }
      constructor.endStatement();
      mb.endStatement();
    }
  }
}","/** 
 * Do code generation for this method call
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
public void generateExpression(ExpressionClassBuilder acb,MethodBuilder mb) throws StandardException {
  if (routineInfo != null) {
    if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)     returnsNullOnNullState=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
  }
  if (returnsNullOnNullState != null) {
    mb.push(false);
    mb.setField(returnsNullOnNullState);
    mb.pushThis();
  }
  int nargs=generateParameters(acb,mb);
  LocalField functionEntrySQLAllowed=null;
  if (routineInfo != null) {
    short sqlAllowed=routineInfo.getSQLAllowed();
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      int sqlOperation;
      if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)       sqlOperation=Authorizer.SQL_SELECT_OP;
 else       if (sqlAllowed == RoutineAliasInfo.MODIFIES_SQL_DATA)       sqlOperation=Authorizer.SQL_WRITE_OP;
 else       sqlOperation=Authorizer.SQL_ARBITARY_OP;
      generateAuthorizeCheck((ActivationClassBuilder)acb,mb,sqlOperation);
    }
    int statmentContextReferences=isSystemCode ? 2 : 1;
    boolean isFunction=routineInfo.getReturnType() != null;
    if (isFunction)     statmentContextReferences++;
    if (statmentContextReferences != 0) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      for (int scc=1; scc < statmentContextReferences; scc++)       mb.dup();
    }
    if (isSystemCode) {
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
    }
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      generateSetupNestedSessionContext((ActivationClassBuilder)acb,mb,routineInfo.hasDefinersRights(),routineDefiner);
    }
    if (isFunction) {
      functionEntrySQLAllowed=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.setField(functionEntrySQLAllowed);
    }
    mb.push(sqlAllowed);
    mb.push(false);
    mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
  }
  if (routineInfo != null && !hasVarargs()) {
    int compiledResultSets=methodParameterTypes.length - methodParms.length;
    if (compiledResultSets != 0) {
      int maxDynamicResults=routineInfo.getMaxDynamicResultSets();
      if (maxDynamicResults > 0) {
        MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
        gdr.push(maxDynamicResults);
        gdr.methodReturn();
        gdr.complete();
      }
      MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
      MethodBuilder cons=acb.getConstructor();
{
        LocalField procedureResultSetsHolder=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
        gdr.getField(procedureResultSetsHolder);
        cons.pushNewArray(""String_Node_Str"",compiledResultSets);
        cons.setField(procedureResultSetsHolder);
        for (int i=0; i < compiledResultSets; i++) {
          mb.pushNewArray(""String_Node_Str"",1);
          mb.dup();
          mb.getField(procedureResultSetsHolder);
          mb.swap();
          mb.setArrayElement(i);
        }
      }
      gdr.methodReturn();
      gdr.complete();
      nargs+=compiledResultSets;
    }
  }
  String javaReturnType=getJavaTypeName();
  MethodBuilder mbnc=null;
  MethodBuilder mbcm=mb;
  if (returnsNullOnNullState != null) {
    mbnc=acb.newGeneratedFun(javaReturnType,Modifier.PRIVATE,methodParameterTypes);
    Class[] throwsSet=((java.lang.reflect.Method)method).getExceptionTypes();
    for (int te=0; te < throwsSet.length; te++) {
      mbnc.addThrownException(throwsSet[te].getName());
    }
    mbnc.getField(returnsNullOnNullState);
    mbnc.conditionalIf();
    mbnc.pushNull(javaReturnType);
    mbnc.startElseCode();
    if (!actualMethodReturnType.equals(javaReturnType))     mbnc.pushNewStart(javaReturnType);
    for (int pa=0; pa < nargs; pa++) {
      mbnc.getParameter(pa);
    }
    mbcm=mbnc;
  }
  mbcm.callMethod(VMOpcode.INVOKESTATIC,method.getDeclaringClass().getName(),methodName,actualMethodReturnType,nargs);
  if (returnsNullOnNullState != null) {
    if (!actualMethodReturnType.equals(javaReturnType)) {
      if (actualMethodReturnType.equals(""String_Node_Str"") && javaReturnType.equals(""String_Node_Str""))       mbnc.upCast(""String_Node_Str"");
      mbnc.pushNewComplete(1);
    }
    mbnc.completeConditional();
    mbnc.methodReturn();
    mbnc.complete();
    mb.callMethod(VMOpcode.INVOKEVIRTUAL,acb.getClassBuilder().getFullName(),mbnc.getName(),javaReturnType,nargs);
    mbnc=null;
  }
  if (routineInfo != null) {
    if (functionEntrySQLAllowed != null) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.getField(functionEntrySQLAllowed);
      mb.push(true);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
    }
    if (outParamArrays != null) {
      MethodBuilder constructor=acb.getConstructor();
      acb.pushThisAsActivation(constructor);
      constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      int[] parameterModes=routineInfo.getParameterModes();
      for (int i=0; i < outParamArrays.length; i++) {
        int parameterMode=parameterModes[getRoutineArgIdx(i)];
        if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
          ValueNode sqlParamNode=((SQLToJavaValueNode)methodParms[i]).getSQLValueNode();
          int applicationParameterNumber=applicationParameterNumbers[i];
          constructor.dup();
          constructor.push(applicationParameterNumber);
          constructor.push(parameterMode);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
          LocalField lf=outParamArrays[i];
          mb.dup();
          mb.push(applicationParameterNumber);
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.DataValueDescriptor,1);
          DataTypeDescriptor paramdtd=sqlParamNode.getTypeServices();
          boolean isNumericType=paramdtd.getTypeId().isNumericTypeId();
          boolean isAnsiUDT=paramdtd.getTypeId().getBaseTypeId().isAnsiUDT();
          Class cellType=((java.lang.reflect.Method)method).getParameterTypes()[getRoutineArgIdx(i)].getComponentType();
          if (isVararg(i)) {
            cellType=cellType.getComponentType();
          }
          boolean isPrimitive=cellType.isPrimitive();
          if (isNumericType) {
            if (!isPrimitive)             mb.cast(ClassName.NumberDataValue);
          }
 else           if (paramdtd.getTypeId().isBooleanTypeId()) {
            if (!isPrimitive)             mb.cast(ClassName.BooleanDataValue);
          }
          if (paramdtd.getTypeId().variableLength()) {
            mb.dup();
          }
          mb.getField(lf);
          mb.getArrayElement(0);
          if (isNumericType && !isPrimitive) {
            mb.upCast(""String_Node_Str"");
          }
          if (isAnsiUDT) {
            mb.upCast(""String_Node_Str"");
          }
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",1);
          if (paramdtd.getTypeId().variableLength()) {
            mb.push(isNumericType ? paramdtd.getPrecision() : paramdtd.getMaximumWidth());
            mb.push(paramdtd.getScale());
            mb.push(isNumericType);
            mb.callMethod(VMOpcode.INVOKEINTERFACE,ClassName.VariableSizeDataValue,""String_Node_Str"",""String_Node_Str"",3);
          }
        }
      }
      constructor.endStatement();
      mb.endStatement();
    }
  }
}"
80025,"/** 
 * Push extra code to generate the casts within the arrays for the parameters passed as arrays.
 */
public void generateOneParameter(ExpressionClassBuilder acb,MethodBuilder mb,int parameterNumber) throws StandardException {
  int parameterMode;
  SQLToJavaValueNode sql2j=null;
  if (methodParms[parameterNumber] instanceof SQLToJavaValueNode)   sql2j=(SQLToJavaValueNode)methodParms[parameterNumber];
  if (routineInfo != null) {
    parameterMode=routineInfo.getParameterModes()[getRoutineArgIdx(parameterNumber)];
  }
 else {
    parameterMode=JDBC30Translation.PARAMETER_MODE_IN;
    if (sql2j != null) {
      if (sql2j.getSQLValueNode().requiresTypeFromContext()) {
        ParameterNode pn;
        if (sql2j.getSQLValueNode() instanceof UnaryOperatorNode)         pn=((UnaryOperatorNode)sql2j.getSQLValueNode()).getParameterOperand();
 else         pn=(ParameterNode)(sql2j.getSQLValueNode());
        int applicationParameterNumber=pn.getParameterNumber();
        String parameterType=methodParameterTypes[parameterNumber];
        if (parameterType.endsWith(""String_Node_Str"")) {
          MethodBuilder constructor=acb.getConstructor();
          acb.pushThisAsActivation(constructor);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
          constructor.push(applicationParameterNumber);
          constructor.push(JDBC30Translation.PARAMETER_MODE_UNKNOWN);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
          constructor.endStatement();
        }
      }
    }
  }
switch (parameterMode) {
case JDBC30Translation.PARAMETER_MODE_IN:
case JDBC30Translation.PARAMETER_MODE_IN_OUT:
case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
    if (sql2j != null)     sql2j.returnsNullOnNullState=returnsNullOnNullState;
  super.generateOneParameter(acb,mb,parameterNumber);
break;
case JDBC30Translation.PARAMETER_MODE_OUT:
break;
}
switch (parameterMode) {
case JDBC30Translation.PARAMETER_MODE_IN:
case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
break;
case JDBC30Translation.PARAMETER_MODE_IN_OUT:
case JDBC30Translation.PARAMETER_MODE_OUT:
{
String methodParameterType=methodParameterTypes[parameterNumber];
String arrayType=methodParameterType.substring(0,methodParameterType.length() - 2);
LocalField lf=acb.newFieldDeclaration(Modifier.PRIVATE,methodParameterType);
if (outParamArrays == null) outParamArrays=new LocalField[methodParms.length];
outParamArrays[parameterNumber]=lf;
mb.pushNewArray(arrayType,1);
mb.putField(lf);
if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT) {
mb.swap();
mb.setArrayElement(0);
mb.getField(lf);
}
break;
}
}
}","/** 
 * Push extra code to generate the casts within the arrays for the parameters passed as arrays.
 */
public void generateOneParameter(ExpressionClassBuilder acb,MethodBuilder mb,int parameterNumber) throws StandardException {
  int parameterMode;
  SQLToJavaValueNode sql2j=null;
  if (methodParms[parameterNumber] instanceof SQLToJavaValueNode)   sql2j=(SQLToJavaValueNode)methodParms[parameterNumber];
  if (routineInfo != null) {
    parameterMode=routineInfo.getParameterModes()[getRoutineArgIdx(parameterNumber)];
  }
 else {
    parameterMode=JDBC30Translation.PARAMETER_MODE_IN;
    if (sql2j != null) {
      if (sql2j.getSQLValueNode().requiresTypeFromContext()) {
        ParameterNode pn;
        if (sql2j.getSQLValueNode() instanceof UnaryOperatorNode)         pn=((UnaryOperatorNode)sql2j.getSQLValueNode()).getParameterOperand();
 else         pn=(ParameterNode)(sql2j.getSQLValueNode());
        int applicationParameterNumber=pn.getParameterNumber();
        String parameterType=methodParameterTypes[getRoutineArgIdx(parameterNumber)];
        if (parameterType.endsWith(""String_Node_Str"")) {
          MethodBuilder constructor=acb.getConstructor();
          acb.pushThisAsActivation(constructor);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
          constructor.push(applicationParameterNumber);
          constructor.push(JDBC30Translation.PARAMETER_MODE_UNKNOWN);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
          constructor.endStatement();
        }
      }
    }
  }
switch (parameterMode) {
case JDBC30Translation.PARAMETER_MODE_IN:
case JDBC30Translation.PARAMETER_MODE_IN_OUT:
case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
    if (sql2j != null)     sql2j.returnsNullOnNullState=returnsNullOnNullState;
  super.generateOneParameter(acb,mb,parameterNumber);
break;
case JDBC30Translation.PARAMETER_MODE_OUT:
break;
}
switch (parameterMode) {
case JDBC30Translation.PARAMETER_MODE_IN:
case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
break;
case JDBC30Translation.PARAMETER_MODE_IN_OUT:
case JDBC30Translation.PARAMETER_MODE_OUT:
{
String methodParameterType=methodParameterTypes[getRoutineArgIdx(parameterNumber)];
String arrayType=methodParameterType.substring(0,methodParameterType.length() - 2);
if (isVararg(parameterNumber)) {
methodParameterType=stripOneArrayLevel(methodParameterType);
arrayType=stripOneArrayLevel(arrayType);
}
LocalField lf=acb.newFieldDeclaration(Modifier.PRIVATE,methodParameterType);
if (outParamArrays == null) {
outParamArrays=new LocalField[methodParms.length];
}
outParamArrays[parameterNumber]=lf;
mb.pushNewArray(arrayType,1);
mb.putField(lf);
if (parameterMode != JDBC30Translation.PARAMETER_MODE_OUT) {
mb.swap();
mb.setArrayElement(0);
mb.getField(lf);
}
break;
}
}
}"
80026,"/** 
 * Prepare to mark the dependent as invalid (due to at least one of its dependencies being invalid).
 * @param action	The action causing the invalidation
 * @param p		the provider
 * @exception StandardException thrown if unable to make it invalid
 */
public void prepareToInvalidate(Provider p,int action,LanguageConnectionContext lcc) throws StandardException {
  DependencyManager dm=getDataDictionary().getDependencyManager();
switch (action) {
default :
    DataDictionary dd=getDataDictionary();
  ColumnDescriptor cd=dd.getColumnDescriptorByDefaultId(defaultUUID);
TableDescriptor td=dd.getTableDescriptor(cd.getReferencingUUID());
throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT,dm.getActionString(action),p.getObjectName(),MessageService.getTextMessage(SQLState.LANG_COLUMN_DEFAULT),td.getQualifiedName() + ""String_Node_Str"" + cd.getColumnName());
}
}","/** 
 * Prepare to mark the dependent as invalid (due to at least one of its dependencies being invalid).
 * @param action	The action causing the invalidation
 * @param p		the provider
 * @exception StandardException thrown if unable to make it invalid
 */
public void prepareToInvalidate(Provider p,int action,LanguageConnectionContext lcc) throws StandardException {
  DependencyManager dm=getDataDictionary().getDependencyManager();
switch (action) {
default :
    DataDictionary dd=getDataDictionary();
  ColumnDescriptor cd=dd.getColumnDescriptorByDefaultId(defaultUUID);
TableDescriptor td=dd.getTableDescriptor(cd.getReferencingUUID());
throw StandardException.newException(SQLState.LANG_PROVIDER_HAS_DEPENDENT_OBJECT,dm.getActionString(action),p.getObjectName(),""String_Node_Str"",td.getQualifiedName() + ""String_Node_Str"" + cd.getColumnName());
}
}"
80027,"/** 
 * processCommands reads and processes NetworkServerControlImpl commands sent to the network server over the socket.  The protocol used is 4 bytes 	- String CMD: 2 bytes		- Protocol version 1 byte		- length of locale (0 for default) n bytes - locale 1 byte		- length of codeset (0 for default) n bytes - codeset 1 byte		- command n bytes		- parameters for the command The server returns 4 bytes		- String RPY: for most commands 1 byte		- command result, 0 - OK, 1 - warning, 2 - error if warning or error 1 bytes		- length of message key n bytes		- message key 1 byte		- number of parameters to message {2 bytes		- length of parameter n bytes		- parameter} for each parameter for sysinfo 1 byte		- command result, 0 - OK, 1 - warning, 2 - error if OK  2 bytes		- length of sysinfo n bytes		- sysinfo Note, the 3rd byte of the command must not be 'D0' to distinquish it  from DSS structures. The protocol for the parameters for each command follows: Command: trace <connection id> {on | off} Protocol: 4 bytes		- connection id - connection id of 0 means all sessions 1 byte		- 0 off, 1 on Command: logConnections {on | off} Protocol: 1 byte		- 0 off, 1 on Command: shutdown // DERBY-2109: transmit user credentials for System Privileges check 2 bytes		- length of user name n bytes		- user name 2 bytes		- length of password n bytes		- password Command: sysinfo No parameters Command: dbstart Protocol: 2 bytes		- length of database name n bytes		- database name 2 bytes		- length of boot password n bytes		- boot password  2 bytes		- length of encryption algorithm n bytes		- encryption algorithm 2 bytes		- length of encryption provider n bytes		- encryption provider 2 bytes		- length of user name n bytes		- user name 2 bytes		- length of password n bytes		- password Command: dbshutdown Protocol: 2 bytes		- length of database name n bytes		- database name 2 bytes		- length of user name n bytes		- user name 2 bytes		- length of password n bytes		- password Command: connpool Protocol: 2 bytes		- length of database name, if 0, default for all databases is set n bytes		- database name 2 bytes		- minimum number of connections, if 0, connection pool not used if value is -1 use default 2 bytes		- maximum number of connections, if 0, connections are created as needed, if value is -1 use default Command: maxthreads Protocol: 2 bytes		- maximum number of threads Command: timeslice  Protocol: 4 bytes		- timeslice value Command: tracedirectory Protocol: 2 bytes		- length of directory name n bytes		- directory name Command: test connection Protocol: 2 bytes		- length of database name if 0, just the connection to the network server is tested and user name and  password aren't sent n bytes		- database name 2 bytes		- length of user name (optional) n bytes		- user name 2 bytes		- length of password  (optional) n bytes		- password The calling routine is synchronized so that multiple threads don't clobber each other. This means that configuration commands will be serialized. This shouldn't be a problem since they should be fairly rare.
 * @param reader	input reader for command
 * @param writer output writer for command
 * @param session	session information
 * @exception Throwable	throws an exception if an error occurs
 */
protected synchronized void processCommands(DDMReader reader,DDMWriter writer,Session session) throws Throwable {
  try {
    String protocolStr=reader.readCmdString(4);
    String locale=DEFAULT_LOCALE;
    String codeset=null;
    int version=reader.readNetworkShort();
    if (version <= 0 || version > MAX_ALLOWED_PROTOCOL_VERSION) {
      throw new Throwable(langUtil.getTextMessage(""String_Node_Str"",version));
    }
    int localeLen=reader.readByte();
    if (localeLen > 0) {
      currentSession=session;
      locale=reader.readCmdString(localeLen);
      session.langUtil=new LocalizedResource(codeset,locale,DRDA_PROP_MESSAGES);
    }
    String notLocalMessage=null;
    int codesetLen=reader.readByte();
    int command=reader.readByte();
    if (command != COMMAND_TESTCONNECTION) {
      try {
        checkAddressIsLocal(session.clientSocket.getInetAddress());
      }
 catch (      Exception e) {
        notLocalMessage=e.getMessage();
      }
    }
    if (notLocalMessage != null) {
      sendMessage(writer,ERROR,notLocalMessage);
      session.langUtil=null;
      currentSession=null;
      return;
    }
switch (command) {
case COMMAND_SHUTDOWN:
      if (version == SHUTDOWN_WITH_CREDENTIAL_PROTOCOL_VERSION) {
        userArg=reader.readCmdString();
        passwordArg=reader.readCmdString();
      }
    try {
      checkShutdownPrivileges();
      sendOK(writer);
      directShutdownInternal();
    }
 catch (    SQLException sqle) {
      sendSQLMessage(writer,sqle,SQLERROR);
      consolePropertyMessage(""String_Node_Str"",sqle.getMessage());
    }
  break;
case COMMAND_TRACE:
sessionArg=reader.readNetworkInt();
boolean on=(reader.readByte() == 1);
if (setTrace(on)) {
sendOK(writer);
}
 else {
if (sessionArg != 0) sendMessage(writer,ERROR,localizeMessage(""String_Node_Str"",(session.langUtil == null) ? langUtil : session.langUtil,new String[]{Integer.toString(sessionArg)}));
 else sendMessage(writer,ERROR,localizeMessage(""String_Node_Str"",null));
}
break;
case COMMAND_TRACEDIRECTORY:
setTraceDirectory(reader.readCmdString());
sendOK(writer);
consolePropertyMessage(""String_Node_Str"",traceDirectory);
break;
case COMMAND_TESTCONNECTION:
databaseArg=reader.readCmdString();
userArg=reader.readCmdString();
passwordArg=reader.readCmdString();
if (databaseArg != null) connectToDatabase(writer,databaseArg,userArg,passwordArg);
 else sendOK(writer);
break;
case COMMAND_LOGCONNECTIONS:
boolean log=(reader.readByte() == 1);
setLogConnections(log);
sendOK(writer);
consolePropertyMessage(""String_Node_Str"",(log ? ""String_Node_Str"" : ""String_Node_Str""));
break;
case COMMAND_SYSINFO:
sendSysInfo(writer);
break;
case COMMAND_PROPERTIES:
sendPropInfo(writer);
break;
case COMMAND_RUNTIME_INFO:
sendRuntimeInfo(writer);
break;
case COMMAND_MAXTHREADS:
int max=reader.readNetworkInt();
try {
setMaxThreads(max);
}
 catch (Exception e) {
sendMessage(writer,ERROR,e.getMessage());
return;
}
int newval=getMaxThreads();
sendOKInt(writer,newval);
consolePropertyMessage(""String_Node_Str"",String.valueOf(newval));
break;
case COMMAND_TIMESLICE:
int timeslice=reader.readNetworkInt();
try {
setTimeSlice(timeslice);
}
 catch (Exception e) {
sendMessage(writer,ERROR,e.getMessage());
return;
}
newval=getTimeSlice();
sendOKInt(writer,newval);
consolePropertyMessage(""String_Node_Str"",String.valueOf(newval));
break;
}
}
 catch (DRDAProtocolException e) {
consoleExceptionPrintTrace(e);
}
catch (Exception e) {
consoleExceptionPrintTrace(e);
}
 finally {
session.langUtil=null;
currentSession=null;
}
}","/** 
 * processCommands reads and processes NetworkServerControlImpl commands sent to the network server over the socket.  The protocol used is 4 bytes 	- String CMD: 2 bytes		- Protocol version 1 byte		- length of locale (0 for default) n bytes - locale 1 byte		- length of codeset (0 for default) n bytes - codeset 1 byte		- command n bytes		- parameters for the command The server returns 4 bytes		- String RPY: for most commands 1 byte		- command result, 0 - OK, 1 - warning, 2 - error if warning or error 1 bytes		- length of message key n bytes		- message key 1 byte		- number of parameters to message {2 bytes		- length of parameter n bytes		- parameter} for each parameter for sysinfo 1 byte		- command result, 0 - OK, 1 - warning, 2 - error if OK  2 bytes		- length of sysinfo n bytes		- sysinfo Note, the 3rd byte of the command must not be 'D0' to distinquish it  from DSS structures. The protocol for the parameters for each command follows: Command: trace <connection id> {on | off} Protocol: 4 bytes		- connection id - connection id of 0 means all sessions 1 byte		- 0 off, 1 on Command: logConnections {on | off} Protocol: 1 byte		- 0 off, 1 on Command: shutdown // DERBY-2109: transmit user credentials for System Privileges check 2 bytes		- length of user name n bytes		- user name 2 bytes		- length of password n bytes		- password Command: sysinfo No parameters Command: dbstart Protocol: 2 bytes		- length of database name n bytes		- database name 2 bytes		- length of boot password n bytes		- boot password  2 bytes		- length of encryption algorithm n bytes		- encryption algorithm 2 bytes		- length of encryption provider n bytes		- encryption provider 2 bytes		- length of user name n bytes		- user name 2 bytes		- length of password n bytes		- password Command: dbshutdown Protocol: 2 bytes		- length of database name n bytes		- database name 2 bytes		- length of user name n bytes		- user name 2 bytes		- length of password n bytes		- password Command: connpool Protocol: 2 bytes		- length of database name, if 0, default for all databases is set n bytes		- database name 2 bytes		- minimum number of connections, if 0, connection pool not used if value is -1 use default 2 bytes		- maximum number of connections, if 0, connections are created as needed, if value is -1 use default Command: maxthreads Protocol: 2 bytes		- maximum number of threads Command: timeslice  Protocol: 4 bytes		- timeslice value Command: tracedirectory Protocol: 2 bytes		- length of directory name n bytes		- directory name Command: test connection Protocol: 2 bytes		- length of database name if 0, just the connection to the network server is tested and user name and  password aren't sent n bytes		- database name 2 bytes		- length of user name (optional) n bytes		- user name 2 bytes		- length of password  (optional) n bytes		- password The calling routine is synchronized so that multiple threads don't clobber each other. This means that configuration commands will be serialized. This shouldn't be a problem since they should be fairly rare.
 * @param reader	input reader for command
 * @param writer output writer for command
 * @param session	session information
 * @exception Throwable	throws an exception if an error occurs
 */
protected synchronized void processCommands(DDMReader reader,DDMWriter writer,Session session) throws Throwable {
  try {
    String protocolStr=reader.readCmdString(4);
    String locale=DEFAULT_LOCALE;
    String codeset=null;
    int version=reader.readNetworkShort();
    if (version <= 0 || version > MAX_ALLOWED_PROTOCOL_VERSION) {
      throw new Throwable(langUtil.getTextMessage(""String_Node_Str"",version));
    }
    int localeLen=reader.readByte();
    if (localeLen > 0) {
      currentSession=session;
      locale=reader.readCmdString(localeLen);
      session.langUtil=new LocalizedResource(codeset,locale,DRDA_PROP_MESSAGES);
    }
    String notLocalMessage=null;
    int codesetLen=reader.readByte();
    int command=reader.readByte();
    if (command != COMMAND_TESTCONNECTION) {
      try {
        checkAddressIsLocal(session.clientSocket.getInetAddress());
      }
 catch (      Exception e) {
        notLocalMessage=e.getMessage();
      }
    }
    if (notLocalMessage != null) {
      sendMessage(writer,ERROR,notLocalMessage);
      session.langUtil=null;
      currentSession=null;
      return;
    }
switch (command) {
case COMMAND_SHUTDOWN:
      if (version == SHUTDOWN_WITH_CREDENTIAL_PROTOCOL_VERSION) {
        userArg=reader.readCmdString();
        passwordArg=reader.readCmdString();
      }
    try {
      checkShutdownPrivileges();
      sendOK(writer);
      directShutdownInternal();
    }
 catch (    SQLException sqle) {
      sendSQLMessage(writer,sqle,SQLERROR);
      consolePropertyMessage(""String_Node_Str"",sqle.getMessage());
    }
  break;
case COMMAND_TRACE:
sessionArg=reader.readNetworkInt();
boolean on=(reader.readByte() == 1);
if (setTrace(on)) {
sendOK(writer);
}
 else {
if (sessionArg != 0) sendMessage(writer,ERROR,localizeMessage(""String_Node_Str"",(session.langUtil == null) ? langUtil : session.langUtil,new String[]{Integer.toString(sessionArg)}));
 else sendMessage(writer,ERROR,localizeMessage(""String_Node_Str"",null));
}
break;
case COMMAND_TRACEDIRECTORY:
setTraceDirectory(reader.readCmdString());
sendOK(writer);
consolePropertyMessage(""String_Node_Str"",traceDirectory);
break;
case COMMAND_TESTCONNECTION:
databaseArg=reader.readCmdString();
userArg=reader.readCmdString();
passwordArg=reader.readCmdString();
if (databaseArg != null) connectToDatabase(writer,databaseArg,userArg,passwordArg);
 else sendOK(writer);
break;
case COMMAND_LOGCONNECTIONS:
boolean log=(reader.readByte() == 1);
setLogConnections(log);
sendOK(writer);
logConnectionsChange(log);
break;
case COMMAND_SYSINFO:
sendSysInfo(writer);
break;
case COMMAND_PROPERTIES:
sendPropInfo(writer);
break;
case COMMAND_RUNTIME_INFO:
sendRuntimeInfo(writer);
break;
case COMMAND_MAXTHREADS:
int max=reader.readNetworkInt();
try {
setMaxThreads(max);
}
 catch (Exception e) {
sendMessage(writer,ERROR,e.getMessage());
return;
}
int newval=getMaxThreads();
sendOKInt(writer,newval);
consolePropertyMessage(""String_Node_Str"",String.valueOf(newval));
break;
case COMMAND_TIMESLICE:
int timeslice=reader.readNetworkInt();
try {
setTimeSlice(timeslice);
}
 catch (Exception e) {
sendMessage(writer,ERROR,e.getMessage());
return;
}
newval=getTimeSlice();
sendOKInt(writer,newval);
consolePropertyMessage(""String_Node_Str"",String.valueOf(newval));
break;
}
}
 catch (DRDAProtocolException e) {
consoleExceptionPrintTrace(e);
}
catch (Exception e) {
consoleExceptionPrintTrace(e);
}
 finally {
session.langUtil=null;
currentSession=null;
}
}"
80028,"/** 
 * Print trace change message to console
 * @param on			true to print tracing on, false to print tracing off
 * @exception Exception	throws an exception if an error occurs
 */
private void consoleTraceMessage(int connNum,boolean on) throws Exception {
  if (connNum == 0)   consolePropertyMessage(""String_Node_Str"",on ? ""String_Node_Str"" : ""String_Node_Str"");
 else {
    String[] args={on ? ""String_Node_Str"" : ""String_Node_Str"",Integer.toString(connNum)};
    consolePropertyMessage(""String_Node_Str"",args);
  }
}","/** 
 * Print trace change message to console
 * @param on			true to print tracing on, false to print tracing off
 * @exception Exception	throws an exception if an error occurs
 */
private void consoleTraceMessage(int connNum,boolean on) throws Exception {
  String messageID;
  String[] args=null;
  if (connNum == 0) {
    if (on) {
      messageID=""String_Node_Str"";
    }
 else {
      messageID=""String_Node_Str"";
    }
  }
 else {
    if (on) {
      messageID=""String_Node_Str"";
    }
 else {
      messageID=""String_Node_Str"";
    }
    args=new String[]{Integer.toString(connNum)};
  }
  consolePropertyMessage(messageID,args);
}"
80029,"/** 
 * Execute the command given on the command line
 * @param command   The command to execute. The command itself was determined by an earlier call to parseArgs().
 * @exception Exception	throws an exception if an error occurssee class comments for more information
 */
public void executeWork(int command) throws Exception {
  if (command == COMMAND_UNKNOWN)   return;
  if (commandArgs.size() != COMMAND_ARGS[command])   consolePropertyMessage(""String_Node_Str"",COMMANDS[command]);
  int min;
  int max;
switch (command) {
case COMMAND_START:
    shutdownDatabasesOnShutdown=true;
  blockingStart(makePrintWriter(System.out));
break;
case COMMAND_SHUTDOWN:
shutdown();
consolePropertyMessage(""String_Node_Str"",new String[]{att_srvclsnm,versionString});
break;
case COMMAND_TRACE:
{
boolean on=isOn((String)commandArgs.get(0));
trace(sessionArg,on);
consoleTraceMessage(sessionArg,on);
break;
}
case COMMAND_TRACEDIRECTORY:
String directory=(String)commandArgs.get(0);
sendSetTraceDirectory(directory);
consolePropertyMessage(""String_Node_Str"",directory);
break;
case COMMAND_TESTCONNECTION:
ping();
consolePropertyMessage(""String_Node_Str"",new String[]{hostArg,Integer.toString(portNumber)});
break;
case COMMAND_LOGCONNECTIONS:
{
boolean on=isOn((String)commandArgs.get(0));
logConnections(on);
consolePropertyMessage(""String_Node_Str"",on ? ""String_Node_Str"" : ""String_Node_Str"");
break;
}
case COMMAND_SYSINFO:
{
String info=sysinfo();
consoleMessage(info,false);
break;
}
case COMMAND_MAXTHREADS:
max=0;
try {
max=Integer.parseInt((String)commandArgs.get(0));
}
 catch (NumberFormatException e) {
consolePropertyMessage(""String_Node_Str"",new String[]{(String)commandArgs.get(0),""String_Node_Str""});
}
if (max < MIN_MAXTHREADS) consolePropertyMessage(""String_Node_Str"",new String[]{Integer.toString(max),""String_Node_Str""});
netSetMaxThreads(max);
break;
case COMMAND_RUNTIME_INFO:
String reply=runtimeInfo();
consoleMessage(reply,false);
break;
case COMMAND_TIMESLICE:
int timeslice=0;
String timeSliceArg=(String)commandArgs.get(0);
try {
timeslice=Integer.parseInt(timeSliceArg);
}
 catch (NumberFormatException e) {
consolePropertyMessage(""String_Node_Str"",new String[]{(String)commandArgs.get(0),""String_Node_Str""});
}
if (timeslice < MIN_TIMESLICE) consolePropertyMessage(""String_Node_Str"",new String[]{Integer.toString(timeslice),""String_Node_Str""});
netSetTimeSlice(timeslice);
break;
default :
if (SanityManager.DEBUG) SanityManager.THROWASSERT(""String_Node_Str"" + command);
}
}","/** 
 * Execute the command given on the command line
 * @param command   The command to execute. The command itself was determined by an earlier call to parseArgs().
 * @exception Exception	throws an exception if an error occurssee class comments for more information
 */
public void executeWork(int command) throws Exception {
  if (command == COMMAND_UNKNOWN)   return;
  if (commandArgs.size() != COMMAND_ARGS[command])   consolePropertyMessage(""String_Node_Str"",COMMANDS[command]);
  int min;
  int max;
switch (command) {
case COMMAND_START:
    shutdownDatabasesOnShutdown=true;
  blockingStart(makePrintWriter(System.out));
break;
case COMMAND_SHUTDOWN:
shutdown();
consolePropertyMessage(""String_Node_Str"",new String[]{att_srvclsnm,versionString});
break;
case COMMAND_TRACE:
{
boolean on=isOn((String)commandArgs.get(0));
trace(sessionArg,on);
consoleTraceMessage(sessionArg,on);
break;
}
case COMMAND_TRACEDIRECTORY:
String directory=(String)commandArgs.get(0);
sendSetTraceDirectory(directory);
consolePropertyMessage(""String_Node_Str"",directory);
break;
case COMMAND_TESTCONNECTION:
ping();
consolePropertyMessage(""String_Node_Str"",new String[]{hostArg,Integer.toString(portNumber)});
break;
case COMMAND_LOGCONNECTIONS:
{
boolean on=isOn((String)commandArgs.get(0));
logConnections(on);
logConnectionsChange(on);
break;
}
case COMMAND_SYSINFO:
{
String info=sysinfo();
consoleMessage(info,false);
break;
}
case COMMAND_MAXTHREADS:
max=0;
try {
max=Integer.parseInt((String)commandArgs.get(0));
}
 catch (NumberFormatException e) {
consolePropertyMessage(""String_Node_Str"",new String[]{(String)commandArgs.get(0),""String_Node_Str""});
}
if (max < MIN_MAXTHREADS) consolePropertyMessage(""String_Node_Str"",new String[]{Integer.toString(max),""String_Node_Str""});
netSetMaxThreads(max);
break;
case COMMAND_RUNTIME_INFO:
String reply=runtimeInfo();
consoleMessage(reply,false);
break;
case COMMAND_TIMESLICE:
int timeslice=0;
String timeSliceArg=(String)commandArgs.get(0);
try {
timeslice=Integer.parseInt(timeSliceArg);
}
 catch (NumberFormatException e) {
consolePropertyMessage(""String_Node_Str"",new String[]{(String)commandArgs.get(0),""String_Node_Str""});
}
if (timeslice < MIN_TIMESLICE) consolePropertyMessage(""String_Node_Str"",new String[]{Integer.toString(timeslice),""String_Node_Str""});
netSetTimeSlice(timeslice);
break;
default :
if (SanityManager.DEBUG) SanityManager.THROWASSERT(""String_Node_Str"" + command);
}
}"
80030,"public void boot(boolean create,Properties startParams) throws StandardException {
  jbmsVersion=Monitor.getMonitor().getEngineVersion();
  jvmVersion=buildJvmVersion();
  jarCPath=jarClassPath(getClass());
  dataDirectory=startParams.getProperty(PersistentService.ROOT);
  UUIDFactory uf=Monitor.getMonitor().getUUIDFactory();
  identifier=uf.createUUID();
  PersistentService ps=Monitor.getMonitor().getServiceType(this);
  try {
    storageFactory=ps.getStorageFactoryInstance(true,dataDirectory,startParams.getProperty(Property.STORAGE_TEMP_DIRECTORY,PropertyUtil.getSystemProperty(Property.STORAGE_TEMP_DIRECTORY)),identifier.toANSIidentifier());
  }
 catch (  IOException ioe) {
    if (create) {
      throw StandardException.newException(SQLState.SERVICE_DIRECTORY_CREATE_ERROR,ioe,dataDirectory);
    }
 else {
      throw StandardException.newException(SQLState.DATABASE_NOT_FOUND,ioe,dataDirectory);
    }
  }
  if (storageFactory instanceof WritableStorageFactory)   writableStorageFactory=(WritableStorageFactory)storageFactory;
  actionCode=BOOT_ACTION;
  try {
    AccessController.doPrivileged(this);
  }
 catch (  PrivilegedActionException pae) {
  }
  String value=startParams.getProperty(Property.FORCE_DATABASE_LOCK,PropertyUtil.getSystemProperty(Property.FORCE_DATABASE_LOCK));
  throwDBlckException=Boolean.valueOf((value != null ? value.trim() : value)).booleanValue();
  if (!isReadOnly())   getJBMSLockOnDB(identifier,uf,dataDirectory);
  String restoreFrom=null;
  restoreFrom=startParams.getProperty(Attribute.CREATE_FROM);
  if (restoreFrom == null)   restoreFrom=startParams.getProperty(Attribute.RESTORE_FROM);
  if (restoreFrom == null)   restoreFrom=startParams.getProperty(Attribute.ROLL_FORWARD_RECOVERY_FROM);
  if (restoreFrom != null) {
    try {
      String dataEncryption=startParams.getProperty(Attribute.DATA_ENCRYPTION);
      databaseEncrypted=Boolean.valueOf(dataEncryption).booleanValue();
      restoreDataDirectory(restoreFrom);
    }
 catch (    StandardException se) {
      releaseJBMSLockOnDB();
      throw se;
    }
  }
  logMsg(LINE);
  String readOnlyMsg=(isReadOnly()) ? MessageService.getTextMessage(MessageId.STORE_BOOT_READONLY_MSG) : ""String_Node_Str"";
  boolean logBootTrace=Boolean.valueOf(startParams.getProperty(Property.LOG_BOOT_TRACE,PropertyUtil.getSystemProperty(Property.LOG_BOOT_TRACE))).booleanValue();
  logMsg(new Date() + MessageService.getTextMessage(MessageId.STORE_BOOT_MSG,jbmsVersion,identifier,dataDirectory + ""String_Node_Str"" + readOnlyMsg,(Object)this.getClass().getClassLoader(),jarCPath));
  logMsg(jvmVersion);
  logMsg(Property.SYSTEM_HOME_PROPERTY + ""String_Node_Str"" + PropertyUtil.getSystemProperty(Property.SYSTEM_HOME_PROPERTY));
  String target=PropertyUtil.getSystemProperty(Property.ERRORLOG_FILE_PROPERTY);
  if (target != null)   logMsg(Property.ERRORLOG_FILE_PROPERTY + ""String_Node_Str"" + target);
  target=PropertyUtil.getSystemProperty(Property.ERRORLOG_METHOD_PROPERTY);
  if (target != null)   logMsg(Property.ERRORLOG_METHOD_PROPERTY + ""String_Node_Str"" + target);
  target=PropertyUtil.getSystemProperty(Property.ERRORLOG_FIELD_PROPERTY);
  if (target != null)   logMsg(Property.ERRORLOG_FIELD_PROPERTY + ""String_Node_Str"" + target);
  if (logBootTrace)   Monitor.logThrowable(new Throwable(""String_Node_Str""));
  uf=null;
  CacheFactory cf=(CacheFactory)Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
  int pageCacheSize=getIntParameter(RawStoreFactory.PAGE_CACHE_SIZE_PARAMETER,null,RawStoreFactory.PAGE_CACHE_SIZE_DEFAULT,RawStoreFactory.PAGE_CACHE_SIZE_MINIMUM,RawStoreFactory.PAGE_CACHE_SIZE_MAXIMUM);
  pageCache=cf.newCacheManager(this,""String_Node_Str"",pageCacheSize / 2,pageCacheSize);
  int fileCacheSize=getIntParameter(RawStoreFactory.CONTAINER_CACHE_SIZE_PARAMETER,null,RawStoreFactory.CONTAINER_CACHE_SIZE_DEFAULT,RawStoreFactory.CONTAINER_CACHE_SIZE_MINIMUM,RawStoreFactory.CONTAINER_CACHE_SIZE_MAXIMUM);
  containerCache=cf.newCacheManager(this,""String_Node_Str"",fileCacheSize / 2,fileCacheSize);
  if (create) {
    String noLog=startParams.getProperty(Property.CREATE_WITH_NO_LOG);
    inCreateNoLog=(noLog != null && Boolean.valueOf(noLog).booleanValue());
  }
  droppedTableStubInfo=new Hashtable();
  if (Property.DURABILITY_TESTMODE_NO_SYNC.equalsIgnoreCase(PropertyUtil.getSystemProperty(Property.DURABILITY_PROPERTY))) {
    dataNotSyncedAtCheckpoint=true;
    Monitor.logMessage(MessageService.getTextMessage(MessageId.STORE_DURABILITY_TESTMODE_NO_SYNC,Property.DURABILITY_PROPERTY,Property.DURABILITY_TESTMODE_NO_SYNC));
  }
 else   if (Performance.MEASURE) {
    dataNotSyncedAtCheckpoint=PropertyUtil.getSystemBoolean(Property.STORAGE_DATA_NOT_SYNCED_AT_CHECKPOINT);
    if (dataNotSyncedAtCheckpoint)     Monitor.logMessage(""String_Node_Str"" + Property.STORAGE_DATA_NOT_SYNCED_AT_CHECKPOINT + ""String_Node_Str"");
  }
  fileHandler=new RFResource(this);
}","public void boot(boolean create,Properties startParams) throws StandardException {
  jbmsVersion=Monitor.getMonitor().getEngineVersion();
  jvmVersion=buildJvmVersion();
  jarCPath=jarClassPath(getClass());
  dataDirectory=startParams.getProperty(PersistentService.ROOT);
  UUIDFactory uf=Monitor.getMonitor().getUUIDFactory();
  identifier=uf.createUUID();
  PersistentService ps=Monitor.getMonitor().getServiceType(this);
  try {
    storageFactory=ps.getStorageFactoryInstance(true,dataDirectory,startParams.getProperty(Property.STORAGE_TEMP_DIRECTORY,PropertyUtil.getSystemProperty(Property.STORAGE_TEMP_DIRECTORY)),identifier.toANSIidentifier());
  }
 catch (  IOException ioe) {
    if (create) {
      throw StandardException.newException(SQLState.SERVICE_DIRECTORY_CREATE_ERROR,ioe,dataDirectory);
    }
 else {
      throw StandardException.newException(SQLState.DATABASE_NOT_FOUND,ioe,dataDirectory);
    }
  }
  if (storageFactory instanceof WritableStorageFactory)   writableStorageFactory=(WritableStorageFactory)storageFactory;
  actionCode=BOOT_ACTION;
  try {
    AccessController.doPrivileged(this);
  }
 catch (  PrivilegedActionException pae) {
  }
  String value=startParams.getProperty(Property.FORCE_DATABASE_LOCK,PropertyUtil.getSystemProperty(Property.FORCE_DATABASE_LOCK));
  throwDBlckException=Boolean.valueOf((value != null ? value.trim() : value)).booleanValue();
  if (!isReadOnly())   getJBMSLockOnDB(identifier,uf,dataDirectory);
  String restoreFrom=null;
  restoreFrom=startParams.getProperty(Attribute.CREATE_FROM);
  if (restoreFrom == null)   restoreFrom=startParams.getProperty(Attribute.RESTORE_FROM);
  if (restoreFrom == null)   restoreFrom=startParams.getProperty(Attribute.ROLL_FORWARD_RECOVERY_FROM);
  if (restoreFrom != null) {
    try {
      String dataEncryption=startParams.getProperty(Attribute.DATA_ENCRYPTION);
      databaseEncrypted=Boolean.valueOf(dataEncryption).booleanValue();
      restoreDataDirectory(restoreFrom);
    }
 catch (    StandardException se) {
      releaseJBMSLockOnDB();
      throw se;
    }
  }
  logMsg(LINE);
  String messageID=(isReadOnly()) ? MessageId.STORE_BOOT_MSG_READ_ONLY : MessageId.STORE_BOOT_MSG;
  boolean logBootTrace=Boolean.valueOf(startParams.getProperty(Property.LOG_BOOT_TRACE,PropertyUtil.getSystemProperty(Property.LOG_BOOT_TRACE))).booleanValue();
  logMsg(new Date() + MessageService.getTextMessage(messageID,jbmsVersion,identifier,dataDirectory,(Object)this.getClass().getClassLoader(),jarCPath));
  logMsg(jvmVersion);
  logMsg(Property.SYSTEM_HOME_PROPERTY + ""String_Node_Str"" + PropertyUtil.getSystemProperty(Property.SYSTEM_HOME_PROPERTY));
  String target=PropertyUtil.getSystemProperty(Property.ERRORLOG_FILE_PROPERTY);
  if (target != null)   logMsg(Property.ERRORLOG_FILE_PROPERTY + ""String_Node_Str"" + target);
  target=PropertyUtil.getSystemProperty(Property.ERRORLOG_METHOD_PROPERTY);
  if (target != null)   logMsg(Property.ERRORLOG_METHOD_PROPERTY + ""String_Node_Str"" + target);
  target=PropertyUtil.getSystemProperty(Property.ERRORLOG_FIELD_PROPERTY);
  if (target != null)   logMsg(Property.ERRORLOG_FIELD_PROPERTY + ""String_Node_Str"" + target);
  if (logBootTrace)   Monitor.logThrowable(new Throwable(""String_Node_Str""));
  uf=null;
  CacheFactory cf=(CacheFactory)Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
  int pageCacheSize=getIntParameter(RawStoreFactory.PAGE_CACHE_SIZE_PARAMETER,null,RawStoreFactory.PAGE_CACHE_SIZE_DEFAULT,RawStoreFactory.PAGE_CACHE_SIZE_MINIMUM,RawStoreFactory.PAGE_CACHE_SIZE_MAXIMUM);
  pageCache=cf.newCacheManager(this,""String_Node_Str"",pageCacheSize / 2,pageCacheSize);
  int fileCacheSize=getIntParameter(RawStoreFactory.CONTAINER_CACHE_SIZE_PARAMETER,null,RawStoreFactory.CONTAINER_CACHE_SIZE_DEFAULT,RawStoreFactory.CONTAINER_CACHE_SIZE_MINIMUM,RawStoreFactory.CONTAINER_CACHE_SIZE_MAXIMUM);
  containerCache=cf.newCacheManager(this,""String_Node_Str"",fileCacheSize / 2,fileCacheSize);
  if (create) {
    String noLog=startParams.getProperty(Property.CREATE_WITH_NO_LOG);
    inCreateNoLog=(noLog != null && Boolean.valueOf(noLog).booleanValue());
  }
  droppedTableStubInfo=new Hashtable();
  if (Property.DURABILITY_TESTMODE_NO_SYNC.equalsIgnoreCase(PropertyUtil.getSystemProperty(Property.DURABILITY_PROPERTY))) {
    dataNotSyncedAtCheckpoint=true;
    Monitor.logMessage(MessageService.getTextMessage(MessageId.STORE_DURABILITY_TESTMODE_NO_SYNC,Property.DURABILITY_PROPERTY,Property.DURABILITY_TESTMODE_NO_SYNC));
  }
 else   if (Performance.MEASURE) {
    dataNotSyncedAtCheckpoint=PropertyUtil.getSystemBoolean(Property.STORAGE_DATA_NOT_SYNCED_AT_CHECKPOINT);
    if (dataNotSyncedAtCheckpoint)     Monitor.logMessage(""String_Node_Str"" + Property.STORAGE_DATA_NOT_SYNCED_AT_CHECKPOINT + ""String_Node_Str"");
  }
  fileHandler=new RFResource(this);
}"
80031,"/** 
 * <p> Create system procedures that are part of the SYSCS_UTIL schema added in version 10.9. These include the procedures for managing NATIVE credentials. See DERBY-866. </p>
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 */
void create_10_9_system_procedures(TransactionController tc,HashSet newlyCreatedRoutines) throws StandardException {
  UUID sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID();
{
    String[] arg_names={""String_Node_Str"",""String_Node_Str""};
    TypeDescriptor[] arg_types={CATALOG_TYPE_SYSTEM_IDENTIFIER,DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
{
    String[] arg_names={""String_Node_Str"",""String_Node_Str""};
    TypeDescriptor[] arg_types={CATALOG_TYPE_SYSTEM_IDENTIFIER,DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
{
    String[] arg_names={""String_Node_Str""};
    TypeDescriptor[] arg_types={DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
{
    String[] arg_names={""String_Node_Str""};
    TypeDescriptor[] arg_types={CATALOG_TYPE_SYSTEM_IDENTIFIER};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
}","/** 
 * <p> Create system procedures that are part of the SYSCS_UTIL schema added in version 10.9. These include the procedures for managing NATIVE credentials. See DERBY-866. </p>
 * @param tc an instance of the Transaction Controller.
 * @param newlyCreatedRoutines set of routines we are creating (used to add permissions later on)
 */
void create_10_9_system_procedures(TransactionController tc,HashSet newlyCreatedRoutines) throws StandardException {
  UUID sysUtilUUID=getSystemUtilSchemaDescriptor().getUUID();
{
    String[] arg_names={""String_Node_Str"",""String_Node_Str""};
    TypeDescriptor[] arg_types={CATALOG_TYPE_SYSTEM_IDENTIFIER,DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
{
    String[] arg_names={""String_Node_Str"",""String_Node_Str""};
    TypeDescriptor[] arg_types={CATALOG_TYPE_SYSTEM_IDENTIFIER,DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
{
    String[] arg_names={""String_Node_Str""};
    TypeDescriptor[] arg_types={DataTypeDescriptor.getCatalogType(Types.VARCHAR,32672)};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
{
    String[] arg_names={""String_Node_Str""};
    TypeDescriptor[] arg_types={CATALOG_TYPE_SYSTEM_IDENTIFIER};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.MODIFIES_SQL_DATA,false,(TypeDescriptor)null,newlyCreatedRoutines,tc);
  }
{
    String[] arg_names={""String_Node_Str"",""String_Node_Str""};
    TypeDescriptor[] arg_types={CATALOG_TYPE_SYSTEM_IDENTIFIER,CATALOG_TYPE_SYSTEM_IDENTIFIER};
    createSystemProcedureOrFunction(""String_Node_Str"",sysUtilUUID,arg_names,arg_types,0,0,RoutineAliasInfo.READS_SQL_DATA,false,DataTypeDescriptor.getCatalogType(Types.BIGINT),newlyCreatedRoutines,tc);
  }
}"
80032,"/** 
 * Drops a sequence descriptor
 * @param descriptor The descriptor to drop
 * @param tc         The TransactionController.
 * @throws StandardException Thrown on failure
 */
public void dropSequenceDescriptor(SequenceDescriptor descriptor,TransactionController tc) throws StandardException {
  DataValueDescriptor sequenceIdOrderable;
  TabInfoImpl ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM);
  sequenceIdOrderable=getIDValueAsCHAR(descriptor.getUUID());
  ExecIndexRow keyRow=(ExecIndexRow)exFactory.getIndexableRow(1);
  keyRow.setColumn(1,sequenceIdOrderable);
  ti.deleteRow(tc,keyRow,SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID);
}","/** 
 * Drops a sequence descriptor
 * @param descriptor The descriptor to drop
 * @param tc         The TransactionController.
 * @throws StandardException Thrown on failure
 */
public void dropSequenceDescriptor(SequenceDescriptor descriptor,TransactionController tc) throws StandardException {
  DataValueDescriptor sequenceIdOrderable;
  TabInfoImpl ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM);
  sequenceIdOrderable=getIDValueAsCHAR(descriptor.getUUID());
  ExecIndexRow keyRow=(ExecIndexRow)exFactory.getIndexableRow(1);
  keyRow.setColumn(1,sequenceIdOrderable);
  ti.deleteRow(tc,keyRow,SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID);
  dropSequenceID(descriptor);
}"
80033,"/** 
 * Start-up method for this instance of the data dictionary.
 * @param startParams	The start-up parameters
 * @exception StandardException	Thrown if the module fails to start
 */
public void boot(boolean create,Properties startParams) throws StandardException {
  softwareVersion=new DD_Version(this,DataDictionary.DD_VERSION_DERBY_10_9);
  startupParameters=startParams;
  uuidFactory=Monitor.getMonitor().getUUIDFactory();
  engineType=Monitor.getEngineType(startParams);
  collationTypeOfSystemSchemas=StringDataValue.COLLATION_TYPE_UCS_BASIC;
  getBuiltinSystemSchemas();
  LanguageConnectionFactory langConnFactory=(LanguageConnectionFactory)Monitor.bootServiceModule(create,this,LanguageConnectionFactory.MODULE,startParams);
  dvf=langConnFactory.getDataValueFactory();
  exFactory=(ExecutionFactory)Monitor.bootServiceModule(create,this,ExecutionFactory.MODULE,startParams);
  initializeCatalogInfo();
  booting=true;
  if (dataDescriptorGenerator == null) {
    dataDescriptorGenerator=new DataDescriptorGenerator(this);
  }
  if (!create) {
    coreInfo[SYSTABLES_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSTABLES_ID,true));
    coreInfo[SYSTABLES_CORE_NUM].setIndexConglomerate(SYSTABLESRowFactory.SYSTABLES_INDEX1_ID,getBootParameter(startParams,CFG_SYSTABLES_INDEX1_ID,true));
    coreInfo[SYSTABLES_CORE_NUM].setIndexConglomerate(SYSTABLESRowFactory.SYSTABLES_INDEX2_ID,getBootParameter(startParams,CFG_SYSTABLES_INDEX2_ID,true));
    coreInfo[SYSCOLUMNS_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSCOLUMNS_ID,true));
    coreInfo[SYSCOLUMNS_CORE_NUM].setIndexConglomerate(SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID,getBootParameter(startParams,CFG_SYSCOLUMNS_INDEX1_ID,true));
    coreInfo[SYSCOLUMNS_CORE_NUM].setIndexConglomerate(SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX2_ID,getBootParameter(startParams,CFG_SYSCOLUMNS_INDEX2_ID,false));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSCONGLOMERATES_ID,true));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setIndexConglomerate(SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX1_ID,getBootParameter(startParams,CFG_SYSCONGLOMERATES_INDEX1_ID,true));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setIndexConglomerate(SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX2_ID,getBootParameter(startParams,CFG_SYSCONGLOMERATES_INDEX2_ID,true));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setIndexConglomerate(SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX3_ID,getBootParameter(startParams,CFG_SYSCONGLOMERATES_INDEX3_ID,true));
    coreInfo[SYSSCHEMAS_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSSCHEMAS_ID,true));
    coreInfo[SYSSCHEMAS_CORE_NUM].setIndexConglomerate(SYSSCHEMASRowFactory.SYSSCHEMAS_INDEX1_ID,getBootParameter(startParams,CFG_SYSSCHEMAS_INDEX1_ID,true));
    coreInfo[SYSSCHEMAS_CORE_NUM].setIndexConglomerate(SYSSCHEMASRowFactory.SYSSCHEMAS_INDEX2_ID,getBootParameter(startParams,CFG_SYSSCHEMAS_INDEX2_ID,true));
  }
  String value=startParams.getProperty(Property.LANG_TD_CACHE_SIZE);
  tdCacheSize=PropertyUtil.intPropertyValue(Property.LANG_TD_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_TD_CACHE_SIZE_DEFAULT);
  value=startParams.getProperty(Property.LANG_SPS_CACHE_SIZE);
  stmtCacheSize=PropertyUtil.intPropertyValue(Property.LANG_SPS_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_SPS_CACHE_SIZE_DEFAULT);
  value=startParams.getProperty(Property.LANG_SEQGEN_CACHE_SIZE);
  seqgenCacheSize=PropertyUtil.intPropertyValue(Property.LANG_SEQGEN_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_SEQGEN_CACHE_SIZE_DEFAULT);
  value=startParams.getProperty(Property.LANG_PERMISSIONS_CACHE_SIZE);
  permissionsCacheSize=PropertyUtil.intPropertyValue(Property.LANG_PERMISSIONS_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_PERMISSIONS_CACHE_SIZE_DEFAULT);
  indexStatsUpdateDisabled=!PropertyUtil.getSystemBoolean(Property.STORAGE_AUTO_INDEX_STATS,true);
  indexStatsUpdateLogging=PropertyUtil.getSystemBoolean(Property.STORAGE_AUTO_INDEX_STATS_LOGGING);
  indexStatsUpdateTracing=PropertyUtil.getSystemProperty(Property.STORAGE_AUTO_INDEX_STATS_TRACING,""String_Node_Str"");
  CacheFactory cf=(CacheFactory)Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
  OIDTdCache=cf.newCacheManager(this,""String_Node_Str"",tdCacheSize,tdCacheSize);
  nameTdCache=cf.newCacheManager(this,""String_Node_Str"",tdCacheSize,tdCacheSize);
  if (stmtCacheSize > 0) {
    spsNameCache=cf.newCacheManager(this,""String_Node_Str"",stmtCacheSize,stmtCacheSize);
    spsIdHash=new Hashtable(stmtCacheSize);
  }
  sequenceGeneratorCache=cf.newCacheManager(this,""String_Node_Str"",seqgenCacheSize,seqgenCacheSize);
  cacheCoordinator=new ShExLockable();
  af=(AccessFactory)Monitor.findServiceModule(this,AccessFactory.MODULE);
  lockFactory=af.getLockFactory();
  ContextService csf=ContextService.getFactory();
  ContextManager cm=csf.getCurrentContextManager();
  if (SanityManager.DEBUG)   SanityManager.ASSERT((cm != null),""String_Node_Str"");
  bootingTC=null;
  try {
    bootingTC=af.getTransaction(cm);
    exFactory.newExecutionContext(cm);
    DataDescriptorGenerator ddg=getDataDescriptorGenerator();
    String userDefinedCollation;
    if (create) {
      userDefinedCollation=startParams.getProperty(Attribute.COLLATION,Property.UCS_BASIC_COLLATION);
      bootingTC.setProperty(Property.COLLATION,userDefinedCollation,true);
    }
 else {
      userDefinedCollation=startParams.getProperty(Property.COLLATION,Property.UCS_BASIC_COLLATION);
    }
    collationTypeOfUserSchemas=DataTypeDescriptor.getCollationType(userDefinedCollation);
    if (SanityManager.DEBUG)     SanityManager.ASSERT((collationTypeOfUserSchemas != -1),""String_Node_Str"" + userDefinedCollation);
    declaredGlobalTemporaryTablesSchemaDesc=newDeclaredGlobalTemporaryTablesSchemaDesc(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME);
    boolean nativeAuthenticationEnabled=PropertyUtil.nativeAuthenticationEnabled(startParams);
    if (create) {
      String userName=IdUtil.getUserNameFromURLProps(startParams);
      authorizationDatabaseOwner=IdUtil.getUserAuthorizationId(userName);
      HashSet newlyCreatedRoutines=new HashSet();
      createDictionaryTables(startParams,bootingTC,ddg);
      create_SYSIBM_procedures(bootingTC,newlyCreatedRoutines);
      createSystemSps(bootingTC);
      create_SYSCS_procedures(bootingTC,newlyCreatedRoutines);
      grantPublicAccessToSystemRoutines(newlyCreatedRoutines,bootingTC,authorizationDatabaseOwner);
      dictionaryVersion=softwareVersion;
      bootingTC.setProperty(DataDictionary.CORE_DATA_DICTIONARY_VERSION,dictionaryVersion,true);
      bootingTC.setProperty(DataDictionary.CREATE_DATA_DICTIONARY_VERSION,dictionaryVersion,true);
      if (PropertyUtil.getSystemBoolean(Property.SQL_AUTHORIZATION_PROPERTY)) {
        bootingTC.setProperty(Property.SQL_AUTHORIZATION_PROPERTY,""String_Node_Str"",true);
      }
      if (PropertyUtil.getSystemBoolean(Property.SQL_AUTHORIZATION_PROPERTY) || nativeAuthenticationEnabled) {
        usesSqlAuthorization=true;
      }
      bootingTC.setProperty(Property.AUTHENTICATION_BUILTIN_ALGORITHM,findDefaultBuiltinAlgorithm(),false);
    }
 else {
      loadDictionaryTables(bootingTC,ddg,startParams);
      String dbIndexStatsUpdateAuto=PropertyUtil.getDatabaseProperty(bootingTC,Property.STORAGE_AUTO_INDEX_STATS);
      if (dbIndexStatsUpdateAuto != null) {
        indexStatsUpdateDisabled=!Boolean.valueOf(dbIndexStatsUpdateAuto).booleanValue();
      }
      String dbEnableIndexStatsLogging=PropertyUtil.getDatabaseProperty(bootingTC,Property.STORAGE_AUTO_INDEX_STATS_LOGGING);
      if (dbEnableIndexStatsLogging != null) {
        indexStatsUpdateLogging=Boolean.valueOf(dbEnableIndexStatsLogging).booleanValue();
      }
      String dbEnableIndexStatsTracing=PropertyUtil.getDatabaseProperty(bootingTC,Property.STORAGE_AUTO_INDEX_STATS_TRACING);
      if (dbEnableIndexStatsTracing != null) {
        if (!(dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str"") || dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str"") || dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str"")|| dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str""))) {
          indexStatsUpdateTracing=""String_Node_Str"";
        }
 else {
          indexStatsUpdateTracing=dbEnableIndexStatsTracing;
        }
      }
      String sqlAuth=PropertyUtil.getDatabaseProperty(bootingTC,Property.SQL_AUTHORIZATION_PROPERTY);
      if (Boolean.valueOf(startParams.getProperty(Attribute.SOFT_UPGRADE_NO_FEATURE_CHECK)).booleanValue()) {
        if (dictionaryVersion.majorVersionNumber >= DataDictionary.DD_VERSION_DERBY_10_2) {
          usesSqlAuthorization=Boolean.valueOf(sqlAuth).booleanValue() || nativeAuthenticationEnabled;
        }
      }
 else {
        if (Boolean.valueOf(sqlAuth).booleanValue() || nativeAuthenticationEnabled) {
          checkVersion(DataDictionary.DD_VERSION_DERBY_10_2,""String_Node_Str"");
          usesSqlAuthorization=true;
        }
      }
    }
    if (SanityManager.DEBUG)     SanityManager.ASSERT((authorizationDatabaseOwner != null),""String_Node_Str"");
    bootingTC.commit();
    cm.getContext(ExecutionContext.CONTEXT_ID).popMe();
  }
  finally {
    if (bootingTC != null) {
      bootingTC.destroy();
      bootingTC=null;
    }
  }
  setDependencyManager();
  booting=false;
}","/** 
 * Start-up method for this instance of the data dictionary.
 * @param startParams	The start-up parameters
 * @exception StandardException	Thrown if the module fails to start
 */
public void boot(boolean create,Properties startParams) throws StandardException {
  softwareVersion=new DD_Version(this,DataDictionary.DD_VERSION_DERBY_10_9);
  startupParameters=startParams;
  uuidFactory=Monitor.getMonitor().getUUIDFactory();
  engineType=Monitor.getEngineType(startParams);
  collationTypeOfSystemSchemas=StringDataValue.COLLATION_TYPE_UCS_BASIC;
  getBuiltinSystemSchemas();
  LanguageConnectionFactory langConnFactory=(LanguageConnectionFactory)Monitor.bootServiceModule(create,this,LanguageConnectionFactory.MODULE,startParams);
  dvf=langConnFactory.getDataValueFactory();
  exFactory=(ExecutionFactory)Monitor.bootServiceModule(create,this,ExecutionFactory.MODULE,startParams);
  initializeCatalogInfo();
  booting=true;
  if (dataDescriptorGenerator == null) {
    dataDescriptorGenerator=new DataDescriptorGenerator(this);
  }
  if (!create) {
    coreInfo[SYSTABLES_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSTABLES_ID,true));
    coreInfo[SYSTABLES_CORE_NUM].setIndexConglomerate(SYSTABLESRowFactory.SYSTABLES_INDEX1_ID,getBootParameter(startParams,CFG_SYSTABLES_INDEX1_ID,true));
    coreInfo[SYSTABLES_CORE_NUM].setIndexConglomerate(SYSTABLESRowFactory.SYSTABLES_INDEX2_ID,getBootParameter(startParams,CFG_SYSTABLES_INDEX2_ID,true));
    coreInfo[SYSCOLUMNS_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSCOLUMNS_ID,true));
    coreInfo[SYSCOLUMNS_CORE_NUM].setIndexConglomerate(SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID,getBootParameter(startParams,CFG_SYSCOLUMNS_INDEX1_ID,true));
    coreInfo[SYSCOLUMNS_CORE_NUM].setIndexConglomerate(SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX2_ID,getBootParameter(startParams,CFG_SYSCOLUMNS_INDEX2_ID,false));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSCONGLOMERATES_ID,true));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setIndexConglomerate(SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX1_ID,getBootParameter(startParams,CFG_SYSCONGLOMERATES_INDEX1_ID,true));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setIndexConglomerate(SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX2_ID,getBootParameter(startParams,CFG_SYSCONGLOMERATES_INDEX2_ID,true));
    coreInfo[SYSCONGLOMERATES_CORE_NUM].setIndexConglomerate(SYSCONGLOMERATESRowFactory.SYSCONGLOMERATES_INDEX3_ID,getBootParameter(startParams,CFG_SYSCONGLOMERATES_INDEX3_ID,true));
    coreInfo[SYSSCHEMAS_CORE_NUM].setHeapConglomerate(getBootParameter(startParams,CFG_SYSSCHEMAS_ID,true));
    coreInfo[SYSSCHEMAS_CORE_NUM].setIndexConglomerate(SYSSCHEMASRowFactory.SYSSCHEMAS_INDEX1_ID,getBootParameter(startParams,CFG_SYSSCHEMAS_INDEX1_ID,true));
    coreInfo[SYSSCHEMAS_CORE_NUM].setIndexConglomerate(SYSSCHEMASRowFactory.SYSSCHEMAS_INDEX2_ID,getBootParameter(startParams,CFG_SYSSCHEMAS_INDEX2_ID,true));
  }
  String value=startParams.getProperty(Property.LANG_TD_CACHE_SIZE);
  tdCacheSize=PropertyUtil.intPropertyValue(Property.LANG_TD_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_TD_CACHE_SIZE_DEFAULT);
  value=startParams.getProperty(Property.LANG_SPS_CACHE_SIZE);
  stmtCacheSize=PropertyUtil.intPropertyValue(Property.LANG_SPS_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_SPS_CACHE_SIZE_DEFAULT);
  value=startParams.getProperty(Property.LANG_SEQGEN_CACHE_SIZE);
  seqgenCacheSize=PropertyUtil.intPropertyValue(Property.LANG_SEQGEN_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_SEQGEN_CACHE_SIZE_DEFAULT);
  value=startParams.getProperty(Property.LANG_PERMISSIONS_CACHE_SIZE);
  permissionsCacheSize=PropertyUtil.intPropertyValue(Property.LANG_PERMISSIONS_CACHE_SIZE,value,0,Integer.MAX_VALUE,Property.LANG_PERMISSIONS_CACHE_SIZE_DEFAULT);
  indexStatsUpdateDisabled=!PropertyUtil.getSystemBoolean(Property.STORAGE_AUTO_INDEX_STATS,true);
  indexStatsUpdateLogging=PropertyUtil.getSystemBoolean(Property.STORAGE_AUTO_INDEX_STATS_LOGGING);
  indexStatsUpdateTracing=PropertyUtil.getSystemProperty(Property.STORAGE_AUTO_INDEX_STATS_TRACING,""String_Node_Str"");
  CacheFactory cf=(CacheFactory)Monitor.startSystemModule(org.apache.derby.iapi.reference.Module.CacheFactory);
  OIDTdCache=cf.newCacheManager(this,""String_Node_Str"",tdCacheSize,tdCacheSize);
  nameTdCache=cf.newCacheManager(this,""String_Node_Str"",tdCacheSize,tdCacheSize);
  if (stmtCacheSize > 0) {
    spsNameCache=cf.newCacheManager(this,""String_Node_Str"",stmtCacheSize,stmtCacheSize);
    spsIdHash=new Hashtable(stmtCacheSize);
  }
  sequenceGeneratorCache=cf.newCacheManager(this,""String_Node_Str"",seqgenCacheSize,seqgenCacheSize);
  sequenceIDs=new HashMap();
  cacheCoordinator=new ShExLockable();
  af=(AccessFactory)Monitor.findServiceModule(this,AccessFactory.MODULE);
  lockFactory=af.getLockFactory();
  ContextService csf=ContextService.getFactory();
  ContextManager cm=csf.getCurrentContextManager();
  if (SanityManager.DEBUG)   SanityManager.ASSERT((cm != null),""String_Node_Str"");
  bootingTC=null;
  try {
    bootingTC=af.getTransaction(cm);
    exFactory.newExecutionContext(cm);
    DataDescriptorGenerator ddg=getDataDescriptorGenerator();
    String userDefinedCollation;
    if (create) {
      userDefinedCollation=startParams.getProperty(Attribute.COLLATION,Property.UCS_BASIC_COLLATION);
      bootingTC.setProperty(Property.COLLATION,userDefinedCollation,true);
    }
 else {
      userDefinedCollation=startParams.getProperty(Property.COLLATION,Property.UCS_BASIC_COLLATION);
    }
    collationTypeOfUserSchemas=DataTypeDescriptor.getCollationType(userDefinedCollation);
    if (SanityManager.DEBUG)     SanityManager.ASSERT((collationTypeOfUserSchemas != -1),""String_Node_Str"" + userDefinedCollation);
    declaredGlobalTemporaryTablesSchemaDesc=newDeclaredGlobalTemporaryTablesSchemaDesc(SchemaDescriptor.STD_DECLARED_GLOBAL_TEMPORARY_TABLES_SCHEMA_NAME);
    boolean nativeAuthenticationEnabled=PropertyUtil.nativeAuthenticationEnabled(startParams);
    if (create) {
      String userName=IdUtil.getUserNameFromURLProps(startParams);
      authorizationDatabaseOwner=IdUtil.getUserAuthorizationId(userName);
      HashSet newlyCreatedRoutines=new HashSet();
      createDictionaryTables(startParams,bootingTC,ddg);
      create_SYSIBM_procedures(bootingTC,newlyCreatedRoutines);
      createSystemSps(bootingTC);
      create_SYSCS_procedures(bootingTC,newlyCreatedRoutines);
      grantPublicAccessToSystemRoutines(newlyCreatedRoutines,bootingTC,authorizationDatabaseOwner);
      dictionaryVersion=softwareVersion;
      bootingTC.setProperty(DataDictionary.CORE_DATA_DICTIONARY_VERSION,dictionaryVersion,true);
      bootingTC.setProperty(DataDictionary.CREATE_DATA_DICTIONARY_VERSION,dictionaryVersion,true);
      if (PropertyUtil.getSystemBoolean(Property.SQL_AUTHORIZATION_PROPERTY)) {
        bootingTC.setProperty(Property.SQL_AUTHORIZATION_PROPERTY,""String_Node_Str"",true);
      }
      if (PropertyUtil.getSystemBoolean(Property.SQL_AUTHORIZATION_PROPERTY) || nativeAuthenticationEnabled) {
        usesSqlAuthorization=true;
      }
      bootingTC.setProperty(Property.AUTHENTICATION_BUILTIN_ALGORITHM,findDefaultBuiltinAlgorithm(),false);
    }
 else {
      loadDictionaryTables(bootingTC,ddg,startParams);
      String dbIndexStatsUpdateAuto=PropertyUtil.getDatabaseProperty(bootingTC,Property.STORAGE_AUTO_INDEX_STATS);
      if (dbIndexStatsUpdateAuto != null) {
        indexStatsUpdateDisabled=!Boolean.valueOf(dbIndexStatsUpdateAuto).booleanValue();
      }
      String dbEnableIndexStatsLogging=PropertyUtil.getDatabaseProperty(bootingTC,Property.STORAGE_AUTO_INDEX_STATS_LOGGING);
      if (dbEnableIndexStatsLogging != null) {
        indexStatsUpdateLogging=Boolean.valueOf(dbEnableIndexStatsLogging).booleanValue();
      }
      String dbEnableIndexStatsTracing=PropertyUtil.getDatabaseProperty(bootingTC,Property.STORAGE_AUTO_INDEX_STATS_TRACING);
      if (dbEnableIndexStatsTracing != null) {
        if (!(dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str"") || dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str"") || dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str"")|| dbEnableIndexStatsTracing.equalsIgnoreCase(""String_Node_Str""))) {
          indexStatsUpdateTracing=""String_Node_Str"";
        }
 else {
          indexStatsUpdateTracing=dbEnableIndexStatsTracing;
        }
      }
      String sqlAuth=PropertyUtil.getDatabaseProperty(bootingTC,Property.SQL_AUTHORIZATION_PROPERTY);
      if (Boolean.valueOf(startParams.getProperty(Attribute.SOFT_UPGRADE_NO_FEATURE_CHECK)).booleanValue()) {
        if (dictionaryVersion.majorVersionNumber >= DataDictionary.DD_VERSION_DERBY_10_2) {
          usesSqlAuthorization=Boolean.valueOf(sqlAuth).booleanValue() || nativeAuthenticationEnabled;
        }
      }
 else {
        if (Boolean.valueOf(sqlAuth).booleanValue() || nativeAuthenticationEnabled) {
          checkVersion(DataDictionary.DD_VERSION_DERBY_10_2,""String_Node_Str"");
          usesSqlAuthorization=true;
        }
      }
    }
    if (SanityManager.DEBUG)     SanityManager.ASSERT((authorizationDatabaseOwner != null),""String_Node_Str"");
    bootingTC.commit();
    cm.getContext(ExecutionContext.CONTEXT_ID).popMe();
  }
  finally {
    if (bootingTC != null) {
      bootingTC.destroy();
      bootingTC=null;
    }
  }
  setDependencyManager();
  booting=false;
}"
80034,"/** 
 * Get the sequence descriptor given a sequence name and a schema Id.
 * @param sequenceName The sequence name, guaranteed to be unique only within its schema.
 * @param sd           The schema descriptor.
 * @return The SequenceDescriptor for the constraints.
 * @throws StandardException Thrown on failure
 */
public SequenceDescriptor getSequenceDescriptor(SchemaDescriptor sd,String sequenceName) throws StandardException {
  DataValueDescriptor schemaIDOrderable;
  DataValueDescriptor sequenceNameOrderable;
  TabInfoImpl ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM);
  sequenceNameOrderable=new SQLVarchar(sequenceName);
  schemaIDOrderable=getIDValueAsCHAR(sd.getUUID());
  ExecIndexRow keyRow=exFactory.getIndexableRow(2);
  keyRow.setColumn(1,schemaIDOrderable);
  keyRow.setColumn(2,sequenceNameOrderable);
  return (SequenceDescriptor)getDescriptorViaIndex(SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX2_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List)null,false);
}","/** 
 * Get the sequence descriptor given a sequence name and a schema Id.
 * @param sequenceName The sequence name, guaranteed to be unique only within its schema.
 * @param sd           The schema descriptor.
 * @return The SequenceDescriptor for the constraints.
 * @throws StandardException Thrown on failure
 */
public SequenceDescriptor getSequenceDescriptor(SchemaDescriptor sd,String sequenceName) throws StandardException {
  DataValueDescriptor schemaIDOrderable;
  DataValueDescriptor sequenceNameOrderable;
  TabInfoImpl ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM);
  sequenceNameOrderable=new SQLVarchar(sequenceName);
  schemaIDOrderable=getIDValueAsCHAR(sd.getUUID());
  ExecIndexRow keyRow=exFactory.getIndexableRow(2);
  keyRow.setColumn(1,schemaIDOrderable);
  keyRow.setColumn(2,sequenceNameOrderable);
  SequenceDescriptor sequenceDescriptor=(SequenceDescriptor)getDescriptorViaIndex(SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX2_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List)null,false);
  putSequenceID(sequenceDescriptor);
  return sequenceDescriptor;
}"
80035,"/** 
 * Open connection to the specified database using the supplied username and password. Treat the database name as a physical database name rather than as a logical name which needs to be mapped. If the database does not exist, it will be created. Requires that the test has been decorated with additionalDatabaseDecorator with the matching name.
 * @param physicalDatabaseName The real database name to use.
 * @user name of user
 * @password password of user
 * @return connection to specified database.
 */
public Connection openPhysicalConnection(String physicalDatabaseName,String user,String password) throws SQLException {
  return connector.openConnection(physicalDatabaseName,user,password);
}","/** 
 * Open connection to the specified database using the supplied username and password. Treat the database name as a physical database name rather than as a logical name which needs to be mapped. If the database does not exist, it will be created. Requires that the test has been decorated with additionalDatabaseDecorator with the matching name.
 * @param physicalDatabaseName The real database name to use.
 * @param user name of user
 * @param password password of user
 * @return connection to specified database.
 */
public Connection openPhysicalConnection(String physicalDatabaseName,String user,String password) throws SQLException {
  return connector.openConnection(physicalDatabaseName,user,password);
}"
80036,"/** 
 * Drop a User from the DataDictionary
 * @param ad	The AliasDescriptor to drop
 * @param tc	The TransactionController
 * @exception StandardException		Thrown on failure
 */
public void dropUser(String userName,TransactionController tc) throws StandardException {
  TabInfoImpl ti=getNonCoreTI(SYSUSERS_CATALOG_NUM);
  ExecIndexRow keyRow1=(ExecIndexRow)exFactory.getIndexableRow(1);
  keyRow1.setColumn(1,new SQLVarchar(userName));
  ti.deleteRow(tc,keyRow1,SYSUSERSRowFactory.SYSUSERS_INDEX1_ID);
}","/** 
 * Drop a User from the DataDictionary
 * @param userName The user to drop.
 * @param tc	The TransactionController
 * @exception StandardException		Thrown on failure
 */
public void dropUser(String userName,TransactionController tc) throws StandardException {
  TabInfoImpl ti=getNonCoreTI(SYSUSERS_CATALOG_NUM);
  ExecIndexRow keyRow1=(ExecIndexRow)exFactory.getIndexableRow(1);
  keyRow1.setColumn(1,new SQLVarchar(userName));
  ti.deleteRow(tc,keyRow1,SYSUSERSRowFactory.SYSUSERS_INDEX1_ID);
}"
80037,"/** 
 * @see java.sql.ResultSet#next
 * @exception SQLException If database-access error occurs.
 */
public boolean next() throws SQLException {
  if (!gotFile) {
    gotFile=true;
    try {
      inputFileStreamReader=new InputStreamReader(new FileInputStream(inputFileName));
      bufferedReader=new BufferedReader(inputFileStreamReader,32 * 1024);
    }
 catch (    FileNotFoundException ex) {
      throw new SQLException(ex.getMessage());
    }
  }
  while (true) {
    try {
      line=bufferedReader.readLine();
    }
 catch (    java.io.IOException ioe) {
      throw new SQLException(ioe.getMessage());
    }
    if (line == null) {
      return false;
    }
    gmtIndex=line.indexOf(GMT_STRING);
    threadIndex=line.indexOf(BEGIN_THREAD_STRING);
    xidIndex=line.indexOf(BEGIN_XID_STRING);
    lccidIndex=line.indexOf(BEGIN_XID_STRING,xidIndex + 1);
    databaseIndex=line.indexOf(BEGIN_DATABASE_STRING,lccidIndex + 1);
    drdaidIndex=line.indexOf(BEGIN_DRDAID_STRING,databaseIndex + 1);
    if (line.indexOf(PARAMETERS_STRING) != -1) {
      continue;
    }
    if (gmtIndex != -1 && threadIndex != -1 && xidIndex != -1 && databaseIndex != -1) {
      return true;
    }
  }
}","/** 
 * @see java.sql.ResultSet#next
 * @exception SQLException If database-access error occurs.
 */
public boolean next() throws SQLException {
  if (!gotFile) {
    gotFile=true;
    try {
      inputFileStreamReader=new InputStreamReader(new FileInputStream(inputFileName));
      bufferedReader=new BufferedReader(inputFileStreamReader,32 * 1024);
    }
 catch (    FileNotFoundException ex) {
      throw new SQLException(ex.getMessage());
    }
  }
  while (true) {
    try {
      line=bufferedReader.readLine();
    }
 catch (    java.io.IOException ioe) {
      throw new SQLException(ioe.getMessage());
    }
    if (line == null) {
      return false;
    }
    endTimestampIndex=line.indexOf(END_TIMESTAMP);
    threadIndex=line.indexOf(BEGIN_THREAD_STRING);
    xidIndex=line.indexOf(BEGIN_XID_STRING);
    lccidIndex=line.indexOf(BEGIN_XID_STRING,xidIndex + 1);
    databaseIndex=line.indexOf(BEGIN_DATABASE_STRING,lccidIndex + 1);
    drdaidIndex=line.indexOf(BEGIN_DRDAID_STRING,databaseIndex + 1);
    if (line.indexOf(PARAMETERS_STRING) != -1) {
      continue;
    }
    if (endTimestampIndex != -1 && threadIndex != -1 && xidIndex != -1 && databaseIndex != -1) {
      return true;
    }
  }
}"
80038,"/** 
 * All columns in the Db2jLogReader VTI have a of String type.
 * @see java.sql.ResultSet#getString
 * @exception SQLException If database-access error occurs.
 */
public String getString(int columnNumber) throws SQLException {
switch (columnNumber) {
case 1:
    return line.substring(0,gmtIndex);
case 2:
  return line.substring(threadIndex + 1,line.indexOf(END_THREAD_STRING));
case 3:
return line.substring(xidIndex + 2,line.indexOf(END_XID_STRING,xidIndex));
case 4:
return line.substring(lccidIndex + 2,line.indexOf(END_XID_STRING,lccidIndex));
case 5:
return line.substring(databaseIndex + BEGIN_DATABASE_STRING.length(),line.indexOf(END_DATABASE_STRING,databaseIndex));
case 6:
return line.substring(drdaidIndex + BEGIN_DRDAID_STRING.length(),line.indexOf(END_DRDAID_STRING,drdaidIndex));
case 7:
StringBuffer output=new StringBuffer(64);
if (line.indexOf(BEGIN_EXECUTING_STRING) == -1) {
output.append(line.substring(line.indexOf(END_DRDAID_STRING,drdaidIndex) + 3));
}
 else {
int endIndex=line.indexOf(END_EXECUTING_STRING,drdaidIndex);
if (endIndex == -1) {
output.append(line.substring(line.indexOf(END_DRDAID_STRING,drdaidIndex) + 3));
}
 else {
output.append(line.substring(line.indexOf(END_XID_STRING,drdaidIndex) + 3,endIndex));
}
while (endIndex == -1) {
try {
line=bufferedReader.readLine();
}
 catch (java.io.IOException ioe) {
throw new SQLException(""String_Node_Str"" + ioe);
}
endIndex=line.indexOf(END_EXECUTING_STRING);
if (endIndex == -1) {
output.append(line);
}
 else {
output.append(line.substring(0,endIndex));
}
}
}
return StringUtil.truncate(output.toString(),Limits.DB2_VARCHAR_MAXWIDTH);
default :
return ""String_Node_Str"";
}
}","/** 
 * All columns in the Db2jLogReader VTI have a of String type.
 * @see java.sql.ResultSet#getString
 * @exception SQLException If database-access error occurs.
 */
public String getString(int columnNumber) throws SQLException {
switch (columnNumber) {
case 1:
    return line.substring(0,endTimestampIndex);
case 2:
  return line.substring(threadIndex + 1,line.indexOf(END_THREAD_STRING));
case 3:
return line.substring(xidIndex + 2,line.indexOf(END_XID_STRING,xidIndex));
case 4:
return line.substring(lccidIndex + 2,line.indexOf(END_XID_STRING,lccidIndex));
case 5:
return line.substring(databaseIndex + BEGIN_DATABASE_STRING.length(),line.indexOf(END_DATABASE_STRING,databaseIndex));
case 6:
return line.substring(drdaidIndex + BEGIN_DRDAID_STRING.length(),line.indexOf(END_DRDAID_STRING,drdaidIndex));
case 7:
StringBuffer output=new StringBuffer(64);
if (line.indexOf(BEGIN_EXECUTING_STRING) == -1) {
output.append(line.substring(line.indexOf(END_DRDAID_STRING,drdaidIndex) + 3));
}
 else {
int endIndex=line.indexOf(END_EXECUTING_STRING,drdaidIndex);
if (endIndex == -1) {
output.append(line.substring(line.indexOf(END_DRDAID_STRING,drdaidIndex) + 3));
}
 else {
output.append(line.substring(line.indexOf(END_XID_STRING,drdaidIndex) + 3,endIndex));
}
while (endIndex == -1) {
try {
line=bufferedReader.readLine();
}
 catch (java.io.IOException ioe) {
throw new SQLException(""String_Node_Str"" + ioe);
}
endIndex=line.indexOf(END_EXECUTING_STRING);
if (endIndex == -1) {
output.append(line);
}
 else {
output.append(line.substring(0,endIndex));
}
}
}
return StringUtil.truncate(output.toString(),Limits.DB2_VARCHAR_MAXWIDTH);
default :
return ""String_Node_Str"";
}
}"
80039,"/** 
 * @see java.sql.ResultSet#next
 * @exception SQLException If database access error occurs.
 */
public boolean next() throws SQLException {
  if (!gotFile) {
    gotFile=true;
    try {
      inputFileStreamReader=new InputStreamReader(new FileInputStream(inputFileName));
      bufferedReader=new BufferedReader(inputFileStreamReader,32 * 1024);
    }
 catch (    FileNotFoundException ex) {
      throw new SQLException(ex.getMessage());
    }
    hashTable=new Hashtable();
  }
  while (true) {
    try {
      line=bufferedReader.readLine();
    }
 catch (    java.io.IOException ioe) {
      throw new SQLException(ioe.getMessage());
    }
    if (line == null) {
      return false;
    }
    gmtIndex=line.indexOf(GMT_STRING);
    threadIndex=line.indexOf(BEGIN_THREAD_STRING);
    xidIndex=line.indexOf(BEGIN_XID_STRING);
    lccidIndex=line.indexOf(BEGIN_XID_STRING,xidIndex + 1);
    if (gmtIndex != -1 && threadIndex != -1) {
      String[] newRow=new String[6];
      for (int index=1; index <= 5; index++) {
        newRow[index - 1]=setupColumn(index);
      }
      Object previousRow=hashTable.put(newRow[3],newRow);
      if (previousRow == null) {
        continue;
      }
      currentRow=(String[])previousRow;
      Timestamp endTs=Timestamp.valueOf(newRow[0]);
      long end=endTs.getTime() + endTs.getNanos() / 1000000;
      Timestamp startTs=Timestamp.valueOf(currentRow[0]);
      long start=startTs.getTime() + startTs.getNanos() / 1000000;
      currentRow[5]=Long.toString(end - start);
      return true;
    }
  }
}","/** 
 * @see java.sql.ResultSet#next
 * @exception SQLException If database access error occurs.
 */
public boolean next() throws SQLException {
  if (!gotFile) {
    gotFile=true;
    try {
      inputFileStreamReader=new InputStreamReader(new FileInputStream(inputFileName));
      bufferedReader=new BufferedReader(inputFileStreamReader,32 * 1024);
    }
 catch (    FileNotFoundException ex) {
      throw new SQLException(ex.getMessage());
    }
    hashTable=new Hashtable();
  }
  while (true) {
    try {
      line=bufferedReader.readLine();
    }
 catch (    java.io.IOException ioe) {
      throw new SQLException(ioe.getMessage());
    }
    if (line == null) {
      return false;
    }
    endTimestampIndex=line.indexOf(END_TIMESTAMP);
    threadIndex=line.indexOf(BEGIN_THREAD_STRING);
    xidIndex=line.indexOf(BEGIN_XID_STRING);
    lccidIndex=line.indexOf(BEGIN_XID_STRING,xidIndex + 1);
    if (endTimestampIndex != -1 && threadIndex != -1 && xidIndex != -1) {
      String[] newRow=new String[6];
      for (int index=1; index <= 5; index++) {
        newRow[index - 1]=setupColumn(index);
      }
      Object previousRow=hashTable.put(newRow[3],newRow);
      if (previousRow == null) {
        continue;
      }
      currentRow=(String[])previousRow;
      Timestamp endTs=stringToTimestamp(newRow[0]);
      long end=endTs.getTime() + endTs.getNanos() / 1000000;
      Timestamp startTs=stringToTimestamp(currentRow[0]);
      long start=startTs.getTime() + startTs.getNanos() / 1000000;
      currentRow[5]=Long.toString(end - start);
      return true;
    }
  }
}"
80040,"private String setupColumn(int columnNumber) throws SQLException {
switch (columnNumber) {
case 1:
    return line.substring(0,gmtIndex);
case 2:
  return line.substring(threadIndex + 1,line.indexOf(END_THREAD_STRING));
case 3:
return line.substring(xidIndex + 2,line.indexOf(END_XID_STRING,xidIndex));
case 4:
return line.substring(lccidIndex + 2,line.indexOf(END_XID_STRING,lccidIndex));
case 5:
StringBuffer output=new StringBuffer(64);
if (line.indexOf(BEGIN_EXECUTING_STRING) == -1) {
output.append(line.substring(line.indexOf(END_XID_STRING,lccidIndex) + 3));
}
 else {
int endIndex=line.indexOf(END_EXECUTING_STRING,lccidIndex);
if (endIndex == -1) {
output.append(line.substring(line.indexOf(END_XID_STRING,lccidIndex) + 3));
}
 else {
output.append(line.substring(line.indexOf(END_XID_STRING,lccidIndex) + 3,endIndex));
}
while (endIndex == -1) {
try {
line=bufferedReader.readLine();
}
 catch (java.io.IOException ioe) {
throw new SQLException(""String_Node_Str"" + ioe);
}
endIndex=line.indexOf(END_EXECUTING_STRING);
if (endIndex == -1) {
output.append(line);
}
 else {
output.append(line.substring(0,endIndex));
}
}
}
return StringUtil.truncate(output.toString(),Limits.DB2_VARCHAR_MAXWIDTH);
default :
return null;
}
}","private String setupColumn(int columnNumber) throws SQLException {
switch (columnNumber) {
case 1:
    return line.substring(0,endTimestampIndex);
case 2:
  return line.substring(threadIndex + 1,line.indexOf(END_THREAD_STRING));
case 3:
return line.substring(xidIndex + 2,line.indexOf(END_XID_STRING,xidIndex));
case 4:
return line.substring(lccidIndex + 2,line.indexOf(END_XID_STRING,lccidIndex));
case 5:
StringBuffer output=new StringBuffer(64);
if (line.indexOf(BEGIN_EXECUTING_STRING) == -1) {
output.append(line.substring(line.indexOf(END_XID_STRING,lccidIndex) + 3));
}
 else {
int endIndex=line.indexOf(END_EXECUTING_STRING,lccidIndex);
if (endIndex == -1) {
output.append(line.substring(line.indexOf(END_XID_STRING,lccidIndex) + 3));
}
 else {
output.append(line.substring(line.indexOf(END_XID_STRING,lccidIndex) + 3,endIndex));
}
while (endIndex == -1) {
try {
line=bufferedReader.readLine();
}
 catch (java.io.IOException ioe) {
throw new SQLException(""String_Node_Str"" + ioe);
}
endIndex=line.indexOf(END_EXECUTING_STRING);
if (endIndex == -1) {
output.append(line);
}
 else {
output.append(line.substring(0,endIndex));
}
}
}
return StringUtil.truncate(output.toString(),Limits.DB2_VARCHAR_MAXWIDTH);
default :
return null;
}
}"
80041,"public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  suite.addTest(TestConfiguration.defaultSuite(SysDiagVTIMappingTest.class));
  return SecurityManagerSetup.noSecurityManager(new SupportFilesSetup(suite,new String[]{""String_Node_Str"" + testLogFile}));
}","public static Test suite(){
  TestSuite suite=new TestSuite(""String_Node_Str"");
  Test defaultSetup=TestConfiguration.defaultSuite(SysDiagVTIMappingTest.class);
  Properties sysprops=new Properties();
  sysprops.put(""String_Node_Str"",""String_Node_Str"");
  Test verboseTest=new SystemPropertyTestSetup(defaultSetup,sysprops);
  suite.addTest(verboseTest);
  return SecurityManagerSetup.noSecurityManager(new SupportFilesSetup(suite,new String[]{""String_Node_Str"" + testLogFile}));
}"
80042,"/** 
 * Switch to the next log file if possible. <P>MT - log factory is single threaded thru a log file switch, the log is frozen for the duration of the switch
 */
public void switchLogFile() throws StandardException {
  boolean switchedOver=false;
synchronized (this) {
    while (logBeingFlushed | isFrozen) {
      try {
        wait();
      }
 catch (      InterruptedException ie) {
        InterruptStatus.setInterrupted();
      }
    }
    if (endPosition == LOG_FILE_HEADER_SIZE) {
      if (SanityManager.DEBUG) {
        Monitor.logMessage(""String_Node_Str"" + logFileNumber + ""String_Node_Str"");
      }
      return;
    }
    StorageFile newLogFile=getLogFileName(logFileNumber + 1);
    if (logFileNumber + 1 >= maxLogFileNumber) {
      throw StandardException.newException(SQLState.LOG_EXCEED_MAX_LOG_FILE_NUMBER,new Long(maxLogFileNumber));
    }
    StorageRandomAccessFile newLog=null;
    try {
      if (privExists(newLogFile) && !privDelete(newLogFile)) {
        logErrMsg(MessageService.getTextMessage(MessageId.LOG_NEW_LOGFILE_EXIST,newLogFile.getPath()));
        return;
      }
      try {
        newLog=privRandomAccessFile(newLogFile,""String_Node_Str"");
      }
 catch (      IOException ioe) {
        newLog=null;
      }
      if (newLog == null || !privCanWrite(newLogFile)) {
        if (newLog != null)         newLog.close();
        newLog=null;
        return;
      }
      if (initLogFile(newLog,logFileNumber + 1,LogCounter.makeLogInstantAsLong(logFileNumber,endPosition))) {
        switchedOver=true;
        logOut.writeEndMarker(0);
        endPosition+=4;
        inLogSwitch=true;
        flush(logFileNumber,endPosition);
        if (SanityManager.DEBUG) {
          if (SanityManager.DEBUG_ON(TEST_SWITCH_LOG_FAIL2))           throw new IOException(""String_Node_Str"");
        }
        logOut.close();
        logWrittenFromLastCheckPoint+=endPosition;
        endPosition=newLog.getFilePointer();
        lastFlush=endPosition;
        if (isWriteSynced) {
          preAllocateNewLogFile(newLog);
          newLog.close();
          newLog=openLogFileInWriteMode(newLogFile);
          newLog.seek(endPosition);
        }
        logOut=new LogAccessFile(this,newLog,logBufferSize);
        newLog=null;
        if (SanityManager.DEBUG) {
          if (endPosition != LOG_FILE_HEADER_SIZE)           SanityManager.THROWASSERT(""String_Node_Str"" + +endPosition);
        }
        logFileNumber++;
        if (SanityManager.DEBUG) {
          SanityManager.ASSERT(endPosition == LOG_FILE_HEADER_SIZE,""String_Node_Str"");
        }
      }
 else {
        newLog.close();
        newLog=null;
        if (privExists(newLogFile))         privDelete(newLogFile);
        newLogFile=null;
        logErrMsg(MessageService.getTextMessage(MessageId.LOG_CANNOT_CREATE_NEW,newLogFile.getPath()));
      }
    }
 catch (    IOException ioe) {
      inLogSwitch=false;
      logErrMsg(MessageService.getTextMessage(MessageId.LOG_CANNOT_CREATE_NEW_DUETO,newLogFile.getPath(),ioe.toString()));
      try {
        if (newLog != null) {
          newLog.close();
          newLog=null;
        }
      }
 catch (      IOException ioe2) {
      }
      if (newLogFile != null && privExists(newLogFile)) {
        privDelete(newLogFile);
        newLogFile=null;
      }
      if (switchedOver) {
        logOut=null;
        throw markCorrupt(StandardException.newException(SQLState.LOG_IO_ERROR,ioe));
      }
    }
    if (inReplicationSlaveMode) {
      allowedToReadFileNumber=logFileNumber - 1;
synchronized (slaveRecoveryMonitor) {
        slaveRecoveryMonitor.notify();
      }
    }
    inLogSwitch=false;
  }
}","/** 
 * Switch to the next log file if possible. <P>MT - log factory is single threaded thru a log file switch, the log is frozen for the duration of the switch
 */
public void switchLogFile() throws StandardException {
  boolean switchedOver=false;
synchronized (this) {
    while (logBeingFlushed | isFrozen) {
      try {
        wait();
      }
 catch (      InterruptedException ie) {
        InterruptStatus.setInterrupted();
      }
    }
    if (endPosition == LOG_FILE_HEADER_SIZE) {
      if (SanityManager.DEBUG) {
        Monitor.logMessage(""String_Node_Str"" + logFileNumber + ""String_Node_Str"");
      }
      return;
    }
    StorageFile newLogFile=getLogFileName(logFileNumber + 1);
    if (logFileNumber + 1 >= maxLogFileNumber) {
      throw StandardException.newException(SQLState.LOG_EXCEED_MAX_LOG_FILE_NUMBER,new Long(maxLogFileNumber));
    }
    StorageRandomAccessFile newLog=null;
    try {
      if (privExists(newLogFile) && !privDelete(newLogFile)) {
        logErrMsg(MessageService.getTextMessage(MessageId.LOG_NEW_LOGFILE_EXIST,newLogFile.getPath()));
        return;
      }
      try {
        newLog=privRandomAccessFile(newLogFile,""String_Node_Str"");
      }
 catch (      IOException ioe) {
        newLog=null;
      }
      if (newLog == null || !privCanWrite(newLogFile)) {
        if (newLog != null)         newLog.close();
        newLog=null;
        return;
      }
      if (initLogFile(newLog,logFileNumber + 1,LogCounter.makeLogInstantAsLong(logFileNumber,endPosition))) {
        switchedOver=true;
        logOut.writeEndMarker(0);
        endPosition+=4;
        inLogSwitch=true;
        flush(logFileNumber,endPosition);
        if (SanityManager.DEBUG) {
          if (SanityManager.DEBUG_ON(TEST_SWITCH_LOG_FAIL2))           throw new IOException(""String_Node_Str"");
        }
        logOut.close();
        logWrittenFromLastCheckPoint+=endPosition;
        endPosition=newLog.getFilePointer();
        lastFlush=endPosition;
        if (isWriteSynced) {
          preAllocateNewLogFile(newLog);
          newLog.close();
          newLog=openLogFileInWriteMode(newLogFile);
          newLog.seek(endPosition);
        }
        logOut=new LogAccessFile(this,newLog,logBufferSize);
        newLog=null;
        if (SanityManager.DEBUG) {
          if (endPosition != LOG_FILE_HEADER_SIZE)           SanityManager.THROWASSERT(""String_Node_Str"" + +endPosition);
        }
        logFileNumber++;
        if (SanityManager.DEBUG) {
          SanityManager.ASSERT(endPosition == LOG_FILE_HEADER_SIZE,""String_Node_Str"");
        }
      }
 else {
        newLog.close();
        newLog=null;
        if (privExists(newLogFile))         privDelete(newLogFile);
        logErrMsg(MessageService.getTextMessage(MessageId.LOG_CANNOT_CREATE_NEW,newLogFile.getPath()));
        newLogFile=null;
      }
    }
 catch (    IOException ioe) {
      inLogSwitch=false;
      logErrMsg(MessageService.getTextMessage(MessageId.LOG_CANNOT_CREATE_NEW_DUETO,newLogFile.getPath(),ioe.toString()));
      try {
        if (newLog != null) {
          newLog.close();
          newLog=null;
        }
      }
 catch (      IOException ioe2) {
      }
      if (newLogFile != null && privExists(newLogFile)) {
        privDelete(newLogFile);
        newLogFile=null;
      }
      if (switchedOver) {
        logOut=null;
        throw markCorrupt(StandardException.newException(SQLState.LOG_IO_ERROR,ioe));
      }
    }
    if (inReplicationSlaveMode) {
      allowedToReadFileNumber=logFileNumber - 1;
synchronized (slaveRecoveryMonitor) {
        slaveRecoveryMonitor.notify();
      }
    }
    inLogSwitch=false;
  }
}"
80043,"/** 
 * Adjust input text to remove junk which confuses the xml parser and/or Forrest. Temporarily writes the adjusted text to the output file.
 */
private void normalizeText(File inputFile,File outputFile) throws Exception {
  String rawString=readFileIntoString(inputFile);
  rawString=fullReplaceToken(rawString,""String_Node_Str"",""String_Node_Str"");
  rawString=fullReplaceToken(rawString,""String_Node_Str"",""String_Node_Str"");
  rawString.replace('[','(');
  rawString.replace(']',')');
  FileWriter fileWriter=new FileWriter(outputFile);
  fileWriter.append(rawString);
  fileWriter.flush();
  fileWriter.close();
}","/** 
 * Adjust input text to remove junk which confuses the xml parser and/or Forrest. Temporarily writes the adjusted text to the output file.
 */
private void normalizeText(File inputFile,File outputFile) throws Exception {
  String rawString=readFileIntoString(inputFile);
  rawString=fullReplaceToken(rawString,""String_Node_Str"",""String_Node_Str"");
  rawString=fullReplaceToken(rawString,""String_Node_Str"",""String_Node_Str"");
  rawString=rawString.replace('[','(');
  rawString=rawString.replace(']',')');
  FileWriter fileWriter=new FileWriter(outputFile);
  fileWriter.append(rawString);
  fileWriter.flush();
  fileWriter.close();
}"
80044,"public Driver getWrappedObject() throws SQLException {
  if (_embedded != null) {
    return _embedded;
  }
 else   if (_netclient != null) {
    return _netclient;
  }
 else {
    throw nothingWrapped();
  }
}","public Driver getWrappedObject() throws SQLException {
  if (_embedded != null) {
    return _embedded;
  }
 else   if (_driver40 != null) {
    return _driver40;
  }
 else   if (_netclient != null) {
    return _netclient;
  }
 else {
    throw nothingWrapped(null);
  }
}"
80045,"public Logger getParentLogger() throws SQLException {
  if (_embedded != null) {
    return _embedded.getParentLogger();
  }
 else   if (_netclient != null) {
    return _netclient.getParentLogger();
  }
 else {
    throw nothingWrapped();
  }
}","public Logger getParentLogger() throws SQLException {
  if (_embedded != null) {
    return _embedded.getParentLogger();
  }
 else   if (_driver40 != null) {
    return _driver40.getParentLogger();
  }
 else   if (_netclient != null) {
    return _netclient.getParentLogger();
  }
 else {
    throw nothingWrapped(null);
  }
}"
80046,"public Wrapper41Driver(Object wrapped) throws Exception {
  if (wrapped instanceof AutoloadedDriver40) {
    _embedded=(AutoloadedDriver40)wrapped;
  }
 else   if (wrapped instanceof ClientDriver40) {
    _netclient=(ClientDriver40)wrapped;
  }
 else {
    throw nothingWrapped();
  }
}","public Wrapper41Driver(Object wrapped) throws Exception {
  if (wrapped instanceof AutoloadedDriver40) {
    _embedded=(AutoloadedDriver40)wrapped;
  }
 else   if (wrapped instanceof Driver40) {
    _driver40=(Driver40)wrapped;
  }
 else   if (wrapped instanceof ClientDriver40) {
    _netclient=(ClientDriver40)wrapped;
  }
 else {
    throw nothingWrapped(wrapped);
  }
}"
80047,"private SQLException nothingWrapped(){
  return new SQLException(""String_Node_Str"");
}","private SQLException nothingWrapped(Object wrapped){
  String wrappedString=(wrapped == null ? ""String_Node_Str"" : wrapped.getClass().getName());
  return new SQLException(""String_Node_Str"" + wrappedString);
}"
80048,"/** 
 * Return the length of a timestamp depending on whether timestamps should have full nanosecond precision or be truncated to just microseconds. java.sql.Timestamp is converted to a character representation which is a DERBY string  representation of a timestamp converted to bytes using UTF8 encoding. For Derby 10.6 and above, this is <code>yyyy-mm-dd-hh.mm.ss.fffffffff</code>. For Derby 10.5 and below, this is <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>. See DERBY-2602. and then converted to bytes using UTF8 encoding
 * @param supportsTimestampNanoseconds true if the connection supports nanoseconds in timestamps
 */
public static int getTimestampLength(boolean supportsTimestampNanoseconds){
  return supportsTimestampNanoseconds ? DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_TIMESTAMP_LENGTH;
}","/** 
 * Return the length of a timestamp depending on whether timestamps should have full nanosecond precision or be truncated to just microseconds. java.sql.Timestamp is converted to a character representation which is a DERBY string  representation of a timestamp converted to bytes using UTF8 encoding. For Derby 10.6 and above, this is <code>yyyy-mm-dd-hh.mm.ss.fffffffff</code>. For Derby 10.5 and below, this is <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>. See DERBY-2602. and then converted to bytes using UTF8 encoding
 * @param supportsTimestampNanoseconds true if the connection supports nanoseconds in timestamps
 */
public static int getTimestampLength(boolean supportsTimestampNanoseconds){
  return supportsTimestampNanoseconds ? DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_OLD_TIMESTAMP_LENGTH;
}"
80049,"/** 
 * The timestamp length may be truncated for old versions of Derby. See DERBY-2602.
 */
protected int getTimestampLength(){
  return supportsTimestampNanoseconds() ? DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_TIMESTAMP_LENGTH;
}","/** 
 * The timestamp length may be truncated for old versions of Derby. See DERBY-2602.
 */
protected int getTimestampLength(){
  return supportsTimestampNanoseconds() ? DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_OLD_TIMESTAMP_LENGTH;
}"
80050,"final byte getByte(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getByteFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return agent_.crossConverters_.getByteFromShort(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return agent_.crossConverters_.getByteFromInt(get_INTEGER(column));
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getByteFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getByteFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getByteFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getByteFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getByteFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getByteFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final byte getByte(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getByteFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return agent_.crossConverters_.getByteFromShort(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return agent_.crossConverters_.getByteFromInt(get_INTEGER(column));
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getByteFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getByteFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getByteFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getByteFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getByteFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getByteFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80051,"final java.math.BigDecimal getBigDecimal(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return java.math.BigDecimal.valueOf(getLong(column));
case java.sql.Types.DECIMAL:
  return get_DECIMAL(column);
case java.sql.Types.REAL:
float f=get_FLOAT(column);
return new java.math.BigDecimal(String.valueOf(f));
case java.sql.Types.DOUBLE:
return new java.math.BigDecimal(String.valueOf(get_DOUBLE(column)));
case java.sql.Types.SMALLINT:
return java.math.BigDecimal.valueOf(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return java.math.BigDecimal.valueOf(get_INTEGER(column));
case java.sql.Types.BIGINT:
return java.math.BigDecimal.valueOf(get_BIGINT(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getBigDecimalFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getBigDecimalFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final java.math.BigDecimal getBigDecimal(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return java.math.BigDecimal.valueOf(getLong(column));
case java.sql.Types.DECIMAL:
  return get_DECIMAL(column);
case java.sql.Types.REAL:
float f=get_FLOAT(column);
return new java.math.BigDecimal(String.valueOf(f));
case java.sql.Types.DOUBLE:
return new java.math.BigDecimal(String.valueOf(get_DOUBLE(column)));
case java.sql.Types.SMALLINT:
return java.math.BigDecimal.valueOf(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return java.math.BigDecimal.valueOf(get_INTEGER(column));
case java.sql.Types.BIGINT:
return java.math.BigDecimal.valueOf(get_BIGINT(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getBigDecimalFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getBigDecimalFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80052,"public final java.sql.Clob getClob(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case Types.CLOB:
    return getClobColumn_(column,agent_,true);
default :
  throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","public final java.sql.Clob getClob(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case Types.CLOB:
    return getClobColumn_(column,agent_,true);
default :
  throw coercionError(""String_Node_Str"",column);
}
}"
80053,"public final java.io.InputStream getAsciiStream(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.CLOB:
    Clob c=getClobColumn_(column,agent_,false);
  if (c.isLocator()) {
    ClobLocatorInputStream is=new ClobLocatorInputStream(agent_.connection_,c);
    return new BufferedInputStream(is);
  }
 else {
    return c.getAsciiStreamX();
  }
case java.sql.Types.CHAR:
try {
  return new java.io.ByteArrayInputStream(getCHAR(column).getBytes(""String_Node_Str""));
}
 catch (java.io.UnsupportedEncodingException e) {
  throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
try {
return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes(""String_Node_Str""));
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.BINARY:
return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
case java.sql.Types.BLOB:
return getBinaryStream(column);
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","public final java.io.InputStream getAsciiStream(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.CLOB:
    Clob c=getClobColumn_(column,agent_,false);
  if (c.isLocator()) {
    ClobLocatorInputStream is=new ClobLocatorInputStream(agent_.connection_,c);
    return new BufferedInputStream(is);
  }
 else {
    return c.getAsciiStreamX();
  }
case java.sql.Types.CHAR:
try {
  return new java.io.ByteArrayInputStream(getCHAR(column).getBytes(""String_Node_Str""));
}
 catch (java.io.UnsupportedEncodingException e) {
  throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
try {
return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes(""String_Node_Str""));
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.BINARY:
return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
case java.sql.Types.BLOB:
return getBinaryStream(column);
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80054,"final byte[] getBytes(int column) throws SqlException {
  try {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BINARY:
      return get_CHAR_FOR_BIT_DATA(column);
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
    return get_VARCHAR_FOR_BIT_DATA(column);
case java.sql.Types.BLOB:
  Blob b=getBlobColumn_(column,agent_,false);
byte[] bytes=b.getBytes(1,(int)b.length());
return bytes;
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}
 catch (SQLException se) {
throw new SqlException(se);
}
}","final byte[] getBytes(int column) throws SqlException {
  try {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BINARY:
      return get_CHAR_FOR_BIT_DATA(column);
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
    return get_VARCHAR_FOR_BIT_DATA(column);
case java.sql.Types.BLOB:
  Blob b=getBlobColumn_(column,agent_,false);
byte[] bytes=b.getBytes(1,(int)b.length());
return bytes;
default :
throw coercionError(""String_Node_Str"",column);
}
}
 catch (SQLException se) {
throw new SqlException(se);
}
}"
80055,"public final Object getObject(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return new Boolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return new Integer(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return new Integer(get_INTEGER(column));
case java.sql.Types.BIGINT:
return new Long(get_BIGINT(column));
case java.sql.Types.REAL:
return new Float(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return new Double(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return get_DECIMAL(column);
case java.sql.Types.DATE:
return getDATE(column,getRecyclableCalendar());
case java.sql.Types.TIME:
return getTIME(column,getRecyclableCalendar());
case java.sql.Types.TIMESTAMP:
return getTIMESTAMP(column,getRecyclableCalendar());
case java.sql.Types.CHAR:
return getCHAR(column);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return getVARCHAR(column);
case Types.BINARY:
return get_CHAR_FOR_BIT_DATA(column);
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
return get_VARCHAR_FOR_BIT_DATA(column);
case java.sql.Types.JAVA_OBJECT:
return get_UDT(column);
case java.sql.Types.BLOB:
return getBlobColumn_(column,agent_,true);
case java.sql.Types.CLOB:
return getClobColumn_(column,agent_,true);
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","public final Object getObject(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return new Boolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return new Integer(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return new Integer(get_INTEGER(column));
case java.sql.Types.BIGINT:
return new Long(get_BIGINT(column));
case java.sql.Types.REAL:
return new Float(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return new Double(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return get_DECIMAL(column);
case java.sql.Types.DATE:
return getDATE(column,getRecyclableCalendar());
case java.sql.Types.TIME:
return getTIME(column,getRecyclableCalendar());
case java.sql.Types.TIMESTAMP:
return getTIMESTAMP(column,getRecyclableCalendar());
case java.sql.Types.CHAR:
return getCHAR(column);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return getVARCHAR(column);
case Types.BINARY:
return get_CHAR_FOR_BIT_DATA(column);
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
return get_VARCHAR_FOR_BIT_DATA(column);
case java.sql.Types.JAVA_OBJECT:
return get_UDT(column);
case java.sql.Types.BLOB:
return getBlobColumn_(column,agent_,true);
case java.sql.Types.CLOB:
return getClobColumn_(column,agent_,true);
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80056,"final int getInt(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getIntFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return (int)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return get_INTEGER(column);
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getIntFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getIntFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getIntFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getIntFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getIntFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getIntFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final int getInt(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getIntFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return (int)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return get_INTEGER(column);
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getIntFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getIntFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getIntFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getIntFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getIntFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getIntFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80057,"final java.sql.Time getTime(int column,Calendar cal) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.TIME:
    return getTIME(column,cal);
case java.sql.Types.TIMESTAMP:
  return getTimeFromTIMESTAMP(column,cal);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getTimeFromString(getCHAR(column),cal);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getTimeFromString(getVARCHAR(column),cal);
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final java.sql.Time getTime(int column,Calendar cal) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.TIME:
    return getTIME(column,cal);
case java.sql.Types.TIMESTAMP:
  return getTimeFromTIMESTAMP(column,cal);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getTimeFromString(getCHAR(column),cal);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getTimeFromString(getVARCHAR(column),cal);
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80058,"public final java.io.InputStream getBinaryStream(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BINARY:
    return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
  return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
case java.sql.Types.BLOB:
Blob b=getBlobColumn_(column,agent_,false);
if (b.isLocator()) {
BlobLocatorInputStream is=new BlobLocatorInputStream(agent_.connection_,b);
return new BufferedInputStream(is);
}
 else {
return b.getBinaryStreamX();
}
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","public final java.io.InputStream getBinaryStream(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BINARY:
    return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
  return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
case java.sql.Types.BLOB:
Blob b=getBlobColumn_(column,agent_,false);
if (b.isLocator()) {
BlobLocatorInputStream is=new BlobLocatorInputStream(agent_.connection_,b);
return new BufferedInputStream(is);
}
 else {
return b.getBinaryStreamX();
}
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80059,"final double getDouble(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getDoubleFromBoolean(get_BOOLEAN(column));
case java.sql.Types.REAL:
  double d=(double)get_FLOAT(column);
return d;
case java.sql.Types.DOUBLE:
return get_DOUBLE(column);
case java.sql.Types.DECIMAL:
return getDoubleFromDECIMAL(column);
case java.sql.Types.SMALLINT:
return (double)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return (double)get_INTEGER(column);
case java.sql.Types.BIGINT:
return (double)get_BIGINT(column);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getDoubleFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getDoubleFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final double getDouble(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getDoubleFromBoolean(get_BOOLEAN(column));
case java.sql.Types.REAL:
  double d=(double)get_FLOAT(column);
return d;
case java.sql.Types.DOUBLE:
return get_DOUBLE(column);
case java.sql.Types.DECIMAL:
return getDoubleFromDECIMAL(column);
case java.sql.Types.SMALLINT:
return (double)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return (double)get_INTEGER(column);
case java.sql.Types.BIGINT:
return (double)get_BIGINT(column);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getDoubleFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getDoubleFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80060,"final float getFloat(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getFloatFromBoolean(get_BOOLEAN(column));
case java.sql.Types.REAL:
  return get_FLOAT(column);
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getFloatFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getFloatFromDouble(getDoubleFromDECIMAL(column));
case java.sql.Types.SMALLINT:
return (float)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return (float)get_INTEGER(column);
case java.sql.Types.BIGINT:
return (float)get_BIGINT(column);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getFloatFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getFloatFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final float getFloat(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getFloatFromBoolean(get_BOOLEAN(column));
case java.sql.Types.REAL:
  return get_FLOAT(column);
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getFloatFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getFloatFromDouble(getDoubleFromDECIMAL(column));
case java.sql.Types.SMALLINT:
return (float)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return (float)get_INTEGER(column);
case java.sql.Types.BIGINT:
return (float)get_BIGINT(column);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getFloatFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getFloatFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80061,"final java.sql.Timestamp getTimestamp(int column,Calendar cal) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.TIMESTAMP:
    return getTIMESTAMP(column,cal);
case java.sql.Types.DATE:
  return getTimestampFromDATE(column,cal);
case java.sql.Types.TIME:
return getTimestampFromTIME(column,cal);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getTimestampFromString(getCHAR(column),cal);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getTimestampFromString(getVARCHAR(column),cal);
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final java.sql.Timestamp getTimestamp(int column,Calendar cal) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.TIMESTAMP:
    return getTIMESTAMP(column,cal);
case java.sql.Types.DATE:
  return getTimestampFromDATE(column,cal);
case java.sql.Types.TIME:
return getTimestampFromTIME(column,cal);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getTimestampFromString(getCHAR(column),cal);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getTimestampFromString(getVARCHAR(column),cal);
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80062,"final boolean getBoolean(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return get_BOOLEAN(column);
case java.sql.Types.SMALLINT:
  return agent_.crossConverters_.getBooleanFromShort(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return agent_.crossConverters_.getBooleanFromInt(get_INTEGER(column));
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getBooleanFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getBooleanFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getBooleanFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getBooleanFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getBooleanFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getBooleanFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final boolean getBoolean(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return get_BOOLEAN(column);
case java.sql.Types.SMALLINT:
  return agent_.crossConverters_.getBooleanFromShort(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return agent_.crossConverters_.getBooleanFromInt(get_INTEGER(column));
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getBooleanFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getBooleanFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getBooleanFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getBooleanFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getBooleanFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getBooleanFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80063,"final java.sql.Date getDate(int column,Calendar cal) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.DATE:
    return getDATE(column,cal);
case java.sql.Types.TIMESTAMP:
  return getDateFromTIMESTAMP(column,cal);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getDateFromString(getCHAR(column),cal);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getDateFromString(getVARCHAR(column),cal);
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final java.sql.Date getDate(int column,Calendar cal) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.DATE:
    return getDATE(column,cal);
case java.sql.Types.TIMESTAMP:
  return getDateFromTIMESTAMP(column,cal);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getDateFromString(getCHAR(column),cal);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getDateFromString(getVARCHAR(column),cal);
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80064,"final short getShort(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getShortFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return get_SMALLINT(column);
case java.sql.Types.INTEGER:
return agent_.crossConverters_.getShortFromInt(get_INTEGER(column));
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getShortFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getShortFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getShortFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getShortFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getShortFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getShortFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final short getShort(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getShortFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return get_SMALLINT(column);
case java.sql.Types.INTEGER:
return agent_.crossConverters_.getShortFromInt(get_INTEGER(column));
case java.sql.Types.BIGINT:
return agent_.crossConverters_.getShortFromLong(get_BIGINT(column));
case java.sql.Types.REAL:
return agent_.crossConverters_.getShortFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getShortFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return agent_.crossConverters_.getShortFromLong(getLongFromDECIMAL(column));
case java.sql.Types.CHAR:
return agent_.crossConverters_.getShortFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getShortFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80065,"final String getString(int column) throws SqlException {
  try {
    String tempString=null;
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
      if (get_BOOLEAN(column)) {
        return Boolean.TRUE.toString();
      }
 else {
        return Boolean.FALSE.toString();
      }
case java.sql.Types.CHAR:
    return getCHAR(column);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
  return getVARCHAR(column);
case java.sql.Types.SMALLINT:
return String.valueOf(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return String.valueOf(get_INTEGER(column));
case java.sql.Types.BIGINT:
return String.valueOf(get_BIGINT(column));
case java.sql.Types.REAL:
return String.valueOf(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return String.valueOf(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return String.valueOf(get_DECIMAL(column));
case java.sql.Types.DATE:
return getStringFromDATE(column);
case java.sql.Types.TIME:
return getStringFromTIME(column);
case java.sql.Types.TIMESTAMP:
return getStringFromTIMESTAMP(column);
case Types.BINARY:
tempString=agent_.crossConverters_.getStringFromBytes(get_CHAR_FOR_BIT_DATA(column));
return (maxFieldSize_ == 0) ? tempString : tempString.substring(0,java.lang.Math.min(maxFieldSize_,tempString.length()));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
tempString=agent_.crossConverters_.getStringFromBytes(get_VARCHAR_FOR_BIT_DATA(column));
return (maxFieldSize_ == 0) ? tempString : tempString.substring(0,java.lang.Math.min(maxFieldSize_,tempString.length()));
case java.sql.Types.JAVA_OBJECT:
Object obj=get_UDT(column);
if (obj == null) {
return null;
}
 else {
return obj.toString();
}
case java.sql.Types.BLOB:
Blob b=getBlobColumn_(column,agent_,false);
tempString=agent_.crossConverters_.getStringFromBytes(b.getBytes(1,(int)b.length()));
return tempString;
case java.sql.Types.CLOB:
Clob c=getClobColumn_(column,agent_,false);
tempString=c.getSubString(1,(int)c.length());
return tempString;
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}
 catch (SQLException se) {
throw new SqlException(se);
}
}","final String getString(int column) throws SqlException {
  try {
    String tempString=null;
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
      if (get_BOOLEAN(column)) {
        return Boolean.TRUE.toString();
      }
 else {
        return Boolean.FALSE.toString();
      }
case java.sql.Types.CHAR:
    return getCHAR(column);
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
  return getVARCHAR(column);
case java.sql.Types.SMALLINT:
return String.valueOf(get_SMALLINT(column));
case java.sql.Types.INTEGER:
return String.valueOf(get_INTEGER(column));
case java.sql.Types.BIGINT:
return String.valueOf(get_BIGINT(column));
case java.sql.Types.REAL:
return String.valueOf(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return String.valueOf(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return String.valueOf(get_DECIMAL(column));
case java.sql.Types.DATE:
return getStringFromDATE(column);
case java.sql.Types.TIME:
return getStringFromTIME(column);
case java.sql.Types.TIMESTAMP:
return getStringFromTIMESTAMP(column);
case Types.BINARY:
tempString=agent_.crossConverters_.getStringFromBytes(get_CHAR_FOR_BIT_DATA(column));
return (maxFieldSize_ == 0) ? tempString : tempString.substring(0,java.lang.Math.min(maxFieldSize_,tempString.length()));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
tempString=agent_.crossConverters_.getStringFromBytes(get_VARCHAR_FOR_BIT_DATA(column));
return (maxFieldSize_ == 0) ? tempString : tempString.substring(0,java.lang.Math.min(maxFieldSize_,tempString.length()));
case java.sql.Types.JAVA_OBJECT:
Object obj=get_UDT(column);
if (obj == null) {
return null;
}
 else {
return obj.toString();
}
case java.sql.Types.BLOB:
Blob b=getBlobColumn_(column,agent_,false);
tempString=agent_.crossConverters_.getStringFromBytes(b.getBytes(1,(int)b.length()));
return tempString;
case java.sql.Types.CLOB:
Clob c=getClobColumn_(column,agent_,false);
tempString=c.getSubString(1,(int)c.length());
return tempString;
default :
throw coercionError(""String_Node_Str"",column);
}
}
 catch (SQLException se) {
throw new SqlException(se);
}
}"
80066,"public final java.io.Reader getCharacterStream(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.CLOB:
    Clob c=getClobColumn_(column,agent_,false);
  if (c.isLocator()) {
    ClobLocatorReader reader=new ClobLocatorReader(agent_.connection_,c);
    return new BufferedReader(reader);
  }
 else {
    return c.getCharacterStreamX();
  }
case java.sql.Types.CHAR:
return new java.io.StringReader(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return new java.io.StringReader(getVARCHAR(column));
case java.sql.Types.BINARY:
try {
return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column)),""String_Node_Str"");
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
try {
return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column)),""String_Node_Str"");
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.BLOB:
try {
return new java.io.InputStreamReader(getBinaryStream(column),""String_Node_Str"");
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","public final java.io.Reader getCharacterStream(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.CLOB:
    Clob c=getClobColumn_(column,agent_,false);
  if (c.isLocator()) {
    ClobLocatorReader reader=new ClobLocatorReader(agent_.connection_,c);
    return new BufferedReader(reader);
  }
 else {
    return c.getCharacterStreamX();
  }
case java.sql.Types.CHAR:
return new java.io.StringReader(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return new java.io.StringReader(getVARCHAR(column));
case java.sql.Types.BINARY:
try {
return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column)),""String_Node_Str"");
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
try {
return new java.io.InputStreamReader(new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column)),""String_Node_Str"");
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
case java.sql.Types.BLOB:
try {
return new java.io.InputStreamReader(getBinaryStream(column),""String_Node_Str"");
}
 catch (java.io.UnsupportedEncodingException e) {
throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
}
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80067,"public final java.sql.Blob getBlob(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case Types.BLOB:
    return getBlobColumn_(column,agent_,true);
default :
  throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","public final java.sql.Blob getBlob(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case Types.BLOB:
    return getBlobColumn_(column,agent_,true);
default :
  throw coercionError(""String_Node_Str"",column);
}
}"
80068,"final long getLong(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getLongFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return (long)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return (long)get_INTEGER(column);
case java.sql.Types.BIGINT:
return get_BIGINT(column);
case java.sql.Types.REAL:
return agent_.crossConverters_.getLongFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getLongFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return getLongFromDECIMAL(column);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getLongFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getLongFromString(getVARCHAR(column));
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}","final long getLong(int column) throws SqlException {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.BOOLEAN:
    return agent_.crossConverters_.getLongFromBoolean(get_BOOLEAN(column));
case java.sql.Types.SMALLINT:
  return (long)get_SMALLINT(column);
case java.sql.Types.INTEGER:
return (long)get_INTEGER(column);
case java.sql.Types.BIGINT:
return get_BIGINT(column);
case java.sql.Types.REAL:
return agent_.crossConverters_.getLongFromFloat(get_FLOAT(column));
case java.sql.Types.DOUBLE:
return agent_.crossConverters_.getLongFromDouble(get_DOUBLE(column));
case java.sql.Types.DECIMAL:
return getLongFromDECIMAL(column);
case java.sql.Types.CHAR:
return agent_.crossConverters_.getLongFromString(getCHAR(column));
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
return agent_.crossConverters_.getLongFromString(getVARCHAR(column));
default :
throw coercionError(""String_Node_Str"",column);
}
}"
80069,"public final java.io.InputStream getUnicodeStream(int column) throws SqlException {
  try {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.CLOB:
{
        Clob c=getClobColumn_(column,agent_,false);
        String s=c.getSubString(1L,(int)c.length());
        try {
          return new java.io.ByteArrayInputStream(s.getBytes(""String_Node_Str""));
        }
 catch (        java.io.UnsupportedEncodingException e) {
          throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
        }
      }
case java.sql.Types.CHAR:
{
      try {
        return new java.io.ByteArrayInputStream(getCHAR(column).getBytes(""String_Node_Str""));
      }
 catch (      java.io.UnsupportedEncodingException e) {
        throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
      }
    }
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
  try {
    return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes(""String_Node_Str""));
  }
 catch (  java.io.UnsupportedEncodingException e) {
    throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
  }
case java.sql.Types.BINARY:
return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
case java.sql.Types.BLOB:
return getBinaryStream(column);
default :
throw new ColumnTypeConversionException(agent_.logWriter_,""String_Node_Str"" + jdbcTypes_[column - 1],""String_Node_Str"");
}
}
 catch (SQLException se) {
throw new SqlException(se);
}
}","public final java.io.InputStream getUnicodeStream(int column) throws SqlException {
  try {
switch (jdbcTypes_[column - 1]) {
case java.sql.Types.CLOB:
{
        Clob c=getClobColumn_(column,agent_,false);
        String s=c.getSubString(1L,(int)c.length());
        try {
          return new java.io.ByteArrayInputStream(s.getBytes(""String_Node_Str""));
        }
 catch (        java.io.UnsupportedEncodingException e) {
          throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
        }
      }
case java.sql.Types.CHAR:
{
      try {
        return new java.io.ByteArrayInputStream(getCHAR(column).getBytes(""String_Node_Str""));
      }
 catch (      java.io.UnsupportedEncodingException e) {
        throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
      }
    }
case java.sql.Types.VARCHAR:
case java.sql.Types.LONGVARCHAR:
  try {
    return new java.io.ByteArrayInputStream(getVARCHAR(column).getBytes(""String_Node_Str""));
  }
 catch (  java.io.UnsupportedEncodingException e) {
    throw new SqlException(agent_.logWriter_,new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),""String_Node_Str"",""String_Node_Str"",e);
  }
case java.sql.Types.BINARY:
return new java.io.ByteArrayInputStream(get_CHAR_FOR_BIT_DATA(column));
case java.sql.Types.VARBINARY:
case java.sql.Types.LONGVARBINARY:
return new java.io.ByteArrayInputStream(get_VARCHAR_FOR_BIT_DATA(column));
case java.sql.Types.BLOB:
return getBinaryStream(column);
default :
throw coercionError(""String_Node_Str"",column);
}
}
 catch (SQLException se) {
throw new SqlException(se);
}
}"
80070,"ColumnTypeConversionException(LogWriter logWriter,String sourceType,String targetType){
  super(logWriter,new ClientMessageId(SQLState.LANG_DATA_TYPE_GET_MISMATCH),sourceType,targetType);
}","ColumnTypeConversionException(LogWriter logWriter,String targetType,String sourceType){
  super(logWriter,new ClientMessageId(SQLState.LANG_DATA_TYPE_GET_MISMATCH),targetType,sourceType);
}"
80071,"/** 
 * Computes the RowLocation in SYSSEQUENCES for a particular sequence. Also constructs the sequence descriptor.
 * @param tc			Transaction Controller to use.
 * @param sequenceIDstring UUID of the sequence as a string
 * @param rowLocation OUTPUT param for returing the row location
 * @param sequenceDescriptor OUTPUT param for return the sequence descriptor
 * @return The RowLocation of that sequence in SYSSEQUENCES
 * @exception StandardException thrown on failure.
 */
void computeSequenceRowLocation(TransactionController tc,String sequenceIDstring,RowLocation[] rowLocation,SequenceDescriptor[] sequenceDescriptor) throws StandardException {
  TabInfoImpl ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM);
  ExecIndexRow keyRow=null;
  ExecRow row;
  keyRow=(ExecIndexRow)exFactory.getIndexableRow(1);
  keyRow.setColumn(1,new SQLChar(sequenceIDstring));
  rowLocation[0]=ti.getRowLocation(tc,keyRow,SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID);
  sequenceDescriptor[0]=(SequenceDescriptor)getDescriptorViaIndexMinion(SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List)null,false,TransactionController.ISOLATION_REPEATABLE_READ,tc);
}","/** 
 * Computes the RowLocation in SYSSEQUENCES for a particular sequence. Also constructs the sequence descriptor.
 * @param tc			Transaction Controller to use.
 * @param sequenceIDstring UUID of the sequence as a string
 * @param rowLocation OUTPUT param for returing the row location
 * @param sequenceDescriptor OUTPUT param for return the sequence descriptor
 * @exception StandardException thrown on failure.
 */
void computeSequenceRowLocation(TransactionController tc,String sequenceIDstring,RowLocation[] rowLocation,SequenceDescriptor[] sequenceDescriptor) throws StandardException {
  TabInfoImpl ti=getNonCoreTI(SYSSEQUENCES_CATALOG_NUM);
  ExecIndexRow keyRow=null;
  ExecRow row;
  keyRow=(ExecIndexRow)exFactory.getIndexableRow(1);
  keyRow.setColumn(1,new SQLChar(sequenceIDstring));
  rowLocation[0]=ti.getRowLocation(tc,keyRow,SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID);
  sequenceDescriptor[0]=(SequenceDescriptor)getDescriptorViaIndexMinion(SYSSEQUENCESRowFactory.SYSSEQUENCES_INDEX1_ID,keyRow,(ScanQualifier[][])null,ti,(TupleDescriptor)null,(List)null,false,TransactionController.ISOLATION_REPEATABLE_READ,tc);
}"
80072,"/** 
 * Do code generation for this method call
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
public void generateExpression(ExpressionClassBuilder acb,MethodBuilder mb) throws StandardException {
  if (routineInfo != null) {
    if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)     returnsNullOnNullState=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
  }
  if (returnsNullOnNullState != null) {
    mb.push(false);
    mb.setField(returnsNullOnNullState);
    mb.pushThis();
  }
  int nargs=generateParameters(acb,mb);
  LocalField functionEntrySQLAllowed=null;
  if (routineInfo != null) {
    short sqlAllowed=routineInfo.getSQLAllowed();
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      int sqlOperation;
      if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)       sqlOperation=Authorizer.SQL_SELECT_OP;
 else       if (sqlAllowed == RoutineAliasInfo.MODIFIES_SQL_DATA)       sqlOperation=Authorizer.SQL_WRITE_OP;
 else       sqlOperation=Authorizer.SQL_ARBITARY_OP;
      generateAuthorizeCheck((ActivationClassBuilder)acb,mb,sqlOperation);
    }
    int statmentContextReferences=isSystemCode ? 2 : 1;
    boolean isFunction=routineInfo.getReturnType() != null;
    if (isFunction)     statmentContextReferences++;
    if (statmentContextReferences != 0) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      for (int scc=1; scc < statmentContextReferences; scc++)       mb.dup();
    }
    if (isSystemCode) {
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
    }
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      generateSetupNestedSessionContext((ActivationClassBuilder)acb,mb);
    }
    if (isFunction) {
      functionEntrySQLAllowed=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.setField(functionEntrySQLAllowed);
    }
    mb.push(sqlAllowed);
    mb.push(false);
    mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
  }
  if (routineInfo != null) {
    int compiledResultSets=methodParameterTypes.length - methodParms.length;
    if (compiledResultSets != 0) {
      int maxDynamicResults=routineInfo.getMaxDynamicResultSets();
      if (maxDynamicResults > 0) {
        MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
        gdr.push(maxDynamicResults);
        gdr.methodReturn();
        gdr.complete();
      }
      MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
      MethodBuilder cons=acb.getConstructor();
{
        LocalField procedureResultSetsHolder=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
        gdr.getField(procedureResultSetsHolder);
        cons.pushNewArray(""String_Node_Str"",compiledResultSets);
        cons.setField(procedureResultSetsHolder);
        for (int i=0; i < compiledResultSets; i++) {
          mb.pushNewArray(""String_Node_Str"",1);
          mb.dup();
          mb.getField(procedureResultSetsHolder);
          mb.swap();
          mb.setArrayElement(i);
        }
      }
      gdr.methodReturn();
      gdr.complete();
      nargs+=compiledResultSets;
    }
  }
  String javaReturnType=getJavaTypeName();
  MethodBuilder mbnc=null;
  MethodBuilder mbcm=mb;
  if (returnsNullOnNullState != null) {
    mbnc=acb.newGeneratedFun(javaReturnType,Modifier.PRIVATE,methodParameterTypes);
    Class[] throwsSet=((java.lang.reflect.Method)method).getExceptionTypes();
    for (int te=0; te < throwsSet.length; te++) {
      mbnc.addThrownException(throwsSet[te].getName());
    }
    mbnc.getField(returnsNullOnNullState);
    mbnc.conditionalIf();
    mbnc.pushNull(javaReturnType);
    mbnc.startElseCode();
    if (!actualMethodReturnType.equals(javaReturnType))     mbnc.pushNewStart(javaReturnType);
    for (int pa=0; pa < nargs; pa++) {
      mbnc.getParameter(pa);
    }
    mbcm=mbnc;
  }
  mbcm.callMethod(VMOpcode.INVOKESTATIC,method.getDeclaringClass().getName(),methodName,actualMethodReturnType,nargs);
  if (returnsNullOnNullState != null) {
    if (!actualMethodReturnType.equals(javaReturnType)) {
      if (actualMethodReturnType.equals(""String_Node_Str"") && javaReturnType.equals(""String_Node_Str""))       mbnc.upCast(""String_Node_Str"");
      mbnc.pushNewComplete(1);
    }
    mbnc.completeConditional();
    mbnc.methodReturn();
    mbnc.complete();
    mb.callMethod(VMOpcode.INVOKEVIRTUAL,acb.getClassBuilder().getFullName(),mbnc.getName(),javaReturnType,nargs);
    mbnc=null;
  }
  if (routineInfo != null) {
    if (functionEntrySQLAllowed != null) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.getField(functionEntrySQLAllowed);
      mb.push(true);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
    }
    if (outParamArrays != null) {
      MethodBuilder constructor=acb.getConstructor();
      acb.pushThisAsActivation(constructor);
      constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      int[] parameterModes=routineInfo.getParameterModes();
      for (int i=0; i < outParamArrays.length; i++) {
        int parameterMode=parameterModes[i];
        if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
          ValueNode sqlParamNode=((SQLToJavaValueNode)methodParms[i]).getSQLValueNode();
          int applicationParameterNumber=applicationParameterNumbers[i];
          constructor.dup();
          constructor.push(applicationParameterNumber);
          constructor.push(parameterMode);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
          LocalField lf=outParamArrays[i];
          mb.dup();
          mb.push(applicationParameterNumber);
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.DataValueDescriptor,1);
          DataTypeDescriptor paramdtd=sqlParamNode.getTypeServices();
          boolean isNumericType=paramdtd.getTypeId().isNumericTypeId();
          boolean isPrimitive=((java.lang.reflect.Method)method).getParameterTypes()[i].getComponentType().isPrimitive();
          if (isNumericType) {
            if (!isPrimitive)             mb.cast(ClassName.NumberDataValue);
          }
 else           if (paramdtd.getTypeId().isBooleanTypeId()) {
            if (!isPrimitive)             mb.cast(ClassName.BooleanDataValue);
          }
          if (paramdtd.getTypeId().variableLength()) {
            mb.dup();
          }
          mb.getField(lf);
          mb.getArrayElement(0);
          if (isNumericType && !isPrimitive) {
            mb.upCast(""String_Node_Str"");
          }
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",1);
          if (paramdtd.getTypeId().variableLength()) {
            mb.push(isNumericType ? paramdtd.getPrecision() : paramdtd.getMaximumWidth());
            mb.push(paramdtd.getScale());
            mb.push(isNumericType);
            mb.callMethod(VMOpcode.INVOKEINTERFACE,ClassName.VariableSizeDataValue,""String_Node_Str"",""String_Node_Str"",3);
          }
        }
      }
      constructor.endStatement();
      mb.endStatement();
    }
  }
}","/** 
 * Do code generation for this method call
 * @param acb	The ExpressionClassBuilder for the class we're generating
 * @param mb	The method the expression will go into
 * @exception StandardException		Thrown on error
 */
public void generateExpression(ExpressionClassBuilder acb,MethodBuilder mb) throws StandardException {
  if (routineInfo != null) {
    if (!routineInfo.calledOnNullInput() && routineInfo.getParameterCount() != 0)     returnsNullOnNullState=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
  }
  if (returnsNullOnNullState != null) {
    mb.push(false);
    mb.setField(returnsNullOnNullState);
    mb.pushThis();
  }
  int nargs=generateParameters(acb,mb);
  LocalField functionEntrySQLAllowed=null;
  if (routineInfo != null) {
    short sqlAllowed=routineInfo.getSQLAllowed();
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      int sqlOperation;
      if (sqlAllowed == RoutineAliasInfo.READS_SQL_DATA)       sqlOperation=Authorizer.SQL_SELECT_OP;
 else       if (sqlAllowed == RoutineAliasInfo.MODIFIES_SQL_DATA)       sqlOperation=Authorizer.SQL_WRITE_OP;
 else       sqlOperation=Authorizer.SQL_ARBITARY_OP;
      generateAuthorizeCheck((ActivationClassBuilder)acb,mb,sqlOperation);
    }
    int statmentContextReferences=isSystemCode ? 2 : 1;
    boolean isFunction=routineInfo.getReturnType() != null;
    if (isFunction)     statmentContextReferences++;
    if (statmentContextReferences != 0) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      for (int scc=1; scc < statmentContextReferences; scc++)       mb.dup();
    }
    if (isSystemCode) {
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
    }
    if (sqlAllowed != RoutineAliasInfo.NO_SQL) {
      generateSetupNestedSessionContext((ActivationClassBuilder)acb,mb);
    }
    if (isFunction) {
      functionEntrySQLAllowed=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.setField(functionEntrySQLAllowed);
    }
    mb.push(sqlAllowed);
    mb.push(false);
    mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
  }
  if (routineInfo != null) {
    int compiledResultSets=methodParameterTypes.length - methodParms.length;
    if (compiledResultSets != 0) {
      int maxDynamicResults=routineInfo.getMaxDynamicResultSets();
      if (maxDynamicResults > 0) {
        MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
        gdr.push(maxDynamicResults);
        gdr.methodReturn();
        gdr.complete();
      }
      MethodBuilder gdr=acb.getClassBuilder().newMethodBuilder(Modifier.PUBLIC,""String_Node_Str"",""String_Node_Str"");
      MethodBuilder cons=acb.getConstructor();
{
        LocalField procedureResultSetsHolder=acb.newFieldDeclaration(Modifier.PRIVATE,""String_Node_Str"");
        gdr.getField(procedureResultSetsHolder);
        cons.pushNewArray(""String_Node_Str"",compiledResultSets);
        cons.setField(procedureResultSetsHolder);
        for (int i=0; i < compiledResultSets; i++) {
          mb.pushNewArray(""String_Node_Str"",1);
          mb.dup();
          mb.getField(procedureResultSetsHolder);
          mb.swap();
          mb.setArrayElement(i);
        }
      }
      gdr.methodReturn();
      gdr.complete();
      nargs+=compiledResultSets;
    }
  }
  String javaReturnType=getJavaTypeName();
  MethodBuilder mbnc=null;
  MethodBuilder mbcm=mb;
  if (returnsNullOnNullState != null) {
    mbnc=acb.newGeneratedFun(javaReturnType,Modifier.PRIVATE,methodParameterTypes);
    Class[] throwsSet=((java.lang.reflect.Method)method).getExceptionTypes();
    for (int te=0; te < throwsSet.length; te++) {
      mbnc.addThrownException(throwsSet[te].getName());
    }
    mbnc.getField(returnsNullOnNullState);
    mbnc.conditionalIf();
    mbnc.pushNull(javaReturnType);
    mbnc.startElseCode();
    if (!actualMethodReturnType.equals(javaReturnType))     mbnc.pushNewStart(javaReturnType);
    for (int pa=0; pa < nargs; pa++) {
      mbnc.getParameter(pa);
    }
    mbcm=mbnc;
  }
  mbcm.callMethod(VMOpcode.INVOKESTATIC,method.getDeclaringClass().getName(),methodName,actualMethodReturnType,nargs);
  if (returnsNullOnNullState != null) {
    if (!actualMethodReturnType.equals(javaReturnType)) {
      if (actualMethodReturnType.equals(""String_Node_Str"") && javaReturnType.equals(""String_Node_Str""))       mbnc.upCast(""String_Node_Str"");
      mbnc.pushNewComplete(1);
    }
    mbnc.completeConditional();
    mbnc.methodReturn();
    mbnc.complete();
    mb.callMethod(VMOpcode.INVOKEVIRTUAL,acb.getClassBuilder().getFullName(),mbnc.getName(),javaReturnType,nargs);
    mbnc=null;
  }
  if (routineInfo != null) {
    if (functionEntrySQLAllowed != null) {
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.LanguageConnectionContext,0);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",0);
      mb.getField(functionEntrySQLAllowed);
      mb.push(true);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
    }
    if (outParamArrays != null) {
      MethodBuilder constructor=acb.getConstructor();
      acb.pushThisAsActivation(constructor);
      constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      acb.pushThisAsActivation(mb);
      mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.ParameterValueSet,0);
      int[] parameterModes=routineInfo.getParameterModes();
      for (int i=0; i < outParamArrays.length; i++) {
        int parameterMode=parameterModes[i];
        if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
          ValueNode sqlParamNode=((SQLToJavaValueNode)methodParms[i]).getSQLValueNode();
          int applicationParameterNumber=applicationParameterNumbers[i];
          constructor.dup();
          constructor.push(applicationParameterNumber);
          constructor.push(parameterMode);
          constructor.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",2);
          LocalField lf=outParamArrays[i];
          mb.dup();
          mb.push(applicationParameterNumber);
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",ClassName.DataValueDescriptor,1);
          DataTypeDescriptor paramdtd=sqlParamNode.getTypeServices();
          boolean isNumericType=paramdtd.getTypeId().isNumericTypeId();
          boolean isAnsiUDT=paramdtd.getTypeId().getBaseTypeId().isAnsiUDT();
          boolean isPrimitive=((java.lang.reflect.Method)method).getParameterTypes()[i].getComponentType().isPrimitive();
          if (isNumericType) {
            if (!isPrimitive)             mb.cast(ClassName.NumberDataValue);
          }
 else           if (paramdtd.getTypeId().isBooleanTypeId()) {
            if (!isPrimitive)             mb.cast(ClassName.BooleanDataValue);
          }
          if (paramdtd.getTypeId().variableLength()) {
            mb.dup();
          }
          mb.getField(lf);
          mb.getArrayElement(0);
          if (isNumericType && !isPrimitive) {
            mb.upCast(""String_Node_Str"");
          }
          if (isAnsiUDT) {
            mb.upCast(""String_Node_Str"");
          }
          mb.callMethod(VMOpcode.INVOKEINTERFACE,null,""String_Node_Str"",""String_Node_Str"",1);
          if (paramdtd.getTypeId().variableLength()) {
            mb.push(isNumericType ? paramdtd.getPrecision() : paramdtd.getMaximumWidth());
            mb.push(paramdtd.getScale());
            mb.push(isNumericType);
            mb.callMethod(VMOpcode.INVOKEINTERFACE,ClassName.VariableSizeDataValue,""String_Node_Str"",""String_Node_Str"",3);
          }
        }
      }
      constructor.endStatement();
      mb.endStatement();
    }
  }
}"
80073,"/** 
 * Write SQLUDTGRP (SQL Descriptor User-Defined Type Group Descriptor) This is the format from the DRDA spec, Volume 1, section 5.6.4.10. However, this format is not rich enough to carry the information needed by JDBC. This format does not have a subtype code for JAVA_OBJECT and this format does not convey the Java class name needed by ResultSetMetaData.getColumnClassName(). SQLUDXTYPE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 Constants which map to java.sql.Types constants DISTINCT, STRUCT, and REF. But DRDA does not define a constant which maps to java.sql.Types.JAVA_OBJECT. SQLUDTRDB; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Database name. SQLUDTSCHEMA_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTSCHEMA_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Schema name. One of the above. SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Unqualified UDT name. One of the above. Instead, we use the following format and only for communication between Derby servers and Derby clients which are both at version 10.6 or higher. For all other client/server combinations, we send null. SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Fully qualified UDT name. One of the above. SQLUDTCLASSNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN SQLUDTCLASSNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN Name of the Java class bound to the UDT. One of the above.
 * @param rsmeta	resultset meta data
 * @param pmeta		parameter meta data
 * @param elemNum	column number we are returning (in case of result set), or,parameter number (in case of parameter)
 * @param rtnOutput	whether this is for a result set	
 * @throws DRDAProtocolException
 * @throws SQLException
 */
private void writeSQLUDTGRP(ResultSetMetaData rsmeta,ParameterMetaData pmeta,int jdbcElemNum,boolean rtnOutput) throws DRDAProtocolException, SQLException {
  int jdbcType=rtnOutput ? rsmeta.getColumnType(jdbcElemNum) : pmeta.getParameterType(jdbcElemNum);
  if (!(jdbcType == Types.JAVA_OBJECT) || !appRequester.supportsUDTs()) {
    writer.writeByte(CodePoint.NULLDATA);
    return;
  }
  String typeName=rtnOutput ? rsmeta.getColumnTypeName(jdbcElemNum) : pmeta.getParameterTypeName(jdbcElemNum);
  String className=rtnOutput ? rsmeta.getColumnClassName(jdbcElemNum) : pmeta.getParameterClassName(jdbcElemNum);
  writeVCMorVCS(typeName);
  writeVCMorVCS(className);
}","/** 
 * Write SQLUDTGRP (SQL Descriptor User-Defined Type Group Descriptor) This is the format from the DRDA spec, Volume 1, section 5.6.4.10. However, this format is not rich enough to carry the information needed by JDBC. This format does not have a subtype code for JAVA_OBJECT and this format does not convey the Java class name needed by ResultSetMetaData.getColumnClassName(). SQLUDXTYPE; DRDA TYPE I4; ENVLID 0x02; Length Override 4 Constants which map to java.sql.Types constants DISTINCT, STRUCT, and REF. But DRDA does not define a constant which maps to java.sql.Types.JAVA_OBJECT. SQLUDTRDB; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Database name. SQLUDTSCHEMA_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTSCHEMA_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Schema name. One of the above. SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Unqualified UDT name. One of the above. Instead, we use the following format and only for communication between Derby servers and Derby clients which are both at version 10.6 or higher. For all other client/server combinations, we send null. SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255 SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255 Fully qualified UDT name. One of the above. SQLUDTCLASSNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN SQLUDTCLASSNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN Name of the Java class bound to the UDT. One of the above.
 * @param rsmeta	resultset meta data
 * @param pmeta		parameter meta data
 * @param jdbcElemNum	column number we are returning (in case of result set), or,parameter number (in case of parameter)
 * @param rtnOutput	whether this is for a result set	
 * @throws DRDAProtocolException
 * @throws SQLException
 */
private void writeSQLUDTGRP(ResultSetMetaData rsmeta,ParameterMetaData pmeta,int jdbcElemNum,boolean rtnOutput) throws DRDAProtocolException, SQLException {
  int jdbcType=rtnOutput ? rsmeta.getColumnType(jdbcElemNum) : pmeta.getParameterType(jdbcElemNum);
  if (!(jdbcType == Types.JAVA_OBJECT) || !appRequester.supportsUDTs()) {
    writer.writeByte(CodePoint.NULLDATA);
    return;
  }
  String typeName=rtnOutput ? rsmeta.getColumnTypeName(jdbcElemNum) : pmeta.getParameterTypeName(jdbcElemNum);
  String className=rtnOutput ? rsmeta.getColumnClassName(jdbcElemNum) : pmeta.getParameterClassName(jdbcElemNum);
  writeVCMorVCS(typeName);
  writeVCMorVCS(className);
}"
80074,"/** 
 * initialize a PrivilegesNode
 * @param objectType (an Integer)
 * @param objectOfPrivilege (a TableName or RoutineDesignator)
 * @param specificPrivileges null for routines
 */
public void init(Object objectType,Object objectOfPrivilege,Object specificPrivileges){
  this.objectType=((Integer)objectType).intValue();
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(objectOfPrivilege != null,""String_Node_Str"");
switch (this.objectType) {
case TABLE_PRIVILEGES:
      SanityManager.ASSERT(specificPrivileges != null,""String_Node_Str"");
    objectName=(TableName)objectOfPrivilege;
  this.specificPrivileges=(TablePrivilegesNode)specificPrivileges;
break;
case ROUTINE_PRIVILEGES:
SanityManager.ASSERT(specificPrivileges == null,""String_Node_Str"");
routineDesignator=(RoutineDesignator)objectOfPrivilege;
objectName=routineDesignator.name;
break;
default :
SanityManager.THROWASSERT(""String_Node_Str"" + this.objectType);
}
}
}","/** 
 * initialize a PrivilegesNode
 * @param objectType (an Integer)
 * @param objectOfPrivilege (a TableName or RoutineDesignator)
 * @param specificPrivileges null for routines
 */
public void init(Object objectType,Object objectOfPrivilege,Object specificPrivileges){
  this.objectType=((Integer)objectType).intValue();
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(objectOfPrivilege != null,""String_Node_Str"");
  }
switch (this.objectType) {
case TABLE_PRIVILEGES:
    if (SanityManager.DEBUG) {
      SanityManager.ASSERT(specificPrivileges != null,""String_Node_Str"");
    }
  objectName=(TableName)objectOfPrivilege;
this.specificPrivileges=(TablePrivilegesNode)specificPrivileges;
break;
case ROUTINE_PRIVILEGES:
if (SanityManager.DEBUG) {
SanityManager.ASSERT(specificPrivileges == null,""String_Node_Str"");
}
routineDesignator=(RoutineDesignator)objectOfPrivilege;
objectName=routineDesignator.name;
break;
default :
if (SanityManager.DEBUG) {
SanityManager.THROWASSERT(""String_Node_Str"" + this.objectType);
}
}
}"
80075,"/** 
 * Reports an unexpected error and the access count for the specified worker thread.
 * @param id worker thread id, must be in the range [0, threadCount>
 * @param accessCount number of successful accesses made to the db
 * @param SQL
 */
public synchronized void reportError(int id,int accessCount,Throwable error){
  reportAccessCount(id,accessCount);
  exceptions[id]=error;
  hasExceptions=true;
  dumpToFile(id,error);
}","/** 
 * Reports an unexpected error and the access count for the specified worker thread.
 * @param id worker thread id, must be in the range [0, threadCount>
 * @param accessCount number of successful accesses made to the db
 * @param error error to report
 */
public synchronized void reportError(int id,int accessCount,Throwable error){
  reportAccessCount(id,accessCount);
  exceptions[id]=error;
  hasExceptions=true;
  dumpToFile(id,error);
}"
80076,"/** 
 * Obtains a reader for the specified file.
 * @param file the file to obtain a reader for
 * @return An unbuffered reader for the specified file.
 * @throws FileNotFoundException if the specified file does not exist
 * @throws SecurityException if the required privileges to read the fileare missing
 */
public static FileReader getFileReader(final File file) throws FileNotFoundException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return (FileReader)AccessController.doPrivileged(new PrivilegedExceptionAction(){
      public Object run() throws FileNotFoundException {
        return new FileReader(file);
      }
    }
);
  }
 catch (  PrivilegedActionException pae) {
    throw (FileNotFoundException)pae.getCause();
  }
}","/** 
 * Obtains a reader for the specified file.
 * @param file the file to obtain a reader for
 * @return An unbuffered reader for the specified file.
 * @throws FileNotFoundException if the specified file does not exist
 * @throws SecurityException if the required permissions to read the file,or the path it is in, are missing
 */
public static FileReader getFileReader(final File file) throws FileNotFoundException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return (FileReader)AccessController.doPrivileged(new PrivilegedExceptionAction(){
      public Object run() throws FileNotFoundException {
        return new FileReader(file);
      }
    }
);
  }
 catch (  PrivilegedActionException pae) {
    throw (FileNotFoundException)pae.getCause();
  }
}"
80077,"public static FileInputStream getFileInputStream(final File file) throws SecurityException, FileNotFoundException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return ((FileInputStream)AccessController.doPrivileged(new PrivilegedExceptionAction(){
      public Object run() throws SecurityException, FileNotFoundException {
        return new FileInputStream(file);
      }
    }
));
  }
 catch (  PrivilegedActionException pae) {
    throw (SecurityException)pae.getException();
  }
}","/** 
 * Returns a input stream for the specified file.
 * @param file the file to open a stream for
 * @return A input stream reading from the specified file.
 * @throws SecurityException if the required permissions to read the file,or the path it is in, are missing
 * @throws FileNotFoundException if the specified file does not exist
 */
public static FileInputStream getFileInputStream(final File file) throws FileNotFoundException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return ((FileInputStream)AccessController.doPrivileged(new PrivilegedExceptionAction(){
      public Object run() throws FileNotFoundException {
        return new FileInputStream(file);
      }
    }
));
  }
 catch (  PrivilegedActionException pae) {
    throw (FileNotFoundException)pae.getException();
  }
}"
80078,"/** 
 * Get the file length.
 * @return byte length of the file.
 * @throws SecurityException if the required permissions to read the file,or the path it is in, are missing
 * @see File#length
 */
public static long length(final File file) throws SecurityException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return ((Long)AccessController.doPrivileged(new PrivilegedExceptionAction(){
      public Object run() throws SecurityException {
        return new Long(file.length());
      }
    }
)).longValue();
  }
 catch (  PrivilegedActionException pae) {
    throw (SecurityException)pae.getException();
  }
}","/** 
 * Get the file length.
 * @return Byte length of the file.
 * @throws SecurityException if the required permissions to read the file,or the path it is in, are missing
 * @see File#length
 */
public static long length(final File file) throws SecurityException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return ((Long)AccessController.doPrivileged(new PrivilegedAction(){
    public Object run(){
      return new Long(file.length());
    }
  }
)).longValue();
}"
80079,"/** 
 * Check if the file exists.
 * @return <code>true</code> if file exists, <code>false</code> otherwise
 * @throws SecurityException if the required permissions to read the file,or the path it is in, are missing
 * @see File#exists
 */
public static boolean exists(final File file) throws SecurityException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    return ((Boolean)AccessController.doPrivileged(new PrivilegedExceptionAction(){
      public Object run() throws SecurityException {
        return new Boolean(file.exists());
      }
    }
)).booleanValue();
  }
 catch (  PrivilegedActionException pae) {
    throw (SecurityException)pae.getException();
  }
}","/** 
 * Check if the file exists.
 * @return {@code true} if file exists, {@code false} otherwise
 * @throws SecurityException if the required permissions to read the file,or the path it is in, are missing
 * @see File#exists
 */
public static boolean exists(final File file) throws SecurityException {
  if (file == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  return ((Boolean)AccessController.doPrivileged(new PrivilegedAction(){
    public Object run(){
      return new Boolean(file.exists());
    }
  }
)).booleanValue();
}"
80080,"/** 
 * Tests that the data updated in a Clob is always reflected in the Reader got. Here the updates are done using both a Writer obtained from this Clob and using Clob.setString.
 * @throws Exception
 */
public void testGetCharacterStreamClobUpdates() throws Exception {
  String str1=""String_Node_Str"";
  String str2=""String_Node_Str"";
  Clob clob=getConnection().createClob();
  Reader r_BeforeWrite=clob.getCharacterStream();
  Writer w=clob.setCharacterStream(1);
  char[] chars_str1=new char[str1.length()];
  str2.getChars(0,str1.length(),chars_str1,0);
  w.write(chars_str1);
  clob.setString((str1.getBytes().length) + 1,str2);
  Reader r_AfterWrite=clob.getCharacterStream();
  assertEquals(r_BeforeWrite,r_AfterWrite);
}","/** 
 * Tests that the data updated in a Clob is always reflected in the Reader got. Here the updates are done using both a Writer obtained from this Clob and using Clob.setString.
 * @throws Exception
 */
public void testGetCharacterStreamClobUpdates() throws Exception {
  String str1=""String_Node_Str"";
  String str2=""String_Node_Str"";
  Clob clob=getConnection().createClob();
  Reader r_BeforeWrite=clob.getCharacterStream();
  Writer w=clob.setCharacterStream(1);
  char[] chars_str1=new char[str1.length()];
  str2.getChars(0,str1.length(),chars_str1,0);
  w.write(chars_str1);
  clob.setString((str1.length()) + 1,str2);
  Reader r_AfterWrite=clob.getCharacterStream();
  assertEquals(r_BeforeWrite,r_AfterWrite);
}"
80081,"/** 
 * Test fix for derby-1382. Test that the getBlob() returns the correct value for the blob before and after updating the blob when using result sets of type TYPE_SCROLL_INSENSITIVE.
 * @throws Exception
 */
public void testGetBlobBeforeAndAfterUpdate() throws Exception {
  String blobData=""String_Node_Str"";
  PreparedStatement ps=prepareStatement(""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    ps.setInt(1,i);
    ps.setBytes(2,(blobData + i).getBytes());
    ps.execute();
  }
  ps.close();
  Statement scrollStmt=createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
  ResultSet rs=scrollStmt.executeQuery(""String_Node_Str"");
  rs.first();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.next();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.relative(3);
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.absolute(7);
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.previous();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.last();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.previous();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.close();
  scrollStmt.close();
}","/** 
 * Test fix for derby-1382. Test that the getBlob() returns the correct value for the blob before and after updating the blob when using result sets of type TYPE_SCROLL_INSENSITIVE.
 * @throws Exception
 */
public void testGetBlobBeforeAndAfterUpdate() throws Exception {
  String blobData=""String_Node_Str"";
  PreparedStatement ps=prepareStatement(""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    ps.setInt(1,i);
    ps.setBytes(2,(blobData + i).getBytes(""String_Node_Str""));
    ps.execute();
  }
  ps.close();
  Statement scrollStmt=createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
  ResultSet rs=scrollStmt.executeQuery(""String_Node_Str"");
  rs.first();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.next();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.relative(3);
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.absolute(7);
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.previous();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.last();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.previous();
  checkContentsBeforeAndAfterUpdatingBlob(rs);
  rs.close();
  scrollStmt.close();
}"
80082,"private void checkContentsBeforeAndAfterUpdatingBlob(ResultSet rs) throws SQLException {
  Blob b;
  byte[] value, expectedValue;
  String blobData=""String_Node_Str"";
  String updatedBlobData=""String_Node_Str"";
  b=rs.getBlob(2);
  value=b.getBytes(1,blobData.length() + 1);
  expectedValue=(blobData + rs.getInt(1)).getBytes();
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
  value=(updatedBlobData + rs.getInt(1)).getBytes();
  b.setBytes(1,value);
  rs.updateBlob(2,b);
  rs.updateRow();
  rs.next();
  rs.previous();
  b=rs.getBlob(2);
  value=b.getBytes(1,updatedBlobData.length() + 1);
  expectedValue=(updatedBlobData + rs.getInt(1)).getBytes();
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
}","private void checkContentsBeforeAndAfterUpdatingBlob(ResultSet rs) throws SQLException, UnsupportedEncodingException {
  Blob b;
  byte[] value, expectedValue;
  String blobData=""String_Node_Str"";
  String updatedBlobData=""String_Node_Str"";
  b=rs.getBlob(2);
  value=b.getBytes(1,blobData.length() + 1);
  expectedValue=(blobData + rs.getInt(1)).getBytes(""String_Node_Str"");
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
  value=(updatedBlobData + rs.getInt(1)).getBytes(""String_Node_Str"");
  b.setBytes(1,value);
  rs.updateBlob(2,b);
  rs.updateRow();
  rs.next();
  rs.previous();
  b=rs.getBlob(2);
  value=b.getBytes(1,updatedBlobData.length() + 1);
  expectedValue=(updatedBlobData + rs.getInt(1)).getBytes(""String_Node_Str"");
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
}"
80083,"/** 
 * Test fix for derby-1421. Test that the getBlob() returns the correct value for the blob before and after updating the blob using the method updateBinaryStream().
 * @throws Exception
 */
public void testGetBlobBeforeAndAfterUpdateStream() throws Exception {
  String blobData=""String_Node_Str"";
  PreparedStatement ps=prepareStatement(""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    ps.setInt(1,i);
    ps.setBytes(2,(blobData + i).getBytes());
    ps.execute();
  }
  ps.close();
  Statement scrollStmt=createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
  ResultSet rs=scrollStmt.executeQuery(""String_Node_Str"");
  rs.first();
  updateBlobWithUpdateBinaryStream(rs);
  rs.next();
  updateBlobWithUpdateBinaryStream(rs);
  rs.relative(3);
  updateBlobWithUpdateBinaryStream(rs);
  rs.absolute(7);
  updateBlobWithUpdateBinaryStream(rs);
  rs.previous();
  updateBlobWithUpdateBinaryStream(rs);
  rs.last();
  updateBlobWithUpdateBinaryStream(rs);
  rs.previous();
  updateBlobWithUpdateBinaryStream(rs);
  rs.close();
  scrollStmt.close();
}","/** 
 * Test fix for derby-1421. Test that the getBlob() returns the correct value for the blob before and after updating the blob using the method updateBinaryStream().
 * @throws Exception
 */
public void testGetBlobBeforeAndAfterUpdateStream() throws Exception {
  String blobData=""String_Node_Str"";
  PreparedStatement ps=prepareStatement(""String_Node_Str"");
  for (int i=0; i < 10; i++) {
    ps.setInt(1,i);
    ps.setBytes(2,(blobData + i).getBytes(""String_Node_Str""));
    ps.execute();
  }
  ps.close();
  Statement scrollStmt=createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);
  ResultSet rs=scrollStmt.executeQuery(""String_Node_Str"");
  rs.first();
  updateBlobWithUpdateBinaryStream(rs);
  rs.next();
  updateBlobWithUpdateBinaryStream(rs);
  rs.relative(3);
  updateBlobWithUpdateBinaryStream(rs);
  rs.absolute(7);
  updateBlobWithUpdateBinaryStream(rs);
  rs.previous();
  updateBlobWithUpdateBinaryStream(rs);
  rs.last();
  updateBlobWithUpdateBinaryStream(rs);
  rs.previous();
  updateBlobWithUpdateBinaryStream(rs);
  rs.close();
  scrollStmt.close();
}"
80084,"private void updateBlobWithUpdateBinaryStream(ResultSet rs) throws SQLException {
  Blob b;
  byte[] value, expectedValue;
  String blobData=""String_Node_Str"";
  String updatedBlobData=""String_Node_Str"";
  b=rs.getBlob(2);
  value=b.getBytes(1,blobData.length() + 1);
  expectedValue=(blobData + rs.getInt(1)).getBytes();
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
  value=(updatedBlobData + rs.getInt(1)).getBytes();
  InputStream updateValue=new ByteArrayInputStream(value);
  rs.updateBinaryStream(2,updateValue,value.length);
  rs.updateRow();
  rs.next();
  rs.previous();
  b=rs.getBlob(2);
  value=b.getBytes(1,updatedBlobData.length() + 1);
  expectedValue=(updatedBlobData + rs.getInt(1)).getBytes();
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
}","private void updateBlobWithUpdateBinaryStream(ResultSet rs) throws SQLException, UnsupportedEncodingException {
  Blob b;
  byte[] value, expectedValue;
  String blobData=""String_Node_Str"";
  String updatedBlobData=""String_Node_Str"";
  b=rs.getBlob(2);
  value=b.getBytes(1,blobData.length() + 1);
  expectedValue=(blobData + rs.getInt(1)).getBytes(""String_Node_Str"");
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
  value=(updatedBlobData + rs.getInt(1)).getBytes(""String_Node_Str"");
  InputStream updateValue=new ByteArrayInputStream(value);
  rs.updateBinaryStream(2,updateValue,value.length);
  rs.updateRow();
  rs.next();
  rs.previous();
  b=rs.getBlob(2);
  value=b.getBytes(1,updatedBlobData.length() + 1);
  expectedValue=(updatedBlobData + rs.getInt(1)).getBytes(""String_Node_Str"");
  assertTrue(""String_Node_Str"",Arrays.equals(value,expectedValue));
}"
80085,"/** 
 * Test Blob.position() with blob argument
 */
public void testPositionBlob() throws Exception {
  insertDefaultData();
  Statement stmt=createStatement();
  ResultSet rs=stmt.executeQuery(""String_Node_Str"");
  int blobLength=0;
  Blob blob;
  Statement stmt2=createStatement();
  Random random=new Random();
  String searchString;
  int start, length, startSearchPos;
  int distance, maxStartPointDistance;
  long foundAt;
  maxStartPointDistance=CharAlphabet.MODERNLATINLOWER.length;
  while (rs.next()) {
    blob=rs.getBlob(1);
    blobLength=rs.getInt(2);
    if (blob != null && blobLength > 0) {
      println(""String_Node_Str"" + blobLength);
      stmt2.executeUpdate(""String_Node_Str"" + ""String_Node_Str"");
      PreparedStatement ps=prepareStatement(""String_Node_Str"");
      for (int i=0; i < 10; i++) {
        start=Math.max(random.nextInt(blobLength - 1),1);
        length=random.nextInt(blobLength - start) + 1;
        println(""String_Node_Str"" + start + ""String_Node_Str""+ length);
        searchString=new String(blob.getBytes(start,length));
        distance=random.nextInt(maxStartPointDistance);
        startSearchPos=Math.max((start - distance),1);
        String tmp=new String(blob.getBytes(startSearchPos,start));
        if (tmp.indexOf(searchString) != -1) {
          startSearchPos=start;
        }
        ps.setBytes(1,searchString.getBytes());
        ps.setInt(2,startSearchPos);
        ps.setInt(3,start);
        ps.executeUpdate();
      }
      ps.close();
      ResultSet rs2=stmt2.executeQuery(""String_Node_Str"");
      while (rs2.next()) {
        Blob searchBlob=rs2.getBlob(1);
        startSearchPos=rs2.getInt(2);
        start=rs2.getInt(3);
        searchString=new String(searchBlob.getBytes(1L,(int)searchBlob.length()));
        println(""String_Node_Str"" + startSearchPos + ""String_Node_Str""+ searchString);
        foundAt=blob.position(searchBlob,startSearchPos);
        assertEquals(""String_Node_Str"" + searchString + ""String_Node_Str""+ startSearchPos+ ""String_Node_Str""+ searchString.length(),start,foundAt);
      }
      rs2.close();
      stmt2.executeUpdate(""String_Node_Str"");
    }
  }
  rs.close();
  stmt.close();
  stmt2.close();
}","/** 
 * Test Blob.position() with blob argument
 */
public void testPositionBlob() throws Exception {
  insertDefaultData();
  Statement stmt=createStatement();
  ResultSet rs=stmt.executeQuery(""String_Node_Str"");
  int blobLength=0;
  Blob blob;
  Statement stmt2=createStatement();
  Random random=new Random();
  String searchString;
  int start, length, startSearchPos;
  int distance, maxStartPointDistance;
  long foundAt;
  maxStartPointDistance=CharAlphabet.MODERNLATINLOWER.length;
  while (rs.next()) {
    blob=rs.getBlob(1);
    blobLength=rs.getInt(2);
    if (blob != null && blobLength > 0) {
      println(""String_Node_Str"" + blobLength);
      stmt2.executeUpdate(""String_Node_Str"" + ""String_Node_Str"");
      PreparedStatement ps=prepareStatement(""String_Node_Str"");
      for (int i=0; i < 10; i++) {
        start=Math.max(random.nextInt(blobLength - 1),1);
        length=random.nextInt(blobLength - start) + 1;
        println(""String_Node_Str"" + start + ""String_Node_Str""+ length);
        searchString=new String(blob.getBytes(start,length),""String_Node_Str"");
        distance=random.nextInt(maxStartPointDistance);
        startSearchPos=Math.max((start - distance),1);
        String tmp=new String(blob.getBytes(startSearchPos,start),""String_Node_Str"");
        if (tmp.indexOf(searchString) != -1) {
          startSearchPos=start;
        }
        ps.setBytes(1,searchString.getBytes(""String_Node_Str""));
        ps.setInt(2,startSearchPos);
        ps.setInt(3,start);
        ps.executeUpdate();
      }
      ps.close();
      ResultSet rs2=stmt2.executeQuery(""String_Node_Str"");
      while (rs2.next()) {
        Blob searchBlob=rs2.getBlob(1);
        startSearchPos=rs2.getInt(2);
        start=rs2.getInt(3);
        searchString=new String(searchBlob.getBytes(1L,(int)searchBlob.length()),""String_Node_Str"");
        println(""String_Node_Str"" + startSearchPos + ""String_Node_Str""+ searchString);
        foundAt=blob.position(searchBlob,startSearchPos);
        assertEquals(""String_Node_Str"" + searchString + ""String_Node_Str""+ startSearchPos+ ""String_Node_Str""+ searchString.length(),start,foundAt);
      }
      rs2.close();
      stmt2.executeUpdate(""String_Node_Str"");
    }
  }
  rs.close();
  stmt.close();
  stmt2.close();
}"
80086,"/** 
 * test position with a byte[] argument
 */
public void testPositionBytes() throws Exception {
  insertDefaultData();
  Statement stmt=createStatement();
  ResultSet rs=stmt.executeQuery(""String_Node_Str"");
  int blobLength=0;
  Blob blob;
  Random random=new Random();
  byte[] searchBytes;
  int start, length, startSearchPos;
  int distance, maxStartPointDistance;
  long foundAt;
  maxStartPointDistance=CharAlphabet.MODERNLATINLOWER.length;
  while (rs.next()) {
    blob=rs.getBlob(1);
    blobLength=rs.getInt(2);
    if (blob != null && blobLength > 0) {
      println(""String_Node_Str"" + blobLength);
      for (int i=0; i < 10; i++) {
        start=Math.max(random.nextInt(blobLength - 1),1);
        length=random.nextInt(blobLength - start) + 1;
        println(""String_Node_Str"" + start + ""String_Node_Str""+ length);
        searchBytes=blob.getBytes(start,length);
        String searchString=new String(searchBytes);
        distance=random.nextInt(maxStartPointDistance);
        startSearchPos=Math.max((start - distance),1);
        byte[] tmp=blob.getBytes(startSearchPos,start);
        if (new String(tmp).indexOf(searchString) != -1) {
          startSearchPos=start;
        }
        println(""String_Node_Str"" + startSearchPos + ""String_Node_Str""+ new String(searchBytes));
        foundAt=blob.position(searchBytes,startSearchPos);
        assertEquals(""String_Node_Str"" + searchString + ""String_Node_Str""+ startSearchPos+ ""String_Node_Str""+ searchBytes.length,start,foundAt);
      }
    }
  }
  rs.close();
  stmt.close();
}","/** 
 * test position with a byte[] argument
 */
public void testPositionBytes() throws Exception {
  insertDefaultData();
  Statement stmt=createStatement();
  ResultSet rs=stmt.executeQuery(""String_Node_Str"");
  int blobLength=0;
  Blob blob;
  Random random=new Random();
  byte[] searchBytes;
  int start, length, startSearchPos;
  int distance, maxStartPointDistance;
  long foundAt;
  maxStartPointDistance=CharAlphabet.MODERNLATINLOWER.length;
  while (rs.next()) {
    blob=rs.getBlob(1);
    blobLength=rs.getInt(2);
    if (blob != null && blobLength > 0) {
      println(""String_Node_Str"" + blobLength);
      for (int i=0; i < 10; i++) {
        start=Math.max(random.nextInt(blobLength - 1),1);
        length=random.nextInt(blobLength - start) + 1;
        println(""String_Node_Str"" + start + ""String_Node_Str""+ length);
        searchBytes=blob.getBytes(start,length);
        String searchString=new String(searchBytes,""String_Node_Str"");
        distance=random.nextInt(maxStartPointDistance);
        startSearchPos=Math.max((start - distance),1);
        byte[] tmp=blob.getBytes(startSearchPos,start);
        if (new String(tmp,""String_Node_Str"").indexOf(searchString) != -1) {
          startSearchPos=start;
        }
        println(""String_Node_Str"" + startSearchPos + ""String_Node_Str""+ new String(searchBytes));
        foundAt=blob.position(searchBytes,startSearchPos);
        assertEquals(""String_Node_Str"" + searchString + ""String_Node_Str""+ startSearchPos+ ""String_Node_Str""+ searchBytes.length,start,foundAt);
      }
    }
  }
  rs.close();
  stmt.close();
}"
80087,"public static Test baseSuite(String name){
  TestSuite suite=new TestSuite(name);
  suite.addTestSuite(LargeDataLocksTest.class);
  return new CleanDatabaseTestSetup(suite){
    /** 
 * Create and populate table
 * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
 */
    protected void decorateSQL(    Statement s) throws SQLException {
      Connection conn=getConnection();
      conn.setAutoCommit(false);
      PreparedStatement ps=null;
      String sql;
      sql=""String_Node_Str"";
      s.executeUpdate(sql);
      sql=""String_Node_Str"";
      ps=conn.prepareStatement(sql);
      ps.setCharacterStream(1,new java.io.StringReader(Utilities.repeatChar(""String_Node_Str"",38000)),38000);
      ps.setBytes(2,Utilities.repeatChar(""String_Node_Str"",38000).getBytes());
      ps.setInt(3,38000);
      ps.executeUpdate();
      ps.close();
      conn.commit();
    }
  }
;
}","public static Test baseSuite(String name){
  TestSuite suite=new TestSuite(name);
  suite.addTestSuite(LargeDataLocksTest.class);
  return new CleanDatabaseTestSetup(suite){
    /** 
 * Create and populate table
 * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
 */
    protected void decorateSQL(    Statement s) throws SQLException {
      Connection conn=getConnection();
      conn.setAutoCommit(false);
      PreparedStatement ps=null;
      String sql;
      sql=""String_Node_Str"";
      s.executeUpdate(sql);
      sql=""String_Node_Str"";
      ps=conn.prepareStatement(sql);
      ps.setCharacterStream(1,new java.io.StringReader(Utilities.repeatChar(""String_Node_Str"",38000)),38000);
      try {
        ps.setBytes(2,Utilities.repeatChar(""String_Node_Str"",38000).getBytes(""String_Node_Str""));
      }
 catch (      UnsupportedEncodingException ue) {
        BaseTestCase.fail(ue.getMessage(),ue);
      }
      ps.setInt(3,38000);
      ps.executeUpdate();
      ps.close();
      conn.commit();
    }
  }
;
}"
80088,"/** 
 * Create and populate table
 * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
 */
protected void decorateSQL(Statement s) throws SQLException {
  Connection conn=getConnection();
  conn.setAutoCommit(false);
  PreparedStatement ps=null;
  String sql;
  sql=""String_Node_Str"";
  s.executeUpdate(sql);
  sql=""String_Node_Str"";
  ps=conn.prepareStatement(sql);
  ps.setCharacterStream(1,new java.io.StringReader(Utilities.repeatChar(""String_Node_Str"",38000)),38000);
  ps.setBytes(2,Utilities.repeatChar(""String_Node_Str"",38000).getBytes());
  ps.setInt(3,38000);
  ps.executeUpdate();
  ps.close();
  conn.commit();
}","/** 
 * Create and populate table
 * @see org.apache.derbyTesting.junit.CleanDatabaseTestSetup#decorateSQL(java.sql.Statement)
 */
protected void decorateSQL(Statement s) throws SQLException {
  Connection conn=getConnection();
  conn.setAutoCommit(false);
  PreparedStatement ps=null;
  String sql;
  sql=""String_Node_Str"";
  s.executeUpdate(sql);
  sql=""String_Node_Str"";
  ps=conn.prepareStatement(sql);
  ps.setCharacterStream(1,new java.io.StringReader(Utilities.repeatChar(""String_Node_Str"",38000)),38000);
  try {
    ps.setBytes(2,Utilities.repeatChar(""String_Node_Str"",38000).getBytes(""String_Node_Str""));
  }
 catch (  UnsupportedEncodingException ue) {
    BaseTestCase.fail(ue.getMessage(),ue);
  }
  ps.setInt(3,38000);
  ps.executeUpdate();
  ps.close();
  conn.commit();
}"
80089,"public void testEarlyEndOfFile() throws Exception {
  Connection c=getConnection();
  try {
    doImportFromFile(c,""String_Node_Str"",""String_Node_Str"",null,null,null,0);
  }
 catch (  SQLException e) {
    assertSQLState(""String_Node_Str"",e);
  }
}","public void testEarlyEndOfFile() throws Exception {
  Connection c=getConnection();
  try {
    doImportFromFile(c,""String_Node_Str"",""String_Node_Str"",null,null,""String_Node_Str"",0);
  }
 catch (  SQLException e) {
    assertSQLState(""String_Node_Str"",e);
  }
}"
80090,"/** 
 * Test killing master during replication.
 * @throws Exception
 */
public void testKillMaster() throws Exception {
  System.out.println(""String_Node_Str"" + getTestConfiguration().getJDBCClient().getJDBCDriverName());
  Connection conn=getConnection();
  Statement s=conn.createStatement();
  s.executeUpdate(""String_Node_Str"");
  PreparedStatement pSt=prepareStatement(""String_Node_Str"");
  int i=0;
  try {
    for (; i < 1000; i++) {
      pSt.setInt(1,i);
      pSt.setString(2,""String_Node_Str"" + i);
      pSt.execute();
      System.out.println(""String_Node_Str"" + i);
      if (i == 500) {
        repRun.killMaster(masterServerHost,masterServerPort);
      }
    }
  }
 catch (  SQLException se) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ se.getMessage()+ ""String_Node_Str"");
    if (i <= 500) {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ se.getMessage()+ ""String_Node_Str"");
    }
  }
  conn.close();
  Thread.sleep(5000L);
  repRun.startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ReplicationRun.ALL_INTERFACES,masterServerPort,ReplicationRun.masterDatabasePath + File.separator + ReplicationRun.masterDbSubPath);
  conn=getConnection();
  s=conn.createStatement();
  ResultSet rs=s.executeQuery(""String_Node_Str"");
  rs.next();
  int count=rs.getInt(1);
  System.out.println(""String_Node_Str"" + count);
}","/** 
 * Test killing master during replication.
 * @throws Exception
 */
public void testKillMaster() throws Exception {
  System.out.println(""String_Node_Str"" + getTestConfiguration().getJDBCClient().getJDBCDriverName());
  Connection conn=getConnection();
  Statement s=conn.createStatement();
  s.executeUpdate(""String_Node_Str"");
  PreparedStatement pSt=prepareStatement(""String_Node_Str"");
  int i=0;
  try {
    for (; i < 1000; i++) {
      pSt.setInt(1,i);
      pSt.setString(2,""String_Node_Str"" + i);
      pSt.execute();
      System.out.println(""String_Node_Str"" + i);
      if (i == 500) {
        repRun.killMaster(masterServerHost,masterServerPort);
      }
    }
  }
 catch (  SQLException se) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ se.getMessage()+ ""String_Node_Str"");
    if (i <= 500) {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ se.getMessage()+ ""String_Node_Str"");
    }
  }
  conn.close();
  Thread.sleep(5000L);
  repRun.startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ReplicationRun.ALL_INTERFACES,masterServerPort,ReplicationRun.masterDbSubPath);
  conn=getConnection();
  s=conn.createStatement();
  ResultSet rs=s.executeQuery(""String_Node_Str"");
  rs.next();
  int count=rs.getInt(1);
  System.out.println(""String_Node_Str"" + count);
}"
80091,"public void run(){
  Process proc=null;
  try {
    util.DEBUG(debugId + ""String_Node_Str"");
    proc=Runtime.getRuntime().exec(localCommand,envElements,workingDir);
    util.DEBUG(debugId + ""String_Node_Str"");
    processDEBUGOutput(debugId + ""String_Node_Str"",proc);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}","public void run(){
  Process proc=null;
  try {
    util.DEBUG(debugId + ""String_Node_Str"");
    proc=Runtime.getRuntime().exec(localCommand,fEnvElements,workingDir);
    util.DEBUG(debugId + ""String_Node_Str"");
    processDEBUGOutput(debugId + ""String_Node_Str"",proc);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
  }
}"
80092,"void stopServer(String serverVM,String serverVersion,String serverHost,int serverPort){
  util.DEBUG(""String_Node_Str"");
  final String debugId=""String_Node_Str"" + serverHost + ""String_Node_Str""+ serverPort+ ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + serverVM + ""String_Node_Str""+ serverVersion+ ""String_Node_Str""+ debugId);
  String serverJvm=serverVM + JVMloc;
  String serverClassPath=serverVersion + FS + ""String_Node_Str""+ PS+ serverVersion+ FS+ ""String_Node_Str"";
  if (serverHost.equals(""String_Node_Str"")) {
    serverClassPath=classPath;
  }
  String command=""String_Node_Str"";
  int port=serverPort;
  final String[] commandElements={serverJvm,""String_Node_Str"",""String_Node_Str"",serverClassPath,""String_Node_Str"" + networkServerControl,""String_Node_Str"" + command,""String_Node_Str"" + serverHost,""String_Node_Str"",serverPort + ""String_Node_Str""};
  final String[] envElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
  String workingDirName=System.getProperty(""String_Node_Str"");
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  String tmp=""String_Node_Str"";
  for (int i=0; i < commandElements.length; i++) {
    tmp=tmp + commandElements[i];
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final String fullCmd=tmp;
  tmp=""String_Node_Str"";
  for (int i=0; i < envElements.length; i++) {
    tmp=tmp + envElements[i] + ""String_Node_Str"";
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final File workingDir=new File(workingDirName);
  String shellCmd=null;
  if (serverHost.equalsIgnoreCase(""String_Node_Str"")) {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    shellCmd=fullCmd;
  }
 else {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    String[] shEnvElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
    String shellEnv=""String_Node_Str"";
    for (int i=0; i < shEnvElements.length; i++) {
      shellEnv=shellEnv + shEnvElements[i] + ""String_Node_Str"";
    }
    util.DEBUG(debugId + ""String_Node_Str"" + shellEnv);
    shellCmd=""String_Node_Str"" + shellEnv + ""String_Node_Str""+ fullCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + shellCmd);
    shellCmd=remoteShell + ""String_Node_Str"" + ""String_Node_Str""+ testUser+ ""String_Node_Str""+ serverHost+ ""String_Node_Str""+ shellCmd;
  }
{
    final String localCommand=shellCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + localCommand);
    try {
      Process proc=Runtime.getRuntime().exec(localCommand,envElements,workingDir);
      processDEBUGOutput(debugId + ""String_Node_Str"",proc);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  util.DEBUG(debugId + ""String_Node_Str"");
  util.DEBUG(""String_Node_Str"");
}","void stopServer(String serverVM,String serverVersion,String serverHost,int serverPort){
  util.DEBUG(""String_Node_Str"");
  final String debugId=""String_Node_Str"" + serverHost + ""String_Node_Str""+ serverPort+ ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + serverVM + ""String_Node_Str""+ serverVersion+ ""String_Node_Str""+ debugId);
  String serverJvm=serverVM + JVMloc;
  String serverClassPath=serverVersion + FS + ""String_Node_Str""+ PS+ serverVersion+ FS+ ""String_Node_Str"";
  if (serverHost.equals(""String_Node_Str"")) {
    serverClassPath=classPath;
  }
  String command=""String_Node_Str"";
  int port=serverPort;
  final String[] commandElements={serverJvm,""String_Node_Str"",""String_Node_Str"",serverClassPath,""String_Node_Str"" + networkServerControl,""String_Node_Str"" + command,""String_Node_Str"" + serverHost,""String_Node_Str"",serverPort + ""String_Node_Str""};
  String[] envElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
  if (serverHost.equals(""String_Node_Str"")) {
    envElements=null;
  }
  String workingDirName=System.getProperty(""String_Node_Str"");
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  String tmp=""String_Node_Str"";
  for (int i=0; i < commandElements.length; i++) {
    tmp=tmp + commandElements[i];
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final String fullCmd=tmp;
  tmp=""String_Node_Str"";
  if (envElements != null) {
    for (int i=0; i < envElements.length; i++) {
      tmp=tmp + envElements[i] + ""String_Node_Str"";
    }
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final File workingDir=new File(workingDirName);
  String shellCmd=null;
  if (serverHost.equalsIgnoreCase(""String_Node_Str"")) {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    shellCmd=fullCmd;
  }
 else {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    String[] shEnvElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
    String shellEnv=""String_Node_Str"";
    for (int i=0; i < shEnvElements.length; i++) {
      shellEnv=shellEnv + shEnvElements[i] + ""String_Node_Str"";
    }
    util.DEBUG(debugId + ""String_Node_Str"" + shellEnv);
    shellCmd=""String_Node_Str"" + shellEnv + ""String_Node_Str""+ fullCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + shellCmd);
    shellCmd=remoteShell + ""String_Node_Str"" + ""String_Node_Str""+ testUser+ ""String_Node_Str""+ serverHost+ ""String_Node_Str""+ shellCmd;
  }
{
    final String localCommand=shellCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + localCommand);
    try {
      Process proc=Runtime.getRuntime().exec(localCommand,envElements,workingDir);
      processDEBUGOutput(debugId + ""String_Node_Str"",proc);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  util.DEBUG(debugId + ""String_Node_Str"");
  util.DEBUG(""String_Node_Str"");
}"
80093,"NetworkServerControl startServer(String serverVM,String serverVersion,String serverHost,String interfacesToListenOn,int serverPort,String fullDbDirPath) throws Exception {
  util.DEBUG(""String_Node_Str"");
  final String debugId=""String_Node_Str"" + serverHost + ""String_Node_Str""+ serverPort+ ""String_Node_Str"";
  util.DEBUG(debugId + ""String_Node_Str"" + serverVM+ ""String_Node_Str""+ serverVersion);
  String serverJvm=serverVM + JVMloc;
  String serverClassPath=serverVersion + FS + ""String_Node_Str""+ PS+ serverVersion+ FS+ ""String_Node_Str"";
  if (serverHost.equals(""String_Node_Str"")) {
    serverClassPath=classPath;
  }
  String command=""String_Node_Str"";
  String securityOption=""String_Node_Str"";
  securityOption=""String_Node_Str"";
  final String[] commandElements={serverJvm,""String_Node_Str"",""String_Node_Str"",serverClassPath,""String_Node_Str"" + networkServerControl,""String_Node_Str"" + command,""String_Node_Str"",interfacesToListenOn,""String_Node_Str"",serverPort + ""String_Node_Str"",""String_Node_Str"" + securityOption};
  final String[] envElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
  String workingDirName=fullDbDirPath;
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  String tmp=""String_Node_Str"";
  for (int i=0; i < commandElements.length; i++) {
    tmp=tmp + commandElements[i];
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final String fullCmd=tmp;
  tmp=""String_Node_Str"";
  for (int i=0; i < envElements.length; i++) {
    tmp=tmp + envElements[i] + ""String_Node_Str"";
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final File workingDir=new File(workingDirName);
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  if (serverHost.equalsIgnoreCase(""String_Node_Str"") || localEnv) {
  }
  String shellCmd=null;
  if (serverHost.equalsIgnoreCase(""String_Node_Str"")) {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    shellCmd=fullCmd;
  }
 else {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    String[] shEnvElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
    String shellEnv=""String_Node_Str"";
    for (int i=0; i < shEnvElements.length; i++) {
      shellEnv=shellEnv + shEnvElements[i] + ""String_Node_Str"";
    }
    util.DEBUG(debugId + ""String_Node_Str"" + shellEnv);
    shellCmd=""String_Node_Str"" + workingDirName + ""String_Node_Str""+ shellEnv+ ""String_Node_Str""+ fullCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + shellCmd);
    shellCmd=remoteShell + ""String_Node_Str"" + ""String_Node_Str""+ testUser+ ""String_Node_Str""+ serverHost+ ""String_Node_Str""+ shellCmd;
  }
{
    final String localCommand=shellCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + localCommand);
    Thread serverThread=new Thread(new Runnable(){
      public void run(){
        Process proc=null;
        try {
          util.DEBUG(debugId + ""String_Node_Str"");
          proc=Runtime.getRuntime().exec(localCommand,envElements,workingDir);
          util.DEBUG(debugId + ""String_Node_Str"");
          processDEBUGOutput(debugId + ""String_Node_Str"",proc);
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
);
    util.DEBUG(debugId + ""String_Node_Str"");
    serverThread.start();
    pingServer(serverHost,serverPort,5);
  }
  util.DEBUG(debugId + ""String_Node_Str"");
  util.DEBUG(""String_Node_Str"");
  return null;
}","NetworkServerControl startServer(String serverVM,String serverVersion,String serverHost,String interfacesToListenOn,int serverPort,String dbSubDirPath) throws Exception {
  util.DEBUG(""String_Node_Str"");
  final String debugId=""String_Node_Str"" + serverHost + ""String_Node_Str""+ serverPort+ ""String_Node_Str"";
  util.DEBUG(debugId + ""String_Node_Str"" + serverVM+ ""String_Node_Str""+ serverVersion);
  String serverJvm=serverVM + JVMloc;
  String serverClassPath=serverVersion + FS + ""String_Node_Str""+ PS+ serverVersion+ FS+ ""String_Node_Str"";
  if (serverHost.equals(""String_Node_Str"")) {
    serverClassPath=classPath;
  }
  String command=""String_Node_Str"";
  String securityOption=""String_Node_Str"";
  securityOption=""String_Node_Str"";
  final String[] commandElements={serverJvm,""String_Node_Str"",""String_Node_Str"",serverClassPath,""String_Node_Str"" + networkServerControl,""String_Node_Str"" + command,""String_Node_Str"",interfacesToListenOn,""String_Node_Str"",serverPort + ""String_Node_Str"",""String_Node_Str"" + securityOption};
  String[] envElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
  if (serverHost.equals(""String_Node_Str"")) {
    envElements=null;
  }
  String workingDirName=userDir + FS + dbSubDirPath;
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  String tmp=""String_Node_Str"";
  for (int i=0; i < commandElements.length; i++) {
    tmp=tmp + commandElements[i];
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final String fullCmd=tmp;
  tmp=""String_Node_Str"";
  if (envElements != null) {
    for (int i=0; i < envElements.length; i++) {
      tmp=tmp + envElements[i] + ""String_Node_Str"";
    }
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final File workingDir=new File(workingDirName);
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  if (serverHost.equalsIgnoreCase(""String_Node_Str"") || localEnv) {
  }
  String shellCmd=null;
  if (serverHost.equalsIgnoreCase(""String_Node_Str"")) {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    shellCmd=fullCmd;
  }
 else {
    util.DEBUG(debugId + ""String_Node_Str"" + serverHost);
    String[] shEnvElements={""String_Node_Str"" + serverClassPath,""String_Node_Str"" + serverVM + FS+ ""String_Node_Str""+ FS+ ""String_Node_Str""};
    String shellEnv=""String_Node_Str"";
    for (int i=0; i < shEnvElements.length; i++) {
      shellEnv=shellEnv + shEnvElements[i] + ""String_Node_Str"";
    }
    util.DEBUG(debugId + ""String_Node_Str"" + shellEnv);
    shellCmd=""String_Node_Str"" + workingDirName + ""String_Node_Str""+ shellEnv+ ""String_Node_Str""+ fullCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + shellCmd);
    shellCmd=remoteShell + ""String_Node_Str"" + ""String_Node_Str""+ testUser+ ""String_Node_Str""+ serverHost+ ""String_Node_Str""+ shellCmd;
  }
{
    final String localCommand=shellCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + localCommand);
    final String[] fEnvElements=envElements;
    Thread serverThread=new Thread(new Runnable(){
      public void run(){
        Process proc=null;
        try {
          util.DEBUG(debugId + ""String_Node_Str"");
          proc=Runtime.getRuntime().exec(localCommand,fEnvElements,workingDir);
          util.DEBUG(debugId + ""String_Node_Str"");
          processDEBUGOutput(debugId + ""String_Node_Str"",proc);
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
);
    util.DEBUG(debugId + ""String_Node_Str"");
    serverThread.start();
    pingServer(serverHost,serverPort,15);
  }
  util.DEBUG(debugId + ""String_Node_Str"");
  util.DEBUG(""String_Node_Str"");
  return null;
}"
80094,"private NetworkServerControl startServer_direct(String serverHost,String interfacesToListenOn,int serverPort,String fullDbDirPath,String securityOption) throws Exception {
  util.DEBUG(""String_Node_Str"" + serverHost + ""String_Node_Str""+ interfacesToListenOn+ ""String_Node_Str""+ serverPort+ ""String_Node_Str""+ fullDbDirPath);
  assertTrue(""String_Node_Str"" + serverHost,serverHost.equalsIgnoreCase(""String_Node_Str""));
  System.setProperty(""String_Node_Str"",fullDbDirPath);
  System.setProperty(""String_Node_Str"",fullDbDirPath);
  NetworkServerControl server=new NetworkServerControl(InetAddress.getByName(interfacesToListenOn),serverPort);
  server.start(null);
  pingServer(serverHost,serverPort,5);
  Properties sp=server.getCurrentProperties();
  sp.setProperty(""String_Node_Str"",securityOption.equalsIgnoreCase(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  return server;
}","private NetworkServerControl startServer_direct(String serverHost,String interfacesToListenOn,int serverPort,String fullDbDirPath,String securityOption) throws Exception {
  util.DEBUG(""String_Node_Str"" + serverHost + ""String_Node_Str""+ interfacesToListenOn+ ""String_Node_Str""+ serverPort+ ""String_Node_Str""+ fullDbDirPath);
  assertTrue(""String_Node_Str"" + serverHost,serverHost.equalsIgnoreCase(""String_Node_Str""));
  System.setProperty(""String_Node_Str"",fullDbDirPath);
  System.setProperty(""String_Node_Str"",fullDbDirPath);
  NetworkServerControl server=new NetworkServerControl(InetAddress.getByName(interfacesToListenOn),serverPort);
  server.start(null);
  pingServer(serverHost,serverPort,15);
  Properties sp=server.getCurrentProperties();
  sp.setProperty(""String_Node_Str"",securityOption.equalsIgnoreCase(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"");
  return server;
}"
80095,"private void runUserCommandLocally(String command,String userDir,String ID){
  util.DEBUG(""String_Node_Str"");
  final String debugId=""String_Node_Str"" + ID + ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + command + ""String_Node_Str""+ userDir);
  String workingDirName=userDir;
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  String tmp=""String_Node_Str"";
  util.DEBUG(debugId + command);
  final String fullCmd=command;
  String[] envElements={""String_Node_Str""};
  tmp=""String_Node_Str"";
  for (int i=0; i < envElements.length; i++) {
    tmp=tmp + envElements[i] + ""String_Node_Str"";
  }
  util.DEBUG(debugId + ""String_Node_Str"" + tmp);
  final File workingDir=new File(workingDirName);
  String shellCmd=fullCmd;
{
    final String localCommand=shellCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + localCommand);
    try {
      Process proc=Runtime.getRuntime().exec(localCommand,envElements,workingDir);
      processDEBUGOutput(debugId + ""String_Node_Str"",proc);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  util.DEBUG(debugId + ""String_Node_Str"");
  util.DEBUG(""String_Node_Str"");
}","private void runUserCommandLocally(String command,String userDir,String ID){
  util.DEBUG(""String_Node_Str"");
  final String debugId=""String_Node_Str"" + ID + ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + command + ""String_Node_Str""+ userDir);
  String workingDirName=userDir;
  util.DEBUG(debugId + ""String_Node_Str"" + workingDirName);
  String tmp=""String_Node_Str"";
  util.DEBUG(debugId + command);
  final String fullCmd=command;
  String[] envElements=null;
  final File workingDir=new File(workingDirName);
  String shellCmd=fullCmd;
{
    final String localCommand=shellCmd;
    util.DEBUG(debugId + ""String_Node_Str"" + localCommand);
    try {
      Process proc=Runtime.getRuntime().exec(localCommand,envElements,workingDir);
      processDEBUGOutput(debugId + ""String_Node_Str"",proc);
    }
 catch (    Exception ex) {
      ex.printStackTrace();
    }
  }
  util.DEBUG(debugId + ""String_Node_Str"");
  util.DEBUG(""String_Node_Str"");
}"
80096,"void restartServer(String serverVM,String serverVersion,String serverHost,String interfacesToListenOn,int serverPort,String fullDbDirPath) throws Exception {
  stopServer(serverVM,serverVersion,serverHost,serverPort);
  startServer(serverVM,serverVersion,serverHost,interfacesToListenOn,serverPort,fullDbDirPath);
}","void restartServer(String serverVM,String serverVersion,String serverHost,String interfacesToListenOn,int serverPort,String dbSubDirPath) throws Exception {
  stopServer(serverVM,serverVersion,serverHost,serverPort);
  startServer(serverVM,serverVersion,serverHost,interfacesToListenOn,serverPort,dbSubDirPath);
}"
80097,"public void testReplication() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDatabasePath + FS + masterDbSubPath);
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDatabasePath + FS + slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  verifySlave();
  verifyMaster();
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
}","public void testReplication() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDbSubPath);
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  verifySlave();
  verifyMaster();
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
}"
80098,"public void testReplication() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  if (runUnReplicated) {
    util.DEBUG(""String_Node_Str"");
    initMaster(masterServerHost,replicatedDb);
    startServer(masterJvmVersion,derbyVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDatabasePath + FS + masterDbSubPath);
    runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
    stopServer(masterJvmVersion,derbyMasterVersion,masterServerHost,masterServerPort);
    util.DEBUG(""String_Node_Str"");
  }
  if (state.testPreStartedMasterServer())   return;
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDatabasePath + FS + masterDbSubPath);
  startOptionalLoad(masterPreRepl,masterDbSubPath,masterServerHost,masterServerPort);
  if (state.testPreStartedSlaveServer())   return;
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDatabasePath + FS + slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  xFindServerPID(slaveServerHost,slaveServerPort);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  startOptionalLoad(masterPostRepl,masterDbSubPath,masterServerHost,masterServerPort);
  startOptionalLoad(slavePreSlave,slaveDbSubPath,slaveServerHost,slaveServerPort);
  if (state.testPreInitSlave())   return;
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  if (state.testPreStartedSlave())   return;
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  if (state.testPreStartedMaster())   return;
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  startOptionalLoad(masterPostSlave,masterDbSubPath,masterServerHost,masterServerPort);
  startOptionalLoad(slavePostSlave,slaveDbSubPath,slaveServerHost,slaveServerPort);
  if (state.testPostStartedMasterAndSlave())   return;
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  if (state.testPreStoppedMaster())   return;
  if (state.testPreStoppedMasterServer())   return;
  if (state.testPreStoppedSlave())   return;
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  int slavePid=xFindServerPID(slaveServerHost,slaveServerPort);
  if (slavePid == -1) {
    util.DEBUG(""String_Node_Str"");
    slaveServer=startServer(jvmVersion,derbyVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDatabasePath + FS + slaveDbSubPath);
  }
 else {
    if (true) {
      util.DEBUG(""String_Node_Str"");
    }
 else {
      util.DEBUG(""String_Node_Str"");
      restartServer(jvmVersion,derbyVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDatabasePath + FS + slaveDbSubPath);
    }
  }
  verifySlave();
  int masterPid=xFindServerPID(masterServerHost,masterServerPort);
  if (masterPid == -1) {
    util.DEBUG(""String_Node_Str"");
    masterServer=startServer(jvmVersion,derbyVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDatabasePath + FS + masterDbSubPath);
  }
  verifyMaster();
  xFindServerPID(slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  if (state.testPostStoppedSlaveServer())   return;
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
  masterPid=xFindServerPID(masterServerHost,masterServerPort);
  if (masterPid != -1) {
    util.DEBUG(""String_Node_Str"");
    killMaster(masterServerHost,masterServerPort);
  }
}","public void testReplication() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  if (runUnReplicated) {
    util.DEBUG(""String_Node_Str"");
    initMaster(masterServerHost,replicatedDb);
    startServer(masterJvmVersion,derbyVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDbSubPath);
    runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
    stopServer(masterJvmVersion,derbyMasterVersion,masterServerHost,masterServerPort);
    util.DEBUG(""String_Node_Str"");
  }
  if (state.testPreStartedMasterServer())   return;
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDbSubPath);
  startOptionalLoad(masterPreRepl,masterDbSubPath,masterServerHost,masterServerPort);
  if (state.testPreStartedSlaveServer())   return;
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  xFindServerPID(slaveServerHost,slaveServerPort);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  startOptionalLoad(masterPostRepl,masterDbSubPath,masterServerHost,masterServerPort);
  startOptionalLoad(slavePreSlave,slaveDbSubPath,slaveServerHost,slaveServerPort);
  if (state.testPreInitSlave())   return;
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  if (state.testPreStartedSlave())   return;
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  if (state.testPreStartedMaster())   return;
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  startOptionalLoad(masterPostSlave,masterDbSubPath,masterServerHost,masterServerPort);
  startOptionalLoad(slavePostSlave,slaveDbSubPath,slaveServerHost,slaveServerPort);
  if (state.testPostStartedMasterAndSlave())   return;
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  if (state.testPreStoppedMaster())   return;
  if (state.testPreStoppedMasterServer())   return;
  if (state.testPreStoppedSlave())   return;
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  int slavePid=xFindServerPID(slaveServerHost,slaveServerPort);
  if (slavePid == -1) {
    util.DEBUG(""String_Node_Str"");
    slaveServer=startServer(jvmVersion,derbyVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDbSubPath);
  }
 else {
    if (true) {
      util.DEBUG(""String_Node_Str"");
    }
 else {
      util.DEBUG(""String_Node_Str"");
      restartServer(jvmVersion,derbyVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDbSubPath);
    }
  }
  verifySlave();
  int masterPid=xFindServerPID(masterServerHost,masterServerPort);
  if (masterPid == -1) {
    util.DEBUG(""String_Node_Str"");
    masterServer=startServer(jvmVersion,derbyVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDbSubPath);
  }
  verifyMaster();
  xFindServerPID(slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  if (state.testPostStoppedSlaveServer())   return;
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
  masterPid=xFindServerPID(masterServerHost,masterServerPort);
  if (masterPid != -1) {
    util.DEBUG(""String_Node_Str"");
    killMaster(masterServerHost,masterServerPort);
  }
}"
80099,"public void testReplication_Local() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDatabasePath + FS + masterDbSubPath);
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDatabasePath + FS + slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  replicationTest=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationTest);
  replicationVerify=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationVerify);
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  verifySlave();
  verifyMaster();
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
}","public void testReplication_Local() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDbSubPath);
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  replicationTest=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationTest);
  replicationVerify=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationVerify);
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  verifySlave();
  verifyMaster();
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
}"
80100,"private void _testPreStartedSlaveServer(){
  Connection conn=null;
  String db=slaveDatabasePath + ""String_Node_Str"" + ReplicationRun.slaveDbSubPath+ ""String_Node_Str""+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveServerPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(""String_Node_Str"" + msg);
    assertTrue(""String_Node_Str"" + msg,""String_Node_Str"".equals(ss));
    util.DEBUG(""String_Node_Str"");
    return;
  }
  assertTrue(""String_Node_Str"" + db + ""String_Node_Str"",false);
}","private void _testPreStartedSlaveServer(){
  Connection conn=null;
  String db=slaveDatabasePath + FS + ReplicationRun.slaveDbSubPath+ FS+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveServerPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(""String_Node_Str"" + msg);
    assertTrue(""String_Node_Str"" + msg,""String_Node_Str"".equals(ss));
    util.DEBUG(""String_Node_Str"");
    return;
  }
  assertTrue(""String_Node_Str"" + db + ""String_Node_Str"",false);
}"
80101,"private void _testPreInitSlave(){
  String db=null;
  String connectionURL=null;
  Connection conn=null;
  db=masterDatabasePath + ""String_Node_Str"" + ReplicationRun.masterDbSubPath+ ""String_Node_Str""+ replicatedDb;
  connectionURL=""String_Node_Str"" + ""String_Node_Str"" + masterServerHost + ""String_Node_Str""+ masterServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_NOT_IN_MASTER_MODE.equals(ss));
    util.DEBUG(""String_Node_Str"" + connectionURL + ""String_Node_Str""+ msg);
  }
  db=slaveDatabasePath + ""String_Node_Str"" + ReplicationRun.slaveDbSubPath+ ""String_Node_Str""+ replicatedDb;
  connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_DB_NOT_BOOTED.equals(ss));
    util.DEBUG(""String_Node_Str"" + connectionURL + ""String_Node_Str""+ msg);
  }
}","private void _testPreInitSlave(){
  String db=null;
  String connectionURL=null;
  Connection conn=null;
  db=masterDatabasePath + FS + ReplicationRun.masterDbSubPath+ FS+ replicatedDb;
  connectionURL=""String_Node_Str"" + ""String_Node_Str"" + masterServerHost + ""String_Node_Str""+ masterServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_NOT_IN_MASTER_MODE.equals(ss));
    util.DEBUG(""String_Node_Str"" + connectionURL + ""String_Node_Str""+ msg);
  }
  db=slaveDatabasePath + FS + ReplicationRun.slaveDbSubPath+ FS+ replicatedDb;
  connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_DB_NOT_BOOTED.equals(ss));
    util.DEBUG(""String_Node_Str"" + connectionURL + ""String_Node_Str""+ msg);
  }
}"
80102,"private void _testPreStartedSlave(){
  Connection conn=null;
  String db=slaveDatabasePath + ""String_Node_Str"" + ReplicationRun.slaveDbSubPath+ ""String_Node_Str""+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveReplPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  if (true)   return;
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(msg);
    assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_SLAVE_STARTED_OK.equals(ss));
  }
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(msg);
    assertTrue(""String_Node_Str"" + msg,SQLState.LOGIN_FAILED.equals(ss));
  }
}","private void _testPreStartedSlave(){
  Connection conn=null;
  String db=slaveDatabasePath + FS + ReplicationRun.slaveDbSubPath+ FS+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveReplPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  if (true)   return;
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(msg);
    assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_SLAVE_STARTED_OK.equals(ss));
  }
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(msg);
    assertTrue(""String_Node_Str"" + msg,SQLState.LOGIN_FAILED.equals(ss));
  }
}"
80103,"public void testReplication_Local_StateTest_part1() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  _testPreStartedMasterServer();
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDatabasePath + FS + masterDbSubPath);
  _testPreStartedSlaveServer();
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDatabasePath + FS + slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  _testPreInitSlave();
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  _testPreStartedSlave();
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  _testPreStartedMaster();
  replicationTest=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationTest);
  replicationVerify=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationVerify);
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  verifySlave();
  verifyMaster();
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
}","public void testReplication_Local_StateTest_part1() throws Exception {
  cleanAllTestHosts();
  initEnvironment();
  _testPreStartedMasterServer();
  initMaster(masterServerHost,replicatedDb);
  masterServer=startServer(masterJvmVersion,derbyMasterVersion,masterServerHost,ALL_INTERFACES,masterServerPort,masterDbSubPath);
  _testPreStartedSlaveServer();
  slaveServer=startServer(slaveJvmVersion,derbySlaveVersion,slaveServerHost,ALL_INTERFACES,slaveServerPort,slaveDbSubPath);
  startServerMonitor(slaveServerHost);
  bootMasterDatabase(jvmVersion,masterDatabasePath + FS + masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,null);
  _testPreInitSlave();
  initSlave(slaveServerHost,jvmVersion,replicatedDb);
  _testPreStartedSlave();
  startSlave(jvmVersion,replicatedDb,slaveServerHost,slaveServerPort,slaveServerHost,slaveReplPort,testClientHost);
  _testPreStartedMaster();
  replicationTest=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationTest);
  replicationVerify=""String_Node_Str"";
  util.DEBUG(""String_Node_Str"" + replicationVerify);
  runTest(replicationTest,jvmVersion,testClientHost,masterServerHost,masterServerPort,replicatedDb);
  failOver(jvmVersion,masterDatabasePath,masterDbSubPath,replicatedDb,masterServerHost,masterServerPort,testClientHost);
  connectPing(slaveDatabasePath + FS + slaveDbSubPath+ FS+ replicatedDb,slaveServerHost,slaveServerPort,testClientHost);
  verifySlave();
  verifyMaster();
  stopServer(jvmVersion,derbyVersion,slaveServerHost,slaveServerPort);
  stopServer(jvmVersion,derbyVersion,masterServerHost,masterServerPort);
}"
80104,"private void _testPreStartedMaster() throws Exception {
  Connection conn=null;
  String db=masterDatabasePath + ""String_Node_Str"" + ReplicationRun.masterDbSubPath+ ""String_Node_Str""+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + masterServerHost + ""String_Node_Str""+ masterServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveReplPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  util.DEBUG(""String_Node_Str"" + connectionURL);
{
    try {
      conn=DriverManager.getConnection(connectionURL);
      util.DEBUG(""String_Node_Str"" + connectionURL);
      assertTrue(""String_Node_Str"" + connectionURL,false);
    }
 catch (    SQLException se) {
      int ec=se.getErrorCode();
      String ss=se.getSQLState();
      String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
      util.DEBUG(""String_Node_Str"" + msg);
      assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_MASTER_ALREADY_BOOTED.equals(ss));
    }
  }
  util.DEBUG(""String_Node_Str"" + connectionURL);
  db=slaveDatabasePath + ""String_Node_Str"" + ReplicationRun.slaveDbSubPath+ ""String_Node_Str""+ replicatedDb;
  connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveReplPort;
  util.DEBUG(connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(""String_Node_Str"" + msg);
    assertTrue(""String_Node_Str"" + msg,SQLState.CANNOT_START_SLAVE_ALREADY_BOOTED.equals(ss));
  }
}","private void _testPreStartedMaster() throws Exception {
  Connection conn=null;
  String db=masterDatabasePath + FS + ReplicationRun.masterDbSubPath+ FS+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + masterServerHost + ""String_Node_Str""+ masterServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveReplPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  startMaster(jvmVersion,replicatedDb,masterServerHost,masterServerPort,masterServerHost,slaveServerPort,slaveServerHost,slaveReplPort);
  util.DEBUG(""String_Node_Str"" + connectionURL);
{
    try {
      conn=DriverManager.getConnection(connectionURL);
      util.DEBUG(""String_Node_Str"" + connectionURL);
      assertTrue(""String_Node_Str"" + connectionURL,false);
    }
 catch (    SQLException se) {
      int ec=se.getErrorCode();
      String ss=se.getSQLState();
      String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
      util.DEBUG(""String_Node_Str"" + msg);
      assertTrue(""String_Node_Str"" + msg,SQLState.REPLICATION_MASTER_ALREADY_BOOTED.equals(ss));
    }
  }
  util.DEBUG(""String_Node_Str"" + connectionURL);
  db=slaveDatabasePath + FS + ReplicationRun.slaveDbSubPath+ FS+ replicatedDb;
  connectionURL=""String_Node_Str"" + ""String_Node_Str"" + slaveServerHost + ""String_Node_Str""+ slaveServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveReplPort;
  util.DEBUG(connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
    util.DEBUG(""String_Node_Str"" + connectionURL);
    assertTrue(""String_Node_Str"" + connectionURL,false);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(""String_Node_Str"" + msg);
    assertTrue(""String_Node_Str"" + msg,SQLState.CANNOT_START_SLAVE_ALREADY_BOOTED.equals(ss));
  }
}"
80105,"private void _testPreStartedMasterServer(){
  Connection conn=null;
  String db=masterDatabasePath + ""String_Node_Str"" + ReplicationRun.masterDbSubPath+ ""String_Node_Str""+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + masterServerHost + ""String_Node_Str""+ masterServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveServerPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(""String_Node_Str"" + msg);
    assertTrue(""String_Node_Str"" + msg,""String_Node_Str"".equals(ss));
    util.DEBUG(""String_Node_Str"");
    return;
  }
  assertTrue(""String_Node_Str"" + db + ""String_Node_Str"",false);
}","private void _testPreStartedMasterServer(){
  Connection conn=null;
  String db=masterDatabasePath + FS + ReplicationRun.masterDbSubPath+ FS+ replicatedDb;
  String connectionURL=""String_Node_Str"" + ""String_Node_Str"" + masterServerHost + ""String_Node_Str""+ masterServerPort+ ""String_Node_Str""+ db+ ""String_Node_Str""+ ""String_Node_Str""+ slaveServerHost+ ""String_Node_Str""+ slaveServerPort;
  util.DEBUG(""String_Node_Str"" + connectionURL);
  try {
    conn=DriverManager.getConnection(connectionURL);
  }
 catch (  SQLException se) {
    int ec=se.getErrorCode();
    String ss=se.getSQLState();
    String msg=ec + ""String_Node_Str"" + ss+ ""String_Node_Str""+ se.getMessage();
    util.DEBUG(""String_Node_Str"" + msg);
    assertTrue(""String_Node_Str"" + msg,""String_Node_Str"".equals(ss));
    util.DEBUG(""String_Node_Str"");
    return;
  }
  assertTrue(""String_Node_Str"" + db + ""String_Node_Str"",false);
}"
80106,"public SSLTest(String testName){
  super(testName);
  _inputStreamHolder=new InputStream[1];
}","public SSLTest(String testName){
  super(testName);
}"
80107,"/** 
 * <p> Compose the required decorators to bring up the server in the correct configuration. </p>
 */
private static Test decorateTest(String testName){
  SSLTest sslTest=new SSLTest(testName);
  String[] startupProperties=getStartupProperties();
  String[] startupArgs=new String[]{};
  NetworkServerTestSetup networkServerTestSetup=new NetworkServerTestSetup(sslTest,startupProperties,startupArgs,true,sslTest._inputStreamHolder);
  Test testSetup=SecurityManagerSetup.noSecurityManager(networkServerTestSetup);
  testSetup=new SupportFilesSetup(testSetup,null,new String[]{""String_Node_Str""},null,new String[]{""String_Node_Str""});
  Test test=TestConfiguration.defaultServerDecorator(testSetup);
  test=TestConfiguration.changeSSLDecorator(test,""String_Node_Str"");
  return test;
}","/** 
 * <p> Compose the required decorators to bring up the server in the correct configuration. </p>
 */
private static Test decorateTest(String testName){
  SSLTest sslTest=new SSLTest(testName);
  String[] startupProperties=getStartupProperties();
  String[] startupArgs=new String[]{};
  NetworkServerTestSetup networkServerTestSetup=new NetworkServerTestSetup(sslTest,startupProperties,startupArgs,true);
  Test testSetup=SecurityManagerSetup.noSecurityManager(networkServerTestSetup);
  testSetup=new SupportFilesSetup(testSetup,null,new String[]{""String_Node_Str""},null,new String[]{""String_Node_Str""});
  Test test=TestConfiguration.defaultServerDecorator(testSetup);
  test=TestConfiguration.changeSSLDecorator(test,""String_Node_Str"");
  return test;
}"
80108,"/** 
 * <p> Compose the required decorators to bring up the server in the correct configuration. </p>
 */
private static Test decorateTest(boolean unsecureSet,boolean authenticationRequired,String customDerbyProperties,String wildCardHost,Outcome outcome){
  SecureServerTest secureServerTest=new SecureServerTest(unsecureSet,authenticationRequired,customDerbyProperties,wildCardHost,outcome);
  String[] startupProperties=getStartupProperties(authenticationRequired,customDerbyProperties);
  String[] startupArgs=getStartupArgs(unsecureSet,wildCardHost);
  NetworkServerTestSetup networkServerTestSetup=new NetworkServerTestSetup(secureServerTest,startupProperties,startupArgs,secureServerTest._outcome.serverShouldComeUp(),secureServerTest._inputStreamHolder);
  secureServerTest.nsTestSetup=networkServerTestSetup;
  Test testSetup=SecurityManagerSetup.noSecurityManager(networkServerTestSetup);
  if (customDerbyProperties != null) {
    testSetup=new SupportFilesSetup(testSetup,null,new String[]{""String_Node_Str""},null,new String[]{""String_Node_Str""});
  }
  Test test=TestConfiguration.defaultServerDecorator(testSetup);
  test=TestConfiguration.changeUserDecorator(test,SST_USER_NAME,SST_PASSWORD);
  return test;
}","/** 
 * <p> Compose the required decorators to bring up the server in the correct configuration. </p>
 */
private static Test decorateTest(boolean unsecureSet,boolean authenticationRequired,String customDerbyProperties,String wildCardHost,Outcome outcome){
  SecureServerTest secureServerTest=new SecureServerTest(unsecureSet,authenticationRequired,customDerbyProperties,wildCardHost,outcome);
  String[] startupProperties=getStartupProperties(authenticationRequired,customDerbyProperties);
  String[] startupArgs=getStartupArgs(unsecureSet,wildCardHost);
  NetworkServerTestSetup networkServerTestSetup=new NetworkServerTestSetup(secureServerTest,startupProperties,startupArgs,secureServerTest._outcome.serverShouldComeUp());
  secureServerTest.nsTestSetup=networkServerTestSetup;
  Test testSetup=SecurityManagerSetup.noSecurityManager(networkServerTestSetup);
  if (customDerbyProperties != null) {
    testSetup=new SupportFilesSetup(testSetup,null,new String[]{""String_Node_Str""},null,new String[]{""String_Node_Str""});
  }
  Test test=TestConfiguration.defaultServerDecorator(testSetup);
  test=TestConfiguration.changeUserDecorator(test,SST_USER_NAME,SST_PASSWORD);
  return test;
}"
80109,"/** 
 * <p> Run a NetworkServerControl command. </p>
 */
private String runServerCommand(String commandSpecifics) throws Exception {
  String portNumber=Integer.toString(getTestConfiguration().getPort());
  StringBuffer buffer=new StringBuffer();
  String classpath=getSystemProperty(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(classpath);
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + portNumber + ""String_Node_Str""+ commandSpecifics);
  final String command=buffer.toString();
  println(""String_Node_Str"" + command);
  Process serverProcess=(Process)AccessController.doPrivileged(new PrivilegedAction(){
    public Object run(){
      Process result=null;
      try {
        result=Runtime.getRuntime().exec(command);
      }
 catch (      Exception ex) {
        ex.printStackTrace();
      }
      return result;
    }
  }
);
  InputStream is=serverProcess.getInputStream();
  return getProcessOutput(is,10000);
}","/** 
 * <p> Run a NetworkServerControl command. </p>
 */
private String runServerCommand(String commandSpecifics) throws Exception {
  String portNumber=Integer.toString(getTestConfiguration().getPort());
  StringBuffer buffer=new StringBuffer();
  String classpath=getSystemProperty(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(classpath);
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + portNumber + ""String_Node_Str""+ commandSpecifics);
  final String command=buffer.toString();
  println(""String_Node_Str"" + command);
  Process serverProcess=(Process)AccessController.doPrivileged(new PrivilegedAction(){
    public Object run(){
      Process result=null;
      try {
        result=Runtime.getRuntime().exec(command);
      }
 catch (      Exception ex) {
        ex.printStackTrace();
      }
      return result;
    }
  }
);
  SpawnedProcess spawned=new SpawnedProcess(serverProcess,commandSpecifics);
  assertEquals(0,spawned.complete(false));
  return spawned.getFullServerOutput();
}"
80110,"private String getServerOutput() throws Exception {
  return getProcessOutput(_inputStreamHolder[0],1000);
}","private String getServerOutput() throws Exception {
  return nsTestSetup.getServerProcess().getNextServerOutput();
}"
80111,"private boolean serverCameUp() throws Exception {
  return NetworkServerTestSetup.pingForServerUp(NetworkServerTestSetup.getNetworkServerControl(),nsTestSetup.getServerProcess(),true);
}","private boolean serverCameUp() throws Exception {
  return NetworkServerTestSetup.pingForServerUp(NetworkServerTestSetup.getNetworkServerControl(),nsTestSetup.getServerProcess().getProcess(),true);
}"
80112,"public SecureServerTest(boolean unsecureSet,boolean authenticationRequired,String customDerbyProperties,String wildCardHost,Outcome outcome){
  super(""String_Node_Str"");
  _unsecureSet=unsecureSet;
  _authenticationRequired=authenticationRequired;
  _customDerbyProperties=customDerbyProperties;
  _wildCardHost=wildCardHost;
  _outcome=outcome;
  _inputStreamHolder=new InputStream[1];
}","public SecureServerTest(boolean unsecureSet,boolean authenticationRequired,String customDerbyProperties,String wildCardHost,Outcome outcome){
  super(""String_Node_Str"");
  _unsecureSet=unsecureSet;
  _authenticationRequired=authenticationRequired;
  _customDerbyProperties=customDerbyProperties;
  _wildCardHost=wildCardHost;
  _outcome=outcome;
}"
80113,"/** 
 * <p> Compose the required decorators to bring up the server in the correct configuration. </p>
 */
private static Test decorateTest(String testName,String[] startupProperties,String[] startupArgs,boolean startServer){
  ServerPropertiesTest spt=new ServerPropertiesTest(testName);
  String[] startupProps;
  if (startupProperties == null)   startupProps=new String[]{};
 else   startupProps=startupProperties;
  if (startupArgs == null)   startupArgs=new String[]{};
  NetworkServerTestSetup networkServerTestSetup;
  if (startServer) {
    networkServerTestSetup=new NetworkServerTestSetup(spt,startupProps,startupArgs,true,spt._inputStreamHolder);
  }
 else {
    networkServerTestSetup=new NetworkServerTestSetup(spt,true,false);
  }
  Test test=decorateWithPolicy(networkServerTestSetup);
  test=TestConfiguration.defaultServerDecorator(test);
  return test;
}","/** 
 * <p> Compose the required decorators to bring up the server in the correct configuration. </p>
 */
private static Test decorateTest(String testName,String[] startupProperties,String[] startupArgs,boolean startServer){
  ServerPropertiesTest spt=new ServerPropertiesTest(testName);
  String[] startupProps;
  if (startupProperties == null)   startupProps=new String[]{};
 else   startupProps=startupProperties;
  if (startupArgs == null)   startupArgs=new String[]{};
  NetworkServerTestSetup networkServerTestSetup;
  if (startServer) {
    networkServerTestSetup=new NetworkServerTestSetup(spt,startupProps,startupArgs,true);
  }
 else {
    networkServerTestSetup=new NetworkServerTestSetup(spt,true,false);
  }
  Test test=decorateWithPolicy(networkServerTestSetup);
  test=TestConfiguration.defaultServerDecorator(test);
  return test;
}"
80114,"public void tearDown() throws Exception {
  super.tearDown();
  POLICY_FILE_NAME=null;
  TARGET_POLICY_FILE_NAME=null;
  _inputStreamHolder=null;
  if (portsSoFar != null) {
    for (int i=0; i < portsSoFar.length; i++) {
      try {
        shutdownServer(portsSoFar[i],true);
      }
 catch (      SQLException e) {
        fail(""String_Node_Str"" + portsSoFar[i]);
      }
    }
    portsSoFar=null;
  }
}","public void tearDown() throws Exception {
  super.tearDown();
  POLICY_FILE_NAME=null;
  TARGET_POLICY_FILE_NAME=null;
  if (portsSoFar != null) {
    for (int i=0; i < portsSoFar.length; i++) {
      try {
        shutdownServer(portsSoFar[i],true);
      }
 catch (      SQLException e) {
        fail(""String_Node_Str"" + portsSoFar[i]);
      }
    }
    portsSoFar=null;
  }
}"
80115,"public ServerPropertiesTest(String name){
  super(name);
  _inputStreamHolder=new InputStream[1];
}","public ServerPropertiesTest(String name){
  super(name);
}"
80116,"protected static Test suite(Class testClass,String suiteName){
  TestSuite outerSuite=new TestSuite(suiteName);
  Test platform=new TestSuite(testClass,suiteName + ""String_Node_Str"");
  platform=TestConfiguration.clientServerDecorator(platform);
  platform=JMXConnectionDecorator.platformMBeanServer(platform);
  platform=SecurityManagerSetup.noSecurityManager(platform);
  outerSuite.addTest(platform);
  Test suite=new TestSuite(testClass,suiteName + ""String_Node_Str"");
  suite=JMXConnectionDecorator.remoteNoSecurity(suite);
  NetworkServerTestSetup networkServerTestSetup=new NetworkServerTestSetup(suite,getCommandLineProperties(),new String[0],true,new InputStream[1]);
  Test testSetup=SecurityManagerSetup.noSecurityManager(networkServerTestSetup);
  outerSuite.addTest(TestConfiguration.defaultServerDecorator(testSetup));
  return outerSuite;
}","protected static Test suite(Class testClass,String suiteName){
  TestSuite outerSuite=new TestSuite(suiteName);
  Test platform=new TestSuite(testClass,suiteName + ""String_Node_Str"");
  platform=TestConfiguration.clientServerDecorator(platform);
  platform=JMXConnectionDecorator.platformMBeanServer(platform);
  platform=SecurityManagerSetup.noSecurityManager(platform);
  outerSuite.addTest(platform);
  Test suite=new TestSuite(testClass,suiteName + ""String_Node_Str"");
  suite=JMXConnectionDecorator.remoteNoSecurity(suite);
  NetworkServerTestSetup networkServerTestSetup=new NetworkServerTestSetup(suite,getCommandLineProperties(),new String[0],true);
  Test testSetup=SecurityManagerSetup.noSecurityManager(networkServerTestSetup);
  outerSuite.addTest(TestConfiguration.defaultServerDecorator(testSetup));
  return outerSuite;
}"
80117,"/** 
 * Initializer for a RowNumberColumn node
 * @paran arg1 The window definition
 * @exception StandardException
 */
public void init(Object arg1) throws StandardException {
  this.init();
  setWindowNode((WindowNode)arg1);
}","/** 
 * Initializer for a RowNumberColumn node
 * @param arg1 The window definition
 * @exception StandardException
 */
public void init(Object arg1) throws StandardException {
  this.init();
  setWindowNode((WindowNode)arg1);
}"
80118,"/** 
 * setWindowNode
 * @param the WindowNode with the window definition for this window function column 
 */
public void setWindowNode(WindowNode wn){
  this.windowNode=wn;
}","/** 
 * setWindowNode
 * @param wn The WindowNode with the window definition for this window function column 
 */
public void setWindowNode(WindowNode wn){
  this.windowNode=wn;
}"
80119,"/** 
 * Window functions do not have a (base)tablename, so we return null.
 * @override
 */
public String getTableName(){
  return null;
}","/** 
 * Window functions do not have a (base)tablename, so we return null. Overrides method from parent class.
 */
public String getTableName(){
  return null;
}"
80120,"/** 
 * Set the windowFunctionLevel of this WindowNode in case there are  multiple window functions in a RCL.
 * @param the window function level of this window function column 
 */
public void setWindowFunctionLevel(int level){
  this.windowFunctionLevel=level;
}","/** 
 * Set the windowFunctionLevel of this WindowNode in case there are  multiple window functions in a RCL.
 * @param level The window function level of this window function column 
 */
public void setWindowFunctionLevel(int level){
  this.windowFunctionLevel=level;
}"
80121,"/** 
 * Get a catalog type that corresponds to a SQL Row Multiset
 * @param columnNames   Names of the columns in the Row Muliset
 * @param types                 Types of the columns in the Row Muliset
 * @return	A new DataTypeDescriptor describing the SQL Row Multiset
 */
public static TypeDescriptor getRowMultiSet(String[] columnNames,TypeDescriptor[] catalogTypes){
  RowMultiSetImpl rms=new RowMultiSetImpl(columnNames,catalogTypes);
  TypeId typeID=new TypeId(StoredFormatIds.ROW_MULTISET_CATALOG_ID,rms);
  return new DataTypeDescriptor(typeID,true).getCatalogType();
}","/** 
 * Get a catalog type that corresponds to a SQL Row Multiset
 * @param columnNames   Names of the columns in the Row Muliset
 * @param catalogTypes  Types of the columns in the Row Muliset
 * @return	A new DataTypeDescriptor describing the SQL Row Multiset
 */
public static TypeDescriptor getRowMultiSet(String[] columnNames,TypeDescriptor[] catalogTypes){
  RowMultiSetImpl rms=new RowMultiSetImpl(columnNames,catalogTypes);
  TypeId typeID=new TypeId(StoredFormatIds.ROW_MULTISET_CATALOG_ID,rms);
  return new DataTypeDescriptor(typeID,true).getCatalogType();
}"
80122,"/** 
 * Return locator for this lob.
 * @return
 */
public int getLocator(){
  return locator;
}","/** 
 * Return locator for this lob.
 * @return The locator identifying this lob.
 */
public int getLocator(){
  return locator;
}"
80123,"/** 
 * Private helper method. Runs the same test for different generated identity columns.
 * @param dataType SMALLINT, INT, or BIGINT
 * @param generatedType BY DEFAULT or ALWAYS
 * @throws Exception all errors passed on to JUnit
 */
private void testGeneratedIdentity(String dataType,String generateType) throws Exception {
  Statement s=createStatement();
  s.execute(""String_Node_Str"" + dataType + ""String_Node_Str""+ generateType+ ""String_Node_Str""+ ""String_Node_Str"");
  PreparedStatement implicit=prepareStatement(""String_Node_Str"");
  implicit.executeUpdate();
  implicit.executeUpdate();
  implicit.executeUpdate();
  PreparedStatement explicit=prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
  explicit.executeUpdate();
  explicit.executeUpdate();
  explicit.executeUpdate();
}","/** 
 * Private helper method. Runs the same test for different generated identity columns.
 * @param dataType SMALLINT, INT, or BIGINT
 * @param generatedType BY DEFAULT or ALWAYS
 * @throws Exception all errors passed on to JUnit
 */
private void testGeneratedIdentity(String dataType,String generatedType) throws Exception {
  Statement s=createStatement();
  s.execute(""String_Node_Str"" + dataType + ""String_Node_Str""+ generatedType+ ""String_Node_Str""+ ""String_Node_Str"");
  PreparedStatement implicit=prepareStatement(""String_Node_Str"");
  implicit.executeUpdate();
  implicit.executeUpdate();
  implicit.executeUpdate();
  PreparedStatement explicit=prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
  explicit.executeUpdate();
  explicit.executeUpdate();
  explicit.executeUpdate();
}"
80124,"/** 
 * See assertRowInResultSet(...) above.
 * @param BitSet colsToCheck If non-null then for every bit bthat is set in colsToCheck, we'll compare the (b+1)-th column of the received result set's current row to the i-th column of expectedRow, where 0 <= i < # bits set in colsToCheck. So if colsToCheck is { 0, 3 } then expectedRow should have two objects and we'll check that: expectedRow[0].equals(rs.getXXX(1)); expectedRow[1].equals(rs.getXXX(4)); If colsToCheck is null then the (i+1)-th column in the result set is compared to the i-th column in expectedRow, where 0 <= i < expectedRow.length.
 */
private static void assertRowInResultSet(ResultSet rs,int rowNum,Object[] expectedRow,boolean asTrimmedStrings,BitSet colsToCheck) throws SQLException {
  int cPos=0;
  ResultSetMetaData rsmd=rs.getMetaData();
  for (int i=0; i < expectedRow.length; i++) {
    cPos=(colsToCheck == null) ? (i + 1) : colsToCheck.nextSetBit(cPos) + 1;
    Object obj;
    if (asTrimmedStrings) {
      if (expectedRow[i] != null)       expectedRow[i]=((String)expectedRow[i]).trim();
      if ((expectedRow[i] != null) && (rsmd.getColumnType(cPos) == Types.SMALLINT)) {
        String s=expectedRow[i].toString();
        if (s.equals(""String_Node_Str"") || s.equals(""String_Node_Str""))         obj=(rs.getShort(cPos) == 0) ? ""String_Node_Str"" : ""String_Node_Str"";
 else         obj=rs.getString(cPos);
      }
 else {
        obj=rs.getString(cPos);
      }
      if (obj != null)       obj=((String)obj).trim();
    }
 else     obj=rs.getObject(cPos);
    boolean ok=(rs.wasNull() && (expectedRow[i] == null)) || (!rs.wasNull() && (expectedRow[i] != null) && (expectedRow[i].equals(obj) || (obj instanceof byte[] && Arrays.equals((byte[])obj,(byte[])expectedRow[i]))));
    if (!ok) {
      Object expected=expectedRow[i];
      Object found=obj;
      if (obj instanceof byte[]) {
        expected=bytesToString((byte[])expectedRow[i]);
        found=bytesToString((byte[])obj);
      }
      Assert.fail(""String_Node_Str"" + rsmd.getColumnName(cPos) + ""String_Node_Str""+ rowNum+ ""String_Node_Str""+ expected+ ""String_Node_Str""+ found+ ""String_Node_Str"");
    }
    if (rs.wasNull())     assertResultColumnNullable(rsmd,cPos);
  }
}","/** 
 * See assertRowInResultSet(...) above.
 * @param colsToCheck If non-null then for every bit bthat is set in colsToCheck, we'll compare the (b+1)-th column of the received result set's current row to the i-th column of expectedRow, where 0 <= i < # bits set in colsToCheck. So if colsToCheck is { 0, 3 } then expectedRow should have two objects and we'll check that: expectedRow[0].equals(rs.getXXX(1)); expectedRow[1].equals(rs.getXXX(4)); If colsToCheck is null then the (i+1)-th column in the result set is compared to the i-th column in expectedRow, where 0 <= i < expectedRow.length.
 */
private static void assertRowInResultSet(ResultSet rs,int rowNum,Object[] expectedRow,boolean asTrimmedStrings,BitSet colsToCheck) throws SQLException {
  int cPos=0;
  ResultSetMetaData rsmd=rs.getMetaData();
  for (int i=0; i < expectedRow.length; i++) {
    cPos=(colsToCheck == null) ? (i + 1) : colsToCheck.nextSetBit(cPos) + 1;
    Object obj;
    if (asTrimmedStrings) {
      if (expectedRow[i] != null)       expectedRow[i]=((String)expectedRow[i]).trim();
      if ((expectedRow[i] != null) && (rsmd.getColumnType(cPos) == Types.SMALLINT)) {
        String s=expectedRow[i].toString();
        if (s.equals(""String_Node_Str"") || s.equals(""String_Node_Str""))         obj=(rs.getShort(cPos) == 0) ? ""String_Node_Str"" : ""String_Node_Str"";
 else         obj=rs.getString(cPos);
      }
 else {
        obj=rs.getString(cPos);
      }
      if (obj != null)       obj=((String)obj).trim();
    }
 else     obj=rs.getObject(cPos);
    boolean ok=(rs.wasNull() && (expectedRow[i] == null)) || (!rs.wasNull() && (expectedRow[i] != null) && (expectedRow[i].equals(obj) || (obj instanceof byte[] && Arrays.equals((byte[])obj,(byte[])expectedRow[i]))));
    if (!ok) {
      Object expected=expectedRow[i];
      Object found=obj;
      if (obj instanceof byte[]) {
        expected=bytesToString((byte[])expectedRow[i]);
        found=bytesToString((byte[])obj);
      }
      Assert.fail(""String_Node_Str"" + rsmd.getColumnName(cPos) + ""String_Node_Str""+ rowNum+ ""String_Node_Str""+ expected+ ""String_Node_Str""+ found+ ""String_Node_Str"");
    }
    if (rs.wasNull())     assertResultColumnNullable(rsmd,cPos);
  }
}"
80125,"public void testAmbigiousMethods() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}","public void testAmbigiousMethods() throws SQLException {
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}"
80126,"public void testOutparams() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  String[] sysaliasDefinition={""String_Node_Str""};
  String[] dbMetadataDefinition={""String_Node_Str""};
  String[] columnDefinition={""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  try {
    s.execute(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    String expectedSQLState=""String_Node_Str"";
    if (usingDerbyNetClient())     expectedSQLState=""String_Node_Str"";
    assertSQLState(expectedSQLState,sqle);
  }
  if (usingEmbedded())   try {
    PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    String expectedSQLState=""String_Node_Str"";
    assertSQLState(expectedSQLState,sqle);
  }
  CallableStatement op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.INTEGER);
  op.setInt(2,7);
  op.execute();
  assertEquals(14,op.getInt(1));
  assertFalse(op.wasNull());
  op.close();
  s.execute(""String_Node_Str"");
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  try {
    s.execute(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    String expectedSQLState=""String_Node_Str"";
    if (usingDerbyNetClient())     expectedSQLState=""String_Node_Str"";
    assertSQLState(expectedSQLState,sqle);
  }
  if (!usingDerbyNetClient()) {
    try {
      PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      String expectedSQLState=""String_Node_Str"";
      assertSQLState(expectedSQLState,sqle);
    }
  }
  op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.INTEGER);
  op.setInt(1,3);
  op.setInt(2,7);
  op.execute();
  assertEquals(17,op.getInt(1));
  assertFalse(op.wasNull());
  op.close();
  s.execute(""String_Node_Str"");
  op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.CHAR);
  op.setString(1,""String_Node_Str"");
  op.setInt(2,8);
  op.execute();
  assertEquals(""String_Node_Str"",op.getString(1));
  assertFalse(op.wasNull());
  op.close();
  s.execute(""String_Node_Str"");
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.DECIMAL);
  op.setString(2,null);
  op.execute();
  assertNull(op.getBigDecimal(1));
  assertTrue(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  op.setString(2,""String_Node_Str"");
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.clearParameters();
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  if (usingEmbedded()) {
    try {
      op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
    try {
      op.setBigDecimal(1,null);
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
    try {
      op.setNull(1,Types.DECIMAL);
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
  }
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  try {
    op.getString(2);
    fail(""String_Node_Str"" + op.getString(2) + ""String_Node_Str""+ op.wasNull());
  }
 catch (  SQLException sqle) {
    if (usingDerbyNetClient())     assertSQLState(""String_Node_Str"",sqle);
 else     assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  op=conn.prepareCall(""String_Node_Str"");
  op.setString(2,""String_Node_Str"");
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    if (usingEmbedded())     assertSQLState(""String_Node_Str"",sqle);
 else     assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  s.execute(""String_Node_Str"");
  op=conn.prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.DECIMAL);
  op.setString(2,null);
  op.setBigDecimal(1,null);
  op.execute();
  assertNull(op.getBigDecimal(1));
  assertTrue(op.wasNull());
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  op.execute();
  assertNull(op.getBigDecimal(1));
  assertTrue(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  if (usingEmbedded()) {
    op.execute();
    assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
    assertFalse(op.wasNull());
  }
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  try {
    op.execute();
    fail(""String_Node_Str"" + op.getBigDecimal(1) + ""String_Node_Str""+ op.wasNull());
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  try {
    op.execute();
    fail(""String_Node_Str"" + op.getBigDecimal(1) + ""String_Node_Str""+ op.wasNull());
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.clearParameters();
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  if (usingEmbedded()) {
    op.clearParameters();
    op.setString(2,""String_Node_Str"");
    try {
      op.execute();
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
  }
  op.clearParameters();
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  op=conn.prepareCall(""String_Node_Str"");
  op.setString(2,""String_Node_Str"");
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    if (usingDerbyNetClient())     assertSQLState(""String_Node_Str"",sqle);
 else     assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}","public void testOutparams() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  String[] sysaliasDefinition={""String_Node_Str""};
  String[] dbMetadataDefinition={""String_Node_Str""};
  String[] columnDefinition={""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  try {
    s.execute(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    String expectedSQLState=""String_Node_Str"";
    if (usingDerbyNetClient())     expectedSQLState=""String_Node_Str"";
    assertSQLState(expectedSQLState,sqle);
  }
  if (usingEmbedded())   try {
    prepareStatement(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    String expectedSQLState=""String_Node_Str"";
    assertSQLState(expectedSQLState,sqle);
  }
  CallableStatement op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.INTEGER);
  op.setInt(2,7);
  op.execute();
  assertEquals(14,op.getInt(1));
  assertFalse(op.wasNull());
  op.close();
  s.execute(""String_Node_Str"");
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  try {
    s.execute(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    String expectedSQLState=""String_Node_Str"";
    if (usingDerbyNetClient())     expectedSQLState=""String_Node_Str"";
    assertSQLState(expectedSQLState,sqle);
  }
  if (!usingDerbyNetClient()) {
    try {
      prepareStatement(""String_Node_Str"");
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      String expectedSQLState=""String_Node_Str"";
      assertSQLState(expectedSQLState,sqle);
    }
  }
  op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.INTEGER);
  op.setInt(1,3);
  op.setInt(2,7);
  op.execute();
  assertEquals(17,op.getInt(1));
  assertFalse(op.wasNull());
  op.close();
  s.execute(""String_Node_Str"");
  op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.CHAR);
  op.setString(1,""String_Node_Str"");
  op.setInt(2,8);
  op.execute();
  assertEquals(""String_Node_Str"",op.getString(1));
  assertFalse(op.wasNull());
  op.close();
  s.execute(""String_Node_Str"");
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  op=prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.DECIMAL);
  op.setString(2,null);
  op.execute();
  assertNull(op.getBigDecimal(1));
  assertTrue(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  op.setString(2,""String_Node_Str"");
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.clearParameters();
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  if (usingEmbedded()) {
    try {
      op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
    try {
      op.setBigDecimal(1,null);
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
    try {
      op.setNull(1,Types.DECIMAL);
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
  }
  op.setString(2,""String_Node_Str"");
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  assertFalse(op.wasNull());
  try {
    op.getString(2);
    fail(""String_Node_Str"" + op.getString(2) + ""String_Node_Str""+ op.wasNull());
  }
 catch (  SQLException sqle) {
    if (usingDerbyNetClient())     assertSQLState(""String_Node_Str"",sqle);
 else     assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  op=conn.prepareCall(""String_Node_Str"");
  op.setString(2,""String_Node_Str"");
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    if (usingEmbedded())     assertSQLState(""String_Node_Str"",sqle);
 else     assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  s.execute(""String_Node_Str"");
  op=conn.prepareCall(""String_Node_Str"");
  op.registerOutParameter(1,Types.DECIMAL);
  op.setString(2,null);
  op.setBigDecimal(1,null);
  op.execute();
  assertNull(op.getBigDecimal(1));
  assertTrue(op.wasNull());
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  op.execute();
  assertNull(op.getBigDecimal(1));
  assertTrue(op.wasNull());
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  op.execute();
  assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
  if (usingEmbedded()) {
    op.execute();
    assertEquals(""String_Node_Str"",op.getBigDecimal(1).toString());
    assertFalse(op.wasNull());
  }
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  try {
    op.execute();
    fail(""String_Node_Str"" + op.getBigDecimal(1) + ""String_Node_Str""+ op.wasNull());
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.setString(2,""String_Node_Str"");
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  try {
    op.execute();
    fail(""String_Node_Str"" + op.getBigDecimal(1) + ""String_Node_Str""+ op.wasNull());
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.clearParameters();
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  if (usingEmbedded()) {
    op.clearParameters();
    op.setString(2,""String_Node_Str"");
    try {
      op.execute();
      fail(""String_Node_Str"");
    }
 catch (    SQLException sqle) {
      assertSQLState(""String_Node_Str"",sqle);
    }
  }
  op.clearParameters();
  op.setBigDecimal(1,new BigDecimal(""String_Node_Str""));
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  op=conn.prepareCall(""String_Node_Str"");
  op.setString(2,""String_Node_Str"");
  try {
    op.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    if (usingDerbyNetClient())     assertSQLState(""String_Node_Str"",sqle);
 else     assertSQLState(""String_Node_Str"",sqle);
  }
  op.close();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}"
80127,"/** 
 * Tests the exception that gets thrown at runtime when the external method for a SQL procedure doesn't exist -- there's no check for existence at CREATE time, the check occurs at runtime.
 * @throws SQLException
 */
public void testDelayedClassChecking() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}","/** 
 * Tests the exception that gets thrown at runtime when the external method for a SQL procedure doesn't exist -- there's no check for existence at CREATE time, the check occurs at runtime.
 * @throws SQLException
 */
public void testDelayedClassChecking() throws SQLException {
  Statement s=createStatement();
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  s.execute(""String_Node_Str"" + ""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}"
80128,"public void testSqlProcedures() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  String[] sysaliasDefinition={""String_Node_Str""};
  String[] dbMetadataDefinition={""String_Node_Str""};
  String[] columnDefinition={""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  CallableStatement ir1=conn.prepareCall(""String_Node_Str"");
  ir1.setInt(1,1);
  ir1.execute();
  ir1.setInt(1,2);
  ir1.execute();
  try {
    ir1.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  ir1.setString(1,""String_Node_Str"");
  ir1.execute();
  ir1.close();
  ir1=conn.prepareCall(""String_Node_Str"");
  ir1.setInt(1,7);
  ir1.execute();
  CallableStatement ir2=conn.prepareCall(""String_Node_Str"");
  ir2.setInt(1,4);
  ir2.setInt(2,4);
  ir2.execute();
  ir2.setInt(1,5);
  ir2.setString(2,""String_Node_Str"");
  ir2.execute();
  ir2.setInt(1,6);
  ir2.setString(2,""String_Node_Str"");
  ir2.execute();
  ir1.close();
  ir2.close();
  if (!conn.getAutoCommit())   conn.commit();
  String[][] t1Results={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  ResultSet rs=s.executeQuery(""String_Node_Str"");
  JDBC.assertFullResultSet(rs,t1Results);
  if (!conn.getAutoCommit())   conn.commit();
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}","public void testSqlProcedures() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  String[] sysaliasDefinition={""String_Node_Str""};
  String[] dbMetadataDefinition={""String_Node_Str""};
  String[] columnDefinition={""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  CallableStatement ir1=prepareCall(""String_Node_Str"");
  ir1.setInt(1,1);
  ir1.execute();
  ir1.setInt(1,2);
  ir1.execute();
  try {
    ir1.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException sqle) {
    assertSQLState(""String_Node_Str"",sqle);
  }
  ir1.setString(1,""String_Node_Str"");
  ir1.execute();
  ir1.close();
  ir1=conn.prepareCall(""String_Node_Str"");
  ir1.setInt(1,7);
  ir1.execute();
  CallableStatement ir2=conn.prepareCall(""String_Node_Str"");
  ir2.setInt(1,4);
  ir2.setInt(2,4);
  ir2.execute();
  ir2.setInt(1,5);
  ir2.setString(2,""String_Node_Str"");
  ir2.execute();
  ir2.setInt(1,6);
  ir2.setString(2,""String_Node_Str"");
  ir2.execute();
  ir1.close();
  ir2.close();
  if (!conn.getAutoCommit())   conn.commit();
  String[][] t1Results={{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  ResultSet rs=s.executeQuery(""String_Node_Str"");
  JDBC.assertFullResultSet(rs,t1Results);
  if (!conn.getAutoCommit())   conn.commit();
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}"
80129,"public static void sqlControl4(int sqlc,String[] e1,String[] e2,String[] e3,String[] e4,String[] e5,String[] e6,String[] e7,String[] e8) throws SQLException {
  Connection conn=DriverManager.getConnection(""String_Node_Str"");
  Statement s=conn.createStatement();
  String sql=""String_Node_Str"" + sqlc + ""String_Node_Str"";
  e1[0]=sql;
  CallableStatement cs1=conn.prepareCall(sql);
  try {
    for (int rop=1; rop <= 7; rop++) {
      cs1.registerOutParameter(rop,Types.VARCHAR);
    }
    cs1.execute();
    e2[0]=cs1.getString(1);
    e3[0]=cs1.getString(2);
    e4[0]=cs1.getString(3);
    e5[0]=cs1.getString(4);
    e6[0]=cs1.getString(5);
    e7[0]=cs1.getString(6);
    e8[0]=cs1.getString(7);
  }
 catch (  SQLException sqle) {
    StringBuffer sb=new StringBuffer(128);
    sb.append(""String_Node_Str"");
    do {
      sb.append(""String_Node_Str"");
      String ss=sqle.getSQLState();
      if (ss == null)       ss=""String_Node_Str"";
      sb.append(ss);
      sqle=sqle.getNextException();
    }
 while (sqle != null);
    e2[0]=sb.toString();
  }
  cs1.close();
  conn.close();
}","public static void sqlControl4(int sqlc,String[] e1,String[] e2,String[] e3,String[] e4,String[] e5,String[] e6,String[] e7,String[] e8) throws SQLException {
  Connection conn=DriverManager.getConnection(""String_Node_Str"");
  String sql=""String_Node_Str"" + sqlc + ""String_Node_Str"";
  e1[0]=sql;
  CallableStatement cs1=conn.prepareCall(sql);
  try {
    for (int rop=1; rop <= 7; rop++) {
      cs1.registerOutParameter(rop,Types.VARCHAR);
    }
    cs1.execute();
    e2[0]=cs1.getString(1);
    e3[0]=cs1.getString(2);
    e4[0]=cs1.getString(3);
    e5[0]=cs1.getString(4);
    e6[0]=cs1.getString(5);
    e7[0]=cs1.getString(6);
    e8[0]=cs1.getString(7);
  }
 catch (  SQLException sqle) {
    StringBuffer sb=new StringBuffer(128);
    sb.append(""String_Node_Str"");
    do {
      sb.append(""String_Node_Str"");
      String ss=sqle.getSQLState();
      if (ss == null)       ss=""String_Node_Str"";
      sb.append(ss);
      sqle=sqle.getNextException();
    }
 while (sqle != null);
    e2[0]=sb.toString();
  }
  cs1.close();
  conn.close();
}"
80130,"/** 
 * 1. basic testing 2. correct auto commit logic 3. correct holdability (JDBC 3)
 */
public void testDynamicResultSets() throws SQLException {
  Connection conn=getConnection();
  Connection conn2=openDefaultConnection();
  Statement s=createStatement();
  assertStatementError(""String_Node_Str"",s,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  String[] sysaliasDefinition={""String_Node_Str""};
  String[] dbMetadataDefinition={""String_Node_Str""};
  String[] columnDefinition={""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  CallableStatement drs1=conn.prepareCall(""String_Node_Str"");
  drs1.setInt(1,3);
  drs1.execute();
  ResultSet rs=drs1.getResultSet();
  String[][] drsResult={{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,drsResult);
  drs1.close();
  s.execute(""String_Node_Str"");
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  CallableStatement drs2;
  drs2=conn.prepareCall(""String_Node_Str"");
  drs2.setInt(1,2);
  drs2.setInt(2,6);
  drs2.execute();
  rs=drs2.getResultSet();
  String[][] drs2Results={{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,drs2Results);
  assertTrue(drs2.getMoreResults());
  drs2Results=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  rs=drs2.getResultSet();
  JDBC.assertFullResultSet(rs,drs2Results);
  drs2.setInt(1,2);
  drs2.setInt(2,99);
  assertTrue(drs2.execute());
  rs=drs2.getResultSet();
  drs2Results=new String[][]{{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,drs2Results);
  assertFalse(drs2.getMoreResults());
  drs2.setInt(1,2);
  drs2.setInt(2,199);
  assertFalse(drs2.execute());
  assertFalse(drs2.getMoreResults());
  drs2.setInt(1,2);
  drs2.setInt(2,299);
  assertTrue(drs2.execute());
  drs2Results=new String[][]{{""String_Node_Str"",""String_Node_Str""}};
  rs=drs2.getResultSet();
  JDBC.assertFullResultSet(rs,drs2Results);
  assertTrue(drs2.getMoreResults());
  rs=drs2.getResultSet();
  JDBC.assertEmpty(rs);
  drs2.setInt(1,2);
  drs2.setInt(2,2);
  drs2.execute();
  ResultSet lastResultSet=null;
  int pass=1;
  do {
    if (lastResultSet != null) {
      try {
        lastResultSet.next();
        fail(""String_Node_Str"");
      }
 catch (      SQLException sqle) {
        assertSQLState(""String_Node_Str"",sqle);
      }
    }
    lastResultSet=drs2.getResultSet();
    if ((pass == 1) || (pass == 2))     assertNotNull(""String_Node_Str"" + pass,lastResultSet);
 else     if (pass == 3)     assertNull(lastResultSet);
    pass++;
  }
 while (drs2.getMoreResults() || lastResultSet != null);
  checkCommitWithMultipleResultSets(drs2,conn2,""String_Node_Str"");
  checkCommitWithMultipleResultSets(drs2,conn2,""String_Node_Str"");
  checkCommitWithMultipleResultSets(drs2,conn2,""String_Node_Str"");
  drs2.close();
  drs2=conn.prepareCall(""String_Node_Str"");
  drs2.setInt(1,2);
  drs2.setInt(2,6);
  drs2.execute();
  rs=drs2.getResultSet();
  String[][] expectedRows={{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expectedRows);
  drs2.close();
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",conn,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  CallableStatement zadrs=conn.prepareCall(""String_Node_Str"");
  zadrs.execute();
  if (usingEmbedded())   assertEquals(0,zadrs.getUpdateCount());
 else   assertEquals(-1,zadrs.getUpdateCount());
  zadrs.close();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  CallableStatement toomany=conn.prepareCall(""String_Node_Str"");
  toomany.setInt(1,2);
  toomany.setInt(2,6);
  toomany.execute();
  SQLWarning warn=toomany.getWarnings();
  if (usingEmbedded())   assertEquals(""String_Node_Str"",warn.getSQLState());
  rs=toomany.getResultSet();
  JDBC.assertFullResultSet(rs,new String[][]{{""String_Node_Str"",""String_Node_Str""}});
  toomany.setInt(1,2);
  toomany.setInt(2,99);
  toomany.execute();
  rs=toomany.getResultSet();
  JDBC.assertFullResultSet(rs,new String[][]{{""String_Node_Str"",""String_Node_Str""}});
  toomany.close();
  s.execute(""String_Node_Str"");
  s.close();
  conn2.close();
}","/** 
 * 1. basic testing 2. correct auto commit logic 3. correct holdability (JDBC 3)
 */
public void testDynamicResultSets() throws SQLException {
  Connection conn=getConnection();
  Connection conn2=openDefaultConnection();
  Statement s=createStatement();
  assertStatementError(""String_Node_Str"",s,""String_Node_Str"");
  s.execute(""String_Node_Str"");
  String[] sysaliasDefinition={""String_Node_Str""};
  String[] dbMetadataDefinition={""String_Node_Str""};
  String[] columnDefinition={""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  CallableStatement drs1=prepareCall(""String_Node_Str"");
  drs1.setInt(1,3);
  drs1.execute();
  ResultSet rs=drs1.getResultSet();
  String[][] drsResult={{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,drsResult);
  drs1.close();
  s.execute(""String_Node_Str"");
  sysaliasDefinition=new String[]{""String_Node_Str""};
  dbMetadataDefinition=new String[]{""String_Node_Str""};
  columnDefinition=new String[]{""String_Node_Str"",""String_Node_Str""};
  checkMatchingProcedures(conn,""String_Node_Str"",sysaliasDefinition,dbMetadataDefinition,columnDefinition);
  CallableStatement drs2;
  drs2=conn.prepareCall(""String_Node_Str"");
  drs2.setInt(1,2);
  drs2.setInt(2,6);
  drs2.execute();
  rs=drs2.getResultSet();
  String[][] drs2Results={{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,drs2Results);
  assertTrue(drs2.getMoreResults());
  drs2Results=new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}};
  rs=drs2.getResultSet();
  JDBC.assertFullResultSet(rs,drs2Results);
  drs2.setInt(1,2);
  drs2.setInt(2,99);
  assertTrue(drs2.execute());
  rs=drs2.getResultSet();
  drs2Results=new String[][]{{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,drs2Results);
  assertFalse(drs2.getMoreResults());
  drs2.setInt(1,2);
  drs2.setInt(2,199);
  assertFalse(drs2.execute());
  assertFalse(drs2.getMoreResults());
  drs2.setInt(1,2);
  drs2.setInt(2,299);
  assertTrue(drs2.execute());
  drs2Results=new String[][]{{""String_Node_Str"",""String_Node_Str""}};
  rs=drs2.getResultSet();
  JDBC.assertFullResultSet(rs,drs2Results);
  assertTrue(drs2.getMoreResults());
  rs=drs2.getResultSet();
  JDBC.assertEmpty(rs);
  drs2.setInt(1,2);
  drs2.setInt(2,2);
  drs2.execute();
  ResultSet lastResultSet=null;
  int pass=1;
  do {
    if (lastResultSet != null) {
      try {
        lastResultSet.next();
        fail(""String_Node_Str"");
      }
 catch (      SQLException sqle) {
        assertSQLState(""String_Node_Str"",sqle);
      }
    }
    lastResultSet=drs2.getResultSet();
    if ((pass == 1) || (pass == 2))     assertNotNull(""String_Node_Str"" + pass,lastResultSet);
 else     if (pass == 3)     assertNull(lastResultSet);
    pass++;
  }
 while (drs2.getMoreResults() || lastResultSet != null);
  checkCommitWithMultipleResultSets(drs2,conn2,""String_Node_Str"");
  checkCommitWithMultipleResultSets(drs2,conn2,""String_Node_Str"");
  checkCommitWithMultipleResultSets(drs2,conn2,""String_Node_Str"");
  drs2.close();
  drs2=conn.prepareCall(""String_Node_Str"");
  drs2.setInt(1,2);
  drs2.setInt(2,6);
  drs2.execute();
  rs=drs2.getResultSet();
  String[][] expectedRows={{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expectedRows);
  drs2.close();
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  assertCallError(""String_Node_Str"",""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  CallableStatement zadrs=conn.prepareCall(""String_Node_Str"");
  zadrs.execute();
  if (usingEmbedded())   assertEquals(0,zadrs.getUpdateCount());
 else   assertEquals(-1,zadrs.getUpdateCount());
  zadrs.close();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  CallableStatement toomany=conn.prepareCall(""String_Node_Str"");
  toomany.setInt(1,2);
  toomany.setInt(2,6);
  toomany.execute();
  SQLWarning warn=toomany.getWarnings();
  if (usingEmbedded())   assertEquals(""String_Node_Str"",warn.getSQLState());
  rs=toomany.getResultSet();
  JDBC.assertFullResultSet(rs,new String[][]{{""String_Node_Str"",""String_Node_Str""}});
  toomany.setInt(1,2);
  toomany.setInt(2,99);
  toomany.execute();
  rs=toomany.getResultSet();
  JDBC.assertFullResultSet(rs,new String[][]{{""String_Node_Str"",""String_Node_Str""}});
  toomany.close();
  s.execute(""String_Node_Str"");
  s.close();
  conn2.close();
}"
80131,"public void testSQLControl() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  String[] control={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < control.length; i++) {
    StringBuffer cp=new StringBuffer(256);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    String cpsql=cp.toString();
    s.execute(cpsql);
    cp.setLength(0);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    cpsql=cp.toString();
    s.execute(cpsql);
    cp.setLength(0);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    cpsql=cp.toString();
    s.execute(cpsql);
    cp.setLength(0);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    cpsql=cp.toString();
    s.execute(cpsql);
  }
  if (!conn.getAutoCommit())   conn.commit();
  String[][] sqlControl_0={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_1={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_2={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_3={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_4={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][][] sqlControl={sqlControl_0,sqlControl_1,sqlControl_2,sqlControl_3,sqlControl_4};
  for (int i=0; i < control.length; i++) {
    String type=control[i];
    if (type.length() == 0)     type=""String_Node_Str"";
    for (int k=1; k <= 3; k++) {
      CallableStatement cs=conn.prepareCall(""String_Node_Str"" + k + ""String_Node_Str""+ i+ ""String_Node_Str"");
      for (int rop=1; rop <= 7; rop++) {
        cs.registerOutParameter(rop,Types.VARCHAR);
      }
      cs.execute();
      for (int p=1; p <= 7; p++) {
        assertEquals(sqlControl[i][k - 1][p - 1],cs.getString(p));
      }
      cs.close();
    }
  }
  String[][] dmlSqlControl_0={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_1={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_2={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_3={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_4={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][][] dmlSqlControl={dmlSqlControl_0,dmlSqlControl_1,dmlSqlControl_2,dmlSqlControl_3,dmlSqlControl_4};
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  for (int i=0; i < control.length; i++) {
    String type=control[i];
    if (type.length() == 0)     type=""String_Node_Str"";
    for (int t=0; t < control.length; t++) {
      String ttype=control[t];
      if (ttype.length() == 0)       ttype=""String_Node_Str"";
      CallableStatement cs=conn.prepareCall(""String_Node_Str"" + i + ""String_Node_Str"");
      cs.setInt(1,t);
      for (int rop=2; rop <= 9; rop++) {
        cs.registerOutParameter(rop,Types.VARCHAR);
      }
      cs.execute();
      for (int p=2; p <= 9; p++) {
        String so=cs.getString(p);
        if (so == null)         continue;
        assertEquals(dmlSqlControl[i][t][p - 2],so);
      }
      cs.close();
    }
  }
  testBug5280(conn);
  s.execute(""String_Node_Str"");
  for (int i=0; i < control.length; i++) {
    s.execute(""String_Node_Str"" + i);
    s.execute(""String_Node_Str"" + i);
    s.execute(""String_Node_Str"" + i);
  }
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}","public void testSQLControl() throws SQLException {
  Connection conn=getConnection();
  Statement s=createStatement();
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  String[] control={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < control.length; i++) {
    StringBuffer cp=new StringBuffer(256);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    String cpsql=cp.toString();
    s.execute(cpsql);
    cp.setLength(0);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    cpsql=cp.toString();
    s.execute(cpsql);
    cp.setLength(0);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    cpsql=cp.toString();
    s.execute(cpsql);
    cp.setLength(0);
    cp.append(""String_Node_Str"");
    cp.append(i);
    cp.append(""String_Node_Str"");
    cp.append(control[i]);
    cp.append(""String_Node_Str"");
    cpsql=cp.toString();
    s.execute(cpsql);
  }
  if (!conn.getAutoCommit())   conn.commit();
  String[][] sqlControl_0={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_1={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_2={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_3={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] sqlControl_4={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][][] sqlControl={sqlControl_0,sqlControl_1,sqlControl_2,sqlControl_3,sqlControl_4};
  for (int i=0; i < control.length; i++) {
    String type=control[i];
    if (type.length() == 0)     type=""String_Node_Str"";
    for (int k=1; k <= 3; k++) {
      CallableStatement cs=conn.prepareCall(""String_Node_Str"" + k + ""String_Node_Str""+ i+ ""String_Node_Str"");
      for (int rop=1; rop <= 7; rop++) {
        cs.registerOutParameter(rop,Types.VARCHAR);
      }
      cs.execute();
      for (int p=1; p <= 7; p++) {
        assertEquals(sqlControl[i][k - 1][p - 1],cs.getString(p));
      }
      cs.close();
    }
  }
  String[][] dmlSqlControl_0={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_1={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_2={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_3={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][] dmlSqlControl_4={{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}};
  String[][][] dmlSqlControl={dmlSqlControl_0,dmlSqlControl_1,dmlSqlControl_2,dmlSqlControl_3,dmlSqlControl_4};
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  for (int i=0; i < control.length; i++) {
    String type=control[i];
    if (type.length() == 0)     type=""String_Node_Str"";
    for (int t=0; t < control.length; t++) {
      String ttype=control[t];
      if (ttype.length() == 0)       ttype=""String_Node_Str"";
      CallableStatement cs=conn.prepareCall(""String_Node_Str"" + i + ""String_Node_Str"");
      cs.setInt(1,t);
      for (int rop=2; rop <= 9; rop++) {
        cs.registerOutParameter(rop,Types.VARCHAR);
      }
      cs.execute();
      for (int p=2; p <= 9; p++) {
        String so=cs.getString(p);
        if (so == null)         continue;
        assertEquals(dmlSqlControl[i][t][p - 2],so);
      }
      cs.close();
    }
  }
  assertCallError(usingEmbedded() ? ""String_Node_Str"" : ""String_Node_Str"",""String_Node_Str"");
  s.execute(""String_Node_Str"");
  for (int i=0; i < control.length; i++) {
    s.execute(""String_Node_Str"" + i);
    s.execute(""String_Node_Str"" + i);
    s.execute(""String_Node_Str"" + i);
  }
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.execute(""String_Node_Str"");
  s.close();
}"
80132,"/** 
 * Executes the Callable statement that is expected to fail and verifies that it throws the expected SQL exception.
 * @param expectedSE The expected SQL exception
 * @param conn The Connection handle
 * @param callSQL The SQL to execute
 * @throws SQLException
 */
public static void assertCallError(String expectedSE,Connection conn,String callSQL) throws SQLException {
  try {
    CallableStatement cs=conn.prepareCall(callSQL);
    cs.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException se) {
    assertSQLState(expectedSE,se.getSQLState(),se);
  }
}","/** 
 * Executes the Callable statement that is expected to fail and verifies that it throws the expected SQL exception.
 * @param expectedSE The expected SQL exception
 * @param callSQL The SQL to execute
 * @throws SQLException
 */
public void assertCallError(String expectedSE,String callSQL) throws SQLException {
  try {
    CallableStatement cs=prepareCall(callSQL);
    cs.execute();
    fail(""String_Node_Str"");
  }
 catch (  SQLException se) {
    assertSQLState(expectedSE,se);
  }
}"
80133,"/** 
 * @see Optimizer#getNextPermutation
 * @exception StandardException		Thrown on error
 */
public boolean getNextPermutation() throws StandardException {
  if (numOptimizables < 1) {
    if (optimizerTrace) {
      trace(NO_TABLES,0,0,0.0,null);
    }
    endOfRoundCleanup();
    return false;
  }
  optimizableList.initAccessPaths(this);
  if ((!timeExceeded) && (numTablesInQuery > 6) && (!noTimeout)) {
    currentTime=System.currentTimeMillis();
    timeExceeded=(currentTime - timeOptimizationStarted) > timeLimit;
    if (optimizerTrace && timeExceeded) {
      trace(TIME_EXCEEDED,0,0,0.0,null);
    }
  }
  if (bestCost.isUninitialized() && foundABestPlan && ((!usingPredsPushedFromAbove && !bestJoinOrderUsedPredsFromAbove) || timeExceeded)) {
    if (permuteState != JUMPING) {
      if (firstLookOrder == null)       firstLookOrder=new int[numOptimizables];
      for (int i=0; i < numOptimizables; i++)       firstLookOrder[i]=bestJoinOrder[i];
      permuteState=JUMPING;
      if (joinPosition >= 0) {
        rewindJoinOrder();
        joinPosition=-1;
      }
    }
    timeExceeded=false;
  }
  boolean joinPosAdvanced=false;
  boolean alreadyCostsMore=!bestCost.isUninitialized() && (currentCost.compare(bestCost) > 0) && ((requiredRowOrdering == null) || (currentSortAvoidanceCost.compare(bestCost) > 0));
  if ((joinPosition < (numOptimizables - 1)) && !alreadyCostsMore && (!timeExceeded)) {
    if ((joinPosition < 0) || optimizableList.getOptimizable(proposedJoinOrder[joinPosition]).getBestAccessPath().getCostEstimate() != null) {
      joinPosition++;
      joinPosAdvanced=true;
      bestRowOrdering.copy(currentRowOrdering);
    }
  }
 else {
    if (optimizerTrace) {
      if (joinPosition < (numOptimizables - 1)) {
        trace(SHORT_CIRCUITING,0,0,0.0,null);
      }
    }
    if (joinPosition < (numOptimizables - 1))     reloadBestPlan=true;
  }
  if (permuteState == JUMPING && !joinPosAdvanced && joinPosition >= 0) {
    reloadBestPlan=true;
    rewindJoinOrder();
    permuteState=NO_JUMP;
  }
  while (joinPosition >= 0) {
    int nextOptimizable=0;
    if (desiredJoinOrderFound || timeExceeded) {
      nextOptimizable=numOptimizables;
    }
 else     if (permuteState == JUMPING) {
      int idealOptimizable=firstLookOrder[joinPosition];
      nextOptimizable=idealOptimizable;
      int lookPos=numOptimizables;
      int lastSwappedOpt=-1;
      Optimizable nextOpt;
      for (nextOpt=optimizableList.getOptimizable(nextOptimizable); !(nextOpt.legalJoinOrder(assignedTableMap)); nextOpt=optimizableList.getOptimizable(nextOptimizable)) {
        if (lastSwappedOpt >= 0) {
          firstLookOrder[joinPosition]=idealOptimizable;
          firstLookOrder[lookPos]=lastSwappedOpt;
        }
        if (lookPos > joinPosition + 1) {
          lastSwappedOpt=firstLookOrder[--lookPos];
          firstLookOrder[joinPosition]=lastSwappedOpt;
          firstLookOrder[lookPos]=idealOptimizable;
          nextOptimizable=lastSwappedOpt;
        }
 else {
          if (joinPosition > 0) {
            joinPosition--;
            reloadBestPlan=true;
            rewindJoinOrder();
          }
          permuteState=NO_JUMP;
          break;
        }
      }
      if (permuteState == NO_JUMP)       continue;
      if (joinPosition == numOptimizables - 1) {
        permuteState=WALK_HIGH;
      }
    }
 else {
      nextOptimizable=proposedJoinOrder[joinPosition] + 1;
      for (; nextOptimizable < numOptimizables; nextOptimizable++) {
        boolean found=false;
        for (int posn=0; posn < joinPosition; posn++) {
          if (proposedJoinOrder[posn] == nextOptimizable) {
            found=true;
            break;
          }
        }
        if (nextOptimizable < numOptimizables) {
          Optimizable nextOpt=optimizableList.getOptimizable(nextOptimizable);
          if (!(nextOpt.legalJoinOrder(assignedTableMap))) {
            if (optimizerTrace) {
              trace(SKIPPING_JOIN_ORDER,nextOptimizable,0,0.0,null);
            }
            if (!optimizableList.optimizeJoinOrder()) {
              if (optimizerTrace) {
                trace(ILLEGAL_USER_JOIN_ORDER,0,0,0.0,null);
              }
              throw StandardException.newException(SQLState.LANG_ILLEGAL_FORCED_JOIN_ORDER);
            }
            continue;
          }
        }
        if (!found) {
          break;
        }
      }
    }
    if (proposedJoinOrder[joinPosition] >= 0) {
      Optimizable pullMe=optimizableList.getOptimizable(proposedJoinOrder[joinPosition]);
      double prevRowCount;
      double prevSingleScanRowCount;
      int prevPosition=0;
      if (joinPosition == 0) {
        prevRowCount=outermostCostEstimate.rowCount();
        prevSingleScanRowCount=outermostCostEstimate.singleScanRowCount();
      }
 else {
        prevPosition=proposedJoinOrder[joinPosition - 1];
        CostEstimate localCE=optimizableList.getOptimizable(prevPosition).getBestAccessPath().getCostEstimate();
        prevRowCount=localCE.rowCount();
        prevSingleScanRowCount=localCE.singleScanRowCount();
      }
      double newCost=currentCost.getEstimatedCost();
      double pullCost=0.0;
      CostEstimate pullCostEstimate=pullMe.getBestAccessPath().getCostEstimate();
      if (pullCostEstimate != null) {
        pullCost=pullCostEstimate.getEstimatedCost();
        newCost-=pullCost;
        if (newCost <= 0.0) {
          if (joinPosition == 0)           newCost=0.0;
 else           newCost=recoverCostFromProposedJoinOrder();
        }
      }
      if (joinPosition == 0) {
        if (outermostCostEstimate != null) {
          newCost=outermostCostEstimate.getEstimatedCost();
        }
 else {
          newCost=0.0;
        }
      }
      currentCost.setCost(newCost,prevRowCount,prevSingleScanRowCount);
      if (requiredRowOrdering != null) {
        if (pullMe.considerSortAvoidancePath()) {
          AccessPath ap=pullMe.getBestSortAvoidancePath();
          double prevEstimatedCost=0.0d;
          if (joinPosition == 0) {
            prevRowCount=outermostCostEstimate.rowCount();
            prevSingleScanRowCount=outermostCostEstimate.singleScanRowCount();
            prevEstimatedCost=outermostCostEstimate.getEstimatedCost();
          }
 else {
            CostEstimate localCE=optimizableList.getOptimizable(prevPosition).getBestSortAvoidancePath().getCostEstimate();
            prevRowCount=localCE.rowCount();
            prevSingleScanRowCount=localCE.singleScanRowCount();
            prevEstimatedCost=currentSortAvoidanceCost.getEstimatedCost() - ap.getCostEstimate().getEstimatedCost();
          }
          if (prevEstimatedCost <= 0.0) {
            if (joinPosition == 0)             prevEstimatedCost=0.0;
 else {
              prevEstimatedCost=recoverCostFromProposedJoinOrder();
            }
          }
          currentSortAvoidanceCost.setCost(prevEstimatedCost,prevRowCount,prevSingleScanRowCount);
          bestRowOrdering.removeOptimizable(pullMe.getTableNumber());
          bestRowOrdering.copy(currentRowOrdering);
        }
      }
      pullMe.pullOptPredicates(predicateList);
      if (reloadBestPlan)       pullMe.updateBestPlanMap(FromTable.LOAD_PLAN,this);
      proposedJoinOrder[joinPosition]=-1;
    }
    if (nextOptimizable >= numOptimizables) {
      if (!optimizableList.optimizeJoinOrder()) {
        if (!optimizableList.legalJoinOrder(numTablesInQuery)) {
          if (optimizerTrace) {
            trace(ILLEGAL_USER_JOIN_ORDER,0,0,0.0,null);
          }
          throw StandardException.newException(SQLState.LANG_ILLEGAL_FORCED_JOIN_ORDER);
        }
        if (optimizerTrace) {
          trace(USER_JOIN_ORDER_OPTIMIZED,0,0,0.0,null);
        }
        desiredJoinOrderFound=true;
      }
      if (permuteState == READY_TO_JUMP && joinPosition > 0 && joinPosition == numOptimizables - 1) {
        permuteState=JUMPING;
        double rc[]=new double[numOptimizables];
        for (int i=0; i < numOptimizables; i++) {
          firstLookOrder[i]=i;
          CostEstimate ce=optimizableList.getOptimizable(i).getBestAccessPath().getCostEstimate();
          if (ce == null) {
            permuteState=READY_TO_JUMP;
            break;
          }
          rc[i]=ce.singleScanRowCount();
        }
        if (permuteState == JUMPING) {
          boolean doIt=false;
          int temp;
          for (int i=0; i < numOptimizables; i++) {
            int k=i;
            for (int j=i + 1; j < numOptimizables; j++)             if (rc[j] < rc[k])             k=j;
            if (k != i) {
              rc[k]=rc[i];
              temp=firstLookOrder[i];
              firstLookOrder[i]=firstLookOrder[k];
              firstLookOrder[k]=temp;
              doIt=true;
            }
          }
          if (doIt) {
            joinPosition--;
            rewindJoinOrder();
            continue;
          }
 else           permuteState=NO_JUMP;
        }
      }
      joinPosition--;
      if (joinPosition >= 0) {
        Optimizable pullMe=optimizableList.getOptimizable(proposedJoinOrder[joinPosition]);
        assignedTableMap.xor(pullMe.getReferencedTableMap());
      }
      if (joinPosition < 0 && permuteState == WALK_HIGH) {
        joinPosition=0;
        permuteState=WALK_LOW;
      }
      continue;
    }
    proposedJoinOrder[joinPosition]=nextOptimizable;
    if (permuteState == WALK_LOW) {
      boolean finishedCycle=true;
      for (int i=0; i < numOptimizables; i++) {
        if (proposedJoinOrder[i] < firstLookOrder[i]) {
          finishedCycle=false;
          break;
        }
 else         if (proposedJoinOrder[i] > firstLookOrder[i])         break;
      }
      if (finishedCycle) {
        proposedJoinOrder[joinPosition]=-1;
        joinPosition--;
        if (joinPosition >= 0) {
          reloadBestPlan=true;
          rewindJoinOrder();
          joinPosition=-1;
        }
        permuteState=READY_TO_JUMP;
        endOfRoundCleanup();
        return false;
      }
    }
    optimizableList.getOptimizable(nextOptimizable).getBestAccessPath().setCostEstimate((CostEstimate)null);
    assignedTableMap.clearAll();
    for (int index=0; index <= joinPosition; index++) {
      assignedTableMap.or(optimizableList.getOptimizable(proposedJoinOrder[index]).getReferencedTableMap());
    }
    if (optimizerTrace) {
      trace(CONSIDERING_JOIN_ORDER,0,0,0.0,null);
    }
    Optimizable nextOpt=optimizableList.getOptimizable(nextOptimizable);
    nextOpt.startOptimizing(this,currentRowOrdering);
    pushPredicates(optimizableList.getOptimizable(nextOptimizable),assignedTableMap);
    return true;
  }
  endOfRoundCleanup();
  return false;
}","/** 
 * @see Optimizer#getNextPermutation
 * @exception StandardException		Thrown on error
 */
public boolean getNextPermutation() throws StandardException {
  if (numOptimizables < 1) {
    if (optimizerTrace) {
      trace(NO_TABLES,0,0,0.0,null);
    }
    endOfRoundCleanup();
    return false;
  }
  optimizableList.initAccessPaths(this);
  if ((!timeExceeded) && (numTablesInQuery > 6) && (!noTimeout)) {
    currentTime=System.currentTimeMillis();
    timeExceeded=(currentTime - timeOptimizationStarted) > timeLimit;
    if (optimizerTrace && timeExceeded) {
      trace(TIME_EXCEEDED,0,0,0.0,null);
    }
  }
  if (bestCost.isUninitialized() && foundABestPlan && ((!usingPredsPushedFromAbove && !bestJoinOrderUsedPredsFromAbove) || timeExceeded)) {
    if (permuteState != JUMPING) {
      if (firstLookOrder == null)       firstLookOrder=new int[numOptimizables];
      for (int i=0; i < numOptimizables; i++)       firstLookOrder[i]=bestJoinOrder[i];
      permuteState=JUMPING;
      if (joinPosition >= 0) {
        rewindJoinOrder();
        joinPosition=-1;
      }
    }
    timeExceeded=false;
  }
  boolean joinPosAdvanced=false;
  boolean alreadyCostsMore=!bestCost.isUninitialized() && (currentCost.compare(bestCost) > 0) && ((requiredRowOrdering == null) || (currentSortAvoidanceCost.compare(bestCost) > 0));
  if ((joinPosition < (numOptimizables - 1)) && !alreadyCostsMore && (!timeExceeded)) {
    if ((joinPosition < 0) || optimizableList.getOptimizable(proposedJoinOrder[joinPosition]).getBestAccessPath().getCostEstimate() != null) {
      joinPosition++;
      joinPosAdvanced=true;
      bestRowOrdering.copy(currentRowOrdering);
    }
  }
 else {
    if (optimizerTrace) {
      if (joinPosition < (numOptimizables - 1)) {
        trace(SHORT_CIRCUITING,0,0,0.0,null);
      }
    }
    if (joinPosition < (numOptimizables - 1))     reloadBestPlan=true;
  }
  if (permuteState == JUMPING && !joinPosAdvanced && joinPosition >= 0) {
    reloadBestPlan=true;
    rewindJoinOrder();
    permuteState=NO_JUMP;
  }
  while (joinPosition >= 0) {
    int nextOptimizable=0;
    if (desiredJoinOrderFound || timeExceeded) {
      nextOptimizable=numOptimizables;
    }
 else     if (permuteState == JUMPING) {
      int idealOptimizable=firstLookOrder[joinPosition];
      nextOptimizable=idealOptimizable;
      int lookPos=numOptimizables;
      int lastSwappedOpt=-1;
      Optimizable nextOpt;
      for (nextOpt=optimizableList.getOptimizable(nextOptimizable); !(nextOpt.legalJoinOrder(assignedTableMap)); nextOpt=optimizableList.getOptimizable(nextOptimizable)) {
        if (lastSwappedOpt >= 0) {
          firstLookOrder[joinPosition]=idealOptimizable;
          firstLookOrder[lookPos]=lastSwappedOpt;
        }
        if (lookPos > joinPosition + 1) {
          lastSwappedOpt=firstLookOrder[--lookPos];
          firstLookOrder[joinPosition]=lastSwappedOpt;
          firstLookOrder[lookPos]=idealOptimizable;
          nextOptimizable=lastSwappedOpt;
        }
 else {
          if (joinPosition > 0) {
            joinPosition--;
            reloadBestPlan=true;
            rewindJoinOrder();
          }
          permuteState=NO_JUMP;
          break;
        }
      }
      if (permuteState == NO_JUMP)       continue;
      if (joinPosition == numOptimizables - 1) {
        permuteState=WALK_HIGH;
      }
    }
 else {
      nextOptimizable=proposedJoinOrder[joinPosition] + 1;
      for (; nextOptimizable < numOptimizables; nextOptimizable++) {
        boolean found=false;
        for (int posn=0; posn < joinPosition; posn++) {
          if (proposedJoinOrder[posn] == nextOptimizable) {
            found=true;
            break;
          }
        }
        if (nextOptimizable < numOptimizables) {
          Optimizable nextOpt=optimizableList.getOptimizable(nextOptimizable);
          if (!(nextOpt.legalJoinOrder(assignedTableMap))) {
            if (optimizerTrace) {
              trace(SKIPPING_JOIN_ORDER,nextOptimizable,0,0.0,null);
            }
            if (!optimizableList.optimizeJoinOrder()) {
              if (optimizerTrace) {
                trace(ILLEGAL_USER_JOIN_ORDER,0,0,0.0,null);
              }
              throw StandardException.newException(SQLState.LANG_ILLEGAL_FORCED_JOIN_ORDER);
            }
            continue;
          }
        }
        if (!found) {
          break;
        }
      }
    }
    if (proposedJoinOrder[joinPosition] >= 0) {
      Optimizable pullMe=optimizableList.getOptimizable(proposedJoinOrder[joinPosition]);
      double prevRowCount;
      double prevSingleScanRowCount;
      int prevPosition=0;
      if (joinPosition == 0) {
        prevRowCount=outermostCostEstimate.rowCount();
        prevSingleScanRowCount=outermostCostEstimate.singleScanRowCount();
      }
 else {
        prevPosition=proposedJoinOrder[joinPosition - 1];
        CostEstimate localCE=optimizableList.getOptimizable(prevPosition).getBestAccessPath().getCostEstimate();
        prevRowCount=localCE.rowCount();
        prevSingleScanRowCount=localCE.singleScanRowCount();
      }
      double newCost=currentCost.getEstimatedCost();
      double pullCost=0.0;
      CostEstimate pullCostEstimate=pullMe.getBestAccessPath().getCostEstimate();
      if (pullCostEstimate != null) {
        pullCost=pullCostEstimate.getEstimatedCost();
        newCost-=pullCost;
        if (newCost <= 0.0) {
          if (joinPosition == 0)           newCost=0.0;
 else           newCost=recoverCostFromProposedJoinOrder(false);
        }
      }
      if (joinPosition == 0) {
        if (outermostCostEstimate != null) {
          newCost=outermostCostEstimate.getEstimatedCost();
        }
 else {
          newCost=0.0;
        }
      }
      currentCost.setCost(newCost,prevRowCount,prevSingleScanRowCount);
      if (requiredRowOrdering != null) {
        if (pullMe.considerSortAvoidancePath()) {
          AccessPath ap=pullMe.getBestSortAvoidancePath();
          double prevEstimatedCost=0.0d;
          if (joinPosition == 0) {
            prevRowCount=outermostCostEstimate.rowCount();
            prevSingleScanRowCount=outermostCostEstimate.singleScanRowCount();
            prevEstimatedCost=outermostCostEstimate.getEstimatedCost();
          }
 else {
            CostEstimate localCE=optimizableList.getOptimizable(prevPosition).getBestSortAvoidancePath().getCostEstimate();
            prevRowCount=localCE.rowCount();
            prevSingleScanRowCount=localCE.singleScanRowCount();
            prevEstimatedCost=currentSortAvoidanceCost.getEstimatedCost() - ap.getCostEstimate().getEstimatedCost();
          }
          if (prevEstimatedCost <= 0.0) {
            if (joinPosition == 0)             prevEstimatedCost=0.0;
 else {
              prevEstimatedCost=recoverCostFromProposedJoinOrder(true);
            }
          }
          currentSortAvoidanceCost.setCost(prevEstimatedCost,prevRowCount,prevSingleScanRowCount);
          bestRowOrdering.removeOptimizable(pullMe.getTableNumber());
          bestRowOrdering.copy(currentRowOrdering);
        }
      }
      pullMe.pullOptPredicates(predicateList);
      if (reloadBestPlan)       pullMe.updateBestPlanMap(FromTable.LOAD_PLAN,this);
      proposedJoinOrder[joinPosition]=-1;
    }
    if (nextOptimizable >= numOptimizables) {
      if (!optimizableList.optimizeJoinOrder()) {
        if (!optimizableList.legalJoinOrder(numTablesInQuery)) {
          if (optimizerTrace) {
            trace(ILLEGAL_USER_JOIN_ORDER,0,0,0.0,null);
          }
          throw StandardException.newException(SQLState.LANG_ILLEGAL_FORCED_JOIN_ORDER);
        }
        if (optimizerTrace) {
          trace(USER_JOIN_ORDER_OPTIMIZED,0,0,0.0,null);
        }
        desiredJoinOrderFound=true;
      }
      if (permuteState == READY_TO_JUMP && joinPosition > 0 && joinPosition == numOptimizables - 1) {
        permuteState=JUMPING;
        double rc[]=new double[numOptimizables];
        for (int i=0; i < numOptimizables; i++) {
          firstLookOrder[i]=i;
          CostEstimate ce=optimizableList.getOptimizable(i).getBestAccessPath().getCostEstimate();
          if (ce == null) {
            permuteState=READY_TO_JUMP;
            break;
          }
          rc[i]=ce.singleScanRowCount();
        }
        if (permuteState == JUMPING) {
          boolean doIt=false;
          int temp;
          for (int i=0; i < numOptimizables; i++) {
            int k=i;
            for (int j=i + 1; j < numOptimizables; j++)             if (rc[j] < rc[k])             k=j;
            if (k != i) {
              rc[k]=rc[i];
              temp=firstLookOrder[i];
              firstLookOrder[i]=firstLookOrder[k];
              firstLookOrder[k]=temp;
              doIt=true;
            }
          }
          if (doIt) {
            joinPosition--;
            rewindJoinOrder();
            continue;
          }
 else           permuteState=NO_JUMP;
        }
      }
      joinPosition--;
      if (joinPosition >= 0) {
        Optimizable pullMe=optimizableList.getOptimizable(proposedJoinOrder[joinPosition]);
        assignedTableMap.xor(pullMe.getReferencedTableMap());
      }
      if (joinPosition < 0 && permuteState == WALK_HIGH) {
        joinPosition=0;
        permuteState=WALK_LOW;
      }
      continue;
    }
    proposedJoinOrder[joinPosition]=nextOptimizable;
    if (permuteState == WALK_LOW) {
      boolean finishedCycle=true;
      for (int i=0; i < numOptimizables; i++) {
        if (proposedJoinOrder[i] < firstLookOrder[i]) {
          finishedCycle=false;
          break;
        }
 else         if (proposedJoinOrder[i] > firstLookOrder[i])         break;
      }
      if (finishedCycle) {
        proposedJoinOrder[joinPosition]=-1;
        joinPosition--;
        if (joinPosition >= 0) {
          reloadBestPlan=true;
          rewindJoinOrder();
          joinPosition=-1;
        }
        permuteState=READY_TO_JUMP;
        endOfRoundCleanup();
        return false;
      }
    }
    optimizableList.getOptimizable(nextOptimizable).getBestAccessPath().setCostEstimate((CostEstimate)null);
    assignedTableMap.clearAll();
    for (int index=0; index <= joinPosition; index++) {
      assignedTableMap.or(optimizableList.getOptimizable(proposedJoinOrder[index]).getReferencedTableMap());
    }
    if (optimizerTrace) {
      trace(CONSIDERING_JOIN_ORDER,0,0,0.0,null);
    }
    Optimizable nextOpt=optimizableList.getOptimizable(nextOptimizable);
    nextOpt.startOptimizing(this,currentRowOrdering);
    pushPredicates(optimizableList.getOptimizable(nextOptimizable),assignedTableMap);
    return true;
  }
  endOfRoundCleanup();
  return false;
}"
80134,"/** 
 * Iterate through all optimizables in the current proposedJoinOrder and find the accumulated sum of their estimated costs.  This method is used to 'recover' cost estimate sums that have been lost due to the addition/subtraction of the cost estimate for the Optimizable at position ""joinPosition"".  Ex. If the total cost for Optimizables at positions < joinPosition is 1500, and then the Optimizable at joinPosition has an estimated cost of 3.14E40, adding those two numbers effectively ""loses"" the 1500. When we later subtract 3.14E40 from the total cost estimate (as part of ""pull"" processing), we'll end up with 0 as the result--which is wrong. This method allows us to recover the ""1500"" that we lost in the process of adding and subtracting 3.14E40.
 */
private double recoverCostFromProposedJoinOrder() throws StandardException {
  double recoveredCost=0.0d;
  for (int i=0; i < joinPosition; i++) {
    recoveredCost+=optimizableList.getOptimizable(proposedJoinOrder[i]).getBestAccessPath().getCostEstimate().getEstimatedCost();
  }
  return recoveredCost;
}","/** 
 * Iterate through all optimizables in the current proposedJoinOrder and find the accumulated sum of their estimated costs.  This method is used to 'recover' cost estimate sums that have been lost due to the addition/subtraction of the cost estimate for the Optimizable at position ""joinPosition"".  Ex. If the total cost for Optimizables at positions < joinPosition is 1500, and then the Optimizable at joinPosition has an estimated cost of 3.14E40, adding those two numbers effectively ""loses"" the 1500. When we later subtract 3.14E40 from the total cost estimate (as part of ""pull"" processing), we'll end up with 0 as the result--which is wrong. This method allows us to recover the ""1500"" that we lost in the process of adding and subtracting 3.14E40.
 */
private double recoverCostFromProposedJoinOrder(boolean sortAvoidance) throws StandardException {
  double recoveredCost=0.0d;
  for (int i=0; i < joinPosition; i++) {
    if (sortAvoidance) {
      recoveredCost+=optimizableList.getOptimizable(proposedJoinOrder[i]).getBestSortAvoidancePath().getCostEstimate().getEstimatedCost();
    }
 else {
      recoveredCost+=optimizableList.getOptimizable(proposedJoinOrder[i]).getBestAccessPath().getCostEstimate().getEstimatedCost();
    }
  }
  return recoveredCost;
}"
80135,"/** 
 * c
 * @param s The string to be parsed
 * @return An array of strings made by breaking the input string at its dots, '.'.
 * @exception StandardException Oops
 */
private static String[] parseMultiPartSQLIdentifier(StringReader r) throws StandardException {
  Vector v=new Vector();
  while (true) {
    String thisId=parseId(r,true);
    v.addElement(thisId);
    int dot;
    try {
      r.mark(0);
      dot=r.read();
      if (dot != '.') {
        if (dot != -1)         r.reset();
        break;
      }
    }
 catch (    IOException ioe) {
      throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
    }
  }
  String[] result=new String[v.size()];
  v.copyInto(result);
  return result;
}","/** 
 * @param r The multi-part identifier to be parsed
 * @return An array of strings made by breaking the input string at its dots, '.'.
 * @exception StandardException Oops
 */
private static String[] parseMultiPartSQLIdentifier(StringReader r) throws StandardException {
  Vector v=new Vector();
  while (true) {
    String thisId=parseId(r,true);
    v.addElement(thisId);
    int dot;
    try {
      r.mark(0);
      dot=r.read();
      if (dot != '.') {
        if (dot != -1)         r.reset();
        break;
      }
    }
 catch (    IOException ioe) {
      throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
    }
  }
  String[] result=new String[v.size()];
  v.copyInto(result);
  return result;
}"
80136,"/** 
 * Assert that the user name returned by various mechanisms matches the normal user name.
 * @param normalUserName
 * @param conn
 * @throws SQLException
 */
private void assertNormalUserName(String normalUserName,Connection connUser) throws SQLException {
  Statement s=connUser.createStatement();
  JDBC.assertSingleValueResultSet(s.executeQuery(""String_Node_Str""),normalUserName);
  JDBC.assertSingleValueResultSet(s.executeQuery(""String_Node_Str""),normalUserName);
  JDBC.assertSingleValueResultSet(s.executeQuery(""String_Node_Str""),normalUserName);
  s.close();
}","/** 
 * Assert that the user name returned by various mechanisms matches the normal user name.
 * @param normalUserName
 * @param connUser
 * @throws SQLException
 */
private void assertNormalUserName(String normalUserName,Connection connUser) throws SQLException {
  Statement s=connUser.createStatement();
  JDBC.assertSingleValueResultSet(s.executeQuery(""String_Node_Str""),normalUserName);
  JDBC.assertSingleValueResultSet(s.executeQuery(""String_Node_Str""),normalUserName);
  JDBC.assertSingleValueResultSet(s.executeQuery(""String_Node_Str""),normalUserName);
  s.close();
}"
80137,"/** 
 * Build a JBitSet of all of the tables that we are correlated with.
 * @param correlationMap	The JBitSet of the tables that we are correlated with.
 */
void getCorrelationTables(JBitSet correlationMap) throws StandardException {
  CollectNodesVisitor getCRs=new CollectNodesVisitor(ColumnReference.class);
  super.accept(getCRs);
  Vector colRefs=getCRs.getList();
  for (Enumeration e=colRefs.elements(); e.hasMoreElements(); ) {
    ColumnReference ref=(ColumnReference)e.nextElement();
    if (ref.getCorrelated()) {
      correlationMap.set(ref.getTableNumber());
    }
  }
}","/** 
 * Build a JBitSet of all of the tables that we are correlated with.
 * @param correlationMap	The JBitSet of the tables that we are correlated with.
 */
void getCorrelationTables(JBitSet correlationMap) throws StandardException {
  CollectNodesVisitor getCRs=new CollectNodesVisitor(ColumnReference.class);
  accept(getCRs);
  Vector colRefs=getCRs.getList();
  for (Enumeration e=colRefs.elements(); e.hasMoreElements(); ) {
    ColumnReference ref=(ColumnReference)e.nextElement();
    if (ref.getCorrelated()) {
      correlationMap.set(ref.getTableNumber());
    }
  }
}"
80138,"/** 
 * Append a byte[] to this LogBufferElement.
 * @return new position
 */
private int appendBytes(byte b[],int pos,int length){
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(freeSize() >= (pos + length),""String_Node_Str"" + ""String_Node_Str"");
    SanityManager.ASSERT(b != null,""String_Node_Str"");
  }
  System.arraycopy(b,0,bufferdata,pos,length);
  return pos + length;
}","/** 
 * Append a byte[] to this LogBufferElement.
 * @param b       where the bytes are copied from
 * @param offset  offset in b to start copying from
 * @param pos     the position in this LogBufferElement to start copying to
 * @param length  number of bytes to copy from b, starting from offset
 * @return new position
 */
private int appendBytes(byte b[],int offset,int pos,int length){
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(freeSize() >= length,""String_Node_Str"" + ""String_Node_Str"");
    SanityManager.ASSERT(b != null,""String_Node_Str"");
  }
  System.arraycopy(b,offset,bufferdata,pos,length);
  return pos + length;
}"
80139,"/** 
 * Method to determine whether or not the buffer had log record the last time next() was called.
 * @return true if the buffer contained log records the last timenext() was called. False if not, or if next() has not been called yet.
 */
public boolean validData(){
synchronized (outputLatch) {
    return validOutBuffer;
  }
}","/** 
 * Method to determine whether or not the buffer had any log records the last time next() was called.
 * @return true if the buffer contained log records the last timenext() was called. False if not, or if next() has not been called yet.
 */
public boolean validData(){
synchronized (outputLatch) {
    return validOutBuffer;
  }
}"
80140,"/** 
 * Make sure that the character in val matches the character in pat. If we are dealing with UCS_BASIC character string (ie collator is null) then we can just do simple character equality check. But if we are dealing with territory based character string type, then we need to  convert the character in val and pat into it's collation element(s) and then do collation element equality comparison.
 * @param val value to compare.
 * @param vLoc character position in val.
 * @param pat pattern to look for in val.
 * @param pLoc character position in pat.
 * @param collator null if we are dealing with UCS_BASIC character stringtypes. If not null, then we use it to get collation elements for  character in val and pat to do the equality comparison.
 * @return
 */
private static boolean checkEquality(char[] val,int vLoc,char[] pat,int pLoc,RuleBasedCollator collator){
  CollationElementIterator patternIterator;
  int curCollationElementInPattern;
  CollationElementIterator valueIterator;
  int curCollationElementInValue;
  if (collator == null) {
    if (val[vLoc] == pat[pLoc])     return true;
 else     return false;
  }
 else {
    patternIterator=collator.getCollationElementIterator(new String(pat,pLoc,1));
    valueIterator=collator.getCollationElementIterator(new String(val,vLoc,1));
    curCollationElementInPattern=patternIterator.next();
    curCollationElementInValue=valueIterator.next();
    while (curCollationElementInPattern == curCollationElementInValue) {
      if (curCollationElementInPattern == CollationElementIterator.NULLORDER)       break;
      curCollationElementInPattern=patternIterator.next();
      curCollationElementInValue=valueIterator.next();
    }
    if (curCollationElementInPattern != curCollationElementInValue)     return false;
 else     return true;
  }
}","/** 
 * Make sure that the character in val matches the character in pat. If we are dealing with UCS_BASIC character string (ie collator is null) then we can just do simple character equality check. But if we are dealing with territory based character string type, then we need to  convert the character in val and pat into it's collation element(s) and then do collation element equality comparison.
 * @param val value to compare.
 * @param vLoc character position in val.
 * @param pat pattern to look for in val.
 * @param pLoc character position in pat.
 * @param collator null if we are dealing with UCS_BASIC character stringtypes. If not null, then we use it to get collation elements for  character in val and pat to do the equality comparison.
 * @return TRUE if the character in val and vLoc match based on straightequality or collation element based equality. Otherwise we will  return FALSE.
 */
private static boolean checkEquality(char[] val,int vLoc,char[] pat,int pLoc,RuleBasedCollator collator){
  CollationElementIterator patternIterator;
  int curCollationElementInPattern;
  CollationElementIterator valueIterator;
  int curCollationElementInValue;
  if (collator == null) {
    if (val[vLoc] == pat[pLoc])     return true;
 else     return false;
  }
 else {
    patternIterator=collator.getCollationElementIterator(new String(pat,pLoc,1));
    valueIterator=collator.getCollationElementIterator(new String(val,vLoc,1));
    curCollationElementInPattern=patternIterator.next();
    curCollationElementInValue=valueIterator.next();
    while (curCollationElementInPattern == curCollationElementInValue) {
      if (curCollationElementInPattern == CollationElementIterator.NULLORDER)       break;
      curCollationElementInPattern=patternIterator.next();
      curCollationElementInValue=valueIterator.next();
    }
    if (curCollationElementInPattern != curCollationElementInValue)     return false;
 else     return true;
  }
}"
80141,"/** 
 * For a TERRITORY_BASED collation french database, differences between pre-composed accents such  as ""\u00C0"" (A-grave) and combining accents such as ""A\u0300"" (A, combining-grave) should match for = and like. But they do not match for UCS_BASIC. We insert both into a table and search based on equal and like. 
 * @param conn
 * @param expectedMatchCount  number of rows we expect back. 2 for french, 1 for English 
 * @throws SQLException
 */
private void compareAgrave(Connection conn,int expectedMatchCountForEqual,int expectedMatchCountForLike) throws SQLException {
  String agrave=""String_Node_Str"";
  String agraveCombined=""String_Node_Str"";
  Statement s=conn.createStatement();
  try {
    s.executeUpdate(""String_Node_Str"");
  }
 catch (  SQLException se) {
  }
  s.executeUpdate(""String_Node_Str"");
  PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
  ps.setString(1,agrave);
  ps.executeUpdate();
  ps.setString(1,agraveCombined);
  ps.executeUpdate();
  ps.close();
  ps=conn.prepareStatement(""String_Node_Str"");
  ps.setString(1,agrave);
  ResultSet rs=ps.executeQuery();
  JDBC.assertSingleValueResultSet(rs,Integer.toString(expectedMatchCountForEqual));
  ps=conn.prepareStatement(""String_Node_Str"");
  ps.setString(1,agrave);
  rs=ps.executeQuery();
  JDBC.assertSingleValueResultSet(rs,Integer.toString(expectedMatchCountForLike));
  rs.close();
  ps.close();
  s.close();
}","/** 
 * For a TERRITORY_BASED collation french database, differences between pre-composed accents such  as ""\u00C0"" (A-grave) and combining accents such as ""A\u0300"" (A, combining-grave) should match for = and like. But they do not match for UCS_BASIC. We insert both into a table and search based on equal and like. 
 * @param conn
 * @param expectedMatchCountForEqual  number of rows we expect back for =. 2 for French, 1 for English 
 * @param expectedMatchCountForLike  number of rows we expect back for LIKE. 1 for French and English 
 * @throws SQLException
 */
private void compareAgrave(Connection conn,int expectedMatchCountForEqual,int expectedMatchCountForLike) throws SQLException {
  String agrave=""String_Node_Str"";
  String agraveCombined=""String_Node_Str"";
  Statement s=conn.createStatement();
  try {
    s.executeUpdate(""String_Node_Str"");
  }
 catch (  SQLException se) {
  }
  s.executeUpdate(""String_Node_Str"");
  PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
  ps.setString(1,agrave);
  ps.executeUpdate();
  ps.setString(1,agraveCombined);
  ps.executeUpdate();
  ps.close();
  ps=conn.prepareStatement(""String_Node_Str"");
  ps.setString(1,agrave);
  ResultSet rs=ps.executeQuery();
  JDBC.assertSingleValueResultSet(rs,Integer.toString(expectedMatchCountForEqual));
  ps=conn.prepareStatement(""String_Node_Str"");
  ps.setString(1,agrave);
  rs=ps.executeQuery();
  JDBC.assertSingleValueResultSet(rs,Integer.toString(expectedMatchCountForLike));
  rs.close();
  ps.close();
  s.close();
}"
80142,"public int read(char[] cbuf,int off,int len) throws IOException {
synchronized (lock) {
    if (noMoreReads)     throw new IOException(READER_CLOSED);
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return -1;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    System.arraycopy(buffer,readPositionInBuffer,cbuf,off,len);
    readPositionInBuffer+=len;
    return len;
  }
}","/** 
 * Reads characters into an array.
 * @return The number of characters read, or <code>-1</code> if the end ofthe stream has been reached.
 */
public int read(char[] cbuf,int off,int len) throws IOException {
synchronized (lock) {
    if (noMoreReads)     throw new IOException(READER_CLOSED);
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return -1;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    System.arraycopy(buffer,readPositionInBuffer,cbuf,off,len);
    readPositionInBuffer+=len;
    return len;
  }
}"
80143,"public int readInto(StringBuffer sb,int len) throws IOException {
synchronized (lock) {
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return -1;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    sb.append(buffer,readPositionInBuffer,len);
    readPositionInBuffer+=len;
    return len;
  }
}","/** 
 * Reads characters from the stream. <p> Due to internal buffering a smaller number of characters than what is requested might be returned. To ensure that the request is fulfilled, call this method in a loop until the requested number of characters is read or <code>-1</code> is returned.
 * @param sb the destination buffer
 * @param len maximum number of characters to read
 * @return The number of characters read, or <code>-1</code> if the end ofthe stream is reached.
 */
public int readInto(StringBuffer sb,int len) throws IOException {
synchronized (lock) {
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return -1;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    sb.append(buffer,readPositionInBuffer,len);
    readPositionInBuffer+=len;
    return len;
  }
}"
80144,"/** 
 * Constructs a <code>UTF8Reader</code> using a stream. <p> This consturctor accepts the stream size as parameter and doesn't attempt to read the length from the stream.
 * @param in the underlying stream
 * @param maxFieldSize the maximum allowed length for the associated column
 * @param streamSize size of the underlying stream in bytes
 * @param parent the connection child this stream is associated with
 * @param synchronization object to synchronize on
 */
public UTF8Reader(InputStream in,long maxFieldSize,long streamSize,ConnectionChild parent,Object synchronization) throws IOException {
  super(synchronization);
  this.maxFieldSize=maxFieldSize;
  this.parent=parent;
  this.utfLen=streamSize;
  this.positionedIn=null;
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(!(in instanceof Resetable));
  }
  this.in=new BufferedInputStream(in);
}","/** 
 * Constructs a <code>UTF8Reader</code> using a stream. <p> This consturctor accepts the stream size as parameter and doesn't attempt to read the length from the stream.
 * @param in the underlying stream
 * @param maxFieldSize the maximum allowed length for the associated column
 * @param streamSize size of the underlying stream in bytes
 * @param parent the connection child this stream is associated with
 * @param synchronization object to synchronize on
 */
public UTF8Reader(InputStream in,long maxFieldSize,long streamSize,ConnectionChild parent,Object synchronization){
  super(synchronization);
  this.maxFieldSize=maxFieldSize;
  this.parent=parent;
  this.utfLen=streamSize;
  this.positionedIn=null;
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(!(in instanceof Resetable));
  }
  this.in=new BufferedInputStream(in);
}"
80145,"int readAsciiInto(byte[] abuf,int off,int len) throws IOException {
synchronized (lock) {
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return -1;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    char[] lbuffer=buffer;
    for (int i=0; i < len; i++) {
      char c=lbuffer[readPositionInBuffer + i];
      byte cb;
      if (c <= 255)       cb=(byte)c;
 else       cb=(byte)'?';
      abuf[off + i]=cb;
    }
    readPositionInBuffer+=len;
    return len;
  }
}","/** 
 * Reads characters into an array as ASCII characters. <p> Due to internal buffering a smaller number of characters than what is requested might be returned. To ensure that the request is fulfilled, call this method in a loop until the requested number of characters is read or <code>-1</code> is returned. <p> Characters outside the ASCII range are replaced with an out of range marker.
 * @param abuf the buffer to read into
 * @param off the offset into the destination buffer
 * @param len maximum number of characters to read
 * @return The number of characters read, or <code>-1</code> if the end ofthe stream is reached.
 */
int readAsciiInto(byte[] abuf,int off,int len) throws IOException {
synchronized (lock) {
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return -1;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    char[] lbuffer=buffer;
    for (int i=0; i < len; i++) {
      char c=lbuffer[readPositionInBuffer + i];
      byte cb;
      if (c <= 255)       cb=(byte)c;
 else       cb=(byte)'?';
      abuf[off + i]=cb;
    }
    readPositionInBuffer+=len;
    return len;
  }
}"
80146,"/** 
 * Fill the buffer, return true if eof has been reached.
 */
private boolean fillBuffer() throws IOException {
  if (in == null)   return true;
  charactersInBuffer=0;
  try {
    try {
      parent.setupContextStack();
      if (this.positionedIn != null) {
        try {
          this.positionedIn.reposition(this.rawStreamPos);
        }
 catch (        StandardException se) {
          throw Util.generateCsSQLException(se);
        }
      }
      readChars:       while ((charactersInBuffer < buffer.length) && ((utfCount < utfLen) || (utfLen == 0)) && ((maxFieldSize == 0) || (readerCharCount < maxFieldSize))) {
        int c=in.read();
        if (c == -1) {
          if (utfLen == 0) {
            closeIn();
            break readChars;
          }
          throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ utfLen+ ""String_Node_Str"");
        }
        int finalChar;
switch (c >> 4) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
          utfCount++;
        finalChar=c;
      break;
case 12:
case 13:
{
      utfCount+=2;
      int char2=in.read();
      if (char2 == -1)       throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ readerCharCount);
      if ((char2 & 0xC0) != 0x80)       throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + char2 + ""String_Node_Str""+ utfCount+ ""String_Node_Str""+ readerCharCount);
      finalChar=(((c & 0x1F) << 6) | (char2 & 0x3F));
      break;
    }
case 14:
{
    utfCount+=3;
    int char2=in.read();
    int char3=in.read();
    if (char2 == -1 || char3 == -1)     throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ readerCharCount);
    if ((c == 0xE0) && (char2 == 0) && (char3 == 0)) {
      if (utfLen == 0) {
        closeIn();
        break readChars;
      }
      throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))     throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + char2 + ""String_Node_Str""+ char3+ ""String_Node_Str""+ utfCount+ ""String_Node_Str""+ readerCharCount);
    finalChar=(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
  }
break;
default :
throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ readerCharCount+ ""String_Node_Str""+ c);
}
buffer[charactersInBuffer++]=(char)finalChar;
readerCharCount++;
}
if (utfLen != 0 && utfCount > utfLen) throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + utfLen + ""String_Node_Str""+ utfCount+ ""String_Node_Str"");
if (charactersInBuffer != 0) {
if (this.positionedIn != null) {
this.rawStreamPos=this.positionedIn.getPosition();
}
return false;
}
closeIn();
return true;
}
  finally {
parent.restoreContextStack();
}
}
 catch (SQLException sqle) {
IOException ioe=new IOException(sqle.getSQLState() + ""String_Node_Str"" + sqle.getMessage());
ioe.initCause(sqle);
throw ioe;
}
}","/** 
 * Fills the internal character buffer by decoding bytes from the stream.
 * @return <code>true</code> if the end of the stream is reached,<code>false</code> if there is apparently more data to be read.
 */
private boolean fillBuffer() throws IOException {
  if (in == null)   return true;
  charactersInBuffer=0;
  try {
    try {
      parent.setupContextStack();
      if (this.positionedIn != null) {
        try {
          this.positionedIn.reposition(this.rawStreamPos);
        }
 catch (        StandardException se) {
          throw Util.generateCsSQLException(se);
        }
      }
      readChars:       while ((charactersInBuffer < buffer.length) && ((utfCount < utfLen) || (utfLen == 0)) && ((maxFieldSize == 0) || (readerCharCount < maxFieldSize))) {
        int c=in.read();
        if (c == -1) {
          if (utfLen == 0) {
            closeIn();
            break readChars;
          }
          throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ utfLen+ ""String_Node_Str"");
        }
        int finalChar;
switch (c >> 4) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
          utfCount++;
        finalChar=c;
      break;
case 12:
case 13:
{
      utfCount+=2;
      int char2=in.read();
      if (char2 == -1)       throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ readerCharCount);
      if ((char2 & 0xC0) != 0x80)       throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + char2 + ""String_Node_Str""+ utfCount+ ""String_Node_Str""+ readerCharCount);
      finalChar=(((c & 0x1F) << 6) | (char2 & 0x3F));
      break;
    }
case 14:
{
    utfCount+=3;
    int char2=in.read();
    int char3=in.read();
    if (char2 == -1 || char3 == -1)     throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ readerCharCount);
    if ((c == 0xE0) && (char2 == 0) && (char3 == 0)) {
      if (utfLen == 0) {
        closeIn();
        break readChars;
      }
      throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))     throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + char2 + ""String_Node_Str""+ char3+ ""String_Node_Str""+ utfCount+ ""String_Node_Str""+ readerCharCount);
    finalChar=(((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));
  }
break;
default :
throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + utfCount + ""String_Node_Str""+ readerCharCount+ ""String_Node_Str""+ c);
}
buffer[charactersInBuffer++]=(char)finalChar;
readerCharCount++;
}
if (utfLen != 0 && utfCount > utfLen) throw utfFormatException(""String_Node_Str"" + ""String_Node_Str"" + utfLen + ""String_Node_Str""+ utfCount+ ""String_Node_Str"");
if (charactersInBuffer != 0) {
if (this.positionedIn != null) {
this.rawStreamPos=this.positionedIn.getPosition();
}
return false;
}
closeIn();
return true;
}
  finally {
parent.restoreContextStack();
}
}
 catch (SQLException sqle) {
IOException ioe=new IOException(sqle.getSQLState() + ""String_Node_Str"" + sqle.getMessage());
ioe.initCause(sqle);
throw ioe;
}
}"
80147,"public long skip(long len) throws IOException {
  if (len < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + len);
  }
synchronized (lock) {
    if (noMoreReads)     throw new IOException(READER_CLOSED);
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return 0L;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    readPositionInBuffer+=len;
    return len;
  }
}","/** 
 * Skips characters.
 * @param len the numbers of characters to skip
 * @return The number of characters actually skipped.
 * @throws IllegalArgumentException if the number of characters to skip isnegative
 * @throws IOException if accessing the underlying stream fails
 */
public long skip(long len) throws IOException {
  if (len < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + len);
  }
synchronized (lock) {
    if (noMoreReads)     throw new IOException(READER_CLOSED);
    if (readPositionInBuffer >= charactersInBuffer) {
      if (fillBuffer()) {
        return 0L;
      }
      readPositionInBuffer=0;
    }
    int remainingInBuffer=charactersInBuffer - readPositionInBuffer;
    if (len > remainingInBuffer)     len=remainingInBuffer;
    readPositionInBuffer+=len;
    return len;
  }
}"
80148,"private void closeIn(){
  if (in != null) {
    try {
      in.close();
    }
 catch (    IOException ioe) {
    }
 finally {
      in=null;
    }
  }
}","/** 
 * Close the underlying stream if it is open.
 */
private void closeIn(){
  if (in != null) {
    try {
      in.close();
    }
 catch (    IOException ioe) {
    }
 finally {
      in=null;
    }
  }
}"
80149,"private IOException utfFormatException(String s){
  noMoreReads=true;
  closeIn();
  return new UTFDataFormatException(s);
}","/** 
 * Convenience method generating an   {@link UTFDataFormatException} andcleaning up the reader state.
 */
private IOException utfFormatException(String s){
  noMoreReads=true;
  closeIn();
  return new UTFDataFormatException(s);
}"
80150,"public void close(){
synchronized (lock) {
    closeIn();
    parent=null;
    noMoreReads=true;
  }
}","/** 
 * Close the reader, disallowing further reads.
 */
public void close(){
synchronized (lock) {
    closeIn();
    parent=null;
    noMoreReads=true;
  }
}"
80151,"private final int readUnsignedShort() throws IOException {
  int ch1=in.read();
  int ch2=in.read();
  if ((ch1 | ch2) < 0)   throw new EOFException(""String_Node_Str"" + ""String_Node_Str"");
  return (ch1 << 8) + (ch2 << 0);
}","/** 
 * Decode the length encoded in the stream. This method came from   {@link java.io.DataInputStream}
 * @return The number of bytes in the stream, or <code>0</code> if thelength is unknown and the end of stream must be marked by the Derby-specific end of stream marker.
 */
private final int readUnsignedShort() throws IOException {
  int ch1=in.read();
  int ch2=in.read();
  if ((ch1 | ch2) < 0)   throw new EOFException(""String_Node_Str"" + ""String_Node_Str"");
  return (ch1 << 8) + (ch2 << 0);
}"
80152,"/** 
 * Removes the supplied LOCATOR entry from the hash map.
 * @param LOCATOR an integer that represents the locator that needs to beremoved from the hash map.
 * @throws SQLException.
 */
public static void CLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
  Clob clob=(Clob)getEmbedConnection().getLOBMapping(LOCATOR);
  if (clob == null) {
    throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
  }
  EmbedClob embedClob=(EmbedClob)clob;
  embedClob.free();
  getEmbedConnection().removeLOBMapping(LOCATOR);
}","/** 
 * Removes the supplied LOCATOR entry from the hash map.
 * @param LOCATOR an integer that represents the locator that needs to beremoved from the hash map.
 * @throws SQLException
 */
public static void CLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
  Clob clob=(Clob)getEmbedConnection().getLOBMapping(LOCATOR);
  if (clob == null) {
    throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
  }
  EmbedClob embedClob=(EmbedClob)clob;
  embedClob.free();
  getEmbedConnection().removeLOBMapping(LOCATOR);
}"
80153,"/** 
 * Returns the length in bytes of the Blob.
 * @param LOCATOR the locator value of the Blob whose length needs tobe found.
 * @return the length of the Blob object mapped to the locator .
 * @throws a SQLException.
 */
public static long BLOBGETLENGTH(int LOCATOR) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).length();
}","/** 
 * Returns the length in bytes of the Blob.
 * @param LOCATOR the locator value of the Blob whose length needs tobe found.
 * @return the length of the Blob object mapped to the locator .
 * @throws SQLException
 */
public static long BLOBGETLENGTH(int LOCATOR) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).length();
}"
80154,"/** 
 * Creates a new empty Clob and registers it in the HashMap in the Connection and returns the locator value corresponding to this Clob.
 * @return an integer that maps to the Clob value created.
 * @throws a SQLException.
 */
public static int CLOBCREATELOCATOR() throws SQLException {
  Clob clob=getEmbedConnection().createClob();
  return getEmbedConnection().addLOBMapping(clob);
}","/** 
 * Creates a new empty Clob and registers it in the HashMap in the Connection and returns the locator value corresponding to this Clob.
 * @return an integer that maps to the Clob value created.
 * @throws SQLException
 */
public static int CLOBCREATELOCATOR() throws SQLException {
  Clob clob=getEmbedConnection().createClob();
  return getEmbedConnection().addLOBMapping(clob);
}"
80155,"/** 
 * returns the length of the Clob corresponding to the LOCATOR value.
 * @param LOCATOR an integer that represents the locator of the Clob whoselength needs to be obtained.
 * @return an integer that represents the length of the Clob.
 */
public static long CLOBGETLENGTH(int LOCATOR) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).length();
}","/** 
 * returns the length of the Clob corresponding to the LOCATOR value.
 * @param LOCATOR an integer that represents the locator of the Clob whoselength needs to be obtained.
 * @return an integer that represents the length of the Clob.
 * @throws java.sql.SQLException 
 */
public static long CLOBGETLENGTH(int LOCATOR) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).length();
}"
80156,"/** 
 * Returns the first occurrence of locator in the Blob.
 * @param LOCATOR the locator value of the Blob in which the seaching needsto be done.
 * @param searchLocator the locator value of the Blob whose position needsneeds to be found.
 * @param pos the position from which the seaching needs to be done.
 * @return the position at which the first occurrence of the Blob isfound.
 * @throws a SQLException.
 */
public static long BLOBGETPOSITIONFROMLOCATOR(int LOCATOR,int searchLocator,long pos) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(getBlobObjectCorrespondingtoLOCATOR(searchLocator),pos);
}","/** 
 * Returns the first occurrence of locator in the Blob.
 * @param LOCATOR the locator value of the Blob in which the seaching needsto be done.
 * @param searchLocator the locator value of the Blob whose position needsneeds to be found.
 * @param pos the position from which the seaching needs to be done.
 * @return the position at which the first occurrence of the Blob isfound.
 * @throws SQLException
 */
public static long BLOBGETPOSITIONFROMLOCATOR(int LOCATOR,int searchLocator,long pos) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(getBlobObjectCorrespondingtoLOCATOR(searchLocator),pos);
}"
80157,"/** 
 * returns the first occurrence of the given search string from the given start search position inside the Clob.
 * @param LOCATOR an integer that represents the locator of the Clobin which the given position of the given sub-string needs to be found.
 * @param searchLiteral a String whose occurence inside the Clob needs tobe found starting from pos.
 * @param fromPosition an integer that represents the position insidethe Clob from which the search needs to begin.
 * @return an integer that represents the position inside the Clob of thefirst occurrence of the sub-string from the given starting position.
 * @throws an SQLException
 */
public static long CLOBGETPOSITIONFROMSTRING(int LOCATOR,String searchLiteral,long fromPosition) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).position(searchLiteral,fromPosition);
}","/** 
 * returns the first occurrence of the given search string from the given start search position inside the Clob.
 * @param LOCATOR an integer that represents the locator of the Clobin which the given position of the given sub-string needs to be found.
 * @param searchLiteral a String whose occurence inside the Clob needs tobe found starting from pos.
 * @param fromPosition an integer that represents the position insidethe Clob from which the search needs to begin.
 * @return an integer that represents the position inside the Clob of thefirst occurrence of the sub-string from the given starting position.
 * @throws SQLException
 */
public static long CLOBGETPOSITIONFROMSTRING(int LOCATOR,String searchLiteral,long fromPosition) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).position(searchLiteral,fromPosition);
}"
80158,"/** 
 * returns the Blob object corresponding to the locator.
 * @param LOCATOR an integer that represents the locator correspondingto the Blob object requested.
 * @return a Blob object that is mapped to the LOCATOR object passed in.
 * @throws a SQLException.
 */
private static Blob getBlobObjectCorrespondingtoLOCATOR(int LOCATOR) throws SQLException {
  Blob blob=(Blob)getEmbedConnection().getLOBMapping(LOCATOR);
  if (blob == null) {
    throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
  }
  return blob;
}","/** 
 * returns the Blob object corresponding to the locator.
 * @param LOCATOR an integer that represents the locator correspondingto the Blob object requested.
 * @return a Blob object that is mapped to the LOCATOR object passed in.
 * @throws SQLException
 */
private static Blob getBlobObjectCorrespondingtoLOCATOR(int LOCATOR) throws SQLException {
  Blob blob=(Blob)getEmbedConnection().getLOBMapping(LOCATOR);
  if (blob == null) {
    throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
  }
  return blob;
}"
80159,"/** 
 * truncates the Clob value represented by LOCATOR to have a length of length.
 * @param LOCATOR an integer that represents the LOCATOR used to retrieve aninstance of the LOB.
 * @param length an integer that represents the length to which the Clobmust be truncated to.
 * @throws a SQLException.
 */
public static void CLOBTRUNCATE(int LOCATOR,long length) throws SQLException {
  getClobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
}","/** 
 * truncates the Clob value represented by LOCATOR to have a length of length.
 * @param LOCATOR an integer that represents the LOCATOR used to retrieve aninstance of the LOB.
 * @param length an integer that represents the length to which the Clobmust be truncated to.
 * @throws SQLException
 */
public static void CLOBTRUNCATE(int LOCATOR,long length) throws SQLException {
  getClobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
}"
80160,"/** 
 * Creates a new empty Blob and registers it in the HashMap in the Connection and returns the locator value corresponding to this Blob.
 * @return an integer that maps to the Blob value created.
 * @throws a SQLException.
 */
public static int BLOBCREATELOCATOR() throws SQLException {
  Blob blob=getEmbedConnection().createBlob();
  return getEmbedConnection().addLOBMapping(blob);
}","/** 
 * Creates a new empty Blob and registers it in the HashMap in the Connection and returns the locator value corresponding to this Blob.
 * @return an integer that maps to the Blob value created.
 * @throws SQLException
 */
public static int BLOBCREATELOCATOR() throws SQLException {
  Blob blob=getEmbedConnection().createBlob();
  return getEmbedConnection().addLOBMapping(blob);
}"
80161,"/** 
 * replaces the characters starting at fromPosition and with length ForLength
 * @param LOCATOR an integer that represents the locator of the Clob in whichthe characters need to be replaced.
 * @param pos an integer that represents the position inside the Clob from whichthe string needs to be replaced.
 * @param length the number of characters from the string that need to be used forreplacement.
 * @param str the string from which the repalcement characters are built.
 * @throws an SQLException.
 */
public static void CLOBSETSTRING(int LOCATOR,long pos,int length,String str) throws SQLException {
  getClobObjectCorrespondingtoLOCATOR(LOCATOR).setString(pos,str,0,length);
}","/** 
 * replaces the characters starting at fromPosition and with length ForLength
 * @param LOCATOR an integer that represents the locator of the Clob in whichthe characters need to be replaced.
 * @param pos an integer that represents the position inside the Clob from whichthe string needs to be replaced.
 * @param length the number of characters from the string that need to be used forreplacement.
 * @param str the string from which the repalcement characters are built.
 * @throws SQLException
 */
public static void CLOBSETSTRING(int LOCATOR,long pos,int length,String str) throws SQLException {
  getClobObjectCorrespondingtoLOCATOR(LOCATOR).setString(pos,str,0,length);
}"
80162,"/** 
 * returns the first occurrence of the given search string from the given start search position inside the Clob.
 * @param LOCATOR an integer that represents the locator of the Clobin which the given position of the given sub-string needs to be found.
 * @param searchLocator a Locator representing a Clob whose occurence insidethe Clob needs to be found starting from pos.
 * @param fromPosition an integer that represents the position insidethe Clob from which the search needs to begin.
 * @return an integer that represents the position inside the Clob of thefirst occurrence of the sub-string from the given starting position.
 * @throws an SQLException
 */
public static long CLOBGETPOSITIONFROMLOCATOR(int LOCATOR,int searchLocator,long fromPosition) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).position(getClobObjectCorrespondingtoLOCATOR(searchLocator),fromPosition);
}","/** 
 * returns the first occurrence of the given search string from the given start search position inside the Clob.
 * @param LOCATOR an integer that represents the locator of the Clobin which the given position of the given sub-string needs to be found.
 * @param searchLocator a Locator representing a Clob whose occurence insidethe Clob needs to be found starting from pos.
 * @param fromPosition an integer that represents the position insidethe Clob from which the search needs to begin.
 * @return an integer that represents the position inside the Clob of thefirst occurrence of the sub-string from the given starting position.
 * @throws SQLException
 */
public static long CLOBGETPOSITIONFROMLOCATOR(int LOCATOR,int searchLocator,long fromPosition) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).position(getClobObjectCorrespondingtoLOCATOR(searchLocator),fromPosition);
}"
80163,"/** 
 * returns the String starting from pos and of len length from the LOB corresponding to LOCATOR.
 * @param LOCATOR an integer that represents the LOCATOR usedto retrieve an instance of the LOB.
 * @param pos a long that represents the position from whichthe substring begins.
 * @param len an integer that represents the length of the substring.
 * @return the substring conforming to the indexes we requested for frominside the LOB.
 * @throws a SQLException
 */
public static String CLOBGETSUBSTRING(int LOCATOR,long pos,int len) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).getSubString(pos,len);
}","/** 
 * returns the String starting from pos and of len length from the LOB corresponding to LOCATOR.
 * @param LOCATOR an integer that represents the LOCATOR usedto retrieve an instance of the LOB.
 * @param pos a long that represents the position from whichthe substring begins.
 * @param len an integer that represents the length of the substring.
 * @return the substring conforming to the indexes we requested for frominside the LOB.
 * @throws SQLException
 */
public static String CLOBGETSUBSTRING(int LOCATOR,long pos,int len) throws SQLException {
  return getClobObjectCorrespondingtoLOCATOR(LOCATOR).getSubString(pos,len);
}"
80164,"/** 
 * Replaces the bytes at pos with len bytes
 * @param LOCATOR the integer that represents the Blob in which the bytesneed to be replaced.
 * @param pos the position stating from which the byte replacement needs tohappen.
 * @param len the number of bytes that need to be used in replacement.
 * @param replaceBytes the byte array that contains the bytes that needs tobe used for replacement.
 * @throws a SQLException.
 */
public static void BLOBSETBYTES(int LOCATOR,long pos,int len,byte[] replaceBytes) throws SQLException {
  getBlobObjectCorrespondingtoLOCATOR(LOCATOR).setBytes(pos,replaceBytes,0,len);
}","/** 
 * Replaces the bytes at pos with len bytes
 * @param LOCATOR the integer that represents the Blob in which the bytesneed to be replaced.
 * @param pos the position stating from which the byte replacement needs tohappen.
 * @param len the number of bytes that need to be used in replacement.
 * @param replaceBytes the byte array that contains the bytes that needs tobe used for replacement.
 * @throws SQLException
 */
public static void BLOBSETBYTES(int LOCATOR,long pos,int len,byte[] replaceBytes) throws SQLException {
  getBlobObjectCorrespondingtoLOCATOR(LOCATOR).setBytes(pos,replaceBytes,0,len);
}"
80165,"/** 
 * Removes the supplied LOCATOR entry from the hash map.
 * @param LOCATOR an integer that represents the locator that needs to beremoved from the hash map.
 * @throws SQLException.
 */
public static void BLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
  Blob blob=(Blob)getEmbedConnection().getLOBMapping(LOCATOR);
  if (blob == null) {
    throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
  }
  EmbedBlob embedBlob=(EmbedBlob)blob;
  embedBlob.free();
  getEmbedConnection().removeLOBMapping(LOCATOR);
}","/** 
 * Removes the supplied LOCATOR entry from the hash map.
 * @param LOCATOR an integer that represents the locator that needs to beremoved from the hash map.
 * @throws SQLException
 */
public static void BLOBRELEASELOCATOR(int LOCATOR) throws SQLException {
  Blob blob=(Blob)getEmbedConnection().getLOBMapping(LOCATOR);
  if (blob == null) {
    throw newSQLException(SQLState.LOB_LOCATOR_INVALID);
  }
  EmbedBlob embedBlob=(EmbedBlob)blob;
  embedBlob.free();
  getEmbedConnection().removeLOBMapping(LOCATOR);
}"
80166,"/** 
 * Returns the first occurrence of the byte array in the Blob.
 * @param LOCATOR the locator value of the Blob in which the seaching needsto be done.
 * @param searchBytes the byte array whose position needs needs to be found.
 * @param pos the position from which the seaching needs to be done.
 * @return the position at which the first occurrence of the Byte array isfound.
 * @throws a SQLException.
 */
public static long BLOBGETPOSITIONFROMBYTES(int LOCATOR,byte[] searchBytes,long pos) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(searchBytes,pos);
}","/** 
 * Returns the first occurrence of the byte array in the Blob.
 * @param LOCATOR the locator value of the Blob in which the seaching needsto be done.
 * @param searchBytes the byte array whose position needs needs to be found.
 * @param pos the position from which the seaching needs to be done.
 * @return the position at which the first occurrence of the Byte array isfound.
 * @throws SQLException
 */
public static long BLOBGETPOSITIONFROMBYTES(int LOCATOR,byte[] searchBytes,long pos) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).position(searchBytes,pos);
}"
80167,"/** 
 * Returns the Byte array containing the bytes starting from pos and of length len
 * @param LOCATOR the locator value of the Blob from which the byte arrayneeds to be retrieved.
 * @param len the length of te byte array that needs to be retrieved frompos
 * @param pos the position from which the bytes from the Blob need to beretrieved.
 * @return a byte array containing the bytes stating from pos andof length len.
 * @throws a SQLException.
 */
public static byte[] BLOBGETBYTES(int LOCATOR,long pos,int len) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).getBytes(pos,len);
}","/** 
 * Returns the Byte array containing the bytes starting from pos and of length len
 * @param LOCATOR the locator value of the Blob from which the byte arrayneeds to be retrieved.
 * @param len the length of the byte array that needs to be retrieved frompos
 * @param pos the position from which the bytes from the Blob need to beretrieved.
 * @return a byte array containing the bytes stating from pos andof length len.
 * @throws SQLException
 */
public static byte[] BLOBGETBYTES(int LOCATOR,long pos,int len) throws SQLException {
  return getBlobObjectCorrespondingtoLOCATOR(LOCATOR).getBytes(pos,len);
}"
80168,"/** 
 * truncates the Blob value represented by LOCATOR to have a length of length.
 * @param LOCATOR an integer that represents the LOCATOR used to retrieve aninstance of the LOB.
 * @param length an integer that represents the length to which the Blobmust be truncated to.
 * @throws a SQLException.
 */
public static void BLOBTRUNCATE(int LOCATOR,long length) throws SQLException {
  getBlobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
}","/** 
 * truncates the Blob value represented by LOCATOR to have a length of length.
 * @param LOCATOR an integer that represents the LOCATOR used to retrieve aninstance of the LOB.
 * @param length an integer that represents the length to which the Blobmust be truncated to.
 * @throws SQLException
 */
public static void BLOBTRUNCATE(int LOCATOR,long length) throws SQLException {
  getBlobObjectCorrespondingtoLOCATOR(LOCATOR).truncate(length);
}"
80169,"/** 
 * Builds a list of columns suitable for creating this Catalog. The last column, the serialized statement, is not added to the column list.  This is done deliberately to make it a 'hidden' column -- one that is not visible to customers, but is visible to the system.
 * @return array of SystemColumn suitable for making this catalog.
 */
public SystemColumn[] buildColumnList(){
  return new SystemColumn[]{SystemColumnImpl.getUUIDColumn(""String_Node_Str"",false),SystemColumnImpl.getIdentifierColumn(""String_Node_Str"",false),SystemColumnImpl.getUUIDColumn(""String_Node_Str"",false),SystemColumnImpl.getIndicatorColumn(""String_Node_Str""),SystemColumnImpl.getColumn(""String_Node_Str"",Types.BOOLEAN,false),SystemColumnImpl.getColumn(""String_Node_Str"",Types.LONGVARCHAR,false,TypeId.LONGVARCHAR_MAXWIDTH),SystemColumnImpl.getColumn(""String_Node_Str"",Types.TIMESTAMP,true),SystemColumnImpl.getUUIDColumn(""String_Node_Str"",false),SystemColumnImpl.getColumn(""String_Node_Str"",Types.LONGVARCHAR,false,TypeId.LONGVARCHAR_MAXWIDTH)};
}","/** 
 * Builds a list of columns suitable for creating this Catalog. The last column, the serialized statement, is not added to the column list.  This is done deliberately to make it a 'hidden' column -- one that is not visible to customers, but is visible to the system.
 * @return array of SystemColumn suitable for making this catalog.
 */
public SystemColumn[] buildColumnList(){
  return new SystemColumn[]{SystemColumnImpl.getUUIDColumn(""String_Node_Str"",false),SystemColumnImpl.getIdentifierColumn(""String_Node_Str"",false),SystemColumnImpl.getUUIDColumn(""String_Node_Str"",false),SystemColumnImpl.getIndicatorColumn(""String_Node_Str""),SystemColumnImpl.getColumn(""String_Node_Str"",Types.BOOLEAN,false),SystemColumnImpl.getColumn(""String_Node_Str"",Types.LONGVARCHAR,false,TypeId.LONGVARCHAR_MAXWIDTH),SystemColumnImpl.getColumn(""String_Node_Str"",Types.TIMESTAMP,true),SystemColumnImpl.getUUIDColumn(""String_Node_Str"",true),SystemColumnImpl.getColumn(""String_Node_Str"",Types.LONGVARCHAR,true,TypeId.LONGVARCHAR_MAXWIDTH)};
}"
80170,"/** 
 * Return a suite that uses a single use database with a primary fixture from this test plus potentially other fixtures.
 * @param locale Locale to use for the database
 * @param baseFixture Base fixture from this test.
 * @return suite of tests to run for the given locale
 */
private static Test collatedSuite(String locale,String baseFixture){
  TestSuite suite=new TestSuite(""String_Node_Str"" + locale);
  suite.addTest(new CollationTest(baseFixture));
  suite.addTest(DatabaseMetaDataTest.suite());
  return Decorator.territoryCollatedDatabase(suite,locale);
}","/** 
 * Return a suite that uses a single use database with a primary fixture from this test plus potentially other fixtures.
 * @param locale Locale to use for the database
 * @param baseFixture Base fixture from this test.
 * @return suite of tests to run for the given locale
 */
private static Test collatedSuite(String locale,String baseFixture){
  TestSuite suite=new TestSuite(""String_Node_Str"" + locale);
  suite.addTest(new CollationTest(baseFixture));
  suite.addTest(DatabaseMetaDataTest.suite());
  suite.addTest(BatchUpdateTest.embeddedSuite());
  suite.addTest(GroupByExpressionTest.suite());
  suite.addTest(UpdatableResultSetTest.suite());
  return Decorator.territoryCollatedDatabase(suite,locale);
}"
80171,"/** 
 * Check the metatdata for a prepared statement that does not return a ResultSet is empty
 * @param conn connection to use
 * @param sql sql for prepared statement
 * @param execute execute PreparedStatement if true
 * @throws SQLException
 */
private void checkEmptyMetaData(String sql,boolean execute) throws SQLException {
  PreparedStatement ps=prepareStatement(sql);
  ResultSetMetaData rsmd=ps.getMetaData();
  assertEmptyResultSetMetaData(rsmd);
  if (execute)   ps.executeUpdate();
  ps.close();
}","/** 
 * Check the metatdata for a prepared statement that does not return a ResultSet is empty
 * @param sql sql for prepared statement
 * @param execute execute PreparedStatement if true
 * @throws SQLException
 */
private void checkEmptyMetaData(String sql,boolean execute) throws SQLException {
  PreparedStatement ps=prepareStatement(sql);
  ResultSetMetaData rsmd=ps.getMetaData();
  assertEmptyResultSetMetaData(rsmd);
  if (execute)   ps.executeUpdate();
  ps.close();
}"
80172,"/** 
 * Return a suite that uses a single use database with a primary fixture from this test plus potentially other fixtures.
 * @param locale Locale to use for the database
 * @param baseFixture Base fixture from this test.
 * @return
 */
private static Test collatedSuite(String locale,String baseFixture){
  TestSuite suite=new TestSuite(""String_Node_Str"" + locale);
  suite.addTest(new CollationTest(baseFixture));
  return Decorator.territoryCollatedDatabase(suite,locale);
}","/** 
 * Return a suite that uses a single use database with a primary fixture from this test plus potentially other fixtures.
 * @param locale Locale to use for the database
 * @param baseFixture Base fixture from this test.
 * @return suite of tests to run for the given locale
 */
private static Test collatedSuite(String locale,String baseFixture){
  TestSuite suite=new TestSuite(""String_Node_Str"" + locale);
  suite.addTest(new CollationTest(baseFixture));
  return Decorator.territoryCollatedDatabase(suite,locale);
}"
80173,"/** 
 * This function public for testing purposes.
 * @param trimType
 * @param trimChar
 * @param source
 * @return
 */
private String trimInternal(int trimType,char trimChar,String source){
  if (source == null) {
    return null;
  }
  int len=source.length();
  int start=0;
  if (trimType == LEADING || trimType == BOTH) {
    for (; start < len; start++)     if (trimChar != source.charAt(start))     break;
  }
  if (start == len)   return ""String_Node_Str"";
  int end=len - 1;
  if (trimType == TRAILING || trimType == BOTH) {
    for (; end >= 0; end--)     if (trimChar != source.charAt(end))     break;
  }
  if (end == -1)   return ""String_Node_Str"";
  return source.substring(start,end + 1);
}","/** 
 * This function public for testing purposes.
 * @param trimType  Type of trim (LEADING, TRAILING, or BOTH)
 * @param trimChar  Character to trim
 * @param source    String from which to trim trimChar
 * @return A String containing the result of the trim.
 */
private String trimInternal(int trimType,char trimChar,String source){
  if (source == null) {
    return null;
  }
  int len=source.length();
  int start=0;
  if (trimType == LEADING || trimType == BOTH) {
    for (; start < len; start++)     if (trimChar != source.charAt(start))     break;
  }
  if (start == len)   return ""String_Node_Str"";
  int end=len - 1;
  if (trimType == TRAILING || trimType == BOTH) {
    for (; end >= 0; end--)     if (trimChar != source.charAt(end))     break;
  }
  if (end == -1)   return ""String_Node_Str"";
  return source.substring(start,end + 1);
}"
80174,"/** 
 * @param trimType
 * @param trimChar
 * @param result
 * @return
 */
public StringDataValue ansiTrim(int trimType,StringDataValue trimChar,StringDataValue result) throws StandardException {
  if (result == null) {
    result=getNewVarchar();
  }
  if (trimChar == null || trimChar.getString() == null) {
    result.setToNull();
    return result;
  }
  if (trimChar.getString().length() != 1) {
    throw StandardException.newException(SQLState.LANG_INVALID_TRIM_CHARACTER,trimChar.getString());
  }
  char trimCharacter=trimChar.getString().charAt(0);
  result.setValue(trimInternal(trimType,trimCharacter,getString()));
  return result;
}","/** 
 * @param trimType  Type of trim (LEADING, TRAILING, or BOTH)
 * @param trimChar  Character to trim from this SQLChar (may be null)
 * @param result    The result of a previous call to this method,null if not called yet.
 * @return A StringDataValue containing the result of the trim.
 */
public StringDataValue ansiTrim(int trimType,StringDataValue trimChar,StringDataValue result) throws StandardException {
  if (result == null) {
    result=getNewVarchar();
  }
  if (trimChar == null || trimChar.getString() == null) {
    result.setToNull();
    return result;
  }
  if (trimChar.getString().length() != 1) {
    throw StandardException.newException(SQLState.LANG_INVALID_TRIM_CHARACTER,trimChar.getString());
  }
  char trimCharacter=trimChar.getString().charAt(0);
  result.setValue(trimInternal(trimType,trimCharacter,getString()));
  return result;
}"
80175,"public Object run() throws IOException {
  lobFile.delete();
  return null;
}","public Object run() throws IOException {
  sf.delete();
  return null;
}"
80176,"/** 
 * Replaces a block of bytes in the middle of the LOB with a another block of bytes, which may be of a different size. <p> The new byte array may not be be of same length as the original, thus it may result in resizing the total lob.
 * @param buf byte array which will be written inplace of old block
 * @param stPos inclusive starting position of current block
 * @param endPos exclusive end position of current block
 * @return Current position after write.
 * @throws IOExcepton if writing to temporary file fails
 * @throws StandardException
 * @throws SQLException
 */
synchronized long replaceBytes(byte[] buf,long stPos,long endPos) throws IOException, SQLException, StandardException {
  long length=getLength();
  long finalLength=length - endPos + stPos + buf.length;
  if (isBytes) {
    if (finalLength > bufferSize) {
      byte[] tmpBytes=dataBytes;
      init(tmpBytes,stPos);
      write(buf,0,buf.length,getLength());
      if (endPos < length)       write(tmpBytes,(int)endPos,(int)(length - endPos),getLength());
    }
 else {
      byte[] tmpByte=new byte[(int)finalLength];
      System.arraycopy(dataBytes,0,tmpByte,0,(int)stPos);
      System.arraycopy(buf,0,tmpByte,(int)stPos,(int)buf.length);
      if (endPos < length)       System.arraycopy(dataBytes,(int)endPos,tmpByte,(int)(stPos + buf.length),(int)(length - endPos));
      dataBytes=tmpByte;
    }
  }
 else {
    byte tmp[]=new byte[0];
    LOBFile oldFile=tmpFile;
    init(tmp,0);
    byte[] tmpByte=new byte[1024];
    long sz=stPos;
    oldFile.seek(0);
    while (sz != 0) {
      int readLen=(int)Math.min(1024,sz);
      int actualLength=oldFile.read(tmpByte,0,readLen);
      if (actualLength == -1)       break;
      tmpFile.write(tmpByte,0,actualLength);
      sz-=actualLength;
    }
    tmpFile.write(buf);
    oldFile.seek(endPos);
    int rdLen;
    if (endPos < length) {
      do {
        rdLen=oldFile.read(tmpByte,0,1024);
        if (rdLen == -1)         break;
        tmpFile.write(tmpByte,0,rdLen);
      }
 while (true);
    }
  }
  updateCount++;
  return stPos + buf.length;
}","/** 
 * Replaces a block of bytes in the middle of the LOB with a another block of bytes, which may be of a different size. <p> The new byte array may not be be of same length as the original, thus it may result in resizing the total lob.
 * @param buf byte array which will be written inplace of old block
 * @param stPos inclusive starting position of current block
 * @param endPos exclusive end position of current block
 * @return Current position after write.
 * @throws IOExcepton if writing to temporary file fails
 * @throws StandardException
 * @throws SQLException
 */
synchronized long replaceBytes(byte[] buf,long stPos,long endPos) throws IOException, SQLException, StandardException {
  long length=getLength();
  long finalLength=length - endPos + stPos + buf.length;
  if (isBytes) {
    if (finalLength > bufferSize) {
      byte[] tmpBytes=dataBytes;
      init(tmpBytes,stPos);
      write(buf,0,buf.length,getLength());
      if (endPos < length)       write(tmpBytes,(int)endPos,(int)(length - endPos),getLength());
    }
 else {
      byte[] tmpByte=new byte[(int)finalLength];
      System.arraycopy(dataBytes,0,tmpByte,0,(int)stPos);
      System.arraycopy(buf,0,tmpByte,(int)stPos,(int)buf.length);
      if (endPos < length)       System.arraycopy(dataBytes,(int)endPos,tmpByte,(int)(stPos + buf.length),(int)(length - endPos));
      dataBytes=tmpByte;
    }
  }
 else {
    byte tmp[]=new byte[0];
    LOBFile oldFile=tmpFile;
    StorageFile oldStoreFile=lobFile;
    init(tmp,0);
    byte[] tmpByte=new byte[1024];
    long sz=stPos;
    oldFile.seek(0);
    while (sz != 0) {
      int readLen=(int)Math.min(1024,sz);
      int actualLength=oldFile.read(tmpByte,0,readLen);
      if (actualLength == -1)       break;
      tmpFile.write(tmpByte,0,actualLength);
      sz-=actualLength;
    }
    tmpFile.write(buf);
    oldFile.seek(endPos);
    int rdLen;
    if (endPos < length) {
      do {
        rdLen=oldFile.read(tmpByte,0,1024);
        if (rdLen == -1)         break;
        tmpFile.write(tmpByte,0,rdLen);
      }
 while (true);
      oldFile.close();
      deleteFile(oldStoreFile);
    }
  }
  updateCount++;
  return stPos + buf.length;
}"
80177,"/** 
 * Invalidates all the variables and closes file handle if open.
 * @throws IOexception
 */
void free() throws IOException {
  dataBytes=null;
  if (tmpFile != null) {
    tmpFile.close();
    try {
      AccessController.doPrivileged(new PrivilegedExceptionAction(){
        public Object run() throws IOException {
          lobFile.delete();
          return null;
        }
      }
);
    }
 catch (    PrivilegedActionException pae) {
      Exception e=pae.getException();
      if (e instanceof IOException)       throw (IOException)e;
      if (e instanceof RuntimeException)       throw (RuntimeException)e;
      IOException ioe=new IOException(e.getMessage());
      ioe.initCause(e);
      throw ioe;
    }
  }
}","/** 
 * Invalidates all the variables and closes file handle if open.
 * @throws IOexception
 */
void free() throws IOException {
  dataBytes=null;
  if (tmpFile != null) {
    tmpFile.close();
    deleteFile(lobFile);
    tmpFile=null;
  }
}"
80178,"public int read(byte[] buf,int off,int length){
  if (remainingBlanks <= 0 && remainingNonBlanks <= 0) {
    return -1;
  }
  int nonBlankLength=Math.min((int)remainingNonBlanks,length);
  fillBuffer(nonBlankLength);
  int read=0;
  int bOff=alphabet.nextByteToRead(0);
  if (nonBlankLength <= (buffer.length - bOff)) {
    System.arraycopy(buffer,bOff,buf,off,nonBlankLength);
    remainingNonBlanks-=nonBlankLength;
    read=nonBlankLength;
    alphabet.nextByteToRead(nonBlankLength);
  }
 else {
    int toRead=0;
    while (remainingNonBlanks > 0 && read < nonBlankLength) {
      bOff=alphabet.nextByteToRead(toRead);
      toRead=Math.min(buffer.length - bOff,nonBlankLength - read);
      System.arraycopy(buffer,bOff,buf,off + read,toRead);
      remainingNonBlanks-=toRead;
      read+=toRead;
    }
    bOff=alphabet.nextByteToRead(toRead);
  }
  if (read < length && remainingBlanks > 0) {
    read+=fillBlanks(buf,off + read,length - read);
  }
  return read;
}","public int read(byte[] buf,int off,int length){
  if (remainingBlanks <= 0 && remainingNonBlanks <= 0) {
    return -1;
  }
  int nonBlankLength=(int)Math.min(remainingNonBlanks,(long)length);
  fillBuffer(nonBlankLength);
  int read=0;
  int bOff=alphabet.nextByteToRead(0);
  if (nonBlankLength <= (buffer.length - bOff)) {
    System.arraycopy(buffer,bOff,buf,off,nonBlankLength);
    remainingNonBlanks-=nonBlankLength;
    read=nonBlankLength;
    alphabet.nextByteToRead(nonBlankLength);
  }
 else {
    int toRead=0;
    while (remainingNonBlanks > 0 && read < nonBlankLength) {
      bOff=alphabet.nextByteToRead(toRead);
      toRead=Math.min(buffer.length - bOff,nonBlankLength - read);
      System.arraycopy(buffer,bOff,buf,off + read,toRead);
      remainingNonBlanks-=toRead;
      read+=toRead;
    }
    bOff=alphabet.nextByteToRead(toRead);
  }
  if (read < length && remainingBlanks > 0) {
    read+=fillBlanks(buf,off + read,length - read);
  }
  return read;
}"
80179,"/** 
 * Returns a writer to write data into the Clob. <p> The semantics of the writer is the same as for   {@link #setString}.
 * @param charPos the starting character position. The first character isat position <code>1</code>.
 * @return A writer initialized at the specified character position.
 * @throws IOException if writing to the Clob fails
 * @throws SQLException if accessing underlying resources fail
 * @throws UnsupportedOperationException if the Clob representation isread-only
 */
Writer getWriter(long pos) throws IOException, SQLException ;","/** 
 * Returns a writer to write data into the Clob. <p> The semantics of the writer is the same as for   {@link #insertString}.
 * @param charPos the starting character position. The first character isat position <code>1</code>.
 * @return A writer initialized at the specified character position.
 * @throws IOException if writing to the Clob fails
 * @throws SQLException if accessing underlying resources fail
 * @throws UnsupportedOperationException if the Clob representation isread-only
 */
Writer getWriter(long charPos) throws IOException, SQLException ;"
80180,"/** 
 * Test simple call to DatabaseMetaData.getColumns() <p> This test is the same form of the getColumns() call that  the IMPORT and EXPORT system procedures depend on.  Currently on ibm and sun 1.4.2 jvm's this test fails.
 */
private void runDERBY_2703(Connection conn,int db_index) throws SQLException {
  if (is142JVM())   return;
  setUpTable(conn);
  ResultSet rs=conn.getMetaData().getColumns(null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  SanityManager.DEBUG_PRINT(""String_Node_Str"",""String_Node_Str"");
  Assert.assertTrue(""String_Node_Str"",rs.next());
  if (verbose_debug)   System.out.println(""String_Node_Str"" + rs.getString(4));
  while (rs.next()) {
    if (verbose_debug)     System.out.println(""String_Node_Str"" + rs.getString(4));
  }
  rs.close();
  dropTable(conn);
}","/** 
 * Test simple call to DatabaseMetaData.getColumns() <p> This test is the same form of the getColumns() call that  the IMPORT and EXPORT system procedures depend on.  Currently on ibm and sun 1.4.2 jvm's this test fails.
 */
private void runDERBY_2703(Connection conn,int db_index) throws SQLException {
  if (is142JVM())   return;
  setUpTable(conn);
  ResultSet rs=conn.getMetaData().getColumns(null,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (SanityManager.DEBUG) {
    SanityManager.DEBUG_PRINT(""String_Node_Str"",""String_Node_Str"");
  }
  Assert.assertTrue(""String_Node_Str"",rs.next());
  if (verbose_debug)   System.out.println(""String_Node_Str"" + rs.getString(4));
  while (rs.next()) {
    if (verbose_debug)     System.out.println(""String_Node_Str"" + rs.getString(4));
  }
  rs.close();
  dropTable(conn);
}"
80181,"/** 
 * Drops the given ConstraintDescriptor from the data dictionary. NOTE: Caller is responsible for dropping any backing index
 * @param table	The table from which to drop theconstraint descriptor
 * @param descriptor	The descriptor to drop
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
public void dropConstraintDescriptor(ConstraintDescriptor descriptor,TransactionController tc) throws StandardException ;","/** 
 * Drops the given ConstraintDescriptor from the data dictionary. NOTE: Caller is responsible for dropping any backing index
 * @param descriptor	The descriptor to drop
 * @param tc	The TransactionController.
 * @exception StandardException		Thrown on failure
 */
public void dropConstraintDescriptor(ConstraintDescriptor descriptor,TransactionController tc) throws StandardException ;"
80182,"/** 
 * @see TypeCompiler#generateDataValue(ExpressionClassBuilder,MethodBuilder,int,String,LocalField) 
 */
public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  super.generateDataValue(eb,mb,collationType,field);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}","/** 
 * Augment the parent's method by ensuring the generated value is setup for collation if required.
 * @see BaseTypeCompiler#generateCollationSensitiveDataValue(ExpressionClassBuilder,MethodBuilder,int)
 */
public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  super.generateDataValue(eb,mb,collationType,field);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}"
80183,"/** 
 * @see TypeCompiler#generateNull(ExpressionClassBuilder,MethodBuilder,int,String)
 */
public void generateNull(ExpressionClassBuilder eb,MethodBuilder mb,int collationType){
  super.generateNull(eb,mb,collationType);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}","/** 
 * Augment the parent's method by ensuring the generated value is setup for collation if required.
 * @see BaseTypeCompiler#generateCollationSensitiveDataValue(ExpressionClassBuilder,MethodBuilder,int)
 */
public void generateNull(ExpressionClassBuilder eb,MethodBuilder mb,int collationType){
  super.generateNull(eb,mb,collationType);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}"
80184,"/** 
 * @see TypeCompiler#generateDataValue(ExpressionClassBuilder,MethodBuilder,int,String,LocalField) 
 */
public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  super.generateDataValue(eb,mb,collationType,field);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}","/** 
 * Augment the parent's method by ensuring the generated value is setup for collation if required.
 * @see BaseTypeCompiler#generateCollationSensitiveDataValue(ExpressionClassBuilder,MethodBuilder,int)
 */
public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  super.generateDataValue(eb,mb,collationType,field);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}"
80185,"/** 
 * @see TypeCompiler#generateNull(ExpressionClassBuilder,MethodBuilder,int,String)
 */
public void generateNull(ExpressionClassBuilder eb,MethodBuilder mb,int collationType){
  super.generateNull(eb,mb,collationType);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}","/** 
 * Augment the parent's method by ensuring the generated value is setup for collation if required.
 * @see BaseTypeCompiler#generateCollationSensitiveDataValue(ExpressionClassBuilder,MethodBuilder,int)
 */
public void generateNull(ExpressionClassBuilder eb,MethodBuilder mb,int collationType){
  super.generateNull(eb,mb,collationType);
  generateCollationSensitiveDataValue(eb,mb,collationType);
}"
80186,"/** 
 * @see TypeCompiler#generateDataValue(ExpressionClassBuilder,MethodBuilder,int,String,LocalField) 
 */
public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  if (!JVMInfo.J2ME && getTypeId().isDecimalTypeId()) {
    mb.upCast(""String_Node_Str"");
  }
  super.generateDataValue(eb,mb,collationType,field);
}","public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  if (!JVMInfo.J2ME && getTypeId().isDecimalTypeId()) {
    mb.upCast(""String_Node_Str"");
  }
  super.generateDataValue(eb,mb,collationType,field);
}"
80187,"/** 
 * @see TypeCompiler#generateDataValue(ExpressionClassBuilder,MethodBuilder,int,String,LocalField) 
 */
public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  mb.upCast(""String_Node_Str"");
  super.generateDataValue(eb,mb,collationType,field);
}","public void generateDataValue(ExpressionClassBuilder eb,MethodBuilder mb,int collationType,LocalField field){
  mb.upCast(""String_Node_Str"");
  super.generateDataValue(eb,mb,collationType,field);
}"
80188,"/** 
 * Gets the foreign key information for this constant action. A full list of foreign keys was compiled into this constant action.
 * @param ec	the ExecutionContext
 * @return	the list of foreign keys to enforce for this action
 */
final FKInfo[] getFKInfo(){
  return fkInfo;
}","/** 
 * Gets the foreign key information for this constant action. A full list of foreign keys was compiled into this constant action.
 * @return	the list of foreign keys to enforce for this action
 */
final FKInfo[] getFKInfo(){
  return fkInfo;
}"
80189,"ElementEnum(){
  try {
    scan=tc.openScan(rowConglomerateId,false,0,TransactionController.MODE_TABLE,TransactionController.ISOLATION_NOLOCK,(FormatableBitSet)null,(DataValueDescriptor[])null,0,(Qualifier[][])null,(DataValueDescriptor[])null,0);
    hasMore=scan.next();
    if (!hasMore) {
      scan.close();
      scan=null;
    }
  }
 catch (  StandardException se) {
    hasMore=false;
    if (scan != null) {
      try {
        scan.close();
      }
 catch (      StandardException se1) {
      }
      ;
      scan=null;
    }
  }
}","ElementEnum(){
  try {
    scan=tc.openScan(rowConglomerateId,keepAfterCommit,0,TransactionController.MODE_TABLE,TransactionController.ISOLATION_NOLOCK,(FormatableBitSet)null,(DataValueDescriptor[])null,0,(Qualifier[][])null,(DataValueDescriptor[])null,0);
    hasMore=scan.next();
    if (!hasMore) {
      scan.close();
      scan=null;
    }
 else     if (keepAfterCommit) {
      rowloc=rowConglomerate.newRowLocationTemplate();
      scan.fetchLocation(rowloc);
    }
  }
 catch (  StandardException se) {
    hasMore=false;
    if (scan != null) {
      try {
        scan.close();
      }
 catch (      StandardException se1) {
      }
      ;
      scan=null;
    }
  }
}"
80190,"/** 
 * Creates a new <code>DiskHashtable</code> instance.
 * @param tc
 * @param template              An array of DataValueDescriptors that serves as a template for the rows.
 * @param key_column_numbers    The indexes of the key columns (0 based)
 * @param remove_duplicates     If true then rows with duplicate keys are removed.
 * @param keepAfterCommit       If true then the hash table is kept after a commit
 */
public DiskHashtable(TransactionController tc,DataValueDescriptor[] template,int[] collation_ids,int[] key_column_numbers,boolean remove_duplicates,boolean keepAfterCommit) throws StandardException {
  this.tc=tc;
  this.key_column_numbers=key_column_numbers;
  this.remove_duplicates=remove_duplicates;
  LanguageConnectionContext lcc=(LanguageConnectionContext)ContextService.getContextOrNull(LanguageConnectionContext.CONTEXT_ID);
  keepStatistics=(lcc != null) && lcc.getRunTimeStatisticsMode();
  row=new DataValueDescriptor[template.length];
  for (int i=0; i < row.length; i++) {
    row[i]=template[i].getNewNull();
    if (SanityManager.DEBUG) {
      SanityManager.ASSERT(row[i] != null,""String_Node_Str"");
    }
  }
  int tempFlags=keepAfterCommit ? (TransactionController.IS_TEMPORARY | TransactionController.IS_KEPT) : TransactionController.IS_TEMPORARY;
  rowConglomerateId=tc.createConglomerate(""String_Node_Str"",template,(ColumnOrdering[])null,collation_ids,(Properties)null,tempFlags);
  rowConglomerate=tc.openConglomerate(rowConglomerateId,keepAfterCommit,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_NOLOCK);
  btreeRow=new DataValueDescriptor[]{new SQLInteger(),rowConglomerate.newRowLocationTemplate()};
  Properties btreeProps=new Properties();
  btreeProps.put(""String_Node_Str"",String.valueOf(rowConglomerateId));
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  int[] index_collation_ids={StringDataValue.COLLATION_TYPE_UCS_BASIC,StringDataValue.COLLATION_TYPE_UCS_BASIC};
  btreeConglomerateId=tc.createConglomerate(""String_Node_Str"",btreeRow,(ColumnOrdering[])null,index_collation_ids,btreeProps,tempFlags);
  btreeConglomerate=tc.openConglomerate(btreeConglomerateId,keepAfterCommit,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_NOLOCK);
}","/** 
 * Creates a new <code>DiskHashtable</code> instance.
 * @param tc
 * @param template              An array of DataValueDescriptors that serves as a template for the rows.
 * @param key_column_numbers    The indexes of the key columns (0 based)
 * @param remove_duplicates     If true then rows with duplicate keys are removed.
 * @param keepAfterCommit       If true then the hash table is kept after a commit
 */
public DiskHashtable(TransactionController tc,DataValueDescriptor[] template,int[] collation_ids,int[] key_column_numbers,boolean remove_duplicates,boolean keepAfterCommit) throws StandardException {
  this.tc=tc;
  this.key_column_numbers=key_column_numbers;
  this.remove_duplicates=remove_duplicates;
  this.keepAfterCommit=keepAfterCommit;
  LanguageConnectionContext lcc=(LanguageConnectionContext)ContextService.getContextOrNull(LanguageConnectionContext.CONTEXT_ID);
  keepStatistics=(lcc != null) && lcc.getRunTimeStatisticsMode();
  row=new DataValueDescriptor[template.length];
  for (int i=0; i < row.length; i++) {
    row[i]=template[i].getNewNull();
    if (SanityManager.DEBUG) {
      SanityManager.ASSERT(row[i] != null,""String_Node_Str"");
    }
  }
  int tempFlags=keepAfterCommit ? (TransactionController.IS_TEMPORARY | TransactionController.IS_KEPT) : TransactionController.IS_TEMPORARY;
  rowConglomerateId=tc.createConglomerate(""String_Node_Str"",template,(ColumnOrdering[])null,collation_ids,(Properties)null,tempFlags);
  rowConglomerate=tc.openConglomerate(rowConglomerateId,keepAfterCommit,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_NOLOCK);
  btreeRow=new DataValueDescriptor[]{new SQLInteger(),rowConglomerate.newRowLocationTemplate()};
  Properties btreeProps=new Properties();
  btreeProps.put(""String_Node_Str"",String.valueOf(rowConglomerateId));
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  btreeProps.put(""String_Node_Str"",""String_Node_Str"");
  int[] index_collation_ids={StringDataValue.COLLATION_TYPE_UCS_BASIC,StringDataValue.COLLATION_TYPE_UCS_BASIC};
  btreeConglomerateId=tc.createConglomerate(""String_Node_Str"",btreeRow,(ColumnOrdering[])null,index_collation_ids,btreeProps,tempFlags);
  btreeConglomerate=tc.openConglomerate(btreeConglomerateId,keepAfterCommit,TransactionController.OPENMODE_FORUPDATE,TransactionController.MODE_TABLE,TransactionController.ISOLATION_NOLOCK);
}"
80191,"public Object nextElement(){
  if (!hasMore)   throw new NoSuchElementException();
  try {
    scan.fetch(row);
    Object retValue=BackingStoreHashtable.shallowCloneRow(row);
    hasMore=scan.next();
    if (!hasMore) {
      scan.close();
      scan=null;
    }
    return retValue;
  }
 catch (  StandardException se) {
    if (scan != null) {
      try {
        scan.close();
      }
 catch (      StandardException se1) {
      }
      ;
      scan=null;
    }
    throw new NoSuchElementException();
  }
}","public Object nextElement(){
  if (!hasMore)   throw new NoSuchElementException();
  try {
    if (scan.isHeldAfterCommit()) {
      if (!scan.positionAtRowLocation(rowloc)) {
        throw StandardException.newException(SQLState.NO_CURRENT_ROW);
      }
    }
    scan.fetch(row);
    Object retValue=BackingStoreHashtable.shallowCloneRow(row);
    hasMore=scan.next();
    if (!hasMore) {
      scan.close();
      scan=null;
    }
 else     if (keepAfterCommit) {
      scan.fetchLocation(rowloc);
    }
    return retValue;
  }
 catch (  StandardException se) {
    if (scan != null) {
      try {
        scan.close();
      }
 catch (      StandardException se1) {
      }
      ;
      scan=null;
    }
    throw new NoSuchElementException();
  }
}"
80192,"/** 
 * Create a HashSet which contains all rows that qualify for the  described scan. <p> All parameters shared between openScan() and this routine are  interpreted exactly the same.  Logically this routine calls openScan() with the passed in set of parameters, and then places all returned rows into a newly created HashSet and returns, actual implementations will likely perform better than actually calling openScan() and doing this.  For documentation of the openScan  parameters see openScan(). <p>
 * @return the BackingStoreHashtable which was created.
 * @param conglomId             see openScan()
 * @param open_mode             see openScan()
 * @param lock_level            see openScan()
 * @param isolation_level       see openScan()
 * @param scanColumnList        see openScan()
 * @param startKeyValue         see openScan()
 * @param startSearchOperator   see openScan()
 * @param qualifier             see openScan()
 * @param stopKeyValue          see openScan()
 * @param stopSearchOperator    see openScan()
 * @param max_rowcnt            The maximum number of rows to insert into the HashSet.  Pass in -1 if there is no  maximum.
 * @param key_column_numbers    The column numbers of the columns in thescan result row to be the key to the  Hashtable.  ""0"" is the first column in the  scan result row (which may be different  than the first row in the table of the  scan).
 * @param remove_duplicates     Should the HashSet automatically removeduplicates, or should it create the Vector  of duplicates?
 * @param estimated_rowcnt      The number of rows that the caller estimates will be inserted into the sort.  -1 indicates that the caller has no idea. Used by the sort to make good choices about in-memory vs. external sorting, and to size merge runs.
 * @param max_inmemory_rowcnt   The number of rows at which the underlyingHashtable implementation should cut over from an in-memory hash to a disk based access method.
 * @param initialCapacity       If not ""-1"" used to initialize the javaHashtable.
 * @param loadFactor            If not ""-1"" used to initialize the javaHashtable.
 * @param collect_runtimestats  If true will collect up runtime stats duringscan processing for retrieval by BackingStoreHashtable.getRuntimeStats().
 * @param skipNullKeyColumns	Whether or not to skip rows with 1 or more null key columns
 * @see BackingStoreHashtable
 * @see TransactionController#openScan
 * @exception StandardException  Standard exception policy.
 */
BackingStoreHashtable createBackingStoreHashtableFromScan(long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier qualifier[][],DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns) throws StandardException ;","/** 
 * Create a HashSet which contains all rows that qualify for the  described scan. <p> All parameters shared between openScan() and this routine are  interpreted exactly the same.  Logically this routine calls openScan() with the passed in set of parameters, and then places all returned rows into a newly created HashSet and returns, actual implementations will likely perform better than actually calling openScan() and doing this.  For documentation of the openScan  parameters see openScan(). <p>
 * @return the BackingStoreHashtable which was created.
 * @param conglomId             see openScan()
 * @param open_mode             see openScan()
 * @param lock_level            see openScan()
 * @param isolation_level       see openScan()
 * @param scanColumnList        see openScan()
 * @param startKeyValue         see openScan()
 * @param startSearchOperator   see openScan()
 * @param qualifier             see openScan()
 * @param stopKeyValue          see openScan()
 * @param stopSearchOperator    see openScan()
 * @param max_rowcnt            The maximum number of rows to insert into the HashSet.  Pass in -1 if there is no  maximum.
 * @param key_column_numbers    The column numbers of the columns in thescan result row to be the key to the  Hashtable.  ""0"" is the first column in the  scan result row (which may be different  than the first row in the table of the  scan).
 * @param remove_duplicates     Should the HashSet automatically removeduplicates, or should it create the Vector  of duplicates?
 * @param estimated_rowcnt      The number of rows that the caller estimates will be inserted into the sort.  -1 indicates that the caller has no idea. Used by the sort to make good choices about in-memory vs. external sorting, and to size merge runs.
 * @param max_inmemory_rowcnt   The number of rows at which the underlyingHashtable implementation should cut over from an in-memory hash to a disk based access method.
 * @param initialCapacity       If not ""-1"" used to initialize the javaHashtable.
 * @param loadFactor            If not ""-1"" used to initialize the javaHashtable.
 * @param collect_runtimestats  If true will collect up runtime stats duringscan processing for retrieval by BackingStoreHashtable.getRuntimeStats().
 * @param skipNullKeyColumns	Whether or not to skip rows with 1 or more null key columns
 * @param keepAfterCommit       If true then the hash table is kept after acommit
 * @see BackingStoreHashtable
 * @see TransactionController#openScan
 * @exception StandardException  Standard exception policy.
 */
BackingStoreHashtable createBackingStoreHashtableFromScan(long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier qualifier[][],DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns,boolean keepAfterCommit) throws StandardException ;"
80193,"HashScanResultSet(long conglomId,StaticCompiledOpenConglomInfo scoci,Activation activation,GeneratedMethod resultRowAllocator,int resultSetNumber,GeneratedMethod startKeyGetter,int startSearchOperator,GeneratedMethod stopKeyGetter,int stopSearchOperator,boolean sameStartStopPosition,Qualifier[][] scanQualifiers,Qualifier[][] nextQualifiers,int initialCapacity,float loadFactor,int maxCapacity,int hashKeyItem,String tableName,String userSuppliedOptimizerOverrides,String indexName,boolean isConstraint,boolean forUpdate,int colRefItem,int lockMode,boolean tableLocked,int isolationLevel,boolean skipNullKeyColumns,double optimizerEstimatedRowCount,double optimizerEstimatedCost) throws StandardException {
  super(activation,resultSetNumber,resultRowAllocator,lockMode,tableLocked,isolationLevel,optimizerEstimatedRowCount,optimizerEstimatedCost);
  this.scoci=scoci;
  this.conglomId=conglomId;
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(activation != null,""String_Node_Str"");
    SanityManager.ASSERT(resultRowAllocator != null,""String_Node_Str"");
    if (sameStartStopPosition) {
      SanityManager.ASSERT(stopKeyGetter == null,""String_Node_Str"");
    }
  }
  this.resultRowAllocator=resultRowAllocator;
  this.startKeyGetter=startKeyGetter;
  this.startSearchOperator=startSearchOperator;
  this.stopKeyGetter=stopKeyGetter;
  this.stopSearchOperator=stopSearchOperator;
  this.sameStartStopPosition=sameStartStopPosition;
  this.scanQualifiers=scanQualifiers;
  this.nextQualifiers=nextQualifiers;
  this.initialCapacity=initialCapacity;
  this.loadFactor=loadFactor;
  this.maxCapacity=maxCapacity;
  this.tableName=tableName;
  this.userSuppliedOptimizerOverrides=userSuppliedOptimizerOverrides;
  this.indexName=indexName;
  this.isConstraint=isConstraint;
  this.forUpdate=forUpdate;
  this.skipNullKeyColumns=skipNullKeyColumns;
  FormatableArrayHolder fah=(FormatableArrayHolder)(activation.getPreparedStatement().getSavedObject(hashKeyItem));
  FormatableIntHolder[] fihArray=(FormatableIntHolder[])fah.getArray(FormatableIntHolder.class);
  keyColumns=new int[fihArray.length];
  for (int index=0; index < fihArray.length; index++) {
    keyColumns[index]=fihArray[index].getInt();
  }
  this.accessedCols=null;
  if (colRefItem != -1) {
    this.accessedCols=(FormatableBitSet)(activation.getPreparedStatement().getSavedObject(colRefItem));
  }
  runTimeStatisticsOn=getLanguageConnectionContext().getRunTimeStatisticsMode();
  compactRow=getCompactRow(candidate,accessedCols,(FormatableBitSet)null,false);
  constructorTime+=getElapsedMillis(beginTime);
}","HashScanResultSet(long conglomId,StaticCompiledOpenConglomInfo scoci,Activation activation,GeneratedMethod resultRowAllocator,int resultSetNumber,GeneratedMethod startKeyGetter,int startSearchOperator,GeneratedMethod stopKeyGetter,int stopSearchOperator,boolean sameStartStopPosition,Qualifier[][] scanQualifiers,Qualifier[][] nextQualifiers,int initialCapacity,float loadFactor,int maxCapacity,int hashKeyItem,String tableName,String userSuppliedOptimizerOverrides,String indexName,boolean isConstraint,boolean forUpdate,int colRefItem,int lockMode,boolean tableLocked,int isolationLevel,boolean skipNullKeyColumns,double optimizerEstimatedRowCount,double optimizerEstimatedCost) throws StandardException {
  super(activation,resultSetNumber,resultRowAllocator,lockMode,tableLocked,isolationLevel,optimizerEstimatedRowCount,optimizerEstimatedCost);
  this.scoci=scoci;
  this.conglomId=conglomId;
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(activation != null,""String_Node_Str"");
    SanityManager.ASSERT(resultRowAllocator != null,""String_Node_Str"");
    if (sameStartStopPosition) {
      SanityManager.ASSERT(stopKeyGetter == null,""String_Node_Str"");
    }
  }
  this.resultRowAllocator=resultRowAllocator;
  this.startKeyGetter=startKeyGetter;
  this.startSearchOperator=startSearchOperator;
  this.stopKeyGetter=stopKeyGetter;
  this.stopSearchOperator=stopSearchOperator;
  this.sameStartStopPosition=sameStartStopPosition;
  this.scanQualifiers=scanQualifiers;
  this.nextQualifiers=nextQualifiers;
  this.initialCapacity=initialCapacity;
  this.loadFactor=loadFactor;
  this.maxCapacity=maxCapacity;
  this.tableName=tableName;
  this.userSuppliedOptimizerOverrides=userSuppliedOptimizerOverrides;
  this.indexName=indexName;
  this.isConstraint=isConstraint;
  this.forUpdate=forUpdate;
  this.skipNullKeyColumns=skipNullKeyColumns;
  this.keepAfterCommit=activation.getResultSetHoldability();
  FormatableArrayHolder fah=(FormatableArrayHolder)(activation.getPreparedStatement().getSavedObject(hashKeyItem));
  FormatableIntHolder[] fihArray=(FormatableIntHolder[])fah.getArray(FormatableIntHolder.class);
  keyColumns=new int[fihArray.length];
  for (int index=0; index < fihArray.length; index++) {
    keyColumns[index]=fihArray[index].getInt();
  }
  this.accessedCols=null;
  if (colRefItem != -1) {
    this.accessedCols=(FormatableBitSet)(activation.getPreparedStatement().getSavedObject(colRefItem));
  }
  runTimeStatisticsOn=getLanguageConnectionContext().getRunTimeStatisticsMode();
  compactRow=getCompactRow(candidate,accessedCols,(FormatableBitSet)null,false);
  constructorTime+=getElapsedMillis(beginTime);
}"
80194,"/** 
 * open a scan on the table. scan parameters are evaluated at each open, so there is probably some way of altering their values...
 * @exception StandardException thrown on failure to open
 */
public void openCore() throws StandardException {
  TransactionController tc;
  beginTime=getCurrentTimeMillis();
  if (SanityManager.DEBUG)   SanityManager.ASSERT(!isOpen,""String_Node_Str"");
  tc=activation.getTransactionController();
  initIsolationLevel();
  if (startKeyGetter != null) {
    startPosition=(ExecIndexRow)startKeyGetter.invoke(activation);
    if (sameStartStopPosition) {
      stopPosition=startPosition;
    }
  }
  if (stopKeyGetter != null) {
    stopPosition=(ExecIndexRow)stopKeyGetter.invoke(activation);
  }
  if (skipScan(startPosition,stopPosition)) {
    ;
  }
 else   if (!hashtableBuilt) {
    DataValueDescriptor[] startPositionRow=startPosition == null ? null : startPosition.getRowArray();
    DataValueDescriptor[] stopPositionRow=stopPosition == null ? null : stopPosition.getRowArray();
    hashtable=tc.createBackingStoreHashtableFromScan(conglomId,(forUpdate ? TransactionController.OPENMODE_FORUPDATE : 0),lockMode,isolationLevel,accessedCols,startPositionRow,startSearchOperator,scanQualifiers,stopPositionRow,stopSearchOperator,-1,keyColumns,eliminateDuplicates,-1,maxCapacity,initialCapacity,loadFactor,runTimeStatisticsOn,skipNullKeyColumns);
    if (runTimeStatisticsOn) {
      hashtableSize=hashtable.size();
      if (scanProperties == null) {
        scanProperties=new Properties();
      }
      try {
        if (hashtable != null) {
          hashtable.getAllRuntimeStats(scanProperties);
        }
      }
 catch (      StandardException se) {
      }
    }
    hashtableBuilt=true;
    activation.informOfRowCount(this,(long)hashtableSize);
  }
  isOpen=true;
  resetProbeVariables();
  numOpens++;
  openTime+=getElapsedMillis(beginTime);
}","/** 
 * open a scan on the table. scan parameters are evaluated at each open, so there is probably some way of altering their values...
 * @exception StandardException thrown on failure to open
 */
public void openCore() throws StandardException {
  TransactionController tc;
  beginTime=getCurrentTimeMillis();
  if (SanityManager.DEBUG)   SanityManager.ASSERT(!isOpen,""String_Node_Str"");
  tc=activation.getTransactionController();
  initIsolationLevel();
  if (startKeyGetter != null) {
    startPosition=(ExecIndexRow)startKeyGetter.invoke(activation);
    if (sameStartStopPosition) {
      stopPosition=startPosition;
    }
  }
  if (stopKeyGetter != null) {
    stopPosition=(ExecIndexRow)stopKeyGetter.invoke(activation);
  }
  if (skipScan(startPosition,stopPosition)) {
    ;
  }
 else   if (!hashtableBuilt) {
    DataValueDescriptor[] startPositionRow=startPosition == null ? null : startPosition.getRowArray();
    DataValueDescriptor[] stopPositionRow=stopPosition == null ? null : stopPosition.getRowArray();
    hashtable=tc.createBackingStoreHashtableFromScan(conglomId,(forUpdate ? TransactionController.OPENMODE_FORUPDATE : 0),lockMode,isolationLevel,accessedCols,startPositionRow,startSearchOperator,scanQualifiers,stopPositionRow,stopSearchOperator,-1,keyColumns,eliminateDuplicates,-1,maxCapacity,initialCapacity,loadFactor,runTimeStatisticsOn,skipNullKeyColumns,keepAfterCommit);
    if (runTimeStatisticsOn) {
      hashtableSize=hashtable.size();
      if (scanProperties == null) {
        scanProperties=new Properties();
      }
      try {
        if (hashtable != null) {
          hashtable.getAllRuntimeStats(scanProperties);
        }
      }
 catch (      StandardException se) {
      }
    }
    hashtableBuilt=true;
    activation.informOfRowCount(this,(long)hashtableSize);
  }
  isOpen=true;
  resetProbeVariables();
  numOpens++;
  openTime+=getElapsedMillis(beginTime);
}"
80195,"/** 
 * Constructors for This class:
 */
public BackingStoreHashTableFromScan(TransactionController tc,long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier qualifier[][],DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns) throws StandardException {
  super(tc,(RowSource)null,key_column_numbers,remove_duplicates,estimated_rowcnt,max_inmemory_rowcnt,initialCapacity,loadFactor,skipNullKeyColumns,false);
  open_scan=(ScanManager)tc.openScan(conglomId,false,open_mode,lock_level,isolation_level,scanColumnList,startKeyValue,startSearchOperator,qualifier,stopKeyValue,stopSearchOperator);
  open_scan.fetchSet(max_rowcnt,key_column_numbers,this);
  if (collect_runtimestats) {
    Properties prop=new Properties();
    open_scan.getScanInfo().getAllScanInfo(prop);
    this.setAuxillaryRuntimeStats(prop);
    prop=null;
  }
}","/** 
 * Constructors for This class:
 */
public BackingStoreHashTableFromScan(TransactionController tc,long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier qualifier[][],DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns,boolean keepAfterCommit) throws StandardException {
  super(tc,(RowSource)null,key_column_numbers,remove_duplicates,estimated_rowcnt,max_inmemory_rowcnt,initialCapacity,loadFactor,skipNullKeyColumns,keepAfterCommit);
  open_scan=(ScanManager)tc.openScan(conglomId,false,open_mode,lock_level,isolation_level,scanColumnList,startKeyValue,startSearchOperator,qualifier,stopKeyValue,stopSearchOperator);
  open_scan.fetchSet(max_rowcnt,key_column_numbers,this);
  if (collect_runtimestats) {
    Properties prop=new Properties();
    open_scan.getScanInfo().getAllScanInfo(prop);
    this.setAuxillaryRuntimeStats(prop);
    prop=null;
  }
}"
80196,"/** 
 * Create a BackingStoreHashtable which contains all rows that qualify for the described scan.
 */
public BackingStoreHashtable createBackingStoreHashtableFromScan(long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier qualifier[][],DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns) throws StandardException {
  return (new BackingStoreHashTableFromScan(this,conglomId,open_mode,lock_level,isolation_level,scanColumnList,startKeyValue,startSearchOperator,qualifier,stopKeyValue,stopSearchOperator,max_rowcnt,key_column_numbers,remove_duplicates,estimated_rowcnt,max_inmemory_rowcnt,initialCapacity,loadFactor,collect_runtimestats,skipNullKeyColumns));
}","/** 
 * Create a BackingStoreHashtable which contains all rows that qualify for the described scan.
 */
public BackingStoreHashtable createBackingStoreHashtableFromScan(long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier qualifier[][],DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns,boolean keepAfterCommit) throws StandardException {
  return (new BackingStoreHashTableFromScan(this,conglomId,open_mode,lock_level,isolation_level,scanColumnList,startKeyValue,startSearchOperator,qualifier,stopKeyValue,stopSearchOperator,max_rowcnt,key_column_numbers,remove_duplicates,estimated_rowcnt,max_inmemory_rowcnt,initialCapacity,loadFactor,collect_runtimestats,skipNullKeyColumns,keepAfterCommit));
}"
80197,"public BackingStoreHashtable createBackingStoreHashtableFromScan(long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier[][] qualifier,DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns) throws StandardException {
  return null;
}","public BackingStoreHashtable createBackingStoreHashtableFromScan(long conglomId,int open_mode,int lock_level,int isolation_level,FormatableBitSet scanColumnList,DataValueDescriptor[] startKeyValue,int startSearchOperator,Qualifier[][] qualifier,DataValueDescriptor[] stopKeyValue,int stopSearchOperator,long max_rowcnt,int[] key_column_numbers,boolean remove_duplicates,long estimated_rowcnt,long max_inmemory_rowcnt,int initialCapacity,float loadFactor,boolean collect_runtimestats,boolean skipNullKeyColumns,boolean keepAfterCommit) throws StandardException {
  return null;
}"
80198,"/** 
 * Create an <code>InputStream</code> for reading the <code>Clob</code> value represented by the given locator based <code>Clob</code> object.
 * @param connection connection to be used to read the<code>Clob</code> value from the server
 * @param clob <code>Clob</code> object that contains locator forthe <code>Clob</code> value on the server.
 */
public ClobLocatorInputStream(Connection connection,Clob clob){
  SanityManager.ASSERT(clob.isLocator());
  this.connection=connection;
  this.clob=clob;
}","/** 
 * Create an <code>InputStream</code> for reading the <code>Clob</code> value represented by the given locator based <code>Clob</code> object.
 * @param connection connection to be used to read the<code>Clob</code> value from the server
 * @param clob <code>Clob</code> object that contains locator forthe <code>Clob</code> value on the server.
 */
public ClobLocatorInputStream(Connection connection,Clob clob){
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(clob.isLocator());
  }
  this.connection=connection;
  this.clob=clob;
}"
80199,"/** 
 * @see SQLChar.stringCompare(SQLChar, SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char2);
}","/** 
 * @see SQLChar#stringCompare(SQLChar,SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char1,char2);
}"
80200,"/** 
 * @see SQLChar.stringCompare(SQLChar, SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char2);
}","/** 
 * @see SQLChar#stringCompare(SQLChar,SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char1,char2);
}"
80201,"/** 
 * @see SQLChar.stringCompare(SQLChar, SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char2);
}","/** 
 * @see SQLChar#stringCompare(SQLChar,SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char1,char2);
}"
80202,"/** 
 * @see SQLChar.stringCompare(SQLChar, SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char2);
}","/** 
 * @see SQLChar#stringCompare(SQLChar,SQLChar) 
 */
protected int stringCompare(SQLChar char1,SQLChar char2) throws StandardException {
  return holderForCollationSensitiveInfo.stringCompare(char1,char2);
}"
80203,"/** 
 * @see SQLChar.stringCompare(SQLChar, SQLChar) 
 */
protected int stringCompare(SQLChar str2) throws StandardException {
  CollationKey ckey1=stringData.getCollationKey();
  CollationKey ckey2=str2.getCollationKey();
  if (ckey1 == null || ckey2 == null) {
    if (ckey1 != null)     return -1;
    if (ckey2 != null)     return 1;
    return 0;
  }
  return ckey1.compareTo(ckey2);
}","/** 
 * @see SQLChar.stringCompare(SQLChar, SQLChar) 
 */
protected int stringCompare(SQLChar str1,SQLChar str2) throws StandardException {
  CollationKey ckey1=str1.getCollationKey();
  CollationKey ckey2=str2.getCollationKey();
  if (ckey1 == null || ckey2 == null) {
    if (ckey1 != null)     return -1;
    if (ckey2 != null)     return 1;
    return 0;
  }
  return ckey1.compareTo(ckey2);
}"
80204,"/** 
 * Test order by with default collation
 * @throws SQLException
 */
public void testDefaultCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  checkLangBasedQuery(ds,new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
}","/** 
 * Test order by with default collation
 * @throws SQLException
 */
public void testDefaultCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  setUpTable(ds);
  checkLangBasedQuery(ds,""String_Node_Str"",new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  checkLangBasedQuery(ds,""String_Node_Str"",null);
  checkLangBasedQuery(ds,""String_Node_Str"",null);
  dropTable(ds);
}"
80205,"/** 
 * sort customers by 
 * @param ds
 * @param expectedResult
 * @throws SQLException
 */
private void checkLangBasedQuery(DataSource ds,String[][] expectedResult) throws SQLException {
  Connection conn=ds.getConnection();
  Statement s=conn.createStatement();
  s.execute(""String_Node_Str"");
  conn.setAutoCommit(false);
  PreparedStatement ps=conn.prepareStatement(""String_Node_Str"");
  for (int i=0; i < NAMES.length; i++) {
    ps.setInt(1,i);
    ps.setString(2,NAMES[i]);
    ps.executeUpdate();
  }
  ResultSet rs=s.executeQuery(""String_Node_Str"");
  JDBC.assertFullResultSet(rs,expectedResult);
  s.execute(""String_Node_Str"");
  conn.commit();
  ps.close();
}","/** 
 * sort customers by 
 * @param ds
 * @param expectedResult Null for this means that the passed query is expected to return an empty resultset. If not empty, then the resultset from the query should match this paramter
 * @throws SQLException
 */
private void checkLangBasedQuery(DataSource ds,String query,String[][] expectedResult) throws SQLException {
  Connection conn=ds.getConnection();
  conn.setAutoCommit(false);
  Statement s=conn.createStatement();
  ResultSet rs=s.executeQuery(query);
  if (expectedResult == null)   JDBC.assertEmpty(rs);
 else   JDBC.assertFullResultSet(rs,expectedResult);
  s.close();
  conn.commit();
}"
80206,"/** 
 * Test order by with English collation
 * @throws SQLException
 */
public void testEnglishCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  checkLangBasedQuery(ds,new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
}","/** 
 * Test order by with English collation
 * @throws SQLException
 */
public void testEnglishCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  setUpTable(ds);
  checkLangBasedQuery(ds,""String_Node_Str"",new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  checkLangBasedQuery(ds,""String_Node_Str"",null);
  checkLangBasedQuery(ds,""String_Node_Str"",new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  dropTable(ds);
}"
80207,"/** 
 * Test order by with polish collation
 * @throws SQLException
 */
public void testPolishCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  checkLangBasedQuery(ds,new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
}","/** 
 * Test order by with polish collation
 * @throws SQLException
 */
public void testPolishCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  setUpTable(ds);
  checkLangBasedQuery(ds,""String_Node_Str"",new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  checkLangBasedQuery(ds,""String_Node_Str"",null);
  checkLangBasedQuery(ds,""String_Node_Str"",new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  dropTable(ds);
}"
80208,"/** 
 * Test order by with Norwegian collation
 * @throws SQLException
 */
public void testNorwayCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  checkLangBasedQuery(ds,new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
}","/** 
 * Test order by with Norwegian collation
 * @throws SQLException
 */
public void testNorwayCollation() throws SQLException {
  DataSource ds=JDBCDataSource.getDataSourceLogical(""String_Node_Str"");
  JDBCDataSource.setBeanProperty(ds,""String_Node_Str"",""String_Node_Str"");
  setUpTable(ds);
  checkLangBasedQuery(ds,""String_Node_Str"",new String[][]{{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""},{""String_Node_Str"",""String_Node_Str""}});
  checkLangBasedQuery(ds,""String_Node_Str"",null);
  checkLangBasedQuery(ds,""String_Node_Str"",null);
  dropTable(ds);
}"
80209,"/** 
 * Create an <code>InputStream</code> for reading the <code>Blob</code> value represented by the given locator based <code>Blob</code> object.
 * @param connection connection to be used to read the<code>Blob</code> value from the server
 * @param blob <code>Blob</code> object that contains locator forthe <code>Blob</code> value on the server.
 * @param offset the offset in the <code>Blob</code> of the firstbyte to read.  
 * @param length the maximum number of bytes to read fromthe <code>Blob</code>.
 * @throws SqlException if an error occurs when obtaining thelength of the <code>Blob</code>.
 */
public BlobLocatorInputStream(Connection connection,Blob blob,long position,long length) throws SqlException {
  SanityManager.ASSERT(blob.isLocator());
  this.connection=connection;
  this.blob=blob;
  this.currentPos=position;
  this.maxPos=Math.min(blob.sqlLength(),position + length - 1);
}","/** 
 * Create an <code>InputStream</code> for reading the <code>Blob</code> value represented by the given locator based <code>Blob</code> object.
 * @param connection connection to be used to read the<code>Blob</code> value from the server
 * @param blob <code>Blob</code> object that contains locator forthe <code>Blob</code> value on the server.
 * @param position the position in the <code>Blob</code> of the firstbyte to read.  
 * @param length the maximum number of bytes to read fromthe <code>Blob</code>.
 * @throws SqlException if an error occurs when obtaining thelength of the <code>Blob</code>.
 */
public BlobLocatorInputStream(Connection connection,Blob blob,long position,long length) throws SqlException {
  SanityManager.ASSERT(blob.isLocator());
  this.connection=connection;
  this.blob=blob;
  this.currentPos=position;
  this.maxPos=Math.min(blob.sqlLength(),position + length - 1);
}"
80210,"/** 
 * Create an <code>InputStream</code> for reading the <code>Blob</code> value represented by the given locator based <code>Blob</code> object.
 * @param connection connection to be used to read the<code>Blob</code> value from the server
 * @param blob <code>Blob</code> object that contains locator forthe <code>Blob</code> value on the server.
 */
public BlobLocatorInputStream(Connection connection,Blob blob){
  SanityManager.ASSERT(blob.isLocator());
  this.connection=connection;
  this.blob=blob;
}","/** 
 * Create an <code>InputStream</code> for reading the <code>Blob</code> value represented by the given locator based <code>Blob</code> object.
 * @param connection connection to be used to read the<code>Blob</code> value from the server
 * @param blob <code>Blob</code> object that contains locator forthe <code>Blob</code> value on the server.
 */
public BlobLocatorInputStream(Connection connection,Blob blob){
  if (SanityManager.DEBUG) {
    SanityManager.ASSERT(blob.isLocator());
  }
  this.connection=connection;
  this.blob=blob;
}"
80211,"/** 
 * Generate the code necessary to produce a SQL value based on a value.  The value's type is assumed to match the type of this TypeId.  For example, a TypeId for the SQL int type should be given an value that evaluates to a Java int or Integer. If the type of the value is incorrect, the generated code will not work. The stack must contain data value factory value.
 * @param mb	The method to put the expression in
 * @param collationType For character DVDs, this will be used to determinewhat Collator should be associated with the DVD which in turn will  decide whether to generate CollatorSQLcharDVDs or SQLcharDVDs. For  other types of DVDs, this parameter will be ignored.
 * @param className name of the base class of the activation's hierarchy
 * @param field LocalField
 */
void generateDataValue(MethodBuilder eb,int collationType,String className,LocalField field);","/** 
 * Generate the code necessary to produce a SQL value based on a value.  The value's type is assumed to match the type of this TypeId.  For example, a TypeId for the SQL int type should be given an value that evaluates to a Java int or Integer. If the type of the value is incorrect, the generated code will not work. The stack must contain data value factory value.
 * @param eb	The method to put the expression in
 * @param collationType For character DVDs, this will be used to determinewhat Collator should be associated with the DVD which in turn will  decide whether to generate CollatorSQLcharDVDs or SQLcharDVDs. For  other types of DVDs, this parameter will be ignored.
 * @param className name of the base class of the activation's hierarchy
 * @param field LocalField
 */
void generateDataValue(MethodBuilder eb,int collationType,String className,LocalField field);"
80212,"/** 
 * DERBY-1759: Serialization of attribute nodes.
 */
public void testAttrSerialization() throws Exception {
  Statement st=createStatement();
  st.executeUpdate(""String_Node_Str"");
  assertUpdateCount(st,1,""String_Node_Str"");
  assertUpdateCount(st,1,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ResultSet rs=st.executeQuery(""String_Node_Str"");
  String[] expColNames=new String[]{""String_Node_Str"",""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  String[][] expRS=new String[][]{{""String_Node_Str"",null},{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true);
  assertStatementError(""String_Node_Str"",st,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  rs=st.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  expColNames=new String[]{""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  expRS=new String[][]{{""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true);
  rs=st.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  expColNames=new String[]{""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  expRS=new String[][]{{""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true);
  if (usingEmbedded()) {
    SQLWarning sqlWarn=rs.getWarnings();
    if (sqlWarn == null)     sqlWarn=st.getWarnings();
    if (sqlWarn == null)     sqlWarn=getConnection().getWarnings();
    assertTrue(""String_Node_Str"",(sqlWarn != null));
    assertSQLState(""String_Node_Str"",sqlWarn);
  }
  rs=st.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  expColNames=new String[]{""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  expRS=new String[][]{{""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true);
  st.executeUpdate(""String_Node_Str"");
  st.close();
}","/** 
 * DERBY-1759: Serialization of attribute nodes.
 */
public void testAttrSerialization() throws Exception {
  Statement st=createStatement();
  st.executeUpdate(""String_Node_Str"");
  assertUpdateCount(st,1,""String_Node_Str"");
  assertUpdateCount(st,1,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  ResultSet rs=st.executeQuery(""String_Node_Str"");
  String[] expColNames=new String[]{""String_Node_Str"",""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  String[][] expRS=new String[][]{{""String_Node_Str"",null},{""String_Node_Str"",""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true);
  assertStatementError(""String_Node_Str"",st,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  rs=st.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  expColNames=new String[]{""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  expRS=new String[][]{{""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true);
  rs=st.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  expColNames=new String[]{""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  expRS=new String[][]{{""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true,false);
  if (usingEmbedded()) {
    SQLWarning sqlWarn=rs.getWarnings();
    if (sqlWarn == null)     sqlWarn=st.getWarnings();
    if (sqlWarn == null)     sqlWarn=getConnection().getWarnings();
    assertTrue(""String_Node_Str"",(sqlWarn != null));
    assertSQLState(""String_Node_Str"",sqlWarn);
  }
  rs.close();
  rs=st.executeQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  expColNames=new String[]{""String_Node_Str""};
  JDBC.assertColumnNames(rs,expColNames);
  expRS=new String[][]{{""String_Node_Str""}};
  JDBC.assertFullResultSet(rs,expRS,true);
  st.executeUpdate(""String_Node_Str"");
  st.close();
}"
80213,"/** 
 * Takes a result set and a two-dimensional array and asserts that the rows and columns in the result set match the number, order, and values of those in the array.  Each row in the array is compared with the corresponding row in the result set. As a side effect, this method closes the ResultSet. Will throw an assertion failure if any of the following is true: 1. Expected vs actual number of columns doesn't match 2. Expected vs actual number of rows doesn't match 3. Any column in any row of the result set does not ""equal"" the corresponding column in the expected 2-d array.  If ""allAsTrimmedStrings"" is true then the result set value will be retrieved as a String and compared, via the "".equals()"" method, to the corresponding object in the array (with the assumption being that the objects in the array are all  Strings).  Otherwise the result set value will be retrieved and compared as an Object, which is useful when asserting the JDBC types of the columns in addition to their values. NOTE: It follows from #3 that the order of the rows in the in received result set must match the order of the rows in the received 2-d array.  Otherwise the result will be an assertion failure.
 * @param rs The actual result set.
 * @param expectedRows 2-Dimensional array of objects representingthe expected result set.
 * @param allAsTrimmedStrings Whether or not to fetch (and compare)all values from the actual result set as trimmed Strings; if false the values will be fetched and compared as Objects.  For more on how this parameter is used, see assertRowInResultSet().
 */
public static void assertFullResultSet(ResultSet rs,Object[][] expectedRows,boolean allAsTrimmedStrings) throws SQLException {
  int rows;
  ResultSetMetaData rsmd=rs.getMetaData();
  Assert.assertEquals(""String_Node_Str"",expectedRows[0].length,rsmd.getColumnCount());
  for (rows=0; rs.next(); rows++) {
    if (rows < expectedRows.length) {
      assertRowInResultSet(rs,rows + 1,expectedRows[rows],allAsTrimmedStrings);
    }
  }
  rs.close();
  Assert.assertEquals(""String_Node_Str"",expectedRows.length,rows);
}","/** 
 * Takes a result set and a two-dimensional array and asserts that the rows and columns in the result set match the number, order, and values of those in the array.  Each row in the array is compared with the corresponding row in the result set. Will throw an assertion failure if any of the following is true: 1. Expected vs actual number of columns doesn't match 2. Expected vs actual number of rows doesn't match 3. Any column in any row of the result set does not ""equal"" the corresponding column in the expected 2-d array.  If ""allAsTrimmedStrings"" is true then the result set value will be retrieved as a String and compared, via the "".equals()"" method, to the corresponding object in the array (with the assumption being that the objects in the array are all  Strings).  Otherwise the result set value will be retrieved and compared as an Object, which is useful when asserting the JDBC types of the columns in addition to their values. NOTE: It follows from #3 that the order of the rows in the in received result set must match the order of the rows in the received 2-d array.  Otherwise the result will be an assertion failure.
 * @param rs The actual result set.
 * @param expectedRows 2-Dimensional array of objects representingthe expected result set.
 * @param allAsTrimmedStrings Whether or not to fetch (and compare)all values from the actual result set as trimmed Strings; if false the values will be fetched and compared as Objects.  For more on how this parameter is used, see assertRowInResultSet().
 * @param closeResultSet If true, the ResultSet is closed on the way out.
 */
public static void assertFullResultSet(ResultSet rs,Object[][] expectedRows,boolean allAsTrimmedStrings,boolean closeResultSet) throws SQLException {
  int rows;
  ResultSetMetaData rsmd=rs.getMetaData();
  Assert.assertEquals(""String_Node_Str"",expectedRows[0].length,rsmd.getColumnCount());
  for (rows=0; rs.next(); rows++) {
    if (rows < expectedRows.length) {
      assertRowInResultSet(rs,rows + 1,expectedRows[rows],allAsTrimmedStrings);
    }
  }
  if (closeResultSet) {
    rs.close();
  }
  Assert.assertEquals(""String_Node_Str"",expectedRows.length,rows);
}"
80214,"/** 
 * See if a string matches the pattern as defined by DatabaseMetaData. By passing in non-zero values can check sub-sets of the pattern against the sub strings of the result. <BR> _ matches a single character <BR> % matches zero or more characters <BR> Other characters match themselves.
 * @param pattern Pattern
 * @param pp Position in pattern to start the actual pattern from
 * @param result result string
 * @param rp position in result to starting checking
 * @return
 */
private boolean doesMatch(String pattern,int pp,String result,int rp){
  for (; ; ) {
    if (pp == pattern.length() && rp == result.length())     return true;
    if (pp == pattern.length())     return false;
    char pc=pattern.charAt(pp);
    if (pc == '_') {
      if (rp == result.length())       return false;
      pp++;
      rp++;
    }
 else     if (pc == '%') {
      if (pp == pattern.length() - 1) {
        return true;
      }
      for (int sp=rp; sp < result.length(); sp++) {
        if (doesMatch(pattern,pp + 1,result,sp)) {
          return true;
        }
      }
      return false;
    }
 else {
      if (rp == result.length())       return false;
      if (pc != result.charAt(rp)) {
        return false;
      }
      pp++;
      rp++;
    }
  }
}","/** 
 * See if a string matches the pattern as defined by DatabaseMetaData. By passing in non-zero values can check sub-sets of the pattern against the sub strings of the result. <BR> _ matches a single character <BR> % matches zero or more characters <BR> Other characters match themselves.
 * @param pattern Pattern
 * @param pp Position in pattern to start the actual pattern from
 * @param result result string
 * @param rp position in result to starting checking
 * @return true if a match is found
 */
private boolean doesMatch(String pattern,int pp,String result,int rp){
  for (; ; ) {
    if (pp == pattern.length() && rp == result.length())     return true;
    if (pp == pattern.length())     return false;
    char pc=pattern.charAt(pp);
    if (pc == '_') {
      if (rp == result.length())       return false;
      pp++;
      rp++;
    }
 else     if (pc == '%') {
      if (pp == pattern.length() - 1) {
        return true;
      }
      for (int sp=rp; sp < result.length(); sp++) {
        if (doesMatch(pattern,pp + 1,result,sp)) {
          return true;
        }
      }
      return false;
    }
 else {
      if (rp == result.length())       return false;
      if (pc != result.charAt(rp)) {
        return false;
      }
      pp++;
      rp++;
    }
  }
}"
80215,"/** 
 * Return the identifiers used to create schemas, tables etc. in the order the database stores them.
 * @return
 */
private String[] getSortedIdentifiers(){
  String[] dbIDS=new String[IDS.length];
  for (int i=0; i < IDS.length; i++) {
    dbIDS[i]=getStoredIdentifier(IDS[i]);
  }
  Arrays.sort(dbIDS);
  return dbIDS;
}","/** 
 * Return the identifiers used to create schemas, tables etc. in the order the database stores them.
 */
private String[] getSortedIdentifiers(){
  String[] dbIDS=new String[IDS.length];
  for (int i=0; i < IDS.length; i++) {
    dbIDS[i]=getStoredIdentifier(IDS[i]);
  }
  Arrays.sort(dbIDS);
  return dbIDS;
}"
80216,"/** 
 * Assert that a user has procedure execute privilege on a given table / column
 * @param hasPrivilege whether or not the user has the privilege
 * @param user the user to check
 * @param schema the schema to check
 * @param table the table to check
 * @throws SQLException throws all exceptions
 */
public void assertProcedurePrivilege(boolean hasPrivilege,String user,String schema,String procedure) throws SQLException {
  Connection c=openUserConnection(user);
  String procedurecall=""String_Node_Str"" + schema + ""String_Node_Str""+ procedure+ ""String_Node_Str"";
  PreparedStatement ps=c.prepareStatement(procedurecall);
  ResultSet rs=null;
  try {
    ps.execute();
    rs=ps.getResultSet();
  }
 catch (  SQLException e) {
    if (!hasPrivilege)     assertSQLState(""String_Node_Str"",e);
 else {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
  }
  ps.close();
  if (rs != null) {
    rs.close();
  }
}","/** 
 * Assert that a user has procedure execute privilege on a given table / column
 * @param hasPrivilege whether or not the user has the privilege
 * @param user the user to check
 * @param schema the schema to check
 * @param procedure the name of the procedure to check
 * @throws SQLException throws all exceptions
 */
public void assertProcedurePrivilege(boolean hasPrivilege,String user,String schema,String procedure) throws SQLException {
  Connection c=openUserConnection(user);
  String procedurecall=""String_Node_Str"" + schema + ""String_Node_Str""+ procedure+ ""String_Node_Str"";
  PreparedStatement ps=c.prepareStatement(procedurecall);
  ResultSet rs=null;
  try {
    ps.execute();
    rs=ps.getResultSet();
  }
 catch (  SQLException e) {
    if (!hasPrivilege)     assertSQLState(""String_Node_Str"",e);
 else {
      e.printStackTrace();
      fail(""String_Node_Str"");
    }
  }
  ps.close();
  if (rs != null) {
    rs.close();
  }
}"
80217,"/** 
 * Most tests run in embedded only, since they are only checking DDL statements. Metadata methods test also runs in client/server mode.
 * @return
 */
public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(basesuite());
  suite.addTest(TestConfiguration.clientServerDecorator(new GrantRevokeTest(""String_Node_Str"")));
  return suite;
}","/** 
 * Most tests run in embedded only, since they are only checking DDL statements. Metadata methods test also runs in client/server mode.
 */
public static Test suite(){
  TestSuite suite=new TestSuite();
  suite.addTest(basesuite());
  suite.addTest(TestConfiguration.clientServerDecorator(new GrantRevokeTest(""String_Node_Str"")));
  return suite;
}"
80218,"/** 
 * Iterates over an array of row vectors, comparing each to the data in the RS using assertRow. Always closes the RS, even when an exception is thrown. Assertion failures are intercepted and 'dumpDiff' is used to print the differences between the RS and the expected values to System.err.
 * @param assertString a message from the caller
 * @param expected array of row vectors
 * @param returned the resultset to verify
 */
private static void assertResultSet(String message,Object[][] expected,ResultSet returned) throws Exception {
  int i=0;
  boolean moreRows=false;
  try {
    for (; i < expected.length && (moreRows=returned.next()); ++i) {
      assertRow(message + ""String_Node_Str"" + (i + 1)+ ""String_Node_Str"",expected[i],returned);
    }
    assertEquals(message + ""String_Node_Str"",expected.length,i);
    moreRows=returned.next();
    ++i;
    assertFalse(message + ""String_Node_Str"" + expected.length+ ""String_Node_Str""+ i+ ""String_Node_Str"",moreRows);
  }
 catch (  junit.framework.AssertionFailedError af) {
    System.err.println(af);
    dumpDiff(expected,i,returned,moreRows,System.err);
    throw af;
  }
 finally {
    returned.close();
  }
}","/** 
 * Iterates over an array of row vectors, comparing each to the data in the RS using assertRow. Always closes the RS, even when an exception is thrown. Assertion failures are intercepted and 'dumpDiff' is used to print the differences between the RS and the expected values to System.err.
 * @param message a message from the caller
 * @param expected array of row vectors
 * @param returned the resultset to verify
 */
private static void assertResultSet(String message,Object[][] expected,ResultSet returned) throws Exception {
  int i=0;
  boolean moreRows=false;
  try {
    for (; i < expected.length && (moreRows=returned.next()); ++i) {
      assertRow(message + ""String_Node_Str"" + (i + 1)+ ""String_Node_Str"",expected[i],returned);
    }
    assertEquals(message + ""String_Node_Str"",expected.length,i);
    moreRows=returned.next();
    ++i;
    assertFalse(message + ""String_Node_Str"" + expected.length+ ""String_Node_Str""+ i+ ""String_Node_Str"",moreRows);
  }
 catch (  junit.framework.AssertionFailedError af) {
    System.err.println(af);
    dumpDiff(expected,i,returned,moreRows,System.err);
    throw af;
  }
 finally {
    returned.close();
  }
}"
80219,"/** 
 * This method checks that the SQL type can be converted to Decimal
 * @param rs ResultSet
 * @param columnIndex Column Index
 * @return true if the SQL type is convertible to DECIMAL, false otherwise.
 * @throws SQLException
 */
protected static boolean canConvertToDecimal(int type) throws SQLException {
  boolean canConvert=false;
  for (int bdType=0; bdType < bdConvertibleTypes.length; bdType++) {
    if (type == bdConvertibleTypes[bdType]) {
      canConvert=true;
      break;
    }
  }
  return canConvert;
}","/** 
 * This method checks that the SQL type can be converted to Decimal
 * @param type the SQL type to check
 * @return true if the SQL type is convertible to DECIMAL, false otherwise.
 * @throws SQLException
 */
protected static boolean canConvertToDecimal(int type) throws SQLException {
  boolean canConvert=false;
  for (int bdType=0; bdType < bdConvertibleTypes.length; bdType++) {
    if (type == bdConvertibleTypes[bdType]) {
      canConvert=true;
      break;
    }
  }
  return canConvert;
}"
80220,"/** 
 * This method is a wrapper for the PreparedStatement method setObject(int parameterIndex, Object x) 
 * @param ps PreparedStatement 
 * @param parameterIndex Parameter Index
 * @param bdString String to be used in setObject method
 * @throws SQLException
 */
public static void setObjectString(PreparedStatement ps,int parameterIndex,String objectString) throws SQLException {
switch (representation) {
case BIGDECIMAL_REPRESENTATION:
    BigDecimal bd=(objectString == null) ? null : new BigDecimal(objectString);
  ps.setObject(parameterIndex,bd);
break;
case STRING_REPRESENTATION:
ps.setObject(parameterIndex,objectString);
break;
default :
new Exception(""String_Node_Str"").printStackTrace();
}
}","/** 
 * This method is a wrapper for the PreparedStatement method setObject(int parameterIndex, Object x) 
 * @param ps PreparedStatement 
 * @param parameterIndex Parameter Index
 * @param objectString String to be used in setObject method
 * @throws SQLException
 */
public static void setObjectString(PreparedStatement ps,int parameterIndex,String objectString) throws SQLException {
switch (representation) {
case BIGDECIMAL_REPRESENTATION:
    BigDecimal bd=(objectString == null) ? null : new BigDecimal(objectString);
  ps.setObject(parameterIndex,bd);
break;
case STRING_REPRESENTATION:
ps.setObject(parameterIndex,objectString);
break;
default :
new Exception(""String_Node_Str"").printStackTrace();
}
}"
80221,"/** 
 * @param args
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}","/** 
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}"
80222,"/** 
 * @param args
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}","/** 
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}"
80223,"/** 
 * @param args
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}","/** 
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}"
80224,"/** 
 * @param args
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}","/** 
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}"
80225,"/** 
 * @param args
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}","/** 
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}"
80226,"/** 
 * @param args
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}","/** 
 */
public void generateQueries(){
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
  queries.add(""String_Node_Str"");
}"
80227,"/** 
 * Prepare commonly used statement to insert a row.
 * @param con connection to database
 * @param colName name of the column to insert into
 */
private PreparedStatement prep(String colName) throws SQLException {
  return prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + colName + ""String_Node_Str"");
}","/** 
 * Prepare commonly used statement to insert a row.
 * @param colName name of the column to insert into
 */
private PreparedStatement prep(String colName) throws SQLException {
  return prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + colName + ""String_Node_Str"");
}"
80228,"/** 
 * Fetch the specified row for update.
 * @param con connection to database
 * @param colName name of the column to fetch
 * @param key identifier for row to fetch
 * @return a <code>ResultSet</code> with zero or one row, depending onthe key used
 */
private ResultSet fetchUpd(String colName,int key) throws SQLException {
  Statement stmt=createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
  return stmt.executeQuery(""String_Node_Str"" + colName + ""String_Node_Str""+ key+ ""String_Node_Str"");
}","/** 
 * Fetch the specified row for update.
 * @param colName name of the column to fetch
 * @param key identifier for row to fetch
 * @return a <code>ResultSet</code> with zero or one row, depending onthe key used
 */
private ResultSet fetchUpd(String colName,int key) throws SQLException {
  Statement stmt=createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);
  return stmt.executeQuery(""String_Node_Str"" + colName + ""String_Node_Str""+ key+ ""String_Node_Str"");
}"
80229,"/** 
 * Fetch the specified row.
 * @param con connection to database
 * @param colName name of the column to fetch
 * @param key identifier for row to fetch
 * @return a <code>ResultSet</code> with zero or one row, depending onthe key used
 */
private ResultSet fetch(String colName,int key) throws SQLException {
  Statement stmt=createStatement();
  return stmt.executeQuery(""String_Node_Str"" + colName + ""String_Node_Str""+ key);
}","/** 
 * Fetch the specified row.
 * @param colName name of the column to fetch
 * @param key identifier for row to fetch
 * @return a <code>ResultSet</code> with zero or one row, depending onthe key used
 */
private ResultSet fetch(String colName,int key) throws SQLException {
  Statement stmt=createStatement();
  return stmt.executeQuery(""String_Node_Str"" + colName + ""String_Node_Str""+ key);
}"
80230,"/** 
 * Resets the size.
 * @param size new size should be smaller than exisiting size
 * @throws IOException , SQLException
 */
synchronized void truncate(long size) throws IOException, SQLException {
  isValidPostion(size);
  if (isBytes) {
    byte[] tmpByte=new byte[(int)size];
    System.arraycopy(dataBytes,0,tmpByte,0,(int)size);
  }
 else {
    if (size < Integer.MAX_VALUE && size < MAX_BUF_SIZE) {
      dataBytes=new byte[(int)size];
      read(dataBytes,0);
      isBytes=true;
      tmpFile.close();
      tmpFile=null;
    }
 else     tmpFile.setLength(size);
  }
}","/** 
 * Resets the size.
 * @param size new size should be smaller than exisiting size
 * @throws IOException , SQLException
 */
synchronized void truncate(long size) throws IOException, SQLException {
  isValidPostion(size);
  if (isBytes) {
    byte[] tmpByte=new byte[(int)size];
    System.arraycopy(dataBytes,0,tmpByte,0,(int)size);
    dataBytes=tmpByte;
  }
 else {
    if (size < Integer.MAX_VALUE && size < MAX_BUF_SIZE) {
      dataBytes=new byte[(int)size];
      read(dataBytes,0);
      isBytes=true;
      tmpFile.close();
      tmpFile=null;
    }
 else     tmpFile.setLength(size);
  }
}"
80231,"/** 
 * tests set bytes method of blob.
 */
public void testSetBytes() throws SQLException {
  Connection con=getConnection();
  try {
    con.setAutoCommit(false);
    PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
    pstmt.setInt(1,1);
    Blob blob=con.createBlob();
    byte[] data=new byte[BUFFER_SIZE];
    for (int i=0; i < BUFFER_SIZE; i++) {
      data[i]=(byte)(i % 255);
    }
    blob.setBytes(1,data);
    assertEquals(BUFFER_SIZE,blob.length());
    pstmt.setBlob(2,blob);
    pstmt.executeUpdate();
    Statement stmt=con.createStatement();
    ResultSet rs=stmt.executeQuery(""String_Node_Str"");
    assertEquals(true,rs.next());
    blob=rs.getBlob(1);
    assertEquals(BUFFER_SIZE,blob.length());
    byte[] data1=new byte[UPDATE_SIZE];
    for (int i=0; i < UPDATE_SIZE; i++)     data1[i]=120;
    blob.setBytes(UPDATE_SIZE,data1);
    byte[] data2=blob.getBytes(100,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    blob.setBytes(BUFFER_SIZE + 1,data1);
    assertEquals(BUFFER_SIZE + UPDATE_SIZE,blob.length());
    data2=blob.getBytes(BUFFER_SIZE + 1,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    pstmt.setInt(1,2);
    pstmt.setBlob(2,blob);
    pstmt.executeUpdate();
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"");
    assertEquals(true,rs.next());
    blob=rs.getBlob(1);
    assertEquals(BUFFER_SIZE + UPDATE_SIZE,blob.length());
    data2=blob.getBytes(100,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    data2=blob.getBytes(BUFFER_SIZE + 1,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    for (int i=0; i < 5; i++)     blob.setBytes(i * BUFFER_SIZE + 1,data);
    assertEquals(BUFFER_SIZE * 5,blob.length());
    blob.setBytes(BUFFER_SIZE + 1,data1);
    blob.setBytes(BUFFER_SIZE * 5 + 1,data1);
    assertEquals(5 * BUFFER_SIZE + UPDATE_SIZE,blob.length());
    pstmt.setInt(1,3);
    pstmt.setBlob(2,blob);
    pstmt.executeUpdate();
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"");
    assertEquals(true,rs.next());
    blob=rs.getBlob(1);
    data2=blob.getBytes(BUFFER_SIZE + 1,UPDATE_SIZE);
    assertEquals(5 * BUFFER_SIZE + UPDATE_SIZE,blob.length());
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    data2=blob.getBytes(5 * BUFFER_SIZE + 1,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    blob.truncate(BUFFER_SIZE);
    assertEquals(BUFFER_SIZE,blob.length());
    con.commit();
    stmt.close();
    pstmt.close();
  }
  finally {
    if (con != null) {
      con.commit();
      con.close();
    }
  }
}","/** 
 * tests set bytes method of blob.
 */
public void testSetBytes() throws SQLException {
  Connection con=getConnection();
  try {
    con.setAutoCommit(false);
    PreparedStatement pstmt=con.prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
    pstmt.setInt(1,1);
    Blob blob=con.createBlob();
    byte[] data=new byte[BUFFER_SIZE];
    for (int i=0; i < BUFFER_SIZE; i++) {
      data[i]=(byte)(i % 255);
    }
    blob.setBytes(1,data);
    assertEquals(BUFFER_SIZE,blob.length());
    pstmt.setBlob(2,blob);
    pstmt.executeUpdate();
    Statement stmt=con.createStatement();
    ResultSet rs=stmt.executeQuery(""String_Node_Str"");
    assertEquals(true,rs.next());
    blob=rs.getBlob(1);
    assertEquals(BUFFER_SIZE,blob.length());
    byte[] data1=new byte[UPDATE_SIZE];
    for (int i=0; i < UPDATE_SIZE; i++)     data1[i]=120;
    blob.setBytes(UPDATE_SIZE,data1);
    byte[] data2=blob.getBytes(100,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    blob.setBytes(BUFFER_SIZE + 1,data1);
    assertEquals(BUFFER_SIZE + UPDATE_SIZE,blob.length());
    data2=blob.getBytes(BUFFER_SIZE + 1,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    pstmt.setInt(1,2);
    pstmt.setBlob(2,blob);
    pstmt.executeUpdate();
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"");
    assertEquals(true,rs.next());
    blob=rs.getBlob(1);
    assertEquals(BUFFER_SIZE + UPDATE_SIZE,blob.length());
    data2=blob.getBytes(100,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    data2=blob.getBytes(BUFFER_SIZE + 1,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    for (int i=0; i < 5; i++)     blob.setBytes(i * BUFFER_SIZE + 1,data);
    assertEquals(BUFFER_SIZE * 5,blob.length());
    blob.setBytes(BUFFER_SIZE + 1,data1);
    blob.setBytes(BUFFER_SIZE * 5 + 1,data1);
    assertEquals(5 * BUFFER_SIZE + UPDATE_SIZE,blob.length());
    pstmt.setInt(1,3);
    pstmt.setBlob(2,blob);
    pstmt.executeUpdate();
    rs=stmt.executeQuery(""String_Node_Str"" + ""String_Node_Str"");
    assertEquals(true,rs.next());
    blob=rs.getBlob(1);
    data2=blob.getBytes(BUFFER_SIZE + 1,UPDATE_SIZE);
    assertEquals(5 * BUFFER_SIZE + UPDATE_SIZE,blob.length());
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    data2=blob.getBytes(5 * BUFFER_SIZE + 1,UPDATE_SIZE);
    for (int i=0; i < UPDATE_SIZE; i++)     assertEquals(data1[i],data2[i]);
    blob.truncate(BUFFER_SIZE);
    assertEquals(BUFFER_SIZE,blob.length());
    blob=con.createBlob();
    data=new byte[100];
    for (int i=0; i < 100; i++) {
      data[i]=(byte)i;
    }
    blob.setBytes(1,data);
    assertEquals(blob.length(),100);
    blob.truncate(50);
    assertEquals(blob.length(),50);
    con.commit();
    stmt.close();
    pstmt.close();
  }
  finally {
    if (con != null) {
      con.commit();
      con.close();
    }
  }
}"
80232,"public NetClientImpl(VertxInternal vertx,NetClientOptions options){
  this.vertx=vertx;
  this.options=new NetClientOptions(options);
  this.sslHelper=new SSLHelper(options,KeyStoreHelper.create(vertx,options.getKeyStore()),KeyStoreHelper.create(vertx,options.getTrustStore()));
  this.closeHook=completionHandler -> {
    NetClientImpl.this.close();
    completionHandler.handle(new FutureResultImpl<>((Void)null));
  }
;
  creatingContext=vertx.getContext();
  if (creatingContext != null) {
    if (creatingContext.isMultithreaded()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    creatingContext.addCloseHook(closeHook);
  }
}","public NetClientImpl(VertxInternal vertx,NetClientOptions options){
  this.vertx=vertx;
  this.options=new NetClientOptions(options);
  this.sslHelper=new SSLHelper(options,KeyStoreHelper.create(vertx,options.getKeyStoreOptions()),KeyStoreHelper.create(vertx,options.getTrustStoreOptions()));
  this.closeHook=completionHandler -> {
    NetClientImpl.this.close();
    completionHandler.handle(new FutureResultImpl<>((Void)null));
  }
;
  creatingContext=vertx.getContext();
  if (creatingContext != null) {
    if (creatingContext.isMultithreaded()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    creatingContext.addCloseHook(closeHook);
  }
}"
80233,"public NetServerImpl(VertxInternal vertx,NetServerOptions options){
  this.vertx=vertx;
  this.options=new NetServerOptions(options);
  this.sslHelper=new SSLHelper(options,KeyStoreHelper.create(vertx,options.getKeyStore()),KeyStoreHelper.create(vertx,options.getTrustStore()));
  this.creatingContext=vertx.getContext();
  if (creatingContext != null) {
    if (creatingContext.isMultithreaded()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    creatingContext.addCloseHook(this);
  }
}","public NetServerImpl(VertxInternal vertx,NetServerOptions options){
  this.vertx=vertx;
  this.options=new NetServerOptions(options);
  this.sslHelper=new SSLHelper(options,KeyStoreHelper.create(vertx,options.getKeyStoreOptions()),KeyStoreHelper.create(vertx,options.getTrustStoreOptions()));
  this.creatingContext=vertx.getContext();
  if (creatingContext != null) {
    if (creatingContext.isMultithreaded()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    creatingContext.addCloseHook(this);
  }
}"
80234,"@Test public void testAsyncDeployCalledSynchronously() throws Exception {
  MyAsyncVerticle verticle=new MyAsyncVerticle(f -> f.setResult(null),null);
  vertx.deployVerticleInstance(verticle,new DeploymentOptions(),ar -> {
    assertTrue(ar.succeeded());
    testComplete();
  }
);
  await();
}","@Test public void testAsyncDeployCalledSynchronously() throws Exception {
  MyAsyncVerticle verticle=new MyAsyncVerticle(f -> f.setResult(null),f -> f.setResult(null));
  vertx.deployVerticleInstance(verticle,new DeploymentOptions(),ar -> {
    assertTrue(ar.succeeded());
    testComplete();
  }
);
  await();
}"
80235,"@Test public void testSimpleChildDeployment() throws Exception {
  Verticle verticle=new MyAsyncVerticle(f -> {
    Context parentContext=vertx.currentContext();
    Verticle child1=new MyAsyncVerticle(f2 -> {
      Context childContext=vertx.currentContext();
      assertNotSame(parentContext,childContext);
      f2.setResult(null);
      testComplete();
    }
,null);
    vertx.deployVerticleInstance(child1,new DeploymentOptions(),ar -> {
      assertTrue(ar.succeeded());
    }
);
    f.setResult(null);
  }
,null);
  vertx.deployVerticleInstance(verticle,new DeploymentOptions(),ar -> {
    assertTrue(ar.succeeded());
  }
);
  await();
}","@Test public void testSimpleChildDeployment() throws Exception {
  Verticle verticle=new MyAsyncVerticle(f -> {
    Context parentContext=vertx.currentContext();
    Verticle child1=new MyAsyncVerticle(f2 -> {
      Context childContext=vertx.currentContext();
      assertNotSame(parentContext,childContext);
      f2.setResult(null);
      testComplete();
    }
,f2 -> f2.setResult(null));
    vertx.deployVerticleInstance(child1,new DeploymentOptions(),ar -> {
      assertTrue(ar.succeeded());
    }
);
    f.setResult(null);
  }
,f -> f.setResult(null));
  vertx.deployVerticleInstance(verticle,new DeploymentOptions(),ar -> {
    assertTrue(ar.succeeded());
  }
);
  await();
}"
80236,"@Test public void testAsyncDeploy() throws Exception {
  long start=System.currentTimeMillis();
  long delay=1000;
  MyAsyncVerticle verticle=new MyAsyncVerticle(f -> vertx.setTimer(delay,id -> f.setResult(null)),null);
  vertx.deployVerticleInstance(verticle,new DeploymentOptions(),ar -> {
    assertTrue(ar.succeeded());
    long now=System.currentTimeMillis();
    assertTrue(now - start >= delay);
    assertTrue(vertx.deployments().contains(ar.result()));
    testComplete();
  }
);
  Thread.sleep(delay / 2);
  assertTrue(vertx.deployments().isEmpty());
  await();
}","@Test public void testAsyncDeploy() throws Exception {
  long start=System.currentTimeMillis();
  long delay=1000;
  MyAsyncVerticle verticle=new MyAsyncVerticle(f -> {
    vertx.setTimer(delay,id -> {
      f.setResult(null);
    }
);
  }
,f -> f.setResult(null));
  vertx.deployVerticleInstance(verticle,new DeploymentOptions(),ar -> {
    assertTrue(ar.succeeded());
    long now=System.currentTimeMillis();
    assertTrue(now - start >= delay);
    assertTrue(vertx.deployments().contains(ar.result()));
    testComplete();
  }
);
  Thread.sleep(delay / 2);
  assertTrue(vertx.deployments().isEmpty());
  await();
}"
80237,"private <T,U>void sendOrPub(ServerID replyDest,BaseMessage<U> message,Handler<Message<T>> replyHandler,Handler<AsyncResult<Message<T>>> asyncResultHandler,long timeout){
  checkStarted();
  ContextImpl context=vertx.getOrCreateContext();
  if (timeout == -1) {
    timeout=defaultReplyTimeout;
  }
  try {
    message.sender=serverID;
    long timeoutID=-1;
    if (replyHandler != null) {
      message.replyAddress=generateReplyAddress();
      Registration registration=registerHandler(message.replyAddress,replyHandler,true,true,timeoutID);
      if (timeout != -1) {
        timeoutID=vertx.setTimer(timeout,timerID -> {
          log.warn(""String_Node_Str"");
          registration.unregister();
          if (asyncResultHandler != null) {
            asyncResultHandler.handle(new FutureResultImpl<>(new ReplyException(ReplyFailure.TIMEOUT,""String_Node_Str"")));
          }
        }
);
      }
    }
    if (replyDest != null) {
      if (!replyDest.equals(this.serverID)) {
        sendRemote(replyDest,message);
      }
 else {
        receiveMessage(message,timeoutID,asyncResultHandler,replyHandler);
      }
    }
 else {
      if (subs != null) {
        long fTimeoutID=timeoutID;
        subs.get(message.address,asyncResult -> {
          if (asyncResult.succeeded()) {
            ChoosableIterable<ServerID> serverIDs=asyncResult.result();
            if (serverIDs != null && !serverIDs.isEmpty()) {
              sendToSubs(serverIDs,message,fTimeoutID,asyncResultHandler,replyHandler);
            }
 else {
              receiveMessage(message,fTimeoutID,asyncResultHandler,replyHandler);
            }
          }
 else {
            log.error(""String_Node_Str"",asyncResult.cause());
          }
        }
);
      }
 else {
        receiveMessage(message,timeoutID,asyncResultHandler,replyHandler);
      }
    }
  }
  finally {
    if (context != null) {
      vertx.setContext(context);
    }
  }
}","private <T,U>void sendOrPub(ServerID replyDest,BaseMessage<U> message,Handler<Message<T>> replyHandler,Handler<AsyncResult<Message<T>>> asyncResultHandler,long timeout){
  checkStarted();
  ContextImpl context=vertx.getOrCreateContext();
  if (timeout == -1) {
    timeout=defaultReplyTimeout;
  }
  try {
    message.sender=serverID;
    long timeoutID=-1;
    if (replyHandler != null) {
      message.replyAddress=generateReplyAddress();
      AtomicReference<Registration> refReg=new AtomicReference<>();
      if (timeout != -1) {
        timeoutID=vertx.setTimer(timeout,timerID -> {
          log.warn(""String_Node_Str"");
          refReg.get().unregister();
          if (asyncResultHandler != null) {
            asyncResultHandler.handle(new FutureResultImpl<>(new ReplyException(ReplyFailure.TIMEOUT,""String_Node_Str"")));
          }
        }
);
      }
      Registration registration=registerHandler(message.replyAddress,replyHandler,true,true,timeoutID);
      refReg.set(registration);
    }
    if (replyDest != null) {
      if (!replyDest.equals(this.serverID)) {
        sendRemote(replyDest,message);
      }
 else {
        receiveMessage(message,timeoutID,asyncResultHandler,replyHandler);
      }
    }
 else {
      if (subs != null) {
        long fTimeoutID=timeoutID;
        subs.get(message.address,asyncResult -> {
          if (asyncResult.succeeded()) {
            ChoosableIterable<ServerID> serverIDs=asyncResult.result();
            if (serverIDs != null && !serverIDs.isEmpty()) {
              sendToSubs(serverIDs,message,fTimeoutID,asyncResultHandler,replyHandler);
            }
 else {
              receiveMessage(message,fTimeoutID,asyncResultHandler,replyHandler);
            }
          }
 else {
            log.error(""String_Node_Str"",asyncResult.cause());
          }
        }
);
      }
 else {
        receiveMessage(message,timeoutID,asyncResultHandler,replyHandler);
      }
    }
  }
  finally {
    if (context != null) {
      vertx.setContext(context);
    }
  }
}"
80238,"@Override public HttpServerResponse setStatusMessage(String statusMessage){
  this.response.setStatus(new HttpResponseStatus(response.getStatus().code(),statusMessage));
  return this;
}","@Override public HttpServerResponse setStatusMessage(String statusMessage){
  this.statusMessage=statusMessage;
  this.response.setStatus(new HttpResponseStatus(response.getStatus().code(),statusMessage));
  return this;
}"
80239,"@Override public HttpServerResponse setStatusCode(int statusCode){
  this.response.setStatus(new HttpResponseStatus(statusCode,response.getStatus().reasonPhrase()));
  return this;
}","@Override public HttpServerResponse setStatusCode(int statusCode){
  HttpResponseStatus status=statusMessage != null ? new HttpResponseStatus(statusCode,statusMessage) : HttpResponseStatus.valueOf(statusCode);
  this.response.setStatus(status);
  return this;
}"
80240,"private void testStatusCode(int code,String statusMessage){
  server.requestHandler(req -> {
    if (code != -1) {
      req.response().setStatusCode(code);
    }
    if (statusMessage != null) {
      req.response().setStatusMessage(statusMessage);
    }
    req.response().end();
  }
);
  server.listen(onSuccess(s -> {
    client.getNow(new RequestOptions().setPort(DEFAULT_HTTP_PORT).setRequestURI(DEFAULT_TEST_URI),resp -> {
      if (code != -1) {
        assertEquals(code,resp.statusCode());
      }
 else {
        assertEquals(200,resp.statusCode());
      }
      if (statusMessage != null) {
        assertEquals(statusMessage,resp.statusMessage());
      }
      testComplete();
    }
);
  }
));
  await();
}","private void testStatusCode(int code,String statusMessage){
  server.requestHandler(req -> {
    if (code != -1) {
      req.response().setStatusCode(code);
    }
    if (statusMessage != null) {
      req.response().setStatusMessage(statusMessage);
    }
    req.response().end();
  }
);
  server.listen(onSuccess(s -> {
    client.getNow(new RequestOptions().setPort(DEFAULT_HTTP_PORT).setRequestURI(DEFAULT_TEST_URI),resp -> {
      int theCode;
      if (code == -1) {
        assertEquals(200,resp.statusCode());
        theCode=200;
      }
 else {
        theCode=code;
      }
      if (statusMessage != null) {
        assertEquals(statusMessage,resp.statusMessage());
      }
 else {
        assertEquals(HttpResponseStatus.valueOf(theCode).reasonPhrase(),resp.statusMessage());
      }
      testComplete();
    }
);
  }
));
  await();
}"
80241,"public void execute(EventLoop worker,Runnable handler){
  if (isOnCorrectWorker(worker)) {
    wrapTask(handler).run();
  }
 else {
    execute(handler);
  }
}","public void execute(EventLoop worker,Runnable handler){
  boolean correctThread;
  Thread thread=Thread.currentThread();
  if (thread instanceof VertxThread) {
    VertxThread vthread=(VertxThread)thread;
    Context ctx=vthread.getContext();
    correctThread=ctx == this;
  }
 else {
    correctThread=false;
  }
  if (correctThread) {
    wrapTask(handler).run();
  }
 else {
    execute(handler);
  }
}"
80242,"@Override public DatagramSocket unlistenMulticastGroup(String multicastAddress,String networkInterface,String source,Handler<AsyncResult<DatagramSocket>> handler){
  configurable=false;
  try {
    addListener(channel().leaveGroup(InetAddress.getByName(multicastAddress),NetworkInterface.getByName(networkInterface),InetAddress.getByName(source)),handler);
  }
 catch (  Exception e) {
    notifyException(handler,e);
  }
  return this;
}","@Override public DatagramSocket unlistenMulticastGroup(String multicastAddress,String networkInterface,String source,Handler<AsyncResult<DatagramSocket>> handler){
  configurable=false;
  try {
    InetAddress sourceAddress;
    if (source == null) {
      sourceAddress=null;
    }
 else {
      sourceAddress=InetAddress.getByName(source);
    }
    addListener(channel().leaveGroup(InetAddress.getByName(multicastAddress),NetworkInterface.getByName(networkInterface),sourceAddress),handler);
  }
 catch (  Exception e) {
    notifyException(handler,e);
  }
  return this;
}"
80243,"@Override public DatagramSocket listenMulticastGroup(String multicastAddress,String networkInterface,String source,Handler<AsyncResult<DatagramSocket>> handler){
  configurable=false;
  try {
    addListener(channel().joinGroup(InetAddress.getByName(multicastAddress),NetworkInterface.getByName(networkInterface),InetAddress.getByName(source)),handler);
  }
 catch (  Exception e) {
    notifyException(handler,e);
  }
  return this;
}","@Override public DatagramSocket listenMulticastGroup(String multicastAddress,String networkInterface,String source,Handler<AsyncResult<DatagramSocket>> handler){
  configurable=false;
  try {
    InetAddress sourceAddress;
    if (source == null) {
      sourceAddress=null;
    }
 else {
      sourceAddress=InetAddress.getByName(source);
    }
    addListener(channel().joinGroup(InetAddress.getByName(multicastAddress),NetworkInterface.getByName(networkInterface),sourceAddress),handler);
  }
 catch (  Exception e) {
    notifyException(handler,e);
  }
  return this;
}"
80244,"public void testMulticastJoinLeave() throws Exception {
  final Buffer buffer=TestUtils.generateRandomBuffer(128);
  final String groupAddress=""String_Node_Str"";
  peer1=vertx.createDatagramSocket(null);
  peer2=vertx.createDatagramSocket(InternetProtocolFamily.IPv4);
  peer2.dataHandler(new Handler<DatagramPacket>(){
    @Override public void handle(    DatagramPacket event){
      tu.checkThread();
      tu.azzert(event.data().equals(buffer));
    }
  }
);
  peer2.listen(""String_Node_Str"",1234,new AsyncResultHandler<DatagramSocket>(){
    @Override public void handle(    AsyncResult<DatagramSocket> event){
      tu.checkThread();
      tu.azzert(event.succeeded());
      peer2.listenMulticastGroup(groupAddress,new AsyncResultHandler<DatagramSocket>(){
        @Override public void handle(        AsyncResult<DatagramSocket> event){
          tu.azzert(event.succeeded());
          peer1.send(buffer,groupAddress,1234,new AsyncResultHandler<DatagramSocket>(){
            @Override public void handle(            AsyncResult<DatagramSocket> event){
              tu.azzert(event.succeeded());
              peer2.unlistenMulticastGroup(groupAddress,new AsyncResultHandler<DatagramSocket>(){
                @Override public void handle(                AsyncResult<DatagramSocket> event){
                  tu.azzert(event.succeeded());
                  final AtomicBoolean received=new AtomicBoolean(false);
                  peer2.dataHandler(new Handler<DatagramPacket>(){
                    @Override public void handle(                    DatagramPacket event){
                      received.set(true);
                    }
                  }
);
                  peer1.send(buffer,groupAddress,1234,new AsyncResultHandler<DatagramSocket>(){
                    @Override public void handle(                    AsyncResult<DatagramSocket> event){
                      tu.azzert(event.succeeded());
                      vertx.setTimer(1000,new Handler<Long>(){
                        @Override public void handle(                        Long event){
                          tu.azzert(!received.get());
                          tu.testComplete();
                        }
                      }
);
                    }
                  }
);
                }
              }
);
            }
          }
);
        }
      }
);
    }
  }
);
}","public void testMulticastJoinLeave() throws Exception {
  final Buffer buffer=TestUtils.generateRandomBuffer(128);
  final String groupAddress=""String_Node_Str"";
  final String iface=NetworkInterface.getByInetAddress(InetAddress.getByName(""String_Node_Str"")).getName();
  final AtomicBoolean received=new AtomicBoolean();
  peer1=vertx.createDatagramSocket(InternetProtocolFamily.IPv4);
  peer2=vertx.createDatagramSocket(InternetProtocolFamily.IPv4);
  peer1.setMulticastNetworkInterface(iface);
  peer2.setMulticastNetworkInterface(iface);
  peer1.dataHandler(new Handler<DatagramPacket>(){
    @Override public void handle(    DatagramPacket event){
      tu.checkThread();
      tu.azzert(event.data().equals(buffer));
      received.set(true);
    }
  }
);
  peer1.listen(1234,new Handler<AsyncResult<DatagramSocket>>(){
    @Override public void handle(    AsyncResult<DatagramSocket> event){
      tu.checkThread();
      tu.azzert(event.succeeded());
      peer1.listenMulticastGroup(groupAddress,iface,null,new AsyncResultHandler<DatagramSocket>(){
        @Override public void handle(        AsyncResult<DatagramSocket> event){
          tu.checkThread();
          tu.azzert(event.succeeded());
          peer2.send(buffer,groupAddress,1234,new AsyncResultHandler<DatagramSocket>(){
            @Override public void handle(            AsyncResult<DatagramSocket> event){
              tu.checkThread();
              tu.azzert(event.succeeded());
              vertx.setTimer(1000,new Handler<Long>(){
                @Override public void handle(                Long event){
                  peer1.unlistenMulticastGroup(groupAddress,iface,null,new AsyncResultHandler<DatagramSocket>(){
                    @Override public void handle(                    AsyncResult<DatagramSocket> event){
                      tu.checkThread();
                      tu.azzert(event.succeeded());
                      final AtomicBoolean receivedAfter=new AtomicBoolean();
                      peer1.dataHandler(new Handler<DatagramPacket>(){
                        @Override public void handle(                        DatagramPacket event){
                          tu.checkThread();
                          receivedAfter.set(true);
                        }
                      }
);
                      peer2.send(buffer,groupAddress,1234,new AsyncResultHandler<DatagramSocket>(){
                        @Override public void handle(                        AsyncResult<DatagramSocket> event){
                          tu.checkThread();
                          tu.azzert(event.succeeded());
                          vertx.setTimer(1000,new Handler<Long>(){
                            @Override public void handle(                            Long event){
                              tu.checkThread();
                              tu.azzert(!receivedAfter.get());
                              tu.azzert(received.get());
                              tu.testComplete();
                            }
                          }
);
                        }
                      }
);
                    }
                  }
);
                }
              }
);
            }
          }
);
        }
      }
);
    }
  }
);
}"
80245,"private void doDeployVerticle(boolean worker,boolean multiThreaded,final String main,final JsonObject config,final URL[] urls,int instances,File currentModDir,String includes,Handler<AsyncResult<String>> doneHandler){
  checkWorkerContext();
  if (main == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (urls == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  String depName=genDepName();
  ModuleIdentifier enclosingModName=getEnclosingModID();
  String moduleKey;
  if (enclosingModName == null) {
    moduleKey=ModuleIdentifier.createInternalModIDForVerticle(depName).toString();
  }
 else {
    moduleKey=enclosingModName.toString() + ""String_Node_Str"" + main;
  }
  ModuleReference mr=getModuleReference(moduleKey,urls);
  if (enclosingModName != null) {
    ModuleReference parentRef=moduleRefs.get(enclosingModName.toString());
    mr.mcl.addReference(parentRef);
    parentRef.incRef();
  }
  if (includes != null) {
    loadIncludedModules(modRoot,currentModDir,mr,includes);
  }
  doDeploy(depName,false,worker,multiThreaded,main,null,config,urls,instances,currentModDir,mr,modRoot,false,doneHandler);
}","private void doDeployVerticle(boolean worker,boolean multiThreaded,final String main,final JsonObject config,final URL[] urls,int instances,File currentModDir,String includes,Handler<AsyncResult<String>> doneHandler){
  checkWorkerContext();
  if (main == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (urls == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  String depName=genDepName();
  ModuleIdentifier enclosingModName=getEnclosingModID();
  String moduleKey;
  if (enclosingModName == null) {
    moduleKey=ModuleIdentifier.createInternalModIDForVerticle(depName).toString();
  }
 else {
    moduleKey=enclosingModName.toString() + ""String_Node_Str"" + main;
  }
  ModuleReference mr=getModuleReference(moduleKey,urls);
  if (enclosingModName != null) {
    ModuleReference parentRef=moduleRefs.get(enclosingModName.toString());
    if (mr.mcl.addReference(parentRef)) {
      parentRef.incRef();
    }
  }
  if (includes != null) {
    loadIncludedModules(modRoot,currentModDir,mr,includes);
  }
  doDeploy(depName,false,worker,multiThreaded,main,null,config,urls,instances,currentModDir,mr,modRoot,false,doneHandler);
}"
80246,"private void deployModuleFromModJson(JsonObject modJSON,String depName,ModuleIdentifier modID,JsonObject config,int instances,File modDir,File currentModDir,List<URL> moduleClasspath,File modRoot,boolean ha,final Handler<AsyncResult<String>> doneHandler){
  ModuleFields fields=new ModuleFields(modJSON);
  String main=fields.getMain();
  if (main == null) {
    throw new PlatformManagerException(""String_Node_Str"" + modID + ""String_Node_Str"");
  }
  boolean worker=fields.isWorker();
  boolean multiThreaded=fields.isMultiThreaded();
  if (multiThreaded && !worker) {
    throw new PlatformManagerException(""String_Node_Str"");
  }
  boolean preserveCwd=fields.isPreserveCurrentWorkingDirectory();
  File modDirToUse=preserveCwd ? currentModDir : modDir;
  ModuleReference mr=moduleRefs.get(modID.toString());
  if (mr == null) {
    boolean res=fields.isResident();
    mr=new ModuleReference(this,modID.toString(),new ModuleClassLoader(modID.toString(),platformClassLoader,moduleClasspath.toArray(new URL[moduleClasspath.size()])),res);
    ModuleReference prev=moduleRefs.putIfAbsent(modID.toString(),mr);
    if (prev != null) {
      mr=prev;
    }
  }
  ModuleIdentifier enclosingModID=getEnclosingModID();
  if (enclosingModID != null) {
    ModuleReference parentRef=moduleRefs.get(enclosingModID.toString());
    mr.mcl.addReference(parentRef);
    parentRef.incRef();
  }
  String includes=fields.getIncludes();
  if (includes != null) {
    loadIncludedModules(modRoot,modDir,mr,includes);
  }
  final boolean autoRedeploy=fields.isAutoRedeploy();
  doDeploy(depName,autoRedeploy,worker,multiThreaded,main,modID,config,moduleClasspath.toArray(new URL[moduleClasspath.size()]),instances,modDirToUse,mr,modRoot,ha,new Handler<AsyncResult<String>>(){
    @Override public void handle(    AsyncResult<String> res){
      if (res.succeeded()) {
        String deploymentID=res.result();
        if (deploymentID != null && autoRedeploy) {
          redeployer.moduleDeployed(deployments.get(deploymentID));
        }
      }
      if (doneHandler != null) {
        doneHandler.handle(res);
      }
 else       if (res.failed()) {
        log.error(""String_Node_Str"",res.cause());
      }
    }
  }
);
}","private void deployModuleFromModJson(JsonObject modJSON,String depName,ModuleIdentifier modID,JsonObject config,int instances,File modDir,File currentModDir,List<URL> moduleClasspath,File modRoot,boolean ha,final Handler<AsyncResult<String>> doneHandler){
  ModuleFields fields=new ModuleFields(modJSON);
  String main=fields.getMain();
  if (main == null) {
    throw new PlatformManagerException(""String_Node_Str"" + modID + ""String_Node_Str"");
  }
  boolean worker=fields.isWorker();
  boolean multiThreaded=fields.isMultiThreaded();
  if (multiThreaded && !worker) {
    throw new PlatformManagerException(""String_Node_Str"");
  }
  boolean preserveCwd=fields.isPreserveCurrentWorkingDirectory();
  File modDirToUse=preserveCwd ? currentModDir : modDir;
  ModuleReference mr=moduleRefs.get(modID.toString());
  if (mr == null) {
    boolean res=fields.isResident();
    mr=new ModuleReference(this,modID.toString(),new ModuleClassLoader(modID.toString(),platformClassLoader,moduleClasspath.toArray(new URL[moduleClasspath.size()])),res);
    ModuleReference prev=moduleRefs.putIfAbsent(modID.toString(),mr);
    if (prev != null) {
      mr=prev;
    }
  }
  ModuleIdentifier enclosingModID=getEnclosingModID();
  if (enclosingModID != null) {
    ModuleReference parentRef=moduleRefs.get(enclosingModID.toString());
    if (mr.mcl.addReference(parentRef)) {
      parentRef.incRef();
    }
  }
  String includes=fields.getIncludes();
  if (includes != null) {
    loadIncludedModules(modRoot,modDir,mr,includes);
  }
  final boolean autoRedeploy=fields.isAutoRedeploy();
  doDeploy(depName,autoRedeploy,worker,multiThreaded,main,modID,config,moduleClasspath.toArray(new URL[moduleClasspath.size()]),instances,modDirToUse,mr,modRoot,ha,new Handler<AsyncResult<String>>(){
    @Override public void handle(    AsyncResult<String> res){
      if (res.succeeded()) {
        String deploymentID=res.result();
        if (deploymentID != null && autoRedeploy) {
          redeployer.moduleDeployed(deployments.get(deploymentID));
        }
      }
      if (doneHandler != null) {
        doneHandler.handle(res);
      }
 else       if (res.failed()) {
        log.error(""String_Node_Str"",res.cause());
      }
    }
  }
);
}"
80247,"private void doLoadIncludedModules(File modRoot,File currentModuleDir,ModuleReference mr,String includesString,Set<String> included){
  checkWorkerContext();
  for (  String moduleName : parseIncludeString(includesString)) {
    ModuleIdentifier modID=new ModuleIdentifier(moduleName);
    if (included.contains(modID.toString())) {
      log.warn(""String_Node_Str"" + modID + ""String_Node_Str"");
    }
 else {
      included.add(modID.toString());
      ModuleReference includedMr=moduleRefs.get(moduleName);
      if (includedMr == null) {
        File modDir=locateModule(modRoot,currentModuleDir,modID);
        if (modDir == null) {
          doInstallMod(modID);
        }
        modDir=locateModule(modRoot,currentModuleDir,modID);
        List<URL> urls=getModuleClasspath(modDir);
        JsonObject conf=loadModuleConfig(modID,modDir);
        ModuleFields fields=new ModuleFields(conf);
        boolean res=fields.isResident();
        includedMr=new ModuleReference(this,moduleName,new ModuleClassLoader(modID.toString(),platformClassLoader,urls.toArray(new URL[urls.size()])),res);
        ModuleReference prev=moduleRefs.putIfAbsent(moduleName,includedMr);
        if (prev != null) {
          includedMr=prev;
        }
        String includes=fields.getIncludes();
        if (includes != null) {
          doLoadIncludedModules(modRoot,modDir,includedMr,includes,included);
        }
      }
      includedMr.incRef();
      mr.mcl.addReference(includedMr);
    }
  }
}","private void doLoadIncludedModules(File modRoot,File currentModuleDir,ModuleReference mr,String includesString,Set<String> included){
  checkWorkerContext();
  for (  String moduleName : parseIncludeString(includesString)) {
    ModuleIdentifier modID=new ModuleIdentifier(moduleName);
    if (included.contains(modID.toString())) {
      log.warn(""String_Node_Str"" + modID + ""String_Node_Str"");
    }
 else {
      included.add(modID.toString());
      ModuleReference includedMr=moduleRefs.get(moduleName);
      if (includedMr == null) {
        File modDir=locateModule(modRoot,currentModuleDir,modID);
        if (modDir == null) {
          doInstallMod(modID);
        }
        modDir=locateModule(modRoot,currentModuleDir,modID);
        List<URL> urls=getModuleClasspath(modDir);
        JsonObject conf=loadModuleConfig(modID,modDir);
        ModuleFields fields=new ModuleFields(conf);
        boolean res=fields.isResident();
        includedMr=new ModuleReference(this,moduleName,new ModuleClassLoader(modID.toString(),platformClassLoader,urls.toArray(new URL[urls.size()])),res);
        ModuleReference prev=moduleRefs.putIfAbsent(moduleName,includedMr);
        if (prev != null) {
          includedMr=prev;
        }
        String includes=fields.getIncludes();
        if (includes != null) {
          doLoadIncludedModules(modRoot,modDir,includedMr,includes,included);
        }
      }
      if (mr.mcl.addReference(includedMr)) {
        includedMr.incRef();
      }
    }
  }
}"
80248,"public synchronized void addReference(ModuleReference reference){
  references.add(reference);
  modGraph=null;
}","public synchronized boolean addReference(ModuleReference reference){
  if (!references.contains(reference)) {
    references.add(reference);
    modGraph=null;
    return true;
  }
 else {
    return false;
  }
}"
80249,"/** 
 * Decodes a full DNS response packet.
 * @param buf the raw DNS response packet
 * @return the decoded {@link DnsResponse}
 */
protected static DnsResponse decodeResponse(ByteBuf buf,ByteBufAllocator allocator){
  DnsResponse response=new DnsResponse(buf);
  DnsResponseHeader header=decodeHeader(response,buf);
  response.setHeader(header);
  for (int i=0; i < header.getReadQuestions(); i++) {
    response.addQuestion(decodeQuestion(buf));
  }
  if (header.getResponseCode() != 0) {
    System.err.println(""String_Node_Str"" + response.getQuestions().get(0).name() + ""String_Node_Str""+ DnsResponseCode.valueOf(header.getResponseCode()));
  }
  for (int i=0; i < header.getReadAnswers(); i++) {
    response.addAnswer(decodeResource(buf,allocator));
  }
  for (int i=0; i < header.getReadAuthorityResources(); i++) {
    response.addAuthorityResource(decodeResource(buf,allocator));
  }
  for (int i=0; i < header.getReadAdditionalResources(); i++) {
    response.addAdditionalResource(decodeResource(buf,allocator));
  }
  return response;
}","/** 
 * Decodes a full DNS response packet.
 * @param buf the raw DNS response packet
 * @return the decoded {@link DnsResponse}
 */
protected static DnsResponse decodeResponse(ByteBuf buf,ByteBufAllocator allocator){
  DnsResponse response=new DnsResponse(buf);
  DnsResponseHeader header=decodeHeader(response,buf);
  response.setHeader(header);
  for (int i=0; i < header.getReadQuestions(); i++) {
    response.addQuestion(decodeQuestion(buf));
  }
  if (header.getResponseCode() != 0) {
    return response;
  }
  for (int i=0; i < header.getReadAnswers(); i++) {
    response.addAnswer(decodeResource(buf,allocator));
  }
  for (int i=0; i < header.getReadAuthorityResources(); i++) {
    response.addAuthorityResource(decodeResource(buf,allocator));
  }
  for (int i=0; i < header.getReadAdditionalResources(); i++) {
    response.addAdditionalResource(decodeResource(buf,allocator));
  }
  return response;
}"
80250,"public NutFilePool(String homePath,long size){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",homePath,size);
  }
  this.size=size;
  this.home=Files.createDirIfNoExists(homePath);
  if (!home.isDirectory())   throw Lang.makeThrow(""String_Node_Str"",homePath,this.getClass().getName());
  home=new File(Disks.normalize(homePath));
  if (log.isDebugEnabled()) {
    log.debugf(""String_Node_Str"",home.getAbsolutePath());
  }
  File last=home;
  String[] subs=null;
  while (last.isDirectory()) {
    subs=last.list(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        return Regex.match(""String_Node_Str"",name);
      }
    }
);
    if (null != subs && subs.length > 0) {
      String lastName=""String_Node_Str"";
      for (      String sub : subs) {
        if (sub.compareTo(lastName) > 0) {
          lastName=sub;
        }
      }
      last=new File(last.getAbsolutePath() + ""String_Node_Str"" + lastName);
      if (last.isFile()) {
        cursor=Pools.getFileId(home,last);
        break;
      }
    }
 else {
      break;
    }
  }
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",cursor);
}","public NutFilePool(String homePath,long size){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",homePath,size);
  }
  this.size=size;
  this.home=Files.createDirIfNoExists(homePath);
  if (!home.isDirectory())   throw Lang.makeThrow(""String_Node_Str"",homePath,this.getClass().getName());
  home=new File(Disks.normalize(homePath));
  if (log.isDebugEnabled()) {
    log.debugf(""String_Node_Str"",home.getAbsolutePath());
  }
  cursor=foundMax(home,home,0);
  if (cursor < 0)   cursor=0;
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",cursor);
}"
80251,"/** 
 * 快速插入一个对象。 对象的 '@Prev' 以及 '@Next' 在这个函数里不起作用。 <p> 即，你必须为其设置好值，它会统一采用 batch 的方法插入
 * @param obj 要被插入的对象 <p> 它可以是： <ul> <li>普通 POJO <li>集合 <li>数组 <li>Map </ul> <b style=color:red>注意：</b> 如果是集合，数组或者 Map，所有的对象必须类型相同，否则可能会出错
 */
<T>T fastInsert(T obj);","<T>T fastInsert(T obj,boolean detectAllColumns);"
80252,"EntityOperator _optBy(Object obj){
  if (null == obj)   return null;
  Entity<?> en=holder.getEntityBy(obj);
  if (null == en)   return null;
  EntityOperator re=_opt(en);
  re.myObj=obj.getClass().isArray() ? Lang.array2list((Object[])obj) : obj;
  return re;
}","EntityOperator _optBy(Object obj,boolean detectAllColumns){
  if (null == obj)   return null;
  Entity<?> en=null;
  if (detectAllColumns && Lang.eleSize(obj) > 1) {
    Object first=Lang.first(obj);
    if (first != null && first instanceof Map) {
      final Map<String,Object> tmp=new HashMap<String,Object>();
      Lang.each(obj,new Each<Object>(){
        @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void invoke(        int index,        Object ele,        int length) throws ExitLoop, ContinueLoop, LoopException {
          tmp.putAll((Map)ele);
        }
      }
);
      en=holder.getEntityBy(tmp);
    }
  }
  if (en == null) {
    en=holder.getEntityBy(obj);
  }
  if (null == en)   return null;
  EntityOperator re=_opt(en);
  re.myObj=obj.getClass().isArray() ? Lang.array2list((Object[])obj) : obj;
  return re;
}"
80253,"public void invoke(Connection conn){
  Statement stat=null;
  ResultSet rs=null;
  try {
    stat=conn.createStatement();
    String sql=""String_Node_Str"" + tableName + ""String_Node_Str"";
    rs=stat.executeQuery(sql);
    if (rs.next())     ee[0]=true;
  }
 catch (  SQLException e) {
  }
 finally {
    Daos.safeClose(stat,rs);
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void invoke(int index,Object ele,int length) throws ExitLoop, ContinueLoop, LoopException {
  tmp.putAll((Map)ele);
}"
80254,"public <T>T fastInsert(T obj){
  EntityOperator opt=_optBy(obj);
  if (null == opt)   return null;
  opt.addInsertSelfOnly();
  opt.exec();
  return obj;
}","public <T>T fastInsert(T obj,boolean detectAllColumns){
  EntityOperator opt=_optBy(obj,detectAllColumns);
  if (null == opt)   return null;
  opt.addInsertSelfOnly();
  opt.exec();
  return obj;
}"
80255,"@Override public void toJson(Mirror<?> mirror,Object currentObj,JsonRender r,JsonFormat jf) throws IOException {
  String df=jf.getDateFormatRaw();
  if (df == null)   df=""String_Node_Str"";
  Locale locale=null;
  String tmp=jf.getLocale();
  if (tmp != null)   locale=Locale.forLanguageTag(tmp);
 else   locale=Locale.getDefault();
  r.string2Json(DateTimeFormatter.ofPattern(df,locale).format((TemporalAccessor)currentObj));
}","@Override public void toJson(Mirror<?> mirror,Object currentObj,JsonRender r,JsonFormat jf) throws IOException {
  String df=jf.getDateFormatRaw();
  if (df == null)   df=""String_Node_Str"";
  Locale locale=null;
  String tmp=jf.getLocale();
  if (tmp != null)   locale=Locale.forLanguageTag(tmp);
 else   locale=Locale.getDefault();
  r.string2Json(DateTimeFormatter.ofPattern(df,locale).withZone(ZoneId.systemDefault()).format((TemporalAccessor)currentObj));
}"
80256,"public NutFilePool(String homePath,long size){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",homePath,size);
  }
  this.size=size;
  this.home=Files.createDirIfNoExists(homePath);
  if (!home.isDirectory())   throw Lang.makeThrow(""String_Node_Str"",homePath,this.getClass().getName());
  home=new File(Disks.normalize(homePath));
  if (log.isDebugEnabled()) {
    log.debugf(""String_Node_Str"",home.getAbsolutePath());
  }
  File last=home;
  String[] subs=null;
  while (last.isDirectory()) {
    subs=last.list(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        return name.matches(""String_Node_Str"");
      }
    }
);
    if (null != subs && subs.length > 0) {
      String lastName=""String_Node_Str"";
      for (      String sub : subs) {
        if (sub.compareTo(lastName) > 0) {
          lastName=sub;
        }
      }
      last=new File(last.getAbsolutePath() + ""String_Node_Str"" + lastName);
      if (last.isFile()) {
        cursor=Pools.getFileId(home,last);
        break;
      }
    }
 else {
      break;
    }
  }
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",cursor);
}","public NutFilePool(String homePath,long size){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",homePath,size);
  }
  this.size=size;
  this.home=Files.createDirIfNoExists(homePath);
  if (!home.isDirectory())   throw Lang.makeThrow(""String_Node_Str"",homePath,this.getClass().getName());
  home=new File(Disks.normalize(homePath));
  if (log.isDebugEnabled()) {
    log.debugf(""String_Node_Str"",home.getAbsolutePath());
  }
  File last=home;
  String[] subs=null;
  while (last.isDirectory()) {
    subs=last.list(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        return Regex.match(""String_Node_Str"",name);
      }
    }
);
    if (null != subs && subs.length > 0) {
      String lastName=""String_Node_Str"";
      for (      String sub : subs) {
        if (sub.compareTo(lastName) > 0) {
          lastName=sub;
        }
      }
      last=new File(last.getAbsolutePath() + ""String_Node_Str"" + lastName);
      if (last.isFile()) {
        cursor=Pools.getFileId(home,last);
        break;
      }
    }
 else {
      break;
    }
  }
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",cursor);
}"
80257,"public boolean accept(File dir,String name){
  return name.matches(""String_Node_Str"");
}","public boolean accept(File dir,String name){
  return Regex.match(""String_Node_Str"",name);
}"
80258,"public static boolean isIocObject(Map<String,?> map){
  for (  Entry<String,?> en : map.entrySet())   if (!en.getKey().matches(OBJFIELDS))   return false;
  return true;
}","public static boolean isIocObject(Map<String,?> map){
  for (  Entry<String,?> en : map.entrySet())   if (!Regex.match(OBJFIELDS,en.getKey()))   return false;
  return true;
}"
80259,"private void checkIfNeedAddNode(){
  if (!Strings.isBlank(sb)) {
    String s=Strings.trim(clearStringBuffer());
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      addNode(new NullNode());
    }
 else     if (s.matches(""String_Node_Str"")) {
      addNode(new BooleanNode(s));
    }
 else     if (s.matches(""String_Node_Str"")) {
      addNode(new NumberNode(s));
    }
 else     if (null == last) {
      int pos=s.lastIndexOf('.');
      if (pos < 0)       throw Lang.makeThrow(""String_Node_Str"",s);
      String className=s.substring(0,pos);
      String funcName=s.substring(pos + 1);
      addNode(new StaticFunctionNode(className,funcName,new ChainNode[0]));
    }
 else {
      addNode(new FieldNode(s));
    }
  }
}","private void checkIfNeedAddNode(){
  if (!Strings.isBlank(sb)) {
    String s=Strings.trim(clearStringBuffer());
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      addNode(new NullNode());
    }
 else     if (Regex.match(""String_Node_Str"",s)) {
      addNode(new BooleanNode(s));
    }
 else     if (Regex.match(""String_Node_Str"",s)) {
      addNode(new NumberNode(s));
    }
 else     if (null == last) {
      int pos=s.lastIndexOf('.');
      if (pos < 0)       throw Lang.makeThrow(""String_Node_Str"",s);
      String className=s.substring(0,pos);
      String funcName=s.substring(pos + 1);
      addNode(new StaticFunctionNode(className,funcName,new ChainNode[0]));
    }
 else {
      addNode(new FieldNode(s));
    }
  }
}"
80260,"/** 
 * 根据正则式，从压缩文件中获取文件
 * @param zip 压缩文件
 * @param regex 正则式，用来匹配文件名
 * @return 数组
 */
public static ZipEntry[] findEntryInZip(ZipFile zip,String regex){
  List<ZipEntry> list=new LinkedList<ZipEntry>();
  Enumeration<? extends ZipEntry> en=zip.entries();
  while (en.hasMoreElements()) {
    ZipEntry ze=en.nextElement();
    if (null == regex || ze.getName().matches(regex))     list.add(ze);
  }
  return list.toArray(new ZipEntry[list.size()]);
}","/** 
 * 根据正则式，从压缩文件中获取文件
 * @param zip 压缩文件
 * @param regex 正则式，用来匹配文件名
 * @return 数组
 */
public static ZipEntry[] findEntryInZip(ZipFile zip,String regex){
  List<ZipEntry> list=new LinkedList<ZipEntry>();
  Enumeration<? extends ZipEntry> en=zip.entries();
  while (en.hasMoreElements()) {
    ZipEntry ze=en.nextElement();
    if (null == regex || Regex.match(regex,ze.getName()))     list.add(ze);
  }
  return list.toArray(new ZipEntry[list.size()]);
}"
80261,"/** 
 * @see #splitInt(String)
 */
public static boolean[] splitBoolean(String str){
  String[] ss=Strings.splitIgnoreBlank(str);
  if (null == ss)   return null;
  boolean[] ns=new boolean[ss.length];
  for (int i=0; i < ns.length; i++) {
    try {
      ns[i]=Pattern.matches(""String_Node_Str"",ss[i].toLowerCase());
    }
 catch (    NumberFormatException e) {
      ns[i]=false;
    }
  }
  return ns;
}","/** 
 * @see #splitInt(String)
 */
public static boolean[] splitBoolean(String str){
  String[] ss=Strings.splitIgnoreBlank(str);
  if (null == ss)   return null;
  boolean[] ns=new boolean[ss.length];
  for (int i=0; i < ns.length; i++) {
    try {
      ns[i]=Regex.match(""String_Node_Str"",ss[i].toLowerCase());
    }
 catch (    NumberFormatException e) {
      ns[i]=false;
    }
  }
  return ns;
}"
80262,"/** 
 * 判断日期是否有效,包括闰年的情况
 * @param date 日期格式YYYY-mm-dd
 * @return true,如果合法
 */
public static boolean isDate(String date){
  StringBuffer reg=new StringBuffer(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  Pattern p=Pattern.compile(reg.toString());
  return p.matcher(date).matches();
}","/** 
 * 判断日期是否有效,包括闰年的情况
 * @param date 日期格式YYYY-mm-dd
 * @return true,如果合法
 */
public static boolean isDate(String date){
  StringBuffer reg=new StringBuffer(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  reg.append(""String_Node_Str"");
  Pattern p=Regex.getPattern(reg.toString());
  return p.matcher(date).matches();
}"
80263,"/** 
 * 判断某个元素下是否有子元素
 * @param ele 元素
 * @param regex 子元素名称的正则表达式，如果为 null，则元素内如果有任意元素都会返回 false
 * @return 是否有子元素
 */
public static boolean hasChild(Element ele,String regex){
  NodeList nl=ele.getChildNodes();
  int len=nl.getLength();
  for (int i=0; i < len; i++) {
    Node nd=nl.item(i);
    if (nd instanceof Element) {
      if (null == regex)       return false;
      if (((Element)nd).getTagName().matches(regex))       return true;
    }
  }
  return false;
}","/** 
 * 判断某个元素下是否有子元素
 * @param ele 元素
 * @param regex 子元素名称的正则表达式，如果为 null，则元素内如果有任意元素都会返回 false
 * @return 是否有子元素
 */
public static boolean hasChild(Element ele,String regex){
  NodeList nl=ele.getChildNodes();
  int len=nl.getLength();
  for (int i=0; i < len; i++) {
    Node nd=nl.item(i);
    if (nd instanceof Element) {
      if (null == regex)       return false;
      if (Regex.match(regex,((Element)nd).getTagName()))       return true;
    }
  }
  return false;
}"
80264,"/** 
 * 遍历文件夹下以特定后缀结尾的文件(不包括文件夹,不包括.开头的文件)
 * @param path 根路径
 * @param regex 文件名的正则表达式
 * @param deep 是否深层遍历
 * @param fv 你所提供的访问器,当然就是你自己的逻辑咯
 */
public static final void visitFile(String path,final String regex,final boolean deep,final FileVisitor fv){
  File d=Files.findFile(path);
  if (null == d)   return;
  visitFile(d,new FileVisitor(){
    @Override public void visit(    File f){
      if (f.isDirectory())       return;
      fv.visit(f);
    }
  }
,new FileFilter(){
    @Override public boolean accept(    File f){
      if (f.isDirectory())       return deep;
      if (f.isHidden())       return false;
      if (Strings.isEmpty(regex))       return true;
      return f.getName().matches(regex);
    }
  }
);
}","/** 
 * 遍历文件夹下以特定后缀结尾的文件(不包括文件夹,不包括.开头的文件)
 * @param path 根路径
 * @param regex 文件名的正则表达式
 * @param deep 是否深层遍历
 * @param fv 你所提供的访问器,当然就是你自己的逻辑咯
 */
public static final void visitFile(String path,final String regex,final boolean deep,final FileVisitor fv){
  File d=Files.findFile(path);
  if (null == d)   return;
  visitFile(d,new FileVisitor(){
    @Override public void visit(    File f){
      if (f.isDirectory())       return;
      fv.visit(f);
    }
  }
,new FileFilter(){
    @Override public boolean accept(    File f){
      if (f.isDirectory())       return deep;
      if (f.isHidden())       return false;
      if (Strings.isEmpty(regex))       return true;
      return Regex.match(regex,f.getName());
    }
  }
);
}"
80265,"private boolean __match_val(final Object mtc,Object val){
  Mirror<?> mi=Mirror.me(mtc);
  if (null == val) {
    return mi.isStringLike() && Strings.isEmpty(mtc.toString());
  }
  Pattern regex=mi.is(Pattern.class) ? (Pattern)mtc : null;
  if (mi.isStringLike()) {
    final String s=mtc.toString();
    if (s.startsWith(""String_Node_Str"")) {
      regex=Pattern.compile(s);
    }
 else {
      final boolean[] re=new boolean[1];
      Lang.each(val,new Each<Object>(){
        @Override public void invoke(        int index,        Object ele,        int length){
          if (null != ele && ele.equals(s)) {
            re[0]=true;
            Lang.Break();
          }
        }
      }
);
      return re[0];
    }
  }
  if (null != regex) {
    final boolean[] re=new boolean[1];
    final Pattern REG=regex;
    Lang.each(val,new Each<Object>(){
      @Override public void invoke(      int index,      Object ele,      int length){
        if (null != ele && REG.matcher(ele.toString()).matches()) {
          re[0]=true;
          Lang.Break();
        }
      }
    }
);
    return re[0];
  }
  if (mi.isSimple()) {
    final boolean[] re=new boolean[1];
    Lang.each(val,new Each<Object>(){
      @Override public void invoke(      int index,      Object ele,      int length){
        if (null != ele && ele.equals(mtc)) {
          re[0]=true;
          Lang.Break();
        }
      }
    }
);
    return re[0];
  }
 else   if (mi.is(Region.class)) {
    throw Lang.noImplement();
  }
  return false;
}","private boolean __match_val(final Object mtc,Object val){
  Mirror<?> mi=Mirror.me(mtc);
  if (null == val) {
    return mi.isStringLike() && Strings.isEmpty(mtc.toString());
  }
  Pattern regex=mi.is(Pattern.class) ? (Pattern)mtc : null;
  if (mi.isStringLike()) {
    final String s=mtc.toString();
    if (s.startsWith(""String_Node_Str"")) {
      regex=Regex.getPattern(s);
    }
 else {
      final boolean[] re=new boolean[1];
      Lang.each(val,new Each<Object>(){
        @Override public void invoke(        int index,        Object ele,        int length){
          if (null != ele && ele.equals(s)) {
            re[0]=true;
            Lang.Break();
          }
        }
      }
);
      return re[0];
    }
  }
  if (null != regex) {
    final boolean[] re=new boolean[1];
    final Pattern REG=regex;
    Lang.each(val,new Each<Object>(){
      @Override public void invoke(      int index,      Object ele,      int length){
        if (null != ele && REG.matcher(ele.toString()).matches()) {
          re[0]=true;
          Lang.Break();
        }
      }
    }
);
    return re[0];
  }
  if (mi.isSimple()) {
    final boolean[] re=new boolean[1];
    Lang.each(val,new Each<Object>(){
      @Override public void invoke(      int index,      Object ele,      int length){
        if (null != ele && ele.equals(mtc)) {
          re[0]=true;
          Lang.Break();
        }
      }
    }
);
    return re[0];
  }
 else   if (mi.is(Region.class)) {
    throw Lang.noImplement();
  }
  return false;
}"
80266,"private static List<Sql> createIndexs(Dao dao,Entity<?> en,Set<String> indexsHis,Object t){
  List<Sql> sqls=new ArrayList<Sql>();
  StringBuilder sb=new StringBuilder();
  List<EntityIndex> indexs=en.getIndexes();
  for (  EntityIndex index : indexs) {
    if (indexsHis.contains(index.getName())) {
      continue;
    }
    sb.setLength(0);
    if (index.isUnique())     sb.append(""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    if (index.getName().contains(""String_Node_Str"")) {
      final String name=index.getName();
      final Molecule<String> m=new Molecule<String>(){
        public void run(){
          setObj(TableName.render(new CharSegment(name)));
        }
      }
;
      TableName.run(t,m);
      sb.append(m.getObj());
    }
 else     sb.append(index.getName());
    sb.append(""String_Node_Str"").append(getTableName(dao,en,t)).append(""String_Node_Str"");
    for (    EntityField field : index.getFields()) {
      if (field instanceof MappingField) {
        MappingField mf=(MappingField)field;
        sb.append(mf.getColumnName()).append(',');
      }
 else {
        throw Lang.makeThrow(DaoException.class,""String_Node_Str"",en.getClass(),field.getName());
      }
    }
    sb.setCharAt(sb.length() - 1,')');
    sqls.add(Sqls.create(sb.toString()));
  }
  return sqls;
}","private static List<Sql> createIndexs(Dao dao,Entity<?> en,Set<String> indexsHis,Object t){
  List<Sql> sqls=new ArrayList<Sql>();
  StringBuilder sb=new StringBuilder();
  List<EntityIndex> indexs=en.getIndexes();
  for (  EntityIndex index : indexs) {
    String indexName=index.getName();
    if (indexName.contains(""String_Node_Str"")) {
      final String name=index.getName();
      final Molecule<String> m=new Molecule<String>(){
        public void run(){
          setObj(TableName.render(new CharSegment(name)));
        }
      }
;
      TableName.run(t,m);
      indexName=m.getObj();
    }
    if (indexsHis.contains(indexName)) {
      continue;
    }
    sb.setLength(0);
    if (index.isUnique())     sb.append(""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    sb.append(indexName);
    sb.append(""String_Node_Str"").append(getTableName(dao,en,t)).append(""String_Node_Str"");
    for (    EntityField field : index.getFields()) {
      if (field instanceof MappingField) {
        MappingField mf=(MappingField)field;
        sb.append(mf.getColumnName()).append(',');
      }
 else {
        throw Lang.makeThrow(DaoException.class,""String_Node_Str"",en.getClass(),field.getName());
      }
    }
    sb.setCharAt(sb.length() - 1,')');
    sqls.add(Sqls.create(sb.toString()));
  }
  return sqls;
}"
80267,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T extends Annotation>T getAnnotationDeep(Method method,Class<T> annotationClass){
  T t=method.getAnnotation(annotationClass);
  if (t != null)   return t;
  Class klass=method.getDeclaringClass();
  while (klass != null && klass != Object.class) {
    try {
      Method tmp=klass.getMethod(method.getName(),method.getParameterTypes());
      t=tmp.getAnnotation(annotationClass);
      if (t != null)       return t;
    }
 catch (    Exception e) {
      break;
    }
    klass=klass.getSuperclass();
  }
  for (  Class klass2 : method.getDeclaringClass().getInterfaces()) {
    try {
      Method tmp=klass2.getMethod(method.getName(),method.getParameterTypes());
      t=tmp.getAnnotation(annotationClass);
      if (t != null)       return t;
    }
 catch (    Exception e) {
    }
  }
  return null;
}","public static <T extends Annotation>T getAnnotationDeep(Class<?> type,Class<T> annotationClass){
  T t=type.getAnnotation(annotationClass);
  if (t != null)   return t;
  Class<?> klass=type.getSuperclass();
  while (klass != null && klass != Object.class) {
    try {
      t=klass.getAnnotation(annotationClass);
      if (t != null)       return t;
    }
 catch (    Exception e) {
      break;
    }
    klass=klass.getSuperclass();
  }
  for (  Class<?> klass2 : type.getInterfaces()) {
    try {
      t=klass2.getAnnotation(annotationClass);
      if (t != null)       return t;
    }
 catch (    Exception e) {
    }
  }
  return null;
}"
80268,"public static void evalModule(ActionInfo ai,Class<?> type){
  ai.setModuleType(type);
  String beanName=null;
  InjectName innm=type.getAnnotation(InjectName.class);
  IocBean iocBean=type.getAnnotation(IocBean.class);
  if (innm == null && iocBean == null)   return;
  if (iocBean != null) {
    beanName=iocBean.name();
  }
  if (Strings.isBlank(beanName)) {
    if (innm != null && !Strings.isBlank(innm.value())) {
      beanName=innm.value();
    }
 else {
      beanName=Strings.lowerFirst(type.getSimpleName());
    }
  }
  ai.setInjectName(beanName);
}","public static void evalModule(ActionInfo ai,Class<?> type){
  ai.setModuleType(type);
  String beanName=null;
  InjectName innm=Mirror.getAnnotationDeep(type,InjectName.class);
  IocBean iocBean=Mirror.getAnnotationDeep(type,IocBean.class);
  if (innm == null && iocBean == null)   return;
  if (iocBean != null) {
    beanName=iocBean.name();
  }
  if (Strings.isBlank(beanName)) {
    if (innm != null && !Strings.isBlank(innm.value())) {
      beanName=innm.value();
    }
 else {
      beanName=Strings.lowerFirst(type.getSimpleName());
    }
  }
  ai.setInjectName(beanName);
}"
80269,"public static void evalHttpMethod(ActionInfo ai,Method method,At at){
  if (method.getAnnotation(GET.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  if (method.getAnnotation(POST.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  if (method.getAnnotation(PUT.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  if (method.getAnnotation(DELETE.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  for (  String m : at.methods()) {
    ai.getHttpMethods().add(m.toUpperCase());
  }
}","public static void evalHttpMethod(ActionInfo ai,Method method,At at){
  if (Mirror.getAnnotationDeep(method,GET.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  if (Mirror.getAnnotationDeep(method,POST.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  if (Mirror.getAnnotationDeep(method,PUT.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  if (Mirror.getAnnotationDeep(method,DELETE.class) != null)   ai.getHttpMethods().add(""String_Node_Str"");
  for (  String m : at.methods()) {
    ai.getHttpMethods().add(m.toUpperCase());
  }
}"
80270,"protected UrlMapping evalUrlMapping(NutConfig config,Class<?> mainModule,Ioc ioc) throws Exception {
  UrlMapping mapping=createUrlMapping(config);
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",mapping.getClass().getName());
  ViewMaker[] makers=createViewMakers(mainModule,ioc);
  ActionChainMaker maker=createChainMaker(config,mainModule);
  ActionInfo mainInfo=Loadings.createInfo(mainModule);
  Set<Class<?>> modules=Loadings.scanModules(ioc,mainModule);
  if (modules.isEmpty()) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
  int atMethods=0;
  for (  Class<?> module : modules) {
    ActionInfo moduleInfo=Loadings.createInfo(module).mergeWith(mainInfo);
    for (    Method method : module.getMethods()) {
      if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))       continue;
      ActionInfo info=Loadings.createInfo(method).mergeWith(moduleInfo);
      info.setViewMakers(makers);
      mapping.add(maker,info,config);
      atMethods++;
    }
    if (null != moduleInfo.getPathMap()) {
      for (      Entry<String,String> en : moduleInfo.getPathMap().entrySet()) {
        config.getAtMap().add(en.getKey(),en.getValue());
      }
    }
  }
  if (atMethods == 0) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
 else {
    log.infof(""String_Node_Str"",atMethods);
  }
  return mapping;
}","protected UrlMapping evalUrlMapping(NutConfig config,Class<?> mainModule,Ioc ioc) throws Exception {
  UrlMapping mapping=createUrlMapping(config);
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",mapping.getClass().getName());
  ViewMaker[] makers=createViewMakers(mainModule,ioc);
  ActionChainMaker maker=createChainMaker(config,mainModule);
  ActionInfo mainInfo=Loadings.createInfo(mainModule);
  Set<Class<?>> modules=Loadings.scanModules(ioc,mainModule);
  if (modules.isEmpty()) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
  int atMethods=0;
  for (  Class<?> module : modules) {
    ActionInfo moduleInfo=Loadings.createInfo(module).mergeWith(mainInfo);
    for (    Method method : module.getMethods()) {
      if (!Modifier.isPublic(method.getModifiers()) || method.isBridge() || Mirror.getAnnotationDeep(method,At.class) == null || method.getDeclaringClass() != module)       continue;
      ActionInfo info=Loadings.createInfo(method).mergeWith(moduleInfo);
      info.setViewMakers(makers);
      mapping.add(maker,info,config);
      atMethods++;
    }
    if (null != moduleInfo.getPathMap()) {
      for (      Entry<String,String> en : moduleInfo.getPathMap().entrySet()) {
        config.getAtMap().add(en.getKey(),en.getValue());
      }
    }
  }
  if (atMethods == 0) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
 else {
    log.infof(""String_Node_Str"",atMethods);
  }
  return mapping;
}"
80271,"/** 
 * 首先,载入需要的配置信息, 分别从nutz.properties和ServletContext的上下文获取. <p/> 子类可以覆盖这个方法实现从任意方式加载配置
 */
@SuppressWarnings(""String_Node_Str"") protected void findConfig(){
  String propLocation=sc.getInitParameter(PROP_LOCATION);
  if (Strings.isBlank(propLocation)) {
    propLocation=""String_Node_Str"";
  }
  PropertiesProxy pp=new PropertiesProxy();
  Enumeration<String> params=sc.getInitParameterNames();
  while (params.hasMoreElements()) {
    String name=(String)params.nextElement();
    if (name.startsWith(""String_Node_Str"")) {
      pp.put(name,sc.getInitParameter(name).trim());
    }
  }
  InputStream in=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"" + propLocation);
  if (in == null) {
    in=sc.getResourceAsStream(""String_Node_Str"" + propLocation);
  }
  if (in == null) {
    log.debug(propLocation + ""String_Node_Str"");
  }
 else {
    pp=new PropertiesProxy(in);
    Streams.safeClose(in);
    this.pp=pp;
  }
}","/** 
 * 首先,载入需要的配置信息, 分别从nutz.properties和ServletContext的上下文获取. <p/> 子类可以覆盖这个方法实现从任意方式加载配置
 */
@SuppressWarnings(""String_Node_Str"") protected void findConfig(){
  String propLocation=sc.getInitParameter(PROP_LOCATION);
  if (Strings.isBlank(propLocation)) {
    propLocation=""String_Node_Str"";
  }
  PropertiesProxy pp=new PropertiesProxy();
  Enumeration<String> params=sc.getInitParameterNames();
  while (params.hasMoreElements()) {
    String name=(String)params.nextElement();
    if (name.startsWith(""String_Node_Str"")) {
      pp.put(name,sc.getInitParameter(name).trim());
    }
  }
  InputStream in=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"" + propLocation);
  if (in == null) {
    in=sc.getResourceAsStream(""String_Node_Str"" + propLocation);
  }
  if (in == null) {
    log.debug(propLocation + ""String_Node_Str"");
  }
 else {
    pp=new PropertiesProxy(in);
    Streams.safeClose(in);
  }
  this.pp=pp;
}"
80272,"public void set(Entity<?> en){
  this.map.put(en.getType(),en);
}","public void set(Entity<?> en){
synchronized (map) {
    this.map.put(en.getType(),en);
  }
}"
80273,"/** 
 * 重新载入
 */
public <T>Entity<T> reloadEntity(Dao dao,Class<T> classOfT){
  final Entity<T> re=maker.make(classOfT);
  map.put(classOfT,re);
  support.expert.createEntity(dao,re);
  support.run(new ConnCallback(){
    public void invoke(    Connection conn) throws Exception {
      support.expert.setupEntityField(conn,re);
    }
  }
);
  return re;
}","/** 
 * 重新载入
 */
public <T>Entity<T> reloadEntity(Dao dao,Class<T> classOfT){
  final Entity<T> re=maker.make(classOfT);
synchronized (map) {
    map.put(classOfT,re);
  }
  support.expert.createEntity(dao,re);
  support.run(new ConnCallback(){
    public void invoke(    Connection conn) throws Exception {
      support.expert.setupEntityField(conn,re);
    }
  }
);
  return re;
}"
80274,"public void remove(Entity<?> en){
  if (en == null || en.getType() == null)   return;
  this.map.remove(en.getType());
}","public void remove(Entity<?> en){
  if (en == null || en.getType() == null)   return;
synchronized (map) {
    this.map.remove(en.getType());
  }
}"
80275,"public boolean hasType(Class<?> typeName){
  return map.containsKey(typeName);
}","public boolean hasType(Class<?> typeName){
synchronized (map) {
    return map.containsKey(typeName);
  }
}"
80276,"/** 
 * 设置一个新的 Sql 管理接口实例
 * @param sqls Sql 管理接口实例
 */
public void setSqlManager(SqlManager sqls){
  this.sqlManager=sqls;
  int count=sqls.count();
  if (sqls != null)   log.debug(""String_Node_Str"" + count);
}","/** 
 * 设置一个新的 Sql 管理接口实例
 * @param sqls Sql 管理接口实例
 */
public void setSqlManager(SqlManager sqls){
  this.sqlManager=sqls;
  if (sqls != null) {
    int count=sqls.count();
    log.debug(""String_Node_Str"" + count);
  }
}"
80277,"JdbcExpertConfigFile init(){
  String home=config.get(""String_Node_Str"").toString();
  try {
    home=Disks.normalize(home);
    if (home == null)     home=config.get(""String_Node_Str"").toString();
    long max=config.containsKey(""String_Node_Str"") ? ((Number)config.get(""String_Node_Str"")).longValue() : 2000;
    if (home.contains(""String_Node_Str"")) {
      try {
        home.replace(""String_Node_Str"",Mvcs.getServletContext().getRealPath(""String_Node_Str""));
      }
 catch (      Throwable e) {
      }
    }
    try {
      pool=new NutFilePool(home,max);
    }
 catch (    Exception e) {
      if (!home.startsWith(""String_Node_Str"") || Mvcs.getServletContext() == null)       throw e;
      try {
        String tmp=Mvcs.getServletContext().getRealPath(""String_Node_Str"") + home.substring(2);
        pool=new NutFilePool(tmp,max);
        log.info(""String_Node_Str"");
      }
 catch (      Exception e1) {
        throw e;
      }
    }
    pool=new SynchronizedFilePool(pool);
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"" + home,e);
  }
  return this;
}","JdbcExpertConfigFile init(){
  String home=config.get(""String_Node_Str"").toString();
  try {
    home=Disks.normalize(home);
    if (home == null)     home=config.get(""String_Node_Str"").toString();
    long max=config.containsKey(""String_Node_Str"") ? ((Number)config.get(""String_Node_Str"")).longValue() : 2000;
    if (home.contains(""String_Node_Str"")) {
      try {
        home=home.replace(""String_Node_Str"",Mvcs.getServletContext().getRealPath(""String_Node_Str""));
      }
 catch (      Throwable e) {
      }
    }
    try {
      pool=new NutFilePool(home,max);
    }
 catch (    Exception e) {
      if (!home.startsWith(""String_Node_Str"") || Mvcs.getServletContext() == null)       throw e;
      try {
        String tmp=Mvcs.getServletContext().getRealPath(""String_Node_Str"") + home.substring(2);
        pool=new NutFilePool(tmp,max);
        log.info(""String_Node_Str"");
      }
 catch (      Exception e1) {
        throw e;
      }
    }
    pool=new SynchronizedFilePool(pool);
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"" + home,e);
  }
  return this;
}"
80278,"/** 
 * 首先,载入需要的配置信息, 分别从nutz.properties和ServletContext的上下文获取. <p/> 子类可以覆盖这个方法实现从任意方式加载配置
 */
@SuppressWarnings(""String_Node_Str"") protected void findConfig(){
  String propLocation=sc.getInitParameter(PROP_LOCATION);
  if (Strings.isBlank(propLocation)) {
    propLocation=""String_Node_Str"";
  }
  PropertiesProxy pp=new PropertiesProxy();
  Enumeration<String> params=sc.getInitParameterNames();
  while (params.hasMoreElements()) {
    String name=(String)params.nextElement();
    if (name.startsWith(""String_Node_Str"")) {
      pp.put(name,sc.getInitParameter(name).trim());
    }
  }
  InputStream in=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"" + propLocation);
  if (in == null) {
    in=sc.getResourceAsStream(""String_Node_Str"" + propLocation);
  }
  if (in == null) {
    log.debug(propLocation + ""String_Node_Str"");
  }
 else {
    pp=new PropertiesProxy(in);
    Streams.safeClose(in);
  }
}","/** 
 * 首先,载入需要的配置信息, 分别从nutz.properties和ServletContext的上下文获取. <p/> 子类可以覆盖这个方法实现从任意方式加载配置
 */
@SuppressWarnings(""String_Node_Str"") protected void findConfig(){
  String propLocation=sc.getInitParameter(PROP_LOCATION);
  if (Strings.isBlank(propLocation)) {
    propLocation=""String_Node_Str"";
  }
  PropertiesProxy pp=new PropertiesProxy();
  Enumeration<String> params=sc.getInitParameterNames();
  while (params.hasMoreElements()) {
    String name=(String)params.nextElement();
    if (name.startsWith(""String_Node_Str"")) {
      pp.put(name,sc.getInitParameter(name).trim());
    }
  }
  InputStream in=getClass().getClassLoader().getResourceAsStream(""String_Node_Str"" + propLocation);
  if (in == null) {
    in=sc.getResourceAsStream(""String_Node_Str"" + propLocation);
  }
  if (in == null) {
    log.debug(propLocation + ""String_Node_Str"");
  }
 else {
    pp=new PropertiesProxy(in);
    Streams.safeClose(in);
    this.pp=pp;
  }
}"
80279,"private void insertRecords(int len){
  for (int i=0; i < len; i++) {
    Pet pet=Pet.create(""String_Node_Str"" + i);
    pet.setNickName(""String_Node_Str"" + i);
    pet.setPrice(R.random(30,100) / 3.1415f);
    dao.insert(pet);
  }
}","private void insertRecords(int len){
  for (int i=0; i < len; i++) {
    Pet pet=Pet.create(""String_Node_Str"" + i);
    pet.setNickName(""String_Node_Str"" + i);
    pet.setPrice((float)(R.random(30,100) / Math.PI));
    dao.insert(pet);
  }
}"
80280,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws IOException {
  Mvcs.write(resp,null == obj ? data : obj,format);
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws IOException {
  resp.setContentType(""String_Node_Str"");
  Mvcs.write(resp,null == obj ? data : obj,format);
}"
80281,"public ValueAdaptor getAdaptor(MappingField ef){
  Mirror<?> mirror=ef.getTypeMirror();
  if (mirror.isBoolean())   return new OracleBooleanAdaptor();
  if (mirror.isOf(Clob.class))   return new OracleClobAdapter(Jdbcs.getFilePool());
  if (mirror.isOf(Blob.class))   return new OracleBlobAdaptor(Jdbcs.getFilePool());
  return super.getAdaptor(ef);
}","public ValueAdaptor getAdaptor(MappingField ef){
  Mirror<?> mirror=ef.getTypeMirror();
  if (mirror.isBoolean())   return new OracleBooleanAdaptor();
  if (mirror.isOf(Clob.class))   return new ClobValueAdapter2(Jdbcs.getFilePool());
  if (mirror.isOf(Blob.class))   return new BlobValueAdaptor2(Jdbcs.getFilePool());
  return super.getAdaptor(ef);
}"
80282,"protected String param2String(Object obj){
  if (obj == null)   return ""String_Node_Str"";
 else {
    if (obj instanceof Blob) {
      Blob blob=(Blob)obj;
      return ""String_Node_Str"" + blob.hashCode() + ""String_Node_Str"";
    }
 else     if (obj instanceof Clob) {
      Clob clob=(Clob)obj;
      return ""String_Node_Str"" + clob.hashCode() + ""String_Node_Str"";
    }
 else     if (obj instanceof byte[] || obj instanceof char[]) {
      if (Array.getLength(obj) > 10240)       return ""String_Node_Str"" + Array.getLength(obj) + ""String_Node_Str"";
    }
 else     if (obj instanceof InputStream) {
      try {
        obj=""String_Node_Str"" + ((InputStream)obj).available() + ""String_Node_Str"";
      }
 catch (      IOException e) {
      }
    }
 else     if (obj instanceof Reader) {
      obj=""String_Node_Str"" + obj.hashCode();
    }
    return Castors.me().castToString(obj);
  }
}","protected String param2String(Object obj){
  if (obj == null)   return ""String_Node_Str"";
 else {
    if (obj instanceof Blob) {
      Blob blob=(Blob)obj;
      if (blob instanceof SimpleBlob) {
        try {
          return ""String_Node_Str"" + blob.length() + ""String_Node_Str"";
        }
 catch (        SQLException e) {
        }
      }
      return ""String_Node_Str"" + blob.hashCode() + ""String_Node_Str"";
    }
 else     if (obj instanceof Clob) {
      Clob clob=(Clob)obj;
      if (clob instanceof SimpleClob) {
        try {
          return ""String_Node_Str"" + clob.length() + ""String_Node_Str"";
        }
 catch (        SQLException e) {
        }
      }
      return ""String_Node_Str"" + clob.hashCode() + ""String_Node_Str"";
    }
 else     if (obj instanceof byte[] || obj instanceof char[]) {
      if (Array.getLength(obj) > 10240)       return ""String_Node_Str"" + Array.getLength(obj) + ""String_Node_Str"";
    }
 else     if (obj instanceof InputStream) {
      try {
        obj=""String_Node_Str"" + ((InputStream)obj).available() + ""String_Node_Str"";
      }
 catch (      IOException e) {
      }
    }
 else     if (obj instanceof Reader) {
      obj=""String_Node_Str"" + obj.hashCode();
    }
    return Castors.me().castToString(obj);
  }
}"
80283,"@Test public void test_insert_with_id(){
  dao.clear(Pet.class);
  Pet pet=Pet.create(""String_Node_Str"");
  pet.setId(9090);
  Dao dao=Daos.ext(this.dao,FieldFilter.create(Pet.class,FieldMatcher.make(null,null,true).setIgnoreId(false)));
  dao.insert(pet);
  pet=dao.fetch(Pet.class);
  assertEquals(9090,pet.getId());
  dao.clear(Pet.class);
  pet=Pet.create(""String_Node_Str"");
  pet.setId(9090);
  dao.insert(pet,FieldFilter.create(Pet.class,FieldMatcher.create(false)));
  pet=dao.fetch(Pet.class);
  assertEquals(9090,pet.getId());
}","@Test public void test_insert_with_id(){
  dao.clear(Pet.class);
  Pet pet=Pet.create(""String_Node_Str"");
  pet.setId(9090);
  Dao dao=Daos.ext(this.dao,FieldFilter.create(Pet.class,FieldMatcher.make(null,null,true).setIgnoreId(false)));
  dao.fastInsert(pet);
  pet=dao.fetch(Pet.class);
  assertEquals(9090,pet.getId());
  if (dao.meta().isPostgresql()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  dao.clear(Pet.class);
  pet=Pet.create(""String_Node_Str"");
  pet.setId(9090);
  dao.insert(pet,FieldFilter.create(Pet.class,FieldMatcher.create(false)));
  pet=dao.fetch(Pet.class);
  assertEquals(9090,pet.getId());
}"
80284,"public AnnotationIocLoader(String... packages){
  for (  String packageZ : packages) {
    if (packageZ.equals(""String_Node_Str"")) {
      String[] pkgs=Strings.splitIgnoreBlank(Mvcs.dynamic_ann_paths,""String_Node_Str"");
      if (null != pkgs)       for (      String pkg : pkgs)       for (      Class<?> classZ : Scans.me().scanPackage(pkg))       addClass(classZ);
    }
 else {
      for (      Class<?> classZ : Scans.me().scanPackage(packageZ))       addClass(classZ);
    }
  }
  if (map.size() > 0) {
    if (log.isInfoEnabled())     log.infof(""String_Node_Str"",map.size(),packages.length,Castors.me().castToString(map.keySet()));
  }
 else {
    log.warn(""String_Node_Str"" + Arrays.toString(packages));
  }
}","public AnnotationIocLoader(String... packages){
  for (  String packageZ : packages) {
    for (    Class<?> classZ : Scans.me().scanPackage(packageZ))     addClass(classZ);
  }
  if (map.size() > 0) {
    if (log.isInfoEnabled())     log.infof(""String_Node_Str"",map.size(),packages.length,Castors.me().castToString(map.keySet()));
  }
 else {
    log.warn(""String_Node_Str"" + Arrays.toString(packages));
  }
}"
80285,"public static Set<Class<?>> scanModules(Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  List<Class<?>> list=new LinkedList<Class<?>>();
  list.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      list.add(module);
    }
  }
  Set<Class<?>> modules=new HashSet<Class<?>>();
  if (null != ann && ann.packages() != null && ann.packages().length > 0) {
    for (    String packageName : ann.packages()) {
      if (packageName.equals(""String_Node_Str"")) {
        String[] pkgs=Strings.splitIgnoreBlank(Mvcs.dynamic_modules,""String_Node_Str"");
        if (null != pkgs)         for (        String pkg : pkgs) {
          scanModuleInPackage(modules,pkg);
        }
      }
 else {
        scanModuleInPackage(modules,packageName);
      }
    }
  }
  for (  Class<?> type : list) {
    try {
      URL location=type.getProtectionDomain().getCodeSource().getLocation();
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",location);
    }
 catch (    NullPointerException e) {
    }
    Scans.me().registerLocation(type);
  }
  for (  Class<?> type : list) {
    if (scan) {
      scanModuleInPackage(modules,type.getPackage().getName());
    }
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}","public static Set<Class<?>> scanModules(Ioc ioc,Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  Set<Class<?>> forScans=new HashSet<Class<?>>();
  Set<Class<?>> modules=new HashSet<Class<?>>();
  forScans.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      forScans.add(module);
    }
    for (    String str : ann.by()) {
      ModuleScanner ms;
      if (str.startsWith(""String_Node_Str"")) {
        String nm=str.substring(""String_Node_Str"".length());
        ms=ioc.get(ModuleScanner.class,nm);
      }
 else {
        try {
          Class<?> klass=Class.forName(str);
          Mirror<?> mi=Mirror.me(klass);
          ms=(ModuleScanner)mi.born();
        }
 catch (        ClassNotFoundException e) {
          throw Lang.wrapThrow(e);
        }
      }
      List<Class<?>> list=ms.scan();
      if (null != list)       for (      Class<?> type : list) {
        if (isModule(type)) {
          modules.add(type);
        }
      }
    }
    if (ann.packages() != null && ann.packages().length > 0) {
      for (      String packageName : ann.packages()) {
        scanModuleInPackage(modules,packageName);
      }
    }
  }
  for (  Class<?> type : forScans) {
    try {
      URL location=type.getProtectionDomain().getCodeSource().getLocation();
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",location);
    }
 catch (    NullPointerException e) {
    }
    Scans.me().registerLocation(type);
  }
  for (  Class<?> type : forScans) {
    if (scan) {
      scanModuleInPackage(modules,type.getPackage().getName());
    }
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}"
80286,"protected UrlMapping evalUrlMapping(NutConfig config,Class<?> mainModule,Ioc ioc) throws Exception {
  UrlMapping mapping=createUrlMapping(config);
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",mapping.getClass().getName());
  ViewMaker[] makers=createViewMakers(mainModule,ioc);
  ActionChainMaker maker=createChainMaker(config,mainModule);
  ActionInfo mainInfo=Loadings.createInfo(mainModule);
  Set<Class<?>> modules=Loadings.scanModules(mainModule);
  if (modules.isEmpty()) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
  int atMethods=0;
  for (  Class<?> module : modules) {
    ActionInfo moduleInfo=Loadings.createInfo(module).mergeWith(mainInfo);
    for (    Method method : module.getMethods()) {
      if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))       continue;
      ActionInfo info=Loadings.createInfo(method).mergeWith(moduleInfo);
      info.setViewMakers(makers);
      mapping.add(maker,info,config);
      atMethods++;
    }
    if (null != moduleInfo.getPathMap()) {
      for (      Entry<String,String> en : moduleInfo.getPathMap().entrySet()) {
        config.getAtMap().add(en.getKey(),en.getValue());
      }
    }
  }
  if (atMethods == 0) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
 else {
    log.infof(""String_Node_Str"",atMethods);
  }
  return mapping;
}","protected UrlMapping evalUrlMapping(NutConfig config,Class<?> mainModule,Ioc ioc) throws Exception {
  UrlMapping mapping=createUrlMapping(config);
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",mapping.getClass().getName());
  ViewMaker[] makers=createViewMakers(mainModule,ioc);
  ActionChainMaker maker=createChainMaker(config,mainModule);
  ActionInfo mainInfo=Loadings.createInfo(mainModule);
  Set<Class<?>> modules=Loadings.scanModules(ioc,mainModule);
  if (modules.isEmpty()) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
  int atMethods=0;
  for (  Class<?> module : modules) {
    ActionInfo moduleInfo=Loadings.createInfo(module).mergeWith(mainInfo);
    for (    Method method : module.getMethods()) {
      if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))       continue;
      ActionInfo info=Loadings.createInfo(method).mergeWith(moduleInfo);
      info.setViewMakers(makers);
      mapping.add(maker,info,config);
      atMethods++;
    }
    if (null != moduleInfo.getPathMap()) {
      for (      Entry<String,String> en : moduleInfo.getPathMap().entrySet()) {
        config.getAtMap().add(en.getKey(),en.getValue());
      }
    }
  }
  if (atMethods == 0) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"");
  }
 else {
    log.infof(""String_Node_Str"",atMethods);
  }
  return mapping;
}"
80287,"protected ParamInjector evalInjector(Type type,Param param){
  if (param == null || ""String_Node_Str"".equals(param.value()))   return new JsonInjector(type,null);
  return super.evalInjector(type,param);
}","protected ParamInjector evalInjector(Type type,Param param){
  if (param == null || ""String_Node_Str"".equals(param.value())) {
    Class<?> clazz=Lang.getTypeClass(type);
    if (clazz != null && AdaptorErrorContext.class.isAssignableFrom(clazz))     return new VoidInjector();
    return new JsonInjector(type,null);
  }
  return super.evalInjector(type,param);
}"
80288,"/** 
 * 对一个图像进行旋转
 * @param image 图像
 * @param degree 旋转角度, 90 为顺时针九十度， -90 为逆时针九十度
 * @return 旋转后得图像对象
 */
public static BufferedImage rotate(BufferedImage image,int degree){
  int iw=image.getWidth();
  int ih=image.getHeight();
  int w=0;
  int h=0;
  int x=0;
  int y=0;
  degree=degree % 360;
  if (degree < 0)   degree=360 + degree;
  double ang=degree * 0.0174532925;
  if (degree == 180 || degree == 0 || degree == 360) {
    w=iw;
    h=ih;
  }
 else   if (degree == 90 || degree == 270) {
    w=ih;
    h=iw;
  }
 else {
    int d=iw + ih;
    w=(int)(d * Math.abs(Math.cos(ang)));
    h=(int)(d * Math.abs(Math.sin(ang)));
  }
  x=(w / 2) - (iw / 2);
  y=(h / 2) - (ih / 2);
  BufferedImage rotatedImage=new BufferedImage(w,h,image.getType());
  Graphics gs=rotatedImage.getGraphics();
  gs.fillRect(0,0,w,h);
  AffineTransform at=new AffineTransform();
  at.rotate(ang,w / 2,h / 2);
  at.translate(x,y);
  AffineTransformOp op=new AffineTransformOp(at,AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
  op.filter(image,rotatedImage);
  image=rotatedImage;
  return image;
}","/** 
 * 对一个图像进行旋转
 * @param image 图像
 * @param degree 旋转角度, 90 为顺时针九十度， -90 为逆时针九十度
 * @return 旋转后得图像对象
 */
public static BufferedImage rotate(BufferedImage image,int degree){
  int iw=image.getWidth();
  int ih=image.getHeight();
  int w=0;
  int h=0;
  int x=0;
  int y=0;
  degree=degree % 360;
  if (degree < 0)   degree=360 + degree;
  double ang=degree * 0.0174532925;
  if (degree == 180 || degree == 0 || degree == 360) {
    w=iw;
    h=ih;
  }
 else   if (degree == 90 || degree == 270) {
    w=ih;
    h=iw;
  }
 else {
    int d=iw + ih;
    w=(int)(d * Math.abs(Math.cos(ang)));
    h=(int)(d * Math.abs(Math.sin(ang)));
  }
  x=(w / 2) - (iw / 2);
  y=(h / 2) - (ih / 2);
  BufferedImage rotatedImage=new BufferedImage(w,h,image.getType());
  Graphics2D gs=rotatedImage.createGraphics();
  gs.fillRect(0,0,w,h);
  AffineTransform at=new AffineTransform();
  at.rotate(ang,w / 2,h / 2);
  at.translate(x,y);
  AffineTransformOp op=new AffineTransformOp(at,AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
  op.filter(image,rotatedImage);
  image=rotatedImage;
  return image;
}"
80289,"/** 
 * 自动等比缩放一个图片
 * @param im 图像对象
 * @param w 宽度
 * @param h 高度
 * @return 被转换后的图像
 */
public static BufferedImage zoomScale(BufferedImage im,int w,int h){
  int oW=im.getWidth();
  int oH=im.getHeight();
  int nW=w, nH=h;
  if (h == -1) {
    nH=(int)((float)w / oW * oH);
  }
 else   if (w == -1) {
    nW=(int)((float)h / oH * oW);
  }
  BufferedImage re=new BufferedImage(nW,nH,ColorSpace.TYPE_RGB);
  re.getGraphics().drawImage(im,0,0,nW,nH,null);
  return re;
}","/** 
 * 自动等比缩放一个图片
 * @param im 图像对象
 * @param w 宽度
 * @param h 高度
 * @return 被转换后的图像
 */
public static BufferedImage zoomScale(BufferedImage im,int w,int h){
  int oW=im.getWidth();
  int oH=im.getHeight();
  int nW=w, nH=h;
  if (h == -1) {
    nH=(int)((float)w / oW * oH);
  }
 else   if (w == -1) {
    nW=(int)((float)h / oH * oW);
  }
  BufferedImage re=new BufferedImage(nW,nH,ColorSpace.TYPE_RGB);
  re.createGraphics().drawImage(im,0,0,nW,nH,null);
  return re;
}"
80290,"/** 
 * 自动缩放剪切一个图片，令其符合给定的尺寸 <p> 如果图片太大，则将其缩小，如果图片太小，则将其放大，多余的部分被裁减
 * @param im 图像对象
 * @param w 宽度
 * @param h 高度
 * @return 被转换后的图像
 */
public static BufferedImage clipScale(BufferedImage im,int w,int h){
  int oW=im.getWidth();
  int oH=im.getHeight();
  float oR=(float)oW / (float)oH;
  float nR=(float)w / (float)h;
  int nW, nH, x, y;
  if (oR > nR) {
    nW=(h * oW) / oH;
    nH=h;
    x=(w - nW) / 2;
    y=0;
  }
 else   if (oR < nR) {
    nW=w;
    nH=(w * oH) / oW;
    x=0;
    y=(h - nH) / 2;
  }
 else {
    nW=w;
    nH=h;
    x=0;
    y=0;
  }
  BufferedImage re=new BufferedImage(w,h,ColorSpace.TYPE_RGB);
  re.getGraphics().drawImage(im,x,y,nW,nH,Color.black,null);
  return re;
}","/** 
 * 自动缩放剪切一个图片，令其符合给定的尺寸 <p> 如果图片太大，则将其缩小，如果图片太小，则将其放大，多余的部分被裁减
 * @param im 图像对象
 * @param w 宽度
 * @param h 高度
 * @return 被转换后的图像
 */
public static BufferedImage clipScale(BufferedImage im,int w,int h){
  int oW=im.getWidth();
  int oH=im.getHeight();
  float oR=(float)oW / (float)oH;
  float nR=(float)w / (float)h;
  int nW, nH, x, y;
  if (oR > nR) {
    nW=(h * oW) / oH;
    nH=h;
    x=(w - nW) / 2;
    y=0;
  }
 else   if (oR < nR) {
    nW=w;
    nH=(w * oH) / oW;
    x=0;
    y=(h - nH) / 2;
  }
 else {
    nW=w;
    nH=h;
    x=0;
    y=0;
  }
  BufferedImage re=new BufferedImage(w,h,ColorSpace.TYPE_RGB);
  re.createGraphics().drawImage(im,x,y,nW,nH,Color.black,null);
  return re;
}"
80291,"public JarResourceLocation(String jarPath){
  if (jarPath.startsWith(""String_Node_Str""))   jarPath=jarPath.substring(4);
  if (jarPath.startsWith(""String_Node_Str""))   jarPath=jarPath.substring(""String_Node_Str"".length());
  this.jarPath=jarPath;
  try {
    ZipInputStream zis=Scans.makeZipInputStream(jarPath);
    ZipEntry ens=null;
    while (null != (ens=zis.getNextEntry())) {
      if (ens.isDirectory())       continue;
      names.add(ens.getName());
    }
    zis.close();
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}","public JarResourceLocation(String jarPath){
  if (jarPath.startsWith(""String_Node_Str""))   jarPath=jarPath.substring(4);
  if (jarPath.startsWith(""String_Node_Str"")) {
    jarPath=jarPath.substring(""String_Node_Str"".length());
    if (!new File(jarPath).exists() && !jarPath.startsWith(""String_Node_Str"")) {
      jarPath=""String_Node_Str"" + jarPath;
    }
  }
  this.jarPath=jarPath;
  ZipInputStream zis=null;
  try {
    zis=Scans.makeZipInputStream(jarPath);
    ZipEntry ens=null;
    while (null != (ens=zis.getNextEntry())) {
      if (ens.isDirectory())       continue;
      names.add(ens.getName());
    }
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
 finally {
    Streams.safeClose(zis);
  }
}"
80292,"public void addLoader(IocLoader loader){
  iocLoaders.add(loader);
}","public void addLoader(IocLoader loader){
  if (iocLoaders.contains(loader))   return;
  iocLoaders.add(loader);
}"
80293,"public static List<MappingField> getFieldsForUpdate(Entity<?> en,FieldMatcher fm,Object refer){
  List<MappingField> re=new ArrayList<MappingField>(en.getMappingFields().size());
  for (  MappingField mf : en.getMappingFields()) {
    if (mf.isPk()) {
      if (en.getPkType() == PkType.ID && mf.isId())       continue;
      if (en.getPkType() == PkType.NAME && mf.isName())       continue;
      if (en.getPkType() == PkType.COMPOSITE && mf.isCompositePk())       continue;
    }
    if (mf.isReadonly() || mf.isAutoIncreasement() || !mf.isUpdate())     continue;
 else     if (null != fm && null != refer && fm.isIgnoreNull() && null == mf.getValue(refer))     continue;
    if (null == fm || fm.match(mf.getName()))     re.add(mf);
  }
  if (re.isEmpty() && log.isDebugEnabled())   log.debug(""String_Node_Str"");
  return re;
}","public static List<MappingField> getFieldsForUpdate(Entity<?> en,FieldMatcher fm,Object refer){
  List<MappingField> re=new ArrayList<MappingField>(en.getMappingFields().size());
  for (  MappingField mf : en.getMappingFields()) {
    if (mf.isPk()) {
      if (en.getPkType() == PkType.ID && mf.isId())       continue;
      if (en.getPkType() == PkType.NAME && mf.isName())       continue;
      if (en.getPkType() == PkType.COMPOSITE && mf.isCompositePk())       continue;
    }
    if (mf.isReadonly() || mf.isAutoIncreasement() || !mf.isUpdate())     continue;
 else     if (null != fm && null != refer && fm.isIgnoreNull() && null == mf.getValue(Lang.first(refer)))     continue;
    if (null == fm || fm.match(mf.getName()))     re.add(mf);
  }
  if (re.isEmpty() && log.isDebugEnabled())   log.debug(""String_Node_Str"");
  return re;
}"
80294,"protected ParamInjector evalInjectorBy(Type type,Param param){
  Class<?> clazz=Lang.getTypeClass(type);
  if (clazz == null) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"",type,param);
    return null;
  }
  Type[] paramTypes=null;
  if (type instanceof ParameterizedType)   paramTypes=((ParameterizedType)type).getActualTypeArguments();
  if (null == param)   return null;
  String defaultValue=null;
  if (param.df() != null && !ParamDefailtTag.equals(param.df()))   defaultValue=param.df();
  String pm=param.value();
  String datefmt=param.dfmt();
  if (""String_Node_Str"".equals(pm)) {
    if (Map.class.isAssignableFrom(clazz)) {
      return new MapPairInjector(type);
    }
    return new ObjectPairInjector(null,type);
  }
 else   if (pm.startsWith(""String_Node_Str"") && pm.length() > 2) {
    return new ObjectNavlPairInjector(pm.substring(2),type);
  }
 else   if (clazz.isArray())   return new ArrayInjector(pm,null,type,paramTypes,defaultValue);
  return getNameInjector(pm,datefmt,type,paramTypes,defaultValue);
}","protected ParamInjector evalInjectorBy(Type type,Param param){
  Class<?> clazz=Lang.getTypeClass(type);
  if (clazz == null) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"",type,param);
    return null;
  }
  Type[] paramTypes=null;
  if (type instanceof ParameterizedType)   paramTypes=((ParameterizedType)type).getActualTypeArguments();
  if (null == param)   return null;
  String defaultValue=null;
  if (param.df() != null && !ParamDefailtTag.equals(param.df()))   defaultValue=param.df();
  String pm=param.value();
  String datefmt=param.dfmt();
  if (""String_Node_Str"".equals(pm)) {
    if (Map.class.isAssignableFrom(clazz)) {
      return new MapPairInjector(type);
    }
    return new ObjectPairInjector(null,type);
  }
 else   if (pm.startsWith(""String_Node_Str"") && pm.length() > 2) {
    return new ObjectNavlPairInjector(pm.substring(2),type);
  }
 else   if (clazz.isArray()) {
    return new ArrayInjector(pm,null,type,paramTypes,defaultValue,param.array_auto_split());
  }
  return getNameInjector(pm,datefmt,type,paramTypes,defaultValue);
}"
80295,"@SuppressWarnings(""String_Node_Str"") @Override public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object value=null;
  if (null != refer) {
    if (refer instanceof Map) {
      value=((Map<String,Object>)refer).get(name);
      if (value != null && value.getClass().isArray())       return Lang.array2array(value,klass.getComponentType());
    }
    if (value != null)     return convertMe(value);
  }
  String[] values=req.getParameterValues(name);
  if (null == values || values.length == 0)   return null;
  if (values.length == 1) {
    return convertMe(values[0]);
  }
  return Lang.array2array(values,klass.getComponentType());
}","@SuppressWarnings(""String_Node_Str"") @Override public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object value=null;
  if (null != refer) {
    if (refer instanceof Map) {
      value=((Map<String,Object>)refer).get(name);
      if (value != null && value.getClass().isArray())       return Lang.array2array(value,klass.getComponentType());
    }
    if (value != null)     return convertMe(value);
  }
  String[] values=req.getParameterValues(name);
  if (null == values || values.length == 0)   return null;
  if (values.length == 1 && auto_split) {
    return convertMe(values[0]);
  }
  return Lang.array2array(values,klass.getComponentType());
}"
80296,"public ArrayInjector(String name,String datefmt,Type type,Type[] paramTypes,String defaultValue){
  super(name,datefmt,type,paramTypes,defaultValue);
}","public ArrayInjector(String name,String datefmt,Type type,Type[] paramTypes,String defaultValue,boolean auto_split){
  super(name,datefmt,type,paramTypes,defaultValue);
  this.auto_split=auto_split;
}"
80297,"protected Response createResponse(Map<String,String> reHeaders) throws IOException {
  Response rep=null;
  if (reHeaders != null) {
    rep=new Response(conn,reHeaders);
    if (rep.isOK()) {
      InputStream is1=conn.getInputStream();
      InputStream is2=null;
      String encoding=conn.getContentEncoding();
      if (encoding != null && encoding.contains(""String_Node_Str"")) {
        is2=new GZIPInputStream(is1);
      }
 else       if (encoding != null && encoding.contains(""String_Node_Str"")) {
        is2=new InflaterInputStream(is1,new Inflater(true));
      }
 else {
        is2=is1;
      }
      BufferedInputStream is=new BufferedInputStream(is2);
      rep.setStream(is);
    }
 else {
      try {
        rep.setStream(conn.getInputStream());
      }
 catch (      IOException e) {
        rep.setStream(new NullInputStream());
      }
    }
  }
  return rep;
}","protected Response createResponse(Map<String,String> reHeaders) throws IOException {
  Response rep=null;
  if (reHeaders != null) {
    rep=new Response(conn,reHeaders);
    if (rep.isOK()) {
      InputStream is1=conn.getInputStream();
      InputStream is2=null;
      String encoding=conn.getContentEncoding();
      if (encoding != null && encoding.contains(""String_Node_Str"")) {
        is2=new GZIPInputStream(is1);
      }
 else       if (encoding != null && encoding.contains(""String_Node_Str"")) {
        is2=new InflaterInputStream(is1,new Inflater(true));
      }
 else {
        is2=is1;
      }
      BufferedInputStream is=new BufferedInputStream(is2);
      rep.setStream(is);
    }
 else {
      try {
        rep.setStream(conn.getInputStream());
      }
 catch (      IOException e) {
        try {
          rep.setStream(conn.getErrorStream());
        }
 catch (        Exception e1) {
          rep.setStream(new NullInputStream());
        }
      }
    }
  }
  return rep;
}"
80298,"public static String fromMillisCN(long mi){
  return _fromMillis(mi,TIME_S_CN,TIME_M_CN,TIME_H_CN,TIME_D_CN);
}","/** 
 * fromMillis的中文版本 1000 -> 1秒 120000 - 2分
 * @param mi 毫秒数
 * @return 可读的文字
 */
public static String fromMillisCN(long mi){
  return _fromMillis(mi,false);
}"
80299,"public static String _fromMillis(long mi,String S,String M,String H,String D){
  if (mi < T_1S) {
    return ""String_Node_Str"";
  }
  if (mi < T_1M) {
    return (int)mi / T_1S + S;
  }
  if (mi >= T_1M && mi < T_1H) {
    int m=(int)mi / T_1M;
    return m + M + fromMillis(mi - m * T_1M);
  }
  if (mi >= T_1H && mi < T_1D) {
    int h=(int)mi / T_1H;
    return h + H + fromMillis(mi - h * T_1H);
  }
  int d=(int)mi / T_1D;
  return d + D + fromMillis(mi - d * T_1D);
}","private static String _fromMillis(long mi,boolean useEnglish){
  if (mi <= T_1S) {
    return ""String_Node_Str"" + (useEnglish ? TIME_S_EN : TIME_S_CN);
  }
  if (mi < T_1M && mi > T_1S) {
    return (int)(mi / T_1S) + (useEnglish ? TIME_S_EN : TIME_S_CN);
  }
  if (mi >= T_1M && mi < T_1H) {
    int m=(int)(mi / T_1M);
    return m + (useEnglish ? TIME_M_EN : TIME_M_CN) + _fromMillis(mi - m * T_1M,useEnglish);
  }
  if (mi >= T_1H && mi < T_1D) {
    int h=(int)(mi / T_1H);
    return h + (useEnglish ? TIME_H_EN : TIME_H_CN) + _fromMillis(mi - h * T_1H,useEnglish);
  }
  if (mi >= T_1D) {
    int d=(int)(mi / T_1D);
    return d + (useEnglish ? TIME_D_EN : TIME_D_CN) + _fromMillis(mi - d * T_1D,useEnglish);
  }
  throw Lang.impossible();
}"
80300,"/** 
 * 一段时间长度的毫秒数转换为一个时间长度的字符串 1000 -> 1s 120000 - 2m
 * @param mi 毫秒数
 * @return 可以正常识别的文字
 */
public static String fromMillis(long mi){
  return _fromMillis(mi,TIME_S_EN,TIME_M_EN,TIME_H_EN,TIME_D_EN);
}","/** 
 * 一段时间长度的毫秒数转换为一个时间长度的字符串 1000 -> 1S 120000 - 2M
 * @param mi 毫秒数
 * @return 可读的文字
 */
public static String fromMillis(long mi){
  return _fromMillis(mi,true);
}"
80301,"protected void openConnection() throws IOException {
  ProxySwitcher proxySwitcher=Http.proxySwitcher;
  if (proxySwitcher != null) {
    try {
      Proxy proxy=proxySwitcher.getProxy(request);
      if (proxy != null) {
        if (Http.autoSwitch) {
          Socket socket=null;
          try {
            socket=new Socket();
            socket.connect(proxy.address(),5 * 1000);
          }
  finally {
            if (socket != null)             socket.close();
          }
        }
        conn=(HttpURLConnection)request.getUrl().openConnection(proxy);
        conn.setConnectTimeout(Default_Conn_Timeout);
        if (timeout > 0)         conn.setReadTimeout(timeout);
 else         conn.setReadTimeout(Default_Read_Timeout);
        return;
      }
    }
 catch (    IOException e) {
      if (!Http.autoSwitch) {
        throw e;
      }
      log.info(""String_Node_Str"",e);
    }
  }
  conn=(HttpURLConnection)request.getUrl().openConnection();
  conn.setConnectTimeout(Default_Conn_Timeout);
  if (timeout > 0)   conn.setReadTimeout(timeout);
 else   conn.setReadTimeout(Default_Read_Timeout);
}","protected void openConnection() throws IOException {
  ProxySwitcher proxySwitcher=Http.proxySwitcher;
  if (proxySwitcher != null) {
    try {
      Proxy proxy=proxySwitcher.getProxy(request);
      if (proxy != null) {
        if (Http.autoSwitch) {
          Socket socket=null;
          try {
            socket=new Socket();
            socket.connect(proxy.address(),5 * 1000);
          }
  finally {
            if (socket != null)             socket.close();
          }
        }
        conn=(HttpURLConnection)request.getUrl().openConnection(proxy);
        conn.setConnectTimeout(Default_Conn_Timeout);
        if (timeout > 0)         conn.setReadTimeout(timeout);
 else         conn.setReadTimeout(Default_Read_Timeout);
        return;
      }
    }
 catch (    IOException e) {
      if (!Http.autoSwitch) {
        throw e;
      }
      log.info(""String_Node_Str"",e);
    }
  }
  conn=(HttpURLConnection)request.getUrl().openConnection();
  conn.setConnectTimeout(Default_Conn_Timeout);
  conn.setRequestMethod(request.getMethod().name());
  if (timeout > 0)   conn.setReadTimeout(timeout);
 else   conn.setReadTimeout(Default_Read_Timeout);
}"
80302,"public static Sender create(Request request,int timeout){
  Sender sender=request.isGet() ? new GetSender(request) : new PostSender(request);
  return sender.setTimeout(timeout);
}","public static Sender create(Request request,int timeout){
  Sender sender=request.isGet() || request.isDelete() ? new GetSender(request) : new PostSender(request);
  return sender.setTimeout(timeout);
}"
80303,"private void insertRecords(int len){
  for (int i=0; i < len; i++) {
    Pet pet=Pet.create(""String_Node_Str"" + i);
    pet.setNickName(""String_Node_Str"" + i);
    dao.insert(pet);
  }
}","private void insertRecords(int len){
  for (int i=0; i < len; i++) {
    Pet pet=Pet.create(""String_Node_Str"" + i);
    pet.setNickName(""String_Node_Str"" + i);
    pet.setPrice(R.random(30,100) / 3.1415f);
    dao.insert(pet);
  }
}"
80304,"@Test public void test_escape_char(){
  if (dao.meta().isMySql()) {
    dao.insert(Pet.create(""String_Node_Str"").setNickName(""String_Node_Str""));
    dao.insert(Pet.create(""String_Node_Str"").setNickName(""String_Node_Str""));
    Criteria cri=Cnd.cri();
    cri.where().andLike(""String_Node_Str"",""String_Node_Str"");
    List<Pet> pets=dao.query(Pet.class,cri);
    assertEquals(1,pets.size());
    assertEquals(""String_Node_Str"",pets.get(0).getName());
  }
}","/** 
 * for issue #515 写给 mysql 一个特殊的例子
 */
@Test public void test_escape_char(){
  if (dao.meta().isMySql()) {
    dao.insert(Pet.create(""String_Node_Str"").setNickName(""String_Node_Str""));
    dao.insert(Pet.create(""String_Node_Str"").setNickName(""String_Node_Str""));
    Criteria cri=Cnd.cri();
    cri.where().andLike(""String_Node_Str"",""String_Node_Str"");
    List<Pet> pets=dao.query(Pet.class,cri);
    assertEquals(1,pets.size());
    assertEquals(""String_Node_Str"",pets.get(0).getName());
  }
}"
80305,"private void parse(){
  for (; i < cs.length; i++) {
    char c=cs[i];
    if (c == ',') {
      checkIfNeedAddNode();
    }
 else     if (c == '\'' || c == '""') {
      clearStringBuffer();
      for (i++; i < cs.length; i++) {
        char n=cs[i];
        if (n == c)         break;
        sb.append(n);
      }
      addNode(new StringNode(clearStringBuffer()));
    }
 else     if (c == '@') {
      String name=readToDot().toUpperCase();
      if (""String_Node_Str"".equals(name)) {
        addNode(new IocSelfNode());
      }
 else       if (""String_Node_Str"".equals(name)) {
        addNode(new IocContextNode());
      }
 else       if (""String_Node_Str"".equals(name)) {
        addNode(new IocObjectNameNode());
      }
      continue;
    }
 else     if (c == '$') {
      String name=readToDot();
      addNode(new IocObjectNode(name));
      continue;
    }
 else     if (c == '(') {
      String funcName=Strings.trim(clearStringBuffer());
      argss.push(new LinkedArray<ChainNode>(ChainNode.class,5));
      ends.push(')');
      i++;
      parse();
      ends.popLast();
      ChainNode[] args=argss.popLast().toArray();
      int pos=funcName.lastIndexOf('.');
      if (pos > 0) {
        String className=funcName.substring(0,pos);
        funcName=funcName.substring(pos + 1);
        addNode(new StaticFunctionNode(className,funcName,args));
      }
 else {
        addNode(new ObjectFunctionNode(funcName,args));
      }
      clearStringBuffer();
    }
 else     if (ends.size() > 0 && c == ends.last()) {
      checkIfNeedAddNode();
      return;
    }
 else {
      sb.append(c);
    }
  }
  checkIfNeedAddNode();
}","private void parse(){
  for (; i < cs.length; i++) {
    char c=cs[i];
    if (c == ',') {
      checkIfNeedAddNode();
    }
 else     if (null != first && c == '.') {
      String fn=clearStringBuffer();
      if (!Strings.isBlank(fn)) {
        addNode(new FieldNode(fn));
      }
    }
 else     if (c == '\'' || c == '""') {
      clearStringBuffer();
      for (i++; i < cs.length; i++) {
        char n=cs[i];
        if (n == c)         break;
        sb.append(n);
      }
      addNode(new StringNode(clearStringBuffer()));
    }
 else     if (c == '@') {
      String name=readToDot().toUpperCase();
      if (""String_Node_Str"".equals(name)) {
        addNode(new IocSelfNode());
      }
 else       if (""String_Node_Str"".equals(name)) {
        addNode(new IocContextNode());
      }
 else       if (""String_Node_Str"".equals(name)) {
        addNode(new IocObjectNameNode());
      }
      continue;
    }
 else     if (c == '$') {
      String name=readToDot();
      addNode(new IocObjectNode(name));
      continue;
    }
 else     if (c == '(') {
      String funcName=Strings.trim(clearStringBuffer());
      argss.push(new LinkedArray<ChainNode>(ChainNode.class,5));
      ends.push(')');
      i++;
      parse();
      ends.popLast();
      ChainNode[] args=argss.popLast().toArray();
      int pos=funcName.lastIndexOf('.');
      if (pos > 0) {
        String className=funcName.substring(0,pos);
        funcName=funcName.substring(pos + 1);
        addNode(new StaticFunctionNode(className,funcName,args));
      }
 else       if (pos == 0) {
        addNode(new ObjectFunctionNode(funcName.substring(1),args));
      }
 else {
        addNode(new ObjectFunctionNode(funcName,args));
      }
      clearStringBuffer();
    }
 else     if (ends.size() > 0 && c == ends.last()) {
      checkIfNeedAddNode();
      return;
    }
 else {
      sb.append(c);
    }
  }
  checkIfNeedAddNode();
}"
80306,"public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  if (proxyFilter != null) {
    proxyFilter.doFilter(req,resp,chain);
    return;
  }
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)resp;
  RequestPath path=Mvcs.getRequestPathObject(request);
  String matchUrl=path.getUrl();
  String preName=Mvcs.getName();
  Context preContext=Mvcs.resetALL();
  try {
    if (sp != null)     req=sp.filter(request,response,Mvcs.getServletContext());
    Mvcs.set(this.selfName,request,response);
    if (!isExclusion(matchUrl)) {
      if (handler.handle(request,response))       return;
    }
    nextChain(request,response,chain);
  }
  finally {
    Mvcs.resetALL();
    if (null != (request.getAttribute(""String_Node_Str""))) {
      if (preName != null)       Mvcs.set(preName,request,response);
      if (preContext != null)       Mvcs.ctx.reqThreadLocal.set(preContext);
    }
  }
}","public void doFilter(final ServletRequest req,final ServletResponse resp,final FilterChain chain) throws IOException, ServletException {
  if (proxyFilter != null) {
    proxyFilter.doFilter(req,resp,chain);
    return;
  }
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)resp;
  RequestPath path=Mvcs.getRequestPathObject(request);
  String matchUrl=path.getUrl();
  String preName=Mvcs.getName();
  Context preContext=Mvcs.resetALL();
  try {
    if (sp != null)     request=sp.filter(request,response,Mvcs.getServletContext());
    Mvcs.set(this.selfName,request,response);
    if (!isExclusion(matchUrl)) {
      if (handler.handle(request,response))       return;
    }
    nextChain(request,response,chain);
  }
  finally {
    Mvcs.resetALL();
    if (null != (request.getAttribute(""String_Node_Str""))) {
      if (preName != null)       Mvcs.set(preName,request,response);
      if (preContext != null)       Mvcs.ctx.reqThreadLocal.set(preContext);
    }
  }
}"
80307,"public HttpServletRequest filter(final HttpServletRequest req,final HttpServletResponse resp,final ServletContext servletContext){
  return new HttpServletRequestWrapper(req){
    private HttpSession session;
    public HttpSession getSession(    boolean create){
      if (create && session == null) {
synchronized (lock) {
          if (session == null)           session=createSession(req,resp,servletContext);
        }
      }
      return session;
    }
  }
;
}","public HttpServletRequest filter(final HttpServletRequest req,final HttpServletResponse resp,final ServletContext servletContext){
  return new SessionProviderHttpServletRequestWrapper(req,resp,servletContext);
}"
80308,"public HttpSession getSession(boolean create){
  if (create && session == null) {
synchronized (lock) {
      if (session == null)       session=createSession(req,resp,servletContext);
    }
  }
  return session;
}","public HttpSession getSession(){
  return getSession(true);
}"
80309,"/** 
 * 在指定的时间点开始以固定的频率运行任务。后续任务的启动时间不受前次任务延时影响。
 * @param task 具体待执行的任务
 * @param startTime 首次运行的时间点
 * @param period 每次执行任务的间隔时间
 * @param unit 时间单位
 */
public static void scheduleAtFixedRate(final Runnable task,Date startTime,final long period,final TimeUnit unit){
  final Timer timer=new Timer();
  timer.schedule(new TimerTask(){
    @Override public void run(){
      taskScheduler.scheduleAtFixedRate(task,0,period,unit);
      timer.cancel();
    }
  }
,startTime);
}","/** 
 * 在指定的时间点开始以固定的频率运行任务。后续任务的启动时间不受前次任务延时影响。
 * @param task 具体待执行的任务
 * @param startTime 首次运行的时间点
 * @param period 每次执行任务的间隔时间
 * @param unit 时间单位
 */
public static void scheduleAtFixedRate(final Runnable task,Date startTime,final long period,final TimeUnit unit){
  final Timer timer=new Timer();
  timer.schedule(new TimerTask(){
    @Override public void run(){
      taskScheduler.scheduleAtFixedRate(task,0,period,unit);
      timer.cancel();
      timerList.remove(timer);
    }
  }
,startTime);
  timerList.add(timer);
}"
80310,"/** 
 * 在指定的时间点启动，两次任务间保持固定的时间间隔
 * @param task 具体待执行的任务
 * @param startTime 首次运行的时间点
 * @param period 两次任务的间隔时间
 * @param unit 时间单位
 */
public static void scheduleWithFixedDelay(final Runnable task,Date startTime,final long period,final TimeUnit unit){
  final Timer timer=new Timer();
  timer.schedule(new TimerTask(){
    @Override public void run(){
      taskScheduler.scheduleWithFixedDelay(task,0,period,unit);
      timer.cancel();
    }
  }
,startTime);
}","/** 
 * 在指定的时间点启动，两次任务间保持固定的时间间隔
 * @param task 具体待执行的任务
 * @param startTime 首次运行的时间点
 * @param period 两次任务的间隔时间
 * @param unit 时间单位
 */
public static void scheduleWithFixedDelay(final Runnable task,Date startTime,final long period,final TimeUnit unit){
  final Timer timer=new Timer();
  timer.schedule(new TimerTask(){
    @Override public void run(){
      taskScheduler.scheduleWithFixedDelay(task,0,period,unit);
      timer.cancel();
      timerList.remove(timer);
    }
  }
,startTime);
  timerList.add(timer);
}"
80311,"@Override public void run(){
  taskScheduler.scheduleWithFixedDelay(task,0,period,unit);
  timer.cancel();
}","@Override public void run(){
  taskScheduler.scheduleWithFixedDelay(task,0,period,unit);
  timer.cancel();
  timerList.remove(timer);
}"
80312,"/** 
 * 关闭定时任务服务 <p>系统关闭时可调用此方法终止正在执行的定时任务，一旦关闭后不允许再向线程池中添加任务，否则会报RejectedExecutionException异常</p>
 */
public static void depose(){
  List<Runnable> awaitingExecution=taskScheduler.shutdownNow();
  logger.infof(""String_Node_Str"",awaitingExecution.size());
}","/** 
 * 关闭定时任务服务 <p>系统关闭时可调用此方法终止正在执行的定时任务，一旦关闭后不允许再向线程池中添加任务，否则会报RejectedExecutionException异常</p>
 */
public static void depose(){
  int timerNum=timerList.size();
synchronized (timerList) {
    for (    Timer t : timerList)     t.cancel();
    timerList.clear();
  }
  List<Runnable> awaitingExecution=taskScheduler.shutdownNow();
  logger.infof(""String_Node_Str"",timerNum + awaitingExecution.size());
}"
80313,"public void add(ActionChainMaker maker,ActionInfo ai,NutConfig config){
  String[] paths=ai.getPaths();
  for (int i=0; i < paths.length; i++) {
    String path=paths[i];
    if (Strings.isBlank(path))     throw new BlankAtException(ai.getModuleType(),ai.getMethod());
    if (path.charAt(0) != '/')     paths[i]='/' + path;
  }
  ActionChain chain=maker.eval(config,ai);
  for (  String path : ai.getPaths()) {
    ActionInvoker invoker=map.get(path);
    if (null == invoker) {
      invoker=new ActionInvoker();
      map.put(path,invoker);
      root.add(path,invoker);
      config.getAtMap().addMethod(path,ai.getMethod());
    }
    if (ai.isForSpecialHttpMethod()) {
      for (      String httpMethod : ai.getHttpMethods())       invoker.addChain(httpMethod,chain);
    }
 else {
      invoker.setDefaultChain(chain);
    }
  }
  printActionMapping(ai);
  if (!Strings.isBlank(ai.getPathKey()))   config.getAtMap().add(ai.getPathKey(),ai.getPaths()[0]);
}","public void add(ActionChainMaker maker,ActionInfo ai,NutConfig config){
  String[] paths=ai.getPaths();
  for (int i=0; i < paths.length; i++) {
    String path=paths[i];
    if (Strings.isBlank(path))     throw new BlankAtException(ai.getModuleType(),ai.getMethod());
    if (path.charAt(0) != '/')     paths[i]='/' + path;
  }
  ActionChain chain=maker.eval(config,ai);
  for (  String path : ai.getPaths()) {
    ActionInvoker invoker=map.get(path);
    if (null == invoker) {
      invoker=new ActionInvoker();
      map.put(path,invoker);
      root.add(path,invoker);
      config.getAtMap().addMethod(path,ai.getMethod());
    }
 else     if (!ai.isForSpecialHttpMethod()) {
      log.debugf(""String_Node_Str"" + path);
    }
    if (ai.isForSpecialHttpMethod()) {
      for (      String httpMethod : ai.getHttpMethods())       invoker.addChain(httpMethod,chain);
    }
 else {
      invoker.setDefaultChain(chain);
    }
  }
  printActionMapping(ai);
  if (!Strings.isBlank(ai.getPathKey()))   config.getAtMap().add(ai.getPathKey(),ai.getPaths()[0]);
}"
80314,"/** 
 * 从给定 offs 尽力匹配给出的数组。 <p> 需要注意的是，如果返回的是 >0 的数，内部的标志位将被设置到第一个匹配字符，以便 DUMP 内容。 <br> 所以，如果下一个节点给出的结论是 -1，但是 'l' 并不是0，那么说明这个匹配是失败的，需要将 本节点的 r 置到 max 处。 <p> 返回值 <ul> <li><b>-1</b> - 全部被匹配 <li><b>0</b> - 未发现匹配 <li><b>大于 0</b> - 在缓冲的末尾发现匹配，但是没有匹配全，希望下一个节点继续从这个位置匹配 </ul>
 * @param bs 数组
 * @return -1, 0 或者 +n
 */
int mark(byte[] bs,int[] fails){
  if (!isLoaded)   throw new MarkUnloadedRingItemException();
  byte start=bs[0];
  for (; r < max; r++) {
    if (buffer[r] == start) {
      int re=0;
      int j=r;
      while (true) {
        re++;
        j++;
        if (re == bs.length) {
          nextmark=j;
          return -1;
        }
        if (j == max) {
          nextmark=max;
          if (isStreamEnd) {
            r=max;
            return 0;
          }
          return re;
        }
        if (bs[re] != buffer[j]) {
          re=fails[re];
          if (bs[re] != buffer[j]) {
            break;
          }
 else {
            r+=re == 0 ? 1 : re;
          }
        }
      }
      r=j;
    }
  }
  nextmark=max;
  return 0;
}","/** 
 * 从给定 offs 尽力匹配给出的数组。 <p> 需要注意的是，如果返回的是 >0 的数，内部的标志位将被设置到第一个匹配字符，以便 DUMP 内容。 <br> 所以，如果下一个节点给出的结论是 -1，但是 'l' 并不是0，那么说明这个匹配是失败的，需要将 本节点的 r 置到 max 处。 <p> 返回值 <ul> <li><b>-1</b> - 全部被匹配 <li><b>0</b> - 未发现匹配 <li><b>大于 0</b> - 在缓冲的末尾发现匹配，但是没有匹配全，希望下一个节点继续从这个位置匹配 </ul>
 * @param bs 数组
 * @return -1, 0 或者 +n
 */
int mark(byte[] bs,int[] fails){
  if (!isLoaded)   throw new MarkUnloadedRingItemException();
  byte start=bs[0];
  for (; r < max; r++) {
    if (buffer[r] == start) {
      int re=0;
      int j=r;
      while (true) {
        re++;
        j++;
        if (re == bs.length) {
          nextmark=j;
          return -1;
        }
        if (j == max) {
          nextmark=max;
          if (isStreamEnd) {
            r=max;
            return 0;
          }
          return re;
        }
        if (bs[re] != buffer[j]) {
          re=fails[re];
          if (bs[re] != buffer[j]) {
            break;
          }
 else           if (re == 0) {
            r=j;
          }
 else {
            r+=re == 0 ? 1 : re;
          }
        }
      }
      r=j;
    }
  }
  nextmark=max;
  return 0;
}"
80315,"/** 
 * 根据字符串得到相对于 ""UTC 1970-01-01 00:00:00"" 的绝对毫秒数。 本函数假想给定的时间字符串是本地时间。所以计算出来结果后，还需要减去时差 支持的时间格式字符串为: <pre> yyyy-MM-dd HH:mm:ss yyyy-MM-dd HH:mm:ss.SSS yy-MM-dd HH:mm:ss; yy-MM-dd HH:mm:ss.SSS; yyyy-MM-dd; yy-MM-dd; HH:mm:ss; HH:mm:ss.SSS; </pre>
 * @param ds 时间字符串
 * @param tz 你给定的时间字符串是属于哪个时区的
 * @return 时间
 */
public static long ams(String ds,TimeZone tz){
  Matcher m=_P_TIME.matcher(ds);
  if (m.find()) {
    int yy=_int(m,2,1970);
    int MM=_int(m,4,1);
    int dd=_int(m,6,1);
    int HH=_int(m,9,0);
    int mm=_int(m,11,0);
    int ss=_int(m,13,0);
    int ms=_int(m,16,0);
    long day=(long)D1970(yy,MM,dd);
    long MS=day * 86400000L;
    MS+=(((long)HH) * 3600L + ((long)mm) * 60L + ss) * 1000L;
    MS+=(long)ms;
    long tzOffset;
    if (null == tz) {
      if (!Strings.isBlank(m.group(17))) {
        tzOffset=Long.parseLong(m.group(19)) * 3600000L * (m.group(18).charAt(0) == '-' ? -1 : 1);
      }
 else {
        tzOffset=TimeZone.getDefault().getRawOffset();
      }
    }
 else {
      tzOffset=tz.getRawOffset();
    }
    return MS - tzOffset;
  }
  throw Lang.makeThrow(""String_Node_Str"",ds);
}","/** 
 * 根据字符串得到相对于 ""UTC 1970-01-01 00:00:00"" 的绝对毫秒数。 本函数假想给定的时间字符串是本地时间。所以计算出来结果后，还需要减去时差 支持的时间格式字符串为: <pre> yyyy-MM-dd HH:mm:ss yyyy-MM-dd HH:mm:ss.SSS yy-MM-dd HH:mm:ss; yy-MM-dd HH:mm:ss.SSS; yyyy-MM-dd; yy-MM-dd; HH:mm:ss; HH:mm:ss.SSS; </pre> 时间字符串后面可以跟 +8 或者 +8:00 表示 GMT+8:00 时区。 同理 -9 或者 -9:00 表示 GMT-9:00 时区
 * @param ds 时间字符串
 * @param tz 你给定的时间字符串是属于哪个时区的
 * @return 时间
 * @see #_P_TIME
 */
public static long ams(String ds,TimeZone tz){
  Matcher m=_P_TIME.matcher(ds);
  if (m.find()) {
    int yy=_int(m,2,1970);
    int MM=_int(m,4,1);
    int dd=_int(m,6,1);
    int HH=_int(m,9,0);
    int mm=_int(m,11,0);
    int ss=_int(m,13,0);
    int ms=_int(m,16,0);
    long day=(long)D1970(yy,MM,dd);
    long MS=day * 86400000L;
    MS+=(((long)HH) * 3600L + ((long)mm) * 60L + ss) * 1000L;
    MS+=(long)ms;
    if (null == tz) {
      if (!Strings.isBlank(m.group(17))) {
        tz=TimeZone.getTimeZone(String.format(""String_Node_Str"",m.group(18),m.group(19)));
      }
 else {
        tz=TimeZone.getDefault();
      }
    }
    return MS - tz.getRawOffset() - tz.getDSTSavings();
  }
  throw Lang.makeThrow(""String_Node_Str"",ds);
}"
80316,"protected void _runExec(Connection conn,DaoStatement st) throws SQLException {
  if (st.getContext().getPager() != null) {
    throw Lang.makeThrow(DaoException.class,""String_Node_Str"" + st);
  }
  String sql=st.toPreparedStatement();
  if (log.isDebugEnabled())   log.debug(sql);
  Object[][] paramMatrix=st.getParamMatrix();
  CallableStatement stmt=null;
  ResultSet rs=null;
  try {
    stmt=conn.prepareCall(sql);
    ValueAdaptor[] adaptors=st.getAdaptors();
    if (paramMatrix != null && paramMatrix.length > 0) {
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set((PreparedStatement)stmt,paramMatrix[0][i],i + 1);
      }
    }
    stmt.execute();
    rs=stmt.getResultSet();
    try {
      st.onAfter(conn,rs);
    }
  finally {
      if (rs != null)       rs.close();
    }
    while (true) {
      if (stmt.getMoreResults()) {
        rs=stmt.getResultSet();
        try {
          if (rs != null)           st.onAfter(conn,rs);
        }
  finally {
          if (rs != null)           rs.close();
        }
      }
      break;
    }
  }
  finally {
    stmt.close();
  }
}","protected void _runExec(Connection conn,DaoStatement st) throws SQLException {
  if (st.getContext().getPager() != null) {
    throw Lang.makeThrow(DaoException.class,""String_Node_Str"" + st);
  }
  String sql=st.toPreparedStatement();
  if (log.isDebugEnabled())   log.debug(sql);
  Object[][] paramMatrix=st.getParamMatrix();
  CallableStatement stmt=null;
  ResultSet rs=null;
  try {
    stmt=conn.prepareCall(sql);
    ValueAdaptor[] adaptors=st.getAdaptors();
    if (paramMatrix != null && paramMatrix.length > 0) {
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set((PreparedStatement)stmt,paramMatrix[0][i],i + 1);
      }
    }
    stmt.execute();
    rs=stmt.getResultSet();
    try {
      st.onAfter(conn,rs);
    }
  finally {
      if (rs != null)       rs.close();
    }
    while (true) {
      if (stmt.getMoreResults()) {
        rs=stmt.getResultSet();
        try {
          if (rs != null)           st.onAfter(conn,rs);
        }
  finally {
          if (rs != null)           rs.close();
        }
      }
      break;
    }
  }
  finally {
    if (stmt != null)     stmt.close();
  }
}"
80317,"public Record(){
  map=new HashMap<String,Object>();
  sqlTypeMap=new HashMap<String,Integer>();
}","public Record(){
  map=new LinkedHashMap<String,Object>();
  sqlTypeMap=new HashMap<String,Integer>();
}"
80318,"public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[argTypes.length];
  if (args.length != injs.length)   throw new IllegalArgumentException(""String_Node_Str"");
  AdaptorErrorContext errCtx=null;
  if (argTypes.length > 0) {
    if (AdaptorErrorContext.class.isAssignableFrom(argTypes[argTypes.length - 1]))     errCtx=(AdaptorErrorContext)Mirror.me(argTypes[argTypes.length - 1]).born(argTypes.length);
  }
  Object obj;
  try {
    obj=getReferObject(sc,req,resp,pathArgs);
  }
 catch (  Throwable e) {
    if (errCtx != null) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"",e);
      errCtx.setAdaptorError(e,this);
      args[args.length - 1]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(e);
  }
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  for (int i=0; i < args.length; i++) {
    Object value=null;
    if (i < len) {
      value=null == pathArgs ? null : pathArgs[i];
    }
 else {
      value=obj;
    }
    try {
      args[i]=injs[i].get(sc,req,resp,value);
    }
 catch (    Throwable e) {
      if (errCtx != null) {
        log.infof(""String_Node_Str"",method,i,e);
        errCtx.setError(i,e,method,value,injs[i]);
      }
 else       throw Lang.wrapThrow(e);
    }
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=Lang.getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  if (errCtx == null)   return args;
  for (  Throwable err : errCtx.getErrors()) {
    if (err == null)     continue;
    int lastParam=argTypes.length - 1;
    if (AdaptorErrorContext.class.equals(argTypes[lastParam])) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      args[lastParam]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(err);
  }
  return args;
}","public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[argTypes.length];
  if (args.length != injs.length)   throw new IllegalArgumentException(""String_Node_Str"");
  AdaptorErrorContext errCtx=null;
  if (argTypes.length > 0) {
    if (AdaptorErrorContext.class.isAssignableFrom(argTypes[argTypes.length - 1]))     errCtx=(AdaptorErrorContext)Mirror.me(argTypes[argTypes.length - 1]).born(argTypes.length);
  }
  Object obj;
  try {
    obj=getReferObject(sc,req,resp,pathArgs);
  }
 catch (  Throwable e) {
    if (errCtx != null) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"",e);
      errCtx.setAdaptorError(e,this);
      args[args.length - 1]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(e);
  }
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  for (int i=0; i < args.length; i++) {
    Object value=null;
    if (i < len) {
      value=null == pathArgs ? null : pathArgs[i];
    }
 else {
      value=obj;
    }
    try {
      args[i]=injs[i].get(sc,req,resp,value);
    }
 catch (    Throwable e) {
      if (errCtx != null) {
        log.infof(""String_Node_Str"",method,i,e);
        errCtx.setError(i,e,method,value,injs[i]);
      }
 else       throw Lang.wrapThrow(e);
    }
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=Lang.getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  if (errCtx == null)   return args;
  for (  Throwable err : errCtx.getErrors()) {
    if (err == null)     continue;
    int lastParam=argTypes.length - 1;
    if (AdaptorErrorContext.class.isAssignableFrom(argTypes[lastParam])) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      args[lastParam]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(err);
  }
  return args;
}"
80319,"/** 
 * 这是最后的大招了,查一下形参的名字,作为@Param(""形参名"")进行处理
 */
protected ParamInjector paramNameInject(Method method,int index){
  List<String> names=MethodParamNamesScaner.getParamNames(method);
  if (names != null)   return new NameInjector(names.get(index),null,method.getParameterTypes()[index],null);
 else   if (log.isInfoEnabled())   log.infof(""String_Node_Str"",index,method);
  return new PathArgInjector(method.getParameterTypes()[index]);
}","/** 
 * 这是最后的大招了,查一下形参的名字,作为@Param(""形参名"")进行处理
 */
protected ParamInjector paramNameInject(Method method,int index){
  if (!Lang.isAndroid) {
    List<String> names=MethodParamNamesScaner.getParamNames(method);
    if (names != null)     return new NameInjector(names.get(index),null,method.getParameterTypes()[index],null);
 else     if (log.isInfoEnabled())     log.infof(""String_Node_Str"",index,method);
  }
  return new PathArgInjector(method.getParameterTypes()[index]);
}"
80320,"/** 
 * 测试此字符串是否被指定的左字符串和右字符串所包裹
 * @param str 字符串
 * @param l 左字符串
 * @param r 右字符串
 * @return 字符串是被左字符串和右字符串包裹
 */
public static boolean isQuoteBy(String str,String l,String r){
  if (null == str && null != l && null != r)   return false;
  return str.startsWith(l) && str.endsWith(r);
}","/** 
 * 测试此字符串是否被指定的左字符串和右字符串所包裹
 * @param str 字符串
 * @param l 左字符串
 * @param r 右字符串
 * @return 字符串是被左字符串和右字符串包裹
 */
public static boolean isQuoteBy(String str,String l,String r){
  if (null == str || null == l || null == r)   return false;
  return str.startsWith(l) && str.endsWith(r);
}"
80321,"/** 
 * 通过普通Java对象为这个 POJO 语句的 SQL 参数赋值 <br> 一个 POJO 实际上是一个 SQL 的语句模板，增加一个 Java 对象，实际上就是增加了一组参数 <br> 因此如果你想为 POJO 里附加一个集合或者数组对象，对象必须是同样类型的，否则会出现不可预知的错误 <p> 接口的实现类会根据你给出的对象类型不同，对你的对象做不通的解释，它考虑的方式为： <ul> <li>集合|数组 : 你打算增加一组对象作为本语句的参数，会为递归调用本函数 <li>迭带器(Iterator) : 你打算增加一组对象作为本语句的参数，会为递归调用本函数 <li>Map : 你打算增加一条记录（将键作为字段名） <li>Chain : 你打算增加一条记录 <li>其他 : 你打算增加一条记录（将对象字段作为字段名） </ul> <p> <b style=""color:red"">注意:</b><br> 某些 SQL 语句（比如 CREATE|DROP）即使有参数，也是没有意义的，所以 Pojo 执行器会忽略它们
 * @param obj 普通 Java 对象
 * @return 自身
 * @see org.nutz.dao.sql.Pojo#addParamsBy(Object)
 */
Pojo addParamsBy(Object obj);","/** 
 * 通过普通Java对象为这个 POJO 语句的 SQL 参数赋值 <br> 一个 POJO 实际上是一个 SQL 的语句模板，增加一个 Java 对象，实际上就是增加了一组参数 <br> 因此如果你想为 POJO 里附加一个集合或者数组对象，对象必须是同样类型的，否则会出现不可预知的错误 <p> 接口的实现类会根据你给出的对象类型不同，对你的对象做不同的解释，它考虑的方式为： <ul> <li>集合|数组 : 你打算增加一组对象作为本语句的参数，会为递归调用本函数 <li>迭带器(Iterator) : 你打算增加一组对象作为本语句的参数，会为递归调用本函数 <li>Map : 你打算增加一条记录（将键作为字段名） <li>Chain : 你打算增加一条记录 <li>其他 : 你打算增加一条记录（将对象字段作为字段名） </ul> <p> <b style=""color:red"">注意:</b><br> 某些 SQL 语句（比如 CREATE|DROP）即使有参数，也是没有意义的，所以 Pojo 执行器会忽略它们
 * @param obj 普通 Java 对象
 * @return 自身
 * @see org.nutz.dao.sql.Pojo#addParamsBy(Object)
 */
Pojo addParamsBy(Object obj);"
80322,"public Map<String,Object> toMap(){
  Map<String,Object> map=new HashMap<String,Object>();
  Entry current=head;
  while (current != null) {
    map.put(current.name,current.value);
    current=current.next;
  }
  return map;
}","public Map<String,Object> toMap(){
  Map<String,Object> map=new LinkedHashMap<String,Object>();
  Entry current=head;
  while (current != null) {
    map.put(current.name,current.value);
    current=current.next;
  }
  return map;
}"
80323,"public void insert(Class<?> classOfT,Chain chain){
  EntityOperator opt=_opt(classOfT);
  opt.myObj=chain;
  opt.addInsertSelfOnly();
  opt.exec();
}","public void insert(Class<?> classOfT,Chain chain){
  if (chain.isSpecial()) {
    Daos.insertBySpecialChain(this,getEntity(classOfT),null,chain);
    return;
  }
  EntityOperator opt=_opt(classOfT);
  opt.myObj=chain;
  opt.addInsertSelfOnly();
  opt.exec();
}"
80324,"public void invoke(Connection conn) throws Exception {
  PreparedStatement ps=conn.prepareStatement(sql.toString());
  try {
    for (int i=0; i < values.size(); i++)     adaptors.get(i).set(ps,values.get(i),i + 1);
    ints[0]=ps.executeUpdate();
  }
  finally {
    Daos.safeClose(ps);
  }
}","public void invoke(Connection conn) throws Exception {
  PreparedStatement ps=conn.prepareStatement(sql.toString());
  try {
    for (int i=0; i < values.size(); i++)     adaptors.get(i).set(ps,values.get(i),i + 1);
    ps.execute();
  }
  finally {
    Daos.safeClose(ps);
  }
}"
80325,"public void init(Method method){
  this.method=method;
  Class<?>[] argTypes=method.getParameterTypes();
  injs=new ParamInjector[argTypes.length];
  Annotation[][] annss=method.getParameterAnnotations();
  Type[] types=method.getGenericParameterTypes();
  for (int i=0; i < annss.length; i++) {
    Annotation[] anns=annss[i];
    Param param=null;
    Attr attr=null;
    IocObj iocObj=null;
    ReqHeader reqHeader=null;
    for (int x=0; x < anns.length; x++)     if (anns[x] instanceof Param) {
      param=(Param)anns[x];
      break;
    }
 else     if (anns[x] instanceof Attr) {
      attr=(Attr)anns[x];
      break;
    }
 else     if (anns[x] instanceof IocObj) {
      iocObj=(IocObj)anns[x];
      break;
    }
 else     if (anns[x] instanceof ReqHeader) {
      reqHeader=(ReqHeader)anns[x];
      break;
    }
    if (null != attr) {
      injs[i]=evalInjectorByAttrScope(attr);
      continue;
    }
    if (null != iocObj) {
      injs[i]=new IocObjInjector(method.getParameterTypes()[i],iocObj.value());
      continue;
    }
    if (null != reqHeader) {
      injs[i]=new ReqHeaderInjector(reqHeader.value(),argTypes[i]);
      continue;
    }
    injs[i]=evalInjectorByParamType(argTypes[i]);
    if (null != injs[i])     continue;
    injs[i]=evalInjector(types[i],param);
    if (null == injs[i]) {
      injs[i]=paramNameInject(method,i);
    }
  }
}","public void init(Method method){
  this.method=method;
  argTypes=method.getParameterTypes();
  injs=new ParamInjector[argTypes.length];
  Annotation[][] annss=method.getParameterAnnotations();
  Type[] types=method.getGenericParameterTypes();
  for (int i=0; i < annss.length; i++) {
    Annotation[] anns=annss[i];
    Param param=null;
    Attr attr=null;
    IocObj iocObj=null;
    ReqHeader reqHeader=null;
    for (int x=0; x < anns.length; x++)     if (anns[x] instanceof Param) {
      param=(Param)anns[x];
      break;
    }
 else     if (anns[x] instanceof Attr) {
      attr=(Attr)anns[x];
      break;
    }
 else     if (anns[x] instanceof IocObj) {
      iocObj=(IocObj)anns[x];
      break;
    }
 else     if (anns[x] instanceof ReqHeader) {
      reqHeader=(ReqHeader)anns[x];
      break;
    }
    if (null != attr) {
      injs[i]=evalInjectorByAttrScope(attr);
      continue;
    }
    if (null != iocObj) {
      injs[i]=new IocObjInjector(method.getParameterTypes()[i],iocObj.value());
      continue;
    }
    if (null != reqHeader) {
      injs[i]=new ReqHeaderInjector(reqHeader.value(),argTypes[i]);
      continue;
    }
    injs[i]=evalInjectorByParamType(argTypes[i]);
    if (null != injs[i])     continue;
    injs[i]=evalInjector(types[i],param);
    if (null == injs[i]) {
      injs[i]=paramNameInject(method,i);
    }
  }
}"
80326,"public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Class<?>[] argTypes=method.getParameterTypes();
  Object[] args=new Object[argTypes.length];
  if (args.length != injs.length)   throw new IllegalArgumentException(""String_Node_Str"");
  AdaptorErrorContext errCtx=null;
  if (argTypes.length > 0) {
    if (AdaptorErrorContext.class.isAssignableFrom(argTypes[argTypes.length - 1]))     errCtx=(AdaptorErrorContext)Mirror.me(argTypes[argTypes.length - 1]).born(argTypes.length);
  }
  Object obj;
  try {
    obj=getReferObject(sc,req,resp,pathArgs);
  }
 catch (  Throwable e) {
    if (errCtx != null) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      errCtx.setAdaptorError(e,this);
      args[args.length - 1]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(e);
  }
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  for (int i=0; i < args.length; i++) {
    Object value=null;
    if (i < len) {
      value=null == pathArgs ? null : pathArgs[i];
    }
 else {
      value=obj;
    }
    try {
      args[i]=injs[i].get(sc,req,resp,value);
    }
 catch (    Throwable e) {
      if (errCtx != null)       errCtx.setError(i,e,method,value,injs[i]);
 else       throw Lang.wrapThrow(e);
    }
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=Lang.getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  if (errCtx == null)   return args;
  for (  Throwable err : errCtx.getErrors()) {
    if (err == null)     continue;
    int lastParam=argTypes.length - 1;
    if (AdaptorErrorContext.class.equals(argTypes[lastParam])) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      args[lastParam]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(err);
  }
  return args;
}","public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[argTypes.length];
  if (args.length != injs.length)   throw new IllegalArgumentException(""String_Node_Str"");
  AdaptorErrorContext errCtx=null;
  if (argTypes.length > 0) {
    if (AdaptorErrorContext.class.isAssignableFrom(argTypes[argTypes.length - 1]))     errCtx=(AdaptorErrorContext)Mirror.me(argTypes[argTypes.length - 1]).born(argTypes.length);
  }
  Object obj;
  try {
    obj=getReferObject(sc,req,resp,pathArgs);
  }
 catch (  Throwable e) {
    if (errCtx != null) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"",e);
      errCtx.setAdaptorError(e,this);
      args[args.length - 1]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(e);
  }
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  for (int i=0; i < args.length; i++) {
    Object value=null;
    if (i < len) {
      value=null == pathArgs ? null : pathArgs[i];
    }
 else {
      value=obj;
    }
    try {
      args[i]=injs[i].get(sc,req,resp,value);
    }
 catch (    Throwable e) {
      if (errCtx != null) {
        log.infof(""String_Node_Str"",method,i,e);
        errCtx.setError(i,e,method,value,injs[i]);
      }
 else       throw Lang.wrapThrow(e);
    }
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=Lang.getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  if (errCtx == null)   return args;
  for (  Throwable err : errCtx.getErrors()) {
    if (err == null)     continue;
    int lastParam=argTypes.length - 1;
    if (AdaptorErrorContext.class.equals(argTypes[lastParam])) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      args[lastParam]=errCtx;
      return args;
    }
    throw Lang.wrapThrow(err);
  }
  return args;
}"
80327,"/** 
 * 设置新的数据源。 <p> 如果有老的数据源需要你在外部手动关闭
 * @param ds 数据源
 */
public void setDataSource(DataSource ds){
  if (null != dataSource)   if (log.isWarnEnabled())   log.warn(""String_Node_Str"");
  dataSource=ds;
  expert=Jdbcs.getExpert(ds);
  pojoMaker=new NutPojoMaker(expert);
  meta=new DatabaseMeta();
  runner.run(dataSource,new ConnCallback(){
    public void invoke(    Connection conn) throws Exception {
      DatabaseMetaData dmd=conn.getMetaData();
      meta.setProductName(dmd.getDatabaseProductName());
      meta.setVersion(dmd.getDatabaseProductVersion());
      log.debug(""String_Node_Str"" + dmd.getDriverVersion());
      log.debug(""String_Node_Str"" + dmd.getDriverName());
    }
  }
);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + meta);
  holder=new EntityHolder(this);
  holder.maker=createEntityMaker();
}","/** 
 * 设置新的数据源。 <p> 如果有老的数据源需要你在外部手动关闭
 * @param ds 数据源
 */
public void setDataSource(DataSource ds){
  if (null != dataSource)   if (log.isWarnEnabled())   log.warn(""String_Node_Str"");
  dataSource=ds;
  expert=Jdbcs.getExpert(ds);
  pojoMaker=new NutPojoMaker(expert);
  meta=new DatabaseMeta();
  runner.run(dataSource,new ConnCallback(){
    public void invoke(    Connection conn) throws Exception {
      DatabaseMetaData dmd=conn.getMetaData();
      meta.setProductName(dmd.getDatabaseProductName());
      meta.setVersion(dmd.getDatabaseProductVersion());
      log.debug(""String_Node_Str"" + dmd.getDriverVersion());
      log.debug(""String_Node_Str"" + dmd.getDriverName());
      if (dmd.getDriverName().contains(""String_Node_Str"") || dmd.getDriverName().contains(""String_Node_Str"")) {
        log.warn(""String_Node_Str"");
        SqlContext.DEFAULT_FETCH_SIZE=Integer.MIN_VALUE;
      }
    }
  }
);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + meta);
  holder=new EntityHolder(this);
  holder.maker=createEntityMaker();
}"
80328,"private void _runSelect(Connection conn,DaoStatement st) throws SQLException {
  Object[][] paramMatrix=st.getParamMatrix();
  int startRow=-1;
  int lastRow=-1;
  if (st.getContext().getResultSetType() == ResultSet.TYPE_SCROLL_INSENSITIVE) {
    Pager pager=st.getContext().getPager();
    if (pager != null) {
      startRow=pager.getOffset();
      lastRow=pager.getOffset() + pager.getPageSize();
    }
  }
  String sql=st.toPreparedStatement();
  ResultSet rs=null;
  Statement stat=null;
  try {
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      if (log.isDebugEnabled())       log.debug(st);
      stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      if (st.getContext().getFetchSize() > 0)       stat.setFetchSize(st.getContext().getFetchSize());
      rs=stat.executeQuery(sql);
    }
 else {
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
      if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      stat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set((PreparedStatement)stat,paramMatrix[0][i],i + 1);
      }
      rs=((PreparedStatement)stat).executeQuery();
    }
    if (startRow > 0)     rs.absolute(startRow);
    st.onAfter(conn,rs);
  }
  finally {
    Daos.safeClose(stat,rs);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}","private void _runSelect(Connection conn,DaoStatement st) throws SQLException {
  Object[][] paramMatrix=st.getParamMatrix();
  int startRow=-1;
  int lastRow=-1;
  if (st.getContext().getResultSetType() == ResultSet.TYPE_SCROLL_INSENSITIVE) {
    Pager pager=st.getContext().getPager();
    if (pager != null) {
      startRow=pager.getOffset();
      lastRow=pager.getOffset() + pager.getPageSize();
    }
  }
  String sql=st.toPreparedStatement();
  ResultSet rs=null;
  Statement stat=null;
  try {
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      if (log.isDebugEnabled())       log.debug(st);
      stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      if (st.getContext().getFetchSize() != 0)       stat.setFetchSize(st.getContext().getFetchSize());
      rs=stat.executeQuery(sql);
    }
 else {
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
      if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      stat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      if (st.getContext().getFetchSize() != 0)       stat.setFetchSize(st.getContext().getFetchSize());
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set((PreparedStatement)stat,paramMatrix[0][i],i + 1);
      }
      rs=((PreparedStatement)stat).executeQuery();
    }
    if (startRow > 0)     rs.absolute(startRow);
    st.onAfter(conn,rs);
  }
  finally {
    Daos.safeClose(stat,rs);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}"
80329,"JdbcExpertConfigFile init(){
  String home=config.get(""String_Node_Str"").toString();
  try {
    home=Disks.normalize(home);
    if (home == null)     home=config.get(""String_Node_Str"").toString();
    long max=((Number)config.get(""String_Node_Str"")).longValue();
    pool=new NutFilePool(home,max);
    pool=new SynchronizedFilePool(pool);
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"" + home,e);
  }
  return this;
}","JdbcExpertConfigFile init(){
  String home=config.get(""String_Node_Str"").toString();
  try {
    home=Disks.normalize(home);
    if (home == null)     home=config.get(""String_Node_Str"").toString();
    long max=config.containsKey(""String_Node_Str"") ? ((Number)config.get(""String_Node_Str"")).longValue() : 2000;
    pool=new NutFilePool(home,max);
    pool=new SynchronizedFilePool(pool);
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"" + home,e);
  }
  return this;
}"
80330,"@Override protected String evalFieldType(MappingField mf){
  if (mf.getCustomDbType() != null)   return mf.getCustomDbType();
  if (mf.getColumnType() == ColType.INT) {
    int width=mf.getWidth();
    if (width <= 0)     return ""String_Node_Str"";
 else     if (width <= 4) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
 else     if (width <= 8) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
  }
  if (mf.getColumnType() == ColType.BINARY) {
    return ""String_Node_Str"";
  }
  return super.evalFieldType(mf);
}","@Override protected String evalFieldType(MappingField mf){
  if (mf.getCustomDbType() != null)   return mf.getCustomDbType();
  if (mf.getColumnType() == ColType.INT) {
    int width=mf.getWidth();
    if (width <= 0) {
      return ""String_Node_Str"";
    }
 else     if (width <= 2) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
 else     if (width <= 4) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
 else     if (width <= 8) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
  }
  if (mf.getColumnType() == ColType.BINARY) {
    return ""String_Node_Str"";
  }
  return super.evalFieldType(mf);
}"
80331,"public Object getValue(Object obj){
  if (ejecting == null)   return null;
  Object val=ejecting.eject(obj);
  if (val == null)   return null;
  if (USE_IGNORE_NUMBER) {
    if (isInt && ((Number)val).intValue() == ignoreNullInt)     return null;
    if (isDouble && ((Number)val).doubleValue() == ignoreNullDouble)     return null;
  }
  return val;
}","public Object getValue(Object obj){
  if (ejecting == null)   return null;
  Object val=ejecting.eject(obj);
  if (val == null)   return null;
  if (hasJsonIgnore) {
    if (isInt && ((Number)val).intValue() == ignoreNullInt)     return null;
    if (isDouble && ((Number)val).doubleValue() == ignoreNullDouble)     return null;
  }
  return val;
}"
80332,"public static JsonEntityField eval(Mirror<?> mirror,Field fld){
  if (fld == null) {
    return null;
  }
  if (fld.getName().startsWith(""String_Node_Str"") && fld.getAnnotation(JsonField.class) == null)   return null;
  JsonField jf=fld.getAnnotation(JsonField.class);
  JsonEntityField jef=new JsonEntityField();
  jef.genericType=Lang.getFieldType(mirror,fld);
  jef.name=Strings.sBlank(null == jf ? null : jf.value(),fld.getName());
  jef.ejecting=mirror.getEjecting(fld.getName());
  jef.injecting=mirror.getInjecting(fld.getName());
  if (Modifier.isTransient(fld.getModifiers()) || (null != jf && jf.ignore())) {
    jef.setIgnore(true);
  }
  Mirror<?> fldMirror=Mirror.me(fld.getType());
  jef.isInt=fldMirror.isInt();
  jef.isDouble=fldMirror.isDouble() || fldMirror.isFloat();
  if (null != jf) {
    jef.setForceString(jf.forceString());
    if (jef.isDouble)     jef.ignoreNullDouble=jf.null_double();
    if (jef.isInt)     jef.ignoreNullInt=jf.null_int();
  }
  return jef;
}","public static JsonEntityField eval(Mirror<?> mirror,Field fld){
  if (fld == null) {
    return null;
  }
  if (fld.getName().startsWith(""String_Node_Str"") && fld.getAnnotation(JsonField.class) == null)   return null;
  JsonField jf=fld.getAnnotation(JsonField.class);
  JsonEntityField jef=new JsonEntityField();
  jef.genericType=Lang.getFieldType(mirror,fld);
  jef.name=Strings.sBlank(null == jf ? null : jf.value(),fld.getName());
  jef.ejecting=mirror.getEjecting(fld.getName());
  jef.injecting=mirror.getInjecting(fld.getName());
  if (Modifier.isTransient(fld.getModifiers()) || (null != jf && jf.ignore())) {
    jef.setIgnore(true);
  }
  if (null != jf) {
    jef.setForceString(jf.forceString());
  }
  JsonIgnore jsonIgnore=fld.getAnnotation(JsonIgnore.class);
  if (jsonIgnore != null) {
    Mirror<?> fldMirror=Mirror.me(fld.getType());
    jef.isInt=fldMirror.isInt();
    jef.isDouble=fldMirror.isDouble() || fldMirror.isFloat();
    jef.hasJsonIgnore=true;
    if (jef.isDouble)     jef.ignoreNullDouble=jsonIgnore.null_double();
    if (jef.isInt)     jef.ignoreNullInt=jsonIgnore.null_int();
  }
  return jef;
}"
80333,"@Test public void test_ignore_numbers(){
  JsonEntityField.setUseIgnoreNumber(true);
  assertEquals(""String_Node_Str"",Json.toJson(new JQ(100,-255,-1),JsonFormat.compact().setQuoteName(false)));
  assertEquals(""String_Node_Str"",Json.toJson(new JQ(150,15.0,-1),JsonFormat.compact().setQuoteName(false)));
  assertEquals(""String_Node_Str"",Json.toJson(new JQ(150,-255,100.5f),JsonFormat.compact().setQuoteName(false)));
}","@Test public void test_ignore_numbers(){
  assertEquals(""String_Node_Str"",Json.toJson(new JQ(100,-255,-1),JsonFormat.compact().setQuoteName(false)));
  assertEquals(""String_Node_Str"",Json.toJson(new JQ(150,15.0,-1),JsonFormat.compact().setQuoteName(false)));
  assertEquals(""String_Node_Str"",Json.toJson(new JQ(150,-255,100.5f),JsonFormat.compact().setQuoteName(false)));
}"
80334,"/** 
 * 当本对象被GC的时候,打印之.<p/> 因为NutDao是线程安全的,用户反复创建NutDao的话,下面的方法将有提示作用
 */
protected void finalize() throws Throwable {
  log.debugf(""String_Node_Str"",getClass().getSimpleName(),_selfId);
  super.finalize();
}","/** 
 * 当本对象被GC的时候,打印之. <p/> 因为NutDao是线程安全的,用户反复创建NutDao的话,下面的方法将有提示作用
 */
protected void finalize() throws Throwable {
  log.debugf(""String_Node_Str"",getClass().getSimpleName(),_selfId);
  super.finalize();
}"
80335,"/** 
 * 较方便的创建一个没有重复的数组，比如： <pre> Pet[] pets = Lang.array(""A"",""B"",""A"");  => [""A"",""B""] Pet[] pets = Lang.array();  => null </pre> 返回的顺序会遵循输入的顺序
 * @param eles 可变参数
 * @return 数组对象
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T[] arrayUniq(T... eles){
  if (null == eles || eles.length == 0)   return null;
  HashSet<T> set=new HashSet<T>(eles.length);
  T[] arr=(T[])Array.newInstance(eles[0].getClass(),set.size());
  int index=0;
  for (int i=0; i < eles.length; i++) {
    if (set.contains(eles[i])) {
      set.remove(eles[i]);
      arr[index++]=eles[i];
    }
  }
  return arr;
}","/** 
 * 较方便的创建一个没有重复的数组，比如： <pre> Pet[] pets = Lang.arrayUniq(""A"",""B"",""A"");  => [""A"",""B""] Pet[] pets = Lang.arrayUniq();  => null </pre> 返回的顺序会遵循输入的顺序
 * @param eles 可变参数
 * @return 数组对象
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T[] arrayUniq(T... eles){
  if (null == eles || eles.length == 0)   return null;
  HashSet<T> set=new HashSet<T>(eles.length);
  for (  T ele : eles) {
    set.add(ele);
  }
  T[] arr=(T[])Array.newInstance(eles[0].getClass(),set.size());
  int index=0;
  for (  T ele : eles) {
    if (set.remove(ele))     Array.set(arr,index++,ele);
  }
  return arr;
}"
80336,"@SuppressWarnings(""String_Node_Str"") public List<Object> getList(String name){
  return getAs(List.class,name);
}","@SuppressWarnings(""String_Node_Str"") public <T>List<T> getList(Class<T> classOfT,String name){
  return (List<T>)getList(name);
}"
80337,List<Object> getList(String name);,"<T>List<T> getList(Class<T> classOfT,String name);"
80338,"@Test public void testEncode(){
  Response response1=Http.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",response1.getEncodeType());
  assertTrue(response1.getContent().indexOf(""String_Node_Str"") > 0);
  Response response2=Http.get(""String_Node_Str"");
  assertTrue(response2.getContent(""String_Node_Str"").indexOf(""String_Node_Str"") > 0);
}","@Test public void testEncode(){
  Response response1=Http.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",response1.getEncodeType().toLowerCase());
  assertTrue(response1.getContent().indexOf(""String_Node_Str"") > 0);
  Response response2=Http.get(""String_Node_Str"");
  assertTrue(response2.getContent(""String_Node_Str"").indexOf(""String_Node_Str"") > 0);
}"
80339,"public int getMinorVersion(){
  throw Lang.noImplement();
}","public int getMinorVersion(){
  return 0;
}"
80340,"public int getMajorVersion(){
  throw Lang.noImplement();
}","public int getMajorVersion(){
  return 1;
}"
80341,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Throwable {
  if (resp.getContentType() == null) {
    if (obj != null && obj instanceof BufferedImage && ""String_Node_Str"".equals(contentType)) {
      contentType=contentTypeMap.get(""String_Node_Str"");
    }
    resp.setContentType(contentType);
  }
  if (obj == null)   return;
  OutputStream out=resp.getOutputStream();
  if (obj instanceof BufferedImage) {
    if (contentType.contains(""String_Node_Str""))     ImageIO.write((BufferedImage)obj,""String_Node_Str"",out);
 else     if (contentType.contains(""String_Node_Str""))     ImageIO.write((BufferedImage)obj,""String_Node_Str"",out);
 else     if (contentType.contains(""String_Node_Str""))     Images.writeJpeg((BufferedImage)obj,out,0.8f);
  }
 else   if (obj instanceof File) {
    File file=(File)obj;
    long fileSz=file.length();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + file.getAbsolutePath());
    if (!file.exists() || file.isDirectory()) {
      log.debug(""String_Node_Str"" + file.getAbsolutePath());
      resp.sendError(404);
      return;
    }
    if (!resp.containsHeader(""String_Node_Str"")) {
      String filename=URLEncoder.encode(file.getName(),Encoding.UTF8);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
    }
    String rangeStr=req.getHeader(""String_Node_Str"");
    if (DISABLE_RANGE_DOWNLOAD || fileSz == 0 || (rangeStr == null || !rangeStr.startsWith(""String_Node_Str"") || rangeStr.length() < ""String_Node_Str"".length())) {
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + fileSz);
      Streams.writeAndClose(out,Streams.fileIn(file));
    }
 else {
      List<RangeRange> rs=new ArrayList<RawView.RangeRange>();
      if (!parseRange(rangeStr,rs,fileSz)) {
        resp.setStatus(416);
        return;
      }
      if (rs.size() != 1) {
        log.info(""String_Node_Str"");
        resp.setStatus(416);
        return;
      }
      long totolSize=0;
      for (      RangeRange rangeRange : rs) {
        totolSize+=(rangeRange.end - rangeRange.start);
      }
      resp.setStatus(206);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + totolSize);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"");
      RangeRange rangeRange=rs.get(0);
      resp.setHeader(""String_Node_Str"",String.format(""String_Node_Str"",rangeRange.start,rangeRange.end - 1,fileSz));
      writeFileRange(file,out,rangeRange);
    }
  }
 else   if (obj instanceof byte[]) {
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + ((byte[])obj).length);
    Streams.writeAndClose(out,(byte[])obj);
  }
 else   if (obj instanceof char[]) {
    Writer writer=resp.getWriter();
    writer.write((char[])obj);
    writer.flush();
  }
 else   if (obj instanceof Reader) {
    Streams.writeAndClose(resp.getWriter(),(Reader)obj);
  }
 else   if (obj instanceof InputStream) {
    Streams.writeAndClose(out,(InputStream)obj);
  }
 else {
    byte[] data=String.valueOf(obj).getBytes(Encoding.UTF8);
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + data.length);
    Streams.writeAndClose(out,data);
  }
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Throwable {
  if (resp.getContentType() == null) {
    if (obj != null && obj instanceof BufferedImage && ""String_Node_Str"".equals(contentType)) {
      contentType=contentTypeMap.get(""String_Node_Str"");
    }
    resp.setContentType(contentType);
  }
  if (obj == null)   return;
  if (obj instanceof BufferedImage) {
    OutputStream out=resp.getOutputStream();
    if (contentType.contains(""String_Node_Str""))     ImageIO.write((BufferedImage)obj,""String_Node_Str"",out);
 else     if (contentType.contains(""String_Node_Str""))     ImageIO.write((BufferedImage)obj,""String_Node_Str"",out);
 else     if (contentType.contains(""String_Node_Str""))     Images.writeJpeg((BufferedImage)obj,out,0.8f);
  }
 else   if (obj instanceof File) {
    File file=(File)obj;
    long fileSz=file.length();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + file.getAbsolutePath());
    if (!file.exists() || file.isDirectory()) {
      log.debug(""String_Node_Str"" + file.getAbsolutePath());
      resp.sendError(404);
      return;
    }
    if (!resp.containsHeader(""String_Node_Str"")) {
      String filename=URLEncoder.encode(file.getName(),Encoding.UTF8);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
    }
    String rangeStr=req.getHeader(""String_Node_Str"");
    OutputStream out=resp.getOutputStream();
    if (DISABLE_RANGE_DOWNLOAD || fileSz == 0 || (rangeStr == null || !rangeStr.startsWith(""String_Node_Str"") || rangeStr.length() < ""String_Node_Str"".length())) {
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + fileSz);
      Streams.writeAndClose(out,Streams.fileIn(file));
    }
 else {
      List<RangeRange> rs=new ArrayList<RawView.RangeRange>();
      if (!parseRange(rangeStr,rs,fileSz)) {
        resp.setStatus(416);
        return;
      }
      if (rs.size() != 1) {
        log.info(""String_Node_Str"");
        resp.setStatus(416);
        return;
      }
      long totolSize=0;
      for (      RangeRange rangeRange : rs) {
        totolSize+=(rangeRange.end - rangeRange.start);
      }
      resp.setStatus(206);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + totolSize);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"");
      RangeRange rangeRange=rs.get(0);
      resp.setHeader(""String_Node_Str"",String.format(""String_Node_Str"",rangeRange.start,rangeRange.end - 1,fileSz));
      writeFileRange(file,out,rangeRange);
    }
  }
 else   if (obj instanceof byte[]) {
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + ((byte[])obj).length);
    OutputStream out=resp.getOutputStream();
    Streams.writeAndClose(out,(byte[])obj);
  }
 else   if (obj instanceof char[]) {
    Writer writer=resp.getWriter();
    writer.write((char[])obj);
    writer.flush();
  }
 else   if (obj instanceof Reader) {
    Streams.writeAndClose(resp.getWriter(),(Reader)obj);
  }
 else   if (obj instanceof InputStream) {
    OutputStream out=resp.getOutputStream();
    Streams.writeAndClose(out,(InputStream)obj);
  }
 else {
    byte[] data=String.valueOf(obj).getBytes(Encoding.UTF8);
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + data.length);
    OutputStream out=resp.getOutputStream();
    Streams.writeAndClose(out,data);
  }
}"
80342,"public Object getValue(Object obj){
  if (ejecting == null)   return null;
  return ejecting.eject(obj);
}","public Object getValue(Object obj){
  if (ejecting == null)   return null;
  Object val=ejecting.eject(obj);
  if (val == null)   return null;
  if (USE_IGNORE_NUMBER) {
    if (isInt && ((Number)val).intValue() == ignoreNullInt)     return null;
    if (isDouble && ((Number)val).doubleValue() == ignoreNullDouble)     return null;
  }
  return val;
}"
80343,"public static JsonEntityField eval(Mirror<?> mirror,Field fld){
  if (fld == null) {
    return null;
  }
  if (fld.getName().startsWith(""String_Node_Str"") && fld.getAnnotation(JsonField.class) == null)   return null;
  JsonField jf=fld.getAnnotation(JsonField.class);
  JsonEntityField jef=new JsonEntityField();
  jef.genericType=Lang.getFieldType(mirror,fld);
  jef.name=Strings.sBlank(null == jf ? null : jf.value(),fld.getName());
  jef.ejecting=mirror.getEjecting(fld.getName());
  jef.injecting=mirror.getInjecting(fld.getName());
  if (Modifier.isTransient(fld.getModifiers()) || (null != jf && jf.ignore())) {
    jef.setIgnore(true);
  }
  if (null != jf)   jef.setForceString(jf.forceString());
  return jef;
}","public static JsonEntityField eval(Mirror<?> mirror,Field fld){
  if (fld == null) {
    return null;
  }
  if (fld.getName().startsWith(""String_Node_Str"") && fld.getAnnotation(JsonField.class) == null)   return null;
  JsonField jf=fld.getAnnotation(JsonField.class);
  JsonEntityField jef=new JsonEntityField();
  jef.genericType=Lang.getFieldType(mirror,fld);
  jef.name=Strings.sBlank(null == jf ? null : jf.value(),fld.getName());
  jef.ejecting=mirror.getEjecting(fld.getName());
  jef.injecting=mirror.getInjecting(fld.getName());
  if (Modifier.isTransient(fld.getModifiers()) || (null != jf && jf.ignore())) {
    jef.setIgnore(true);
  }
  Mirror<?> fldMirror=Mirror.me(fld.getType());
  jef.isInt=fldMirror.isInt();
  jef.isDouble=fldMirror.isDouble() || fldMirror.isFloat();
  if (null != jf) {
    jef.setForceString(jf.forceString());
    if (jef.isDouble)     jef.ignoreNullDouble=jf.null_double();
    if (jef.isInt)     jef.ignoreNullInt=jf.null_int();
  }
  return jef;
}"
80344,"/** 
 * 获取一个 Json 实体
 */
public static JsonEntity getEntity(Mirror<?> mirror){
  JsonEntity je=entities.get(mirror.getTypeId());
  if (null == je) {
    je=new JsonEntity(mirror);
    entities.put(mirror.getTypeId(),je);
  }
  return je;
}","/** 
 * 获取一个 Json 实体
 */
public static JsonEntity getEntity(Mirror<?> mirror){
  JsonEntity je=entities.get(mirror.getType());
  if (null == je) {
    je=new JsonEntity(mirror);
    entities.put(mirror.getType(),je);
  }
  return je;
}"
80345,"/** 
 * 获取一个 Json 实体
 */
public static JsonEntity getEntity(Mirror<?> mirror){
  JsonEntity je=entities.get(mirror.getType());
  if (null == je) {
    je=new JsonEntity(mirror);
    entities.put(mirror.getType(),je);
  }
  return je;
}","/** 
 * 获取一个 Json 实体
 */
public static JsonEntity getEntity(Mirror<?> mirror){
  JsonEntity je=entities.get(mirror.getTypeId());
  if (null == je) {
    je=new JsonEntity(mirror);
    entities.put(mirror.getTypeId(),je);
  }
  return je;
}"
80346,"/** 
 * @return 本类型的唯一标识名称
 */
public String getTypeId(){
  if (null == _type_id) {
    if (null != type && type instanceof ParameterizedType) {
      ParameterizedType pmType=(ParameterizedType)type;
      List<Type> list=new ArrayList<Type>(pmType.getActualTypeArguments().length);
      for (      Type pmA : pmType.getActualTypeArguments()) {
        list.add(pmA);
      }
      _type_id=String.format(""String_Node_Str"",klass.getName(),Lang.concat(""String_Node_Str"",list));
    }
 else {
      _type_id=klass.getName();
    }
  }
  return _type_id;
}","/** 
 * @return 本类型的唯一标识名称
 */
public String getTypeId(){
  if (null == _type_id) {
    if (null != type && type instanceof ParameterizedType) {
      ParameterizedType pmType=(ParameterizedType)type;
      List<Type> list=new ArrayList<Type>(pmType.getActualTypeArguments().length);
      for (      Type pmA : pmType.getActualTypeArguments()) {
        list.add(pmA);
      }
      _type_id=String.format(""String_Node_Str"",klass.getName(),Lang.concat(""String_Node_Str"",list));
    }
 else {
      _type_id=klass.getName();
    }
    _type_id+=""String_Node_Str"" + klass.getClassLoader();
  }
  return _type_id;
}"
80347,"protected String _fmtcolnm(Entity<?> en,String name){
  if (null == en && null != pojo)   en=pojo.getEntity();
  if (null != en) {
    MappingField mf=en.getField(name);
    if (null != mf)     return mf.getColumnName();
  }
  return name;
}","protected String _fmtcolnm(Entity<?> en,String name){
  if (null == en && null != pojo)   en=pojo.getEntity();
  if (null != en) {
    MappingField mf=en.getField(name);
    if (null != mf)     return mf.getColumnName();
  }
  return name.replaceAll(""String_Node_Str"",""String_Node_Str"");
}"
80348,"/** 
 * 这是最后的大招了,查一下形参的名字,作为@Param(""形参名"")进行处理
 */
protected ParamInjector paramNameInject(Method method,int index){
  List<String> names=MethodParamNamesScaner.getParamNames(method);
  if (names != null)   return new NameInjector(names.get(index),method.getParameterTypes()[index],null);
 else   if (log.isInfoEnabled())   log.infof(""String_Node_Str"",index,method);
  return new PathArgInjector(method.getParameterTypes()[index]);
}","/** 
 * 这是最后的大招了,查一下形参的名字,作为@Param(""形参名"")进行处理
 */
protected ParamInjector paramNameInject(Method method,int index){
  List<String> names=MethodParamNamesScaner.getParamNames(method);
  if (names != null)   return new NameInjector(names.get(index),null,method.getParameterTypes()[index],null);
 else   if (log.isInfoEnabled())   log.infof(""String_Node_Str"",index,method);
  return new PathArgInjector(method.getParameterTypes()[index]);
}"
80349,"protected ParamInjector evalInjectorBy(Type type,Param param){
  Class<?> clazz=Lang.getTypeClass(type);
  if (clazz == null) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"",type,param);
    return null;
  }
  Type[] paramTypes=null;
  if (type instanceof ParameterizedType)   paramTypes=((ParameterizedType)type).getActualTypeArguments();
  if (null == param)   return null;
  String pm=param.value();
  if (""String_Node_Str"".equals(pm)) {
    if (clazz.isAssignableFrom(Map.class))     return new MapPairInjector();
    return new ObjectPairInjector(null,type);
  }
 else   if (pm.startsWith(""String_Node_Str"") && pm.length() > 2) {
    return new ObjectNavlPairInjector(pm.substring(2),type);
  }
 else   if (clazz.isArray())   return new ArrayInjector(pm,clazz,paramTypes);
  return new NameInjector(pm,clazz,paramTypes);
}","protected ParamInjector evalInjectorBy(Type type,Param param){
  Class<?> clazz=Lang.getTypeClass(type);
  if (clazz == null) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"",type,param);
    return null;
  }
  Type[] paramTypes=null;
  if (type instanceof ParameterizedType)   paramTypes=((ParameterizedType)type).getActualTypeArguments();
  if (null == param)   return null;
  String pm=param.value();
  String datefmt=param.dfmt();
  if (""String_Node_Str"".equals(pm)) {
    if (clazz.isAssignableFrom(Map.class))     return new MapPairInjector();
    return new ObjectPairInjector(null,type);
  }
 else   if (pm.startsWith(""String_Node_Str"") && pm.length() > 2) {
    return new ObjectNavlPairInjector(pm.substring(2),type);
  }
 else   if (clazz.isArray())   return new ArrayInjector(pm,clazz,paramTypes);
  return new NameInjector(pm,datefmt,clazz,paramTypes);
}"
80350,"/** 
 * 构造参数转换器
 */
public static ParamConvertor makeParamConvertor(Class<?> type){
  if (type.isArray())   return new ArrayParamConvertor(type.getComponentType());
  Mirror<?> mirror=Mirror.me(type);
  if (mirror.isDateTimeLike()) {
    return new DateParamConvertor(type);
  }
  return new StringParamConvertor();
}","/** 
 * 构造参数转换器
 * @param type 要转换的目标类型
 * @param datefmt 如果目标类型是 DateTime 类似的类型，可以声明一个特殊转换格式，<br> 如果为 null 表示用 Times.D 函数自动猜测
 */
public static ParamConvertor makeParamConvertor(Class<?> type,String datefmt){
  if (type.isArray())   return new ArrayParamConvertor(type.getComponentType());
  Mirror<?> mirror=Mirror.me(type);
  if (mirror.isDateTimeLike()) {
    return new DateParamConvertor(type,datefmt);
  }
  return new StringParamConvertor();
}"
80351,"public ArrayParamConvertor(Class<?> eleType){
  this.eleType=eleType;
  this.convertor=Params.makeParamConvertor(eleType);
}","public ArrayParamConvertor(Class<?> eleType){
  this.eleType=eleType;
  this.convertor=Params.makeParamConvertor(eleType,null);
}"
80352,"public DateParamConvertor(Class<?> type){
  this.type=type;
}","public DateParamConvertor(Class<?> type,String datefmt){
  this.type=type;
  if (Strings.isBlank(datefmt)) {
    dfmt=null;
  }
 else {
    dfmt=new SimpleDateFormat(datefmt);
  }
}"
80353,"public Object convert(String[] ss){
  if (null == ss || ss.length == 0)   return null;
  if (Strings.isBlank(ss[0]))   return null;
  return Castors.me().cast(ss[0],String.class,type);
}","public Object convert(String[] ss){
  if (null == ss || ss.length == 0)   return null;
  if (Strings.isBlank(ss[0]))   return null;
  if (null != dfmt) {
    Date o=Times.parseq(dfmt,ss[0]);
    return Castors.me().castTo(o,type);
  }
  return Castors.me().cast(ss[0],String.class,type);
}"
80354,"public ArrayInjector(String name,Class<?> type,Type[] paramTypes){
  super(name,type,paramTypes);
}","public ArrayInjector(String name,Class<?> type,Type[] paramTypes){
  super(name,null,type,paramTypes);
}"
80355,"public Object fromReqParam(HttpServletRequest req){
  String[] params=req.getParameterValues(name);
  return Castors.me().castTo(params,type);
}","public Object fromReqParam(HttpServletRequest req){
  String[] params=req.getParameterValues(name);
  if (null != dfmt && params != null && params.length > 0) {
    Object o=Times.parseq(dfmt,params[0]);
    return Castors.me().castTo(o,type);
  }
  return Castors.me().castTo(params,type);
}"
80356,"public NameInjector(String name,Class<?> type,Type[] paramTypes){
  if (null == name)   throw Lang.makeThrow(""String_Node_Str"",type.getName());
  this.name=name;
  this.type=type;
  this.paramTypes=paramTypes;
}","public NameInjector(String name,String datefmt,Class<?> type,Type[] paramTypes){
  if (null == name)   throw Lang.makeThrow(""String_Node_Str"",type.getName());
  this.name=name;
  if (Strings.isBlank(datefmt) || !Mirror.me(type).isDateTimeLike()) {
    dfmt=null;
  }
 else {
    dfmt=new SimpleDateFormat(datefmt);
  }
  this.type=type;
  this.paramTypes=paramTypes;
}"
80357,"public ObjectPairInjector(String prefix,Type type){
  prefix=Strings.isBlank(prefix) ? ""String_Node_Str"" : Strings.trim(prefix);
  this.mirror=Mirror.me(type);
  fields=mirror.getFields();
  this.injs=new Injecting[fields.length];
  this.names=new String[fields.length];
  this.converters=new ParamConvertor[fields.length];
  for (int i=0; i < fields.length; i++) {
    Field f=fields[i];
    this.injs[i]=mirror.getInjecting(f.getName());
    Param param=f.getAnnotation(Param.class);
    String nm=null == param ? f.getName() : param.value();
    this.names[i]=prefix + nm;
    this.converters[i]=Params.makeParamConvertor(f.getType());
  }
}","public ObjectPairInjector(String prefix,Type type){
  prefix=Strings.isBlank(prefix) ? ""String_Node_Str"" : Strings.trim(prefix);
  this.mirror=Mirror.me(type);
  fields=mirror.getFields();
  this.injs=new Injecting[fields.length];
  this.names=new String[fields.length];
  this.converters=new ParamConvertor[fields.length];
  for (int i=0; i < fields.length; i++) {
    Field f=fields[i];
    this.injs[i]=mirror.getInjecting(f.getName());
    Param param=f.getAnnotation(Param.class);
    String nm=null == param ? f.getName() : param.value();
    String datefmt=null == param ? null : param.dfmt();
    this.names[i]=prefix + nm;
    this.converters[i]=Params.makeParamConvertor(f.getType(),datefmt);
  }
}"
80358,"public MapItemInjector(String name,Class<?> type,Type[] paramTypes){
  super(name,type,paramTypes);
}","public MapItemInjector(String name,Class<?> type,Type[] paramTypes){
  super(name,null,type,paramTypes);
}"
80359,"@SuppressWarnings({""String_Node_Str""}) private static <T>T inj(String name,Class<T> type,HttpServletRequest req){
  return (T)new NameInjector(name,type,null).get(null,req,null,null);
}","@SuppressWarnings({""String_Node_Str""}) private static <T>T inj(String name,Class<T> type,HttpServletRequest req){
  NameInjector nminj=new NameInjector(name,null,type,null);
  return (T)nminj.get(null,req,null,null);
}"
80360,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void init(){
  List<LinkField> lfs=new ArrayList<LinkField>();
  lfs.addAll(ones.getAll());
  lfs.addAll(manys.getAll());
  lfs.addAll(manymanys.getAll());
  if (lfs.isEmpty())   return;
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + type);
  Mirror<T> mirror=Mirror.me(type);
  List<InterceptorPair> interceptorPairs=new ArrayList<InterceptorPair>();
  for (  LinkField lf : lfs) {
    String fieldName=lf.getName();
    try {
      Method setter=mirror.getSetter(mirror.getField(fieldName));
      LazyMethodInterceptor lmi=new LazyMethodInterceptor(setter,fieldName);
      interceptorPairs.add(new InterceptorPair(lmi,MethodMatcherFactory.matcher(""String_Node_Str"" + Strings.capitalize(fieldName) + ""String_Node_Str"")));
    }
 catch (    Throwable e) {
      if (log.isWarnEnabled())       log.warn(""String_Node_Str"",e);
    }
  }
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  Class lazyClass=agent.define(cd,type);
  BornContext<T> bc=Borns.evalByArgTypes(type,ResultSet.class);
  if (null == bc)   this.bornByDefault=Mirror.me(lazyClass).getBorningByArgTypes();
 else   this.bornByRS=bc.getBorning();
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void init(){
  List<LinkField> lfs=new ArrayList<LinkField>();
  lfs.addAll(ones.getAll());
  lfs.addAll(manys.getAll());
  lfs.addAll(manymanys.getAll());
  if (lfs.isEmpty())   return;
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + type);
  Mirror<T> mirror=Mirror.me(type);
  List<InterceptorPair> interceptorPairs=new ArrayList<InterceptorPair>();
  for (  LinkField lf : lfs) {
    String fieldName=lf.getName();
    try {
      Method setter=mirror.getSetter(mirror.getField(fieldName));
      LazyMethodInterceptor lmi=new LazyMethodInterceptor(setter,fieldName);
      interceptorPairs.add(new InterceptorPair(lmi,MethodMatcherFactory.matcher(""String_Node_Str"" + Strings.upperFirst(fieldName) + ""String_Node_Str"")));
    }
 catch (    Throwable e) {
      if (log.isWarnEnabled())       log.warn(""String_Node_Str"",e);
    }
  }
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  Class lazyClass=agent.define(cd,type);
  BornContext<T> bc=Borns.evalByArgTypes(type,ResultSet.class);
  if (null == bc)   this.bornByDefault=Mirror.me(lazyClass).getBorningByArgTypes();
 else   this.bornByRS=bc.getBorning();
}"
80361,"public static String post(String url,Map<String,Object> params,int timeout){
  return Sender.create(Request.create(url,METHOD.POST,params,null)).setTimeout(timeout).send().getContent();
}","public static String post(String url,Map<String,Object> params,String inenc,String reenc){
  return Sender.create(Request.create(url,METHOD.POST,params,null).setEnc(inenc)).send().getContent(reenc);
}"
80362,"public InputStream getInputStream(){
  if (inputStream != null) {
    return inputStream;
  }
 else {
    if (null == data) {
      return new ByteArrayInputStream(Strings.getBytesUTF8(getURLEncodedParams()));
    }
    return new ByteArrayInputStream(data);
  }
}","public InputStream getInputStream(){
  if (inputStream != null) {
    return inputStream;
  }
 else {
    if (null == data) {
      if (enc != null)       try {
        return new ByteArrayInputStream(getURLEncodedParams().getBytes(enc));
      }
 catch (      UnsupportedEncodingException e) {
        throw Lang.wrapThrow(e);
      }
      return new ByteArrayInputStream(Strings.getBytesUTF8(getURLEncodedParams()));
    }
    return new ByteArrayInputStream(data);
  }
}"
80363,"/** 
 * 优先通过 getter 获取字段值，如果没有，则直接获取字段值
 * @param obj 对象
 * @param name 字段名
 * @return 字段值
 * @throws FailToGetValueException 既没发现 getter，又没有字段
 */
public Object getValue(Object obj,String name) throws FailToGetValueException {
  try {
    return this.getGetter(name).invoke(obj);
  }
 catch (  Exception e) {
    try {
      return getValue(obj,getField(name));
    }
 catch (    NoSuchFieldException e1) {
      throw makeGetValueException(obj.getClass(),name,e);
    }
  }
}","/** 
 * 优先通过 getter 获取字段值，如果没有，则直接获取字段值
 * @param obj 对象
 * @param name 字段名
 * @return 字段值
 * @throws FailToGetValueException 既没发现 getter，又没有字段
 */
public Object getValue(Object obj,String name) throws FailToGetValueException {
  try {
    return this.getGetter(name).invoke(obj);
  }
 catch (  Exception e) {
    try {
      return getValue(obj,getField(name));
    }
 catch (    NoSuchFieldException e1) {
      if (obj != null && obj.getClass().isArray() && ""String_Node_Str"".equals(name)) {
        return Lang.length(obj);
      }
      throw makeGetValueException(obj.getClass(),name,e);
    }
  }
}"
80364,"@Override public void init(NutConfig config,ActionInfo ai) throws Throwable {
  view=evalView(config,ai,ai.getOkView());
}","@Override public void init(NutConfig config,ActionInfo ai) throws Throwable {
  if (""String_Node_Str"".equals(ai.getOkView()) && String.class.equals(ai.getMethod().getReturnType())) {
    log.warn(""String_Node_Str"" + Lang.simpleMetodDesc(ai.getMethod()));
  }
  view=evalView(config,ai,ai.getOkView());
}"
80365,"public static View evalView(NutConfig config,ActionInfo ai,String viewType){
  if (Strings.isBlank(viewType))   return new VoidView();
  String str=viewType;
  int pos=str.indexOf(':');
  String type, value;
  if (pos > 0) {
    type=Strings.trim(str.substring(0,pos).toLowerCase());
    value=Strings.trim(pos >= (str.length() - 1) ? null : str.substring(pos + 1));
  }
 else {
    type=str;
    value=null;
  }
  if (""String_Node_Str"".equals(type) && String.class.equals(ai.getMethod().getReturnType())) {
    log.warn(""String_Node_Str"" + Lang.simpleMetodDesc(ai.getMethod()));
  }
  for (  ViewMaker maker : ai.getViewMakers()) {
    if (maker instanceof ViewMaker2) {
      View view=((ViewMaker2)maker).make(config,ai,type,value);
      if (view != null)       return view;
    }
    View view=maker.make(config.getIoc(),type,value);
    if (null != view)     return view;
  }
  throw Lang.makeThrow(""String_Node_Str"",viewType,str,ai.getMethod());
}","public static View evalView(NutConfig config,ActionInfo ai,String viewType){
  if (Strings.isBlank(viewType))   return new VoidView();
  String str=viewType;
  int pos=str.indexOf(':');
  String type, value;
  if (pos > 0) {
    type=Strings.trim(str.substring(0,pos).toLowerCase());
    value=Strings.trim(pos >= (str.length() - 1) ? null : str.substring(pos + 1));
  }
 else {
    type=str;
    value=null;
  }
  for (  ViewMaker maker : ai.getViewMakers()) {
    if (maker instanceof ViewMaker2) {
      View view=((ViewMaker2)maker).make(config,ai,type,value);
      if (view != null)       return view;
    }
    View view=maker.make(config.getIoc(),type,value);
    if (null != view)     return view;
  }
  throw Lang.makeThrow(""String_Node_Str"",viewType,str,ai.getMethod());
}"
80366,"/** 
 * 回滚事务，执行它前，你必需保证你已经手工开始了一个事务
 * @throws Exception
 */
public static void rollback() throws Exception {
  Integer c=Trans.count.get();
  if (c == null)   c=Integer.valueOf(0);
  Trans._rollback(c);
}","/** 
 * 回滚事务，执行它前，你必需保证你已经手工开始了一个事务
 * @throws Exception
 */
public static void rollback() throws Exception {
  Integer c=Trans.count.get();
  if (c == null)   c=Integer.valueOf(0);
 else   if (c > 0)   c--;
  Trans._rollback(c);
}"
80367,"static void _depose(){
  if (count.get() == 0)   try {
    if (DEBUG)     log.debugf(""String_Node_Str"",trans.get().getId());
    trans.get().close();
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
 finally {
    trans.set(null);
  }
}","static void _depose(){
  if (count.get() == 0)   try {
    if (DEBUG)     log.debugf(""String_Node_Str"",trans.get().getId(),count.get());
    trans.get().close();
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
 finally {
    trans.set(null);
  }
}"
80368,"static void _rollback(Integer num){
  count.set(num);
  if (count.get() == 0) {
    if (DEBUG)     log.debugf(""String_Node_Str"",trans.get().getId());
    trans.get().rollback();
  }
 else {
    if (DEBUG)     log.debugf(""String_Node_Str"",trans.get().getId());
  }
}","static void _rollback(Integer num){
  count.set(num);
  if (count.get() == 0) {
    if (DEBUG)     log.debugf(""String_Node_Str"",trans.get().getId(),num);
    trans.get().rollback();
  }
 else {
    if (DEBUG)     log.debugf(""String_Node_Str"",trans.get().getId(),num);
  }
}"
80369,"public void onAfter(Connection conn,ResultSet rs) throws SQLException {
  Context context=entityField.getEntity().wrapAsContext(getOperatingObject());
  Object value=bin.eval(context);
  entityField.setValue(getOperatingObject(),value);
}","public void onAfter(Connection conn,ResultSet rs) throws SQLException {
  Context context=entityField.getEntity().wrapAsContext(getOperatingObject());
  context.set(""String_Node_Str"",entityField.getColumnName());
  context.set(""String_Node_Str"",entityField.getEntity());
  Object value=bin.eval(context);
  entityField.setValue(getOperatingObject(),value);
}"
80370,"protected List<MappingField> _mfs(Entity<?> en){
  if (null == mfs)   return Pojos.getFieldsForUpdate(_en(en),getFieldMatcher(),refer);
  return mfs;
}","protected List<MappingField> _mfs(Entity<?> en){
  if (null == mfs)   return Pojos.getFieldsForUpdate(_en(en),getFieldMatcher(),refer == null ? pojo.getOperatingObject() : refer);
  return mfs;
}"
80371,"/** 
 * 根据默认时区计算时间字符串的绝对毫秒数
 * @param ds 时间字符串
 * @return 绝对毫秒数
 * @see #ms(String,TimeZone)
 */
public static long ams(String ds){
  return ms(ds,TimeZone.getDefault());
}","/** 
 * 根据字符串得到相对于 ""UTC 1970-01-01 00:00:00"" 的绝对毫秒数。 本函数假想给定的时间字符串是本地时间。所以计算出来结果后，还需要减去时差 支持的时间格式字符串为: <pre> yyyy-MM-dd HH:mm:ss yyyy-MM-dd HH:mm:ss.SSS yy-MM-dd HH:mm:ss; yy-MM-dd HH:mm:ss.SSS; yyyy-MM-dd; yy-MM-dd; HH:mm:ss; HH:mm:ss.SSS; </pre>
 * @param ds 时间字符串
 * @param tz 你给定的时间字符串是属于哪个时区的
 * @return 时间
 */
public static long ams(String ds,TimeZone tz){
  Matcher m=_P_TIME.matcher(ds);
  if (m.find()) {
    int yy=_int(m,2,1970);
    int MM=_int(m,4,1);
    int dd=_int(m,6,1);
    int HH=_int(m,9,0);
    int mm=_int(m,11,0);
    int ss=_int(m,13,0);
    int ms=_int(m,16,0);
    long day=(long)D1970(yy,MM,dd);
    long MS=day * 86400000L;
    MS+=(((long)HH) * 3600L + ((long)mm) * 60L + ss) * 1000L;
    MS+=(long)ms;
    long tzOffset;
    if (null == tz) {
      if (!Strings.isBlank(m.group(17))) {
        tzOffset=Long.parseLong(m.group(19)) * 3600000L * (m.group(18).charAt(0) == '-' ? -1 : 1);
      }
 else {
        tzOffset=TimeZone.getDefault().getRawOffset();
      }
    }
 else {
      tzOffset=tz.getRawOffset();
    }
    return MS - tzOffset;
  }
  throw Lang.makeThrow(""String_Node_Str"",ds);
}"
80372,"/** 
 * 执行一个特殊的Chain(事实上普通Chain也能执行,但不建议使用)
 * @see org.nutz.dao.Chain#addSpecial(String,Object)
 */
@SuppressWarnings({""String_Node_Str""}) public static int updateBySpecialChain(Dao dao,Entity en,String tableName,Chain chain,Condition cnd){
  if (en != null)   tableName=en.getTableName();
  if (tableName == null)   throw Lang.makeThrow(DaoException.class,""String_Node_Str"");
  final StringBuilder sql=new StringBuilder(""String_Node_Str"").append(tableName).append(""String_Node_Str"");
  Chain head=chain.head();
  final List<Object> values=new ArrayList<Object>();
  final List<ValueAdaptor> adaptors=new ArrayList<ValueAdaptor>();
  while (head != null) {
    MappingField mf=null;
    if (en != null)     mf=en.getField(head.name());
    String colName=head.name();
    if (mf != null)     colName=mf.getColumnName();
    sql.append(colName).append(""String_Node_Str"");
    if (head.special()) {
      if (""String_Node_Str"".equals(head.value()) || ""String_Node_Str"".equals(head.value())) {
        sql.append(colName);
      }
      sql.append(head.value());
    }
 else {
      sql.append(""String_Node_Str"");
      values.add(head.value());
      ValueAdaptor adaptor=Jdbcs.getAdaptorBy(head.value());
      if (mf != null && mf.getAdaptor() != null)       adaptor=mf.getAdaptor();
      adaptors.add(adaptor);
    }
    sql.append(""String_Node_Str"");
    head=head.next();
    if (head != null)     sql.append(""String_Node_Str"");
  }
  if (cnd != null)   sql.append(""String_Node_Str"").append(cnd.toSql(en));
  if (log.isDebugEnabled())   log.debug(sql);
  final int[] ints=new int[1];
  dao.run(new ConnCallback(){
    public void invoke(    Connection conn) throws Exception {
      PreparedStatement ps=conn.prepareStatement(sql.toString());
      try {
        for (int i=0; i < values.size(); i++)         adaptors.get(i).set(ps,values.get(i),i + 1);
        ints[0]=ps.executeUpdate();
      }
  finally {
        Daos.safeClose(ps);
      }
    }
  }
);
  return ints[0];
}","/** 
 * 执行一个特殊的Chain(事实上普通Chain也能执行,但不建议使用)
 * @see org.nutz.dao.Chain#addSpecial(String,Object)
 */
@SuppressWarnings({""String_Node_Str""}) public static int updateBySpecialChain(Dao dao,Entity en,String tableName,Chain chain,Condition cnd){
  if (en != null)   tableName=en.getTableName();
  if (tableName == null)   throw Lang.makeThrow(DaoException.class,""String_Node_Str"");
  final StringBuilder sql=new StringBuilder(""String_Node_Str"").append(tableName).append(""String_Node_Str"");
  Chain head=chain.head();
  final List<Object> values=new ArrayList<Object>();
  final List<ValueAdaptor> adaptors=new ArrayList<ValueAdaptor>();
  while (head != null) {
    MappingField mf=null;
    if (en != null)     mf=en.getField(head.name());
    String colName=head.name();
    if (mf != null)     colName=mf.getColumnName();
    sql.append(colName).append(""String_Node_Str"");
    if (head.special()) {
      if (head.value() != null && head.value() instanceof String) {
        String str=(String)head.value();
        if (str.length() > 0) {
switch (str.charAt(0)) {
case '+':
case '-':
case '*':
case '/':
case '%':
case '&':
case '^':
case '|':
            sql.append(colName);
          break;
      }
    }
  }
  sql.append(head.value());
}
 else {
  sql.append(""String_Node_Str"");
  values.add(head.value());
  ValueAdaptor adaptor=Jdbcs.getAdaptorBy(head.value());
  if (mf != null && mf.getAdaptor() != null)   adaptor=mf.getAdaptor();
  adaptors.add(adaptor);
}
sql.append(""String_Node_Str"");
head=head.next();
if (head != null) sql.append(""String_Node_Str"");
}
if (cnd != null) sql.append(""String_Node_Str"").append(cnd.toSql(en));
if (log.isDebugEnabled()) log.debug(sql);
final int[] ints=new int[1];
dao.run(new ConnCallback(){
public void invoke(Connection conn) throws Exception {
  PreparedStatement ps=conn.prepareStatement(sql.toString());
  try {
    for (int i=0; i < values.size(); i++)     adaptors.get(i).set(ps,values.get(i),i + 1);
    ints[0]=ps.executeUpdate();
  }
  finally {
    Daos.safeClose(ps);
  }
}
}
);
return ints[0];
}"
80373,"public static ResourceLocation file(File root){
  if (!root.exists())   return new ErrorResourceLocation(root);
  try {
    return new FileSystemResourceLocation(root.getAbsoluteFile().getCanonicalFile());
  }
 catch (  Exception e) {
    return new ErrorResourceLocation(root);
  }
}","public static ResourceLocation file(File root){
  try {
    if (!root.exists())     return new ErrorResourceLocation(root);
    return new FileSystemResourceLocation(root.getAbsoluteFile().getCanonicalFile());
  }
 catch (  Exception e) {
    return new ErrorResourceLocation(root);
  }
}"
80374,"public List<NutResource> loadResource(String regex,String... paths){
  List<NutResource> list=new LinkedList<NutResource>();
  for (  String path : paths) {
    list.addAll(scan(path,regex));
  }
  if (list.size() < 1 && paths.length > 0)   throw Lang.makeThrow(RuntimeException.class,""String_Node_Str"",regex,Castors.me().castToString(paths));
  return new ArrayList<NutResource>((new HashSet<NutResource>(list)));
}","public List<NutResource> loadResource(String regex,String... paths){
  List<NutResource> list=new LinkedList<NutResource>();
  for (  String path : paths) {
    list.addAll(scan(path,regex));
  }
  if (list.size() < 1 && paths.length > 0)   throw Lang.makeThrow(RuntimeException.class,""String_Node_Str"",regex,Castors.me().castToString(paths));
  return new ArrayList<NutResource>((new LinkedHashSet<NutResource>(list)));
}"
80375,"public void setupEntityField(Connection conn,Entity<?> en){
  Statement stat=null;
  ResultSet rs=null;
  ResultSetMetaData rsmd=null;
  try {
    stat=conn.createStatement();
    rs=stat.executeQuery(createResultSetMetaSql(en));
    rsmd=rs.getMetaData();
    for (    MappingField mf : en.getMappingFields()) {
      int ci=Daos.getColumnIndex(rsmd,mf.getColumnName());
      if (ResultSetMetaData.columnNoNulls == rsmd.isNullable(ci))       mf.setAsNotNull();
      if (mf.getTypeMirror().isEnum()) {
        if (Daos.isIntLikeColumn(rsmd,ci)) {
          mf.setColumnType(ColType.INT);
        }
 else {
          mf.setColumnType(ColType.VARCHAR);
        }
      }
    }
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",en.getViewName());
  }
 finally {
    Daos.safeClose(stat,rs);
  }
}","public void setupEntityField(Connection conn,Entity<?> en){
  Statement stat=null;
  ResultSet rs=null;
  ResultSetMetaData rsmd=null;
  try {
    stat=conn.createStatement();
    rs=stat.executeQuery(createResultSetMetaSql(en));
    rsmd=rs.getMetaData();
    for (    MappingField mf : en.getMappingFields()) {
      try {
        int ci=Daos.getColumnIndex(rsmd,mf.getColumnName());
        if (ResultSetMetaData.columnNoNulls == rsmd.isNullable(ci))         mf.setAsNotNull();
        if (mf.getTypeMirror().isEnum()) {
          if (Daos.isIntLikeColumn(rsmd,ci)) {
            mf.setColumnType(ColType.INT);
          }
 else {
            mf.setColumnType(ColType.VARCHAR);
          }
        }
      }
 catch (      Exception e) {
      }
    }
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",en.getViewName());
  }
 finally {
    Daos.safeClose(stat,rs);
  }
}"
80376,"public static int getColumnIndex(ResultSetMetaData meta,String colName) throws SQLException {
  if (meta == null)   return 0;
  int columnCount=meta.getColumnCount();
  for (int i=1; i <= columnCount; i++)   if (meta.getColumnName(i).equalsIgnoreCase(colName))   return i;
  log.infof(""String_Node_Str"",colName);
  throw Lang.makeThrow(SQLException.class,""String_Node_Str"",colName);
}","public static int getColumnIndex(ResultSetMetaData meta,String colName) throws SQLException {
  if (meta == null)   return 0;
  int columnCount=meta.getColumnCount();
  for (int i=1; i <= columnCount; i++)   if (meta.getColumnName(i).equalsIgnoreCase(colName))   return i;
  log.infof(""String_Node_Str"",colName,meta.getTableName(1));
  throw Lang.makeThrow(SQLException.class,""String_Node_Str"",colName);
}"
80377,"/** 
 * 这是最后的大招了,查一下形参的名字,作为@Param(""形参名"")进行处理
 */
protected ParamInjector paramNameInject(Method method,int index){
  List<String> names=MethodParamNamesScaner.getParamNames(method);
  if (names != null)   return new NameInjector(names.get(index),method.getParameterTypes()[index],null);
 else   if (log.isInfoEnabled())   log.info(""String_Node_Str"" + index);
  return new PathArgInjector(method.getParameterTypes()[index]);
}","/** 
 * 这是最后的大招了,查一下形参的名字,作为@Param(""形参名"")进行处理
 */
protected ParamInjector paramNameInject(Method method,int index){
  List<String> names=MethodParamNamesScaner.getParamNames(method);
  if (names != null)   return new NameInjector(names.get(index),method.getParameterTypes()[index],null);
 else   if (log.isInfoEnabled())   log.infof(""String_Node_Str"",index,method);
  return new PathArgInjector(method.getParameterTypes()[index]);
}"
80378,"public void init(Method method){
  this.method=method;
  Class<?>[] argTypes=method.getParameterTypes();
  injs=new ParamInjector[argTypes.length];
  Annotation[][] annss=method.getParameterAnnotations();
  Type[] types=method.getGenericParameterTypes();
  for (int i=0; i < annss.length; i++) {
    Annotation[] anns=annss[i];
    Param param=null;
    Attr attr=null;
    IocObj iocObj=null;
    for (int x=0; x < anns.length; x++)     if (anns[x] instanceof Param) {
      param=(Param)anns[x];
      break;
    }
 else     if (anns[x] instanceof Attr) {
      attr=(Attr)anns[x];
      break;
    }
 else     if (anns[x] instanceof IocObj) {
      iocObj=(IocObj)anns[x];
      break;
    }
    if (null != attr) {
      injs[i]=evalInjectorByAttrScope(attr);
      continue;
    }
    if (null != iocObj) {
      injs[i]=new IocObjInjector(method.getParameterTypes()[i],iocObj.value());
      continue;
    }
    injs[i]=evalInjectorByParamType(argTypes[i]);
    if (null != injs[i])     continue;
    injs[i]=evalInjector(types[i],param);
    if (null == injs[i]) {
      injs[i]=paramNameInject(method,i);
    }
  }
}","public void init(Method method){
  this.method=method;
  Class<?>[] argTypes=method.getParameterTypes();
  injs=new ParamInjector[argTypes.length];
  Annotation[][] annss=method.getParameterAnnotations();
  Type[] types=method.getGenericParameterTypes();
  for (int i=0; i < annss.length; i++) {
    Annotation[] anns=annss[i];
    Param param=null;
    Attr attr=null;
    IocObj iocObj=null;
    ReqHeader reqHeader=null;
    for (int x=0; x < anns.length; x++)     if (anns[x] instanceof Param) {
      param=(Param)anns[x];
      break;
    }
 else     if (anns[x] instanceof Attr) {
      attr=(Attr)anns[x];
      break;
    }
 else     if (anns[x] instanceof IocObj) {
      iocObj=(IocObj)anns[x];
      break;
    }
 else     if (anns[x] instanceof ReqHeader) {
      reqHeader=(ReqHeader)anns[x];
      break;
    }
    if (null != attr) {
      injs[i]=evalInjectorByAttrScope(attr);
      continue;
    }
    if (null != iocObj) {
      injs[i]=new IocObjInjector(method.getParameterTypes()[i],iocObj.value());
      continue;
    }
    if (null != reqHeader) {
      injs[i]=new ReqHeaderInjector(reqHeader.value());
      continue;
    }
    injs[i]=evalInjectorByParamType(argTypes[i]);
    if (null != injs[i])     continue;
    injs[i]=evalInjector(types[i],param);
    if (null == injs[i]) {
      injs[i]=paramNameInject(method,i);
    }
  }
}"
80379,"public View make(Ioc ioc,String type,String value){
  type=type.toLowerCase();
  if (VIEW_JSP.equals(type))   return new JspView(value);
  if (VIEW_JSON.equals(type))   if (Strings.isBlank(value))   return new UTF8JsonView(JsonFormat.compact());
 else   return new UTF8JsonView(Json.fromJson(JsonFormat.class,value));
  if (VIEW_REDIRECT.equals(type) || VIEW_REDIRECT2.equals(type))   return new ServerRedirectView(value);
  if (VIEW_FORWARD.equals(type) || VIEW_FORWARD2.equals(type))   return new ForwardView(value);
  if (VIEW_VOID.equals(type))   return new VoidView();
  if (VIEW_IOC.equals(type))   return ioc.get(View.class,value);
  if (VIEW_HTTP.equals(type))   return new HttpStatusView(Integer.parseInt(value));
  if (VIEW_RAW.equals(type))   return new RawView(value);
  return null;
}","public View make(Ioc ioc,String type,String value){
  type=type.toLowerCase();
  if (VIEW_JSP.equals(type))   return new JspView(value);
  if (VIEW_JSON.equals(type))   if (Strings.isBlank(value))   return UTF8JsonView.COMPACT;
 else {
    if (value.charAt(0) == '{')     return new UTF8JsonView(Json.fromJson(JsonFormat.class,value));
 else     if (""String_Node_Str"".equals(value))     return UTF8JsonView.NICE;
 else     if (""String_Node_Str"".equals(value))     return UTF8JsonView.FORLOOK;
 else     if (""String_Node_Str"".equals(value))     return UTF8JsonView.FULL;
 else     if (""String_Node_Str"".equals(value))     return UTF8JsonView.COMPACT;
 else     throw new IllegalArgumentException(""String_Node_Str"" + value);
  }
  if (VIEW_REDIRECT.equals(type) || VIEW_REDIRECT2.equals(type))   return new ServerRedirectView(value);
  if (VIEW_FORWARD.equals(type) || VIEW_FORWARD2.equals(type))   return new ForwardView(value);
  if (VIEW_VOID.equals(type))   return new VoidView();
  if (VIEW_IOC.equals(type))   return ioc.get(View.class,value);
  if (VIEW_HTTP.equals(type))   return new HttpStatusView(Integer.parseInt(value));
  if (VIEW_RAW.equals(type))   return new RawView(value);
  return null;
}"
80380,"/** 
 * 设置新的数据源。 <p> 如果有老的数据源需要你在外部手动关闭
 * @param ds 数据源
 */
public void setDataSource(DataSource ds){
  if (null != dataSource)   if (log.isWarnEnabled())   log.warn(""String_Node_Str"");
  dataSource=ds;
  expert=Jdbcs.getExpert(ds);
  pojoMaker=new NutPojoMaker(expert);
  meta=new DatabaseMeta();
  runner.run(dataSource,new ConnCallback(){
    public void invoke(    Connection conn) throws Exception {
      DatabaseMetaData dmd=conn.getMetaData();
      meta.setProductName(dmd.getDatabaseProductName());
      meta.setVersion(dmd.getDatabaseProductVersion());
    }
  }
);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + meta);
  holder=new EntityHolder(this);
  holder.maker=createEntityMaker();
}","/** 
 * 设置新的数据源。 <p> 如果有老的数据源需要你在外部手动关闭
 * @param ds 数据源
 */
public void setDataSource(DataSource ds){
  if (null != dataSource)   if (log.isWarnEnabled())   log.warn(""String_Node_Str"");
  dataSource=ds;
  expert=Jdbcs.getExpert(ds);
  pojoMaker=new NutPojoMaker(expert);
  meta=new DatabaseMeta();
  runner.run(dataSource,new ConnCallback(){
    public void invoke(    Connection conn) throws Exception {
      DatabaseMetaData dmd=conn.getMetaData();
      meta.setProductName(dmd.getDatabaseProductName());
      meta.setVersion(dmd.getDatabaseProductVersion());
      log.debug(""String_Node_Str"" + dmd.getDriverVersion());
      log.debug(""String_Node_Str"" + dmd.getDriverName());
    }
  }
);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + meta);
  holder=new EntityHolder(this);
  holder.maker=createEntityMaker();
}"
80381,"/** 
 * 获取当前会话的本地字符串集合的键值；如果当前 HTTP 会话不存在，则返回 null
 * @return 当前会话的本地字符串集合的键值；如果当前 HTTP 会话不存在，则返回 null
 */
public static String getLocalizationKey(){
  HttpSession sess=getHttpSession();
  return null == sess ? null : (String)sess.getAttribute(LOCALE_KEY);
}","/** 
 * 获取当前会话的本地字符串集合的键值；如果当前 HTTP 会话不存在，则返回 null
 * @return 当前会话的本地字符串集合的键值；如果当前 HTTP 会话不存在，则返回 null
 */
public static String getLocalizationKey(){
  HttpSession sess=getHttpSession(false);
  return null == sess ? null : (String)sess.getAttribute(LOCALE_KEY);
}"
80382,"public void process(ActionContext ac) throws Throwable {
  RequestIocContext reqContext=null;
  try {
    if (null != moduleObj) {
      ac.setModule(moduleObj);
    }
 else {
      Ioc ioc=ac.getIoc();
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",injectName,injectName);
      Object obj;
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(ac.getRequest());
        SessionIocContext sessionContext=new SessionIocContext(Mvcs.getHttpSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        Mvcs.setIocContext(myContext);
        obj=((Ioc2)ioc).get(moduleType,injectName,myContext);
      }
 else       obj=ioc.get(moduleType,injectName);
      ac.setModule(obj);
    }
    ac.setMethod(method);
    doNext(ac);
  }
  finally {
    if (reqContext != null)     try {
      reqContext.depose();
    }
 catch (    Throwable e) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"",e);
    }
  }
}","public void process(ActionContext ac) throws Throwable {
  RequestIocContext reqContext=null;
  try {
    if (null != moduleObj) {
      ac.setModule(moduleObj);
    }
 else {
      Ioc ioc=ac.getIoc();
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",injectName,injectName);
      Object obj;
      if (NutSessionListener.isSessionScopeEnable && ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(ac.getRequest());
        SessionIocContext sessionContext=new SessionIocContext(Mvcs.getHttpSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        Mvcs.setIocContext(myContext);
        obj=((Ioc2)ioc).get(moduleType,injectName,myContext);
      }
 else       obj=ioc.get(moduleType,injectName);
      ac.setModule(obj);
    }
    ac.setMethod(method);
    doNext(ac);
  }
  finally {
    if (reqContext != null)     try {
      reqContext.depose();
    }
 catch (    Throwable e) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"",e);
    }
  }
}"
80383,"protected List<Sql> createIndexs(Entity<?> en){
  List<Sql> sqls=new ArrayList<Sql>();
  StringBuilder sb=new StringBuilder();
  List<EntityIndex> indexs=en.getIndexes();
  for (  EntityIndex index : indexs) {
    sb.setLength(0);
    if (index.isUnique())     sb.append(""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    sb.append(index.getName());
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    EntityField field : index.getFields()) {
      if (field instanceof MappingField) {
        MappingField mf=(MappingField)field;
        sb.append(mf.getColumnName()).append(',');
      }
 else {
        throw Lang.makeThrow(DaoException.class,""String_Node_Str"",en.getClass(),field.getName());
      }
    }
    sb.setCharAt(sb.length() - 1,')');
    sqls.add(Sqls.create(sb.toString()));
  }
  return sqls;
}","protected List<Sql> createIndexs(Entity<?> en){
  List<Sql> sqls=new ArrayList<Sql>();
  StringBuilder sb=new StringBuilder();
  List<EntityIndex> indexs=en.getIndexes();
  for (  EntityIndex index : indexs) {
    sb.setLength(0);
    if (index.isUnique())     sb.append(""String_Node_Str"");
 else     sb.append(""String_Node_Str"");
    if (index.getName().contains(""String_Node_Str""))     sb.append(TableName.render(new CharSegment(index.getName())));
 else     sb.append(index.getName());
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    EntityField field : index.getFields()) {
      if (field instanceof MappingField) {
        MappingField mf=(MappingField)field;
        sb.append(mf.getColumnName()).append(',');
      }
 else {
        throw Lang.makeThrow(DaoException.class,""String_Node_Str"",en.getClass(),field.getName());
      }
    }
    sb.setCharAt(sb.length() - 1,')');
    sqls.add(Sqls.create(sb.toString()));
  }
  return sqls;
}"
80384,"public String popFirst(int num){
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < num; i++)   sb.append(popFirst());
  return sb.toString();
}","public LinkedCharArray popFirst(int num){
  for (int i=0; i < num; i++)   popFirst();
  return this;
}"
80385,"@SuppressWarnings(""String_Node_Str"") public <T>Mirror<T> getMirror(Class<T> type,String name){
  if (MethodInterceptor.class.isAssignableFrom(type) || type.getName().endsWith(ClassAgent.CLASSNAME_SUFFIX) || AopConfigration.IOCNAME.equals(name)|| AopConfigration.class.isAssignableFrom(type)) {
    return Mirror.me(type);
  }
  try {
    return (Mirror<T>)Mirror.me(cd.load(type.getName() + ClassAgent.CLASSNAME_SUFFIX));
  }
 catch (  ClassNotFoundException e) {
  }
  if (aopConfigration == null)   if (ioc.has(AopConfigration.IOCNAME))   aopConfigration=ioc.get(AopConfigration.class,AopConfigration.IOCNAME);
 else   aopConfigration=new AnnotationAopConfigration();
  List<InterceptorPair> interceptorPairs=aopConfigration.getInterceptorPairList(ioc,type);
  if (interceptorPairs == null || interceptorPairs.size() < 1) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",type);
    return Mirror.me(type);
  }
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  return Mirror.me(agent.define(cd,type));
}","@SuppressWarnings(""String_Node_Str"") public <T>Mirror<T> getMirror(Class<T> type,String name){
  if (MethodInterceptor.class.isAssignableFrom(type) || type.getName().endsWith(ClassAgent.CLASSNAME_SUFFIX) || AopConfigration.IOCNAME.equals(name)|| AopConfigration.class.isAssignableFrom(type)) {
    return Mirror.me(type);
  }
  try {
    if (cd == null) {
synchronized (lock) {
        if (cd == null) {
          ClassLoader cd=type.getClassLoader();
          if (cd == null) {
            cd=Thread.currentThread().getContextClassLoader();
            if (cd == null)             cd=getClass().getClassLoader();
          }
          log.info(""String_Node_Str"" + cd);
          this.cd=new DefaultClassDefiner(cd);
        }
      }
    }
    return (Mirror<T>)Mirror.me(cd.load(type.getName() + ClassAgent.CLASSNAME_SUFFIX));
  }
 catch (  ClassNotFoundException e) {
  }
  if (aopConfigration == null)   if (ioc.has(AopConfigration.IOCNAME))   aopConfigration=ioc.get(AopConfigration.class,AopConfigration.IOCNAME);
 else   aopConfigration=new AnnotationAopConfigration();
  List<InterceptorPair> interceptorPairs=aopConfigration.getInterceptorPairList(ioc,type);
  if (interceptorPairs == null || interceptorPairs.size() < 1) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",type);
    return Mirror.me(type);
  }
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  return Mirror.me(agent.define(cd,type));
}"
80386,"public DefaultMirrorFactory(Ioc ioc){
  this.ioc=ioc;
  this.cd=new DefaultClassDefiner(getClass().getClassLoader());
}","public DefaultMirrorFactory(Ioc ioc){
  this.ioc=ioc;
}"
80387,"@SuppressWarnings(""String_Node_Str"") IocValue object2value(Object obj){
  IocValue iv=new IocValue();
  if (null == obj) {
    iv.setType(""String_Node_Str"");
    return iv;
  }
 else   if (obj instanceof IocValue) {
    return (IocValue)obj;
  }
 else   if (obj instanceof Map<?,?>) {
    Map<String,Object> map=(Map<String,Object>)obj;
    if (map.size() == 1) {
      Entry<String,?> en=map.entrySet().iterator().next();
      String key=en.getKey();
      if (supportedTypes.contains(key)) {
        iv.setType(key);
        iv.setValue(en.getValue());
        return iv;
      }
    }
    if (isIocObject(map)) {
      iv.setType(IocValue.TYPE_INNER);
      try {
        iv.setValue(map2iobj(map));
      }
 catch (      ObjectLoadException e) {
        throw Lang.wrapThrow(e);
      }
      return iv;
    }
    Map<String,IocValue> newmap=new HashMap<String,IocValue>();
    for (    Entry<String,Object> en : map.entrySet()) {
      IocValue v=object2value(en.getValue());
      newmap.put(en.getKey(),v);
    }
    iv.setType(IocValue.TYPE_NORMAL);
    iv.setValue(newmap);
    return iv;
  }
 else   if (obj.getClass().isArray()) {
    Object[] array=(Object[])obj;
    IocValue[] ivs=new IocValue[array.length];
    for (int i=0; i < ivs.length; i++) {
      ivs[i]=object2value(array[i]);
    }
    iv.setType(IocValue.TYPE_NORMAL);
    iv.setValue(ivs);
    return iv;
  }
 else   if (obj instanceof Collection<?>) {
    try {
      Collection<IocValue> values=(Collection<IocValue>)Mirror.me(obj).born();
      Iterator<?> it=((Collection<?>)obj).iterator();
      while (it.hasNext()) {
        Object o=it.next();
        IocValue v=object2value(o);
        values.add(v);
      }
      iv.setType(IocValue.TYPE_NORMAL);
      iv.setValue(values);
      return iv;
    }
 catch (    Exception e) {
      throw Lang.wrapThrow(e);
    }
  }
  iv.setType(IocValue.TYPE_NORMAL);
  iv.setValue(obj);
  return iv;
}","@SuppressWarnings(""String_Node_Str"") IocValue object2value(Object obj){
  IocValue iv=new IocValue();
  if (null == obj) {
    iv.setType(""String_Node_Str"");
    return iv;
  }
 else   if (obj instanceof IocValue) {
    return (IocValue)obj;
  }
 else   if (obj instanceof Map<?,?>) {
    Map<String,Object> map=(Map<String,Object>)obj;
    if (map.size() == 1) {
      Entry<String,?> en=map.entrySet().iterator().next();
      String key=en.getKey();
      if (supportedTypes.contains(key)) {
        iv.setType(key);
        iv.setValue(en.getValue());
        return iv;
      }
    }
    if (map.size() > 0 && isIocObject(map)) {
      iv.setType(IocValue.TYPE_INNER);
      try {
        iv.setValue(map2iobj(map));
      }
 catch (      ObjectLoadException e) {
        throw Lang.wrapThrow(e);
      }
      return iv;
    }
    Map<String,IocValue> newmap=new HashMap<String,IocValue>();
    for (    Entry<String,Object> en : map.entrySet()) {
      IocValue v=object2value(en.getValue());
      newmap.put(en.getKey(),v);
    }
    iv.setType(IocValue.TYPE_NORMAL);
    iv.setValue(newmap);
    return iv;
  }
 else   if (obj.getClass().isArray()) {
    Object[] array=(Object[])obj;
    IocValue[] ivs=new IocValue[array.length];
    for (int i=0; i < ivs.length; i++) {
      ivs[i]=object2value(array[i]);
    }
    iv.setType(IocValue.TYPE_NORMAL);
    iv.setValue(ivs);
    return iv;
  }
 else   if (obj instanceof Collection<?>) {
    try {
      Collection<IocValue> values=(Collection<IocValue>)Mirror.me(obj).born();
      Iterator<?> it=((Collection<?>)obj).iterator();
      while (it.hasNext()) {
        Object o=it.next();
        IocValue v=object2value(o);
        values.add(v);
      }
      iv.setType(IocValue.TYPE_NORMAL);
      iv.setValue(values);
      return iv;
    }
 catch (    Exception e) {
      throw Lang.wrapThrow(e);
    }
  }
  iv.setType(IocValue.TYPE_NORMAL);
  iv.setValue(obj);
  return iv;
}"
80388,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Throwable {
  if (resp.getContentType() == null)   resp.setContentType(contentType);
  if (obj == null)   return;
  if (obj instanceof File) {
    File file=(File)obj;
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + file.getAbsolutePath());
    if (!file.exists() && file.isDirectory()) {
      resp.sendError(404);
      return;
    }
    file=file.getAbsoluteFile();
    String filename=URLEncoder.encode(file.getName(),Encoding.UTF8);
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + file.length());
    Streams.writeAndClose(resp.getOutputStream(),Streams.fileIn(file));
  }
 else   if (obj instanceof byte[]) {
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + ((byte[])obj).length);
    Streams.writeAndClose(resp.getOutputStream(),(byte[])obj);
  }
 else   if (obj instanceof char[]) {
    Writer writer=resp.getWriter();
    writer.write((char[])obj);
    writer.flush();
  }
 else   if (obj instanceof Reader) {
    Streams.writeAndClose(resp.getWriter(),(Reader)obj);
  }
 else   if (obj instanceof InputStream) {
    Streams.writeAndClose(resp.getOutputStream(),(InputStream)obj);
  }
 else {
    byte[] data=String.valueOf(obj).getBytes(Encoding.UTF8);
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + data.length);
    Streams.writeAndClose(resp.getOutputStream(),data);
  }
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Throwable {
  if (resp.getContentType() == null)   resp.setContentType(contentType);
  if (obj == null)   return;
  if (obj instanceof File) {
    File file=(File)obj;
    long fileSz=file.length();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"" + file.getAbsolutePath());
    if (!file.exists() || file.isDirectory()) {
      resp.sendError(404);
      return;
    }
    String filename=URLEncoder.encode(file.getName(),Encoding.UTF8);
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
    String rangeStr=req.getHeader(""String_Node_Str"");
    if (DISABLE_RANGE_DOWNLOAD || fileSz == 0 || (rangeStr == null || !rangeStr.startsWith(""String_Node_Str"") || rangeStr.length() < ""String_Node_Str"".length())) {
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + fileSz);
      Streams.writeAndClose(resp.getOutputStream(),Streams.fileIn(file));
    }
 else {
      List<RangeRange> rs=new ArrayList<RawView.RangeRange>();
      if (!parseRange(rangeStr,rs,fileSz)) {
        resp.setStatus(416);
        return;
      }
      if (rs.size() != 1) {
        log.info(""String_Node_Str"");
        resp.setStatus(416);
        return;
      }
      long totolSize=0;
      for (      RangeRange rangeRange : rs) {
        totolSize+=(rangeRange.end - rangeRange.start);
      }
      resp.setStatus(206);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"" + totolSize);
      resp.setHeader(""String_Node_Str"",""String_Node_Str"");
      RangeRange rangeRange=rs.get(0);
      resp.setHeader(""String_Node_Str"",String.format(""String_Node_Str"",rangeRange.start,rangeRange.end - 1,fileSz));
      writeFileRange(file,resp.getOutputStream(),rangeRange);
    }
  }
 else   if (obj instanceof byte[]) {
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + ((byte[])obj).length);
    Streams.writeAndClose(resp.getOutputStream(),(byte[])obj);
  }
 else   if (obj instanceof char[]) {
    Writer writer=resp.getWriter();
    writer.write((char[])obj);
    writer.flush();
  }
 else   if (obj instanceof Reader) {
    Streams.writeAndClose(resp.getWriter(),(Reader)obj);
  }
 else   if (obj instanceof InputStream) {
    Streams.writeAndClose(resp.getOutputStream(),(InputStream)obj);
  }
 else {
    byte[] data=String.valueOf(obj).getBytes(Encoding.UTF8);
    resp.setHeader(""String_Node_Str"",""String_Node_Str"" + data.length);
    Streams.writeAndClose(resp.getOutputStream(),data);
  }
}"
80389,"@Override public Timestamp cast(String src,Class<?> toType,String... args){
  if (Strings.isBlank(src))   return null;
  try {
    return new java.sql.Timestamp(((DateFormat)dateTimeFormat.clone()).parse(src).getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}","@Override public Timestamp cast(String src,Class<?> toType,String... args){
  if (Strings.isBlank(src))   return null;
  try {
    Date d;
    if (src.length() > 10) {
      d=((DateFormat)dateTimeFormat.clone()).parse(src);
    }
 else {
      d=((DateFormat)dateFormat.clone()).parse(src);
    }
    return new java.sql.Timestamp(d.getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}"
80390,"public Pager setPageNumber(int pn){
  pageNumber=pn;
  return this;
}","public Pager setPageNumber(int pn){
  if (1 > pn && log.isInfoEnabled())   log.infof(""String_Node_Str"",pn);
  pageNumber=pn;
  return this;
}"
80391,"protected EntityMaker createEntityMaker(){
  return new LazyAnnotationEntityMaker(dataSource,expert,holder,this);
}","protected EntityMaker createEntityMaker(){
  if (cycle)   return new LazyAnnotationEntityMaker(dataSource,expert,holder,this);
  return new LazyAnnotationEntityMaker(dataSource,expert,holder,new NutDao(dataSource));
}"
80392,"@Test public void test_lazy_get(){
  Base base=dao.fetch(Base.class);
  System.out.println(""String_Node_Str"");
  System.out.println(base.getCountry());
}","@Test public void test_lazy_get(){
  Base base=dao.fetch(Base.class);
  System.out.println(""String_Node_Str"");
  System.out.println(base.getCountry());
  System.out.println(base.getPlatoons());
}"
80393,"public Log setTag(String tag){
  return this;
}","public Log setTag(String tag){
  this.tag=tag;
  return this;
}"
80394,"/** 
 * 为当前的 HTTP 请求对象设置一些必要的属性。包括： <ul> <li>本地化子字符串 => ${msg} <li>应用的路径名 => ${base} </ul>
 * @param req HTTP 请求对象
 */
public static void updateRequestAttributes(HttpServletRequest req){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss) {
    Map<String,Object> msgs=null;
    String lKey=Strings.sBlank(Mvcs.getLocalizationKey(),getDefaultLocalizationKey());
    if (!Strings.isBlank(lKey))     msgs=msgss.get(lKey);
    if (null == msgs) {
      if (msgss.size() > 0)       msgs=msgss.values().iterator().next();
    }
    req.setAttribute(MSG,msgs);
  }
  req.setAttribute(""String_Node_Str"",req.getContextPath());
  req.setAttribute(""String_Node_Str"",req);
}","/** 
 * 为当前的 HTTP 请求对象设置一些必要的属性。包括： <ul> <li>本地化子字符串 => ${msg} <li>应用的路径名 => ${base} </ul>
 * @param req HTTP 请求对象
 */
public static void updateRequestAttributes(HttpServletRequest req){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (msgss == null)   msgss=ctx.localizations.values().iterator().next();
  if (null != msgss) {
    Map<String,Object> msgs=null;
    String lKey=Strings.sBlank(Mvcs.getLocalizationKey(),getDefaultLocalizationKey());
    if (!Strings.isBlank(lKey))     msgs=msgss.get(lKey);
    if (null == msgs) {
      if (msgss.size() > 0)       msgs=msgss.values().iterator().next();
    }
    req.setAttribute(MSG,msgs);
  }
  req.setAttribute(""String_Node_Str"",req.getContextPath());
  req.setAttribute(""String_Node_Str"",req);
}"
80395,"public void init(FilterConfig conf) throws ServletException {
  Mvcs.setServletContext(conf.getServletContext());
  this.selfName=conf.getFilterName();
  Mvcs.set(selfName,null,null);
  FilterNutConfig config=new FilterNutConfig(conf);
  Mvcs.setNutConfig(config);
  String skipMode=Strings.sNull(conf.getInitParameter(""String_Node_Str""),""String_Node_Str"").toLowerCase();
  if (!""String_Node_Str"".equals(skipMode)) {
    handler=new ActionHandler(config);
    String regx=Strings.sNull(config.getInitParameter(""String_Node_Str""),IGNORE);
    if (!""String_Node_Str"".equalsIgnoreCase(regx)) {
      ignorePtn=Pattern.compile(regx,Pattern.CASE_INSENSITIVE);
    }
  }
 else   this.skipMode=true;
  sp=config.getSessionProvider();
}","public void init(FilterConfig conf) throws ServletException {
  if (""String_Node_Str"".equals(Strings.sNull(conf.getInitParameter(""String_Node_Str""),""String_Node_Str"").toLowerCase())) {
    proxyFilter=new NutFilter2();
    return;
  }
  Mvcs.setServletContext(conf.getServletContext());
  this.selfName=conf.getFilterName();
  Mvcs.set(selfName,null,null);
  FilterNutConfig config=new FilterNutConfig(conf);
  Mvcs.setNutConfig(config);
  handler=new ActionHandler(config);
  String regx=Strings.sNull(config.getInitParameter(""String_Node_Str""),IGNORE);
  if (!""String_Node_Str"".equalsIgnoreCase(regx)) {
    ignorePtn=Pattern.compile(regx,Pattern.CASE_INSENSITIVE);
  }
  sp=config.getSessionProvider();
}"
80396,"@SuppressWarnings(""String_Node_Str"") public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  String preName=Mvcs.getName();
  Context preContext=Mvcs.resetALL();
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)resp;
  try {
    if (sp != null)     req=sp.filter(request,response,Mvcs.getServletContext());
    if (needRealName && skipMode) {
      Enumeration<String> names=Mvcs.getServletContext().getAttributeNames();
      while (names.hasMoreElements()) {
        String name=(String)names.nextElement();
        if (name.endsWith(""String_Node_Str"")) {
          this.selfName=name.substring(0,name.length() - ""String_Node_Str"".length());
          break;
        }
      }
      needRealName=false;
    }
    Mvcs.set(this.selfName,request,response);
    if (!skipMode) {
      RequestPath path=Mvcs.getRequestPathObject(request);
      if (null == ignorePtn || !ignorePtn.matcher(path.getUrl()).find()) {
        if (handler.handle(request,response))         return;
      }
    }
    Mvcs.updateRequestAttributes((HttpServletRequest)req);
    chain.doFilter(req,resp);
  }
  finally {
    Mvcs.resetALL();
    if (null != (request.getAttribute(""String_Node_Str""))) {
      if (preName != null)       Mvcs.set(preName,request,response);
      if (preContext != null)       Mvcs.ctx.reqThreadLocal.set(preContext);
    }
  }
}","public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  if (proxyFilter != null) {
    proxyFilter.doFilter(req,resp,chain);
    return;
  }
  String preName=Mvcs.getName();
  Context preContext=Mvcs.resetALL();
  HttpServletRequest request=(HttpServletRequest)req;
  HttpServletResponse response=(HttpServletResponse)resp;
  try {
    if (sp != null)     req=sp.filter(request,response,Mvcs.getServletContext());
    Mvcs.set(this.selfName,request,response);
    RequestPath path=Mvcs.getRequestPathObject(request);
    if (null == ignorePtn || !ignorePtn.matcher(path.getUrl()).find()) {
      if (handler.handle(request,response))       return;
    }
    Mvcs.updateRequestAttributes((HttpServletRequest)req);
    chain.doFilter(req,resp);
  }
  finally {
    Mvcs.resetALL();
    if (null != (request.getAttribute(""String_Node_Str""))) {
      if (preName != null)       Mvcs.set(preName,request,response);
      if (preContext != null)       Mvcs.ctx.reqThreadLocal.set(preContext);
    }
  }
}"
80397,"public void destroy(){
  Mvcs.resetALL();
  Mvcs.set(selfName,null,null);
  if (handler != null)   handler.depose();
  Mvcs.setServletContext(null);
  Mvcs.close();
}","public void destroy(){
  if (proxyFilter != null)   return;
  Mvcs.resetALL();
  Mvcs.set(selfName,null,null);
  if (handler != null)   handler.depose();
  Mvcs.setServletContext(null);
  Mvcs.close();
}"
80398,"@Override public int hashCode(){
  return null == name ? ""String_Node_Str"".hashCode() : name.hashCode();
}","public int hashCode(){
  return null == name ? ""String_Node_Str"".hashCode() : name.hashCode();
}"
80399,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj instanceof NutResource)   return 0 == compareTo((NutResource)obj);
  return false;
}","public boolean equals(Object obj){
  if (obj == null)   return false;
  if (this == obj)   return true;
  if (obj instanceof NutResource)   return this.toString().equals(obj.toString());
  return false;
}"
80400,"@Override public String toString(){
  return String.format(""String_Node_Str"",name);
}","public String toString(){
  return String.format(""String_Node_Str"",name);
}"
80401,"public List<NutResource> loadResource(String regex,String... paths){
  List<NutResource> list=new LinkedList<NutResource>();
  for (  String path : paths) {
    list.addAll(scan(path,regex));
  }
  if (list.size() < 1 && paths.length > 0)   throw Lang.makeThrow(RuntimeException.class,""String_Node_Str"",regex,Castors.me().castToString(paths));
  return list;
}","public List<NutResource> loadResource(String regex,String... paths){
  List<NutResource> list=new LinkedList<NutResource>();
  for (  String path : paths) {
    list.addAll(scan(path,regex));
  }
  if (list.size() < 1 && paths.length > 0)   throw Lang.makeThrow(RuntimeException.class,""String_Node_Str"",regex,Castors.me().castToString(paths));
  return new ArrayList<NutResource>((new HashSet<NutResource>(list)));
}"
80402,"public static NutResource makeJarNutResource(final String jarPath,final String entryName,final String base) throws IOException {
  NutResource nutResource=new NutResource(){
    @Override public InputStream getInputStream() throws IOException {
      ZipInputStream zis=makeZipInputStream(jarPath);
      ZipEntry ens=null;
      while (null != (ens=zis.getNextEntry())) {
        if (ens.getName().equals(entryName))         return zis;
      }
      throw Lang.impossible();
    }
  }
;
  if (entryName.equals(base))   nutResource.setName(entryName);
 else   nutResource.setName(entryName.substring(base.length()));
  return nutResource;
}","public static NutResource makeJarNutResource(final String jarPath,final String entryName,final String base) throws IOException {
  NutResource nutResource=new NutResource(){
    public InputStream getInputStream() throws IOException {
      ZipInputStream zis=makeZipInputStream(jarPath);
      ZipEntry ens=null;
      while (null != (ens=zis.getNextEntry())) {
        if (ens.getName().equals(entryName))         return zis;
      }
      throw Lang.impossible();
    }
    public int hashCode(){
      return (jarPath + ""String_Node_Str"" + entryName).hashCode();
    }
  }
;
  if (entryName.equals(base))   nutResource.setName(entryName);
 else   nutResource.setName(entryName.substring(base.length()));
  return nutResource;
}"
80403,"@Override public InputStream getInputStream() throws IOException {
  ZipInputStream zis=makeZipInputStream(jarPath);
  ZipEntry ens=null;
  while (null != (ens=zis.getNextEntry())) {
    if (ens.getName().equals(entryName))     return zis;
  }
  throw Lang.impossible();
}","public InputStream getInputStream() throws IOException {
  ZipInputStream zis=makeZipInputStream(jarPath);
  ZipEntry ens=null;
  while (null != (ens=zis.getNextEntry())) {
    if (ens.getName().equals(entryName))     return zis;
  }
  throw Lang.impossible();
}"
80404,"public FileResource(String base,File file){
  base=Disks.normalize(Disks.getCanonicalPath(base));
  if (base == null)   base=""String_Node_Str"";
 else   if (!base.endsWith(""String_Node_Str""))   base+=""String_Node_Str"";
  this.name=Disks.normalize(Disks.getCanonicalPath(file.getAbsolutePath()));
  this.name=this.name.substring(this.name.indexOf(base) + base.length()).replace('\\','/');
  this.file=file;
}","public FileResource(String base,File file){
  base=Disks.normalize(Disks.getCanonicalPath(base));
  if (base == null)   base=""String_Node_Str"";
 else   if (!base.endsWith(""String_Node_Str""))   base+=""String_Node_Str"";
  this.name=Disks.normalize(Disks.getCanonicalPath(file.getAbsolutePath()));
  this.name=this.name.substring(this.name.indexOf(base) + base.length()).replace('\\','/');
  this.file=file.getAbsoluteFile();
}"
80405,"@Override public InputStream getInputStream() throws IOException {
  return Streams.fileIn(file);
}","public InputStream getInputStream() throws IOException {
  return Streams.fileIn(file);
}"
80406,"public static ResourceLocation file(File root){
  if (!root.exists())   return new ErrorResourceLocation(root);
  try {
    return new FileSystemResourceLocation(root.getAbsoluteFile());
  }
 catch (  Exception e) {
    return new ErrorResourceLocation(root);
  }
}","public static ResourceLocation file(File root){
  if (!root.exists())   return new ErrorResourceLocation(root);
  try {
    return new FileSystemResourceLocation(root.getAbsoluteFile().getCanonicalFile());
  }
 catch (  Exception e) {
    return new ErrorResourceLocation(root);
  }
}"
80407,"private static String makeMessage(Throwable e,Class<?> type,Object[] args){
  StringBuilder sb=new StringBuilder();
  String name=null == type ? ""String_Node_Str"" : type.getName();
  sb.append(""String_Node_Str"").append(name).append('\'');
  if (null != args) {
    sb.append(""String_Node_Str"");
    for (    Object arg : args)     sb.append(""String_Node_Str"").append(arg).append(')');
    sb.append(""String_Node_Str"");
  }
  if (null != e) {
    sb.append(""String_Node_Str"").append(getExceptionMessage(e));
  }
  return sb.toString();
}","private static String makeMessage(Throwable e,Class<?> type,Object[] args){
  StringBuilder sb=new StringBuilder();
  String name=null == type ? ""String_Node_Str"" : type.getName();
  sb.append(""String_Node_Str"").append(name).append('\'');
  if (null != args) {
    sb.append(""String_Node_Str"");
    for (    Object arg : args)     sb.append(""String_Node_Str"").append(arg).append(')');
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
  }
  if (null != e) {
    sb.append(""String_Node_Str"").append(getExceptionMessage(e));
  }
  return sb.toString();
}"
80408,"/** 
 * 根据参数类型数组获取一个对象的构建信息
 * @param < T > 对象类型信息
 * @param type 对象类型
 * @param args 构造参数数组
 * @return 构建信息对象
 */
public static <T>BornContext<T> eval(Class<T> type,Object... args){
  BornContext<T> re;
  if (args.length == 0) {
    re=evalWithoutArgs(type);
  }
 else {
    re=evalWithArgs(type,args);
  }
  return re;
}","/** 
 * 根据参数类型数组获取一个对象的构建信息
 * @param < T > 对象类型信息
 * @param type 对象类型
 * @param args 构造参数数组
 * @return 构建信息对象
 * @throws NullPointerException when args is null
 */
public static <T>BornContext<T> eval(Class<T> type,Object... args){
  BornContext<T> re;
  if (args.length == 0) {
    re=evalWithoutArgs(type);
  }
 else {
    re=evalWithArgs(type,args);
  }
  return re;
}"
80409,"public UrlMapping load(NutConfig config){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",Nutz.version());
    log.infof(""String_Node_Str"",config.getAppName());
  }
  if (log.isDebugEnabled()) {
    Properties sys=System.getProperties();
    log.debug(""String_Node_Str"");
    log.debugf(""String_Node_Str"",Encoding.defaultEncoding());
    log.debugf(""String_Node_Str"",new File(""String_Node_Str"").getAbsolutePath());
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""),sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",config.getServletContext().getServerInfo());
  }
  UrlMapping mapping;
  Stopwatch sw=Stopwatch.begin();
  try {
    Class<?> mainModule=config.getMainModule();
    createContext(config);
    createIoc(config,mainModule);
    mapping=evalUrlMapping(config,mainModule);
    evalLocalization(config,mainModule);
    createSessionProvider(config,mainModule);
    evalSetup(config,mainModule);
  }
 catch (  Exception e) {
    if (log.isErrorEnabled())     log.error(""String_Node_Str"",e);
    throw Lang.wrapThrow(e,LoadingException.class);
  }
  sw.stop();
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",config.getAppName(),sw.getDuration());
  return mapping;
}","public UrlMapping load(NutConfig config){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",Nutz.version());
    log.infof(""String_Node_Str"",config.getAppName());
  }
  if (log.isDebugEnabled()) {
    Properties sys=System.getProperties();
    log.debug(""String_Node_Str"");
    log.debugf(""String_Node_Str"",Encoding.defaultEncoding());
    log.debugf(""String_Node_Str"",new File(""String_Node_Str"").getAbsolutePath());
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""),sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",config.getServletContext().getServerInfo());
    log.debugf(""String_Node_Str"",config.getServletContext().getContextPath());
  }
  UrlMapping mapping;
  Stopwatch sw=Stopwatch.begin();
  try {
    Class<?> mainModule=config.getMainModule();
    createContext(config);
    createIoc(config,mainModule);
    mapping=evalUrlMapping(config,mainModule);
    evalLocalization(config,mainModule);
    createSessionProvider(config,mainModule);
    evalSetup(config,mainModule);
  }
 catch (  Exception e) {
    if (log.isErrorEnabled())     log.error(""String_Node_Str"",e);
    throw Lang.wrapThrow(e,LoadingException.class);
  }
  sw.stop();
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",config.getAppName(),sw.getDuration());
  return mapping;
}"
80410,"/** 
 * 将一组 NutResource 转换成 class 对象
 * @param packagePath 包前缀
 * @param list 列表
 * @return 类对象列表
 */
private static List<Class<?>> rs2class(List<NutResource> list){
  Set<Class<?>> re=new HashSet<Class<?>>(list.size());
  if (!list.isEmpty()) {
    for (    NutResource nr : list) {
      if (!nr.getName().endsWith(""String_Node_Str"") || nr.getName().endsWith(""String_Node_Str"")) {
        continue;
      }
      InputStream in=null;
      try {
        in=nr.getInputStream();
        String className=ClassTools.getClassName(in);
        if (className == null) {
          if (log.isInfoEnabled())           log.infof(""String_Node_Str"",nr);
          continue;
        }
        Class<?> klass=Lang.loadClass(className);
        re.add(klass);
      }
 catch (      ClassNotFoundException e) {
        if (log.isInfoEnabled())         log.infof(""String_Node_Str"",nr,e);
      }
catch (      IOException e) {
        if (log.isInfoEnabled())         log.infof(""String_Node_Str"",nr,e);
      }
 finally {
        Streams.safeClose(in);
      }
    }
  }
  return new ArrayList<Class<?>>(re);
}","/** 
 * 将一组 NutResource 转换成 class 对象
 * @param packagePath 包前缀
 * @param list 列表
 * @return 类对象列表
 */
private static List<Class<?>> rs2class(String pkg,List<NutResource> list){
  Set<Class<?>> re=new HashSet<Class<?>>(list.size());
  if (!list.isEmpty()) {
    for (    NutResource nr : list) {
      if (!nr.getName().endsWith(""String_Node_Str"") || nr.getName().endsWith(""String_Node_Str"")) {
        continue;
      }
      String className=pkg + ""String_Node_Str"" + nr.getName().substring(0,nr.getName().length() - 6).replaceAll(""String_Node_Str"",""String_Node_Str"");
      try {
        Class<?> klass=Lang.loadClass(className);
        re.add(klass);
        continue;
      }
 catch (      Throwable e) {
      }
      InputStream in=null;
      try {
        in=nr.getInputStream();
        className=ClassTools.getClassName(in);
        if (className == null) {
          if (log.isInfoEnabled())           log.infof(""String_Node_Str"",nr);
          continue;
        }
        Class<?> klass=Lang.loadClass(className);
        re.add(klass);
      }
 catch (      ClassNotFoundException e) {
        if (log.isInfoEnabled())         log.infof(""String_Node_Str"",nr,e);
      }
catch (      IOException e) {
        if (log.isInfoEnabled())         log.infof(""String_Node_Str"",nr,e);
      }
 finally {
        Streams.safeClose(in);
      }
    }
  }
  return new ArrayList<Class<?>>(re);
}"
80411,"/** 
 * 搜索给定包下所有的类（递归），并返回所有符合正则式描述的类
 * @param pkg 包名或者包路径
 * @param regex 正则表达式，请注意你需要匹配的名称为 'xxxx.class' 而不仅仅是类名，从而保证选出的对象都是类文件
 */
public List<Class<?>> scanPackage(String pkg,String regex){
  String packagePath=pkg.replace('.','/').replace('\\','/');
  if (!packagePath.endsWith(""String_Node_Str""))   packagePath+=""String_Node_Str"";
  return rs2class(scan(packagePath,regex));
}","/** 
 * 搜索给定包下所有的类（递归），并返回所有符合正则式描述的类
 * @param pkg 包名或者包路径
 * @param regex 正则表达式，请注意你需要匹配的名称为 'xxxx.class' 而不仅仅是类名，从而保证选出的对象都是类文件
 */
public List<Class<?>> scanPackage(String pkg,String regex){
  String packagePath=pkg.replace('.','/').replace('\\','/');
  if (!packagePath.endsWith(""String_Node_Str""))   packagePath+=""String_Node_Str"";
  return rs2class(pkg,scan(packagePath,regex));
}"
80412,"/** 
 * [@|$][a-zA-Z0-9_-.]+ <pre> 48-57    0-9 65-90    A-Z 97-122    a-z 95        _ 45        - 46        . </pre>
 * @param str
 * @return SqlLiteral
 */
SqlLiteral valueOf(String str){
  reset();
  source=str;
  if (null == source)   return this;
  char[] cs=Strings.trim(source).toCharArray();
  StringBuilder sb;
  for (int i=0; i < cs.length; i++) {
    char c=cs[i];
switch (c) {
case '@':
      if (cs[i + 1] == '@') {
        stack.push(c);
        i++;
        break;
      }
    sb=new StringBuilder();
  i=readTokenName(cs,i,sb);
if (sb.length() == 0) {
  stack.push(c);
}
 else {
  paramIndexes.add(sb.toString(),stack.markToken());
}
break;
case '$':
if (cs[i + 1] == '$') {
stack.push(c);
i++;
break;
}
sb=new StringBuilder();
i=readTokenName(cs,i,sb);
if (sb.length() == 0) {
stack.push(c);
}
 else {
varIndexes.add(sb.toString(),stack.markToken());
}
break;
default :
stack.push(c);
}
}
stack.finish();
if (stack.firstEquals(""String_Node_Str"") || stack.firstEquals(""String_Node_Str"")) type=SqlType.SELECT;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.UPDATE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.INSERT;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.DELETE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.CREATE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.DROP;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.TRUNCATE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.ALTER;
 else type=SqlType.OTHER;
return this;
}","/** 
 * [@|$][a-zA-Z0-9_-.]+ <pre> 48-57    0-9 65-90    A-Z 97-122    a-z 95        _ 45        - 46        . </pre>
 * @param str
 * @return SqlLiteral
 */
SqlLiteral valueOf(String str){
  reset();
  source=str;
  if (null == source)   return this;
  char[] cs=Strings.trim(source).toCharArray();
  StringBuilder sb;
  for (int i=0; i < cs.length; i++) {
    char c=cs[i];
switch (c) {
case '@':
      if (cs[i + 1] == '@') {
        stack.push(c);
        i++;
        break;
      }
    sb=new StringBuilder();
  i=readTokenName(cs,i,sb);
if (sb.length() == 0) {
  stack.push(c);
}
 else {
  paramIndexes.add(sb.toString(),stack.markToken());
}
break;
case '$':
if (cs[i + 1] == '$') {
stack.push(c);
i++;
break;
}
sb=new StringBuilder();
i=readTokenName(cs,i,sb);
if (sb.length() == 0) {
stack.push(c);
}
 else {
varIndexes.add(sb.toString(),stack.markToken());
}
break;
default :
stack.push(c);
}
}
stack.finish();
if (stack.firstEquals(""String_Node_Str"") || stack.firstEquals(""String_Node_Str"")) type=SqlType.SELECT;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.UPDATE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.INSERT;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.DELETE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.CREATE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.DROP;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.TRUNCATE;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.ALTER;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.EXEC;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.CALL;
 else if (stack.firstEquals(""String_Node_Str"")) type=SqlType.CALL;
 else type=SqlType.OTHER;
return this;
}"
80413,"public void exec(Connection conn,DaoStatement st){
  Object[][] paramMatrix;
  try {
    st.onBefore(conn);
switch (st.getSqlType()) {
case SELECT:
      _runSelect(conn,st);
    break;
case ALTER:
case TRUNCATE:
case CREATE:
case DROP:
  _runStatement(conn,st);
st.onAfter(conn,null);
break;
case RUN:
st.onAfter(conn,null);
break;
default :
if (st.getSqlType() == SqlType.OTHER && log.isInfoEnabled()) log.info(""String_Node_Str"" + st);
paramMatrix=st.getParamMatrix();
if (null == paramMatrix || paramMatrix.length == 0) {
_runStatement(conn,st);
}
 else {
_runPreparedStatement(conn,st,paramMatrix);
}
st.onAfter(conn,null);
}
}
 catch (SQLException e) {
if (log.isInfoEnabled()) log.debug(""String_Node_Str"",e);
throw new DaoException(format(""String_Node_Str"",st.toString(),st.toPreparedStatement()),e);
}
}","public void exec(Connection conn,DaoStatement st){
  Object[][] paramMatrix;
  try {
    st.onBefore(conn);
switch (st.getSqlType()) {
case SELECT:
      _runSelect(conn,st);
    break;
case ALTER:
case TRUNCATE:
case CREATE:
case DROP:
  _runStatement(conn,st);
st.onAfter(conn,null);
break;
case RUN:
st.onAfter(conn,null);
break;
case CALL:
case EXEC:
_runExec(conn,st);
break;
default :
if (st.getSqlType() == SqlType.OTHER && log.isInfoEnabled()) log.info(""String_Node_Str"" + st);
paramMatrix=st.getParamMatrix();
if (null == paramMatrix || paramMatrix.length == 0) {
_runStatement(conn,st);
}
 else {
_runPreparedStatement(conn,st,paramMatrix);
}
st.onAfter(conn,null);
}
}
 catch (SQLException e) {
if (log.isInfoEnabled()) log.debug(""String_Node_Str"",e);
throw new DaoException(format(""String_Node_Str"",st.toString(),st.toPreparedStatement()),e);
}
}"
80414,"/** 
 * 根据函数参数类型数组的最后一个类型（一定是数组，表示变参），为最后一个变参生成一个空数组
 * @param pts 函数参数类型列表
 * @return 变参空数组
 */
public static Object[] blankArrayArg(Class<?>[] pts){
  return (Object[])Array.newInstance(pts[pts.length - 1].getComponentType(),0);
}","/** 
 * 根据函数参数类型数组的最后一个类型（一定是数组，表示变参），为最后一个变参生成一个空数组
 * @param pts 函数参数类型列表
 * @return 变参空数组
 */
public static Object blankArrayArg(Class<?>[] pts){
  return Array.newInstance(pts[pts.length - 1].getComponentType(),0);
}"
80415,"@Test public void testEncode(){
  Response response1=Http.get(""String_Node_Str"");
  assertTrue(""String_Node_Str"".equals(response1.getEncodeType()));
  assertTrue(response1.getContent().indexOf(""String_Node_Str"") > 0);
  Response response2=Http.get(""String_Node_Str"");
  assertTrue(response2.getContent(""String_Node_Str"").indexOf(""String_Node_Str"") > 0);
}","@Test public void testEncode(){
  Response response1=Http.get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",response1.getEncodeType());
  assertTrue(response1.getContent().indexOf(""String_Node_Str"") > 0);
  Response response2=Http.get(""String_Node_Str"");
  assertTrue(response2.getContent(""String_Node_Str"").indexOf(""String_Node_Str"") > 0);
}"
80416,"protected ResourceLocation makeResourceLocation(URL url){
  try {
    String str=url.toString();
    if (str.endsWith(""String_Node_Str"")) {
      return ResourceLocation.jar(str);
    }
 else     if (str.contains(""String_Node_Str"")) {
      return ResourceLocation.jar(str.substring(0,str.lastIndexOf(""String_Node_Str"") + 3));
    }
 else     if (str.startsWith(""String_Node_Str"")) {
      return ResourceLocation.file(new File(url.getFile()));
    }
 else {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"" + url);
    }
  }
 catch (  Throwable e) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + url,e);
  }
  return new ErrorResourceLocation(url);
}","protected ResourceLocation makeResourceLocation(URL url){
  try {
    String str=url.toString();
    if (str.endsWith(""String_Node_Str"")) {
      return ResourceLocation.jar(str);
    }
 else     if (str.contains(""String_Node_Str"")) {
      if (str.startsWith(""String_Node_Str"")) {
        str=str.substring(""String_Node_Str"".length());
      }
      return ResourceLocation.jar(str.substring(0,str.lastIndexOf(""String_Node_Str"") + 3));
    }
 else     if (str.startsWith(""String_Node_Str"")) {
      return ResourceLocation.file(new File(url.getFile()));
    }
 else {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"" + url);
    }
  }
 catch (  Throwable e) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + url,e);
  }
  return new ErrorResourceLocation(url);
}"
80417,"private void _evalFieldMacro(Entity<?> en,List<MappingInfo> infos){
  for (  MappingInfo info : infos) {
    if (null != info.annPrev) {
      en.addBeforeInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annPrev.els(),info.annPrev.value())));
    }
    if (null != info.annNext && en.addAfterInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annNext.els(),info.annNext.value())))) {
      continue;
    }
 else     if (null != info.annId && info.annId.auto()) {
      if (expert != null && !expert.isSupportAutoIncrement()) {
        throw new DaoException(""String_Node_Str"");
      }
      en.addAfterInsertMacro(expert.fetchPojoId(en,en.getField(info.name)));
    }
  }
}","private void _evalFieldMacro(Entity<?> en,List<MappingInfo> infos){
  for (  MappingInfo info : infos) {
    if (null != info.annPrev) {
      en.addBeforeInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annPrev.els(),info.annPrev.value())));
    }
    if (null != info.annNext && en.addAfterInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annNext.els(),info.annNext.value())))) {
      continue;
    }
 else     if (null != info.annId && info.annId.auto()) {
      if (expert != null && !expert.isSupportAutoIncrement()) {
        log.debug(""String_Node_Str"");
      }
      en.addAfterInsertMacro(expert.fetchPojoId(en,en.getField(info.name)));
    }
  }
}"
80418,"public static Throwable unwrapThrow(Throwable e){
  if (e == null)   return null;
  if (e instanceof InvocationTargetException) {
    InvocationTargetException itE=(InvocationTargetException)e;
    if (itE.getTargetException() != null)     return unwrapThrow(itE.getTargetException());
  }
  if (e.getCause() != null)   return unwrapThrow(e.getCause());
  return e;
}","public static Throwable unwrapThrow(Throwable e){
  if (e == null)   return null;
  if (e instanceof InvocationTargetException) {
    InvocationTargetException itE=(InvocationTargetException)e;
    if (itE.getTargetException() != null)     return unwrapThrow(itE.getTargetException());
  }
  if (e instanceof RuntimeException && e.getCause() != null && e.getMessage() == null)   return unwrapThrow(e.getCause());
  return e;
}"
80419,"public UrlMapping load(NutConfig config){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",Nutz.version());
    log.infof(""String_Node_Str"",config.getAppName());
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
    log.debugf(""String_Node_Str"",Encoding.defaultEncoding());
    log.debugf(""String_Node_Str"",new File(""String_Node_Str"").getAbsolutePath());
    log.debugf(""String_Node_Str"",System.getProperties().get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",System.getProperties().get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",System.getProperties().get(""String_Node_Str""));
  }
  UrlMapping mapping;
  Stopwatch sw=Stopwatch.begin();
  try {
    Class<?> mainModule=config.getMainModule();
    createContext(config);
    createIoc(config,mainModule);
    mapping=evalUrlMapping(config,mainModule);
    evalLocalization(config,mainModule);
    createSessionProvider(config,mainModule);
    evalSetup(config,mainModule);
  }
 catch (  Exception e) {
    if (log.isErrorEnabled())     log.error(""String_Node_Str"",e);
    throw Lang.wrapThrow(e,LoadingException.class);
  }
  sw.stop();
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",config.getAppName(),sw.getDuration());
  return mapping;
}","public UrlMapping load(NutConfig config){
  if (log.isInfoEnabled()) {
    log.infof(""String_Node_Str"",Nutz.version());
    log.infof(""String_Node_Str"",config.getAppName());
  }
  if (log.isDebugEnabled()) {
    Properties sys=System.getProperties();
    log.debug(""String_Node_Str"");
    log.debugf(""String_Node_Str"",Encoding.defaultEncoding());
    log.debugf(""String_Node_Str"",new File(""String_Node_Str"").getAbsolutePath());
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",sys.get(""String_Node_Str""),sys.get(""String_Node_Str""));
    log.debugf(""String_Node_Str"",config.getServletContext().getServerInfo());
  }
  UrlMapping mapping;
  Stopwatch sw=Stopwatch.begin();
  try {
    Class<?> mainModule=config.getMainModule();
    createContext(config);
    createIoc(config,mainModule);
    mapping=evalUrlMapping(config,mainModule);
    evalLocalization(config,mainModule);
    createSessionProvider(config,mainModule);
    evalSetup(config,mainModule);
  }
 catch (  Exception e) {
    if (log.isErrorEnabled())     log.error(""String_Node_Str"",e);
    throw Lang.wrapThrow(e,LoadingException.class);
  }
  sw.stop();
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",config.getAppName(),sw.getDuration());
  return mapping;
}"
80420,"protected IocValue parseX(Element element) throws Throwable {
  IocValue iocValue=new IocValue();
  String type=element.getNodeName();
  if (EVN_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(EVN_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (SYS_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(SYS_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JNDI_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JNDI_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JAVA_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JAVA_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (REFER_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(REFER_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (FILE_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(FILE_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (OBJ_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(REFER_TAG);
    iocValue.setValue(paserBean(element,true));
  }
 else   if (MAP_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserMap(element));
  }
 else   if (LIST_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element));
  }
 else   if (ARRAY_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element).toArray());
  }
 else   if (SET_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    Set<Object> set=new HashSet<Object>();
    set.addAll(paserCollection(element));
    iocValue.setValue(set);
  }
 else {
    iocValue.setType(null);
    if (element.getFirstChild() != null)     iocValue.setValue(element.getFirstChild().getTextContent());
  }
  return iocValue;
}","protected IocValue parseX(Element element) throws Throwable {
  IocValue iocValue=new IocValue();
  String type=element.getNodeName();
  if (EVN_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(EVN_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (SYS_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(SYS_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JNDI_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JNDI_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JAVA_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JAVA_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (REFER_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(REFER_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (FILE_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(FILE_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (APP_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(APP_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (OBJ_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(REFER_TAG);
    iocValue.setValue(paserBean(element,true));
  }
 else   if (MAP_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserMap(element));
  }
 else   if (LIST_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element));
  }
 else   if (ARRAY_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element).toArray());
  }
 else   if (SET_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    Set<Object> set=new HashSet<Object>();
    set.addAll(paserCollection(element));
    iocValue.setValue(set);
  }
 else {
    iocValue.setType(null);
    if (element.getFirstChild() != null)     iocValue.setValue(element.getFirstChild().getTextContent());
  }
  return iocValue;
}"
80421,"public void visit(Object obj,LinkField lnk){
  Object value=lnk.getValue(obj);
  if (value == null) {
    log.infof(""String_Node_Str"",lnk.getLinkType(),lnk.getEntity().getType().getSimpleName(),lnk.getHostField().getName());
    return;
  }
  final Pojo pojo=opt.maker().makeDelete(lnk.getLinkedEntity());
  pojo.setOperatingObject(value);
  pojo.append(Pojos.Items.cndAuto(lnk.getLinkedEntity(),null));
  Lang.each(value,new Each<Object>(){
    public void invoke(    int i,    Object ele,    int length) throws ExitLoop, LoopException {
      pojo.addParamsBy(ele);
    }
  }
);
  opt.add(pojo);
}","public void visit(Object obj,LinkField lnk){
  Object value=lnk.getValue(obj);
  if (value == null || Lang.length(value) == 0) {
    log.infof(""String_Node_Str"",lnk.getLinkType(),lnk.getEntity().getType().getSimpleName(),lnk.getHostField().getName());
    return;
  }
  final Pojo pojo=opt.maker().makeDelete(lnk.getLinkedEntity());
  pojo.setOperatingObject(value);
  pojo.append(Pojos.Items.cndAuto(lnk.getLinkedEntity(),null));
  Lang.each(value,new Each<Object>(){
    public void invoke(    int i,    Object ele,    int length) throws ExitLoop, LoopException {
      pojo.addParamsBy(ele);
    }
  }
);
  opt.add(pojo);
}"
80422,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  dao.execute(createIndexs(en).toArray(new Sql[0]));
  addComment(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    sb.append(makePksName(en));
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  dao.execute(createIndexs(en).toArray(new Sql[0]));
  addComment(dao,en);
  return true;
}"
80423,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isPk() && en.getPks().size() == 1)       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isUnsigned())       sb.append(""String_Node_Str"").append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  List<Sql> sqls=new ArrayList<Sql>();
  sqls.add(Sqls.create(sb.toString()));
  List<MappingField> pks=en.getPks();
  if (pks.size() > 1) {
    StringBuilder pkNames=new StringBuilder();
    StringBuilder pkNames2=new StringBuilder();
    for (    MappingField pk : pks) {
      pkNames.append(pk.getColumnName()).append(',');
      pkNames2.append(pk.getColumnName()).append('_');
    }
    pkNames.setLength(pkNames.length() - 1);
    pkNames2.setLength(pkNames2.length() - 1);
    String sql=String.format(""String_Node_Str"",en.getTableName(),pkNames2,pkNames);
    sqls.add(Sqls.create(sql));
  }
  for (  MappingField mf : en.getMappingFields()) {
    if (!mf.isAutoIncreasement())     continue;
    sqls.add(Sqls.create(gSQL(CSEQ,en.getTableName(),mf.getColumnName())));
    sqls.add(Sqls.create(gSQL(CTRI,en.getTableName(),mf.getColumnName())));
  }
  sqls.addAll(createIndexs(en));
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
  createRelation(dao,en);
  addComment(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isPk() && en.getPks().size() == 1)       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isUnsigned())       sb.append(""String_Node_Str"").append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  List<Sql> sqls=new ArrayList<Sql>();
  sqls.add(Sqls.create(sb.toString()));
  List<MappingField> pks=en.getPks();
  if (pks.size() > 1) {
    StringBuilder pkNames=new StringBuilder();
    for (    MappingField pk : pks) {
      pkNames.append(pk.getColumnName()).append(',');
    }
    pkNames.setLength(pkNames.length() - 1);
    String pkNames2=makePksName(en);
    String sql=String.format(""String_Node_Str"",en.getTableName(),pkNames2,pkNames);
    sqls.add(Sqls.create(sql));
  }
  for (  MappingField mf : en.getMappingFields()) {
    if (!mf.isAutoIncreasement())     continue;
    sqls.add(Sqls.create(gSQL(CSEQ,en.getTableName(),mf.getColumnName())));
    sqls.add(Sqls.create(gSQL(CTRI,en.getTableName(),mf.getColumnName())));
  }
  sqls.addAll(createIndexs(en));
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
  createRelation(dao,en);
  addComment(dao,en);
  return true;
}"
80424,"public String getServerInfo(){
  throw Lang.noImplement();
}","public String getServerInfo(){
  return ""String_Node_Str"";
}"
80425,"@SuppressWarnings(""String_Node_Str"") public JsonActionChainMakerConfiguretion(String... jsonPaths){
  List<NutResource> list=Scans.me().loadResource(""String_Node_Str"",jsonPaths);
  try {
    File defaultChainsFile=Files.findFile(""String_Node_Str"");
    if (defaultChainsFile == null) {
      log.warn(""String_Node_Str"");
      throw new NutRuntimeException(""String_Node_Str"");
    }
    map.putAll(Json.fromJsonFile(Map.class,defaultChainsFile));
    for (    NutResource nr : list)     map.putAll(Json.fromJson(Map.class,nr.getReader()));
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}","@SuppressWarnings(""String_Node_Str"") public JsonActionChainMakerConfiguretion(String... jsonPaths){
  List<NutResource> list=Scans.me().loadResource(""String_Node_Str"",jsonPaths);
  try {
    File defaultChainsFile=Files.findFile(""String_Node_Str"");
    if (defaultChainsFile != null && defaultChainsFile.exists())     map.putAll(Json.fromJsonFile(Map.class,defaultChainsFile));
 else {
      if (!Lang.isAndroid) {
        log.warn(""String_Node_Str"");
        throw new NutRuntimeException(""String_Node_Str"");
      }
      map.putAll(Json.fromJson(Map.class,new InputStreamReader(getClass().getClassLoader().getResourceAsStream(""String_Node_Str""))));
    }
    for (    NutResource nr : list)     map.putAll(Json.fromJson(Map.class,nr.getReader()));
  }
 catch (  IOException e) {
    if (Lang.isAndroid) {
    }
    throw Lang.wrapThrow(e);
  }
}"
80426,"public Object getReferObject(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  try {
    String str=Streams.readAndClose(Streams.utf8r(req.getInputStream()));
    return Json.fromJson(str);
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}","public Object getReferObject(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  try {
    return Json.fromJson(Streams.utf8r(req.getInputStream()));
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}"
80427,"@SuppressWarnings(""String_Node_Str"") public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null == name)   return Castors.me().castTo(refer,Lang.getTypeClass(type));
  Map<String,Object> map=(Map<String,Object>)refer;
  Object theObj=map.get(name);
  if (null == theObj)   return null;
  Class<?> clazz=Lang.getTypeClass(type);
  return Castors.me().castTo(theObj,clazz);
}","@SuppressWarnings(""String_Node_Str"") public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null == name)   return Mapl.maplistToObj(refer,type);
  Map<String,Object> map=(Map<String,Object>)refer;
  Object theObj=map.get(name);
  if (null == theObj)   return null;
  return Mapl.maplistToObj(map,type);
}"
80428,"@Test public void test_deleteWith_many(){
  dao.create(Ask.class,true);
  dao.create(AskReply.class,true);
  Ask ask=new Ask();
  ask.setTemptitle(""String_Node_Str"");
  ask.setTitle(""String_Node_Str"");
  List<AskReply> askReplies=new ArrayList<AskReply>();
  askReplies.add(new AskReply(ask.getAskId()));
  askReplies.add(new AskReply(ask.getAskId()));
  ask.setReplys(askReplies);
  dao.insertWith(ask,""String_Node_Str"");
  dao.deleteWith(ask,""String_Node_Str"");
  assertEquals(0,dao.count(AskReply.class));
}","@Test public void test_deleteWith_many(){
  dao.create(Ask.class,true);
  dao.create(AskReply.class,true);
  Ask ask=new Ask();
  ask.setTemptitle(""String_Node_Str"");
  ask.setTitle(""String_Node_Str"");
  List<AskReply> askReplies=new ArrayList<AskReply>();
  askReplies.add(new AskReply(ask.getAskId()));
  askReplies.add(new AskReply(ask.getAskId()));
  ask.setReplys(askReplies);
  dao.insertWith(ask,""String_Node_Str"");
  ask.setReplys(null);
  dao.deleteWith(ask,""String_Node_Str"");
  assertEquals(2,dao.count(AskReply.class));
  ask=dao.fetchLinks(ask,null);
  dao.deleteWith(ask,""String_Node_Str"");
  assertEquals(0,dao.count(AskReply.class));
}"
80429,"@At({""String_Node_Str"",""String_Node_Str""}) @Fail(""String_Node_Str"") public void errParam(@Param(""String_Node_Str"") long id,AdaptorErrorContext errCtx){
  TestCase.assertNotNull(errCtx);
  TestCase.assertNotNull(errCtx.getErrors()[0]);
}","@At({""String_Node_Str"",""String_Node_Str""}) public void errParam(@Param(""String_Node_Str"") long id,AdaptorErrorContext errCtx){
  TestCase.assertNotNull(errCtx);
  TestCase.assertNotNull(errCtx.getErrors()[0]);
}"
80430,"/** 
 * @return 当前类型是不是接口
 */
public boolean isInterface(){
  return null == klass ? null : klass.isInterface();
}","/** 
 * @return 当前类型是不是接口
 */
public boolean isInterface(){
  return klass.isInterface();
}"
80431,"/** 
 * 子类可以覆盖这个方法，给出自己特殊的后缀
 * @return 后缀
 */
protected String getExt(){
  return ""String_Node_Str"";
}","/** 
 * 子类可以覆盖这个方法，给出自己特殊的后缀,必须小写哦
 * @return 后缀
 */
protected String getExt(){
  return ""String_Node_Str"";
}"
80432,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  String args=""String_Node_Str"";
  if (path != null && path.contains(""String_Node_Str"")) {
    path=path.substring(0,path.indexOf('?'));
    args=path.substring(path.indexOf('?'));
  }
  String ext=getExt();
  if (Strings.isBlank(path)) {
    path=Mvcs.getRequestPath(req);
    path=""String_Node_Str"" + (path.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + Files.renameSuffix(path,ext);
  }
 else   if (path.charAt(0) == '/') {
    if (!path.toLowerCase().endsWith(ext))     path+=ext;
  }
 else {
    path=""String_Node_Str"" + path.replace('.','/') + ext;
  }
  path=path + args;
  RequestDispatcher rd=req.getRequestDispatcher(path);
  if (rd == null)   throw Lang.makeThrow(""String_Node_Str"",path);
  rd.forward(req,resp);
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  String args=""String_Node_Str"";
  if (path != null && path.contains(""String_Node_Str"")) {
    args=path.substring(path.indexOf('?'));
    path=path.substring(0,path.indexOf('?'));
  }
  String ext=getExt();
  if (Strings.isBlank(path)) {
    path=Mvcs.getRequestPath(req);
    path=""String_Node_Str"" + (path.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + Files.renameSuffix(path,ext);
  }
 else   if (path.charAt(0) == '/') {
    if (!path.toLowerCase().endsWith(ext))     path+=ext;
  }
 else {
    path=""String_Node_Str"" + path.replace('.','/') + ext;
  }
  path=path + args;
  RequestDispatcher rd=req.getRequestDispatcher(path);
  if (rd == null)   throw Lang.makeThrow(""String_Node_Str"",path);
  rd.forward(req,resp);
}"
80433,"public void visit(Object obj,LinkField lnk){
  Object value=lnk.getValue(obj);
  final Pojo pojo=opt.maker().makeDelete(lnk.getLinkedEntity());
  pojo.setOperatingObject(value);
  pojo.append(Pojos.Items.cndAuto(lnk.getLinkedEntity(),null));
  Lang.each(value,new Each<Object>(){
    public void invoke(    int i,    Object ele,    int length) throws ExitLoop, LoopException {
      pojo.addParamsBy(ele);
    }
  }
);
  opt.add(pojo);
}","public void visit(Object obj,LinkField lnk){
  Object value=lnk.getValue(obj);
  if (value == null) {
    log.infof(""String_Node_Str"",lnk.getLinkType(),lnk.getEntity().getType().getSimpleName(),lnk.getHostField().getName());
    return;
  }
  final Pojo pojo=opt.maker().makeDelete(lnk.getLinkedEntity());
  pojo.setOperatingObject(value);
  pojo.append(Pojos.Items.cndAuto(lnk.getLinkedEntity(),null));
  Lang.each(value,new Each<Object>(){
    public void invoke(    int i,    Object ele,    int length) throws ExitLoop, LoopException {
      pojo.addParamsBy(ele);
    }
  }
);
  opt.add(pojo);
}"
80434,"public int joinParams(Entity<?> en,Object obj,Object[] params,int off){
  if (def == obj && null != obj) {
    params[off++]=def;
  }
 else {
    en=_en(en);
    if (null != obj && null != mf && mf.getEntity() == en && en.getType().isInstance(obj))     params[off++]=mf.getValue(obj);
 else     if (null != def)     params[off++]=def;
 else     if (null != obj)     params[off++]=Castors.me().castTo(obj,colType);
 else     throw Lang.impossible();
  }
  return off;
}","public int joinParams(Entity<?> en,Object obj,Object[] params,int off){
  if (def == obj && null != obj) {
    params[off++]=def;
  }
 else {
    en=_en(en);
    if (null != obj && null != mf && mf.getEntity() == en && en.getType().isInstance(obj))     params[off++]=mf.getValue(obj);
 else     if (null != def)     params[off++]=def;
 else     if (null != obj) {
      params[off++]=Castors.me().castTo(obj,colType);
    }
 else     throw Lang.impossible();
  }
  return off;
}"
80435,"public Method getCallingMethod(){
  return callingMethod;
}","/** 
 * 正在被调用的Method
 */
public Method getCallingMethod(){
  return callingMethod;
}"
80436,"public Object[] getArgs(){
  return args;
}","/** 
 * 方法调用的参数数组,如果你要改变参数,那么必须保证参数类型与方法参数兼容.
 */
public Object[] getArgs(){
  return args;
}"
80437,"private void _runSelect(Connection conn,DaoStatement st) throws SQLException {
  Object[][] paramMatrix=st.getParamMatrix();
  int startRow=-1;
  int lastRow=-1;
  if (st.getContext().getResultSetType() == ResultSet.TYPE_SCROLL_INSENSITIVE) {
    Pager pager=st.getContext().getPager();
    if (pager != null) {
      startRow=pager.getOffset();
      lastRow=pager.getOffset() + pager.getPageSize();
    }
  }
  String sql=st.toPreparedStatement();
  if (log.isDebugEnabled())   log.debug(sql);
  ResultSet rs=null;
  Statement stat=null;
  try {
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      if (st.getContext().getFetchSize() > 0)       stat.setFetchSize(st.getContext().getFetchSize());
      rs=stat.executeQuery(sql);
    }
 else {
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
 else       if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      stat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set((PreparedStatement)stat,paramMatrix[0][i],i + 1);
      }
      rs=((PreparedStatement)stat).executeQuery();
    }
    if (startRow > 0)     rs.absolute(startRow);
    st.onAfter(conn,rs);
  }
  finally {
    Daos.safeClose(stat,rs);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}","private void _runSelect(Connection conn,DaoStatement st) throws SQLException {
  Object[][] paramMatrix=st.getParamMatrix();
  int startRow=-1;
  int lastRow=-1;
  if (st.getContext().getResultSetType() == ResultSet.TYPE_SCROLL_INSENSITIVE) {
    Pager pager=st.getContext().getPager();
    if (pager != null) {
      startRow=pager.getOffset();
      lastRow=pager.getOffset() + pager.getPageSize();
    }
  }
  String sql=st.toPreparedStatement();
  ResultSet rs=null;
  Statement stat=null;
  try {
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      if (log.isDebugEnabled())       log.debug(st);
      stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      if (st.getContext().getFetchSize() > 0)       stat.setFetchSize(st.getContext().getFetchSize());
      rs=stat.executeQuery(sql);
    }
 else {
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
      if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      stat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
      if (lastRow > 0)       stat.setMaxRows(lastRow);
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set((PreparedStatement)stat,paramMatrix[0][i],i + 1);
      }
      rs=((PreparedStatement)stat).executeQuery();
    }
    if (startRow > 0)     rs.absolute(startRow);
    st.onAfter(conn,rs);
  }
  finally {
    Daos.safeClose(stat,rs);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}"
80438,"public ActionInvoker get(ActionContext ac){
  String path=Mvcs.getRequestPath(ac.getRequest());
  ActionInvoker invoker=root.get(ac,path);
  if (invoker != null) {
    ActionChain chain=invoker.getActionChain(ac);
    if (chain != null) {
      if (log.isDebugEnabled()) {
        log.debugf(""String_Node_Str"",path,chain);
      }
      return invoker;
    }
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",path);
  return null;
}","public ActionInvoker get(ActionContext ac){
  String path=Mvcs.getRequestPath(ac.getRequest());
  ActionInvoker invoker=root.get(ac,path);
  if (invoker != null) {
    ActionChain chain=invoker.getActionChain(ac);
    if (chain != null) {
      if (log.isDebugEnabled()) {
        log.debugf(""String_Node_Str"",ac.getRequest().getMethod(),path,chain);
      }
      return invoker;
    }
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",path);
  return null;
}"
80439,"public void process(ActionContext ac) throws Throwable {
  RequestIocContext reqContext=null;
  try {
    if (null != moduleObj) {
      ac.setModule(moduleObj);
    }
 else {
      Ioc ioc=ac.getIoc();
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",injectName,injectName);
      Object obj;
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(ac.getRequest());
        SessionIocContext sessionContext=new SessionIocContext(Mvcs.getHttpSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        Mvcs.setIocContext(myContext);
        obj=((Ioc2)ioc).get(moduleType,injectName,myContext);
      }
 else       obj=ioc.get(moduleType,injectName);
      ac.setModule(obj);
    }
    ac.setMethod(method);
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",ac.getPath(),method);
    doNext(ac);
  }
  finally {
    if (reqContext != null)     try {
      reqContext.depose();
    }
 catch (    Throwable e) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"",e);
    }
  }
}","public void process(ActionContext ac) throws Throwable {
  RequestIocContext reqContext=null;
  try {
    if (null != moduleObj) {
      ac.setModule(moduleObj);
    }
 else {
      Ioc ioc=ac.getIoc();
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",injectName,injectName);
      Object obj;
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(ac.getRequest());
        SessionIocContext sessionContext=new SessionIocContext(Mvcs.getHttpSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        Mvcs.setIocContext(myContext);
        obj=((Ioc2)ioc).get(moduleType,injectName,myContext);
      }
 else       obj=ioc.get(moduleType,injectName);
      ac.setModule(obj);
    }
    ac.setMethod(method);
    doNext(ac);
  }
  finally {
    if (reqContext != null)     try {
      reqContext.depose();
    }
 catch (    Throwable e) {
      if (log.isDebugEnabled())       log.debug(""String_Node_Str"",e);
    }
  }
}"
80440,"private void _runPreparedStatement(Connection conn,DaoStatement st,Object[][] paramMatrix) throws SQLException {
  ValueAdaptor[] adaptors=st.getAdaptors();
  if (adaptors.length != paramMatrix[0].length)   throw Lang.makeThrow(""String_Node_Str"");
  boolean statIsClosed=false;
  String sql=st.toPreparedStatement();
  PreparedStatement pstat=null;
  if (log.isDebugEnabled())   log.debug(st);
  try {
    pstat=conn.prepareStatement(sql);
    if (paramMatrix.length == 1) {
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
      }
      pstat.execute();
      st.getContext().setUpdateCount(pstat.getUpdateCount());
      pstat.close();
      statIsClosed=true;
    }
 else {
      for (      Object[] params : paramMatrix) {
        for (int i=0; i < params.length; i++) {
          adaptors[i].set(pstat,params[i],i + 1);
        }
        pstat.addBatch();
      }
      int[] counts=pstat.executeBatch();
      pstat.close();
      statIsClosed=true;
      int sum=0;
      for (      int i : counts)       sum+=i;
      st.getContext().setUpdateCount(sum);
    }
  }
  finally {
    if (!statIsClosed)     Daos.safeClose(pstat);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}","private void _runPreparedStatement(Connection conn,DaoStatement st,Object[][] paramMatrix) throws SQLException {
  ValueAdaptor[] adaptors=st.getAdaptors();
  if (adaptors.length != paramMatrix[0].length)   throw Lang.makeThrow(""String_Node_Str"");
  boolean statIsClosed=false;
  String sql=st.toPreparedStatement();
  PreparedStatement pstat=null;
  if (log.isDebugEnabled())   log.debug(st);
  try {
    pstat=conn.prepareStatement(sql);
    if (paramMatrix.length == 1) {
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
      }
      pstat.execute();
      st.getContext().setUpdateCount(pstat.getUpdateCount());
      pstat.close();
      statIsClosed=true;
    }
 else {
      for (      Object[] params : paramMatrix) {
        for (int i=0; i < params.length; i++) {
          adaptors[i].set(pstat,params[i],i + 1);
        }
        pstat.addBatch();
      }
      int[] counts=pstat.executeBatch();
      int sum=0;
      for (      int i : counts)       if (i > 0)       sum+=i;
      if (sum == 0)       sum=pstat.getUpdateCount();
      pstat.close();
      statIsClosed=true;
      st.getContext().setUpdateCount(sum);
    }
  }
  finally {
    if (!statIsClosed)     Daos.safeClose(pstat);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}"
80441,"public FilterConvertImpl(List<String> paths){
  this.paths=paths;
}","public FilterConvertImpl(List<String> paths){
  this.items=paths;
}"
80442,"protected void DLR(String path,Object item){
  if (clude) {
    if (paths.contains(path)) {
      build.put(path,item,arrayIndex);
    }
  }
}","protected void DLR(String path,Object item){
  if (clude) {
    if (items.contains(path)) {
      build.put(path,item,arrayIndex);
    }
  }
}"
80443,"protected void LRD(String path,Object item){
  if (clude) {
    return;
  }
  for (  String p : paths) {
    if (!p.startsWith(path) && !path.startsWith(p)) {
      build.put(path,item,arrayIndex);
    }
  }
}","protected void LRD(String path,Object item){
  if (clude) {
    return;
  }
  int isFilter=0;
  for (  String p : items) {
    System.out.println(p + ""String_Node_Str"" + path);
    if (!(p.equals(path) || path.startsWith((p + ""String_Node_Str"")) || p.startsWith(path + ""String_Node_Str"")|| path.startsWith((p + ""String_Node_Str""))|| p.startsWith(path + ""String_Node_Str""))) {
      isFilter++;
    }
  }
  if (isFilter == items.size()) {
    build.put(path,item,arrayIndex);
  }
}"
80444,"private void _evalFieldMacro(Entity<?> en,List<MappingInfo> infos){
  for (  MappingInfo info : infos) {
    if (null != info.annPrev) {
      en.addBeforeInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annPrev.els(),info.annPrev.value())));
    }
    if (null != info.annNext && en.addAfterInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annNext.els(),info.annNext.value())))) {
      continue;
    }
 else     if (null != info.annId && info.annId.auto()) {
      MappingField idField=en.getField(info.name);
      String autoSql=""String_Node_Str"";
      Pojo autoInfo=new SqlFieldMacro(idField,autoSql);
      autoInfo.setEntity(en);
      en.addAfterInsertMacro(autoInfo);
    }
  }
}","private void _evalFieldMacro(Entity<?> en,List<MappingInfo> infos){
  for (  MappingInfo info : infos) {
    if (null != info.annPrev) {
      en.addBeforeInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annPrev.els(),info.annPrev.value())));
    }
    if (null != info.annNext && en.addAfterInsertMacro(__macro(en.getField(info.name),_annToFieldMacroInfo(info.annNext.els(),info.annNext.value())))) {
      continue;
    }
 else     if (null != info.annId && info.annId.auto()) {
      en.addAfterInsertMacro(expert.fetchPojoId(en,en.getField(info.name)));
    }
  }
}"
80445,"@Override public String getDatabaseType(){
  return DB.H2.name();
}","public String getDatabaseType(){
  return DB.H2.name();
}"
80446,"public Object run(List<Object> param){
  Object obj=fetchVar();
  Mirror<?> me=null;
  me=Mirror.me(obj);
  if (param.isEmpty()) {
    return me.invoke(obj,right.toString());
  }
  return me.invoke(obj,right.toString(),param.toArray());
}","public Object run(List<Object> param){
  Object obj=fetchVar();
  Mirror<?> me=null;
  if (obj == null)   throw new NullPointerException();
  if (obj instanceof Class) {
    me=Mirror.me(obj);
    try {
      return me.invoke(obj,right.toString(),param.toArray());
    }
 catch (    InvokingException e) {
      throw e;
    }
catch (    Throwable e) {
      if (Lang.unwrapThrow(e) instanceof NoSuchMethodException) {
        me=Mirror.me(obj.getClass().getClass());
        return me.invoke(obj,right.toString(),param.toArray());
      }
      throw Lang.wrapThrow(e);
    }
  }
 else {
    me=Mirror.me(obj);
    return me.invoke(obj,right.toString(),param.toArray());
  }
}"
80447,"@Test public void testIssue308(){
  Context context=Lang.context();
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  context.set(""String_Node_Str"",list);
  context.set(""String_Node_Str"",System.class);
}","@Test public void testIssue308(){
  Context context=Lang.context();
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  context.set(""String_Node_Str"",list);
  context.set(""String_Node_Str"",System.class);
  El.eval(context,""String_Node_Str"");
}"
80448,"private void _checkupEntityFieldsWithDatabase(NutEntity<?> en){
  Connection conn=null;
  try {
    conn=Trans.getConnectionAuto(datasource);
    expert.setupEntityField(conn,en);
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",en.getType().getName(),en.getTableName(),e.getClass().getName(),e.getMessage());
  }
 finally {
    if (null != conn) {
      try {
        conn.close();
      }
 catch (      SQLException e) {
        if (log.isWarnEnabled())         log.warn(""String_Node_Str"",e);
      }
    }
  }
}","private void _checkupEntityFieldsWithDatabase(NutEntity<?> en){
  Connection conn=null;
  try {
    conn=Trans.getConnectionAuto(datasource);
    expert.setupEntityField(conn,en);
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",en.getType().getName(),en.getTableName(),e.getClass().getName(),e.getMessage());
  }
 finally {
    Trans.closeConnectionAuto(conn);
  }
}"
80449,"/** 
 * 如果在事务中,则返回事务的连接,否则直接从数据源取一个新的连接
 * @param ds
 * @return
 * @throws SQLException
 */
public static Connection getConnectionAuto(DataSource ds) throws SQLException {
  if (get() == null)   return ds.getConnection();
 else   return get().getConnection(ds);
}","/** 
 * 如果在事务中,则返回事务的连接,否则直接从数据源取一个新的连接
 */
public static Connection getConnectionAuto(DataSource ds) throws SQLException {
  if (get() == null)   return ds.getConnection();
 else   return get().getConnection(ds);
}"
80450,"public FileResource(String base,File file){
  base=Disks.normalize(Disks.getCanonicalPath(base));
  if (!base.endsWith(""String_Node_Str""))   base+=""String_Node_Str"";
  this.name=Disks.normalize(Disks.getCanonicalPath(file.getAbsolutePath()));
  this.name=this.name.substring(this.name.indexOf(base) + base.length()).replace('\\','/');
  this.file=file;
}","public FileResource(String base,File file){
  base=Disks.normalize(Disks.getCanonicalPath(base));
  if (base == null)   base=""String_Node_Str"";
 else   if (!base.endsWith(""String_Node_Str""))   base+=""String_Node_Str"";
  this.name=Disks.normalize(Disks.getCanonicalPath(file.getAbsolutePath()));
  this.name=this.name.substring(this.name.indexOf(base) + base.length()).replace('\\','/');
  this.file=file;
}"
80451,"public Object run(List<Object> param){
  Object obj=fetchVar();
  Mirror<?> me=null;
  if (obj instanceof Class) {
    me=Mirror.me((Class<?>)obj);
  }
 else {
    me=Mirror.me(obj);
  }
  if (param.isEmpty()) {
    return me.invoke(obj,right.toString());
  }
  return me.invoke(obj,right.toString(),param.toArray());
}","public Object run(List<Object> param){
  Object obj=fetchVar();
  Mirror<?> me=null;
  me=Mirror.me(obj);
  if (param.isEmpty()) {
    return me.invoke(obj,right.toString());
  }
  return me.invoke(obj,right.toString(),param.toArray());
}"
80452,"/** 
 * 转换数据,主要是转换负号,方法执行
 */
private Object parseItem(Object item){
  if (paramSize == 0) {
    if (!(item instanceof Operator)) {
      paramSize=1;
    }
  }
 else {
    if (item instanceof CommaOpt) {
      paramSize++;
    }
  }
  if (item instanceof LBracketOpt) {
    if (prev instanceof Elobj) {
      prem=new MethodOpt();
      item=new Object[]{prem,new LBracketOpt()};
      paramSize=0;
      bracket.addFirst(BracketType.Method);
    }
 else {
      bracket.addFirst(BracketType.Default);
    }
  }
  if (item instanceof RBracketOpt) {
switch (bracket.poll()) {
case Method:
      prem.setSize(paramSize);
    paramSize=-1;
  item=new Object[]{new RBracketOpt(),new InvokeMethodOpt()};
prem=null;
break;
default :
break;
}
}
if (item instanceof SubOpt && NegativeOpt.isNegetive(prev)) {
item=new NegativeOpt();
}
prev=item;
return item;
}","/** 
 * 转换数据,主要是转换负号,方法执行
 */
private Object parseItem(Object item){
  if (methods.peek() != null) {
    MethodOpt opt=methods.peek();
    if (opt.getSize() <= 0) {
      if (!(item instanceof CommaOpt) && !(item instanceof RBracketOpt)) {
        opt.setSize(1);
      }
    }
 else {
      if (item instanceof CommaOpt) {
        opt.setSize(opt.getSize() + 1);
      }
    }
  }
  if (item instanceof LBracketOpt) {
    if (prev instanceof Elobj) {
      MethodOpt prem=new MethodOpt();
      item=new Object[]{prem,new LBracketOpt()};
      methods.addFirst(prem);
    }
 else {
      methods.addFirst(null);
    }
  }
  if (item instanceof RBracketOpt) {
    if (methods.poll() != null) {
      item=new Object[]{new RBracketOpt(),new InvokeMethodOpt()};
    }
  }
  if (item instanceof SubOpt && NegativeOpt.isNegetive(prev)) {
    item=new NegativeOpt();
  }
  prev=item;
  return item;
}"
80453,"public Invoking(Class<?> type,String methodName,Object... args){
  try {
    if (null == args || args.length == 0) {
      invoker=new NullArgInvoker(type.getMethod(methodName));
    }
 else {
      Method[] all=type.getMethods();
      List<Method> candidates=new ArrayList<Method>(all.length);
      for (      Method m : all)       if (m.getName().equals(methodName)) {
        candidates.add(m);
      }
      Class<?>[] argTypes=Mirror.evalToTypes(args);
      Object dynaArg=Mirror.evalArgToRealArray(args);
      for (Iterator<Method> it=candidates.iterator(); it.hasNext(); ) {
        Method m=it.next();
        Class<?>[] pts=m.getParameterTypes();
        MatchType mr=Mirror.matchParamTypes(pts,argTypes);
        if (MatchType.YES == mr) {
          invoker=new DefaultInvoker(m,args);
          break;
        }
 else         if (MatchType.LACK == mr) {
          invoker=new DefaultInvoker(m,Lang.arrayLast(args,Mirror.blankArrayArg(pts)));
          break;
        }
 else         if (null != dynaArg && pts.length == 1) {
          if (pts[0] == dynaArg.getClass()) {
            invoker=new DynamicArgsInvoker(m,Lang.array2array(args,pts[0].getComponentType()));
            break;
          }
          if (pts[0].isArray()) {
            if (Mirror.me(pts[0].getComponentType()).getWrapper().equals(Mirror.me(dynaArg.getClass().getComponentType()).getWrapper()))             invoker=new DynamicArgsInvoker(m,Lang.array2array(args,pts[0].getComponentType()));
            break;
          }
        }
      }
      if (null == invoker)       try {
        for (Iterator<Method> it=candidates.iterator(); it.hasNext(); ) {
          Method m=it.next();
          Class<?>[] pts=m.getParameterTypes();
          if (pts.length == args.length) {
            invoker=new DefaultInvoker(m,Lang.array2ObjectArray(args,pts));
          }
 else           if (pts.length == args.length + 1 && pts[args.length].isArray()) {
            invoker=new DefaultInvoker(m,Lang.array2ObjectArray(args,pts));
          }
        }
      }
 catch (      Exception e) {
      }
    }
  }
 catch (  NoSuchMethodException e) {
    throw Lang.wrapThrow(e);
  }
  if (null == invoker)   throw new InvokingException(""String_Node_Str"",type.getName(),methodName,Lang.concat('\n',args));
  msg=format(""String_Node_Str"",type.getName(),methodName,Lang.concat('\n',args)) + ""String_Node_Str"";
}","public Invoking(Class<?> type,String methodName,Object... args){
  try {
    if (null == args || args.length == 0) {
      invoker=new NullArgInvoker(type.getMethod(methodName));
    }
 else {
      Method[] all=type.getMethods();
      List<Method> candidates=new ArrayList<Method>(all.length);
      for (      Method m : all)       if (m.getName().equals(methodName)) {
        candidates.add(m);
      }
      Class<?>[] argTypes=Mirror.evalToTypes(args);
      Object dynaArg=Mirror.evalArgToRealArray(args);
      for (Iterator<Method> it=candidates.iterator(); it.hasNext(); ) {
        Method m=it.next();
        Class<?>[] pts=m.getParameterTypes();
        MatchType mr=Mirror.matchParamTypes(pts,argTypes);
        if (MatchType.YES == mr) {
          invoker=new DefaultInvoker(m,args);
          break;
        }
 else         if (MatchType.LACK == mr) {
          invoker=new DefaultInvoker(m,Lang.arrayLast(args,Mirror.blankArrayArg(pts)));
          break;
        }
 else         if (null != dynaArg && pts.length == 1) {
          if (pts[0] == dynaArg.getClass()) {
            invoker=new DynamicArgsInvoker(m,Lang.array2array(args,pts[0].getComponentType()));
            break;
          }
          if (pts[0].isArray()) {
            if (Mirror.me(pts[0].getComponentType()).getWrapper().equals(Mirror.me(dynaArg.getClass().getComponentType()).getWrapper())) {
              invoker=new DynamicArgsInvoker(m,Lang.array2array(args,pts[0].getComponentType()));
              break;
            }
          }
        }
      }
      if (null == invoker)       try {
        for (Iterator<Method> it=candidates.iterator(); it.hasNext(); ) {
          Method m=it.next();
          Class<?>[] pts=m.getParameterTypes();
          if (pts.length == args.length) {
            invoker=new DefaultInvoker(m,Lang.array2ObjectArray(args,pts));
          }
 else           if (pts.length == args.length + 1 && pts[args.length].isArray()) {
            invoker=new DefaultInvoker(m,Lang.array2ObjectArray(args,pts));
          }
        }
      }
 catch (      Exception e) {
      }
    }
  }
 catch (  NoSuchMethodException e) {
    throw Lang.wrapThrow(e);
  }
  if (null == invoker)   throw new InvokingException(""String_Node_Str"",type.getName(),methodName,Lang.concat('\n',args));
  msg=format(""String_Node_Str"",type.getName(),methodName,Lang.concat('\n',args)) + ""String_Node_Str"";
}"
80454,"/** 
 * 取得变得的值
 */
public Object fetchVar(){
  if (left instanceof AccessOpt) {
    return ((AccessOpt)left).fetchVar();
  }
  if (left instanceof Operator) {
    return ((Operator)left).calculate();
  }
  if (left instanceof Elobj) {
    Object obj=((Elobj)left).fetchVal();
    if (right instanceof FieldObj) {
      try {
        return Mirror.me(obj).getField(((Elobj)right).getVal());
      }
 catch (      NoSuchFieldException e) {
        throw Lang.wrapThrow(e);
      }
    }
    return obj;
  }
  return left;
}","/** 
 * 取得变得的值
 */
public Object fetchVar(){
  if (left instanceof AccessOpt) {
    return ((AccessOpt)left).fetchVar();
  }
  if (left instanceof Operator) {
    return ((Operator)left).calculate();
  }
  if (left instanceof Elobj) {
    Object obj=((Elobj)left).fetchVal();
    if (right instanceof FieldObj) {
      return Mirror.me(obj).getValue(obj,((Elobj)right).getVal());
    }
    return obj;
  }
  return left;
}"
80455,"@Test public void testIssue303(){
  Context context=Lang.context();
  Issue303 item=new Issue303(""String_Node_Str"");
  item.child=new Issue303(""String_Node_Str"");
  context.set(""String_Node_Str"",item);
  assertEquals(""String_Node_Str"",El.eval(context,""String_Node_Str""));
}","@Test public void testIssue303(){
  Context context=Lang.context();
  Issue303 item=new Issue303(""String_Node_Str"");
  item.child=new Issue303(""String_Node_Str"");
  context.set(""String_Node_Str"",item);
  assertEquals(""String_Node_Str"",El.eval(context,""String_Node_Str""));
  assertEquals(0,El.eval(context,""String_Node_Str""));
}"
80456,"public IdentifierObj(String val){
  this.val=val;
}","public IdentifierObj(String val){
  super(val);
}"
80457,"/** 
 * 取得变得的值
 */
public Object fetchVar(){
  if (left instanceof AccessOpt) {
    return ((AccessOpt)left).fetchVar();
  }
  if (left instanceof Operator) {
    return ((Operator)left).calculate();
  }
  if (left instanceof Elobj) {
    return ((Elobj)left).fetchVal();
  }
  return left;
}","/** 
 * 取得变得的值
 */
public Object fetchVar(){
  if (left instanceof AccessOpt) {
    return ((AccessOpt)left).fetchVar();
  }
  if (left instanceof Operator) {
    return ((Operator)left).calculate();
  }
  if (left instanceof Elobj) {
    Object obj=((Elobj)left).fetchVal();
    if (right instanceof FieldObj) {
      try {
        return Mirror.me(obj).getField(((Elobj)right).getVal());
      }
 catch (      NoSuchFieldException e) {
        throw Lang.wrapThrow(e);
      }
    }
    return obj;
  }
  return left;
}"
80458,"private void _checkupEntityFieldsWithDatabase(NutEntity<?> en){
  Connection conn=null;
  try {
    conn=datasource.getConnection();
    expert.setupEntityField(conn,en);
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",en.getType().getName(),en.getTableName(),e.getClass().getName(),e.getMessage());
  }
 finally {
    if (null != conn) {
      try {
        conn.close();
      }
 catch (      SQLException e) {
        if (log.isWarnEnabled())         log.warn(""String_Node_Str"",e);
      }
    }
  }
}","private void _checkupEntityFieldsWithDatabase(NutEntity<?> en){
  Connection conn=null;
  try {
    conn=Trans.getConnectionAuto(datasource);
    expert.setupEntityField(conn,en);
  }
 catch (  Exception e) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",en.getType().getName(),en.getTableName(),e.getClass().getName(),e.getMessage());
  }
 finally {
    if (null != conn) {
      try {
        conn.close();
      }
 catch (      SQLException e) {
        if (log.isWarnEnabled())         log.warn(""String_Node_Str"",e);
      }
    }
  }
}"
80459,"/** 
 * 根据 Java 字段创建一个实体字段信息对象
 * @param pk 复合主键
 * @param field Java 字段
 * @return 字段信息对象
 */
public static MappingInfo createMappingInfo(PK pk,Field field){
  MappingInfo info=create(MappingInfo.class,field);
  info.annPK=pk;
  info.annColumn=field.getAnnotation(Column.class);
  info.annDefine=field.getAnnotation(ColDefine.class);
  info.annDefault=field.getAnnotation(Default.class);
  info.annId=field.getAnnotation(Id.class);
  info.annName=field.getAnnotation(Name.class);
  info.annNext=field.getAnnotation(Next.class);
  info.annPrev=field.getAnnotation(Prev.class);
  info.annReadonly=field.getAnnotation(Readonly.class);
  info.columnComment=field.getAnnotation(Comment.class);
  return info;
}","/** 
 * 根据 Java 字段创建一个实体字段信息对象
 * @param pk 复合主键
 * @param field Java 字段
 * @return 字段信息对象
 */
public static MappingInfo createMappingInfo(PK pk,Field field){
  MappingInfo info=create(MappingInfo.class,field);
  info.annPK=pk;
  info.annColumn=field.getAnnotation(Column.class);
  info.annDefine=field.getAnnotation(ColDefine.class);
  info.annDefault=field.getAnnotation(Default.class);
  info.annId=field.getAnnotation(Id.class);
  info.annName=field.getAnnotation(Name.class);
  info.annNext=field.getAnnotation(Next.class);
  info.annPrev=field.getAnnotation(Prev.class);
  info.annReadonly=field.getAnnotation(Readonly.class);
  info.columnComment=field.getAnnotation(Comment.class);
  if (info.annId != null) {
    if (!Mirror.me(field.getType()).isIntLike())     throw Lang.makeThrow(DaoException.class,""String_Node_Str"",field);
  }
  if (info.annName != null)   if (!Mirror.me(field.getType()).isStringLike())   throw Lang.makeThrow(DaoException.class,""String_Node_Str"",field);
  return info;
}"
80460,"public void wrap(Queue<Object> rpn){
  if (rpn.peek() instanceof AccessOpt) {
    left=rpn.poll();
    return;
  }
  if (getSize() <= 0) {
    left=rpn.poll();
  }
 else {
    right=rpn.poll();
    left=rpn.poll();
  }
}","public void wrap(Queue<Object> rpn){
  if (getSize() <= 0) {
    left=rpn.poll();
  }
 else {
    right=rpn.poll();
    left=rpn.poll();
  }
}"
80461,"/** 
 * 转换数据,主要是转换负号,方法执行
 */
private Object parseItem(Object item){
  paramSize++;
  if (item instanceof LBracketOpt) {
    if (prev instanceof Elobj) {
      prem=new MethodOpt();
      item=new Object[]{prem,new LBracketOpt()};
      paramSize=0;
      bracket.addFirst(BracketType.Method);
    }
 else {
      bracket.addFirst(BracketType.Default);
    }
  }
  if (item instanceof RBracketOpt) {
switch (bracket.poll()) {
case Method:
      prem.setSize(paramSize - 1);
    item=new Object[]{new RBracketOpt(),new InvokeMethodOpt()};
  prem=null;
break;
default :
break;
}
}
if (item instanceof SubOpt && NegativeOpt.isNegetive(prev)) {
item=new NegativeOpt();
}
prev=item;
return item;
}","/** 
 * 转换数据,主要是转换负号,方法执行
 */
private Object parseItem(Object item){
  if (paramSize == 0) {
    if (!(item instanceof Operator)) {
      paramSize=1;
    }
  }
 else {
    if (item instanceof CommaOpt) {
      paramSize++;
    }
  }
  if (item instanceof LBracketOpt) {
    if (prev instanceof Elobj) {
      prem=new MethodOpt();
      item=new Object[]{prem,new LBracketOpt()};
      paramSize=0;
      bracket.addFirst(BracketType.Method);
    }
 else {
      bracket.addFirst(BracketType.Default);
    }
  }
  if (item instanceof RBracketOpt) {
switch (bracket.poll()) {
case Method:
      prem.setSize(paramSize);
    paramSize=-1;
  item=new Object[]{new RBracketOpt(),new InvokeMethodOpt()};
prem=null;
break;
default :
break;
}
}
if (item instanceof SubOpt && NegativeOpt.isNegetive(prev)) {
item=new NegativeOpt();
}
prev=item;
return item;
}"
80462,"public Object get(ResultSet rs,String colName) throws SQLException {
  File f=this.createTempFile();
  Clob clob=rs.getClob(colName);
  if (clob == null)   return null;
  Files.write(f,clob.getAsciiStream());
  return new SimpleClob(f);
}","public Object get(ResultSet rs,String colName) throws SQLException {
  File f=this.createTempFile();
  Clob clob=rs.getClob(colName);
  if (clob == null)   return null;
  Files.write(f,clob.getCharacterStream());
  return new SimpleClob(f);
}"
80463,"public Object get(ResultSet rs,String colName) throws SQLException {
  File f=this.createTempFile();
  Clob clob=rs.getClob(colName);
  if (clob == null)   return null;
  Files.write(f,clob.getAsciiStream());
  return new SimpleClob(f);
}","public Object get(ResultSet rs,String colName) throws SQLException {
  File f=this.createTempFile();
  Clob clob=rs.getClob(colName);
  if (clob == null)   return null;
  Files.write(f,clob.getCharacterStream());
  return new SimpleClob(f);
}"
80464,"public void truncate(long len) throws SQLException {
  Files.write(file,new Byte[]{});
}","public void truncate(long len) throws SQLException {
  try {
    new RandomAccessFile(file,""String_Node_Str"").setLength(len);
  }
 catch (  FileNotFoundException e) {
    throw Lang.wrapThrow(e);
  }
catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}"
80465,"@Override public boolean dropEntity(Dao dao,Entity<?> en){
  if (super.dropEntity(dao,en)) {
    if (en.getPks().isEmpty())     return true;
    List<Sql> sqls=new ArrayList<Sql>();
    for (    MappingField pk : en.getPks()) {
      String sql=gSQL(DSEQ,en.getTableName(),pk.getColumnName());
      sqls.add(Sqls.create(sql));
    }
    try {
      dao.execute(sqls.toArray(new Sql[sqls.size()]));
      return true;
    }
 catch (    Exception e) {
    }
  }
  return false;
}","@Override public boolean dropEntity(Dao dao,Entity<?> en){
  if (super.dropEntity(dao,en)) {
    if (en.getPks().isEmpty())     return true;
    List<Sql> sqls=new ArrayList<Sql>();
    for (    MappingField pk : en.getPks()) {
      if (pk.isAutoIncreasement()) {
        String sql=gSQL(DSEQ,en.getTableName(),pk.getColumnName());
        sqls.add(Sqls.create(sql));
      }
    }
    try {
      dao.execute(sqls.toArray(new Sql[sqls.size()]));
      return true;
    }
 catch (    Exception e) {
    }
  }
  return false;
}"
80466,"private void evalLocalization(NutConfig config,Class<?> mainModule){
  Localization lc=mainModule.getAnnotation(Localization.class);
  if (null != lc) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",lc.value());
    Map<String,Map<String,Object>> msgss=Mirror.me(lc.type()).born().load(lc.value());
    Mvcs.setMessageSet(msgss);
  }
 else   if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
}","private void evalLocalization(NutConfig config,Class<?> mainModule){
  Localization lc=mainModule.getAnnotation(Localization.class);
  if (null != lc) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",lc.value());
    MessageLoader msgLoader=null;
    if (!Strings.isBlank(lc.beanName())) {
      msgLoader=config.getIoc().get(lc.type(),lc.beanName());
    }
 else {
      msgLoader=Mirror.me(lc.type()).born();
    }
    Map<String,Map<String,Object>> msgss=msgLoader.load(lc.value());
    Mvcs.setMessageSet(msgss);
  }
 else   if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
}"
80467,"private ViewMaker[] createViewMakers(Class<?> mainModule) throws Exception {
  Views vms=mainModule.getAnnotation(Views.class);
  ViewMaker[] makers;
  int i=0;
  if (null != vms) {
    makers=new ViewMaker[vms.value().length + 1];
    for (; i < vms.value().length; i++)     makers[i]=Mirror.me(vms.value()[i]).born();
  }
 else {
    makers=new ViewMaker[1];
  }
  makers[i]=new DefaultViewMaker();
  if (log.isDebugEnabled()) {
    StringBuilder sb=new StringBuilder();
    sb.append(makers[0].getClass().getSimpleName());
    for (i=1; i < makers.length; i++)     sb.append(',').append(makers[i].getClass().getSimpleName());
    log.debugf(""String_Node_Str"",sb);
  }
  return makers;
}","private ViewMaker[] createViewMakers(Class<?> mainModule) throws Exception {
  Views vms=mainModule.getAnnotation(Views.class);
  ViewMaker[] makers;
  int i=0;
  if (null != vms) {
    makers=new ViewMaker[vms.value().length + 1];
    for (; i < vms.value().length; i++)     makers[i]=Mirror.me(vms.value()[i]).born();
  }
 else {
    makers=new ViewMaker[1];
  }
  makers[i]=new DefaultViewMaker();
  if (log.isDebugEnabled()) {
    StringBuilder sb=new StringBuilder();
    sb.append(makers[0].getClass().getSimpleName());
    for (i=0; i < makers.length - 1; i++)     sb.append(',').append(makers[i].getClass().getSimpleName());
    log.debugf(""String_Node_Str"",sb);
  }
  return makers;
}"
80468,"/** 
 * 获取当前会话的 Locale 名称
 */
public static String getLocaleName(HttpSession session){
  return (String)session.getAttribute(LOCALE_NAME);
}","/** 
 * 获取当前会话的 Locale 名称
 */
@Deprecated public static String getLocaleName(HttpSession session){
  return (String)session.getAttribute(LOCALE_KEY);
}"
80469,"/** 
 * 判断当前会话是否已经设置了本地字符串表
 */
public static boolean hasLocale(HttpSession session){
  return null != session.getAttribute(MSG);
}","/** 
 * 判断当前会话是否已经设置了本地字符串表
 */
@Deprecated public static boolean hasLocale(HttpSession session){
  return null != session.getAttribute(MSG);
}"
80470,"/** 
 * 为当前会话设置 Locale 的名称
 */
public static void setLocaleName(HttpSession session,String name){
  session.setAttribute(LOCALE_NAME,name);
  session.removeAttribute(MSG);
}","/** 
 * 为当前会话设置 Locale 的名称
 */
@Deprecated public static void setLocaleName(HttpSession session,String name){
  session.setAttribute(LOCALE_KEY,name);
  session.removeAttribute(MSG);
}"
80471,"/** 
 * 判断当前会话是够设置了特殊的 Locale 的名称。
 */
public static boolean hasLocaleName(HttpSession session){
  return !Strings.isBlank(getLocaleName(session));
}","/** 
 * 判断当前会话是够设置了特殊的 Locale 的名称。
 */
@Deprecated public static boolean hasLocaleName(HttpSession session){
  return !Strings.isBlank(getLocaleName(session));
}"
80472,"/** 
 * 为当前的 HTTP 请求对象设置一些必要的属性。包括： <ul> <li>本地化子字符串 => ${msg} <li>应用的路径名 => ${base} </ul>
 * @param req HTTP 请求对象
 */
@SuppressWarnings(""String_Node_Str"") public static void updateRequestAttributes(HttpServletRequest req){
  HttpSession sess=getHttpSession();
  if (null != getMessageSet()) {
    Map<String,Object> msgs=null;
    if (!hasLocale(sess))     msgs=setLocale(sess,getLocaleName(sess));
 else     msgs=(Map<String,Object>)sess.getAttribute(MSG);
    if (null == msgs) {
      Map<String,Map<String,Object>> msgss=getMessageSet();
      if (msgss.size() > 0)       msgs=msgss.values().iterator().next();
    }
    req.setAttribute(MSG,msgs);
  }
  req.setAttribute(""String_Node_Str"",req.getContextPath());
  req.setAttribute(""String_Node_Str"",req);
}","/** 
 * 为当前的 HTTP 请求对象设置一些必要的属性。包括： <ul> <li>本地化子字符串 => ${msg} <li>应用的路径名 => ${base} </ul>
 * @param req HTTP 请求对象
 */
public static void updateRequestAttributes(HttpServletRequest req){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss) {
    Map<String,Object> msgs=null;
    String lKey=Mvcs.getLocalizationKey();
    if (!Strings.isBlank(lKey))     msgs=msgss.get(lKey);
    if (null == msgs) {
      if (msgss.size() > 0)       msgs=msgss.values().iterator().next();
    }
    req.setAttribute(MSG,msgs);
  }
  req.setAttribute(""String_Node_Str"",req.getContextPath());
  req.setAttribute(""String_Node_Str"",req);
}"
80473,"/** 
 * 获取整个应用的默认字符串表
 * @param context 上下文
 * @return 字符串表
 */
public static Map<String,Object> getDefaultLocaleMessage(ServletContext context){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss)   return msgss.get(DEFAULT_MSGS);
  return null;
}","/** 
 * 获取整个应用的默认字符串表
 * @param context 上下文
 * @return 字符串表
 */
@Deprecated public static Map<String,Object> getDefaultLocaleMessage(ServletContext context){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss)   return msgss.get(DEFAULT_MSGS);
  return null;
}"
80474,"/** 
 * 获取整个应用可用的 Locale 名称集合
 */
public static Set<String> getLocaleNames(ServletContext context){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss)   return msgss.keySet();
  return null;
}","/** 
 * 获取整个应用可用的 Locale 名称集合
 */
@Deprecated public static Set<String> getLocaleNames(ServletContext context){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss)   return msgss.keySet();
  return null;
}"
80475,"/** 
 * 为当前会话设置本地字符串表。如果传入的 localeName 为空，或者不存在该表，则用默认字符串表替代。 执行完毕后，在 session 中会有一个属性（名称请参见 Mvcs.MSGS 定义） <p> 在 jsp 中，你可以用 EL 表达式 ${msgs.xxx} 来直接获取字符串的值。
 * @return 设置的 本地化字符串表
 */
public static Map<String,Object> setLocale(HttpSession session,String localeName){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss) {
    Map<String,Object> msgs=null;
    if (null != localeName)     msgs=msgss.get(localeName);
    if (null == msgs)     msgs=msgss.get(DEFAULT_MSGS);
    if (null != msgs)     session.setAttribute(MSG,msgs);
    return msgs;
  }
  return null;
}","/** 
 * 为当前会话设置本地字符串表。如果传入的 localeName 为空，或者不存在该表，则用默认字符串表替代。 执行完毕后，在 session 中会有一个属性（名称请参见 Mvcs.MSGS 定义） <p> 在 jsp 中，你可以用 EL 表达式 ${msgs.xxx} 来直接获取字符串的值。
 * @return 设置的 本地化字符串表
 */
@Deprecated public static Map<String,Object> setLocale(HttpSession session,String localeName){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss) {
    Map<String,Object> msgs=null;
    if (null != localeName)     msgs=msgss.get(localeName);
    if (null == msgs)     msgs=msgss.get(DEFAULT_MSGS);
    if (null != msgs)     session.setAttribute(MSG,msgs);
    return msgs;
  }
  return null;
}"
80476,"@Override protected String evalFieldType(MappingField mf){
switch (mf.getColumnType()) {
case BOOLEAN:
    return ""String_Node_Str"";
case TIMESTAMP:
  return ""String_Node_Str"";
case DATETIME:
case DATE:
case TIME:
return ""String_Node_Str"";
case INT:
if (mf.getWidth() > 0) return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str"";
return ""String_Node_Str"";
case FLOAT:
if (mf.getWidth() > 0 && mf.getPrecision() > 0) {
return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str""+ mf.getPrecision()+ ""String_Node_Str"";
}
if (mf.getTypeMirror().isDouble()) return ""String_Node_Str"";
return ""String_Node_Str"";
}
return super.evalFieldType(mf);
}","@Override protected String evalFieldType(MappingField mf){
switch (mf.getColumnType()) {
case BOOLEAN:
    return ""String_Node_Str"";
case TIMESTAMP:
  return ""String_Node_Str"";
case DATETIME:
case DATE:
case TIME:
return ""String_Node_Str"";
case INT:
if (mf.getWidth() > 0) return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str"";
return ""String_Node_Str"";
case FLOAT:
if (mf.getWidth() > 0 && mf.getPrecision() > 0) {
return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str""+ mf.getPrecision()+ ""String_Node_Str"";
}
if (mf.getTypeMirror().isDouble()) return ""String_Node_Str"";
return ""String_Node_Str"";
case BINARY:
return ""String_Node_Str"";
}
return super.evalFieldType(mf);
}"
80477,"/** 
 * 判断当前类型是否为POJO。 除了下面的类型，其他均为 POJO <ul> <li>原生以及所有包裹类 <li>类字符串 <li>类日期 <li>非容器 </ul>
 * @return true or false
 */
public boolean isPojo(){
  if (this.klass.isPrimitive())   return false;
  if (this.isStringLike() || this.isDateTimeLike())   return false;
  if (this.isPrimitiveNumber() || this.isBoolean() || this.isChar())   return false;
  return !isContainer();
}","/** 
 * 判断当前类型是否为POJO。 除了下面的类型，其他均为 POJO <ul> <li>原生以及所有包裹类 <li>类字符串 <li>类日期 <li>非容器 </ul>
 * @return true or false
 */
public boolean isPojo(){
  if (this.klass.isPrimitive() || this.isEnum())   return false;
  if (this.isStringLike() || this.isDateTimeLike())   return false;
  if (this.isPrimitiveNumber() || this.isBoolean() || this.isChar())   return false;
  return !isContainer();
}"
80478,"@Override public void formatQuery(Sql sql){
  sql.getContext().setResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
}","public void formatQuery(Sql sql){
  sql.getContext().setResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
}"
80479,"/** 
 * 为一个输出流包裹一个缓冲流。如果这个输出流本身就是缓冲流，则直接返回
 * @param ops 输出流。
 * @return 缓冲输出流
 */
public static BufferedOutputStream buff(OutputStream ops){
  if (ops instanceof BufferedOutputStream)   return (BufferedOutputStream)ops;
  return new BufferedOutputStream(ops);
}","/** 
 * 为一个输出流包裹一个缓冲流。如果这个输出流本身就是缓冲流，则直接返回
 * @param ops 输出流。
 * @return 缓冲输出流
 */
public static BufferedOutputStream buff(OutputStream ops){
  if (ops == null)   throw new NullPointerException(""String_Node_Str"");
  if (ops instanceof BufferedOutputStream)   return (BufferedOutputStream)ops;
  return new BufferedOutputStream(ops);
}"
80480,"public void setProductName(String productName){
  this.productName=productName;
  String proName=productName.toLowerCase();
  if (""String_Node_Str"".equals(proName)) {
    type=DB.H2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.PSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.MYSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.ORACLE;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.DB2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.SQLSERVER;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.SQLITE;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.HSQL;
  }
 else {
    type=DB.OTHER;
  }
}","public void setProductName(String productName){
  this.productName=productName;
  String proName=productName.toLowerCase();
  if (""String_Node_Str"".equals(proName)) {
    type=DB.H2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.PSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.MYSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.ORACLE;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.DB2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.SQLSERVER;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.SQLITE;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.HSQL;
  }
 else   if (proName.contains(""String_Node_Str"")) {
    type=DB.DERBY;
  }
 else {
    type=DB.OTHER;
  }
}"
80481,"protected String createResultSetMetaSql(Entity<?> en){
  return ""String_Node_Str"" + en.getViewName();
}","protected String createResultSetMetaSql(Entity<?> en){
  return ""String_Node_Str"" + en.getViewName() + ""String_Node_Str"";
}"
80482,"void visitX(int i){
  if (i < 6) {
    mv.visitInsn(i + ICONST_0);
  }
 else {
    mv.visitIntInsn(BIPUSH,i);
  }
}","void visitX(int i){
  if (i < 6) {
    mv.visitInsn(i + ICONST_0);
  }
 else {
    if (i < Byte.MAX_VALUE)     mv.visitIntInsn(BIPUSH,i);
 else     mv.visitIntInsn(SIPUSH,i);
  }
}"
80483,"public void exec(Connection conn,DaoStatement st){
  Object[][] paramMatrix;
  try {
    st.onBefore(conn);
switch (st.getSqlType()) {
case SELECT:
      paramMatrix=st.getParamMatrix();
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      String sql=st.toPreparedStatement();
      if (log.isDebugEnabled())       log.debug(sql);
      Statement stat=null;
      ResultSet rs=null;
      try {
        stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        if (st.getContext().getFetchSize() > 0)         stat.setFetchSize(st.getContext().getFetchSize());
        rs=stat.executeQuery(sql);
        if (st.getContext().getResultSetType() == ResultSet.TYPE_SCROLL_INSENSITIVE) {
          Pager pager=st.getContext().getPager();
          if (pager != null) {
            rs.absolute(pager.getOffset());
          }
        }
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(stat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
 else {
      String sql=st.toPreparedStatement();
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
 else       if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      PreparedStatement pstat=null;
      ResultSet rs=null;
      try {
        pstat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        for (int i=0; i < paramMatrix[0].length; i++) {
          adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
        }
        rs=pstat.executeQuery();
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(pstat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
  break;
case ALTER:
case TRUNCATE:
case CREATE:
case DROP:
_runStatement(conn,st);
st.onAfter(conn,null);
break;
case RUN:
st.onAfter(conn,null);
break;
default :
paramMatrix=st.getParamMatrix();
if (null == paramMatrix || paramMatrix.length == 0) {
_runStatement(conn,st);
}
 else {
_runPreparedStatement(conn,st,paramMatrix);
}
st.onAfter(conn,null);
}
}
 catch (SQLException e) {
if (log.isInfoEnabled()) log.debug(""String_Node_Str"",e);
throw new DaoException(format(""String_Node_Str"",st.toString(),st.toPreparedStatement()),e);
}
}","public void exec(Connection conn,DaoStatement st){
  Object[][] paramMatrix;
  try {
    st.onBefore(conn);
switch (st.getSqlType()) {
case SELECT:
      paramMatrix=st.getParamMatrix();
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      String sql=st.toPreparedStatement();
      if (log.isDebugEnabled())       log.debug(sql);
      Statement stat=null;
      ResultSet rs=null;
      try {
        stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        int startRow=-1;
        int lastRow=-1;
        if (st.getContext().getResultSetType() == ResultSet.TYPE_SCROLL_INSENSITIVE) {
          Pager pager=st.getContext().getPager();
          if (pager != null) {
            startRow=pager.getOffset();
            lastRow=pager.getOffset() + pager.getPageSize();
          }
        }
        if (lastRow > 0)         stat.setMaxRows(lastRow);
        if (st.getContext().getFetchSize() > 0)         stat.setFetchSize(st.getContext().getFetchSize());
        rs=stat.executeQuery(sql);
        if (startRow > 0)         rs.absolute(startRow);
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(stat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
 else {
      String sql=st.toPreparedStatement();
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
 else       if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      PreparedStatement pstat=null;
      ResultSet rs=null;
      try {
        pstat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        for (int i=0; i < paramMatrix[0].length; i++) {
          adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
        }
        rs=pstat.executeQuery();
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(pstat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
  break;
case ALTER:
case TRUNCATE:
case CREATE:
case DROP:
_runStatement(conn,st);
st.onAfter(conn,null);
break;
case RUN:
st.onAfter(conn,null);
break;
default :
paramMatrix=st.getParamMatrix();
if (null == paramMatrix || paramMatrix.length == 0) {
_runStatement(conn,st);
}
 else {
_runPreparedStatement(conn,st,paramMatrix);
}
st.onAfter(conn,null);
}
}
 catch (SQLException e) {
if (log.isInfoEnabled()) log.debug(""String_Node_Str"",e);
throw new DaoException(format(""String_Node_Str"",st.toString(),st.toPreparedStatement()),e);
}
}"
80484,"/** 
 * 获取某一个本地字符串表
 * @param context 上下文
 * @param localeName 本地名
 * @return 字符串表
 * @see org.nutz.mvc.annotation.Localization
 * @see org.nutz.mvc.MessageLoader
 */
@Deprecated public static Map<String,String> getLocaleMessage(ServletContext context,String localeName){
  Map<String,Map<String,String>> msgss=getMessageSet();
  if (null != msgss)   return msgss.get(localeName);
  return null;
}","/** 
 * 获取某一个本地字符串表
 * @param context 上下文
 * @param localeName 本地名
 * @return 字符串表
 * @see org.nutz.mvc.annotation.Localization
 * @see org.nutz.mvc.MessageLoader
 */
@Deprecated public static Map<String,Object> getLocaleMessage(ServletContext context,String localeName){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss)   return msgss.get(localeName);
  return null;
}"
80485,"/** 
 * 获取整个应用的字符串表集合
 * @param context 上下文
 * @return 字符串表集合
 */
@Deprecated public static Map<String,Map<String,String>> getMessageSet(ServletContext context){
  return getMessageSet();
}","/** 
 * 获取整个应用的字符串表集合
 * @param context 上下文
 * @return 字符串表集合
 */
@Deprecated public static Map<String,Map<String,Object>> getMessageSet(ServletContext context){
  return getMessageSet();
}"
80486,"/** 
 * 为当前的 HTTP 请求对象设置一些必要的属性。包括： <ul> <li>本地化子字符串 => ${msg} <li>应用的路径名 => ${base} </ul>
 * @param req HTTP 请求对象
 */
@SuppressWarnings(""String_Node_Str"") public static void updateRequestAttributes(HttpServletRequest req){
  HttpSession sess=getHttpSession();
  if (null != getMessageSet()) {
    Map<String,String> msgs=null;
    if (!hasLocale(sess))     msgs=setLocale(sess,getLocaleName(sess));
 else     msgs=(Map<String,String>)sess.getAttribute(MSG);
    if (null == msgs) {
      Map<String,Map<String,String>> msgss=getMessageSet();
      if (msgss.size() > 0)       msgs=msgss.values().iterator().next();
    }
    req.setAttribute(MSG,msgs);
  }
  req.setAttribute(""String_Node_Str"",req.getContextPath());
  req.setAttribute(""String_Node_Str"",req);
}","/** 
 * 为当前的 HTTP 请求对象设置一些必要的属性。包括： <ul> <li>本地化子字符串 => ${msg} <li>应用的路径名 => ${base} </ul>
 * @param req HTTP 请求对象
 */
@SuppressWarnings(""String_Node_Str"") public static void updateRequestAttributes(HttpServletRequest req){
  HttpSession sess=getHttpSession();
  if (null != getMessageSet()) {
    Map<String,Object> msgs=null;
    if (!hasLocale(sess))     msgs=setLocale(sess,getLocaleName(sess));
 else     msgs=(Map<String,Object>)sess.getAttribute(MSG);
    if (null == msgs) {
      Map<String,Map<String,Object>> msgss=getMessageSet();
      if (msgss.size() > 0)       msgs=msgss.values().iterator().next();
    }
    req.setAttribute(MSG,msgs);
  }
  req.setAttribute(""String_Node_Str"",req.getContextPath());
  req.setAttribute(""String_Node_Str"",req);
}"
80487,"/** 
 * 获取整个应用的默认字符串表
 * @param context 上下文
 * @return 字符串表
 */
public static Map<String,String> getDefaultLocaleMessage(ServletContext context){
  Map<String,Map<String,String>> msgss=getMessageSet();
  if (null != msgss)   return msgss.get(DEFAULT_MSGS);
  return null;
}","/** 
 * 获取整个应用的默认字符串表
 * @param context 上下文
 * @return 字符串表
 */
public static Map<String,Object> getDefaultLocaleMessage(ServletContext context){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss)   return msgss.get(DEFAULT_MSGS);
  return null;
}"
80488,"/** 
 * 获取整个应用可用的 Locale 名称集合
 */
public static Set<String> getLocaleNames(ServletContext context){
  Map<String,Map<String,String>> msgss=getMessageSet();
  if (null != msgss)   return msgss.keySet();
  return null;
}","/** 
 * 获取整个应用可用的 Locale 名称集合
 */
public static Set<String> getLocaleNames(ServletContext context){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss)   return msgss.keySet();
  return null;
}"
80489,"/** 
 * 为当前会话设置本地字符串表。如果传入的 localeName 为空，或者不存在该表，则用默认字符串表替代。 执行完毕后，在 session 中会有一个属性（名称请参见 Mvcs.MSGS 定义） <p> 在 jsp 中，你可以用 EL 表达式 ${msgs.xxx} 来直接获取字符串的值。
 * @return 设置的 本地化字符串表
 */
public static Map<String,String> setLocale(HttpSession session,String localeName){
  Map<String,Map<String,String>> msgss=getMessageSet();
  if (null != msgss) {
    Map<String,String> msgs=null;
    if (null != localeName)     msgs=msgss.get(localeName);
    if (null == msgs)     msgs=msgss.get(DEFAULT_MSGS);
    if (null != msgs)     session.setAttribute(MSG,msgs);
    return msgs;
  }
  return null;
}","/** 
 * 为当前会话设置本地字符串表。如果传入的 localeName 为空，或者不存在该表，则用默认字符串表替代。 执行完毕后，在 session 中会有一个属性（名称请参见 Mvcs.MSGS 定义） <p> 在 jsp 中，你可以用 EL 表达式 ${msgs.xxx} 来直接获取字符串的值。
 * @return 设置的 本地化字符串表
 */
public static Map<String,Object> setLocale(HttpSession session,String localeName){
  Map<String,Map<String,Object>> msgss=getMessageSet();
  if (null != msgss) {
    Map<String,Object> msgs=null;
    if (null != localeName)     msgs=msgss.get(localeName);
    if (null == msgs)     msgs=msgss.get(DEFAULT_MSGS);
    if (null != msgs)     session.setAttribute(MSG,msgs);
    return msgs;
  }
  return null;
}"
80490,"public void registerLocation(URL url){
  if (url == null)   return;
  try {
    if (url.toString().endsWith(""String_Node_Str"")) {
      locations.add(ResourceLocation.jar(new JarEntryInfo(url.toString()).getJarPath()));
    }
 else {
      locations.add(ResourceLocation.file(new File(url.toURI())));
    }
  }
 catch (  Throwable e) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + url,e);
  }
}","public void registerLocation(URL url){
  if (url == null)   return;
  try {
    if (url.toString().endsWith(""String_Node_Str"")) {
      locations.add(ResourceLocation.jar(url.toString()));
    }
 else {
      locations.add(ResourceLocation.file(new File(url.toURI())));
    }
  }
 catch (  Throwable e) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + url,e);
  }
}"
80491,"private Scans(){
  locations.add(ResourceLocation.file(new File(""String_Node_Str"")));
  registerLocation(Nutz.class);
  try {
    String referPath=""String_Node_Str"";
    Enumeration<URL> urls=getClass().getClassLoader().getResources(referPath);
    while (urls.hasMoreElements()) {
      URL url=urls.nextElement();
      url=new URL(url.toString().substring(0,url.toString().length() - referPath.length() - 2));
      registerLocation(url);
    }
  }
 catch (  IOException e) {
  }
  try {
    String classpath=System.getProperties().getProperty(""String_Node_Str"");
    String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
    for (    String pathZ : paths) {
      if (pathZ.endsWith(""String_Node_Str""))       locations.add(ResourceLocation.jar(pathZ));
 else       locations.add(ResourceLocation.file(new File(pathZ)));
    }
  }
 catch (  Throwable e) {
  }
}","private Scans(){
  locations.add(ResourceLocation.file(new File(""String_Node_Str"")));
  registerLocation(Nutz.class);
  try {
    String referPath=""String_Node_Str"";
    Enumeration<URL> urls=getClass().getClassLoader().getResources(referPath);
    while (urls.hasMoreElements()) {
      URL url=urls.nextElement();
      if (url.toString().contains(""String_Node_Str""))       url=new URL(url.toString().substring(0,url.toString().length() - referPath.length() - 2));
 else       url=new URL(url.toString().substring(0,url.toString().length() - referPath.length()));
      registerLocation(url);
    }
  }
 catch (  IOException e) {
  }
  try {
    String classpath=System.getProperties().getProperty(""String_Node_Str"");
    String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
    for (    String pathZ : paths) {
      if (pathZ.endsWith(""String_Node_Str""))       locations.add(ResourceLocation.jar(pathZ));
 else       locations.add(ResourceLocation.file(new File(pathZ)));
    }
  }
 catch (  Throwable e) {
  }
}"
80492,"public static Set<Class<?>> scanModules(Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  List<Class<?>> list=new LinkedList<Class<?>>();
  list.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      list.add(module);
    }
  }
  Set<Class<?>> modules=new HashSet<Class<?>>();
  if (null != ann && ann.packages() != null && ann.packages().length > 0) {
    for (    String packageName : ann.packages())     scanModuleInPackage(modules,packageName);
  }
  for (  Class<?> type : list) {
    if (scan) {
      URL location=type.getProtectionDomain().getCodeSource().getLocation();
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",location);
      Scans.me().registerLocation(location,""String_Node_Str"");
      scanModuleInPackage(modules,type.getPackage().getName());
    }
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}","public static Set<Class<?>> scanModules(Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  List<Class<?>> list=new LinkedList<Class<?>>();
  list.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      list.add(module);
    }
  }
  Set<Class<?>> modules=new HashSet<Class<?>>();
  if (null != ann && ann.packages() != null && ann.packages().length > 0) {
    for (    String packageName : ann.packages())     scanModuleInPackage(modules,packageName);
  }
  for (  Class<?> type : list) {
    if (scan) {
      URL location=type.getProtectionDomain().getCodeSource().getLocation();
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",location);
      Scans.me().registerLocation(location);
      scanModuleInPackage(modules,type.getPackage().getName());
    }
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}"
80493,"public void registerLocation(URL url,String referPath){
  if (url == null)   return;
  try {
    if (url.toString().contains(""String_Node_Str"")) {
      locations.add(ResourceLocation.jar(new JarEntryInfo(url.toString()).getJarPath()));
    }
 else {
      String root=new File(url.toURI()).getAbsolutePath();
      root=root.substring(0,root.length() - referPath.length());
      locations.add(ResourceLocation.file(new File(root)));
    }
  }
 catch (  Throwable e) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + url,e);
  }
}","public void registerLocation(URL url){
  if (url == null)   return;
  try {
    if (url.toString().endsWith(""String_Node_Str"")) {
      locations.add(ResourceLocation.jar(new JarEntryInfo(url.toString()).getJarPath()));
    }
 else {
      locations.add(ResourceLocation.file(new File(url.toURI())));
    }
  }
 catch (  Throwable e) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + url,e);
  }
}"
80494,"private Scans(){
  locations.add(ResourceLocation.file(new File(""String_Node_Str"")));
  registerLocation(Nutz.class);
  try {
    String referPath=""String_Node_Str"";
    Enumeration<URL> urls=getClass().getClassLoader().getResources(referPath);
    while (urls.hasMoreElements()) {
      registerLocation(urls.nextElement(),referPath);
    }
  }
 catch (  IOException e) {
  }
  try {
    String classpath=System.getProperties().getProperty(""String_Node_Str"");
    String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
    for (    String pathZ : paths) {
      if (pathZ.endsWith(""String_Node_Str""))       locations.add(ResourceLocation.jar(pathZ));
 else       locations.add(ResourceLocation.file(new File(pathZ)));
    }
  }
 catch (  Throwable e) {
  }
}","private Scans(){
  locations.add(ResourceLocation.file(new File(""String_Node_Str"")));
  registerLocation(Nutz.class);
  try {
    String referPath=""String_Node_Str"";
    Enumeration<URL> urls=getClass().getClassLoader().getResources(referPath);
    while (urls.hasMoreElements()) {
      URL url=urls.nextElement();
      url=new URL(url.toString().substring(0,url.toString().length() - referPath.length() - 2));
      registerLocation(url);
    }
  }
 catch (  IOException e) {
  }
  try {
    String classpath=System.getProperties().getProperty(""String_Node_Str"");
    String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
    for (    String pathZ : paths) {
      if (pathZ.endsWith(""String_Node_Str""))       locations.add(ResourceLocation.jar(pathZ));
 else       locations.add(ResourceLocation.file(new File(pathZ)));
    }
  }
 catch (  Throwable e) {
  }
}"
80495,"@Override protected String evalFieldType(MappingField mf){
switch (mf.getColumnType()) {
case INT:
    if (mf.getWidth() > 0)     return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str"";
  return ""String_Node_Str"";
case FLOAT:
if (mf.getWidth() > 0 && mf.getPrecision() > 0) {
  return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str""+ mf.getPrecision()+ ""String_Node_Str"";
}
if (mf.getTypeMirror().isDouble()) return ""String_Node_Str"";
return ""String_Node_Str"";
case BINARY:
return ""String_Node_Str"";
}
return super.evalFieldType(mf);
}","@Override protected String evalFieldType(MappingField mf){
switch (mf.getColumnType()) {
case INT:
    if (mf.getWidth() > 0)     return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str"";
  return ""String_Node_Str"";
case FLOAT:
if (mf.getWidth() > 0 && mf.getPrecision() > 0) {
  return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str""+ mf.getPrecision()+ ""String_Node_Str"";
}
if (mf.getTypeMirror().isDouble()) return ""String_Node_Str"";
return ""String_Node_Str"";
case BINARY:
return ""String_Node_Str"";
case DATETIME:
return ""String_Node_Str"";
}
return super.evalFieldType(mf);
}"
80496,"public JarResourceLocation(String jarPath){
  this.jarPath=jarPath;
  try {
    ZipInputStream zis=Scans.makeZipInputStream(jarPath);
    ZipEntry ens=null;
    while (null != (ens=zis.getNextEntry())) {
      if (ens.isDirectory())       continue;
      names.add(ens.getName());
    }
    zis.close();
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"" + jarPath + ""String_Node_Str"",e);
  }
}","public JarResourceLocation(String jarPath){
  this.jarPath=jarPath;
  try {
    ZipInputStream zis=Scans.makeZipInputStream(jarPath);
    ZipEntry ens=null;
    while (null != (ens=zis.getNextEntry())) {
      if (ens.isDirectory())       continue;
      names.add(ens.getName());
    }
    zis.close();
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}"
80497,"public static ResourceLocation file(File root){
  return new FileSystemResourceLocation(root.getAbsoluteFile());
}","public static ResourceLocation file(File root){
  if (!root.exists())   return new ErrorResourceLocation(root);
  try {
    return new FileSystemResourceLocation(root.getAbsoluteFile());
  }
 catch (  Exception e) {
    return new ErrorResourceLocation(root);
  }
}"
80498,"public void scan(String base,Pattern regex,List<NutResource> list){
  try {
    for (    String ensName : names) {
      String name=ensName;
      if (name.contains(""String_Node_Str""))       name=name.substring(name.lastIndexOf('/') + 1);
      if (ensName.startsWith(base) && (null == regex || regex.matcher(name).find())) {
        list.add(Scans.makeJarNutResource(jarPath,ensName,base));
      }
    }
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"" + jarPath + ""String_Node_Str"",e);
  }
}","public void scan(String base,Pattern regex,List<NutResource> list){
  for (  String ensName : names) {
    String name=ensName;
    if (name.contains(""String_Node_Str""))     name=name.substring(name.lastIndexOf('/') + 1);
    if (ensName.startsWith(base) && (null == regex || regex.matcher(name).find())) {
      try {
        list.add(Scans.makeJarNutResource(jarPath,ensName,base));
      }
 catch (      IOException e) {
        if (log.isInfoEnabled())         log.info(""String_Node_Str"" + jarPath,e);
      }
    }
  }
}"
80499,"public static ResourceLocation jar(String jarPath){
  return new JarResourceLocation(jarPath);
}","public static ResourceLocation jar(String jarPath){
  try {
    return new JarResourceLocation(jarPath);
  }
 catch (  Exception e) {
    return new ErrorResourceLocation(jarPath);
  }
}"
80500,"protected void scanClasspath(String src,Pattern regex,List<NutResource> list){
  String classpath=System.getProperties().getProperty(""String_Node_Str"");
  if (log.isInfoEnabled())   log.info(""String_Node_Str"" + classpath);
  String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
  for (  String pathZ : paths) {
    if (pathZ.endsWith(""String_Node_Str""))     list.addAll(scanInJar(checkSrc(src),regex,pathZ));
 else     list.addAll(scanInDir(regex,new File(pathZ + ""String_Node_Str"" + src),true));
  }
}","protected void scanClasspath(String src,Pattern regex,List<NutResource> list){
  try {
    String classpath=System.getProperties().getProperty(""String_Node_Str"");
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + classpath);
    String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
    for (    String pathZ : paths) {
      if (pathZ.endsWith(""String_Node_Str""))       list.addAll(scanInJar(checkSrc(src),regex,pathZ));
 else       list.addAll(scanInDir(regex,new File(pathZ + ""String_Node_Str"" + src),true));
    }
  }
 catch (  Throwable e) {
  }
  try {
    Enumeration<URL> urls=getClass().getClassLoader().getResources(""String_Node_Str"");
    while (urls.hasMoreElements()) {
      list.addAll(scanInJar(src,regex,new JarEntryInfo(urls.nextElement().toString()).getJarPath()));
    }
  }
 catch (  Throwable e) {
  }
}"
80501,"public List<NutResource> list(String src,String filter){
  final List<NutResource> list=new LinkedList<NutResource>();
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  File f=Files.findFile(src);
  if (f != null && f.exists()) {
    if (f.isFile())     list.addAll(scanInDir(regex,f.getParentFile(),ignoreHidden));
 else     list.addAll(scanInDir(regex,f,ignoreHidden));
  }
 else {
    String path=Disks.absolute(src,getClass().getClassLoader(),Encoding.defaultEncoding());
    if (null != path) {
      f=new File(path);
      if (!path.contains(""String_Node_Str"")) {
        int pos=path.lastIndexOf(src);
        if (pos > 0)         list.addAll(scanInDir(regex,f,ignoreHidden));
      }
 else {
        JarEntryInfo jeInfo=new JarEntryInfo(path);
        list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
      }
    }
 else {
      try {
        Enumeration<URL> en=getClass().getClassLoader().getResources(src);
        if (en != null) {
          while (en.hasMoreElements()) {
            JarEntryInfo jeInfo=new JarEntryInfo(en.nextElement().getPath());
            list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
          }
        }
      }
 catch (      Throwable e) {
        e.printStackTrace();
      }
    }
  }
  if (list.isEmpty())   scanClasspath(src,regex,list);
  return list;
}","public List<NutResource> list(String src,String filter){
  final List<NutResource> list=new LinkedList<NutResource>();
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  File f=Files.findFile(src);
  if (f != null && f.exists()) {
    if (f.isFile())     list.addAll(scanInDir(regex,f.getParentFile(),ignoreHidden));
 else     list.addAll(scanInDir(regex,f,ignoreHidden));
  }
 else {
    String path=Disks.absolute(src,getClass().getClassLoader(),Encoding.defaultEncoding());
    if (null != path) {
      f=new File(path);
      if (!path.contains(""String_Node_Str"")) {
        int pos=path.lastIndexOf(src);
        if (pos > 0)         list.addAll(scanInDir(regex,f,ignoreHidden));
      }
 else {
        JarEntryInfo jeInfo=new JarEntryInfo(path);
        list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
      }
    }
 else {
      try {
        Enumeration<URL> en=getClass().getClassLoader().getResources(src);
        if (en != null) {
          while (en.hasMoreElements()) {
            JarEntryInfo jeInfo=new JarEntryInfo(en.nextElement().getPath());
            list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
          }
        }
      }
 catch (      Throwable e) {
        e.printStackTrace();
      }
    }
  }
  scanClasspath(src,regex,list);
  return list;
}"
80502,"public AbstractNutConfig(ServletContext context){
  Scans.me().init(context);
}","public AbstractNutConfig(ServletContext context){
  Scans.me().init(context);
  Json.clearEntityCache();
}"
80503,"private void enhandMethod(){
  for (  Method method : methodArray) {
    String methodName=method.getName();
    String methodDesc=Type.getMethodDescriptor(method);
    int methodAccess=getAccess(method.getModifiers());
    MethodVisitor mv=cw.visitMethod(methodAccess,methodName,methodDesc,null,convertExp(method.getExceptionTypes()));
    int methodIndex=findMethodIndex(methodName,methodDesc,methodArray);
    new AopMethodAdapter(mv,methodAccess,methodName,methodDesc,methodIndex,myName,enhancedSuperName).visitCode();
  }
}","private void enhandMethod(){
  for (  Method method : methodArray) {
    String methodName=method.getName();
    String methodDesc=Type.getMethodDescriptor(method);
    int methodAccess=getAccess(method.getModifiers());
    MethodVisitor mv=cw.visitMethod(methodAccess,methodName,methodDesc,null,convertExp(method.getExceptionTypes()));
    int methodIndex=findMethodIndex(methodName,methodDesc,methodArray);
    AopMethodAdapter adapter=new AopMethodAdapter(mv,methodAccess,methodName,methodDesc,methodIndex,myName,enhancedSuperName);
    adapter.visitCode();
    adapter.visitAttribute();
  }
}"
80504,"ClassY(Class<?> klass,String myName,Method[] methodArray,Constructor<?>[] constructors){
  this.myName=myName.replace('.','/');
  this.enhancedSuperName=klass.getName().replace('.','/');
  this.cw=new ClassWriter(ClassWriter.COMPUTE_FRAMES);
  cw.visit(AsmClassAgent.CLASS_LEVEL,ACC_PUBLIC,this.myName,null,enhancedSuperName,getParentInterfaces(klass));
  this.methodArray=methodArray;
  this.constructors=constructors;
}","ClassY(Class<?> klass,String myName,Method[] methodArray,Constructor<?>[] constructors){
  this.myName=myName.replace('.','/');
  this.enhancedSuperName=klass.getName().replace('.','/');
  this.cw=new ClassWriter(ClassWriter.COMPUTE_FRAMES);
  cw.visit(AsmClassAgent.CLASS_LEVEL,ACC_PUBLIC,this.myName,null,enhancedSuperName,getParentInterfaces(klass));
  this.methodArray=methodArray;
  this.constructors=constructors;
  this.superClass=klass;
}"
80505,"byte[] toByteArray(){
  addField();
  addConstructors();
  addAopMethods();
  enhandMethod();
  return cw.toByteArray();
}","byte[] toByteArray(){
  addField();
  addConstructors();
  addAopMethods();
  enhandMethod();
  cw.visitSource(superClass.getSimpleName() + ""String_Node_Str"",null);
  return cw.toByteArray();
}"
80506,"/** 
 * Constructs a new empty attribute.
 * @param type the type of the attribute.
 */
protected Attribute(final String type){
  this.type=type;
}","/** 
 * Constructs a new empty attribute.
 * @param type the type of the attribute.
 */
public Attribute(final String type){
  this.type=type;
}"
80507,"/** 
 * 为一次 HTTP 请求，创建一个可以被表达式引擎接受的上下文对象
 * @param req HTTP 请求对象
 * @param obj 入口函数的返回值
 * @return 上下文对象
 */
@SuppressWarnings(""String_Node_Str"") public static Context createContext(HttpServletRequest req,Object obj){
  Context context=Lang.context();
  Object globalContext=Mvcs.getServletContext().getAttribute(Loading.CONTEXT_NAME);
  if (globalContext != null) {
    context.putAll((Context)globalContext);
  }
  Map<String,Object> a=new HashMap<String,Object>();
  for (Enumeration<String> en=req.getAttributeNames(); en.hasMoreElements(); ) {
    String tem=en.nextElement();
    a.put(tem,req.getAttribute(tem));
  }
  context.set(""String_Node_Str"",a);
  Map<String,String> p=new HashMap<String,String>();
  for (  Object o : req.getParameterMap().keySet()) {
    String key=(String)o;
    String value=req.getParameter(key);
    p.put(key,value);
    context.set(key,value);
  }
  context.set(""String_Node_Str"",p);
  Map<String,String> u=new HashMap<String,String>();
  AtMap at=Mvcs.getAtMap();
  if (at != null) {
    for (    Object o : at.keys()) {
      String key=(String)o;
      u.put(key,at.get(key));
    }
    context.set(""String_Node_Str"",u);
  }
  if (null != obj)   context.set(ViewProcessor.DEFAULT_ATTRIBUTE,obj);
  return context;
}","/** 
 * 为一次 HTTP 请求，创建一个可以被表达式引擎接受的上下文对象
 * @param req HTTP 请求对象
 * @param obj 入口函数的返回值
 * @return 上下文对象
 */
@SuppressWarnings(""String_Node_Str"") public static Context createContext(HttpServletRequest req,Object obj){
  Context context=Lang.context();
  Object globalContext=Mvcs.getServletContext().getAttribute(Loading.CONTEXT_NAME);
  if (globalContext != null) {
    context.putAll((Context)globalContext);
  }
  Map<String,Object> req_attr=new HashMap<String,Object>();
  for (Enumeration<String> en=req.getAttributeNames(); en.hasMoreElements(); ) {
    String tem=en.nextElement();
    req_attr.put(tem,req.getAttribute(tem));
  }
  context.set(""String_Node_Str"",req_attr);
  context.set(""String_Node_Str"",req_attr);
  Map<String,Object> session_attr=new HashMap<String,Object>();
  for (Enumeration<String> en=req.getSession().getAttributeNames(); en.hasMoreElements(); ) {
    String tem=en.nextElement();
    session_attr.put(tem,req.getAttribute(tem));
  }
  context.set(""String_Node_Str"",session_attr);
  Map<String,String> p=new HashMap<String,String>();
  for (  Object o : req.getParameterMap().keySet()) {
    String key=(String)o;
    String value=req.getParameter(key);
    p.put(key,value);
    context.set(key,value);
  }
  context.set(""String_Node_Str"",p);
  Map<String,String> u=new HashMap<String,String>();
  AtMap at=Mvcs.getAtMap();
  if (at != null) {
    for (    Object o : at.keys()) {
      String key=(String)o;
      u.put(key,at.get(key));
    }
    context.set(""String_Node_Str"",u);
  }
  if (null != obj)   context.set(ViewProcessor.DEFAULT_ATTRIBUTE,obj);
  return context;
}"
80508,"@SuppressWarnings({""String_Node_Str""}) protected static Collection<?> createCollection(Object src,Class<?> toType) throws FailToCastObjectException {
  Collection<?> coll=null;
  try {
    coll=(Collection<Object>)toType.newInstance();
  }
 catch (  Exception e) {
    if (Modifier.isAbstract(toType.getModifiers()) && toType.isAssignableFrom(ArrayList.class)) {
      coll=new ArrayList<Object>(Array.getLength(src));
    }
    if (null == coll)     throw new FailToCastObjectException(String.format(""String_Node_Str"",toType.getName()),e);
  }
  return coll;
}","@SuppressWarnings({""String_Node_Str""}) protected static Collection<?> createCollection(Object src,Class<?> toType) throws FailToCastObjectException {
  Collection<?> coll=null;
  try {
    coll=(Collection<Object>)toType.newInstance();
  }
 catch (  Exception e) {
    if (Modifier.isAbstract(toType.getModifiers())) {
      if (toType.isAssignableFrom(ArrayList.class)) {
        coll=new ArrayList<Object>(Array.getLength(src));
      }
 else       if (toType.isAssignableFrom(HashSet.class)) {
        coll=new HashSet<Object>();
      }
    }
    if (null == coll)     throw new FailToCastObjectException(String.format(""String_Node_Str"",toType.getName()),e);
  }
  return coll;
}"
80509,"/** 
 * 检查一个字符串是否为合法的电子邮件地址
 * @param input 需要检查的字符串
 * @return true 如果是有效的邮箱地址
 */
public static synchronized final boolean isEmail(CharSequence input){
  return email_Pattern.matcher(input).matches();
}","/** 
 * 检查一个字符串是否为合法的电子邮件地址
 * @param input 需要检查的字符串
 * @return true 如果是有效的邮箱地址
 */
public static final boolean isEmail(CharSequence input){
  if (Strings.isBlank(input))   return false;
  try {
    new Email(input.toString());
    return true;
  }
 catch (  Exception e) {
  }
  return false;
}"
80510,"/** 
 * 加载指定文件/文件夹的Properties文件,合并成一个Properties对象 <p> <b style=color:red>如果有重复的key,请务必注意加载的顺序!!<b/>
 * @param paths 需要加载的Properties文件路径
 */
public void setPaths(String... paths){
  mp=new MultiLineProperties();
  List<NutResource> list=Scans.me().loadResource(""String_Node_Str"",paths);
  try {
    if (utf8)     for (    NutResource nr : list)     mp.load(nr.getReader());
 else {
      Properties p=new Properties();
      for (      NutResource nr : list) {
        p.load(nr.getInputStream());
      }
      mp.putAll(p);
    }
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}","/** 
 * 加载指定文件/文件夹的Properties文件,合并成一个Properties对象 <p> <b style=color:red>如果有重复的key,请务必注意加载的顺序!!<b/>
 * @param paths 需要加载的Properties文件路径
 */
public void setPaths(String... paths){
  mp=new MultiLineProperties();
  List<NutResource> list=Scans.me().loadResource(""String_Node_Str"",paths);
  try {
    if (utf8)     for (    NutResource nr : list)     mp.load(nr.getReader(),false);
 else {
      Properties p=new Properties();
      for (      NutResource nr : list) {
        p.load(nr.getInputStream());
      }
      mp.putAll(p);
    }
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}"
80511,"public List<String> keys(){
  return keys;
}","public List<String> keys(){
  return new ArrayList<String>(maps.keySet());
}"
80512,"public MultiLineProperties(){
  maps=new HashMap<String,String>();
  keys=new LinkedList<String>();
}","public MultiLineProperties(){
  maps=new HashMap<String,String>();
}"
80513,"public synchronized void load(Reader reader) throws IOException {
  BufferedReader tr=null;
  if (reader instanceof BufferedReader)   tr=(BufferedReader)reader;
 else   tr=new BufferedReader(reader);
  this.clear();
  String s;
  while (null != (s=tr.readLine())) {
    if (Strings.isBlank(s))     continue;
    if (s.length() > 0 && s.trim().charAt(0) == '#')     continue;
    int pos;
    char c='0';
    for (pos=0; pos < s.length(); pos++) {
      c=s.charAt(pos);
      if (c == '=' || c == ':')       break;
    }
    if (c == '=') {
      String name=s.substring(0,pos);
      maps.put(name,s.substring(pos + 1));
      keys.add(name);
    }
 else     if (c == ':') {
      String name=s.substring(0,pos);
      StringBuffer sb=new StringBuffer();
      sb.append(s.substring(pos + 1));
      String ss;
      while (null != (ss=tr.readLine())) {
        if (ss.length() > 0 && ss.charAt(0) == '#')         break;
        sb.append(""String_Node_Str"" + ss);
      }
      maps.put(name,sb.toString());
      keys.add(name);
      if (null == ss)       return;
    }
 else {
      maps.put(s,null);
      keys.add(s);
    }
  }
}","public synchronized void load(Reader reader,boolean clear) throws IOException {
  if (clear)   this.clear();
  BufferedReader tr=null;
  if (reader instanceof BufferedReader)   tr=(BufferedReader)reader;
 else   tr=new BufferedReader(reader);
  String s;
  while (null != (s=tr.readLine())) {
    if (Strings.isBlank(s))     continue;
    if (s.length() > 0 && s.trim().charAt(0) == '#')     continue;
    int pos;
    char c='0';
    for (pos=0; pos < s.length(); pos++) {
      c=s.charAt(pos);
      if (c == '=' || c == ':')       break;
    }
    if (c == '=') {
      String name=s.substring(0,pos);
      maps.put(name,s.substring(pos + 1));
    }
 else     if (c == ':') {
      String name=s.substring(0,pos);
      StringBuffer sb=new StringBuffer();
      sb.append(s.substring(pos + 1));
      String ss;
      while (null != (ss=tr.readLine())) {
        if (ss.length() > 0 && ss.charAt(0) == '#')         break;
        sb.append(""String_Node_Str"" + ss);
      }
      maps.put(name,sb.toString());
      if (null == ss)       return;
    }
 else {
      maps.put(s,null);
    }
  }
}"
80514,"public void execute(final Sql... sqls){
  _exec(sqls);
}","public void execute(final Sql... sqls){
  for (  Sql sql : sqls)   expert.formatQuery(sql);
  _exec(sqls);
}"
80515,"public void formatQuery(Pojo pojo){
  Pager pager=pojo.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    pojo.insertFirst(Pojos.Items.wrap(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
    pojo.append(Pojos.Items.wrapf(""String_Node_Str"",pager.getOffset() + 1,pager.getOffset() + pager.getPageSize()));
  }
}","public void formatQuery(Sql sql){
  Pager pager=sql.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    String pre=""String_Node_Str"";
    String last=String.format(""String_Node_Str"",pager.getOffset() + 1,pager.getOffset() + pager.getPageSize());
    sql.setSourceSql(pre + sql.getSourceSql() + last);
  }
}"
80516,"public void formatQuery(Pojo pojo){
  Pager pager=pojo.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    pojo.append(Pojos.Items.wrapf(""String_Node_Str"",pager.getPageSize(),pager.getOffset()));
  }
}","public void formatQuery(Sql sql){
  Pager pager=sql.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    sql.setSourceSql(sql.getSourceSql() + String.format(""String_Node_Str"",pager.getPageSize(),pager.getOffset()));
  }
}"
80517,"public void formatQuery(Pojo pojo){
  Pager pager=pojo.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0)   pojo.append(Pojos.Items.wrapf(""String_Node_Str"",pager.getOffset(),pager.getPageSize()));
}","public void formatQuery(Sql sql){
  Pager pager=sql.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0)   sql.setSourceSql(sql.getSourceSql() + String.format(""String_Node_Str"",pager.getOffset(),pager.getPageSize()));
}"
80518,"public void formatQuery(Pojo pojo){
  Pager pager=pojo.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    pojo.insertFirst(Pojos.Items.wrap(""String_Node_Str""));
    pojo.append(Pojos.Items.wrapf(""String_Node_Str"",pager.getOffset() + pager.getPageSize(),pager.getOffset()));
  }
}","@Override public void formatQuery(Sql sql){
  Pager pager=sql.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    String pre=""String_Node_Str"";
    String last=String.format(""String_Node_Str"",pager.getOffset() + pager.getPageSize(),pager.getOffset());
    sql.setSourceSql(pre + sql.getSourceSql() + last);
  }
}"
80519,"public void formatQuery(Pojo pojo){
  Pager pager=pojo.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0)   pojo.append(Pojos.Items.wrapf(""String_Node_Str"",pager.getPageSize(),pager.getOffset()));
}","public void formatQuery(Sql sql){
  Pager pager=sql.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    sql.setSourceSql(sql.getSourceSql() + String.format(""String_Node_Str"",pager.getPageSize(),pager.getOffset()));
  }
}"
80520,"@Override public void formatQuery(Pojo pojo){
  pojo.getContext().setResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
}","@Override public void formatQuery(Sql sql){
  sql.getContext().setResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
}"
80521,"public void formatQuery(Pojo pojo){
  Pager pager=pojo.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    PItem pi=pojo.getItem(0);
    StringBuilder sb=new StringBuilder();
    pi.joinSql(pojo.getEntity(),sb);
    String str=sb.toString();
    if (str.trim().toLowerCase().startsWith(""String_Node_Str"")) {
      pojo.setItem(0,Pojos.Items.wrap(str.substring(6)));
    }
 else     return;
    pojo.insertFirst(Pojos.Items.wrapf(""String_Node_Str"",pager.getOffset() + pager.getPageSize()));
    pojo.append(Pojos.Items.wrapf(""String_Node_Str"",pager.getOffset()));
  }
}","@Override public void formatQuery(Sql sql){
  Pager pager=sql.getContext().getPager();
  if (null != pager && pager.getPageNumber() > 0) {
    if (!sql.getSourceSql().toUpperCase().startsWith(""String_Node_Str""))     return;
    String xSql=sql.getSourceSql().substring(6);
    String pre=String.format(""String_Node_Str"",pager.getOffset() + pager.getPageSize());
    String last=String.format(""String_Node_Str"",pager.getOffset());
    sql.setSourceSql(pre + xSql + last);
  }
}"
80522,"@Override protected String createResultSetMetaSql(Entity<?> en){
  return ""String_Node_Str"" + en.getViewName();
}","protected String createResultSetMetaSql(Entity<?> en){
  return ""String_Node_Str"" + en.getViewName();
}"
80523,"/** 
 * 根据 Dao 查询语句，以及其翻页信息，对其进行格式化
 * @param pojo Dao 语句
 */
void formatQuery(Pojo pojo);","/** 
 * 根据 Dao 查询语句，以及其翻页信息，对其进行格式化
 * @param pojo Dao 语句
 */
void formatQuery(DaoStatement daoStatement);"
80524,"public static PItem cndAuto(Entity<?> en,Object obj){
  obj=Lang.first(obj);
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
throw Lang.makeThrow(""String_Node_Str"",en.getType().getName(),obj);
}
}","public static PItem cndAuto(Entity<?> en,Object obj){
  obj=Lang.first(obj);
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
log.infof(""String_Node_Str"",en.getType().getName(),obj);
return null;
}
}"
80525,"public static PItem cndAuto(Entity<?> en,Object obj){
  obj=Lang.first(obj);
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
log.infof(""String_Node_Str"",en.getType().getName(),obj);
return null;
}
}","public static PItem cndAuto(Entity<?> en,Object obj){
  obj=Lang.first(obj);
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
if (Map.class.isAssignableFrom(en.getType())) {
log.infof(""String_Node_Str"",en.getType().getName(),obj);
return null;
}
throw Lang.makeThrow(""String_Node_Str"",en.getType().getName(),obj);
}
}"
80526,"public static PItem cndAuto(Entity<?> en,Object obj){
  obj=Lang.first(obj);
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
if (Map.class.isAssignableFrom(en.getType())) {
log.infof(""String_Node_Str"",en.getType().getName(),obj);
return null;
}
throw Lang.makeThrow(""String_Node_Str"",en.getType().getName(),obj);
}
}","public static PItem cndAuto(Entity<?> en,Object obj){
  obj=Lang.first(obj);
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
if (Map.class.isAssignableFrom(en.getType())) {
return null;
}
throw Lang.makeThrow(""String_Node_Str"",en.getType().getName(),obj);
}
}"
80527,"public void doLoop(ResultSet rs,SqlContext context) throws SQLException {
  Pager pager=context.getPager();
  if (null == rs)   return;
  if (null == pager || ResultSet.TYPE_FORWARD_ONLY == rs.getType() || pager.getPageNumber() <= 0) {
    if (null != pager && pager.getPageSize() > 0)     rs.setFetchSize(pager.getPageSize());
    while (rs.next()) {
      createObject(++index,rs,context,-1);
    }
  }
 else   if (rs.last()) {
    if (pager.getPageSize() <= 0)     rs.setFetchSize(Pager.DEFAULT_PAGE_SIZE);
 else     if (pager.getPageSize() > Pager.MAX_FETCH_SIZE)     rs.setFetchSize(Pager.MAX_FETCH_SIZE);
 else     rs.setFetchSize(pager.getPageSize());
    int rowCount=rs.getRow();
    LoopScope ls=LoopScope.eval(pager,rowCount);
    if (rs.absolute(ls.start + 1))     for (int i=ls.start; i < ls.max; i++) {
      createObject(++index,rs,context,rowCount);
      if (!rs.next())       break;
    }
  }
}","public void doLoop(ResultSet rs,SqlContext context) throws SQLException {
  Pager pager=context.getPager();
  if (null == rs)   return;
  if (null == pager || ResultSet.TYPE_FORWARD_ONLY == rs.getType() || pager.getPageNumber() <= 0) {
    while (rs.next()) {
      createObject(++index,rs,context,-1);
    }
  }
 else   if (rs.last()) {
    if (pager.getPageSize() <= 0)     rs.setFetchSize(Pager.DEFAULT_PAGE_SIZE);
 else     if (pager.getPageSize() > Pager.MAX_FETCH_SIZE)     rs.setFetchSize(Pager.MAX_FETCH_SIZE);
 else     rs.setFetchSize(pager.getPageSize());
    int rowCount=rs.getRow();
    LoopScope ls=LoopScope.eval(pager,rowCount);
    if (rs.absolute(ls.start + 1))     for (int i=ls.start; i < ls.max; i++) {
      createObject(++index,rs,context,rowCount);
      if (!rs.next())       break;
    }
  }
}"
80528,"public boolean canWork(){
  try {
    Class.forName(""String_Node_Str"",false,Thread.currentThread().getContextClassLoader());
    return true;
  }
 catch (  Throwable e) {
  }
  return false;
}","public boolean canWork(){
  try {
    Class.forName(""String_Node_Str"",false,Log4jLogAdapter.class.getClassLoader());
    return true;
  }
 catch (  Throwable e) {
  }
  return false;
}"
80529,"public void run(DataSource dataSource,ConnCallback callback){
  Transaction t=Trans.get();
  if (null != t) {
    Connection conn=null;
    Savepoint sp=null;
    try {
      conn=t.getConnection(dataSource);
      sp=conn.setSavepoint();
      callback.invoke(conn);
    }
 catch (    Exception e) {
      if (e instanceof DaoException)       if (null != conn && null != e.getCause() && e.getCause() instanceof SQLException) {
        try {
          if (null == sp)           conn.rollback();
 else           conn.rollback(sp);
        }
 catch (        SQLException e1) {
          if (log.isErrorEnabled())           log.error(e1);
        }
      }
      throw new DaoException(e);
    }
  }
 else {
    Connection conn=null;
    boolean old=false;
    try {
      conn=dataSource.getConnection();
      old=conn.getAutoCommit();
      conn.setAutoCommit(false);
      callback.invoke(conn);
      if (!conn.getAutoCommit())       conn.commit();
    }
 catch (    Exception e) {
      try {
        conn.rollback();
      }
 catch (      SQLException e1) {
      }
      throw new DaoException(e);
    }
 finally {
      if (null != conn) {
        try {
          if (old != conn.getAutoCommit())           conn.setAutoCommit(old);
        }
 catch (        SQLException autoE) {
          if (log.isWarnEnabled())           log.warn(""String_Node_Str"" + old + ""String_Node_Str"",autoE);
        }
        try {
          conn.close();
        }
 catch (        SQLException closeE) {
          if (log.isWarnEnabled())           log.warn(""String_Node_Str"",closeE);
        }
      }
    }
  }
}","public void run(DataSource dataSource,ConnCallback callback){
  Transaction t=Trans.get();
  if (null != t) {
    Connection conn=null;
    Savepoint sp=null;
    try {
      conn=t.getConnection(dataSource);
      sp=conn.setSavepoint();
      callback.invoke(conn);
    }
 catch (    Exception e) {
      if (e instanceof DaoException)       if (null != conn && null != e.getCause() && e.getCause() instanceof SQLException) {
        try {
          if (null == sp)           conn.rollback();
 else           conn.rollback(sp);
        }
 catch (        SQLException e1) {
          if (log.isErrorEnabled())           log.error(e1);
        }
      }
      throw new DaoException(e);
    }
  }
 else {
    Connection conn=null;
    boolean old=false;
    try {
      conn=dataSource.getConnection();
      old=conn.getAutoCommit();
      conn.setAutoCommit(false);
      callback.invoke(conn);
      if (!conn.getAutoCommit())       conn.commit();
    }
 catch (    Exception e) {
      try {
        if (conn != null)         conn.rollback();
      }
 catch (      SQLException e1) {
      }
      throw new DaoException(e);
    }
 finally {
      if (null != conn) {
        try {
          if (old != conn.getAutoCommit())           conn.setAutoCommit(old);
        }
 catch (        SQLException autoE) {
          if (log.isWarnEnabled())           log.warn(""String_Node_Str"" + old + ""String_Node_Str"",autoE);
        }
        try {
          conn.close();
        }
 catch (        SQLException closeE) {
          if (log.isWarnEnabled())           log.warn(""String_Node_Str"",closeE);
        }
      }
    }
  }
}"
80530,"public void destroy(){
  if (handler != null)   handler.depose();
  Mvcs.setServletContext(null);
}","public void destroy(){
  Mvcs.resetALL();
  Mvcs.set(selfName,null,null);
  if (handler != null)   handler.depose();
  Mvcs.setServletContext(null);
}"
80531,"public void destroy(){
  if (handler != null)   handler.depose();
}","public void destroy(){
  Mvcs.resetALL();
  Mvcs.set(selfName,null,null);
  if (handler != null)   handler.depose();
  Mvcs.setServletContext(null);
}"
80532,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj){
  resp.setStatus(sc);
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj){
  if (sc >= 400)   try {
    resp.sendError(sc);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
 else   resp.setStatus(sc);
}"
80533,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  addComment(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  dao.execute(createIndexs(en).toArray(new Sql[0]));
  addComment(dao,en);
  return true;
}"
80534,"@Override public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  if (en.getPks().size() > 1 && en.getPkType() == PkType.ID) {
    return false;
  }
  boolean mPks=en.getPks().size() > 1;
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    if (mf.isId() && en.getPkType() == PkType.ID) {
      sb.append(""String_Node_Str"");
      continue;
    }
 else     sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isPk() && !mPks) {
        sb.append(""String_Node_Str"");
      }
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (mPks) {
    sb.append('\n');
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}","@Override public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  if (en.getPks().size() > 1 && en.getPkType() == PkType.ID) {
    return false;
  }
  boolean mPks=en.getPks().size() > 1;
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    if (mf.isId() && en.getPkType() == PkType.ID) {
      sb.append(""String_Node_Str"");
      continue;
    }
 else     sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isPk() && !mPks) {
        sb.append(""String_Node_Str"");
      }
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (mPks) {
    sb.append('\n');
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  dao.execute(createIndexs(en).toArray(new Sql[0]));
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}"
80535,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  addComment(dao,en,COMMENT_COLUMN);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  dao.execute(createIndexs(en).toArray(new Sql[0]));
  createRelation(dao,en);
  addComment(dao,en,COMMENT_COLUMN);
  return true;
}"
80536,"/** 
 * 将一个图片文件读入内存
 * @param imgFile 图片文件
 * @return 图片对象
 */
public static BufferedImage read(File imgFile){
  try {
    return ImageIO.read(imgFile);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}","/** 
 * 将一个图片文件读入内存
 * @param imgFile 图片文件
 * @return 图片对象
 */
public static BufferedImage read(Object img){
  try {
    if (img instanceof File)     return ImageIO.read((File)img);
 else     if (img instanceof URL)     return ImageIO.read((URL)img);
 else     if (img instanceof InputStream)     return ImageIO.read((InputStream)img);
    throw Lang.makeThrow(""String_Node_Str"" + img);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}"
80537,"private void _runPreparedStatement(Connection conn,DaoStatement st,Object[][] paramMatrix) throws SQLException {
  ValueAdaptor[] adaptors=st.getAdaptors();
  if (adaptors.length != paramMatrix[0].length)   throw Lang.makeThrow(""String_Node_Str"");
  boolean statIsClosed=false;
  String sql=st.toPreparedStatement();
  PreparedStatement pstat=null;
  if (log.isDebugEnabled())   log.debug(st);
  try {
    pstat=conn.prepareStatement(sql);
    if (paramMatrix.length == 1) {
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
      }
      pstat.execute();
      st.getContext().setUpdateCount(pstat.getUpdateCount());
      pstat.close();
      statIsClosed=true;
    }
 else {
      boolean oldAutoCommit=conn.getAutoCommit();
      conn.setAutoCommit(false);
      for (      Object[] params : paramMatrix) {
        for (int i=0; i < params.length; i++) {
          adaptors[i].set(pstat,params[i],i + 1);
        }
        pstat.addBatch();
      }
      int[] counts=pstat.executeBatch();
      pstat.close();
      statIsClosed=true;
      conn.commit();
      conn.setAutoCommit(oldAutoCommit);
      int sum=0;
      for (      int i : counts)       sum+=i;
      st.getContext().setUpdateCount(sum);
    }
  }
  finally {
    if (!statIsClosed)     Daos.safeClose(pstat);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}","private void _runPreparedStatement(Connection conn,DaoStatement st,Object[][] paramMatrix) throws SQLException {
  ValueAdaptor[] adaptors=st.getAdaptors();
  if (adaptors.length != paramMatrix[0].length)   throw Lang.makeThrow(""String_Node_Str"");
  boolean statIsClosed=false;
  String sql=st.toPreparedStatement();
  PreparedStatement pstat=null;
  if (log.isDebugEnabled())   log.debug(st);
  try {
    pstat=conn.prepareStatement(sql);
    if (paramMatrix.length == 1) {
      for (int i=0; i < paramMatrix[0].length; i++) {
        adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
      }
      pstat.execute();
      st.getContext().setUpdateCount(pstat.getUpdateCount());
      pstat.close();
      statIsClosed=true;
    }
 else {
      for (      Object[] params : paramMatrix) {
        for (int i=0; i < params.length; i++) {
          adaptors[i].set(pstat,params[i],i + 1);
        }
        pstat.addBatch();
      }
      int[] counts=pstat.executeBatch();
      pstat.close();
      statIsClosed=true;
      int sum=0;
      for (      int i : counts)       sum+=i;
      st.getContext().setUpdateCount(sum);
    }
  }
  finally {
    if (!statIsClosed)     Daos.safeClose(pstat);
  }
  if (log.isTraceEnabled())   log.trace(""String_Node_Str"");
}"
80538,"protected static void scanModuleInPackage(Set<Class<?>> modules,String packageName){
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",packageName);
  List<Class<?>> subs=Scans.me().scanPackage(packageName);
  for (  Class<?> sub : subs) {
    if (isModule(sub)) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",sub.getName());
      modules.add(sub);
    }
 else     if (log.isTraceEnabled()) {
      log.tracef(""String_Node_Str"",sub.getName());
    }
  }
}","protected static void scanModuleInPackage(Set<Class<?>> modules,String packageName){
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",packageName);
  List<Class<?>> subs=Scans.me().scanPackage(packageName);
  checkModule(modules,subs);
}"
80539,"public static Set<Class<?>> scanModules(Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  List<Class<?>> list=new LinkedList<Class<?>>();
  list.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      list.add(module);
    }
  }
  Set<Class<?>> modules=new HashSet<Class<?>>();
  if (null != ann && ann.packages() != null && ann.packages().length > 0) {
    for (    String packageName : ann.packages())     scanModuleInPackage(modules,packageName);
  }
  for (  Class<?> type : list) {
    if (scan)     scanModuleInPackage(modules,type.getPackage().getName());
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}","public static Set<Class<?>> scanModules(Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  List<Class<?>> list=new LinkedList<Class<?>>();
  list.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      list.add(module);
    }
  }
  Set<Class<?>> modules=new HashSet<Class<?>>();
  if (null != ann && ann.packages() != null && ann.packages().length > 0) {
    for (    String packageName : ann.packages())     scanModuleInPackage(modules,packageName);
  }
  for (  Class<?> type : list) {
    if (scan) {
      URL jarLocation=type.getProtectionDomain().getCodeSource().getLocation();
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",jarLocation);
      scanModuleInPackageByJar(jarLocation,modules,type);
    }
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}"
80540,"private <T>Pair2[] findMatchedMethod(Class<T> klass){
  Method[] all=Mirror.me(klass).getAllDeclaredMethodsWithoutTop();
  List<Pair2> p2=new ArrayList<Pair2>();
  for (  Method m : all) {
    int mod=m.getModifiers();
    if (mod == 0 || Modifier.isStatic(mod) || Modifier.isPrivate(mod))     continue;
    ArrayList<MethodInterceptor> mls=new ArrayList<MethodInterceptor>();
    for (    Pair p : pairs)     if (p.matcher.match(m))     mls.add(p.listener);
    if (mls.size() > 0)     p2.add(new Pair2(m,mls));
  }
  return p2.toArray(new Pair2[p2.size()]);
}","private <T>Pair2[] findMatchedMethod(Class<T> klass){
  Method[] all=Mirror.me(klass).getAllDeclaredMethodsWithoutTop();
  List<Pair2> p2=new ArrayList<Pair2>();
  for (  Method m : all) {
    int mod=m.getModifiers();
    if (mod == 0 || Modifier.isStatic(mod) || Modifier.isPrivate(mod) || Modifier.isFinal(mod) || Modifier.isAbstract(mod))     continue;
    ArrayList<MethodInterceptor> mls=new ArrayList<MethodInterceptor>();
    for (    Pair p : pairs)     if (p.matcher.match(m))     mls.add(p.listener);
    if (mls.size() > 0)     p2.add(new Pair2(m,mls));
  }
  return p2.toArray(new Pair2[p2.size()]);
}"
80541,"@Override protected String evalFieldType(MappingField mf){
switch (mf.getColumnType()) {
case INT:
    if (mf.getWidth() > 0)     return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str"";
  return ""String_Node_Str"";
case FLOAT:
if (mf.getWidth() > 0 && mf.getPrecision() > 0) {
  return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str""+ mf.getPrecision()+ ""String_Node_Str"";
}
if (mf.getTypeMirror().isDouble()) return ""String_Node_Str"";
return ""String_Node_Str"";
}
return super.evalFieldType(mf);
}","@Override protected String evalFieldType(MappingField mf){
switch (mf.getColumnType()) {
case INT:
    if (mf.getWidth() > 0)     return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str"";
  return ""String_Node_Str"";
case FLOAT:
if (mf.getWidth() > 0 && mf.getPrecision() > 0) {
  return ""String_Node_Str"" + mf.getWidth() + ""String_Node_Str""+ mf.getPrecision()+ ""String_Node_Str"";
}
if (mf.getTypeMirror().isDouble()) return ""String_Node_Str"";
return ""String_Node_Str"";
case BINARY:
return ""String_Node_Str"";
}
return super.evalFieldType(mf);
}"
80542,"public void set(PreparedStatement stat,Object obj,int i) throws SQLException {
  if (null == obj) {
    stat.setString(i,null);
  }
 else {
    String v=Castors.me().castToString(obj);
    stat.setString(i,v);
  }
}","public void set(PreparedStatement stat,Object obj,int index) throws SQLException {
  if (null == obj) {
    stat.setNull(index,Types.BINARY);
  }
 else {
    stat.setBytes(index,(byte[])obj);
  }
}"
80543,"public static ValueAdaptor getAdaptor(Mirror<?> mirror){
  if (mirror.isStringLike())   return Jdbcs.Adaptor.asString;
  if (mirror.isInt())   return Jdbcs.Adaptor.asInteger;
  if (mirror.isBoolean())   return Jdbcs.Adaptor.asBoolean;
  if (mirror.isLong())   return Jdbcs.Adaptor.asLong;
  if (mirror.isEnum())   return Jdbcs.Adaptor.asEnumChar;
  if (mirror.isChar())   return Jdbcs.Adaptor.asChar;
  if (mirror.isOf(Timestamp.class))   return Jdbcs.Adaptor.asTimestamp;
  if (mirror.isByte())   return Jdbcs.Adaptor.asByte;
  if (mirror.isShort())   return Jdbcs.Adaptor.asShort;
  if (mirror.isFloat())   return Jdbcs.Adaptor.asFloat;
  if (mirror.isDouble())   return Jdbcs.Adaptor.asDouble;
  if (mirror.isOf(BigDecimal.class))   return Jdbcs.Adaptor.asBigDecimal;
  if (mirror.isOf(Calendar.class))   return Jdbcs.Adaptor.asCalendar;
  if (mirror.isOf(java.util.Date.class))   return Jdbcs.Adaptor.asDate;
  if (mirror.isOf(java.sql.Date.class))   return Jdbcs.Adaptor.asSqlDate;
  if (mirror.isOf(java.sql.Time.class))   return Jdbcs.Adaptor.asSqlTime;
  if (mirror.isOf(Blob.class))   return new BlobValueAdaptor(conf.getPool());
  if (mirror.isOf(Clob.class))   return new ClobValueAdaptor(conf.getPool());
  return Jdbcs.Adaptor.asString;
}","public static ValueAdaptor getAdaptor(Mirror<?> mirror){
  if (mirror.isStringLike())   return Jdbcs.Adaptor.asString;
  if (mirror.isInt())   return Jdbcs.Adaptor.asInteger;
  if (mirror.isBoolean())   return Jdbcs.Adaptor.asBoolean;
  if (mirror.isLong())   return Jdbcs.Adaptor.asLong;
  if (mirror.isEnum())   return Jdbcs.Adaptor.asEnumChar;
  if (mirror.isChar())   return Jdbcs.Adaptor.asChar;
  if (mirror.isOf(Timestamp.class))   return Jdbcs.Adaptor.asTimestamp;
  if (mirror.isByte())   return Jdbcs.Adaptor.asByte;
  if (mirror.isShort())   return Jdbcs.Adaptor.asShort;
  if (mirror.isFloat())   return Jdbcs.Adaptor.asFloat;
  if (mirror.isDouble())   return Jdbcs.Adaptor.asDouble;
  if (mirror.isOf(BigDecimal.class))   return Jdbcs.Adaptor.asBigDecimal;
  if (mirror.isOf(Calendar.class))   return Jdbcs.Adaptor.asCalendar;
  if (mirror.isOf(java.util.Date.class))   return Jdbcs.Adaptor.asDate;
  if (mirror.isOf(java.sql.Date.class))   return Jdbcs.Adaptor.asSqlDate;
  if (mirror.isOf(java.sql.Time.class))   return Jdbcs.Adaptor.asSqlTime;
  if (mirror.isOf(Blob.class))   return new BlobValueAdaptor(conf.getPool());
  if (mirror.isOf(Clob.class))   return new ClobValueAdaptor(conf.getPool());
  if (mirror.getType().isArray() && mirror.getType().getComponentType() == byte.class) {
    return Jdbcs.Adaptor.asBytes;
  }
  return Jdbcs.Adaptor.asString;
}"
80544,"public Object get(ResultSet rs,String colName) throws SQLException {
  return rs.getObject(colName);
}","public Object get(ResultSet rs,String colName) throws SQLException {
  return rs.getBytes(colName);
}"
80545,"/** 
 * 判断两个输入流是否严格相等
 */
public static boolean equals(InputStream sA,InputStream sB) throws IOException {
  int dA;
  while ((dA=sA.read()) != -1) {
    if (dA != sB.read())     return false;
  }
  return sB.read() == -1;
}","/** 
 * 判断两个输入流是否严格相等
 */
public static boolean equals(InputStream sA,InputStream sB) throws IOException {
  int dA;
  while ((dA=sA.read()) != -1) {
    int dB=sB.read();
    if (dA != dB)     return false;
  }
  return sB.read() == -1;
}"
80546,"@SuppressWarnings(""String_Node_Str"") public Object invoke(Connection conn,ResultSet rs,Pojo pojo) throws SQLException {
  final Each<Object> each=pojo.getContext().attr(Each.class);
  if (null == each)   return null;
  final Entity<?> en=pojo.getEntity();
  ResultSetLooping ing=new ResultSetLooping(){
    protected boolean createObject(    int index,    ResultSet rs,    SqlContext context,    int rowCount){
      Object obj=en.getObject(rs,context.getFieldMatcher());
      try {
        each.invoke(index,obj,rowCount);
      }
 catch (      LoopException e) {
        throw Lang.wrapThrow(e);
      }
      return false;
    }
  }
;
  try {
    if (each instanceof Loop)     if (!((Loop<?>)each).begin())     return 0;
    ing.doLoop(rs,pojo.getContext());
    if (each instanceof Loop)     ((Loop<?>)each).end();
  }
 catch (  ExitLoop e) {
  }
catch (  LoopException e) {
    throw new SQLException(e.getCause());
  }
  return ing.getIndex() + 1;
}","@SuppressWarnings(""String_Node_Str"") public Object invoke(Connection conn,ResultSet rs,Pojo pojo) throws SQLException {
  final Each<Object> each=pojo.getContext().attr(Each.class);
  if (null == each)   return null;
  final Entity<?> en=pojo.getEntity();
  ResultSetLooping ing=new ResultSetLooping(){
    protected boolean createObject(    int index,    ResultSet rs,    SqlContext context,    int rowCount){
      Object obj=en.getObject(rs,context.getFieldMatcher());
      try {
        each.invoke(index,obj,rowCount);
      }
 catch (      LoopException e) {
        throw Lang.wrapThrow(e);
      }
      return false;
    }
  }
;
  try {
    if (each instanceof Loop)     if (!((Loop<?>)each).begin())     return 0;
    ing.doLoop(rs,pojo.getContext());
    if (each instanceof Loop)     ((Loop<?>)each).end();
  }
 catch (  ExitLoop e) {
  }
catch (  LoopException e) {
    SQLException e2=new SQLException();
    e2.initCause(e.getCause());
    throw e2;
  }
  return ing.getIndex() + 1;
}"
80547,"public SqlExpressionGroup andNotEquals(String name,Object val){
  return and(eq(name,val).not());
}","public SqlExpressionGroup andNotEquals(String name,Object val){
  if (null == val)   return andNotIsNull(name);
  return and(eq(name,val).not());
}"
80548,"public SqlExpressionGroup andEquals(String name,Object val){
  return and(eq(name,val));
}","public SqlExpressionGroup andEquals(String name,Object val){
  if (null == val)   return andIsNull(name);
  return and(eq(name,val));
}"
80549,"public void addComment(Dao dao,Entity<?> en,String commentTable,String commentColumn){
  if (!en.hasTableComment() && !en.hasColumnComment()) {
    return;
  }
  List<Sql> sqls=new ArrayList<Sql>();
  if (en.hasTableComment()) {
    Sql tableCommentSQL=Sqls.create(commentTable);
    tableCommentSQL.vars().set(""String_Node_Str"",en.getTableName()).set(""String_Node_Str"",en.getTableComment());
    sqls.add(tableCommentSQL);
  }
  if (en.hasColumnComment()) {
    for (    MappingField mf : en.getMappingFields()) {
      if (mf.hasColumnComment()) {
        Sql columnCommentSQL=Sqls.create(commentColumn);
        columnCommentSQL.vars().set(""String_Node_Str"",en.getTableName()).set(""String_Node_Str"",mf.getColumnName()).set(""String_Node_Str"",mf.getColumnComment());
        sqls.add(columnCommentSQL);
      }
    }
  }
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
}","public void addComment(Dao dao,Entity<?> en,String commentTable,String commentColumn){
  if (!en.hasTableComment() && !en.hasColumnComment()) {
    return;
  }
  List<Sql> sqls=new ArrayList<Sql>();
  if (en.hasTableComment()) {
    Sql tableCommentSQL=Sqls.create(Strings.isBlank(commentTable) ? DEFAULT_COMMENT_TABLE : commentTable);
    tableCommentSQL.vars().set(""String_Node_Str"",en.getTableName()).set(""String_Node_Str"",en.getTableComment());
    sqls.add(tableCommentSQL);
  }
  if (en.hasColumnComment()) {
    for (    MappingField mf : en.getMappingFields()) {
      if (mf.hasColumnComment()) {
        Sql columnCommentSQL=Sqls.create(Strings.isBlank(commentColumn) ? DEFAULT_COMMENT_COLUMN : commentColumn);
        columnCommentSQL.vars().set(""String_Node_Str"",en.getTableName()).set(""String_Node_Str"",mf.getColumnName()).set(""String_Node_Str"",mf.getColumnComment());
        sqls.add(columnCommentSQL);
      }
    }
  }
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
}"
80550,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  addComment(dao,en,COMMENT_TABLE,COMMENT_COLUMN);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  addComment(dao,en);
  return true;
}"
80551,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
 else       if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  dao.execute(createIndexs(en).toArray(new Sql[0]));
  createRelation(dao,en);
  addComment(dao,en,COMMENT_TABLE,COMMENT_COLUMN);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
 else       if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  dao.execute(createIndexs(en).toArray(new Sql[0]));
  createRelation(dao,en);
  addComment(dao,en);
  return true;
}"
80552,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isPk() && en.getPks().size() == 1)       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isUnsigned())       sb.append(""String_Node_Str"").append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  List<Sql> sqls=new ArrayList<Sql>();
  sqls.add(Sqls.create(sb.toString()));
  List<MappingField> pks=en.getPks();
  if (pks.size() > 1) {
    StringBuilder pkNames=new StringBuilder();
    StringBuilder pkNames2=new StringBuilder();
    for (    MappingField pk : pks) {
      pkNames.append(pk.getColumnName()).append(',');
      pkNames2.append(pk.getColumnName()).append('_');
    }
    pkNames.setLength(pkNames.length() - 1);
    pkNames2.setLength(pkNames2.length() - 1);
    String sql=String.format(""String_Node_Str"",en.getTableName(),pkNames2,pkNames);
    sqls.add(Sqls.create(sql));
  }
  for (  MappingField mf : en.getMappingFields()) {
    if (!mf.isAutoIncreasement())     continue;
    sqls.add(Sqls.create(gSQL(CSEQ,en.getTableName(),mf.getColumnName())));
    sqls.add(Sqls.create(gSQL(CTRI,en.getTableName(),mf.getColumnName())));
  }
  sqls.addAll(createIndexs(en));
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
  createRelation(dao,en);
  addComment(dao,en,COMMENT_TABLE,COMMENT_COLUMN);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isPk() && en.getPks().size() == 1)       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isUnsigned())       sb.append(""String_Node_Str"").append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  List<Sql> sqls=new ArrayList<Sql>();
  sqls.add(Sqls.create(sb.toString()));
  List<MappingField> pks=en.getPks();
  if (pks.size() > 1) {
    StringBuilder pkNames=new StringBuilder();
    StringBuilder pkNames2=new StringBuilder();
    for (    MappingField pk : pks) {
      pkNames.append(pk.getColumnName()).append(',');
      pkNames2.append(pk.getColumnName()).append('_');
    }
    pkNames.setLength(pkNames.length() - 1);
    pkNames2.setLength(pkNames2.length() - 1);
    String sql=String.format(""String_Node_Str"",en.getTableName(),pkNames2,pkNames);
    sqls.add(Sqls.create(sql));
  }
  for (  MappingField mf : en.getMappingFields()) {
    if (!mf.isAutoIncreasement())     continue;
    sqls.add(Sqls.create(gSQL(CSEQ,en.getTableName(),mf.getColumnName())));
    sqls.add(Sqls.create(gSQL(CTRI,en.getTableName(),mf.getColumnName())));
  }
  sqls.addAll(createIndexs(en));
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
  createRelation(dao,en);
  addComment(dao,en);
  return true;
}"
80553,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  addComment(dao,en,COMMENT_COLUMN);
  return true;
}"
80554,"protected String toStatement(Object[][] mtrx,String sql){
  StringBuilder sb=new StringBuilder();
  String[] ss=sql.split(""String_Node_Str"");
  int i;
  for (i=0; i < mtrx[0].length; i++) {
    sb.append(ss[i]);
    sb.append(Sqls.formatFieldValue(mtrx[0][i]));
  }
  if (i < ss.length)   sb.append(ss[i]);
  return sb.toString();
}","protected String toStatement(Object[][] mtrx,String sql){
  StringBuilder sb=new StringBuilder();
  String[] ss=sql.split(""String_Node_Str"");
  int i=0;
  if (mtrx.length > 0) {
    for (; i < mtrx[0].length; i++) {
      sb.append(ss[i]);
      sb.append(Sqls.formatFieldValue(mtrx[0][i]));
    }
  }
  if (i < ss.length)   sb.append(ss[i]);
  return sb.toString();
}"
80555,"public Object[][] getParamMatrix(){
  Object[][] re=new Object[rows.size()][adaptors.length];
  int i=0;
  for (  VarSet row : rows) {
    Object[] cols=re[i++];
    for (    String name : literal.getParamIndexes().names()) {
      Object value=row.get(name);
      int[] is=literal.getParamIndexes().getOrderIndex(name);
      for (      int x : is)       cols[x]=value;
    }
  }
  return re;
}","public Object[][] getParamMatrix(){
  if (rows.size() > 0) {
    VarSet vs=rows.get(rows.size() - 1);
    while (null != vs) {
      if (vs.keys().size() == 0) {
        rows.remove(vs);
        vs=null;
        if (rows.size() > 0)         vs=rows.get(rows.size() - 1);
      }
 else {
        break;
      }
    }
  }
  Object[][] re=new Object[rows.size()][adaptors.length];
  int i=0;
  for (  VarSet row : rows) {
    Object[] cols=re[i++];
    for (    String name : literal.getParamIndexes().names()) {
      Object value=row.get(name);
      int[] is=literal.getParamIndexes().getOrderIndex(name);
      for (      int x : is)       cols[x]=value;
    }
  }
  return re;
}"
80556,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.length() > 0 && path.charAt(0) == '/') {
    path=req.getContextPath() + path;
  }
 else {
    String myPath=req.getPathInfo();
    int pos=myPath.lastIndexOf('/');
    if (pos > 0)     path=myPath.substring(0,pos) + ""String_Node_Str"" + path;
 else     path=""String_Node_Str"" + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.length() > 0 && path.charAt(0) == '/') {
    path=req.getContextPath() + path;
  }
 else {
    String myPath=Mvcs.getRequestPath(req);
    int pos=myPath.lastIndexOf('/');
    if (pos > 0)     path=myPath.substring(0,pos) + ""String_Node_Str"" + path;
 else     path=""String_Node_Str"" + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}"
80557,"@SuppressWarnings(""String_Node_Str"") public Object invoke(Connection conn,ResultSet rs,Pojo pojo) throws SQLException {
  final Each<Object> each=pojo.getContext().attr(Each.class);
  if (null == each)   return null;
  final Entity<?> en=pojo.getEntity();
  ResultSetLooping ing=new ResultSetLooping(){
    protected boolean createObject(    int index,    ResultSet rs,    SqlContext context,    int rowCount){
      Object obj=en.getObject(rs,context.getFieldMatcher());
      try {
        each.invoke(index,obj,rowCount);
      }
 catch (      LoopException e) {
        throw Lang.wrapThrow(e);
      }
      return false;
    }
  }
;
  try {
    ing.doLoop(rs,pojo.getContext());
  }
 catch (  ExitLoop e) {
  }
  return ing.getIndex() + 1;
}","@SuppressWarnings(""String_Node_Str"") public Object invoke(Connection conn,ResultSet rs,Pojo pojo) throws SQLException {
  final Each<Object> each=pojo.getContext().attr(Each.class);
  if (null == each)   return null;
  final Entity<?> en=pojo.getEntity();
  ResultSetLooping ing=new ResultSetLooping(){
    protected boolean createObject(    int index,    ResultSet rs,    SqlContext context,    int rowCount){
      Object obj=en.getObject(rs,context.getFieldMatcher());
      try {
        each.invoke(index,obj,rowCount);
      }
 catch (      LoopException e) {
        throw Lang.wrapThrow(e);
      }
      return false;
    }
  }
;
  try {
    if (each instanceof Loop)     if (!((Loop<?>)each).begin())     return 0;
    ing.doLoop(rs,pojo.getContext());
    if (each instanceof Loop)     ((Loop<?>)each).end();
  }
 catch (  ExitLoop e) {
  }
catch (  LoopException e) {
    throw new SQLException(e.getCause());
  }
  return ing.getIndex() + 1;
}"
80558,"@SuppressWarnings(""String_Node_Str"") public Object invoke(Connection conn,ResultSet rs,Pojo pojo) throws SQLException {
  final Each<Object> each=pojo.getContext().attr(Each.class);
  if (null == each)   return null;
  ResultSetLooping ing=new ResultSetLooping(){
    protected boolean createObject(    int index,    ResultSet rs,    SqlContext context,    int rowCount){
      Object obj=Record.create(rs);
      try {
        each.invoke(index,obj,rowCount);
      }
 catch (      LoopException e) {
        throw Lang.wrapThrow(e);
      }
      return false;
    }
  }
;
  try {
    ing.doLoop(rs,pojo.getContext());
  }
 catch (  ExitLoop e) {
  }
  return ing.getIndex() + 1;
}","@SuppressWarnings(""String_Node_Str"") public Object invoke(Connection conn,ResultSet rs,Pojo pojo) throws SQLException {
  final Each<Object> each=pojo.getContext().attr(Each.class);
  if (null == each)   return null;
  ResultSetLooping ing=new ResultSetLooping(){
    protected boolean createObject(    int index,    ResultSet rs,    SqlContext context,    int rowCount){
      Object obj=Record.create(rs);
      try {
        each.invoke(index,obj,rowCount);
      }
 catch (      LoopException e) {
        throw Lang.wrapThrow(e);
      }
      return false;
    }
  }
;
  try {
    if (each instanceof Loop)     if (!((Loop<?>)each).begin())     return 0;
    ing.doLoop(rs,pojo.getContext());
    if (each instanceof Loop)     ((Loop<?>)each).end();
  }
 catch (  ExitLoop e) {
  }
catch (  LoopException e) {
    throw new SQLException(e.getCause());
  }
  return ing.getIndex() + 1;
}"
80559,"/** 
 * 用回调的方式，遍历一个对象，可以支持遍历 <ul> <li>数组 <li>集合 <li>Map <li>单一元素 </ul>
 * @param obj 对象
 * @param callback 回调
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>void each(Object obj,Each<T> callback){
  if (null == obj || null == callback)   return;
  try {
    Class<T> eType=Mirror.getTypeParam(callback.getClass(),0);
    if (obj.getClass().isArray()) {
      int len=Array.getLength(obj);
      for (int i=0; i < len; i++)       try {
        callback.invoke(i,(T)Array.get(obj,i),len);
      }
 catch (      ContinueLoop e) {
      }
catch (      ExitLoop e) {
        break;
      }
    }
 else     if (obj instanceof Collection) {
      int len=((Collection)obj).size();
      int i=0;
      for (Iterator<T> it=((Collection)obj).iterator(); it.hasNext(); )       try {
        callback.invoke(i++,it.next(),len);
      }
 catch (      ContinueLoop e) {
      }
catch (      ExitLoop e) {
        break;
      }
    }
 else     if (obj instanceof Map) {
      Map map=(Map)obj;
      int len=map.size();
      int i=0;
      if (null != eType && eType != Object.class && eType.isAssignableFrom(Entry.class)) {
        for (        Object v : map.entrySet())         try {
          callback.invoke(i++,(T)v,len);
        }
 catch (        ContinueLoop e) {
        }
catch (        ExitLoop e) {
          break;
        }
      }
 else {
        for (        Object v : map.entrySet())         try {
          callback.invoke(i++,(T)((Entry)v).getValue(),len);
        }
 catch (        ContinueLoop e) {
        }
catch (        ExitLoop e) {
          break;
        }
      }
    }
 else     if (obj instanceof Iterator<?>) {
      Iterator<?> it=(Iterator<?>)obj;
      int i=0;
      while (it.hasNext()) {
        try {
          callback.invoke(i++,(T)it.next(),-1);
        }
 catch (        ContinueLoop e) {
        }
catch (        ExitLoop e) {
          break;
        }
      }
    }
 else     try {
      callback.invoke(0,(T)obj,1);
    }
 catch (    ContinueLoop e) {
    }
catch (    ExitLoop e) {
    }
  }
 catch (  LoopException e) {
    throw Lang.wrapThrow(e.getCause());
  }
}","/** 
 * 用回调的方式，遍历一个对象，可以支持遍历 <ul> <li>数组 <li>集合 <li>Map <li>单一元素 </ul>
 * @param obj 对象
 * @param callback 回调
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>void each(Object obj,Each<T> callback){
  if (null == obj || null == callback)   return;
  try {
    if (callback instanceof Loop)     if (!((Loop)callback).begin())     return;
    Class<T> eType=Mirror.getTypeParam(callback.getClass(),0);
    if (obj.getClass().isArray()) {
      int len=Array.getLength(obj);
      for (int i=0; i < len; i++)       try {
        callback.invoke(i,(T)Array.get(obj,i),len);
      }
 catch (      ContinueLoop e) {
      }
catch (      ExitLoop e) {
        break;
      }
    }
 else     if (obj instanceof Collection) {
      int len=((Collection)obj).size();
      int i=0;
      for (Iterator<T> it=((Collection)obj).iterator(); it.hasNext(); )       try {
        callback.invoke(i++,it.next(),len);
      }
 catch (      ContinueLoop e) {
      }
catch (      ExitLoop e) {
        break;
      }
    }
 else     if (obj instanceof Map) {
      Map map=(Map)obj;
      int len=map.size();
      int i=0;
      if (null != eType && eType != Object.class && eType.isAssignableFrom(Entry.class)) {
        for (        Object v : map.entrySet())         try {
          callback.invoke(i++,(T)v,len);
        }
 catch (        ContinueLoop e) {
        }
catch (        ExitLoop e) {
          break;
        }
      }
 else {
        for (        Object v : map.entrySet())         try {
          callback.invoke(i++,(T)((Entry)v).getValue(),len);
        }
 catch (        ContinueLoop e) {
        }
catch (        ExitLoop e) {
          break;
        }
      }
    }
 else     if (obj instanceof Iterator<?>) {
      Iterator<?> it=(Iterator<?>)obj;
      int i=0;
      while (it.hasNext()) {
        try {
          callback.invoke(i++,(T)it.next(),-1);
        }
 catch (        ContinueLoop e) {
        }
catch (        ExitLoop e) {
          break;
        }
      }
    }
 else     try {
      callback.invoke(0,(T)obj,1);
    }
 catch (    ContinueLoop e) {
    }
catch (    ExitLoop e) {
    }
    if (callback instanceof Loop)     ((Loop)callback).end();
  }
 catch (  LoopException e) {
    throw Lang.wrapThrow(e.getCause());
  }
}"
80560,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.length() > 0 && path.charAt(0) == '/') {
    path=req.getContextPath() + path;
  }
 else {
    String myPath=Mvcs.getRequestPath(req);
    int pos=myPath.lastIndexOf('/');
    if (pos > 0)     path=myPath.substring(0,pos) + ""String_Node_Str"" + path;
 else     path=""String_Node_Str"" + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.length() > 0 && path.charAt(0) == '/') {
    path=req.getContextPath() + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}"
80561,"public int joinParams(Entity<?> en,Object obj,Object[] params,int off){
  List<MappingField> mfs=_mfs(en);
  for (  MappingField mf : mfs)   params[off++]=mf.getValue(obj);
  return off;
}","public int joinParams(Entity<?> en,Object obj,Object[] params,int off){
  List<MappingField> mfs=_mfs(en);
  for (  MappingField mf : mfs) {
    Object v=mf.getValue(obj);
    params[off++]=null == v ? mf.getDefaultValue(obj) : v;
  }
  return off;
}"
80562,"/** 
 * 获取一个目录下所有的文件。隐藏文件会被忽略。
 * @param dir 目录
 * @param suffix 文件后缀名。如果为 null，则获取全部文件
 * @return 文件数组
 */
public static File[] files(File dir,final String suffix){
  return dir.listFiles(new FileFilter(){
    public boolean accept(    File f){
      return !f.isHidden() && f.isFile() && (null == suffix || f.getName().endsWith(suffix));
    }
  }
);
}","/** 
 * 获取一个目录下所有的文件(不递归，仅仅一层)。隐藏文件会被忽略。
 * @param dir 目录
 * @param suffix 文件后缀名。如果为 null，则获取全部文件
 * @return 文件数组
 */
public static File[] files(File dir,final String suffix){
  return dir.listFiles(new FileFilter(){
    public boolean accept(    File f){
      return !f.isHidden() && f.isFile() && (null == suffix || f.getName().endsWith(suffix));
    }
  }
);
}"
80563,"@Test public void update_with_null_links(){
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  p.setLeaderName(""String_Node_Str"");
  dao.updateWith(p,null);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",p.getLeaderName());
}","@Test public void update_with_null_links(){
  pojos.initData();
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  p.setLeaderName(""String_Node_Str"");
  dao.updateWith(p,null);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",p.getLeaderName());
}"
80564,"@Test public void test_updateIgnoreNull_by_list(){
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  p.setLeaderName(""String_Node_Str"");
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  String name=p.getLeaderName();
  assertNotNull(name);
  p.setLeaderName(null);
  int re=dao.updateIgnoreNull(Lang.list(p));
  assertEquals(1,re);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(name,p.getLeaderName());
  p.setLeaderName(null);
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertNull(p.getLeaderName());
}","@Test public void test_updateIgnoreNull_by_list(){
  pojos.initData();
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  p.setLeaderName(""String_Node_Str"");
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  String name=p.getLeaderName();
  assertNotNull(name);
  p.setLeaderName(null);
  int re=dao.updateIgnoreNull(Lang.list(p));
  assertEquals(1,re);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(name,p.getLeaderName());
  p.setLeaderName(null);
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertNull(p.getLeaderName());
}"
80565,"@Test public void test_updateIgnoreNull(){
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  p.setLeaderName(""String_Node_Str"");
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  String name=p.getLeaderName();
  assertNotNull(name);
  p.setLeaderName(null);
  int re=dao.updateIgnoreNull(p);
  assertEquals(1,re);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(name,p.getLeaderName());
  p.setLeaderName(null);
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertNull(p.getLeaderName());
}","@Test public void test_updateIgnoreNull(){
  pojos.initData();
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  p.setLeaderName(""String_Node_Str"");
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  String name=p.getLeaderName();
  assertNotNull(name);
  p.setLeaderName(null);
  int re=dao.updateIgnoreNull(p);
  assertEquals(1,re);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(name,p.getLeaderName());
  p.setLeaderName(null);
  dao.update(p);
  p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertNull(p.getLeaderName());
}"
80566,"@Test public void batch_update_relation(){
  dao.updateRelation(Fighter.class,""String_Node_Str"",Chain.make(""String_Node_Str"",""String_Node_Str""),Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(13,dao.count(""String_Node_Str"",Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
}","@Test public void batch_update_relation(){
  pojos.initData();
  dao.updateRelation(Fighter.class,""String_Node_Str"",Chain.make(""String_Node_Str"",""String_Node_Str""),Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(13,dao.count(""String_Node_Str"",Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
}"
80567,"@Test public void batch_update_partly(){
  int re=dao.update(Fighter.class,Chain.make(""String_Node_Str"",""String_Node_Str""),Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(1,re);
  int maxId=dao.getMaxId(Fighter.class);
  re=dao.update(Fighter.class,Chain.make(""String_Node_Str"",""String_Node_Str""),Cnd.where(""String_Node_Str"",""String_Node_Str"",maxId - 5));
  assertEquals(5,re);
  assertEquals(re,dao.count(Fighter.class,Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
}","@Test public void batch_update_partly(){
  pojos.initData();
  int re=dao.update(Fighter.class,Chain.make(""String_Node_Str"",""String_Node_Str""),Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(1,re);
  int maxId=dao.getMaxId(Fighter.class);
  re=dao.update(Fighter.class,Chain.make(""String_Node_Str"",""String_Node_Str""),Cnd.where(""String_Node_Str"",""String_Node_Str"",maxId - 5));
  assertEquals(5,re);
  assertEquals(re,dao.count(Fighter.class,Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
}"
80568,"@Test public void fetch_by_name_ignorecase(){
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",p.getName());
}","@Test public void fetch_by_name_ignorecase(){
  pojos.initData();
  Platoon p=dao.fetch(Platoon.class,""String_Node_Str"");
  assertEquals(""String_Node_Str"",p.getName());
}"
80569,"@Test public void batch_update_all(){
  dao.update(Fighter.class,Chain.make(""String_Node_Str"",Fighter.TYPE.SU_35.name()),null);
  assertEquals(13,dao.count(Fighter.class,Cnd.where(""String_Node_Str"",""String_Node_Str"",Fighter.TYPE.SU_35.name())));
}","@Test public void batch_update_all(){
  pojos.initData();
  dao.update(Fighter.class,Chain.make(""String_Node_Str"",Fighter.TYPE.SU_35.name()),null);
  assertEquals(13,dao.count(Fighter.class,Cnd.where(""String_Node_Str"",""String_Node_Str"",Fighter.TYPE.SU_35.name())));
}"
80570,"public AtMap(){
  ats=new HashMap<String,String>();
}","public AtMap(){
  ats=new HashMap<String,String>();
  methods=new HashMap<String,Method>();
}"
80571,"public AtMap add(String key,String actionPath){
  if (actionPath.endsWith(""String_Node_Str""))   actionPath=actionPath.substring(0,actionPath.length() - 2);
  ats.put(Strings.trim(key),Strings.trim(actionPath));
  return this;
}","public void add(String key,String actionPath){
  if (actionPath.endsWith(""String_Node_Str""))   actionPath=actionPath.substring(0,actionPath.length() - 2);
  ats.put(Strings.trim(key),Strings.trim(actionPath));
}"
80572,"public void add(ActionChainMaker maker,ActionInfo ai,NutConfig config){
  ActionChain chain=maker.eval(config,ai);
  for (  String path : ai.getPaths()) {
    if (Strings.isBlank(path))     throw new BlankAtException(ai.getModuleType(),ai.getMethod());
    ActionInvoker invoker=map.get(path);
    if (null == invoker) {
      invoker=new ActionInvoker();
      map.put(path,invoker);
      root.add(path,invoker);
    }
    if (ai.isForSpecialHttpMethod()) {
      for (      String httpMethod : ai.getHttpMethods())       invoker.addChain(httpMethod,chain);
    }
 else {
      invoker.setDefaultChain(chain);
    }
    if (log.isDebugEnabled()) {
      String[] paths=ai.getPaths();
      StringBuilder sb=new StringBuilder();
      if (null != paths && paths.length > 0) {
        sb.append(""String_Node_Str"").append(paths[0]).append(""String_Node_Str"");
        for (int i=1; i < paths.length; i++)         sb.append(""String_Node_Str"").append(paths[i]).append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
      Method method=ai.getMethod();
      String str;
      if (null != method)       str=method.getName() + ""String_Node_Str"" + method.getReturnType().getSimpleName();
 else       str=""String_Node_Str"";
      log.debugf(""String_Node_Str"",Strings.alignLeft(sb,30,' '),str,ai.getOkView(),ai.getFailView(),(null == ai.getFilterInfos() ? 0 : ai.getFilterInfos().length),ai.getInputEncoding(),ai.getOutputEncoding());
    }
  }
  if (!Strings.isBlank(ai.getPathKey()))   config.getAtMap().add(ai.getPathKey(),ai.getPaths()[0]);
}","public void add(ActionChainMaker maker,ActionInfo ai,NutConfig config){
  ActionChain chain=maker.eval(config,ai);
  for (  String path : ai.getPaths()) {
    if (Strings.isBlank(path))     throw new BlankAtException(ai.getModuleType(),ai.getMethod());
    ActionInvoker invoker=map.get(path);
    if (null == invoker) {
      invoker=new ActionInvoker();
      map.put(path,invoker);
      root.add(path,invoker);
      config.getAtMap().addMethod(path,ai.getMethod());
    }
    if (ai.isForSpecialHttpMethod()) {
      for (      String httpMethod : ai.getHttpMethods())       invoker.addChain(httpMethod,chain);
    }
 else {
      invoker.setDefaultChain(chain);
    }
    if (log.isDebugEnabled()) {
      String[] paths=ai.getPaths();
      StringBuilder sb=new StringBuilder();
      if (null != paths && paths.length > 0) {
        sb.append(""String_Node_Str"").append(paths[0]).append(""String_Node_Str"");
        for (int i=1; i < paths.length; i++)         sb.append(""String_Node_Str"").append(paths[i]).append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
      Method method=ai.getMethod();
      String str;
      if (null != method)       str=method.getName() + ""String_Node_Str"" + method.getReturnType().getSimpleName();
 else       str=""String_Node_Str"";
      log.debugf(""String_Node_Str"",Strings.alignLeft(sb,30,' '),str,ai.getOkView(),ai.getFailView(),(null == ai.getFilterInfos() ? 0 : ai.getFilterInfos().length),ai.getInputEncoding(),ai.getOutputEncoding());
    }
  }
  if (!Strings.isBlank(ai.getPathKey()))   config.getAtMap().add(ai.getPathKey(),ai.getPaths()[0]);
}"
80573,"public int deleteLinks(Object obj,String regex){
  EntityOperator opt=this._optBy(obj);
  if (null == opt)   return 0;
  opt.entity.visitMany(obj,regex,doDelete(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByLinkedField(opt));
  opt.entity.visitManyMany(obj,regex,doDelete(opt));
  opt.entity.visitOne(obj,regex,doDelete(opt));
  return opt.exec().getUpdateCount();
}","public int deleteLinks(Object obj,final String regex){
  if (null == obj)   return 0;
  final int[] re=new int[1];
  Lang.each(obj,new Each<Object>(){
    public void invoke(    int index,    Object ele,    int length) throws ExitLoop, ContinueLoop, LoopException {
      EntityOperator opt=_optBy(ele);
      if (null == opt)       return;
      opt.entity.visitMany(ele,regex,doDelete(opt));
      opt.entity.visitManyMany(ele,regex,doClearRelationByLinkedField(opt));
      opt.entity.visitManyMany(ele,regex,doDelete(opt));
      opt.entity.visitOne(ele,regex,doDelete(opt));
      re[0]+=opt.exec().getUpdateCount();
    }
  }
);
  return re[0];
}"
80574,"public <T>T clearLinks(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  if (null == opt)   return null;
  opt.entity.visitMany(obj,regex,doClear(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByHostField(opt));
  opt.entity.visitOne(obj,regex,doClear(opt));
  opt.exec();
  return obj;
}","public <T>T clearLinks(T obj,final String regex){
  if (null == obj)   return null;
  Lang.each(obj,new Each<Object>(){
    public void invoke(    int index,    Object ele,    int length) throws ExitLoop, ContinueLoop, LoopException {
      EntityOperator opt=_optBy(ele);
      if (null == opt)       return;
      opt.entity.visitMany(ele,regex,doClear(opt));
      opt.entity.visitManyMany(ele,regex,doClearRelationByHostField(opt));
      opt.entity.visitOne(ele,regex,doClear(opt));
      opt.exec();
    }
  }
);
  return obj;
}"
80575,"public <T>T updateLinks(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  if (null == opt)   return null;
  opt.entity.visitOne(obj,regex,doUpdate(opt));
  opt.entity.visitMany(obj,regex,doUpdate(opt));
  opt.entity.visitManyMany(obj,regex,doUpdate(opt));
  opt.exec();
  return obj;
}","public <T>T updateLinks(T obj,final String regex){
  if (null == obj)   return null;
  Lang.each(obj,new Each<Object>(){
    public void invoke(    int index,    Object ele,    int length) throws ExitLoop, ContinueLoop, LoopException {
      EntityOperator opt=_optBy(ele);
      if (null == opt)       return;
      opt.entity.visitOne(ele,regex,doUpdate(opt));
      opt.entity.visitMany(ele,regex,doUpdate(opt));
      opt.entity.visitManyMany(ele,regex,doUpdate(opt));
      opt.exec();
    }
  }
);
  return obj;
}"
80576,"public <T>T updateWith(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  if (null == opt)   return null;
  opt.entity.visitOne(obj,regex,doUpdate(opt));
  opt.addUpdate();
  opt.entity.visitMany(obj,regex,doUpdate(opt));
  opt.entity.visitManyMany(obj,regex,doUpdate(opt));
  opt.exec();
  return obj;
}","public <T>T updateWith(T obj,final String regex){
  if (null == obj)   return null;
  Lang.each(obj,new Each<Object>(){
    public void invoke(    int index,    Object ele,    int length) throws ExitLoop, ContinueLoop, LoopException {
      EntityOperator opt=_optBy(ele);
      if (null == opt)       return;
      opt.entity.visitOne(ele,regex,doUpdate(opt));
      opt.addUpdate();
      opt.entity.visitMany(ele,regex,doUpdate(opt));
      opt.entity.visitManyMany(ele,regex,doUpdate(opt));
      opt.exec();
    }
  }
);
  return obj;
}"
80577,"public <T>T fetchLinks(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  if (null == opt)   return null;
  opt.entity.visitMany(obj,regex,doFetch(opt));
  opt.entity.visitManyMany(obj,regex,doFetch(opt));
  opt.entity.visitOne(obj,regex,doFetch(opt));
  opt.exec();
  return obj;
}","public <T>T fetchLinks(T obj,final String regex){
  if (null == obj)   return null;
  Lang.each(obj,new Each<Object>(){
    public void invoke(    int index,    Object ele,    int length) throws ExitLoop, ContinueLoop, LoopException {
      EntityOperator opt=_optBy(ele);
      if (null == opt)       return;
      opt.entity.visitMany(ele,regex,doFetch(opt));
      opt.entity.visitManyMany(ele,regex,doFetch(opt));
      opt.entity.visitOne(ele,regex,doFetch(opt));
      opt.exec();
    }
  }
);
  return obj;
}"
80578,"public int deleteWith(Object obj,String regex){
  EntityOperator opt=this._optBy(obj);
  if (null == opt)   return 0;
  opt.entity.visitMany(obj,regex,doDelete(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByLinkedField(opt));
  opt.entity.visitManyMany(obj,regex,doDelete(opt));
  opt.addDeleteSelfOnly();
  opt.entity.visitOne(obj,regex,doDelete(opt));
  return opt.exec().getUpdateCount();
}","public int deleteWith(Object obj,final String regex){
  if (null == obj)   return 0;
  final int[] re=new int[1];
  Lang.each(obj,new Each<Object>(){
    public void invoke(    int index,    Object ele,    int length) throws ExitLoop, ContinueLoop, LoopException {
      EntityOperator opt=_optBy(ele);
      if (null == opt)       return;
      opt.entity.visitMany(ele,regex,doDelete(opt));
      opt.entity.visitManyMany(ele,regex,doClearRelationByLinkedField(opt));
      opt.entity.visitManyMany(ele,regex,doDelete(opt));
      opt.addDeleteSelfOnly();
      opt.entity.visitOne(ele,regex,doDelete(opt));
      re[0]+=opt.exec().getUpdateCount();
    }
  }
);
  return re[0];
}"
80579,"public static Record create(ResultSet rs){
  try {
    Record re=new Record();
    ResultSetMetaData meta=rs.getMetaData();
    int count=meta.getColumnCount();
    for (int i=1; i <= count; i++) {
      String name=meta.getColumnLabel(i);
switch (meta.getColumnType(i)) {
case Types.TIMESTAMP:
{
          re.set(name,re.getTimestamp(name));
          break;
        }
case Types.CLOB:
{
        re.set(name,rs.getString(i));
        break;
      }
default :
    re.set(name,rs.getObject(i));
  break;
}
re.setSqlType(name,meta.getColumnType(i));
}
return re;
}
 catch (SQLException e) {
throw Lang.wrapThrow(e);
}
}","public static Record create(ResultSet rs){
  try {
    Record re=new Record();
    ResultSetMetaData meta=rs.getMetaData();
    int count=meta.getColumnCount();
    for (int i=1; i <= count; i++) {
      String name=meta.getColumnLabel(i);
switch (meta.getColumnType(i)) {
case Types.TIMESTAMP:
{
          re.set(name,rs.getTimestamp(name));
          break;
        }
case Types.CLOB:
{
        re.set(name,rs.getString(i));
        break;
      }
default :
    re.set(name,rs.getObject(i));
  break;
}
re.setSqlType(name,meta.getColumnType(i));
}
return re;
}
 catch (SQLException e) {
throw Lang.wrapThrow(e);
}
}"
80580,"public static Condition format(String format,Object... args){
  return new SimpleCondition(format,args);
}","public static Condition format(String format,Object... args){
  return Strings.isBlank(format) ? null : new SimpleCondition(format,args);
}"
80581,"public static Condition wrap(String sql,Object value){
  return new SimpleCondition(new CharSegment(sql).setBy(value));
}","public static Condition wrap(String sql,Object value){
  return Strings.isBlank(sql) ? null : new SimpleCondition(new CharSegment(sql).setBy(value));
}"
80582,"@Override public Object getValue(Object obj){
  Object value=super.getValue(obj);
  System.out.println(""String_Node_Str"" + value);
  if (value == null)   return getDefaultValue(obj);
  return value;
}","@Override public Object getValue(Object obj){
  Object value=super.getValue(obj);
  if (value == null)   return getDefaultValue(obj);
  return value;
}"
80583,"@Test public void fetch_record(){
  Record re=dao.fetch(""String_Node_Str"",Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Pet pet=re.toPojo(Pet.class);
  assertEquals(5,re.getColumnCount());
  assertEquals(4,pet.getId());
  assertEquals(""String_Node_Str"",pet.getName());
}","@Test public void fetch_record(){
  Record re=dao.fetch(""String_Node_Str"",Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Pet pet=re.toPojo(Pet.class);
  assertEquals(6,re.getColumnCount());
  assertEquals(4,pet.getId());
  assertEquals(""String_Node_Str"",pet.getName());
}"
80584,"@Override protected String evalFieldType(MappingField mf){
  if (mf.getColumnType() == ColType.INT) {
    int width=mf.getWidth();
    if (width <= 0)     return ""String_Node_Str"";
 else     if (width <= 4) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
 else     if (width <= 8) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
  }
 else   if (mf.getColumnType() == ColType.BOOLEAN)   return ""String_Node_Str"";
  return super.evalFieldType(mf);
}","@Override protected String evalFieldType(MappingField mf){
  if (mf.getColumnType() == ColType.INT) {
    int width=mf.getWidth();
    if (width <= 0)     return ""String_Node_Str"";
 else     if (width <= 4) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
 else     if (width <= 8) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
  }
  return super.evalFieldType(mf);
}"
80585,"@SuppressWarnings(""String_Node_Str"") public <T>Mirror<T> getMirror(Class<T> type,String name){
  if (MethodInterceptor.class.isAssignableFrom(type) || type.getName().endsWith(ClassAgent.CLASSNAME_SUFFIX) || AopConfigration.IOCNAME.equals(name)|| AopConfigration.class.isAssignableFrom(type))   return Mirror.me(type);
  try {
    return (Mirror<T>)Mirror.me(cd.load(type.getName() + ClassAgent.CLASSNAME_SUFFIX));
  }
 catch (  ClassNotFoundException e) {
  }
  if (aopConfigration == null)   if (ioc.has(AopConfigration.IOCNAME))   aopConfigration=ioc.get(AopConfigration.class,AopConfigration.IOCNAME);
 else   aopConfigration=new AnnotationAopConfigration();
  List<InterceptorPair> interceptorPairs=aopConfigration.getInterceptorPairList(ioc,type);
  if (interceptorPairs == null || interceptorPairs.size() < 1)   return Mirror.me(type);
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  return Mirror.me(agent.define(cd,type));
}","@SuppressWarnings(""String_Node_Str"") public <T>Mirror<T> getMirror(Class<T> type,String name){
  if (MethodInterceptor.class.isAssignableFrom(type) || type.getName().endsWith(ClassAgent.CLASSNAME_SUFFIX) || AopConfigration.IOCNAME.equals(name)|| AopConfigration.class.isAssignableFrom(type)) {
    return Mirror.me(type);
  }
  try {
    return (Mirror<T>)Mirror.me(cd.load(type.getName() + ClassAgent.CLASSNAME_SUFFIX));
  }
 catch (  ClassNotFoundException e) {
  }
  if (aopConfigration == null)   if (ioc.has(AopConfigration.IOCNAME))   aopConfigration=ioc.get(AopConfigration.class,AopConfigration.IOCNAME);
 else   aopConfigration=new AnnotationAopConfigration();
  List<InterceptorPair> interceptorPairs=aopConfigration.getInterceptorPairList(ioc,type);
  if (interceptorPairs == null || interceptorPairs.size() < 1) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",type);
    return Mirror.me(type);
  }
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  return Mirror.me(agent.define(cd,type));
}"
80586,"public String getDefaultValue(Object obj){
  if (null == defaultValue)   return null;
  String re;
  if (null == obj)   re=defaultValue.toString();
 else   re=defaultValue.render(new EntityObjectContext(getEntity(),obj)).toString();
  return re.replace(""String_Node_Str"",""String_Node_Str"");
}","public String getDefaultValue(Object obj){
  if (null == defaultValue)   return null;
  String re;
  if (null == obj || defaultValue.keyCount() == 0)   re=defaultValue.toString();
 else   re=defaultValue.render(new EntityObjectContext(getEntity(),obj)).toString();
  return re;
}"
80587,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  return true;
}"
80588,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
 else       if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
 else       if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}"
80589,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  if (en.hasMeta(META_ENGINE)) {
    sb.append(""String_Node_Str"" + en.getMeta(META_ENGINE));
  }
  if (en.hasMeta(META_CHARSET)) {
    sb.append(""String_Node_Str"" + en.getMeta(META_CHARSET));
  }
 else {
    sb.append(""String_Node_Str"");
  }
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  if (en.hasMeta(META_ENGINE)) {
    sb.append(""String_Node_Str"" + en.getMeta(META_ENGINE));
  }
  if (en.hasMeta(META_CHARSET)) {
    sb.append(""String_Node_Str"" + en.getMeta(META_CHARSET));
  }
 else {
    sb.append(""String_Node_Str"");
  }
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}"
80590,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isPk() && en.getPks().size() == 1)       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
      if (mf.isUnsigned())       sb.append(""String_Node_Str"").append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  List<Sql> sqls=new ArrayList<Sql>();
  sqls.add(Sqls.create(sb.toString()));
  List<MappingField> pks=en.getPks();
  if (pks.size() > 1) {
    StringBuilder pkNames=new StringBuilder();
    StringBuilder pkNames2=new StringBuilder();
    for (    MappingField pk : pks) {
      pkNames.append(pk.getColumnName()).append(',');
      pkNames2.append(pk.getColumnName()).append('_');
    }
    pkNames.setLength(pkNames.length() - 1);
    pkNames2.setLength(pkNames2.length() - 1);
    String sql=String.format(""String_Node_Str"",en.getTableName(),pkNames2,pkNames);
    sqls.add(Sqls.create(sql));
  }
  for (  MappingField mf : en.getMappingFields()) {
    if (!mf.isAutoIncreasement())     continue;
    sqls.add(Sqls.create(gSQL(CSEQ,en.getTableName(),mf.getColumnName())));
    sqls.add(Sqls.create(gSQL(CTRI,en.getTableName(),mf.getColumnName())));
  }
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isPk() && en.getPks().size() == 1)       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      if (mf.isUnsigned())       sb.append(""String_Node_Str"").append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  List<Sql> sqls=new ArrayList<Sql>();
  sqls.add(Sqls.create(sb.toString()));
  List<MappingField> pks=en.getPks();
  if (pks.size() > 1) {
    StringBuilder pkNames=new StringBuilder();
    StringBuilder pkNames2=new StringBuilder();
    for (    MappingField pk : pks) {
      pkNames.append(pk.getColumnName()).append(',');
      pkNames2.append(pk.getColumnName()).append('_');
    }
    pkNames.setLength(pkNames.length() - 1);
    pkNames2.setLength(pkNames2.length() - 1);
    String sql=String.format(""String_Node_Str"",en.getTableName(),pkNames2,pkNames);
    sqls.add(Sqls.create(sql));
  }
  for (  MappingField mf : en.getMappingFields()) {
    if (!mf.isAutoIncreasement())     continue;
    sqls.add(Sqls.create(gSQL(CSEQ,en.getTableName(),mf.getColumnName())));
    sqls.add(Sqls.create(gSQL(CTRI,en.getTableName(),mf.getColumnName())));
  }
  dao.execute(sqls.toArray(new Sql[sqls.size()]));
  createRelation(dao,en);
  return true;
}"
80591,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    if (mf.isId() && mf.isAutoIncreasement()) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(' ').append(evalFieldType(mf));
      if (mf.isName() && en.getPkType() != PkType.NAME) {
        sb.append(""String_Node_Str"");
      }
 else {
        if (mf.isUnsigned())         sb.append(""String_Node_Str"");
        if (mf.isNotNull())         sb.append(""String_Node_Str"");
        if (mf.isAutoIncreasement())         throw Lang.noImplement();
        if (mf.hasDefaultValue())         sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
      }
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(String.format(""String_Node_Str"",en.getTableName()));
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    if (mf.isId() && mf.isAutoIncreasement()) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(' ').append(evalFieldType(mf));
      if (mf.isName() && en.getPkType() != PkType.NAME) {
        sb.append(""String_Node_Str"");
      }
 else {
        if (mf.isUnsigned())         sb.append(""String_Node_Str"");
        if (mf.isNotNull())         sb.append(""String_Node_Str"");
        if (mf.isAutoIncreasement())         throw Lang.noImplement();
        if (mf.hasDefaultValue())         sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
      }
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(String.format(""String_Node_Str"",en.getTableName()));
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}"
80592,"@Override public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  if (en.getPks().size() > 1 && en.getPkType() == PkType.ID) {
    return false;
  }
  boolean mPks=en.getPks().size() > 1;
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    if (mf.isId() && en.getPkType() == PkType.ID) {
      sb.append(""String_Node_Str"");
      continue;
    }
 else     sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isPk() && !mPks) {
        sb.append(""String_Node_Str"");
      }
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (mPks) {
    sb.append('\n');
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}","@Override public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  if (en.getPks().size() > 1 && en.getPkType() == PkType.ID) {
    return false;
  }
  boolean mPks=en.getPks().size() > 1;
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    if (mf.isId() && en.getPkType() == PkType.ID) {
      sb.append(""String_Node_Str"");
      continue;
    }
 else     sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isPk() && !mPks) {
        sb.append(""String_Node_Str"");
      }
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (mPks) {
    sb.append('\n');
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}"
80593,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isUnsigned())       sb.append(""String_Node_Str"");
      if (mf.isNotNull())       sb.append(""String_Node_Str"");
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(getDefaultValue(mf)).append('\'');
    }
    sb.append(',');
  }
  List<MappingField> pks=en.getPks();
  if (!pks.isEmpty()) {
    sb.append('\n');
    sb.append(""String_Node_Str"");
    for (    MappingField pk : pks) {
      sb.append(pk.getColumnName()).append(',');
    }
    sb.setCharAt(sb.length() - 1,')');
    sb.append(""String_Node_Str"");
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  createRelation(dao,en);
  return true;
}"
80594,"@Override protected String evalFieldType(MappingField mf){
  if (mf.getColumnType() == ColType.INT) {
    int width=mf.getWidth();
    if (width <= 0)     return ""String_Node_Str"";
 else     if (width <= 4) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
 else     if (width <= 8) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
  }
  return super.evalFieldType(mf);
}","@Override protected String evalFieldType(MappingField mf){
  if (mf.getColumnType() == ColType.INT) {
    int width=mf.getWidth();
    if (width <= 0)     return ""String_Node_Str"";
 else     if (width <= 4) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
 else     if (width <= 8) {
      return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + (width * 4) + ""String_Node_Str"";
  }
 else   if (mf.getColumnType() == ColType.BOOLEAN)   return ""String_Node_Str"";
  return super.evalFieldType(mf);
}"
80595,"public void setData(String data){
  this.data=data.getBytes(Encoding.CHARSET_UTF8);
}","public void setData(String data){
  try {
    this.data=data.getBytes(Encoding.UTF8);
  }
 catch (  UnsupportedEncodingException e) {
  }
}"
80596,"public InputStream getInputStream(){
  if (null == data) {
    StringBuilder sb=new StringBuilder();
    for (    String key : params.keySet()) {
      sb.append(key).append('=').append(params.get(key)).append('&');
    }
    sb.setCharAt(sb.length() - 1,'\n');
    byte[] bytes=sb.toString().getBytes(Encoding.CHARSET_UTF8);
    return new ByteInputStream(bytes);
  }
  return null == data ? null : new ByteInputStream(data);
}","public InputStream getInputStream(){
  if (null == data) {
    StringBuilder sb=new StringBuilder();
    for (    String key : params.keySet()) {
      sb.append(key).append('=').append(params.get(key)).append('&');
    }
    sb.setCharAt(sb.length() - 1,'\n');
    byte[] bytes=null;
    try {
      bytes=sb.toString().getBytes(Encoding.UTF8);
    }
 catch (    UnsupportedEncodingException e) {
    }
    return new ByteInputStream(bytes);
  }
  return null == data ? null : new ByteInputStream(data);
}"
80597,"/** 
 * 整合两个整数数组为一个数组
 * @param ary 整数数组
 * @param is 变参
 * @return 新的整合过的数组
 */
public static int[] join(int[] ary,int... is){
  if (null == ary)   return is;
  int[] re=Arrays.copyOf(ary,ary.length + is.length);
  int i=ary.length;
  for (  int num : is)   re[i++]=num;
  return re;
}","/** 
 * 整合两个整数数组为一个数组 <b>这个方法在JDK5不可用!!<b/>
 * @param ary 整数数组
 * @param is 变参
 * @return 新的整合过的数组
 */
public static int[] join(int[] ary,int... is){
  if (null == ary)   return is;
  int[] re=Arrays.copyOf(ary,ary.length + is.length);
  int i=ary.length;
  for (  int num : is)   re[i++]=num;
  return re;
}"
80598,"public void write(String str){
  if (!atom.socket.isClosed())   try {
    atom.ops.write(str.getBytes(Encoding.CHARSET_UTF8));
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}","public void write(String str){
  if (!atom.socket.isClosed())   try {
    atom.ops.write(str.getBytes(Encoding.UTF8));
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}"
80599,"@Test public void test_pathargs(){
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
}","@Test public void test_pathargs(){
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
  get(""String_Node_Str"");
  assertEquals(""String_Node_Str"",resp.getContent());
}"
80600,"public <T>Entity<T> make(Class<T> type){
  NutEntity<T> en=new NutEntity<T>(type);
  TableInfo ti=_createTableInfo(type);
  if (null != expert.getConf()) {
    for (    String key : expert.getConf().keySet())     en.getMetas().put(key,expert.getConf().get(key));
  }
  if (null != ti.annMeta) {
    Map<String,Object> map=Lang.map(ti.annMeta.value());
    for (    Entry<String,Object> entry : map.entrySet()) {
      en.getMetas().put(entry.getKey(),entry.getValue().toString());
    }
  }
  String tableName=null == ti.annTable ? Strings.lowerWord(type.getSimpleName(),'_') : ti.annTable.value();
  String viewName=null == ti.annView ? tableName : ti.annView.value();
  en.setTableName(tableName);
  en.setViewName(viewName);
  boolean shouldUseColumn=false;
  for (  Field field : en.getMirror().getFields()) {
    if (null != field.getAnnotation(Column.class)) {
      shouldUseColumn=true;
      break;
    }
  }
  List<MappingInfo> infos=new ArrayList<MappingInfo>();
  List<LinkInfo> ones=new ArrayList<LinkInfo>();
  List<LinkInfo> manys=new ArrayList<LinkInfo>();
  List<LinkInfo> manymanys=new ArrayList<LinkInfo>();
  for (  Field field : en.getMirror().getFields()) {
    if (null != field.getAnnotation(One.class)) {
      ones.add(_Infos.createLinkInfo(field));
    }
 else     if (null != field.getAnnotation(Many.class)) {
      manys.add(_Infos.createLinkInfo(field));
    }
 else     if (null != field.getAnnotation(ManyMany.class)) {
      manymanys.add(_Infos.createLinkInfo(field));
    }
 else     if (shouldUseColumn && (null == field.getAnnotation(Column.class) && null == field.getAnnotation(Id.class) && null == field.getAnnotation(Name.class))) {
      continue;
    }
 else {
      infos.add(_Infos.createMappingInfo(ti.annPK,field));
    }
  }
  for (  Method method : en.getType().getMethods()) {
    if (null != method.getAnnotation(One.class)) {
      ones.add(_Infos.createLinkInfo(method));
    }
 else     if (null != method.getAnnotation(Many.class)) {
      manys.add(_Infos.createLinkInfo(method));
    }
 else     if (null != method.getAnnotation(ManyMany.class)) {
      manymanys.add(_Infos.createLinkInfo(method));
    }
 else     if (null == method.getAnnotation(Column.class) && null == method.getAnnotation(Id.class) && null == method.getAnnotation(Name.class)) {
      continue;
    }
 else {
      infos.add(_Infos.createMapingInfo(ti.annPK,method));
    }
  }
  for (  MappingInfo info : infos) {
    NutMappingField ef=new NutMappingField(en);
    _evalMappingField(ef,info);
    en.addMappingField(ef);
  }
  holder.set(en);
  for (  LinkInfo li : ones) {
    en.addLinkField(new OneLinkField(en,holder,li));
  }
  for (  LinkInfo li : manys) {
    en.addLinkField(new ManyLinkField(en,holder,li));
  }
  for (  LinkInfo li : manymanys) {
    en.addLinkField(new ManyManyLinkField(en,holder,li));
  }
  en.checkCompositeFields(null == ti.annPK ? null : ti.annPK.value());
  if (null != datasource && null != expert) {
    _checkupEntityFieldsWithDatabase(en);
  }
  _evalFieldMacro(en,infos);
  if (null != ti.annIndexes)   _evalEntityIndexes(en,ti.annIndexes);
  return en;
}","public <T>Entity<T> make(Class<T> type){
  NutEntity<T> en=new NutEntity<T>(type);
  TableInfo ti=_createTableInfo(type);
  if (null != expert.getConf()) {
    for (    String key : expert.getConf().keySet())     en.getMetas().put(key,expert.getConf().get(key));
  }
  if (null != ti.annMeta) {
    Map<String,Object> map=Lang.map(ti.annMeta.value());
    for (    Entry<String,Object> entry : map.entrySet()) {
      en.getMetas().put(entry.getKey(),entry.getValue().toString());
    }
  }
  String tableName=null == ti.annTable ? Strings.lowerWord(type.getSimpleName(),'_') : ti.annTable.value();
  String viewName=null == ti.annView ? tableName : ti.annView.value();
  en.setTableName(tableName);
  en.setViewName(viewName);
  boolean shouldUseColumn=false;
  for (  Field field : en.getMirror().getFields()) {
    if (null != field.getAnnotation(Column.class)) {
      shouldUseColumn=true;
      break;
    }
  }
  List<MappingInfo> infos=new ArrayList<MappingInfo>();
  List<LinkInfo> ones=new ArrayList<LinkInfo>();
  List<LinkInfo> manys=new ArrayList<LinkInfo>();
  List<LinkInfo> manymanys=new ArrayList<LinkInfo>();
  for (  Field field : en.getMirror().getFields()) {
    if (null != field.getAnnotation(One.class)) {
      ones.add(_Infos.createLinkInfo(field));
    }
 else     if (null != field.getAnnotation(Many.class)) {
      manys.add(_Infos.createLinkInfo(field));
    }
 else     if (null != field.getAnnotation(ManyMany.class)) {
      manymanys.add(_Infos.createLinkInfo(field));
    }
 else     if (shouldUseColumn && (null == field.getAnnotation(Column.class) && null == field.getAnnotation(Id.class) && null == field.getAnnotation(Name.class))) {
      continue;
    }
 else {
      infos.add(_Infos.createMappingInfo(ti.annPK,field));
    }
  }
  for (  Method method : en.getType().getMethods()) {
    if (null != method.getAnnotation(One.class)) {
      ones.add(_Infos.createLinkInfo(method));
    }
 else     if (null != method.getAnnotation(Many.class)) {
      manys.add(_Infos.createLinkInfo(method));
    }
 else     if (null != method.getAnnotation(ManyMany.class)) {
      manymanys.add(_Infos.createLinkInfo(method));
    }
 else     if (null == method.getAnnotation(Column.class) && null == method.getAnnotation(Id.class) && null == method.getAnnotation(Name.class)) {
      continue;
    }
 else {
      infos.add(_Infos.createMapingInfo(ti.annPK,method));
    }
  }
  List<MappingInfo> tmp=new ArrayList<MappingInfo>(infos.size());
  MappingInfo miId=null;
  MappingInfo miName=null;
  for (  MappingInfo mi : infos) {
    if (mi.annId != null)     miId=mi;
 else     if (mi.annName != null)     miName=mi;
 else     tmp.add(mi);
  }
  if (miName != null)   tmp.add(0,miName);
  if (miId != null)   tmp.add(0,miId);
  infos=tmp;
  for (  MappingInfo info : infos) {
    NutMappingField ef=new NutMappingField(en);
    _evalMappingField(ef,info);
    en.addMappingField(ef);
  }
  holder.set(en);
  for (  LinkInfo li : ones) {
    en.addLinkField(new OneLinkField(en,holder,li));
  }
  for (  LinkInfo li : manys) {
    en.addLinkField(new ManyLinkField(en,holder,li));
  }
  for (  LinkInfo li : manymanys) {
    en.addLinkField(new ManyManyLinkField(en,holder,li));
  }
  en.checkCompositeFields(null == ti.annPK ? null : ti.annPK.value());
  if (null != datasource && null != expert) {
    _checkupEntityFieldsWithDatabase(en);
  }
  _evalFieldMacro(en,infos);
  if (null != ti.annIndexes)   _evalEntityIndexes(en,ti.annIndexes);
  return en;
}"
80601,"/** 
 * 转换成操作树
 */
private Deque<Object> OperatorTree(Queue<Object> rpn){
  Deque<Object> operand=new LinkedList<Object>();
  while (!rpn.isEmpty()) {
    if (rpn.peek() instanceof Operator) {
      Operator opt=(Operator)rpn.poll();
      opt.wrap(operand);
      operand.addFirst(opt);
      continue;
    }
    if (rpn.peek() instanceof IdentifierObj) {
      ((IdentifierObj)rpn.peek()).setEc(ec);
    }
    operand.addFirst(rpn.poll());
  }
  return operand;
}","/** 
 * 转换成操作树
 */
private LinkedList<Object> OperatorTree(Queue<Object> rpn){
  LinkedList<Object> operand=new LinkedList<Object>();
  while (!rpn.isEmpty()) {
    if (rpn.peek() instanceof Operator) {
      Operator opt=(Operator)rpn.poll();
      opt.wrap(operand);
      operand.addFirst(opt);
      continue;
    }
    if (rpn.peek() instanceof IdentifierObj) {
      ((IdentifierObj)rpn.peek()).setEc(ec);
    }
    operand.addFirst(rpn.poll());
  }
  return operand;
}"
80602,"/** 
 * 计算
 */
private Object calculate(Deque<Object> el2){
  if (el2.peek() instanceof Operator) {
    Operator obj=(Operator)el2.peek();
    return obj.calculate();
  }
  if (el2.peek() instanceof IdentifierObj) {
    return ((IdentifierObj)el2.peek()).fetchVal();
  }
  return el2.peek();
}","/** 
 * 计算
 */
private Object calculate(LinkedList<Object> el2){
  if (el2.peek() instanceof Operator) {
    Operator obj=(Operator)el2.peek();
    return obj.calculate();
  }
  if (el2.peek() instanceof IdentifierObj) {
    return ((IdentifierObj)el2.peek()).fetchVal();
  }
  return el2.peek();
}"
80603,"public synchronized void load(Reader reader) throws IOException {
  BufferedReader tr=null;
  if (reader instanceof BufferedReader)   tr=(BufferedReader)reader;
 else   tr=new BufferedReader(reader);
  this.clear();
  String s;
  while (null != (s=tr.readLine())) {
    if (Strings.isBlank(s))     continue;
    if (s.length() > 0 && s.charAt(0) == '#')     continue;
    int pos;
    char c='0';
    for (pos=0; pos < s.length(); pos++) {
      c=s.charAt(pos);
      if (c == '=' || c == ':')       break;
    }
    if (c == '=') {
      String name=s.substring(0,pos);
      maps.put(name,s.substring(pos + 1));
      keys.add(name);
    }
 else     if (c == ':') {
      String name=s.substring(0,pos);
      StringBuffer sb=new StringBuffer();
      sb.append(s.substring(pos + 1));
      String ss;
      while (null != (ss=tr.readLine())) {
        if (ss.length() > 0 && ss.charAt(0) == '#')         break;
        sb.append(""String_Node_Str"" + ss);
      }
      maps.put(name,sb.toString());
      keys.add(name);
      if (null == ss)       return;
    }
 else {
      maps.put(s,null);
      keys.add(s);
    }
  }
}","public synchronized void load(Reader reader) throws IOException {
  BufferedReader tr=null;
  if (reader instanceof BufferedReader)   tr=(BufferedReader)reader;
 else   tr=new BufferedReader(reader);
  this.clear();
  String s;
  while (null != (s=tr.readLine())) {
    if (Strings.isBlank(s))     continue;
    if (s.length() > 0 && s.trim().charAt(0) == '#')     continue;
    int pos;
    char c='0';
    for (pos=0; pos < s.length(); pos++) {
      c=s.charAt(pos);
      if (c == '=' || c == ':')       break;
    }
    if (c == '=') {
      String name=s.substring(0,pos);
      maps.put(name,s.substring(pos + 1));
      keys.add(name);
    }
 else     if (c == ':') {
      String name=s.substring(0,pos);
      StringBuffer sb=new StringBuffer();
      sb.append(s.substring(pos + 1));
      String ss;
      while (null != (ss=tr.readLine())) {
        if (ss.length() > 0 && ss.charAt(0) == '#')         break;
        sb.append(""String_Node_Str"" + ss);
      }
      maps.put(name,sb.toString());
      keys.add(name);
      if (null == ss)       return;
    }
 else {
      maps.put(s,null);
      keys.add(s);
    }
  }
}"
80604,"public Object parse(Reader reader){
  this.reader=reader;
  try {
    if (!tryNextChar())     return null;
    skipCommentsAndBlank();
    if (cursor == 'v') {
      OUTER:       while (true) {
        nextChar();
switch (cursor) {
case '{':
          break OUTER;
      }
    }
  }
  return parseFromHere();
}
 catch (IOException e) {
  throw Lang.wrapThrow(e);
}
}","public Object parse(Reader reader){
  if (reader == null)   return null;
  this.reader=reader;
  try {
    if (!tryNextChar())     return null;
    skipCommentsAndBlank();
    if (cursor == 'v') {
      OUTER:       while (true) {
        nextChar();
switch (cursor) {
case '{':
          break OUTER;
      }
    }
  }
  return parseFromHere();
}
 catch (IOException e) {
  throw Lang.wrapThrow(e);
}
}"
80605,"@SuppressWarnings(""String_Node_Str"") public void doRun() throws IOException {
  StringBuilder sb=new StringBuilder();
  line=br.readLine();
  while (null != line) {
    sb.append(line).append('\n');
    if (Strings.isBlank(line))     break;
    line=br.readLine();
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + sb);
  try {
    LinkedHashMap<String,Object> map=Json.fromJson(LinkedHashMap.class,sb);
    SocketAction action=saTable.get(map.get(""String_Node_Str"").toString());
    if (null != action) {
      SocketContext context=new SocketContext(this);
      if (action instanceof JsonAction)       ((JsonAction)action).run(map,context);
 else       action.run(context);
    }
 else {
      Writer writer=Streams.utf8w(ops);
      Map<String,Object> x=new HashMap<String,Object>();
      x.put(""String_Node_Str"",false);
      x.put(""String_Node_Str"",""String_Node_Str"");
      Json.toJson(writer,x);
      try {
        writer.close();
      }
 catch (      IOException e) {
        if (log.isWarnEnabled())         log.warn(""String_Node_Str"",e);
      }
    }
  }
 catch (  JsonException e) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"",e.getMessage(),sb);
  }
}","@SuppressWarnings(""String_Node_Str"") public void doRun() throws IOException {
  StringBuilder sb=new StringBuilder();
  line=br.readLine();
  while (null != line) {
    sb.append(line).append('\n');
    if (Strings.isBlank(line))     break;
    line=br.readLine();
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + sb);
  try {
    LinkedHashMap<String,Object> map=Json.fromJson(LinkedHashMap.class,br);
    SocketAction action=saTable.get(map.get(""String_Node_Str"").toString());
    if (null != action) {
      SocketContext context=new SocketContext(this);
      if (action instanceof JsonAction)       ((JsonAction)action).run(map,context);
 else       action.run(context);
    }
 else {
      Writer writer=Streams.utf8w(ops);
      Map<String,Object> x=new HashMap<String,Object>();
      x.put(""String_Node_Str"",false);
      x.put(""String_Node_Str"",""String_Node_Str"");
      Json.toJson(writer,x);
      try {
        writer.close();
      }
 catch (      IOException e) {
        if (log.isWarnEnabled())         log.warn(""String_Node_Str"",e);
      }
    }
  }
 catch (  JsonException e) {
  }
}"
80606,"public static JsonEntityField eval(Mirror<?> mirror,Field fld){
  JsonField jf=fld.getAnnotation(JsonField.class);
  if (null != jf && jf.ignore())   return null;
  JsonEntityField jef=new JsonEntityField();
  jef.injecting=mirror.getInjecting(fld.getName());
  jef.ejecting=mirror.getEjecting(fld.getName());
  jef.genericType=fld.getGenericType();
  if (null != jf && !Strings.isBlank(jf.value()))   jef.name=jf.value();
 else   jef.name=fld.getName();
  return jef;
}","public static JsonEntityField eval(Mirror<?> mirror,Field fld){
  JsonField jf=fld.getAnnotation(JsonField.class);
  if (null != jf && jf.ignore())   return null;
  JsonEntityField jef=new JsonEntityField();
  jef.injecting=mirror.getInjecting(fld.getName());
  jef.genericType=fld.getGenericType();
  if (null != jf && !Strings.isBlank(jf.by()))   jef.ejecting=new EjectBySimpleEL(jf.by());
 else   jef.ejecting=mirror.getEjecting(fld.getName());
  if (null != jf && !Strings.isBlank(jf.value()))   jef.name=jf.value();
 else   jef.name=fld.getName();
  return jef;
}"
80607,"@Test public void test_enum(){
  Random<Color> r=new EnumRandom<Color>(){
  }
;
  Set<Color> re=new HashSet<Color>(Arrays.asList(Color.values()));
  Set<Color> rs=new HashSet<Color>();
  for (int j=0; j < 4; j++) {
    for (int i=0; i < 4; i++)     rs.add(r.next());
    assertTrue(Lang.equals(re,rs));
  }
}","@Ignore(""String_Node_Str"") @Test public void test_enum(){
  Random<Color> r=new EnumRandom<Color>(){
  }
;
  Set<Color> re=new HashSet<Color>(Arrays.asList(Color.values()));
  Set<Color> rs=new HashSet<Color>();
  for (int j=0; j < 4; j++) {
    for (int i=0; i < 4; i++)     rs.add(r.next());
    assertTrue(Lang.equals(re,rs));
  }
}"
80608,"public void visit(final Object obj,final LinkField lnk){
  Object value=lnk.getValue(obj);
  if (Lang.length(value) == 0)   return;
  lnk.updateLinkedField(obj,value);
  final Entity<?> en=lnk.getLinkedEntity();
  Lang.each(value,new Each<Object>(){
    public void invoke(    int i,    Object ele,    int length) throws ExitLoop, LoopException {
      opt.addInsert(en,ele);
      opt.add(Pojos.createRun(new PojoCallback(){
        public Object invoke(        Connection conn,        ResultSet rs,        Pojo pojo) throws SQLException {
          lnk.saveLinkedField(obj,pojo.getOperatingObject());
          return pojo.getOperatingObject();
        }
      }
).setOperatingObject(ele));
    }
  }
);
}","public void visit(final Object obj,final LinkField lnk){
  final Object value=lnk.getValue(obj);
  if (Lang.length(value) == 0)   return;
  opt.add(Pojos.createRun(new PojoCallback(){
    public Object invoke(    Connection conn,    ResultSet rs,    Pojo pojo) throws SQLException {
      lnk.updateLinkedField(obj,value);
      return pojo.getOperatingObject();
    }
  }
).setOperatingObject(obj));
  final Entity<?> en=lnk.getLinkedEntity();
  Lang.each(value,new Each<Object>(){
    public void invoke(    int i,    Object ele,    int length) throws ExitLoop, LoopException {
      opt.addInsert(en,ele);
      opt.add(Pojos.createRun(new PojoCallback(){
        public Object invoke(        Connection conn,        ResultSet rs,        Pojo pojo) throws SQLException {
          lnk.saveLinkedField(obj,pojo.getOperatingObject());
          return pojo.getOperatingObject();
        }
      }
).setOperatingObject(ele));
    }
  }
);
}"
80609,"@Test public void fetch_record(){
  Record re=dao.fetch(""String_Node_Str"",Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Pet pet=re.toPojo(Pet.class);
  assertEquals(4,re.getColumnCount());
  assertEquals(4,pet.getId());
  assertEquals(""String_Node_Str"",pet.getName());
}","@Test public void fetch_record(){
  Record re=dao.fetch(""String_Node_Str"",Cnd.where(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  Pet pet=re.toPojo(Pet.class);
  assertEquals(5,re.getColumnCount());
  assertEquals(4,pet.getId());
  assertEquals(""String_Node_Str"",pet.getName());
}"
80610,"private void parseSp(StringBuilder sb) throws IOException {
  nextChar();
switch (cursor) {
case 'n':
    sb.append('\n');
  break;
case 'r':
sb.append('\r');
break;
case 't':
sb.append('\t');
break;
case '\\':
sb.append('\\');
break;
case '\'':
sb.append('\'');
break;
case '\""':
sb.append('\""');
break;
case 'u':
char[] hex=new char[4];
for (int i=0; i < 4; i++) hex[i]=(char)nextChar();
sb.append((char)Integer.valueOf(new String(hex),16).intValue());
break;
case 'b':
sb.append(' ');
break;
case 'f':
sb.append('\f');
break;
default :
throw unexpectedChar();
}
}","private void parseSp(StringBuilder sb) throws IOException {
  nextChar();
switch (cursor) {
case 'n':
    sb.append('\n');
  break;
case 'r':
sb.append('\r');
break;
case 't':
sb.append('\t');
break;
case '\\':
sb.append('\\');
break;
case '\'':
sb.append('\'');
break;
case '\""':
sb.append('\""');
break;
case '/':
sb.append('/');
break;
case 'u':
char[] hex=new char[4];
for (int i=0; i < 4; i++) hex[i]=(char)nextChar();
sb.append((char)Integer.valueOf(new String(hex),16).intValue());
break;
case 'b':
sb.append(' ');
break;
case 'f':
sb.append('\f');
break;
default :
throw unexpectedChar();
}
}"
80611,"public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  return true;
}","public boolean createEntity(Dao dao,Entity<?> en){
  StringBuilder sb=new StringBuilder(""String_Node_Str"" + en.getTableName() + ""String_Node_Str"");
  for (  MappingField mf : en.getMappingFields()) {
    sb.append('\n').append(mf.getColumnName());
    sb.append(' ').append(evalFieldType(mf));
    if (mf.isName() && en.getPkType() != PkType.NAME) {
      sb.append(""String_Node_Str"");
    }
 else {
      if (mf.isNotNull() || mf.isPk())       sb.append(""String_Node_Str"");
      if (mf.hasDefaultValue())       sb.append(""String_Node_Str"").append(mf.getDefaultValue(null)).append('\'');
      if (mf.isAutoIncreasement())       sb.append(""String_Node_Str"");
      if (mf.isPk() && en.getPks().size() == 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(',');
  }
  sb.setCharAt(sb.length() - 1,')');
  dao.execute(Sqls.create(sb.toString()));
  if (en.getPks().size() > 1) {
    sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(en.getTableName()).append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(""String_Node_Str"").append(mf.getColumnName());
    }
    sb.append(""String_Node_Str"");
    for (    MappingField mf : en.getPks()) {
      sb.append(mf.getColumnName()).append(""String_Node_Str"");
    }
    sb.setCharAt(sb.length() - 1,')');
    dao.execute(Sqls.create(sb.toString()));
  }
  createRelation(dao,en);
  return true;
}"
80612,"@Test public void test_var_in_prev(){
  dao.create(Pet2.class,true);
  if (pojos.dao().meta().isOracle() || pojos.dao().meta().isHsql())   return;
  pojos.initPet();
  Pet2 pet=new Pet2();
  pet.setName(""String_Node_Str"").setAge(10);
  dao.insert(pet);
  assertEquals(""String_Node_Str"",pet.getNickName());
}","@Test public void test_var_in_prev(){
  dao.create(Pet2.class,true);
  if (dao.meta().isOracle() || dao.meta().isHsql() || dao.meta().isDB2())   return;
  pojos.initPet();
  Pet2 pet=new Pet2();
  pet.setName(""String_Node_Str"").setAge(10);
  dao.insert(pet);
  assertEquals(""String_Node_Str"",pet.getNickName());
}"
80613,"@Test public void check_if_support_all_normal_types() throws FailToCastObjectException {
  String d=""String_Node_Str"";
  String t=""String_Node_Str"";
  String dt=d + ""String_Node_Str"" + t;
  Date date=Castors.me().castTo(d,Date.class);
  Time time=Castors.me().castTo(t,Time.class);
  Timestamp ts=Castors.me().castTo(dt,Timestamp.class);
  EntityTypes exp=new EntityTypes();
  exp.name=""String_Node_Str"";
  exp.enum_s=TT.B;
  exp.enum_i=TT.A;
  exp.char_p='G';
  exp.char_obj='O';
  exp.int_p=23;
  exp.int_obj=23;
  exp.float_p=34.67f;
  exp.float_obj=34.68f;
  exp.short_p=6;
  exp.short_obj=6;
  exp.byte_p=2;
  exp.byte_obj=4;
  exp.long_p=56787;
  exp.long_obj=5678L;
  exp.double_p=2.4325243;
  exp.double_obj=3.4325243;
  exp.sqlDate=date;
  exp.sqlTime=time;
  exp.sqlDT=ts;
  dao.insert(exp);
  EntityTypes et=dao.fetch(EntityTypes.class);
  assertEquals(exp.id,et.id);
  Mirror<EntityTypes> me=Mirror.me(EntityTypes.class);
  for (  Field f : me.getFields()) {
    Object expValue;
    Object ttValue;
    if (f.getName().equals(""String_Node_Str"") && dao.meta().isMySql()) {
      expValue=me.getValue(exp,f).toString();
      ttValue=me.getValue(et,f).toString();
    }
 else {
      expValue=me.getValue(exp,f);
      ttValue=me.getValue(et,f);
      if (null == expValue)       continue;
    }
    if (!expValue.equals(ttValue))     throw Lang.makeThrow(""String_Node_Str"",f.getName(),expValue,ttValue);
  }
  assertTrue(true);
}","@Test public void check_if_support_all_normal_types() throws FailToCastObjectException {
  String d=""String_Node_Str"";
  String t=""String_Node_Str"";
  String dt=d + ""String_Node_Str"" + t;
  Date date=Castors.me().castTo(d,Date.class);
  Time time=Castors.me().castTo(t,Time.class);
  Timestamp ts=Castors.me().castTo(dt,Timestamp.class);
  EntityTypes exp=new EntityTypes();
  exp.name=""String_Node_Str"";
  exp.enum_s=TT.B;
  exp.enum_i=TT.A;
  exp.char_p='G';
  exp.char_obj='O';
  exp.int_p=23;
  exp.int_obj=23;
  exp.float_p=34.67f;
  exp.float_obj=34.68f;
  exp.short_p=6;
  exp.short_obj=6;
  exp.byte_p=2;
  exp.byte_obj=4;
  exp.long_p=56787;
  exp.long_obj=5678L;
  exp.double_p=2.4325243;
  exp.double_obj=3.4325243;
  exp.sqlDate=date;
  exp.sqlTime=time;
  exp.sqlDT=ts;
  dao.insert(exp);
  EntityTypes et=dao.fetch(EntityTypes.class);
  assertEquals(exp.id,et.id);
  Mirror<EntityTypes> me=Mirror.me(EntityTypes.class);
  for (  Field f : me.getFields()) {
    Object expValue;
    Object ttValue;
    if (f.getName().equals(""String_Node_Str"") && dao.meta().isMySql()) {
      expValue=me.getValue(exp,f).toString();
      ttValue=me.getValue(et,f).toString();
    }
 else {
      expValue=me.getValue(exp,f);
      ttValue=me.getValue(et,f);
      if (null == expValue)       continue;
    }
    if (!expValue.equals(ttValue) && !dao.meta().isDB2())     throw Lang.makeThrow(""String_Node_Str"",f.getName(),expValue,ttValue);
  }
  assertTrue(true);
}"
80614,"@Override public Response send() throws HttpException {
  try {
    openConnection();
    Map<String,?> params=request.getParams();
    String data=null;
    if (null != params && params.size() > 0) {
      data=request.getURLEncodedParams();
    }
    setupRequestHeader();
    setupDoInputOutputFlag();
    if (data != null) {
      Writer w=new BufferedWriter(Streams.utf8w(conn.getOutputStream()));
      w.write(data);
      Streams.safeFlush(w);
      Streams.safeClose(w);
    }
    return createResponse(getResponseHeader());
  }
 catch (  Exception e) {
    throw new HttpException(request.getUrl().toString(),e);
  }
}","@Override public Response send() throws HttpException {
  try {
    openConnection();
    setupRequestHeader();
    setupDoInputOutputFlag();
    InputStream ins=request.getInputStream();
    if (null != ins) {
      OutputStream ops=Streams.buff(conn.getOutputStream());
      Streams.write(ops,ins,8192);
      Streams.safeClose(ins);
      Streams.safeFlush(ops);
      Streams.safeClose(ops);
    }
    return createResponse(getResponseHeader());
  }
 catch (  Exception e) {
    throw new HttpException(request.getUrl().toString(),e);
  }
}"
80615,"/** 
 * 子类应该覆盖这个方法或者evalInjector(Type,Param)方法.
 */
protected ParamInjector evalInjector(Class<?> type,Param param){
  return null;
}","protected ParamInjector evalInjector(Type type,Param param){
  Class<?> clazz=Lang.getTypeClass(type);
  Type[] paramTypes=null;
  if (type instanceof ParameterizedType)   paramTypes=((ParameterizedType)type).getActualTypeArguments();
  if (clazz == null) {
    if (log.isWarnEnabled())     log.warnf(""String_Node_Str"",type,param);
    return null;
  }
  return evalInjectorBy(clazz,param,paramTypes);
}"
80616,"public Object getReferObject(ServletContext sc,HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  try {
    return Json.fromJson(Streams.utf8r(request.getInputStream()));
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}","public Object getReferObject(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  try {
    String str=Streams.readAndClose(Streams.utf8r(req.getInputStream()));
    return Json.fromJson(str);
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}"
80617,"public ArrayInjector(String name,Class<?> type){
  super(name,type);
}","public ArrayInjector(String name,Class<?> type,Type[] paramTypes){
  super(name,type,paramTypes);
}"
80618,"/** 
 * 获得所有的属性，包括私有属性。不包括 Object 的属性
 */
public Field[] getFields(){
  Class<?> cc=klass;
  Map<String,Field> map=new LinkedHashMap<String,Field>();
  while (null != cc && cc != Object.class) {
    Field[] fs=cc.getDeclaredFields();
    for (int i=0; i < fs.length; i++) {
      if (!isIgnoredField(fs[i]) && !map.containsKey(fs[i].getName()))       map.put(fs[i].getName(),fs[i]);
    }
    cc=cc.getSuperclass();
  }
  return map.values().toArray(new Field[map.size()]);
}","/** 
 * 获得所有的属性，包括私有属性。不包括 Object 的属性
 * @return 字段列表
 */
public Field[] getFields(){
  return _getFields(true,false,true,true);
}"
80619,"public static Set<Class<?>> scanModules(Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  List<Class<?>> list=new LinkedList<Class<?>>();
  list.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      list.add(module);
    }
  }
  Set<Class<?>> modules=new HashSet<Class<?>>();
  for (  Class<?> type : list) {
    if (scan) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",type.getPackage().getName());
      List<Class<?>> subs=Scans.me().scanPackage(type);
      for (      Class<?> sub : subs) {
        if (isModule(sub)) {
          if (log.isDebugEnabled())           log.debugf(""String_Node_Str"",sub.getName());
          modules.add(sub);
        }
 else         if (log.isTraceEnabled()) {
          log.tracef(""String_Node_Str"",sub.getName());
        }
      }
    }
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}","public static Set<Class<?>> scanModules(Class<?> mainModule){
  Modules ann=mainModule.getAnnotation(Modules.class);
  boolean scan=null == ann ? false : ann.scanPackage();
  List<Class<?>> list=new LinkedList<Class<?>>();
  list.add(mainModule);
  if (null != ann) {
    for (    Class<?> module : ann.value()) {
      list.add(module);
    }
  }
  Set<Class<?>> modules=new HashSet<Class<?>>();
  if (null != ann && ann.packages() != null && ann.packages().length > 0) {
    for (    String packageName : ann.packages())     scanModuleInPackage(modules,packageName);
  }
  for (  Class<?> type : list) {
    if (scan)     scanModuleInPackage(modules,type.getPackage().getName());
 else {
      if (isModule(type)) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",type.getName());
        modules.add(type);
      }
 else       if (log.isTraceEnabled()) {
        log.tracef(""String_Node_Str"",type.getName());
      }
    }
  }
  return modules;
}"
80620,"public static PItem cndAuto(Entity<?> en,Object obj){
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
throw Lang.makeThrow(""String_Node_Str"",en.getType().getName(),obj);
}
}","public static PItem cndAuto(Entity<?> en,Object obj){
  obj=Lang.first(obj);
switch (en.getPkType()) {
case ID:
    Number id=null != obj ? ((Number)en.getIdField().getValue(obj)) : null;
  return cndId(en,id);
case NAME:
String name=null != obj ? en.getNameField().getValue(obj).toString() : null;
return cndName(en,name);
case COMPOSITE:
Object[] pks=null;
if (null != obj) {
pks=new Object[en.getCompositePKFields().size()];
int i=0;
for (EntityField ef : en.getCompositePKFields()) pks[i++]=ef.getValue(obj);
}
return cndPk(en,pks);
default :
throw Lang.makeThrow(""String_Node_Str"",en.getType().getName(),obj);
}
}"
80621,"protected ParamInjector evalInjector(Type type,Param param){
  return new JsonInjector(type,null == param ? null : param.value());
}","@Override protected ParamInjector evalInjector(Type type,Param param){
  if (param == null)   return new JsonInjector(type,null);
  return super.evalInjector(type,param);
}"
80622,"public Object getReferObject(ServletContext sc,HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  try {
    return Streams.readAndClose(Streams.utf8r(request.getInputStream()));
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}","public Object getReferObject(ServletContext sc,HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  try {
    return Json.fromJson(Streams.utf8r(request.getInputStream()));
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}"
80623,"@Override public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null != refer)   return Castors.me().castTo(refer,type);
  String[] values=req.getParameterValues(name);
  if (null == values || values.length == 0)   return null;
  if (values.length == 1) {
    try {
      return Castors.me().castTo(values[0],type);
    }
 catch (    Exception e) {
      Object re=Array.newInstance(type.getComponentType(),1);
      Object v=Castors.me().castTo(values[0],type.getComponentType());
      Array.set(re,0,v);
      return re;
    }
  }
  return Lang.array2array(values,type.getComponentType());
}","@SuppressWarnings(""String_Node_Str"") @Override public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object value=null;
  if (null != refer) {
    if (refer instanceof Map) {
      value=((Map<String,Object>)refer).get(name);
      if (value != null && value.getClass().isArray())       return Lang.array2array(value,type.getComponentType());
    }
    if (value != null)     return convertMe(value);
  }
  String[] values=req.getParameterValues(name);
  if (null == values || values.length == 0)   return null;
  if (values.length == 1) {
    return convertMe(values[0]);
  }
  return Lang.array2array(values,type.getComponentType());
}"
80624,"public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null == name)   return Json.fromJson(type,refer.toString());
  NutMap map=Json.fromJson(NutMap.class,refer.toString());
  Object theObj=map.get(name);
  if (null == theObj)   return null;
  Class<?> clazz=Lang.getTypeClass(type);
  return Castors.me().castTo(theObj,clazz);
}","@SuppressWarnings(""String_Node_Str"") public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null == name)   return Castors.me().castTo(refer,Lang.getTypeClass(type));
  Map<String,Object> map=(Map<String,Object>)refer;
  Object theObj=map.get(name);
  if (null == theObj)   return null;
  Class<?> clazz=Lang.getTypeClass(type);
  return Castors.me().castTo(theObj,clazz);
}"
80625,"public void process(ActionContext ac) throws Throwable {
  Object module=ac.getModule();
  Method method=ac.getMethod();
  Object[] args=ac.getMethodArgs();
  try {
    Object re=method.invoke(module,args);
    ac.setMethodReturn(re);
    doNext(ac);
  }
 catch (  IllegalAccessException e) {
    throw e.getCause();
  }
catch (  IllegalArgumentException e) {
    throw e.getCause();
  }
catch (  InvocationTargetException e) {
    throw e.getTargetException();
  }
}","public void process(ActionContext ac) throws Throwable {
  Object module=ac.getModule();
  Method method=ac.getMethod();
  Object[] args=ac.getMethodArgs();
  try {
    Object re=method.invoke(module,args);
    ac.setMethodReturn(re);
    doNext(ac);
  }
 catch (  IllegalAccessException e) {
    throw Lang.unwrapThrow(e);
  }
catch (  IllegalArgumentException e) {
    throw Lang.unwrapThrow(e);
  }
catch (  InvocationTargetException e) {
    throw Lang.unwrapThrow(e);
  }
}"
80626,"public Object getReferObject(ServletContext sc,HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  try {
    Uploading ing=new FastUploading();
    return ing.parse(request,context);
  }
 catch (  UploadException e) {
    throw Lang.wrapThrow(e);
  }
 finally {
    Uploads.removeInfo(request);
  }
}","public Map<String,Object> getReferObject(ServletContext sc,HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  try {
    Uploading ing=new FastUploading();
    return ing.parse(request,context);
  }
 catch (  UploadException e) {
    throw Lang.wrapThrow(e);
  }
 finally {
    Uploads.removeInfo(request);
  }
}"
80627,"@Test public void testPersonObject() throws Exception {
  Person p=Json.fromJson(Person.class,getFileAsInputStreamReader(""String_Node_Str""));
  StringBuilder sb=new StringBuilder();
  Writer w=new OutputStreamWriter(new StringOutputStream(sb));
  w.write(p.dump());
  w.write(""String_Node_Str"");
  w.write(p.getFather().dump());
  w.write(""String_Node_Str"");
  w.write(p.getCompany().getName());
  w.write(""String_Node_Str"");
  w.write(p.getCompany().getCreator().dump());
  w.flush();
  w.close();
  assertTrue(Streams.equals(new StringInputStream(sb),getClass().getResourceAsStream(""String_Node_Str"")));
}","@Ignore @Test public void testPersonObject() throws Exception {
  Person p=Json.fromJson(Person.class,getFileAsInputStreamReader(""String_Node_Str""));
  StringBuilder sb=new StringBuilder();
  Writer w=new OutputStreamWriter(new StringOutputStream(sb));
  w.write(p.dump());
  w.write(""String_Node_Str"");
  w.write(p.getFather().dump());
  w.write(""String_Node_Str"");
  w.write(p.getCompany().getName());
  w.write(""String_Node_Str"");
  w.write(p.getCompany().getCreator().dump());
  w.flush();
  w.close();
  assertTrue(Streams.equals(new StringInputStream(sb),getClass().getResourceAsStream(""String_Node_Str"")));
}"
80628,"@Test public void test_array() throws ServletException, IOException {
  String path=""String_Node_Str"";
  String json=""String_Node_Str"";
  initreq(path,json);
  servlet.service(request,response);
  assertEquals(3,response.getAsInt());
}","@Test public void test_array() throws ServletException, IOException {
  String path=""String_Node_Str"";
  String json=""String_Node_Str"";
  initreq(path,json);
  servlet.service(request,response);
  System.out.println(response.getAsString());
  assertEquals(3,response.getAsInt());
}"
80629,"public static List<MappingField> getFieldsForUpdate(Entity<?> en,FieldMatcher fm,Object refer){
  List<MappingField> re=new ArrayList<MappingField>(en.getMappingFields().size());
  for (  MappingField mf : en.getMappingFields()) {
    if (mf.isPk()) {
      if (en.getPkType() == PkType.ID && mf.isId())       continue;
      if (en.getPkType() == PkType.NAME && mf.isName())       continue;
      if (en.getPkType() == PkType.COMPOSITE && mf.isCompositePk())       continue;
    }
    if (!mf.isAutoIncreasement() && !mf.isReadonly())     if (null != fm && null != refer && fm.isIgnoreNull() && null == mf.getValue(refer))     continue;
    if (null == fm || fm.match(mf.getName()))     re.add(mf);
  }
  return re;
}","public static List<MappingField> getFieldsForUpdate(Entity<?> en,FieldMatcher fm,Object refer){
  List<MappingField> re=new ArrayList<MappingField>(en.getMappingFields().size());
  for (  MappingField mf : en.getMappingFields()) {
    if (mf.isPk()) {
      if (en.getPkType() == PkType.ID && mf.isId())       continue;
      if (en.getPkType() == PkType.NAME && mf.isName())       continue;
      if (en.getPkType() == PkType.COMPOSITE && mf.isCompositePk())       continue;
    }
    if (mf.isReadonly() || mf.isAutoIncreasement())     continue;
 else     if (null != fm && null != refer && fm.isIgnoreNull() && null == mf.getValue(refer))     continue;
    if (null == fm || fm.match(mf.getName()))     re.add(mf);
  }
  return re;
}"
80630,"public JsonEntity(Mirror<?> mirror){
  Field[] flds=mirror.getFields();
  fields=new ArrayList<JsonEntityField>(flds.length);
  for (  Field fld : flds) {
    JsonEntityField ef=new JsonEntityField(mirror,fld);
    fields.add(ef);
  }
  try {
    borning=mirror.getBorning();
  }
 catch (  BorningException e) {
    err=e;
  }
}","public JsonEntity(Mirror<?> mirror){
  Field[] flds=mirror.getFields();
  fields=new ArrayList<JsonEntityField>(flds.length);
  for (  Field fld : flds) {
    JsonEntityField ef=JsonEntityField.eval(mirror,fld);
    if (null != ef)     fields.add(ef);
  }
  try {
    borning=mirror.getBorning();
  }
 catch (  BorningException e) {
    err=e;
  }
}"
80631,"public JsonEntityField(Mirror<?> mirror,Field fld){
  this.injecting=mirror.getInjecting(fld.getName());
  this.ejecting=mirror.getEjecting(fld.getName());
  this.genericType=fld.getGenericType();
  JsonField jf=fld.getAnnotation(JsonField.class);
  if (null != jf)   name=jf.value();
 else   name=fld.getName();
}","private JsonEntityField(){
}"
80632,"public void exec(Connection conn,DaoStatement st){
  Object[][] paramMatrix;
  try {
    st.onBefore(conn);
switch (st.getSqlType()) {
case SELECT:
      paramMatrix=st.getParamMatrix();
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      String sql=st.toPreparedStatement();
      if (log.isDebugEnabled())       log.debug(sql);
      Statement stat=null;
      ResultSet rs=null;
      try {
        stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        if (st.getContext().getFetchSize() > 0)         stat.setFetchSize(st.getContext().getFetchSize());
        rs=stat.executeQuery(sql);
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(stat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
 else {
      String sql=st.toPreparedStatement();
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
 else       if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      PreparedStatement pstat=null;
      ResultSet rs=null;
      try {
        pstat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        for (int i=0; i < paramMatrix[0].length; i++) {
          adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
        }
        rs=pstat.executeQuery();
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(pstat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
  break;
case DELETE:
case UPDATE:
case INSERT:
paramMatrix=st.getParamMatrix();
if (null == paramMatrix || paramMatrix.length == 0) {
_runStatement(conn,st);
}
 else {
_runPreparedStatement(conn,st,paramMatrix);
}
st.onAfter(conn,null);
break;
case TRUNCATE:
case CREATE:
case DROP:
_runStatement(conn,st);
st.onAfter(conn,null);
break;
case ALTER:
case RUN:
st.onAfter(conn,null);
break;
default :
throw Lang.impossible();
}
}
 catch (SQLException e) {
throw new DaoException(format(""String_Node_Str"",st.toString(),st.toPreparedStatement()),e);
}
}","public void exec(Connection conn,DaoStatement st){
  Object[][] paramMatrix;
  try {
    st.onBefore(conn);
switch (st.getSqlType()) {
case SELECT:
      paramMatrix=st.getParamMatrix();
    if (null == paramMatrix || paramMatrix.length == 0 || paramMatrix[0].length == 0) {
      String sql=st.toPreparedStatement();
      if (log.isDebugEnabled())       log.debug(sql);
      Statement stat=null;
      ResultSet rs=null;
      try {
        stat=conn.createStatement(st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        if (st.getContext().getFetchSize() > 0)         stat.setFetchSize(st.getContext().getFetchSize());
        rs=stat.executeQuery(sql);
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(stat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
 else {
      String sql=st.toPreparedStatement();
      if (paramMatrix.length > 1) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",paramMatrix.length - 1,st);
      }
 else       if (log.isDebugEnabled()) {
        log.debug(st);
      }
      ValueAdaptor[] adaptors=st.getAdaptors();
      PreparedStatement pstat=null;
      ResultSet rs=null;
      try {
        pstat=conn.prepareStatement(sql,st.getContext().getResultSetType(),ResultSet.CONCUR_READ_ONLY);
        for (int i=0; i < paramMatrix[0].length; i++) {
          adaptors[i].set(pstat,paramMatrix[0][i],i + 1);
        }
        rs=pstat.executeQuery();
        st.onAfter(conn,rs);
      }
  finally {
        Daos.safeClose(pstat,rs);
      }
      if (log.isTraceEnabled())       log.trace(""String_Node_Str"");
    }
  break;
case ALTER:
case TRUNCATE:
case CREATE:
case DROP:
_runStatement(conn,st);
st.onAfter(conn,null);
break;
case RUN:
st.onAfter(conn,null);
break;
default :
paramMatrix=st.getParamMatrix();
if (null == paramMatrix || paramMatrix.length == 0) {
_runStatement(conn,st);
}
 else {
_runPreparedStatement(conn,st,paramMatrix);
}
st.onAfter(conn,null);
}
}
 catch (SQLException e) {
throw new DaoException(format(""String_Node_Str"",st.toString(),st.toPreparedStatement()),e);
}
}"
80633,"/** 
 * 从一个 ResultSet 中获取一个对象。 <p> 因为 Dao 接口可以知道一个 POJO 的映射细节，这个函数可以帮你节省一点体力。
 * @param classOfT
 * @param rs
 * @param fm
 * @return 对象
 */
<T>T getObject(Class<T> classOfT,ResultSet rs,FieldMatcher fm);","/** 
 * 从一个 ResultSet 中获取一个对象。 <p> 因为 Dao 接口可以知道一个 POJO 的映射细节，这个函数可以帮你节省一点体力。
 * @param classOfT 对象类型
 * @param rs 结果集
 * @param fm 字段过滤器
 * @return 对象
 */
<T>T getObject(Class<T> classOfT,ResultSet rs,FieldMatcher fm);"
80634,"@SuppressWarnings(""String_Node_Str"") private void addClass(Class<?> classZ){
  if (classZ.isInterface() || classZ.isMemberClass() || classZ.isEnum()|| classZ.isAnnotation()|| classZ.isAnonymousClass())   return;
  int modify=classZ.getModifiers();
  if (Modifier.isAbstract(modify) || (!Modifier.isPublic(modify)))   return;
  IocBean iocBean=classZ.getAnnotation(IocBean.class);
  if (iocBean != null) {
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ);
    String beanName=iocBean.name();
    if (Strings.isBlank(beanName)) {
      InjectName innm=classZ.getAnnotation(InjectName.class);
      if (null != innm && !Strings.isBlank(innm.value())) {
        beanName=innm.value();
      }
 else {
        beanName=Strings.lowerFirst(classZ.getSimpleName());
      }
    }
    IocObject iocObject=new IocObject();
    iocObject.setType(classZ);
    map.put(beanName,iocObject);
    iocObject.setSingleton(iocBean.singleton());
    if (!Strings.isBlank(iocBean.scope()))     iocObject.setScope(iocBean.scope());
    String[] args=iocBean.args();
    if (null == args || args.length == 0)     args=iocBean.param();
    if (null != args && args.length > 0)     for (    String value : args)     iocObject.addArg(convert(value));
    IocEventSet eventSet=new IocEventSet();
    iocObject.setEvents(eventSet);
    if (!Strings.isBlank(iocBean.create()))     eventSet.setCreate(iocBean.create().trim().intern());
    if (!Strings.isBlank(iocBean.depose()))     eventSet.setDepose(iocBean.depose().trim().intern());
    if (!Strings.isBlank(iocBean.fetch()))     eventSet.setFetch(iocBean.fetch().trim().intern());
    List<String> fieldList=new ArrayList<String>();
    Mirror<?> mirror=Mirror.me(classZ);
    Field[] fields=mirror.getFields();
    for (    Field field : fields) {
      Inject inject=field.getAnnotation(Inject.class);
      if (inject == null)       continue;
      IocField iocField=new IocField();
      iocField.setName(field.getName());
      IocValue iocValue;
      if (Strings.isBlank(inject.value())) {
        iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(field.getName());
      }
 else       iocValue=convert(inject.value());
      iocField.setValue(iocValue);
      iocObject.addField(iocField);
      fieldList.add(iocField.getName());
    }
    Method[] methods=mirror.getMethods();
    for (    Method method : methods) {
      Inject inject=method.getAnnotation(Inject.class);
      if (inject == null)       continue;
      if (method.getName().startsWith(""String_Node_Str"") && method.getName().length() > 3 && method.getParameterTypes().length == 1) {
        IocField iocField=new IocField();
        iocField.setName(Strings.lowerFirst(method.getName().substring(3)));
        IocValue iocValue;
        if (Strings.isBlank(inject.value())) {
          iocValue=new IocValue();
          iocValue.setType(IocValue.TYPE_REFER);
          iocValue.setValue(Strings.lowerFirst(method.getName().substring(3)));
        }
 else         iocValue=convert(inject.value());
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    String[] flds=iocBean.fields();
    if (null == flds || flds.length == 0) {
      flds=iocBean.field();
    }
    if (flds != null && flds.length > 0) {
      for (      String fieldInfo : flds) {
        if (fieldList.contains(fieldInfo))         throw Lang.makeThrow(""String_Node_Str"",classZ,fieldInfo);
        IocField iocField=new IocField();
        iocField.setName(fieldInfo);
        IocValue iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(fieldInfo);
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ,beanName);
  }
}","private void addClass(Class<?> classZ){
  if (classZ.isInterface() || classZ.isMemberClass() || classZ.isEnum()|| classZ.isAnnotation()|| classZ.isAnonymousClass())   return;
  int modify=classZ.getModifiers();
  if (Modifier.isAbstract(modify) || (!Modifier.isPublic(modify)))   return;
  IocBean iocBean=classZ.getAnnotation(IocBean.class);
  if (iocBean != null) {
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ);
    String beanName=iocBean.name();
    if (Strings.isBlank(beanName)) {
      InjectName innm=classZ.getAnnotation(InjectName.class);
      if (null != innm && !Strings.isBlank(innm.value())) {
        beanName=innm.value();
      }
 else {
        beanName=Strings.lowerFirst(classZ.getSimpleName());
      }
    }
    IocObject iocObject=new IocObject();
    iocObject.setType(classZ);
    map.put(beanName,iocObject);
    iocObject.setSingleton(iocBean.singleton());
    if (!Strings.isBlank(iocBean.scope()))     iocObject.setScope(iocBean.scope());
    String[] args=iocBean.args();
    if (null != args && args.length > 0)     for (    String value : args)     iocObject.addArg(convert(value));
    IocEventSet eventSet=new IocEventSet();
    iocObject.setEvents(eventSet);
    if (!Strings.isBlank(iocBean.create()))     eventSet.setCreate(iocBean.create().trim().intern());
    if (!Strings.isBlank(iocBean.depose()))     eventSet.setDepose(iocBean.depose().trim().intern());
    if (!Strings.isBlank(iocBean.fetch()))     eventSet.setFetch(iocBean.fetch().trim().intern());
    List<String> fieldList=new ArrayList<String>();
    Mirror<?> mirror=Mirror.me(classZ);
    Field[] fields=mirror.getFields(Inject.class);
    for (    Field field : fields) {
      Inject inject=field.getAnnotation(Inject.class);
      IocField iocField=new IocField();
      iocField.setName(field.getName());
      IocValue iocValue;
      if (Strings.isBlank(inject.value())) {
        iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(field.getName());
      }
 else       iocValue=convert(inject.value());
      iocField.setValue(iocValue);
      iocObject.addField(iocField);
      fieldList.add(iocField.getName());
    }
    Method[] methods=mirror.getMethods();
    for (    Method method : methods) {
      Inject inject=method.getAnnotation(Inject.class);
      if (inject == null)       continue;
      int m=method.getModifiers();
      if (Modifier.isAbstract(m) || (!Modifier.isPublic(m)) || Modifier.isStatic(m))       continue;
      if (method.getName().startsWith(""String_Node_Str"") && method.getName().length() > 3 && method.getParameterTypes().length == 1) {
        IocField iocField=new IocField();
        iocField.setName(Strings.lowerFirst(method.getName().substring(3)));
        if (fieldList.contains(iocField.getName()))         throw duplicateField(classZ,iocField.getName());
        IocValue iocValue;
        if (Strings.isBlank(inject.value())) {
          iocValue=new IocValue();
          iocValue.setType(IocValue.TYPE_REFER);
          iocValue.setValue(Strings.lowerFirst(method.getName().substring(3)));
        }
 else         iocValue=convert(inject.value());
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    String[] flds=iocBean.fields();
    if (flds != null && flds.length > 0) {
      for (      String fieldInfo : flds) {
        if (fieldList.contains(fieldInfo))         throw duplicateField(classZ,fieldInfo);
        IocField iocField=new IocField();
        iocField.setName(fieldInfo);
        IocValue iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(fieldInfo);
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ,beanName);
  }
}"
80635,"/** 
 * 将字符串，变成数字对象，现支持的格式为： <ul> <li>null - 整数 0</li> <li>23.78 - 浮点 Float</li> <li>0x45 - 16进制整数 Integer</li> <li>78L - 长整数 Long</li> <li>69 - 普通整数 Integer</li> </ul>
 * @param s 参数
 * @return 数字对象
 */
public static Number str2number(String s){
  if (null == s) {
    return 0;
  }
  s=s.toUpperCase();
  if (s.indexOf('.') != -1) {
    return Float.valueOf(s);
  }
  if (s.startsWith(""String_Node_Str"")) {
    return Integer.valueOf(s.substring(2),16);
  }
  if (s.charAt(s.length() - 1) == 'L') {
    return Long.valueOf(s.substring(0,s.length() - 1));
  }
  return Integer.valueOf(s);
}","/** 
 * 将字符串，变成数字对象，现支持的格式为： <ul> <li>null - 整数 0</li> <li>23.78 - 浮点 Float</li> <li>0x45 - 16进制整数 Integer</li> <li>78L - 长整数 Long</li> <li>69 - 普通整数 Integer</li> </ul>
 * @param s 参数
 * @return 数字对象
 */
public static Number str2number(String s){
  if (null == s) {
    return 0;
  }
  s=s.toUpperCase();
  if (s.indexOf('.') != -1) {
    return Float.valueOf(s);
  }
  if (s.startsWith(""String_Node_Str"")) {
    return Integer.valueOf(s.substring(2),16);
  }
  if (s.charAt(s.length() - 1) == 'L') {
    return Long.valueOf(s.substring(0,s.length() - 1));
  }
  Long re=Long.parseLong(s);
  if (Integer.MAX_VALUE >= re && re >= Integer.MIN_VALUE)   return re.intValue();
  return re;
}"
80636,"public static ElObj oLong(Long v){
  return new StaticElObj(new LongElValue(v));
}","public static ElObj oLong(Long v){
  return new StaticElObj(new NumberElValue(v));
}"
80637,"public static ElObj oInt(Integer v){
  return new StaticElObj(new IntegerElValue(v));
}","public static ElObj oInt(Integer v){
  return new StaticElObj(new NumberElValue(v));
}"
80638,"public static ElObj oFloat(Float v){
  return new StaticElObj(new FloatElValue(v));
}","public static ElObj oFloat(Float v){
  return new StaticElObj(new NumberElValue(v));
}"
80639,"public ElValue make(Object obj){
  if (obj instanceof ElValue)   return (ElValue)obj;
  if (null == obj)   return new NullElValue();
  if (obj instanceof Map<?,?>)   return new MapElValue((Map<?,?>)obj);
  if (obj instanceof List<?>)   return new ListElValue((List<?>)obj);
  if (obj instanceof Collection<?>)   return new CollectionElValue((List<?>)obj);
  if (obj.getClass().isArray()) {
    return new ArrayElValue(obj);
  }
  Mirror<?> mirror=Mirror.me(obj);
  if (mirror.isStringLike())   return new StringElValue(obj.toString());
  if (mirror.isLong())   return new LongElValue((Long)obj);
  if (mirror.isIntLike())   return new IntegerElValue((Integer)obj);
  if (mirror.isBoolean())   return (Boolean)obj ? El.TRUE : El.FALSE;
  if (mirror.isFloat())   return new FloatElValue((Float)obj);
  return new PojoElValue<Object>(obj);
}","public ElValue make(Object obj){
  if (obj instanceof ElValue)   return (ElValue)obj;
  if (null == obj)   return new NullElValue();
  if (obj instanceof Map<?,?>)   return new MapElValue((Map<?,?>)obj);
  if (obj instanceof List<?>)   return new ListElValue((List<?>)obj);
  if (obj instanceof Collection<?>)   return new CollectionElValue((List<?>)obj);
  if (obj.getClass().isArray()) {
    return new ArrayElValue(obj);
  }
  Mirror<?> mirror=Mirror.me(obj);
  if (mirror.isStringLike())   return new StringElValue(obj.toString());
  if (mirror.isLong())   return new NumberElValue((Long)obj);
  if (mirror.isIntLike())   return new NumberElValue((Integer)obj);
  if (mirror.isBoolean())   return (Boolean)obj ? El.TRUE : El.FALSE;
  if (mirror.isFloat())   return new NumberElValue((Float)obj);
  return new PojoElValue<Object>(obj);
}"
80640,"public ElValue getProperty(ElValue val){
  Object v=val.get();
  if (v instanceof Integer) {
    return El.wrap(Array.get(obj,((Integer)v).intValue()));
  }
 else   if (""String_Node_Str"".equals(val.getString())) {
    return El.wrap(Array.getLength(obj));
  }
  throw new ElException(""String_Node_Str"",val.getString());
}","public ElValue getProperty(ElValue val){
  Object v=val.get();
  if (v instanceof BigDecimal) {
    return El.wrap(Array.get(obj,((BigDecimal)v).intValue()));
  }
 else   if (""String_Node_Str"".equals(val.getString())) {
    return El.wrap(Array.getLength(obj));
  }
  throw new ElException(""String_Node_Str"",val.getString());
}"
80641,"public void injectValue(Object obj,ResultSet rs){
  try {
    this.setValue(obj,adaptor.get(rs,columnName));
  }
 catch (  SQLException e) {
    throw Lang.wrapThrow(e);
  }
}","public void injectValue(Object obj,ResultSet rs){
  try {
    this.setValue(obj,adaptor.get(rs,columnName));
  }
 catch (  SQLException e) {
  }
}"
80642,"public <T>T insertRelation(T obj,String regex){
  EntityOperator opt=__opt(obj);
  opt.entity.visitManyMany(obj,regex,doInsertRelation(opt));
  opt.exec();
  return obj;
}","public <T>T insertRelation(T obj,String regex){
  EntityOperator opt=_optBy(obj);
  opt.entity.visitManyMany(obj,regex,doInsertRelation(opt));
  opt.exec();
  return obj;
}"
80643,"public <T>T insertWith(T obj,String regex){
  EntityOperator opt=__opt(obj);
  opt.entity.visitOne(obj,regex,doInsert(opt));
  opt.addInsert();
  opt.entity.visitMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsertRelation(opt));
  opt.exec();
  return obj;
}","public <T>T insertWith(T obj,String regex){
  EntityOperator opt=_optBy(obj);
  opt.entity.visitOne(obj,regex,doInsert(opt));
  opt.addInsert();
  opt.entity.visitMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsertRelation(opt));
  opt.exec();
  return obj;
}"
80644,"public <T>T insertLinks(T obj,String regex){
  EntityOperator opt=__opt(obj);
  opt.entity.visitOne(obj,regex,doInsert(opt));
  opt.entity.visitMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsertRelation(opt));
  opt.exec();
  return obj;
}","public <T>T insertLinks(T obj,String regex){
  EntityOperator opt=_optBy(obj);
  opt.entity.visitOne(obj,regex,doInsert(opt));
  opt.entity.visitMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsert(opt));
  opt.entity.visitManyMany(obj,regex,doInsertRelation(opt));
  opt.exec();
  return obj;
}"
80645,"public int update(Class<?> classOfT,Chain chain,Condition cnd){
  Entity<?> en=holder.getEntity(classOfT);
  return update(en.getTableName(),chain.updateBy(en),cnd);
}","public int update(Class<?> classOfT,Chain chain,Condition cnd){
  EntityOperator opt=_opt(classOfT);
  opt.addUpdate(chain,cnd);
  opt.exec();
  return opt.getUpdateCount();
}"
80646,"public int delete(Object obj){
  EntityOperator opt=__opt(obj);
  opt.addDeleteSelfOnly();
  opt.exec();
  return opt.getUpdateCount();
}","public int delete(Object obj){
  EntityOperator opt=_optBy(obj);
  opt.addDeleteSelfOnly();
  opt.exec();
  return opt.getUpdateCount();
}"
80647,"public int updateIgnoreNull(final Object obj){
  EntityOperator opt=__opt(obj);
  opt.addUpdateForIgnoreNull(opt.entity,obj,FieldFilter.get(opt.entity.getType()));
  opt.exec();
  return opt.getUpdateCount();
}","public int updateIgnoreNull(final Object obj){
  EntityOperator opt=_optBy(obj);
  opt.addUpdateForIgnoreNull(opt.entity,obj,FieldFilter.get(opt.entity.getType()));
  opt.exec();
  return opt.getUpdateCount();
}"
80648,"public int deleteLinks(Object obj,String regex){
  EntityOperator opt=this.__opt(obj);
  opt.entity.visitMany(obj,regex,doDelete(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByLinkedField(opt));
  opt.entity.visitManyMany(obj,regex,doDelete(opt));
  opt.entity.visitOne(obj,regex,doDelete(opt));
  return opt.exec().getUpdateCount();
}","public int deleteLinks(Object obj,String regex){
  EntityOperator opt=this._optBy(obj);
  opt.entity.visitMany(obj,regex,doDelete(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByLinkedField(opt));
  opt.entity.visitManyMany(obj,regex,doDelete(opt));
  opt.entity.visitOne(obj,regex,doDelete(opt));
  return opt.exec().getUpdateCount();
}"
80649,"public <T>T clearLinks(T obj,String regex){
  EntityOperator opt=this.__opt(obj);
  opt.entity.visitMany(obj,regex,doClear(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByHostField(opt));
  opt.entity.visitOne(obj,regex,doClear(opt));
  opt.exec();
  return obj;
}","public <T>T clearLinks(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  opt.entity.visitMany(obj,regex,doClear(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByHostField(opt));
  opt.entity.visitOne(obj,regex,doClear(opt));
  opt.exec();
  return obj;
}"
80650,"public <T>T updateLinks(T obj,String regex){
  EntityOperator opt=this.__opt(obj);
  opt.entity.visitOne(obj,regex,doUpdate(opt));
  opt.entity.visitMany(obj,regex,doUpdate(opt));
  opt.entity.visitManyMany(obj,regex,doUpdate(opt));
  opt.exec();
  return obj;
}","public <T>T updateLinks(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  opt.entity.visitOne(obj,regex,doUpdate(opt));
  opt.entity.visitMany(obj,regex,doUpdate(opt));
  opt.entity.visitManyMany(obj,regex,doUpdate(opt));
  opt.exec();
  return obj;
}"
80651,"public <T>T updateWith(T obj,String regex){
  EntityOperator opt=this.__opt(obj);
  opt.entity.visitOne(obj,regex,doUpdate(opt));
  opt.addUpdate();
  opt.entity.visitMany(obj,regex,doUpdate(opt));
  opt.entity.visitManyMany(obj,regex,doUpdate(opt));
  opt.exec();
  return obj;
}","public <T>T updateWith(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  opt.entity.visitOne(obj,regex,doUpdate(opt));
  opt.addUpdate();
  opt.entity.visitMany(obj,regex,doUpdate(opt));
  opt.entity.visitManyMany(obj,regex,doUpdate(opt));
  opt.exec();
  return obj;
}"
80652,"public <T>T fetchLinks(T obj,String regex){
  EntityOperator opt=this.__opt(obj);
  opt.entity.visitMany(obj,regex,doFetch(opt));
  opt.entity.visitManyMany(obj,regex,doFetch(opt));
  opt.entity.visitOne(obj,regex,doFetch(opt));
  opt.exec();
  return obj;
}","public <T>T fetchLinks(T obj,String regex){
  EntityOperator opt=this._optBy(obj);
  opt.entity.visitMany(obj,regex,doFetch(opt));
  opt.entity.visitManyMany(obj,regex,doFetch(opt));
  opt.entity.visitOne(obj,regex,doFetch(opt));
  opt.exec();
  return obj;
}"
80653,"public <T>T fastInsert(T obj){
  EntityOperator opt=__opt(obj);
  opt.addInsertSelfOnly();
  opt.exec();
  return obj;
}","public <T>T fastInsert(T obj){
  EntityOperator opt=_optBy(obj);
  opt.addInsertSelfOnly();
  opt.exec();
  return obj;
}"
80654,"public int deleteWith(Object obj,String regex){
  EntityOperator opt=this.__opt(obj);
  opt.entity.visitMany(obj,regex,doDelete(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByLinkedField(opt));
  opt.entity.visitManyMany(obj,regex,doDelete(opt));
  opt.addDeleteSelfOnly();
  opt.entity.visitOne(obj,regex,doDelete(opt));
  return opt.exec().getUpdateCount();
}","public int deleteWith(Object obj,String regex){
  EntityOperator opt=this._optBy(obj);
  opt.entity.visitMany(obj,regex,doDelete(opt));
  opt.entity.visitManyMany(obj,regex,doClearRelationByLinkedField(opt));
  opt.entity.visitManyMany(obj,regex,doDelete(opt));
  opt.addDeleteSelfOnly();
  opt.entity.visitOne(obj,regex,doDelete(opt));
  return opt.exec().getUpdateCount();
}"
80655,"public Pojo append(PItem... itemAry){
  if (null != itemAry)   for (  PItem item : itemAry) {
    items.add(item);
    item.setPojo(this);
  }
  return this;
}","public Pojo append(PItem... itemAry){
  if (null != itemAry)   for (  PItem item : itemAry) {
    if (null != item) {
      items.add(item);
      item.setPojo(this);
    }
  }
  return this;
}"
80656,"public static PItem[] cnd(Condition cnd){
  List<PItem> list=new LinkedList<PItem>();
  if (null == cnd) {
  }
  if (cnd instanceof Criteria) {
    list.add((Criteria)cnd);
  }
 else {
    list.add(new ConditionPItem(cnd));
  }
  return list.toArray(new PItem[list.size()]);
}","public static PItem[] cnd(Condition cnd){
  List<PItem> list=new LinkedList<PItem>();
  if (null == cnd) {
  }
 else   if (cnd instanceof Criteria) {
    list.add((Criteria)cnd);
  }
 else {
    list.add(new ConditionPItem(cnd));
  }
  return list.toArray(new PItem[list.size()]);
}"
80657,"public List<NutResource> loadResource(String regex,String... paths){
  List<NutResource> list=new LinkedList<NutResource>();
  try {
    for (    String path : paths) {
      File f=Files.findFile(path);
      if (null == f || f.isDirectory()) {
        list.addAll(scan(path,regex));
      }
 else       if (f.isFile()) {
        list.add(new FileResource(f));
      }
 else       if (f.getAbsolutePath().contains(""String_Node_Str"")) {
        list.add(new JarEntryResource(new JarEntryInfo(f.getAbsolutePath())));
      }
    }
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (list.size() < 1 && paths.length > 0)   throw Lang.makeThrow(RuntimeException.class,""String_Node_Str"",regex,Castors.me().castToString(paths));
  return list;
}","public List<NutResource> loadResource(String regex,String... paths){
  List<NutResource> list=new LinkedList<NutResource>();
  for (  String path : paths) {
    File f=Files.findFile(path);
    if (null == f || f.isDirectory()) {
      list.addAll(scan(path,regex));
    }
 else     if (f.isFile()) {
      list.add(new FileResource(f));
    }
 else     if (isInJar(f)) {
      NutResource nutResource=makeJarNutResource(f);
      if (nutResource != null) {
        list.add(nutResource);
      }
 else {
        if (!path.replace('\\','/').endsWith(""String_Node_Str""))         path+='/';
        list.addAll(scan(path,regex));
      }
    }
  }
  if (list.size() < 1 && paths.length > 0)   throw Lang.makeThrow(RuntimeException.class,""String_Node_Str"",regex,Castors.me().castToString(paths));
  return list;
}"
80658,"protected List<NutResource> scanInJar(String src,Pattern regex,String jarPath){
  List<NutResource> list=new ArrayList<NutResource>();
  try {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",jarPath,regex,src);
    JarFile jar=new JarFile(jarPath);
    Enumeration<JarEntry> ens=jar.entries();
    while (ens.hasMoreElements()) {
      JarEntry jen=ens.nextElement();
      if (jen.isDirectory())       continue;
      String name=jen.getName();
      if (name.startsWith(src) && (null != regex && regex.matcher(name).find())) {
        list.add(new JarEntryResource(jar,jen,jen.getName().substring(src.length())));
      }
    }
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",list.size(),jarPath,regex,src);
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"" + jarPath + ""String_Node_Str"",e);
  }
  return list;
}","protected List<NutResource> scanInJar(String src,Pattern regex,String jarPath){
  List<NutResource> list=new ArrayList<NutResource>();
  try {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",jarPath,regex,src);
    JarFile jar=new JarFile(jarPath);
    Enumeration<JarEntry> ens=jar.entries();
    while (ens.hasMoreElements()) {
      JarEntry jen=ens.nextElement();
      if (jen.isDirectory())       continue;
      String name=jen.getName();
      if (name.startsWith(src) && (null == regex || regex.matcher(name).find())) {
        list.add(new JarEntryResource(jar,jen,jen.getName().substring(src.length())));
      }
    }
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",list.size(),jarPath,regex,src);
  }
 catch (  Throwable e) {
    if (log.isWarnEnabled())     log.warn(""String_Node_Str"" + jarPath + ""String_Node_Str"",e);
  }
  return list;
}"
80659,"public List<NutResource> list(String src,String filter){
  final List<NutResource> list=new LinkedList<NutResource>();
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  File f=Files.findFile(src);
  if (f != null && f.exists()) {
    if (f.isFile())     list.addAll(scanInDir(regex,f.getParentFile(),ignoreHidden));
 else     list.addAll(scanInDir(regex,f,ignoreHidden));
  }
 else {
    String path=Disks.absolute(src,getClass().getClassLoader(),Encoding.defaultEncoding());
    if (null != path) {
      f=new File(path);
      if (!path.contains(""String_Node_Str"")) {
        int pos=path.lastIndexOf(src);
        if (pos > 0)         list.addAll(scanInDir(regex,f,ignoreHidden));
      }
 else {
        JarEntryInfo jeInfo=new JarEntryInfo(path);
        list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
      }
    }
 else {
      String classpath=System.getProperties().getProperty(""String_Node_Str"");
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + classpath);
      String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
      for (      String pathZ : paths) {
        if (pathZ.endsWith(""String_Node_Str""))         list.addAll(scanInJar(checkSrc(src),regex,pathZ));
 else         list.addAll(scanInDir(regex,new File(pathZ + ""String_Node_Str"" + src),ignoreHidden));
      }
    }
  }
  return list;
}","public List<NutResource> list(String src,String filter){
  final List<NutResource> list=new LinkedList<NutResource>();
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  File f=Files.findFile(src);
  if (f != null && f.exists()) {
    if (f.isFile())     list.addAll(scanInDir(regex,f.getParentFile(),ignoreHidden));
 else     list.addAll(scanInDir(regex,f,ignoreHidden));
  }
 else {
    String path=Disks.absolute(src,getClass().getClassLoader(),Encoding.defaultEncoding());
    if (null != path) {
      f=new File(path);
      if (!path.contains(""String_Node_Str"")) {
        int pos=path.lastIndexOf(src);
        if (pos > 0)         list.addAll(scanInDir(regex,f,ignoreHidden));
      }
 else {
        JarEntryInfo jeInfo=new JarEntryInfo(path);
        list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
      }
    }
 else {
      try {
        Enumeration<URL> en=getClass().getClassLoader().getResources(src);
        if (en != null) {
          while (en.hasMoreElements()) {
            JarEntryInfo jeInfo=new JarEntryInfo(en.nextElement().getPath());
            list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
          }
        }
      }
 catch (      Throwable e) {
        e.printStackTrace();
      }
    }
  }
  return list;
}"
80660,"@SuppressWarnings({""String_Node_Str""}) public void render(Object obj) throws IOException {
  if (null == obj) {
    writer.write(""String_Node_Str"");
  }
 else   if (obj instanceof Class) {
    string2Json(((Class<?>)obj).getName());
  }
 else   if (obj instanceof Mirror) {
    string2Json(((Mirror<?>)obj).getType().getName());
  }
 else {
    Mirror mr=Mirror.me(obj.getClass());
    if (mr.isEnum()) {
      string2Json(((Enum)obj).name());
    }
 else     if (mr.isNumber() || mr.isBoolean() || mr.isChar()) {
      writer.append(obj.toString());
    }
 else     if (mr.isStringLike()) {
      string2Json(obj.toString());
    }
 else     if (mr.isDateTimeLike()) {
      string2Json(format.getCastors().castToString(obj));
    }
 else     if (memo.containsKey(obj)) {
      writer.append(""String_Node_Str"");
    }
 else {
      memo.put(obj,null);
      if (obj instanceof Map)       map2Json((Map)obj);
 else       if (obj instanceof Collection)       coll2Json((Collection)obj);
 else       if (obj.getClass().isArray())       array2Json(obj);
 else {
        pojo2Json(obj);
      }
      memo.remove(obj);
    }
  }
}","@SuppressWarnings({""String_Node_Str""}) public void render(Object obj) throws IOException {
  if (null == obj) {
    writer.write(""String_Node_Str"");
  }
 else   if (obj instanceof Class) {
    string2Json(((Class<?>)obj).getName());
  }
 else   if (obj instanceof Mirror) {
    string2Json(((Mirror<?>)obj).getType().getName());
  }
 else {
    Mirror mr=Mirror.me(obj.getClass());
    if (mr.isEnum()) {
      string2Json(((Enum)obj).name());
    }
 else     if (mr.isNumber() || mr.isBoolean()) {
      writer.append(obj.toString());
    }
 else     if (mr.isStringLike() || mr.isChar()) {
      string2Json(obj.toString());
    }
 else     if (mr.isDateTimeLike()) {
      string2Json(format.getCastors().castToString(obj));
    }
 else     if (memo.containsKey(obj)) {
      writer.append(""String_Node_Str"");
    }
 else {
      memo.put(obj,null);
      if (obj instanceof Map)       map2Json((Map)obj);
 else       if (obj instanceof Collection)       coll2Json((Collection)obj);
 else       if (obj.getClass().isArray())       array2Json(obj);
 else {
        pojo2Json(obj);
      }
      memo.remove(obj);
    }
  }
}"
80661,"public ElValue isNEQ(ElValue ta){
  throw new ElException(""String_Node_Str"",getClass().getSimpleName(),""String_Node_Str"");
}","public ElValue isNEQ(ElValue ta){
  if (obj != ta.get())   return El.TRUE;
  return El.FALSE;
}"
80662,"public ElValue isEquals(ElValue ta){
  throw new ElException(""String_Node_Str"",getClass().getSimpleName(),""String_Node_Str"");
}","public ElValue isEquals(ElValue ta){
  if (obj == ta.get())   return El.TRUE;
  return El.FALSE;
}"
80663,"@Override public Response send() throws HttpException {
  try {
    String boundary=""String_Node_Str"";
    openConnection();
    setupRequestHeader();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + boundary);
    setupDoInputOutputFlag();
    Map<String,?> params=request.getParams();
    if (null != params && params.size() > 0) {
      DataOutputStream outs=new DataOutputStream(conn.getOutputStream());
      for (      Entry<String,?> entry : params.entrySet()) {
        outs.writeBytes(""String_Node_Str"" + boundary + SEPARATOR);
        String key=entry.getKey();
        File f=new File(entry.getKey());
        if (f.exists()) {
          outs.writeBytes(""String_Node_Str"" + key + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
          outs.writeBytes(""String_Node_Str"");
          InputStream is=new FileInputStream(f);
          byte[] buffer=new byte[is.available()];
          while (true) {
synchronized (buffer) {
              int amountRead=is.read(buffer);
              if (amountRead == -1) {
                break;
              }
              outs.write(buffer,0,amountRead);
              outs.writeBytes(""String_Node_Str"");
            }
          }
          Streams.safeClose(is);
        }
 else {
          outs.writeBytes(""String_Node_Str"" + key + ""String_Node_Str"");
          outs.writeBytes(entry.getValue() + ""String_Node_Str"");
        }
      }
      outs.writeBytes(""String_Node_Str"" + boundary + ""String_Node_Str""+ SEPARATOR);
      Streams.safeFlush(outs);
      Streams.safeClose(outs);
    }
    return createResponse(getResponseHeader());
  }
 catch (  IOException e) {
    throw new HttpException(request.getUrl().toString(),e);
  }
}","@Override public Response send() throws HttpException {
  try {
    String boundary=""String_Node_Str"";
    openConnection();
    setupRequestHeader();
    conn.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + boundary);
    setupDoInputOutputFlag();
    Map<String,Object> params=request.getParams();
    if (null != params && params.size() > 0) {
      DataOutputStream outs=new DataOutputStream(conn.getOutputStream());
      for (      Entry<String,?> entry : params.entrySet()) {
        outs.writeBytes(""String_Node_Str"" + boundary + SEPARATOR);
        String key=entry.getKey();
        File f=null;
        if (entry.getValue() instanceof File)         f=(File)entry.getValue();
 else         if (entry.getValue() instanceof String)         f=Files.findFile(entry.getValue().toString());
        if (f != null && f.exists()) {
          outs.writeBytes(""String_Node_Str"" + key + ""String_Node_Str""+ entry.getValue()+ ""String_Node_Str"");
          outs.writeBytes(""String_Node_Str"");
          if (f.length() == 0)           continue;
          InputStream is=new FileInputStream(f);
          byte[] buffer=new byte[is.available()];
          while (true) {
            int amountRead=is.read(buffer);
            if (amountRead == -1) {
              break;
            }
            outs.write(buffer,0,amountRead);
            outs.writeBytes(""String_Node_Str"");
          }
          Streams.safeClose(is);
        }
 else {
          outs.writeBytes(""String_Node_Str"" + key + ""String_Node_Str"");
          outs.writeBytes(entry.getValue() + ""String_Node_Str"");
        }
      }
      outs.writeBytes(""String_Node_Str"" + boundary + ""String_Node_Str""+ SEPARATOR);
      Streams.safeFlush(outs);
      Streams.safeClose(outs);
    }
    return createResponse(getResponseHeader());
  }
 catch (  IOException e) {
    throw new HttpException(request.getUrl().toString(),e);
  }
}"
80664,"public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[injs.length];
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  int i=0;
  for (; i < len; i++) {
    args[i]=injs[i].get(sc,req,resp,null == pathArgs ? null : pathArgs[i]);
  }
  Class<?>[] argTypes=method.getParameterTypes();
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(sc,req,resp,null);
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=Lang.getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  return args;
}","public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[injs.length];
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  int i=0;
  for (; i < len; i++) {
    args[i]=injs[i].get(sc,req,resp,null == pathArgs ? null : pathArgs[i]);
  }
  Class<?>[] argTypes=method.getParameterTypes();
  Object obj=getReferObject(sc,req,resp,pathArgs);
  for (; i < injs.length; i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ injs[i].getClass());
    args[i]=injs[i].get(sc,req,resp,obj);
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=Lang.getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  return args;
}"
80665,"protected ParamInjector evalInjector(Class<?> type,Param param){
  if (Map.class.isAssignableFrom(type))   return new MapSelfInjector();
  if (null == param)   return null;
  String paramName=param.value();
  if (File.class.isAssignableFrom(type))   return new FileInjector(paramName);
  if (FieldMeta.class.isAssignableFrom(type))   return new FileMetaInjector(paramName);
  if (TempFile.class.isAssignableFrom(type))   return new TempFileInjector(paramName);
  if (InputStream.class.isAssignableFrom(type))   return new InputStreamInjector(paramName);
  if (Reader.class.isAssignableFrom(type))   return new ReaderInjector(paramName);
  if (List.class.isAssignableFrom(type))   return new MapListInjector(paramName);
  if (type.isArray())   return new MapArrayInjector(type.getComponentType(),paramName);
  if (""String_Node_Str"".equals(paramName)) {
    if (type.isAssignableFrom(Map.class))     return new MapPairInjector();
    return new ObjectPairInjector(null,type);
  }
 else   if (paramName.startsWith(""String_Node_Str"") && paramName.length() > 2) {
    return new ObjectPairInjector(null,type);
  }
  return new MapItemInjector(paramName,type);
}","protected ParamInjector evalInjector(Class<?> type,Param param){
  if (Map.class.isAssignableFrom(type))   return new MapSelfInjector();
  if (null == param)   return super.evalInjector(type,param);
  String paramName=param.value();
  if (File.class.isAssignableFrom(type))   return new FileInjector(paramName);
  if (FieldMeta.class.isAssignableFrom(type))   return new FileMetaInjector(paramName);
  if (TempFile.class.isAssignableFrom(type))   return new TempFileInjector(paramName);
  if (InputStream.class.isAssignableFrom(type))   return new InputStreamInjector(paramName);
  if (Reader.class.isAssignableFrom(type))   return new ReaderInjector(paramName);
  if (List.class.isAssignableFrom(type))   return new MapListInjector(paramName);
  return super.evalInjector(type,param);
}"
80666,"@Test public void test_base(){
  resp=get(""String_Node_Str"");
  assertNotNull(resp);
  assertEquals(200,resp.getStatus());
  assertEquals(getContextPath(),resp.getContent());
}","@Test public void test_base(){
  get(""String_Node_Str"");
  assertNotNull(resp);
  assertEquals(200,resp.getStatus());
  assertEquals(getContextPath(),resp.getContent());
}"
80667,"public Response post(String path,Map<String,Object> params){
  resp=Sender.create(Request.create(""String_Node_Str"" + getContextPath() + path,METHOD.POST,params,null)).send();
  assertNotNull(resp);
  return resp;
}","public Response post(String path,Map<String,Object> params){
  resp=Sender.create(Request.create(getBaseURL() + path,METHOD.POST,params,null)).send();
  assertNotNull(resp);
  return resp;
}"
80668,"public Response get(String path){
  resp=Http.get(""String_Node_Str"" + getContextPath() + path);
  assertNotNull(resp);
  return resp;
}","public Response get(String path){
  resp=Http.get(getBaseURL() + path);
  assertNotNull(resp);
  return resp;
}"
80669,"public Sql insert(Entity<?> en,Object obj){
  StringBuilder fields=new StringBuilder();
  StringBuilder values=new StringBuilder();
  FieldMatcher fm=FieldFilter.get(en.getType());
  Map<String,Object> map=new HashMap<String,Object>();
  for (Iterator<EntityField> it=en.fields().iterator(); it.hasNext(); ) {
    EntityField ef=it.next();
    String fn=ef.getName();
    if (ef.isSerial() || ef.isReadonly())     continue;
    Object value=ef.getValue(obj);
    if (null != fm) {
      if (fm.isIgnoreNull() && null == value)       continue;
 else       if (!fm.match(fn))       continue;
    }
 else     if (null == value) {
      if (ef.hasDefaultValue())       value=ef.getDefaultValue(obj);
 else       continue;
    }
    fields.append(',').append(ef.getColumnName());
    values.append(""String_Node_Str"").append(fn);
    map.put(fn,value);
  }
  fields.deleteCharAt(0);
  values.deleteCharAt(0);
  Sql sql=Sqls.create(format(""String_Node_Str"",en.getTableName(),fields,values)).setEntity(en);
  sql.params().putAll(map);
  return sql;
}","public Sql insert(Entity<?> en,Object obj){
  StringBuilder fields=new StringBuilder();
  StringBuilder values=new StringBuilder();
  FieldMatcher fm=FieldFilter.get(en.getType());
  Map<String,Object> map=new HashMap<String,Object>();
  for (Iterator<EntityField> it=en.fields().iterator(); it.hasNext(); ) {
    EntityField ef=it.next();
    String fn=ef.getName();
    if (ef.isSerial() || ef.isReadonly())     continue;
    Object value=ef.getValue(obj);
    if (null != fm) {
      if (fm.isIgnoreNull() && null == value)       continue;
 else       if (!fm.match(fn))       continue;
    }
 else     if (null == value) {
      if (ef.hasDefaultValue())       value=ef.getDefaultValue(obj);
 else       continue;
    }
    fields.append(',').append(ef.getColumnName());
    values.append(""String_Node_Str"").append(fn);
    map.put(fn,value);
  }
  if (fields.length() == 0)   throw Lang.makeThrow(DaoException.class,""String_Node_Str"",en.getTableName());
  fields.deleteCharAt(0);
  values.deleteCharAt(0);
  Sql sql=Sqls.create(format(""String_Node_Str"",en.getTableName(),fields,values)).setEntity(en);
  sql.params().putAll(map);
  return sql;
}"
80670,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj instanceof Pair<?>)   if (Strings.equals(((Pair<?>)obj).name,name))   Lang.equals(((Pair<?>)obj).value,value);
  return false;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj instanceof Pair<?>)   if (Strings.equals(((Pair<?>)obj).name,name))   return Lang.equals(((Pair<?>)obj).value,value);
  return false;
}"
80671,"public static Pair<String> create(String s){
  String[] ss=Strings.splitIgnoreBlank(s,""String_Node_Str"");
  String name=null;
  String value=null;
  String pattern=PTN_3;
  if (null != ss)   if (ss.length == 1) {
    name=ss[0];
  }
 else   if (ss.length == 2) {
    name=ss[0];
    if (ss[1].length() > 0) {
      if (ss[1].charAt(0) == '""') {
        value=ss[1].substring(1,ss[1].length() - 2);
        pattern=PTN_3;
      }
 else       if (ss[1].charAt(0) == '\'') {
        value=ss[1].substring(1,ss[1].length() - 2);
        pattern=PTN_2;
      }
 else {
        value=ss[1];
        pattern=PTN_1;
      }
    }
  }
  Pair<String> re=new Pair<String>(name,value);
  re.pattern=pattern;
  return re;
}","public static Pair<String> create(String s){
  String[] ss=Strings.splitIgnoreBlank(s,""String_Node_Str"");
  String name=null;
  String value=null;
  String pattern=PTN_3;
  if (null != ss)   if (ss.length == 1) {
    name=ss[0];
  }
 else   if (ss.length == 2) {
    name=ss[0];
    if (ss[1].length() > 0) {
      if (ss[1].charAt(0) == '""') {
        value=ss[1].substring(1,ss[1].length() - 1);
        pattern=PTN_3;
      }
 else       if (ss[1].charAt(0) == '\'') {
        value=ss[1].substring(1,ss[1].length() - 1);
        pattern=PTN_2;
      }
 else {
        value=ss[1];
        pattern=PTN_1;
      }
    }
  }
  Pair<String> re=new Pair<String>(name,value);
  re.pattern=pattern;
  return re;
}"
80672,"@SuppressWarnings(""String_Node_Str"") private <T>T parseArray(Mirror<T> me,ParameterizedType type) throws Exception {
  Type tt=null;
  boolean reurnAsList=true;
  List list=null;
  if (null == me) {
    list=new LinkedList();
  }
 else   if (me.getType().isArray()) {
    list=new LinkedList();
    reurnAsList=false;
    tt=me.getType().getComponentType();
  }
 else   if (List.class.isAssignableFrom(me.getType())) {
    reurnAsList=true;
    if (me.is(List.class))     list=new LinkedList();
 else     list=(List)me.born();
    tt=type.getActualTypeArguments()[0];
  }
 else {
    throw makeError(String.format(""String_Node_Str"",me.getType().getName()));
  }
  nextChar();
  skipCommentsAndBlank();
  while (cursor != -1 && cursor != ']') {
    Object o=parseFromCurrentLocation(tt);
    list.add(o);
    skipCommentsAndBlank();
    if (cursor == ']')     break;
    if (cursor != ',')     throw makeError(""String_Node_Str"");
    nextChar();
    skipCommentsAndBlank();
  }
  nextChar();
  if (reurnAsList)   return (T)list;
  Object ary=Array.newInstance((Class<?>)tt,list.size());
  int i=0;
  for (Iterator it=list.iterator(); it.hasNext(); )   Array.set(ary,i++,Castors.me().castTo(it.next(),(Class<?>)tt));
  return (T)ary;
}","@SuppressWarnings(""String_Node_Str"") private <T>T parseArray(Mirror<T> me,ParameterizedType type) throws Exception {
  Type tt=null;
  boolean reurnAsList=true;
  List list=null;
  if (null == me) {
    list=new LinkedList();
  }
 else   if (me.getType().isArray()) {
    list=new LinkedList();
    reurnAsList=false;
    tt=me.getType().getComponentType();
  }
 else   if (List.class.isAssignableFrom(me.getType())) {
    reurnAsList=true;
    if (me.is(List.class))     list=new LinkedList();
 else     list=(List)me.born();
    if (type != null && type.getActualTypeArguments() != null)     tt=type.getActualTypeArguments()[0];
  }
 else {
    throw makeError(String.format(""String_Node_Str"",me.getType().getName()));
  }
  nextChar();
  skipCommentsAndBlank();
  while (cursor != -1 && cursor != ']') {
    Object o=parseFromCurrentLocation(tt);
    list.add(o);
    skipCommentsAndBlank();
    if (cursor == ']')     break;
    if (cursor != ',')     throw makeError(""String_Node_Str"");
    nextChar();
    skipCommentsAndBlank();
  }
  nextChar();
  if (reurnAsList)   return (T)list;
  Object ary=Array.newInstance((Class<?>)tt,list.size());
  int i=0;
  for (Iterator it=list.iterator(); it.hasNext(); )   Array.set(ary,i++,Castors.me().castTo(it.next(),(Class<?>)tt));
  return (T)ary;
}"
80673,"protected void parseArgs(Element beanElement,IocObject iocObject) throws Throwable {
  NodeList argsNodeList=beanElement.getElementsByTagName(TAG_ARGS);
  if (argsNodeList.getLength() > 0) {
    Element argsElement=(Element)argsNodeList.item(0);
    NodeList argNodeList=argsElement.getChildNodes();
    for (int i=0; i < argNodeList.getLength(); i++) {
      if (argNodeList.item(i) instanceof Element)       iocObject.addArg(parseX((Element)argNodeList.item(i)));
    }
  }
}","protected void parseArgs(Element beanElement,IocObject iocObject) throws Throwable {
  List<Element> list=getChildNodesByTagName(beanElement,TAG_ARGS);
  if (list.size() > 0) {
    Element argsElement=list.get(0);
    NodeList argNodeList=argsElement.getChildNodes();
    for (int i=0; i < argNodeList.getLength(); i++) {
      if (argNodeList.item(i) instanceof Element)       iocObject.addArg(parseX((Element)argNodeList.item(i)));
    }
  }
}"
80674,"protected void parseEvents(Element beanElement,IocObject iocObject){
  NodeList eventsNodeList=beanElement.getElementsByTagName(""String_Node_Str"");
  if (eventsNodeList.getLength() > 0) {
    Element eventsElement=(Element)eventsNodeList.item(0);
    IocEventSet iocEventSet=new IocEventSet();
    NodeList fetchNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (fetchNodeList.getLength() > 0)     iocEventSet.setFetch(((Element)fetchNodeList.item(0)).getTextContent());
    NodeList createNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (createNodeList.getLength() > 0)     iocEventSet.setCreate(((Element)createNodeList.item(0)).getTextContent());
    NodeList deposeNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (deposeNodeList.getLength() > 0)     iocEventSet.setDepose(((Element)deposeNodeList.item(0)).getTextContent());
    if (iocEventSet.getCreate() == null)     if (iocEventSet.getDepose() == null)     if (iocEventSet.getFetch() == null)     return;
    iocObject.setEvents(iocEventSet);
  }
}","protected void parseEvents(Element beanElement,IocObject iocObject){
  List<Element> elist=getChildNodesByTagName(beanElement,""String_Node_Str"");
  if (elist.size() > 0) {
    Element eventsElement=elist.get(0);
    IocEventSet iocEventSet=new IocEventSet();
    elist=getChildNodesByTagName(eventsElement,""String_Node_Str"");
    if (elist.size() > 0)     iocEventSet.setFetch(elist.get(0).getTextContent());
    elist=getChildNodesByTagName(eventsElement,""String_Node_Str"");
    if (elist.size() > 0)     iocEventSet.setCreate(elist.get(0).getTextContent());
    elist=getChildNodesByTagName(eventsElement,""String_Node_Str"");
    if (elist.size() > 0)     iocEventSet.setDepose(elist.get(0).getTextContent());
    if (iocEventSet.getCreate() == null)     if (iocEventSet.getDepose() == null)     if (iocEventSet.getFetch() == null)     return;
    iocObject.setEvents(iocEventSet);
  }
}"
80675,"protected Map<String,?> paserMap(Element element){
  Map<String,Object> map=new HashMap<String,Object>();
  if (element.hasChildNodes()) {
    NodeList nodeList=element.getElementsByTagName(ITEM_TAG);
    for (int i=0; i < nodeList.getLength(); i++) {
      if (nodeList.item(i) instanceof Element) {
        Element elementItem=(Element)nodeList.item(i);
        String key=elementItem.getAttribute(""String_Node_Str"");
        if (map.containsKey(key))         throw new IllegalArgumentException(""String_Node_Str"");
        NodeList list=elementItem.getChildNodes();
        for (int j=0; j < list.getLength(); j++) {
          if (list.item(j) instanceof Element) {
            map.put(key,list.item(j).getTextContent());
            break;
          }
        }
        if (!map.containsKey(key))         map.put(key,null);
      }
    }
  }
  return map;
}","protected Map<String,?> paserMap(Element element) throws Throwable {
  Map<String,Object> map=new HashMap<String,Object>();
  if (element.hasChildNodes()) {
    List<Element> elist=getChildNodesByTagName(element,ITEM_TAG);
    for (    Element elementItem : elist) {
      String key=elementItem.getAttribute(""String_Node_Str"");
      if (map.containsKey(key))       throw new IllegalArgumentException(""String_Node_Str"");
      NodeList list=elementItem.getChildNodes();
      for (int j=0; j < list.getLength(); j++) {
        if (list.item(j) instanceof Element) {
          map.put(key,parseX((Element)list.item(j)));
          break;
        }
      }
      if (!map.containsKey(key))       map.put(key,null);
    }
  }
  return map;
}"
80676,"protected void parseFields(Element beanElement,IocObject iocObject) throws Throwable {
  NodeList fieldNodeList=beanElement.getElementsByTagName(TAG_FIELD);
  if (fieldNodeList.getLength() > 0) {
    int len=fieldNodeList.getLength();
    for (int i=0; i < len; i++) {
      Element fieldElement=(Element)fieldNodeList.item(i);
      IocField iocField=new IocField();
      iocField.setName(fieldElement.getAttribute(""String_Node_Str""));
      if (fieldElement.hasChildNodes()) {
        NodeList nodeList=fieldElement.getChildNodes();
        for (int j=0; j < nodeList.getLength(); j++) {
          if (nodeList.item(j) instanceof Element) {
            iocField.setValue(parseX((Element)nodeList.item(j)));
            break;
          }
        }
      }
      iocObject.addField(iocField);
    }
  }
}","protected void parseFields(Element beanElement,IocObject iocObject) throws Throwable {
  List<Element> list=getChildNodesByTagName(beanElement,TAG_FIELD);
  for (  Element fieldElement : list) {
    IocField iocField=new IocField();
    iocField.setName(fieldElement.getAttribute(""String_Node_Str""));
    if (fieldElement.hasChildNodes()) {
      NodeList nodeList=fieldElement.getChildNodes();
      for (int j=0; j < nodeList.getLength(); j++) {
        if (nodeList.item(j) instanceof Element) {
          iocField.setValue(parseX((Element)nodeList.item(j)));
          break;
        }
      }
    }
    iocObject.addField(iocField);
  }
}"
80677,"public void rollback() throws SQLException {
  if (null == sp)   conn.rollback();
 else   conn.rollback(sp);
}","public void rollback() throws SQLException {
  if (null != sp)   conn.rollback(sp);
}"
80678,"@SuppressWarnings(""String_Node_Str"") public OptSymbolLoader(){
  root=new OptNode();
  List<Class<?>> optTypes=Scans.me().scanPackage(AbstractOperator.class);
  for (  Class<?> optType : optTypes) {
    if (!Modifier.isAbstract(optType.getModifiers()) && ElOperator.class.isAssignableFrom(optType) && null == optType.getAnnotation(OptHidden.class)) {
      Class<? extends ElOperator> theType=(Class<? extends ElOperator>)optType;
      ElOperator optObj=El.opt(theType);
      char[] cs=optObj.getString().toCharArray();
      OptNode on=root;
      for (      char c : cs) {
        on=on.addNode(c);
      }
      if (on.getOperator() != null) {
        throw Lang.makeThrow(""String_Node_Str"",on.getOperator().getClass().getName(),optType.getName());
      }
      on.setOperator(optObj);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") public OptSymbolLoader(){
  root=new OptNode();
  if (optTypes.size() == 0) {
synchronized (optTypes) {
      if (optTypes.size() == 0) {
        List<Class<?>> optTypes=Scans.me().scanPackage(AbstractOperator.class);
        for (        Class<?> optType : optTypes) {
          if (!Modifier.isAbstract(optType.getModifiers()) && ElOperator.class.isAssignableFrom(optType) && null == optType.getAnnotation(OptHidden.class)) {
            OptSymbolLoader.optTypes.add(optType);
          }
        }
      }
    }
  }
  for (  Class<?> optType : optTypes) {
    Class<? extends ElOperator> theType=(Class<? extends ElOperator>)optType;
    ElOperator optObj=El.opt(theType);
    char[] cs=optObj.getString().toCharArray();
    OptNode on=root;
    for (    char c : cs) {
      on=on.addNode(c);
    }
    if (on.getOperator() != null) {
      throw Lang.makeThrow(""String_Node_Str"",on.getOperator().getClass().getName(),optType.getName());
    }
    on.setOperator(optObj);
  }
}"
80679,"/** 
 * 获取一个Type类型实际对应的Class
 */
@SuppressWarnings(""String_Node_Str"") public static Class<?> getTypeClass(Type type){
  Class<?> clazz=null;
  if (type instanceof ParameterizedType) {
    ParameterizedType pt=(ParameterizedType)type;
    clazz=(Class<?>)pt.getRawType();
  }
 else   if (type instanceof Class<?>) {
    clazz=(Class<?>)type;
  }
 else   if (type instanceof GenericArrayType) {
    GenericArrayType gat=(GenericArrayType)type;
    return getTypeClass(gat.getGenericComponentType());
  }
 else   if (type instanceof TypeVariable) {
    TypeVariable tv=(TypeVariable)type;
    Type[] ts=tv.getBounds();
    if (ts != null && ts.length > 0)     return getTypeClass(ts[0]);
  }
 else   if (type instanceof WildcardType) {
    WildcardType wt=(WildcardType)type;
    Type[] t_low=wt.getLowerBounds();
    if (t_low.length > 0)     return getTypeClass(t_low[0]);
    Type[] t_up=wt.getUpperBounds();
    return getTypeClass(t_up[0]);
  }
  return clazz;
}","/** 
 * 获取一个Type类型实际对应的Class
 */
@SuppressWarnings(""String_Node_Str"") public static Class<?> getTypeClass(Type type){
  Class<?> clazz=null;
  if (type instanceof ParameterizedType) {
    ParameterizedType pt=(ParameterizedType)type;
    clazz=(Class<?>)pt.getRawType();
  }
 else   if (type instanceof Class<?>) {
    clazz=(Class<?>)type;
  }
 else   if (type instanceof GenericArrayType) {
    GenericArrayType gat=(GenericArrayType)type;
    Class<?> typeClass=getTypeClass(gat.getGenericComponentType());
    return Array.newInstance(typeClass,0).getClass();
  }
 else   if (type instanceof TypeVariable) {
    TypeVariable tv=(TypeVariable)type;
    Type[] ts=tv.getBounds();
    if (ts != null && ts.length > 0)     return getTypeClass(ts[0]);
  }
 else   if (type instanceof WildcardType) {
    WildcardType wt=(WildcardType)type;
    Type[] t_low=wt.getLowerBounds();
    if (t_low.length > 0)     return getTypeClass(t_low[0]);
    Type[] t_up=wt.getUpperBounds();
    return getTypeClass(t_up[0]);
  }
  return clazz;
}"
80680,"public RequestDispatcher getRequestDispatcher(String arg0){
  throw Lang.noImplement();
}","public RequestDispatcher getRequestDispatcher(String dest){
  return new MockRequestDispatcher(dispatcherTarget,dest);
}"
80681,"public MockHttpServletRequest(){
  this.headers=new HashMap<String,String>();
}","public MockHttpServletRequest(){
  this.headers=new HashMap<String,String>();
  this.dispatcherTarget=new String[1];
}"
80682,"protected String evalPath(HttpServletRequest req,Object obj){
  Context context=Lang.context();
  Context expContext=createContext(req,obj);
  for (  Entry<String,ElObj> en : exps.entrySet())   context.set(en.getKey(),en.getValue().eval(expContext).getString());
  return this.dest.render(context).toString();
}","protected String evalPath(HttpServletRequest req,Object obj){
  if (null == dest)   return null;
  Context context=Lang.context();
  Context expContext=createContext(req,obj);
  for (  Entry<String,ElObj> en : exps.entrySet())   context.set(en.getKey(),en.getValue().eval(expContext).getString());
  return Strings.trim(this.dest.render(context).toString());
}"
80683,"public AbstractPathView(String dest){
  this.dest=new CharSegment(Strings.trim(dest));
  this.exps=new HashMap<String,ElObj>();
  for (  String key : this.dest.keys()) {
    this.exps.put(key,El.compile(key));
  }
}","public AbstractPathView(String dest){
  if (null != dest) {
    this.dest=new CharSegment(Strings.trim(dest));
    this.exps=new HashMap<String,ElObj>();
    for (    String key : this.dest.keys()) {
      this.exps.put(key,El.compile(key));
    }
  }
}"
80684,"protected String getExt(){
  return ""String_Node_Str"";
}","/** 
 * 子类可以覆盖这个方法，给出自己特殊的后缀
 * @return 后缀
 */
protected String getExt(){
  return ""String_Node_Str"";
}"
80685,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  if (Strings.isBlank(path)) {
    path=Mvcs.getRequestPath(req);
    path=""String_Node_Str"" + Files.renameSuffix(path,getExt());
  }
  RequestDispatcher rd=req.getRequestDispatcher(path);
  if (rd == null)   throw Lang.makeThrow(""String_Node_Str"",path);
  rd.forward(req,resp);
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  String path=evalPath(req,obj);
  if (Strings.isBlank(path)) {
    path=Mvcs.getRequestPath(req);
    path=""String_Node_Str"" + (path.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + Files.renameSuffix(path,getExt());
  }
 else   if (path.charAt(0) == '/') {
    String ext=getExt();
    if (!path.toLowerCase().endsWith(ext))     path+=ext;
  }
 else {
    path=""String_Node_Str"" + path.replace('.','/') + getExt();
  }
  RequestDispatcher rd=req.getRequestDispatcher(path);
  if (rd == null)   throw Lang.makeThrow(""String_Node_Str"",path);
  rd.forward(req,resp);
}"
80686,"public ForwardView(String dest){
  super(dest);
}","public ForwardView(String dest){
  super(dest == null ? null : dest.replace('\\','/'));
}"
80687,"/** 
 * 为一次 HTTP 请求，创建一个可以被表达式引擎接受的上下文对象
 * @param req HTTP 请求对象
 * @param obj 入口函数的返回值
 * @return 上下文对象
 */
@SuppressWarnings(""String_Node_Str"") public static Context createContext(HttpServletRequest req,Object obj){
  Context context=Lang.context();
  Object servletContext=req.getSession().getServletContext().getAttribute(Loading.CONTEXT_NAME);
  if (servletContext != null) {
    context.putAll((Context)servletContext);
  }
  for (  Object o : req.getParameterMap().keySet()) {
    String key=(String)o;
    context.set(key,req.getParameter(key));
  }
  for (Enumeration<String> en=req.getAttributeNames(); en.hasMoreElements(); ) {
    String tem=en.nextElement();
    context.set(tem,req.getAttribute(tem));
  }
  if (null != obj)   context.set(ViewProcessor.DEFAULT_ATTRIBUTE,obj);
  return context;
}","/** 
 * 为一次 HTTP 请求，创建一个可以被表达式引擎接受的上下文对象
 * @param req HTTP 请求对象
 * @param obj 入口函数的返回值
 * @return 上下文对象
 */
@SuppressWarnings(""String_Node_Str"") public static Context createContext(HttpServletRequest req,Object obj){
  Context context=Lang.context();
  Object servletContext=req.getSession().getServletContext().getAttribute(Loading.CONTEXT_NAME);
  if (servletContext != null) {
    context.putAll((Context)servletContext);
  }
  Map<String,String> p=new HashMap<String,String>();
  for (  Object o : req.getParameterMap().keySet()) {
    String key=(String)o;
    context.set(key,req.getParameter(key));
    p.put(key,req.getParameter(key));
  }
  context.set(""String_Node_Str"",p);
  for (Enumeration<String> en=req.getAttributeNames(); en.hasMoreElements(); ) {
    String tem=en.nextElement();
    context.set(tem,req.getAttribute(tem));
  }
  if (null != obj)   context.set(ViewProcessor.DEFAULT_ATTRIBUTE,obj);
  return context;
}"
80688,"/** 
 * @param < T >
 * @param type
 * @return
 * @throws Exception
 */
private Object parseFromCurrentLocation(Type type) throws Exception {
  Class<?> clazz=null;
  ParameterizedType pt=null;
  if (type instanceof Class) {
    clazz=(Class<?>)type;
  }
  if (type instanceof ParameterizedType) {
    pt=(ParameterizedType)type;
    clazz=(Class<?>)pt.getRawType();
  }
  Mirror<?> me=Mirror.me(clazz);
switch (cursor) {
case -1:
    return null;
case '[':
  return parseArray(me,pt);
case '{':
return parseObj(me,pt);
case 'u':
return parseUndefined();
case 'n':
return parseNull();
case '\'':
case '""':
return parseString(me);
case 't':
return parseTrue(me);
case 'f':
return parseFalse(me);
case '.':
case '-':
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
return parseNumber(me);
case 'v':
while (-1 != nextChar()) if ('{' == cursor) return parseFromCurrentLocation(type);
default :
throw makeError(""String_Node_Str"");
}
}","/** 
 * @param < T >
 * @param type
 * @return
 * @throws Exception
 */
private Object parseFromCurrentLocation(Type type) throws Exception {
  Class<?> clazz=Lang.getTypeClass(type);
  ParameterizedType pt=null;
  if (type instanceof ParameterizedType) {
    pt=(ParameterizedType)type;
    clazz=(Class<?>)pt.getRawType();
  }
  Mirror<?> me=Mirror.me(clazz);
switch (cursor) {
case -1:
    return null;
case '[':
  return parseArray(me,pt);
case '{':
return parseObj(me,pt);
case 'u':
return parseUndefined();
case 'n':
return parseNull();
case '\'':
case '""':
return parseString(me);
case 't':
return parseTrue(me);
case 'f':
return parseFalse(me);
case '.':
case '-':
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
return parseNumber(me);
case 'v':
while (-1 != nextChar()) if ('{' == cursor) return parseFromCurrentLocation(type);
default :
throw makeError(""String_Node_Str"");
}
}"
80689,"/** 
 * 获取一个类的某个一个泛型参数
 * @param klass 类
 * @param index 参数下标 （从 0 开始）
 * @return 泛型参数类型
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Class<T> getTypeParam(Class<?> klass,int index){
  Type[] types=getTypeParams(klass);
  if (index >= 0 && index < types.length) {
    Type t=types[index];
    if (t instanceof Class<?>) {
      return (Class<T>)t;
    }
 else     if (t instanceof ParameterizedType) {
      t=((ParameterizedType)t).getRawType();
      return (Class<T>)t;
    }
    throw Lang.makeThrow(""String_Node_Str"",t.toString());
  }
  throw Lang.makeThrow(""String_Node_Str"",index,types.length);
}","/** 
 * 获取一个类的某个一个泛型参数
 * @param klass 类
 * @param index 参数下标 （从 0 开始）
 * @return 泛型参数类型
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Class<T> getTypeParam(Class<?> klass,int index){
  Type[] types=getTypeParams(klass);
  if (index >= 0 && index < types.length) {
    Type t=types[index];
    Class<T> clazz=(Class<T>)Lang.getTypeClass(t);
    if (clazz == null)     throw Lang.makeThrow(""String_Node_Str"",t.toString());
    return clazz;
  }
  throw Lang.makeThrow(""String_Node_Str"",index,types.length);
}"
80690,"public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[injs.length];
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  int i=0;
  for (; i < len; i++) {
    args[i]=injs[i].get(sc,req,resp,null == pathArgs ? null : pathArgs[i]);
  }
  Class<?>[] argTypes=method.getParameterTypes();
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(sc,req,resp,null);
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  return args;
}","public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[injs.length];
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  int i=0;
  for (; i < len; i++) {
    args[i]=injs[i].get(sc,req,resp,null == pathArgs ? null : pathArgs[i]);
  }
  Class<?>[] argTypes=method.getParameterTypes();
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(sc,req,resp,null);
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=Lang.getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  return args;
}"
80691,"public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null == name)   return Json.fromJson(type,refer.toString());
  NutMap map=Json.fromJson(NutMap.class,refer.toString());
  Object theObj=map.get(name);
  if (null == theObj)   return null;
  Class<?> clazz=null;
  if (type instanceof ParameterizedType) {
    clazz=(Class<?>)((ParameterizedType)type).getRawType();
  }
  clazz=(Class<?>)type;
  return Castors.me().castTo(theObj,clazz);
}","public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null == name)   return Json.fromJson(type,refer.toString());
  NutMap map=Json.fromJson(NutMap.class,refer.toString());
  Object theObj=map.get(name);
  if (null == theObj)   return null;
  Class<?> clazz=Lang.getTypeClass(type);
  return Castors.me().castTo(theObj,clazz);
}"
80692,"public ActionChain eval(NutConfig config,ActionInfo ai){
  try {
    List<Processor> list=new ArrayList<Processor>();
    for (    String name : co.getProcessors(ai.getChainName())) {
      Processor processor=getProcessorByName(config,name);
      processor.init(config,ai);
      list.add(processor);
    }
    Processor errorProcessor=getProcessorByName(config,co.getErrorProcessor(ai.getChainName()));
    errorProcessor.init(config,ai);
    return new NutActionChain(list,errorProcessor);
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
}","public ActionChain eval(NutConfig config,ActionInfo ai){
  try {
    List<Processor> list=new ArrayList<Processor>();
    for (    String name : co.getProcessors(ai.getChainName())) {
      Processor processor=getProcessorByName(config,name);
      processor.init(config,ai);
      list.add(processor);
    }
    Processor errorProcessor=getProcessorByName(config,co.getErrorProcessor(ai.getChainName()));
    errorProcessor.init(config,ai);
    ActionChain chain=new NutActionChain(list,errorProcessor);
    return chain;
  }
 catch (  Throwable e) {
    if (logger.isDebugEnabled())     logger.debugf(""String_Node_Str"",ai.getMethod());
    throw Lang.wrapThrow(e);
  }
}"
80693,"public void process(ActionContext ac) throws Throwable {
  Object re=ac.getMethodReturn();
  Object err=ac.getError();
  if (re != null && re instanceof View) {
    if (re instanceof ViewWrapper)     putRequestAttribute(ac.getRequest(),((ViewWrapper)re).getData());
    ((View)re).render(ac.getRequest(),ac.getResponse(),err);
  }
 else {
    putRequestAttribute(ac.getRequest(),re);
    view.render(ac.getRequest(),ac.getResponse(),null == re ? err : re);
  }
  doNext(ac);
}","public void process(ActionContext ac) throws Throwable {
  Object re=ac.getMethodReturn();
  Object err=ac.getError();
  if (re != null && re instanceof View) {
    if (re instanceof ViewWrapper)     putRequestAttribute(ac.getRequest(),((ViewWrapper)re).getData());
    ((View)re).render(ac.getRequest(),ac.getResponse(),err);
  }
 else {
    putRequestAttribute(ac.getRequest(),null == re ? err : re);
    view.render(ac.getRequest(),ac.getResponse(),null == re ? err : re);
  }
  doNext(ac);
}"
80694,"public void init(FilterConfig conf) throws ServletException {
  FilterNutConfig config=new FilterNutConfig(conf);
  String skipMode=Strings.sNull(conf.getInitParameter(""String_Node_Str""),""String_Node_Str"").toLowerCase();
  if (!""String_Node_Str"".equals(skipMode)) {
    handler=new ActionHandler(config);
    String regx=Strings.sNull(config.getInitParameter(""String_Node_Str""),IGNORE);
    if (!""String_Node_Str"".equalsIgnoreCase(regx)) {
      ignorePtn=Pattern.compile(regx,Pattern.CASE_INSENSITIVE);
    }
  }
 else   this.skipMode=true;
}","public void init(FilterConfig conf) throws ServletException {
  FilterNutConfig config=new FilterNutConfig(conf);
  String skipMode=Strings.sNull(conf.getInitParameter(""String_Node_Str""),""String_Node_Str"").toLowerCase();
  if (!""String_Node_Str"".equals(skipMode)) {
    handler=new ActionHandler(config);
    String regx=Strings.sNull(config.getInitParameter(""String_Node_Str""),IGNORE);
    if (!""String_Node_Str"".equalsIgnoreCase(regx)) {
      ignorePtn=Pattern.compile(regx,Pattern.CASE_INSENSITIVE);
    }
  }
 else   this.skipMode=true;
  String doNextFilter=Strings.sNull(conf.getInitParameter(""String_Node_Str""),""String_Node_Str"").toLowerCase();
  this.doNextFilter=""String_Node_Str"".equals(doNextFilter);
}"
80695,"public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  if (!skipMode) {
    RequestPath path=Mvcs.getRequestPathObject((HttpServletRequest)req);
    if (null == ignorePtn || !ignorePtn.matcher(path.getUrl()).find()) {
      if (handler.handle((HttpServletRequest)req,(HttpServletResponse)resp))       return;
    }
  }
 else {
    Mvcs.updateRequestAttributes((HttpServletRequest)req);
  }
  chain.doFilter(req,resp);
}","public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  if (!skipMode) {
    RequestPath path=Mvcs.getRequestPathObject((HttpServletRequest)req);
    if (null == ignorePtn || !ignorePtn.matcher(path.getUrl()).find()) {
      if (handler.handle((HttpServletRequest)req,(HttpServletResponse)resp))       if (!doNextFilter)       return;
    }
  }
  Mvcs.updateRequestAttributes((HttpServletRequest)req);
  chain.doFilter(req,resp);
}"
80696,"@Override public void init(NutConfig config,ActionInfo ai) throws Throwable {
  method=ai.getMethod();
  moduleType=ai.getModuleType();
  if (!Strings.isBlank(ai.getInjectName()))   injectName=ai.getInjectName();
}","@Override public void init(NutConfig config,ActionInfo ai) throws Throwable {
  method=ai.getMethod();
  moduleType=ai.getModuleType();
  if (Strings.isBlank(ai.getInjectName())) {
    moduleObj=Mirror.me(moduleType).born();
  }
 else {
    injectName=ai.getInjectName();
  }
}"
80697,"public void process(ActionContext ac) throws Throwable {
  RequestIocContext reqContext=null;
  try {
    if (null == injectName) {
      ac.setModule(Mirror.me(moduleType).born());
    }
 else {
      Ioc ioc=ac.getIoc();
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",injectName);
      Object obj;
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(ac.getRequest());
        SessionIocContext sessionContext=new SessionIocContext(ac.getRequest().getSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        obj=((Ioc2)ioc).get(moduleType,injectName,myContext);
      }
 else       obj=ioc.get(moduleType,injectName);
      ac.setModule(obj);
    }
    ac.setMethod(method);
    doNext(ac);
  }
  finally {
    if (reqContext != null)     try {
      reqContext.depose();
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}","public void process(ActionContext ac) throws Throwable {
  RequestIocContext reqContext=null;
  try {
    if (null != moduleObj) {
      ac.setModule(moduleObj);
    }
 else {
      Ioc ioc=ac.getIoc();
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",injectName);
      Object obj;
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(ac.getRequest());
        SessionIocContext sessionContext=new SessionIocContext(ac.getRequest().getSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        obj=((Ioc2)ioc).get(moduleType,injectName,myContext);
      }
 else       obj=ioc.get(moduleType,injectName);
      ac.setModule(obj);
    }
    ac.setMethod(method);
    doNext(ac);
  }
  finally {
    if (reqContext != null)     try {
      reqContext.depose();
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}"
80698,"@Override public void process(ActionContext ac) throws Throwable {
  super.process(ac);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"",ac.getError());
}","@Override public void process(ActionContext ac) throws Throwable {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"",ac.getError());
  super.process(ac);
}"
80699,"public List<NutResource> list(String src,String filter){
  final List<NutResource> list=new LinkedList<NutResource>();
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  File f=Files.findFile(src);
  if (f != null && f.exists()) {
    if (f.isFile())     list.addAll(scanInDir(regex,src,f.getParentFile(),ignoreHidden));
 else     list.addAll(scanInDir(regex,src,f,ignoreHidden));
  }
 else {
    String path=Disks.absolute(src,getClass().getClassLoader(),Encoding.defaultEncoding());
    if (null != path) {
      f=new File(path);
      if (!path.contains(""String_Node_Str"")) {
        int pos=path.lastIndexOf(src);
        list.addAll(scanInDir(regex,path.substring(0,pos),f,ignoreHidden));
      }
 else {
        JarEntryInfo jeInfo=new JarEntryInfo(path);
        list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
      }
    }
 else {
      String classpath=System.getProperties().getProperty(""String_Node_Str"");
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + classpath);
      String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
      for (      String pathZ : paths) {
        if (pathZ.endsWith(""String_Node_Str""))         list.addAll(scanInJar(checkSrc(src),regex,pathZ));
 else         list.addAll(scanInDir(regex,pathZ,new File(pathZ + ""String_Node_Str"" + src),ignoreHidden));
      }
    }
  }
  return list;
}","public List<NutResource> list(String src,String filter){
  final List<NutResource> list=new LinkedList<NutResource>();
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  File f=Files.findFile(src);
  if (f != null && f.exists()) {
    if (f.isFile())     list.addAll(scanInDir(regex,src,f.getParentFile(),ignoreHidden));
 else     list.addAll(scanInDir(regex,src,f,ignoreHidden));
  }
 else {
    String path=Disks.absolute(src,getClass().getClassLoader(),Encoding.defaultEncoding());
    if (null != path) {
      f=new File(path);
      if (!path.contains(""String_Node_Str"")) {
        int pos=path.lastIndexOf(src);
        if (pos > 0)         list.addAll(scanInDir(regex,path.substring(0,pos),f,ignoreHidden));
      }
 else {
        JarEntryInfo jeInfo=new JarEntryInfo(path);
        list.addAll(scanInJar(checkSrc(jeInfo.getEntryName()),regex,jeInfo.getJarPath()));
      }
    }
 else {
      String classpath=System.getProperties().getProperty(""String_Node_Str"");
      if (LOG.isInfoEnabled())       LOG.info(""String_Node_Str"" + classpath);
      String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
      for (      String pathZ : paths) {
        if (pathZ.endsWith(""String_Node_Str""))         list.addAll(scanInJar(checkSrc(src),regex,pathZ));
 else         list.addAll(scanInDir(regex,pathZ,new File(pathZ + ""String_Node_Str"" + src),ignoreHidden));
      }
    }
  }
  return list;
}"
80700,"public BinElObj append(ElOperator opt,ElObj obj){
  if (null == operator) {
    return setOperator(opt).setRight(obj);
  }
  BinElObj nn=new BinElObj();
  if (opt.isHigherThan(operator)) {
    if (right instanceof BinElObj) {
      setRight(((BinElObj)right).append(opt,obj));
    }
 else {
      nn.setLeft(right).setOperator(opt).setRight(obj);
      setRight(nn);
    }
  }
 else {
    BinElObj on=this;
    while (on.parent != null) {
      on=on.parent;
      if (!on.getOperator().isHigherThan(opt))       break;
    }
    nn.setLeft(on).setOperator(opt).setRight(obj);
  }
  return nn;
}","public BinElObj append(ElOperator opt,ElObj obj){
  if (null == operator) {
    return setOperator(opt).setRight(obj);
  }
  BinElObj nn;
  if (opt.isHigherThan(operator)) {
    if (right instanceof BinElObj) {
      nn=((BinElObj)right).append(opt,obj);
    }
 else {
      nn=new BinElObj();
      nn.setLeft(right).setOperator(opt).setRight(obj);
      setRight(nn);
    }
  }
 else {
    nn=new BinElObj();
    BinElObj on=this;
    while (on.parent != null) {
      if (!on.getOperator().isHigherThan(opt))       break;
      on=on.parent;
    }
    nn.parent=on.parent;
    nn.setLeft(on).setOperator(opt).setRight(obj);
    if (null != nn.parent)     nn.parent.setRight(nn);
  }
  return nn;
}"
80701,"Map<String,Map<String,String>> load(String refer);","Map<String,Map<String,Object>> load(String refer);"
80702,"private void evalLocalization(NutConfig config,Class<?> mainModule){
  Localization lc=mainModule.getAnnotation(Localization.class);
  if (null != lc) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",lc.value());
    Map<String,Map<String,String>> msgss=Mirror.me(lc.type()).born().load(lc.value());
    config.setAttributeIgnoreNull(Localization.class.getName(),msgss);
  }
 else   if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
}","private void evalLocalization(NutConfig config,Class<?> mainModule){
  Localization lc=mainModule.getAnnotation(Localization.class);
  if (null != lc) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",lc.value());
    Map<String,Map<String,Object>> msgss=Mirror.me(lc.type()).born().load(lc.value());
    config.setAttributeIgnoreNull(Localization.class.getName(),msgss);
  }
 else   if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"");
  }
}"
80703,"public Map<String,Map<String,String>> load(String refer){
  Map<String,Map<String,String>> re=new HashMap<String,Map<String,String>>();
  List<NutResource> allnrs=Scans.me().scan(refer,""String_Node_Str"");
  for (  NutResource nutResource : allnrs) {
    if (nutResource.getName().indexOf(refer) > -1)     nutResource.setName(nutResource.getName().substring(refer.length() + 1));
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",allnrs.size(),allnrs);
  int max=0;
  for (  NutResource nr : allnrs) {
    String[] nms=nr.getName().split(""String_Node_Str"");
    max=Math.max(max,nms.length);
  }
  Map<String,List<NutResource>> map=new HashMap<String,List<NutResource>>();
  for (  NutResource nr : allnrs) {
    String langType;
    String resName=nr.getName();
    if (resName.contains(""String_Node_Str""))     langType=resName.substring(0,resName.indexOf('/'));
 else     if (resName.contains(""String_Node_Str""))     langType=resName.substring(0,resName.indexOf('\\'));
 else     langType=Mvcs.DEFAULT_MSGS;
    List<NutResource> list=map.get(langType);
    if (null == list) {
      list=new ArrayList<NutResource>(10);
      map.put(langType,list);
    }
    list.add(nr);
  }
  try {
    for (    Entry<String,List<NutResource>> entry : map.entrySet()) {
      List<NutResource> nrs=entry.getValue();
      for (      NutResource nr : nrs) {
        MultiLineProperties p=new MultiLineProperties(){
          public String get(          Object key){
            return Strings.sNull(super.get(key),(String)key);
          }
        }
;
        Reader r=nr.getReader();
        p.load(r);
        r.close();
        Map<String,String> langs=re.get(entry.getKey());
        if (null == langs)         re.put(entry.getKey(),p);
 else         langs.putAll(p);
      }
    }
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",re.size());
  if (log.isTraceEnabled())   log.tracef(""String_Node_Str"",Json.toJson(re));
  return re;
}","public Map<String,Map<String,Object>> load(String refer){
  Map<String,Map<String,Object>> re=new HashMap<String,Map<String,Object>>();
  List<NutResource> allnrs=Scans.me().scan(refer,""String_Node_Str"");
  for (  NutResource nutResource : allnrs) {
    if (nutResource.getName().indexOf(refer) > -1)     nutResource.setName(nutResource.getName().substring(refer.length() + 1));
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",allnrs.size(),allnrs);
  int max=0;
  for (  NutResource nr : allnrs) {
    String[] nms=nr.getName().split(""String_Node_Str"");
    max=Math.max(max,nms.length);
  }
  Map<String,List<NutResource>> map=new HashMap<String,List<NutResource>>();
  for (  NutResource nr : allnrs) {
    String langType;
    String resName=nr.getName();
    if (resName.contains(""String_Node_Str""))     langType=resName.substring(0,resName.indexOf('/'));
 else     if (resName.contains(""String_Node_Str""))     langType=resName.substring(0,resName.indexOf('\\'));
 else     langType=Mvcs.DEFAULT_MSGS;
    List<NutResource> list=map.get(langType);
    if (null == list) {
      list=new ArrayList<NutResource>(10);
      map.put(langType,list);
    }
    list.add(nr);
  }
  try {
    for (    Entry<String,List<NutResource>> entry : map.entrySet()) {
      List<NutResource> nrs=entry.getValue();
      String langType=entry.getKey();
      for (      NutResource nr : nrs) {
        MultiLineProperties p=new MultiLineProperties();
        Reader r=nr.getReader();
        p.load(r);
        r.close();
        Map<String,Object> msgs=re.get(langType);
        if (null == msgs) {
          msgs=new NutMessageMap();
          re.put(langType,msgs);
        }
        for (        String key : p.keySet()) {
          String str=p.get(key);
          Segment seg=(new CharSegment()).valueOf(str);
          if (seg.keys().isEmpty())           msgs.put(key,str);
 else           msgs.put(key,seg);
        }
      }
    }
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",re.size());
  if (log.isTraceEnabled())   log.tracef(""String_Node_Str"",Json.toJson(re));
  return re;
}"
80704,"public List<NutResource> list(final String src,String filter){
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  final List<NutResource> list=new ArrayList<NutResource>();
  Set<String> jars=sc.getResourcePaths(""String_Node_Str"");
  if (jars != null)   for (  String path : jars) {
    if (!path.toLowerCase().endsWith(""String_Node_Str""))     continue;
    list.addAll(scanInJar(checkSrc(src),regex,sc.getRealPath(path)));
  }
  File dir=Files.findFile(src);
  boolean flag=true;
  if (null != dir && dir.exists()) {
    String src2=Disks.getCanonicalPath(src);
    String dirPath=Disks.getCanonicalPath(dir.getAbsolutePath());
    int pos=dirPath.indexOf(src2,dirPath.indexOf(""String_Node_Str"") + 7);
    final String base=pos < 0 ? dirPath : dirPath.substring(0,pos);
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",dir,base);
    List<NutResource> list2=scanInDir(regex,base,dir,true);
    for (    NutResource nutResource : list2) {
      String name=nutResource.getName();
      if (name.indexOf(base) > -1)       nutResource.setName(name.substring(base.length()));
      list.add(nutResource);
    }
    flag=list2.isEmpty();
  }
  if (flag && (!src.startsWith(""String_Node_Str""))) {
    try {
      String base=sc.getRealPath(""String_Node_Str"");
      String path=sc.getRealPath(""String_Node_Str"" + src);
      if (path != null) {
        List<NutResource> list2=scanInDir(regex,base,new File(path),true);
        for (        NutResource nutResource : list2) {
          String name=nutResource.getName();
          if (name.indexOf(base) > -1)           nutResource.setName(name.substring(base.length()));
          list.add(nutResource);
        }
        flag=list2.isEmpty();
      }
    }
 catch (    Throwable e) {
    }
  }
  if (flag && log.isInfoEnabled())   log.infof(""String_Node_Str"",src,sc.getServletContextName());
  return list;
}","public List<NutResource> list(final String src,String filter){
  final Pattern regex=null == filter ? null : Pattern.compile(filter);
  final List<NutResource> list=new ArrayList<NutResource>();
  Set<String> jars=sc.getResourcePaths(""String_Node_Str"");
  if (jars != null)   for (  String path : jars) {
    if (!path.toLowerCase().endsWith(""String_Node_Str""))     continue;
    list.addAll(scanInJar(checkSrc(src),regex,sc.getRealPath(path)));
  }
  File dir=Files.findFile(src);
  boolean flag=true;
  if (null != dir && dir.exists()) {
    String src2=Disks.getCanonicalPath(src);
    String dirPath=Disks.getCanonicalPath(dir.getAbsolutePath());
    int pos=dirPath.indexOf(src2,dirPath.indexOf(""String_Node_Str"") + 7);
    final String base=pos < 0 ? dirPath : dirPath.substring(0,pos);
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",dir,base);
    List<NutResource> list2=scanInDir(regex,base,dir,true);
    for (    NutResource nutResource : list2) {
      String name=nutResource.getName();
      if (name.indexOf(base) > -1)       nutResource.setName(name.substring(base.length()));
      list.add(nutResource);
    }
    flag=list2.isEmpty();
  }
  if (flag && (!src.startsWith(""String_Node_Str""))) {
    try {
      String base=sc.getRealPath(""String_Node_Str"");
      String path=sc.getRealPath(""String_Node_Str"" + src);
      if (path != null) {
        List<NutResource> list2=scanInDir(regex,base,new File(path),true);
        for (        NutResource nutResource : list2) {
          String name=nutResource.getName();
          if (name.indexOf(base) > -1)           nutResource.setName(name.substring(base.length()));
          list.add(nutResource);
        }
        flag=list2.isEmpty();
      }
    }
 catch (    Throwable e) {
    }
  }
  if (flag) {
    String classpath=System.getProperties().getProperty(""String_Node_Str"");
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + classpath);
    String[] paths=classpath.split(System.getProperties().getProperty(""String_Node_Str""));
    for (    String pathZ : paths) {
      if (pathZ.endsWith(""String_Node_Str""))       list.addAll(scanInJar(checkSrc(src),regex,pathZ));
 else       list.addAll(scanInDir(regex,pathZ,new File(pathZ + ""String_Node_Str"" + src),true));
    }
    flag=list.isEmpty();
  }
  if (flag && log.isInfoEnabled())   log.infof(""String_Node_Str"",src,sc.getServletContextName());
  return list;
}"
80705,"private void string2Json(String s) throws IOException {
  if (null == s)   writer.append(""String_Node_Str"");
 else {
    char[] cs=s.toCharArray();
    writer.append(format.getSeparator());
    for (    char c : cs) {
switch (c) {
case '""':
        writer.append(""String_Node_Str"");
      break;
case '\n':
    writer.append(""String_Node_Str"");
  break;
case '\t':
writer.append(""String_Node_Str"");
break;
case '\r':
writer.append(""String_Node_Str"");
break;
case '\\':
writer.append(""String_Node_Str"");
break;
default :
writer.append(c);
}
}
writer.append(format.getSeparator());
}
}","private void string2Json(String s) throws IOException {
  if (null == s)   writer.append(""String_Node_Str"");
 else {
    char[] cs=s.toCharArray();
    writer.append(format.getSeparator());
    for (    char c : cs) {
switch (c) {
case '""':
        writer.append(""String_Node_Str"");
      break;
case '\n':
    writer.append(""String_Node_Str"");
  break;
case '\t':
writer.append(""String_Node_Str"");
break;
case '\r':
writer.append(""String_Node_Str"");
break;
case '\\':
writer.append(""String_Node_Str"");
break;
default :
if (c >= 256 && format.isAutoUnicode()) writer.append(""String_Node_Str"").append(Integer.toHexString(c).toUpperCase());
 else writer.append(c);
}
}
writer.append(format.getSeparator());
}
}"
80706,"public void init(Method method){
  Class<?>[] argTypes=method.getParameterTypes();
  injs=new ParamInjector[argTypes.length];
  Annotation[][] annss=method.getParameterAnnotations();
  for (int i=0; i < annss.length; i++) {
    Annotation[] anns=annss[i];
    Param param=null;
    Attr attr=null;
    IocObj iocObj=null;
    for (int x=0; x < anns.length; x++)     if (anns[x] instanceof Param) {
      param=(Param)anns[x];
      break;
    }
 else     if (anns[x] instanceof Attr) {
      attr=(Attr)anns[x];
      break;
    }
 else     if (anns[x] instanceof IocObj) {
      iocObj=(IocObj)anns[x];
      break;
    }
    if (null != attr) {
      injs[i]=evalInjectorByAttrScope(attr);
      continue;
    }
    if (null != iocObj) {
      injs[i]=new IocObjInjector(method.getParameterTypes()[i],iocObj.value());
      continue;
    }
    injs[i]=evalInjectorByParamType(argTypes[i]);
    if (null != injs[i])     continue;
    injs[i]=evalInjector(argTypes[i],param);
    if (null == injs[i])     injs[i]=new ErrorInjector(method,i);
  }
}","public void init(Method method){
  this.method=method;
  Class<?>[] argTypes=method.getParameterTypes();
  injs=new ParamInjector[argTypes.length];
  Annotation[][] annss=method.getParameterAnnotations();
  for (int i=0; i < annss.length; i++) {
    Annotation[] anns=annss[i];
    Param param=null;
    Attr attr=null;
    IocObj iocObj=null;
    for (int x=0; x < anns.length; x++)     if (anns[x] instanceof Param) {
      param=(Param)anns[x];
      break;
    }
 else     if (anns[x] instanceof Attr) {
      attr=(Attr)anns[x];
      break;
    }
 else     if (anns[x] instanceof IocObj) {
      iocObj=(IocObj)anns[x];
      break;
    }
    if (null != attr) {
      injs[i]=evalInjectorByAttrScope(attr);
      continue;
    }
    if (null != iocObj) {
      injs[i]=new IocObjInjector(method.getParameterTypes()[i],iocObj.value());
      continue;
    }
    injs[i]=evalInjectorByParamType(argTypes[i]);
    if (null != injs[i])     continue;
    injs[i]=evalInjector(argTypes[i],param);
    if (null == injs[i])     injs[i]=new ErrorInjector(method,i);
  }
}"
80707,"public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[injs.length];
  int i=0;
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  for (; i < len; i++) {
    args[i]=injs[i].get(sc,req,resp,null == pathArgs ? null : pathArgs[i]);
  }
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(sc,req,resp,null);
  }
  return args;
}","public Object[] adapt(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  Object[] args=new Object[injs.length];
  int len=Math.min(args.length,null == pathArgs ? 0 : pathArgs.length);
  for (int i=0; i < len; i++) {
    args[i]=injs[i].get(sc,req,resp,null == pathArgs ? null : pathArgs[i]);
  }
  Class<?>[] argTypes=method.getParameterTypes();
  for (int i=0; i < injs.length; i++) {
    args[i]=injs[i].get(sc,req,resp,null);
    if (args[i] == null && argTypes[i].isPrimitive()) {
      args[i]=getPrimitiveDefaultValue(argTypes[i]);
    }
  }
  return args;
}"
80708,"@Override public String cast(Calendar src,Class<?> toType,String... args){
  return dateTimeFormat.format(src.getTime());
}","@Override public String cast(Calendar src,Class<?> toType,String... args){
  return ((DateFormat)dateTimeFormat.clone()).format(src.getTime());
}"
80709,"@Override public String cast(java.util.Date src,Class<?> toType,String... args){
  return dateTimeFormat.format(src);
}","@Override public String cast(java.util.Date src,Class<?> toType,String... args){
  return ((DateFormat)dateTimeFormat.clone()).format(src);
}"
80710,"@Override public String cast(java.sql.Date src,Class<?> toType,String... args){
  return dateFormat.format(new java.util.Date(src.getTime()));
}","@Override public String cast(java.sql.Date src,Class<?> toType,String... args){
  return ((DateFormat)dateFormat.clone()).format(new java.util.Date(src.getTime()));
}"
80711,"@Override public String cast(java.sql.Time src,Class<?> toType,String... args){
  return timeFormat.format(new java.util.Date(src.getTime()));
}","@Override public String cast(java.sql.Time src,Class<?> toType,String... args){
  return ((DateFormat)timeFormat.clone()).format(new java.util.Date(src.getTime()));
}"
80712,"@Override public Calendar cast(String src,Class<?> toType,String... args){
  Calendar c=Calendar.getInstance();
  try {
    c.setTime(dateTimeFormat.parse(src));
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
  return c;
}","@Override public Calendar cast(String src,Class<?> toType,String... args){
  Calendar c=Calendar.getInstance();
  try {
    c.setTime(((DateFormat)dateTimeFormat.clone()).parse(src));
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
  return c;
}"
80713,"@Override public java.util.Date cast(String src,Class<?> toType,String... args){
  try {
    return this.dateTimeFormat.parse(src);
  }
 catch (  ParseException e1) {
    try {
      return dateFormat.parse(src);
    }
 catch (    ParseException e) {
      throw Lang.wrapThrow(e);
    }
  }
}","@Override public java.util.Date cast(String src,Class<?> toType,String... args){
  try {
    return ((DateFormat)dateTimeFormat.clone()).parse(src);
  }
 catch (  ParseException e1) {
    try {
      return ((DateFormat)dateFormat.clone()).parse(src);
    }
 catch (    ParseException e) {
      throw Lang.wrapThrow(e);
    }
  }
}"
80714,"@Override public java.sql.Date cast(String src,Class<?> toType,String... args){
  try {
    return new java.sql.Date(dateFormat.parse(src).getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}","@Override public java.sql.Date cast(String src,Class<?> toType,String... args){
  try {
    return new java.sql.Date(((DateFormat)dateFormat.clone()).parse(src).getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}"
80715,"@Override public java.sql.Time cast(String src,Class<?> toType,String... args){
  try {
    return new java.sql.Time(timeFormat.parse(src).getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}","@Override public java.sql.Time cast(String src,Class<?> toType,String... args){
  try {
    return new java.sql.Time(((DateFormat)timeFormat.clone()).parse(src).getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}"
80716,"@Override public Timestamp cast(String src,Class<?> toType,String... args){
  try {
    return new java.sql.Timestamp(dateTimeFormat.parse(src).getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}","@Override public Timestamp cast(String src,Class<?> toType,String... args){
  try {
    return new java.sql.Timestamp(((DateFormat)dateTimeFormat.clone()).parse(src).getTime());
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}"
80717,"@Override public String cast(Timestamp src,Class<?> toType,String... args){
  return dateTimeFormat.format(new java.util.Date(src.getTime()));
}","@Override public String cast(Timestamp src,Class<?> toType,String... args){
  return ((DateFormat)dateTimeFormat.clone()).format(new java.util.Date(src.getTime()));
}"
80718,"public void render(final StringBuilder sb,Entity<?> en){
  if (null != en) {
    EntityField ef=en.getField(name);
    sb.append(null != ef ? ef.getColumnName() : name);
  }
 else   sb.append(name);
  if (""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"");
    if (null == value)     throw Lang.makeThrow(""String_Node_Str"",sb);
    if (value instanceof Collection<?> || value.getClass().isArray()) {
      sb.append('(');
      Lang.each(value,new Each<Object>(){
        public void invoke(        int i,        Object ele,        int length) throws ExitLoop, LoopException {
          sb.append(Sqls.formatSqlFieldValue(ele)).append(',');
        }
      }
);
      sb.setCharAt(sb.length() - 1,')');
    }
 else     sb.append(Sqls.formatSqlFieldValue(value));
  }
 else   if (null == value && op.startsWith(""String_Node_Str"")) {
    sb.append(' ').append(op).append(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    sb.append(' ').append(op).append(' ').append(Sqls.formatSqlFieldValue(value));
  }
 else {
    sb.append(op).append(Sqls.formatSqlFieldValue(value));
  }
}","public void render(final StringBuilder sb,Entity<?> en){
  if (null != en) {
    EntityField ef=en.getField(name);
    sb.append(null != ef ? ef.getColumnName() : name);
  }
 else   sb.append(name);
  if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"").append(op).append(""String_Node_Str"");
    if (null == value)     throw Lang.makeThrow(""String_Node_Str"",op,sb);
    if (value instanceof Collection<?> || value.getClass().isArray()) {
      sb.append('(');
      Lang.each(value,new Each<Object>(){
        public void invoke(        int i,        Object ele,        int length) throws ExitLoop, LoopException {
          sb.append(Sqls.formatSqlFieldValue(ele)).append(',');
        }
      }
);
      sb.setCharAt(sb.length() - 1,')');
    }
 else     sb.append(Sqls.formatSqlFieldValue(value));
  }
 else   if (null == value && op.startsWith(""String_Node_Str"")) {
    sb.append(' ').append(op).append(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    sb.append(' ').append(op).append(' ').append(Sqls.formatSqlFieldValue(value));
  }
 else {
    sb.append(op).append(Sqls.formatSqlFieldValue(value));
  }
}"
80719,"public Map<String,Object> parse(HttpServletRequest req,UploadingContext context) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  int bufferSize=context.getBufferSize();
  String charset=context.getCharset();
  FilePool tmps=context.getFilePool();
  int maxFileSize=context.getMaxFileSize();
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  NutMap params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes firstBoundaryBytes=RemountBytes.create(firstBoundary);
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes itemEndlBytes=RemountBytes.create(itemEndl);
  RemountBytes nameEndlBytes=RemountBytes.create(""String_Node_Str"");
  if (Http.multipart.getBoundary(req.getContentType()) == null) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"");
    return params;
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  try {
    FieldMeta meta;
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString(charset);
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (!context.isNameAccepted(meta.getFileLocalName())) {
          throw new UploadUnsupportedFileNameException(meta);
        }
        if (!context.isContentTypeAccepted(meta.getContentType())) {
          throw new UploadUnsupportedFileTypeException(meta);
        }
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            if (maxFileSize > 0) {
              long maxPos=info.current + maxFileSize;
              do {
                info.current=br.load();
                mm=br.mark(itemEndlBytes);
                assertStreamNotEnd(mm);
                if (info.current > maxPos) {
                  throw new UploadOutOfSizeException(meta);
                }
                br.dump(ops);
              }
 while (mm == MarkMode.NOT_FOUND);
            }
 else {
              do {
                info.current=br.load();
                mm=br.mark(itemEndlBytes);
                assertStreamNotEnd(mm);
                br.dump(ops);
              }
 while (mm == MarkMode.NOT_FOUND);
            }
          }
  finally {
            Streams.safeFlush(ops);
            Streams.safeClose(ops);
          }
          if (context.isIgnoreNull() && tmp.length() == 0) {
          }
 else {
            params.add(meta.getName(),new TempFile(meta,tmp));
          }
        }
      }
 else {
        StringBuilder sb=new StringBuilder();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          sb.append(br.dumpAsString(charset));
        }
 while (mm == MarkMode.NOT_FOUND);
        params.add(meta.getName(),sb.toString());
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",meta.getName(),sb.toString());
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}","public Map<String,Object> parse(HttpServletRequest req,UploadingContext context) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  int bufferSize=context.getBufferSize();
  String charset=context.getCharset();
  FilePool tmps=context.getFilePool();
  int maxFileSize=context.getMaxFileSize();
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  NutMap params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes firstBoundaryBytes=RemountBytes.create(firstBoundary);
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes itemEndlBytes=RemountBytes.create(itemEndl);
  RemountBytes nameEndlBytes=RemountBytes.create(""String_Node_Str"");
  if (Http.multipart.getBoundary(req.getContentType()) == null) {
    if (log.isInfoEnabled())     log.info(""String_Node_Str"");
    return params;
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  try {
    FieldMeta meta;
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString(charset);
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (!context.isNameAccepted(meta.getFileLocalName())) {
          throw new UploadUnsupportedFileNameException(meta);
        }
        if (!context.isContentTypeAccepted(meta.getContentType())) {
          throw new UploadUnsupportedFileTypeException(meta);
        }
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            if (maxFileSize > 0) {
              long maxPos=info.current + maxFileSize;
              do {
                info.current=br.load();
                mm=br.mark(itemEndlBytes);
                assertStreamNotEnd(mm);
                if (info.current > maxPos) {
                  throw new UploadOutOfSizeException(meta);
                }
                br.dump(ops);
                if (info.stop)                 throw new UploadStopException(info);
              }
 while (mm == MarkMode.NOT_FOUND);
            }
 else {
              do {
                info.current=br.load();
                mm=br.mark(itemEndlBytes);
                assertStreamNotEnd(mm);
                br.dump(ops);
                if (info.stop)                 throw new UploadStopException(info);
              }
 while (mm == MarkMode.NOT_FOUND);
            }
          }
  finally {
            Streams.safeFlush(ops);
            Streams.safeClose(ops);
          }
          if (context.isIgnoreNull() && tmp.length() == 0) {
          }
 else {
            params.add(meta.getName(),new TempFile(meta,tmp));
          }
        }
      }
 else {
        StringBuilder sb=new StringBuilder();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          sb.append(br.dumpAsString(charset));
        }
 while (mm == MarkMode.NOT_FOUND);
        params.add(meta.getName(),sb.toString());
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",meta.getName(),sb.toString());
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}"
80720,"public void doChain() throws Throwable {
  if (filters.isEmpty())   return;
  filters.remove(0).filter(this);
}","public void doChain() throws Throwable {
  if (filters.isEmpty())   return;
  ActionFilter filter=filters.remove(0);
  filter.filter(this);
}"
80721,"public ObjectPairInjector(String prefix,Class<?> type){
  prefix=Strings.isBlank(prefix) ? ""String_Node_Str"" : Strings.trim(prefix);
  this.mirror=Mirror.me(type);
  Field[] fields=mirror.getFields();
  this.injs=new Injecting[fields.length];
  this.names=new String[fields.length];
  for (int i=0; i < fields.length; i++) {
    Field f=fields[i];
    this.injs[i]=mirror.getInjecting(f.getName());
    Param param=f.getAnnotation(Param.class);
    String nm=null == param ? f.getName() : param.value();
    this.names[i]=prefix + nm;
  }
}","public ObjectPairInjector(String prefix,Class<?> type){
  prefix=Strings.isBlank(prefix) ? ""String_Node_Str"" : Strings.trim(prefix);
  this.mirror=Mirror.me(type);
  fields=mirror.getFields();
  this.injs=new Injecting[fields.length];
  this.names=new String[fields.length];
  for (int i=0; i < fields.length; i++) {
    Field f=fields[i];
    this.injs[i]=mirror.getInjecting(f.getName());
    Param param=f.getAnnotation(Param.class);
    String nm=null == param ? f.getName() : param.value();
    this.names[i]=prefix + nm;
  }
}"
80722,"public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object obj=mirror.born();
  for (int i=0; i < injs.length; i++) {
    String[] ss=req.getParameterValues(names[i]);
    if (null == ss)     continue;
    injs[i].inject(obj,ss);
  }
  return obj;
}","public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object obj=mirror.born();
  for (int i=0; i < injs.length; i++) {
    String[] ss=filterParam(req.getParameterValues(names[i]),i);
    if (null == ss)     continue;
    injs[i].inject(obj,ss);
  }
  return obj;
}"
80723,"private EntityField evalField(DatabaseMeta db,ResultSetMetaData rsmd,Entity<?> entity,Field field) throws SQLException {
  field.setAccessible(true);
  EntityField ef=new EntityField(entity,field);
  Column column=field.getAnnotation(Column.class);
  if (null == column || Strings.isBlank(column.value()))   ef.setColumnName(field.getName());
 else   ef.setColumnName(column.value());
  int ci=Daos.getColumnIndex(rsmd,ef.getColumnName());
  ef.setReadonly((field.getAnnotation(Readonly.class) != null));
  if (null != rsmd)   ef.setNotNull(ResultSetMetaData.columnNoNulls == rsmd.isNullable(ci));
  if (null != rsmd)   if (ef.getMirror().isEnum()) {
    if (Daos.isIntLikeColumn(rsmd,ci))     ef.setType(FieldType.ENUM_INT);
  }
  Default dft=field.getAnnotation(Default.class);
  if (null != dft) {
    ef.setDefaultValue(new CharSegment(dft.value()));
  }
  Prev prev=field.getAnnotation(Prev.class);
  if (null != prev) {
    ef.setBeforeInsert(FieldQuerys.eval(db,prev.value(),ef));
  }
  Next next=field.getAnnotation(Next.class);
  if (null != next) {
    ef.setAfterInsert(FieldQuerys.eval(db,next.value(),ef));
  }
  Id id=field.getAnnotation(Id.class);
  if (null != id) {
    if (!ef.getMirror().isIntLike())     throw error(entity,""String_Node_Str"",field.getName());
    if (id.auto()) {
      ef.setType(FieldType.SERIAL);
      if (null == field.getAnnotation(Next.class)) {
        ef.setAfterInsert(FieldQuerys.create(""String_Node_Str"",ef));
      }
    }
 else {
      ef.setType(FieldType.ID);
    }
  }
  Name name=field.getAnnotation(Name.class);
  if (null != name) {
    if (!ef.getMirror().isStringLike())     throw error(entity,""String_Node_Str"",field.getName());
    ef.setNotNull(true);
    if (name.casesensitive())     ef.setType(FieldType.CASESENSITIVE_NAME);
 else     ef.setType(FieldType.NAME);
  }
  ef.setFieldAdapter(FieldAdapter.create(ef.getMirror(),ef.isEnumInt()));
  ef.setValueAdapter(ValueAdapter.create(ef.getMirror(),ef.isEnumInt()));
  return ef;
}","protected EntityField evalField(DatabaseMeta db,ResultSetMetaData rsmd,Entity<?> entity,Field field) throws SQLException {
  field.setAccessible(true);
  EntityField ef=new EntityField(entity,field);
  Column column=field.getAnnotation(Column.class);
  if (null == column || Strings.isBlank(column.value()))   ef.setColumnName(field.getName());
 else   ef.setColumnName(column.value());
  int ci=Daos.getColumnIndex(rsmd,ef.getColumnName());
  ef.setReadonly((field.getAnnotation(Readonly.class) != null));
  if (null != rsmd)   ef.setNotNull(ResultSetMetaData.columnNoNulls == rsmd.isNullable(ci));
  if (null != rsmd)   if (ef.getMirror().isEnum()) {
    if (Daos.isIntLikeColumn(rsmd,ci))     ef.setType(FieldType.ENUM_INT);
  }
  Default dft=field.getAnnotation(Default.class);
  if (null != dft) {
    ef.setDefaultValue(new CharSegment(dft.value()));
  }
  Prev prev=field.getAnnotation(Prev.class);
  if (null != prev) {
    ef.setBeforeInsert(FieldQuerys.eval(db,prev.value(),ef));
  }
  Next next=field.getAnnotation(Next.class);
  if (null != next) {
    ef.setAfterInsert(FieldQuerys.eval(db,next.value(),ef));
  }
  Id id=field.getAnnotation(Id.class);
  if (null != id) {
    if (!ef.getMirror().isIntLike())     throw error(entity,""String_Node_Str"",field.getName());
    if (id.auto()) {
      ef.setType(FieldType.SERIAL);
      if (null == field.getAnnotation(Next.class)) {
        ef.setAfterInsert(FieldQuerys.create(""String_Node_Str"",ef));
      }
    }
 else {
      ef.setType(FieldType.ID);
    }
  }
  Name name=field.getAnnotation(Name.class);
  if (null != name) {
    if (!ef.getMirror().isStringLike())     throw error(entity,""String_Node_Str"",field.getName());
    ef.setNotNull(true);
    if (name.casesensitive())     ef.setType(FieldType.CASESENSITIVE_NAME);
 else     ef.setType(FieldType.NAME);
  }
  ef.setFieldAdapter(FieldAdapter.create(ef.getMirror(),ef.isEnumInt()));
  ef.setValueAdapter(ValueAdapter.create(ef.getMirror(),ef.isEnumInt()));
  return ef;
}"
80724,"private EntityName evalEntityName(Class<?> type,Class<? extends Annotation> annType,Class<? extends Annotation> dftAnnType){
  Annotation ann=null;
  Class<?> me=type;
  while (null != me && !(me == Object.class)) {
    ann=me.getAnnotation(annType);
    if (ann != null) {
      String v=Mirror.me(annType).invoke(ann,""String_Node_Str"").toString();
      if (!Strings.isBlank(v))       return EntityName.create(v);
    }
    me=me.getSuperclass();
  }
  if (null != dftAnnType)   return evalEntityName(type,dftAnnType,null);
  return EntityName.create(type.getSimpleName().toLowerCase());
}","protected EntityName evalEntityName(Class<?> type,Class<? extends Annotation> annType,Class<? extends Annotation> dftAnnType){
  Annotation ann=null;
  Class<?> me=type;
  while (null != me && !(me == Object.class)) {
    ann=me.getAnnotation(annType);
    if (ann != null) {
      String v=Mirror.me(annType).invoke(ann,""String_Node_Str"").toString();
      if (!Strings.isBlank(v))       return EntityName.create(v);
    }
    me=me.getSuperclass();
  }
  if (null != dftAnnType)   return evalEntityName(type,dftAnnType,null);
  return EntityName.create(type.getSimpleName().toLowerCase());
}"
80725,"private boolean isPojoExistsColumnAnnField(Mirror<?> mirror){
  for (  Field f : mirror.getFields())   if (null != f.getAnnotation(Column.class))   return true;
  return false;
}","protected boolean isPojoExistsColumnAnnField(Mirror<?> mirror){
  for (  Field f : mirror.getFields())   if (null != f.getAnnotation(Column.class))   return true;
  return false;
}"
80726,"private Link evalLink(DatabaseMeta db,Connection conn,Mirror<?> mirror,Field field){
  try {
    One one=field.getAnnotation(One.class);
    if (null != one) {
      Mirror<?> ta=Mirror.me(one.target());
      Field referFld=mirror.getField(one.field());
      Field targetPkFld=lookupPkByReferField(ta,referFld);
      return Link.getLinkForOne(mirror,field,ta.getType(),referFld,targetPkFld);
    }
    Many many=field.getAnnotation(Many.class);
    if (null != many) {
      Mirror<?> ta=Mirror.me(many.target());
      Field pkFld;
      Field targetReferFld;
      if (Strings.isBlank(many.field())) {
        pkFld=null;
        targetReferFld=null;
      }
 else {
        targetReferFld=ta.getField(many.field());
        pkFld=lookupPkByReferField(mirror,targetReferFld);
      }
      return Link.getLinkForMany(mirror,field,ta.getType(),targetReferFld,pkFld,many.key());
    }
    ManyMany mm=field.getAnnotation(ManyMany.class);
    if (null != mm) {
      Statement stat=null;
      ResultSet rs=null;
      ResultSetMetaData rsmd=null;
      boolean fromName=false;
      boolean toName=false;
      try {
        stat=conn.createStatement();
        Segment tableName=new CharSegment(mm.relation());
        rs=stat.executeQuery(db.getResultSetMetaSql(TableName.render(tableName)));
        rsmd=rs.getMetaData();
        fromName=!Daos.isIntLikeColumn(rsmd,mm.from());
        toName=!Daos.isIntLikeColumn(rsmd,mm.to());
      }
 catch (      Exception e) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"" + ""String_Node_Str"",mm.relation(),mm.from(),mm.to());
      }
 finally {
        Daos.safeClose(stat,rs);
      }
      Mirror<?> ta=Mirror.me(mm.target());
      Field selfPk=mirror.getField(fromName ? Name.class : Id.class);
      Field targetPk=ta.getField(toName ? Name.class : Id.class);
      return Link.getLinkForManyMany(mirror,field,ta.getType(),selfPk,targetPk,mm.key(),mm.relation(),mm.from(),mm.to());
    }
  }
 catch (  NoSuchFieldException e) {
    throw Lang.makeThrow(""String_Node_Str"",field.getName(),mirror.getType().getName(),e.getMessage());
  }
  return null;
}","protected Link evalLink(DatabaseMeta db,Connection conn,Mirror<?> mirror,Field field){
  try {
    One one=field.getAnnotation(One.class);
    if (null != one) {
      Mirror<?> ta=Mirror.me(one.target());
      Field referFld=mirror.getField(one.field());
      Field targetPkFld=lookupPkByReferField(ta,referFld);
      return Link.getLinkForOne(mirror,field,ta.getType(),referFld,targetPkFld);
    }
    Many many=field.getAnnotation(Many.class);
    if (null != many) {
      Mirror<?> ta=Mirror.me(many.target());
      Field pkFld;
      Field targetReferFld;
      if (Strings.isBlank(many.field())) {
        pkFld=null;
        targetReferFld=null;
      }
 else {
        targetReferFld=ta.getField(many.field());
        pkFld=lookupPkByReferField(mirror,targetReferFld);
      }
      return Link.getLinkForMany(mirror,field,ta.getType(),targetReferFld,pkFld,many.key());
    }
    ManyMany mm=field.getAnnotation(ManyMany.class);
    if (null != mm) {
      Statement stat=null;
      ResultSet rs=null;
      ResultSetMetaData rsmd=null;
      boolean fromName=false;
      boolean toName=false;
      try {
        stat=conn.createStatement();
        Segment tableName=new CharSegment(mm.relation());
        rs=stat.executeQuery(db.getResultSetMetaSql(TableName.render(tableName)));
        rsmd=rs.getMetaData();
        fromName=!Daos.isIntLikeColumn(rsmd,mm.from());
        toName=!Daos.isIntLikeColumn(rsmd,mm.to());
      }
 catch (      Exception e) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"" + ""String_Node_Str"",mm.relation(),mm.from(),mm.to());
      }
 finally {
        Daos.safeClose(stat,rs);
      }
      Mirror<?> ta=Mirror.me(mm.target());
      Field selfPk=mirror.getField(fromName ? Name.class : Id.class);
      Field targetPk=ta.getField(toName ? Name.class : Id.class);
      return Link.getLinkForManyMany(mirror,field,ta.getType(),selfPk,targetPk,mm.key(),mm.relation(),mm.from(),mm.to());
    }
  }
 catch (  NoSuchFieldException e) {
    throw Lang.makeThrow(""String_Node_Str"",field.getName(),mirror.getType().getName(),e.getMessage());
  }
  return null;
}"
80727,"private static Field lookupPkByReferField(Mirror<?> mirror,Field fld) throws NoSuchFieldException {
  Mirror<?> fldType=Mirror.me(fld.getType());
  if (fldType.isStringLike()) {
    return mirror.getField(Name.class);
  }
 else   if (fldType.isIntLike()) {
    return mirror.getField(Id.class);
  }
  throw Lang.makeThrow(""String_Node_Str"",fld.getDeclaringClass().getName(),fld.getName());
}","protected static Field lookupPkByReferField(Mirror<?> mirror,Field fld) throws NoSuchFieldException {
  Mirror<?> fldType=Mirror.me(fld.getType());
  if (fldType.isStringLike()) {
    return mirror.getField(Name.class);
  }
 else   if (fldType.isIntLike()) {
    return mirror.getField(Id.class);
  }
  throw Lang.makeThrow(""String_Node_Str"",fld.getDeclaringClass().getName(),fld.getName());
}"
80728,"private ErrorEntitySyntaxException error(Entity<?> entity,String fmt,Object... args){
  return new ErrorEntitySyntaxException(String.format(""String_Node_Str"",null == entity ? ""String_Node_Str"" : entity.getType().getName(),String.format(fmt,args)));
}","protected ErrorEntitySyntaxException error(Entity<?> entity,String fmt,Object... args){
  return new ErrorEntitySyntaxException(String.format(""String_Node_Str"",null == entity ? ""String_Node_Str"" : entity.getType().getName(),String.format(fmt,args)));
}"
80729,"public boolean isNameAccepted(String name){
  if (null == nameFilter)   return true;
  if (null == name)   return false;
  return Pattern.matches(nameFilter,name.toLowerCase());
}","public boolean isNameAccepted(String name){
  if (null == nameFilter)   return true;
  if (Strings.isBlank(name))   return true;
  return Pattern.matches(nameFilter,name.toLowerCase());
}"
80730,"public boolean isContentTypeAccepted(String contentType){
  if (null == contentTypeFilter)   return true;
  if (null == contentType)   return false;
  return Pattern.matches(contentTypeFilter,contentType.toLowerCase());
}","public boolean isContentTypeAccepted(String contentType){
  if (null == contentTypeFilter)   return true;
  if (Strings.isBlank(contentType))   return true;
  return Pattern.matches(contentTypeFilter,contentType.toLowerCase());
}"
80731,"public boolean add(List<ViewMaker> makers,Class<?> moduleType){
  Ok myOk=moduleType.getAnnotation(Ok.class);
  if (null == myOk)   myOk=ok;
  Fail myFail=moduleType.getAnnotation(Fail.class);
  if (null == myFail)   myFail=fail;
  AdaptBy myAb=moduleType.getAnnotation(AdaptBy.class);
  if (null == myAb)   myAb=adaptBy;
  Filters myFlts=moduleType.getAnnotation(Filters.class);
  if (null == myFlts)   myFlts=filters;
  Encoding myEncoding=moduleType.getAnnotation(Encoding.class);
  if (null == myEncoding)   myEncoding=encoding;
  At baseAt=moduleType.getAnnotation(At.class);
  String[] bases;
  if (null == baseAt)   bases=Lang.array(""String_Node_Str"");
 else   if (null == baseAt.value() || baseAt.value().length == 0)   bases=Lang.array(""String_Node_Str"" + moduleType.getSimpleName().toLowerCase());
 else {
    bases=baseAt.value();
    for (int i=0; i < bases.length; i++)     if (bases[i] == null || ""String_Node_Str"".equals(bases[i]))     bases[i]=""String_Node_Str"";
  }
  boolean isModule=false;
  for (  Method method : moduleType.getMethods()) {
    if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))     continue;
    At atAnn=method.getAnnotation(At.class);
    isModule=true;
    ActionInvoker invoker=new ActionInvokerImpl(context,ioc,makers,moduleType,method,myOk,myFail,myAb,myFlts,myEncoding);
    String actionPath=null;
    for (    String base : bases) {
      String[] paths=atAnn.value();
      if ((paths.length == 1 && Strings.isBlank(paths[0])) || paths.length == 0) {
        actionPath=base + ""String_Node_Str"" + method.getName().toLowerCase();
        root.add(actionPath,invoker);
        if (log.isDebugEnabled())         log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
      }
 else {
        for (        String at : paths) {
          actionPath=base + at;
          root.add(actionPath,invoker);
          if (log.isDebugEnabled())           log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
        }
      }
    }
    if (!Strings.isBlank(atAnn.key()) && !Strings.isBlank(actionPath))     config.atMap().add(atAnn.key(),actionPath);
  }
  return isModule;
}","public boolean add(List<ViewMaker> makers,Class<?> moduleType){
  Ok myOk=moduleType.getAnnotation(Ok.class);
  if (null == myOk)   myOk=ok;
  Fail myFail=moduleType.getAnnotation(Fail.class);
  if (null == myFail)   myFail=fail;
  AdaptBy myAb=moduleType.getAnnotation(AdaptBy.class);
  if (null == myAb)   myAb=adaptBy;
  Filters myFlts=moduleType.getAnnotation(Filters.class);
  if (null == myFlts)   myFlts=filters;
  Encoding myEncoding=moduleType.getAnnotation(Encoding.class);
  if (null == myEncoding)   myEncoding=encoding;
  At baseAt=moduleType.getAnnotation(At.class);
  String[] bases;
  if (null == baseAt)   bases=Lang.array(""String_Node_Str"");
 else   if (null == baseAt.value() || baseAt.value().length == 0)   bases=Lang.array(""String_Node_Str"" + moduleType.getSimpleName().toLowerCase());
 else {
    bases=baseAt.value();
    for (int i=0; i < bases.length; i++)     if (bases[i] == null || ""String_Node_Str"".equals(bases[i]))     bases[i]=""String_Node_Str"";
  }
  boolean isModule=false;
  for (  Method method : moduleType.getMethods()) {
    if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))     continue;
    At atAnn=method.getAnnotation(At.class);
    isModule=true;
    ActionInvoker invoker=new ActionInvokerImpl(context,ioc,makers,moduleType,method,myOk,myFail,myAb,myFlts,myEncoding);
    String actionPath=null;
    for (    String base : bases) {
      String[] paths=atAnn.value();
      if ((paths.length == 1 && Strings.isBlank(paths[0])) || paths.length == 0) {
        actionPath=base + ""String_Node_Str"" + method.getName().toLowerCase();
        root.add(actionPath,invoker);
        if (log.isDebugEnabled())         log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
      }
 else {
        for (        String at : paths) {
          if (Strings.isBlank(at)) {
            throw new BlankAtException(moduleType,method);
          }
          actionPath=base + at;
          root.add(actionPath,invoker);
          if (log.isDebugEnabled())           log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
        }
      }
    }
    if (!Strings.isBlank(atAnn.key()) && !Strings.isBlank(actionPath))     config.atMap().add(atAnn.key(),actionPath);
  }
  return isModule;
}"
80732,"private void _insertSelf(Entity<?> entity,Object obj){
  runFieldQuery(entity.getBefores(),obj);
  execute(sqlMaker.insert(entity,obj));
  runFieldQuery(entity.getAfters(),obj);
}","private void _insertSelf(final Entity<?> entity,final Object obj){
  Trans.exec(new Atom(){
    public void run(){
      runFieldQuery(entity.getBefores(),obj);
      execute(sqlMaker.insert(entity,obj));
      runFieldQuery(entity.getAfters(),obj);
    }
  }
);
}"
80733,"public static RequestPath getRequestPathObject(HttpServletRequest req){
  RequestPath rr=new RequestPath();
  String url=req.getPathInfo();
  if (null == url)   url=req.getServletPath();
  rr.setUrl(url);
  if (null != url) {
    int lio=url.lastIndexOf('.');
    if (lio > 0) {
      rr.setPath(url.substring(0,lio));
      rr.setSuffix(url.substring(lio + 1));
    }
 else {
      rr.setPath(url);
      rr.setSuffix(""String_Node_Str"");
    }
  }
 else {
    rr.setPath(""String_Node_Str"");
    rr.setSuffix(""String_Node_Str"");
  }
  return rr;
}","public static RequestPath getRequestPathObject(HttpServletRequest req){
  RequestPath rr=new RequestPath();
  String url=req.getPathInfo();
  if (null == url)   url=req.getServletPath();
  rr.setUrl(url);
  if (null != url) {
    int lio=0;
    if (!url.endsWith(""String_Node_Str"")) {
      int ll=url.lastIndexOf('/');
      lio=url.lastIndexOf('.');
      if (lio < ll)       lio=-1;
    }
    if (lio > 0) {
      rr.setPath(url.substring(0,lio));
      rr.setSuffix(url.substring(lio + 1));
    }
 else {
      rr.setPath(url);
      rr.setSuffix(""String_Node_Str"");
    }
  }
 else {
    rr.setPath(""String_Node_Str"");
    rr.setSuffix(""String_Node_Str"");
  }
  return rr;
}"
80734,"public boolean add(List<ViewMaker> makers,Class<?> moduleType){
  Ok myOk=moduleType.getAnnotation(Ok.class);
  if (null == myOk)   myOk=ok;
  Fail myFail=moduleType.getAnnotation(Fail.class);
  if (null == myFail)   myFail=fail;
  AdaptBy myAb=moduleType.getAnnotation(AdaptBy.class);
  if (null == myAb)   myAb=adaptBy;
  Filters myFlts=moduleType.getAnnotation(Filters.class);
  if (null == myFlts)   myFlts=filters;
  Encoding myEncoding=moduleType.getAnnotation(Encoding.class);
  if (null == myEncoding)   myEncoding=encoding;
  At baseAt=moduleType.getAnnotation(At.class);
  String[] bases;
  if (null == baseAt)   bases=Lang.array(""String_Node_Str"");
 else   if (null == baseAt.value() || baseAt.value().length == 0)   bases=Lang.array(""String_Node_Str"" + moduleType.getSimpleName().toLowerCase());
 else   bases=baseAt.value();
  boolean isModule=false;
  for (  Method method : moduleType.getMethods()) {
    if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))     continue;
    At atAnn=method.getAnnotation(At.class);
    isModule=true;
    ActionInvoker invoker=new ActionInvokerImpl(context,ioc,makers,moduleType,method,myOk,myFail,myAb,myFlts,myEncoding);
    String actionPath=null;
    for (    String base : bases) {
      String[] paths=atAnn.value();
      if ((paths.length == 1 && Strings.isBlank(paths[0])) || paths.length == 0) {
        actionPath=base + ""String_Node_Str"" + method.getName().toLowerCase();
        root.add(actionPath,invoker);
        if (log.isDebugEnabled())         log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
      }
 else {
        for (        String at : paths) {
          actionPath=base + at;
          root.add(actionPath,invoker);
          if (log.isDebugEnabled())           log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
        }
      }
    }
    if (!Strings.isBlank(atAnn.key()) && !Strings.isBlank(actionPath))     config.atMap().add(atAnn.key(),actionPath);
  }
  return isModule;
}","public boolean add(List<ViewMaker> makers,Class<?> moduleType){
  Ok myOk=moduleType.getAnnotation(Ok.class);
  if (null == myOk)   myOk=ok;
  Fail myFail=moduleType.getAnnotation(Fail.class);
  if (null == myFail)   myFail=fail;
  AdaptBy myAb=moduleType.getAnnotation(AdaptBy.class);
  if (null == myAb)   myAb=adaptBy;
  Filters myFlts=moduleType.getAnnotation(Filters.class);
  if (null == myFlts)   myFlts=filters;
  Encoding myEncoding=moduleType.getAnnotation(Encoding.class);
  if (null == myEncoding)   myEncoding=encoding;
  At baseAt=moduleType.getAnnotation(At.class);
  String[] bases;
  if (null == baseAt)   bases=Lang.array(""String_Node_Str"");
 else   if (null == baseAt.value() || baseAt.value().length == 0)   bases=Lang.array(""String_Node_Str"" + moduleType.getSimpleName().toLowerCase());
 else {
    bases=baseAt.value();
    for (int i=0; i < bases.length; i++)     if (bases[i] == null || ""String_Node_Str"".equals(bases[i]))     bases[i]=""String_Node_Str"";
  }
  boolean isModule=false;
  for (  Method method : moduleType.getMethods()) {
    if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))     continue;
    At atAnn=method.getAnnotation(At.class);
    isModule=true;
    ActionInvoker invoker=new ActionInvokerImpl(context,ioc,makers,moduleType,method,myOk,myFail,myAb,myFlts,myEncoding);
    String actionPath=null;
    for (    String base : bases) {
      String[] paths=atAnn.value();
      if ((paths.length == 1 && Strings.isBlank(paths[0])) || paths.length == 0) {
        actionPath=base + ""String_Node_Str"" + method.getName().toLowerCase();
        root.add(actionPath,invoker);
        if (log.isDebugEnabled())         log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
      }
 else {
        for (        String at : paths) {
          actionPath=base + at;
          root.add(actionPath,invoker);
          if (log.isDebugEnabled())           log.debug(String.format(""String_Node_Str"",method.getName(),actionPath));
        }
      }
    }
    if (!Strings.isBlank(atAnn.key()) && !Strings.isBlank(actionPath))     config.atMap().add(atAnn.key(),actionPath);
  }
  return isModule;
}"
80735,"public static RequestPath getRequestPathObject(HttpServletRequest req){
  RequestPath rr=new RequestPath();
  String url=req.getPathInfo();
  if (null == url)   url=req.getServletPath();
  rr.setUrl(url);
  if (null != url) {
    int lio=0;
    if (!url.endsWith(""String_Node_Str"")) {
      int ll=url.lastIndexOf('/');
      lio=url.lastIndexOf('.');
      if (lio < ll)       lio=-1;
    }
    if (lio > 0) {
      rr.setPath(url.substring(0,lio));
      rr.setSuffix(url.substring(lio + 1));
    }
 else {
      rr.setPath(url);
      rr.setSuffix(""String_Node_Str"");
    }
  }
 else {
    rr.setPath(""String_Node_Str"");
    rr.setSuffix(""String_Node_Str"");
  }
  return rr;
}","/** 
 * 获取当前请求的路径，并去掉后缀
 */
public static RequestPath getRequestPathObject(String url){
  RequestPath rr=new RequestPath();
  rr.setUrl(url);
  if (null != url) {
    int lio=url.lastIndexOf('.');
    if (lio > 0) {
      rr.setPath(url.substring(0,lio));
      rr.setSuffix(url.substring(lio + 1));
    }
 else {
      rr.setPath(url);
      rr.setSuffix(""String_Node_Str"");
    }
  }
 else {
    rr.setPath(""String_Node_Str"");
    rr.setSuffix(""String_Node_Str"");
  }
  return rr;
}"
80736,"public void init(FilterConfig conf) throws ServletException {
  config=new FilterNutConfig(conf);
  String skipMode=Strings.sNull(conf.getInitParameter(""String_Node_Str""),""String_Node_Str"").toLowerCase();
  if (!""String_Node_Str"".equals(skipMode)) {
    Loading ing=Inits.init(config,true);
    if (null != ing)     urls=ing.getUrls();
    String regx=Strings.sNull(config.getInitParameter(""String_Node_Str""),IGNORE);
    if (!""String_Node_Str"".equalsIgnoreCase(regx)) {
      ignorePtn=Pattern.compile(regx,Pattern.CASE_INSENSITIVE);
    }
  }
}","public void init(FilterConfig conf) throws ServletException {
  FilterNutConfig config=new FilterNutConfig(conf);
  String skipMode=Strings.sNull(conf.getInitParameter(""String_Node_Str""),""String_Node_Str"").toLowerCase();
  if (!""String_Node_Str"".equals(skipMode)) {
    nutMvc.init(config);
    String regx=Strings.sNull(config.getInitParameter(""String_Node_Str""),IGNORE);
    if (!""String_Node_Str"".equalsIgnoreCase(regx)) {
      ignorePtn=Pattern.compile(regx,Pattern.CASE_INSENSITIVE);
    }
  }
}"
80737,"public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  Mvcs.updateRequestAttributes((HttpServletRequest)req);
  if (null != urls) {
    RequestPath path=Mvcs.getRequestPathObject((HttpServletRequest)req);
    if (null == ignorePtn || !ignorePtn.matcher(path.getUrl()).find()) {
      ActionInvoking ing=urls.get(path.getPath());
      if (null != ing && null != ing.getInvoker()) {
        if (log.isInfoEnabled())         log.info(path);
        ing.invoke(config.getServletContext(),(HttpServletRequest)req,(HttpServletResponse)resp);
        return;
      }
    }
  }
  chain.doFilter(req,resp);
}","public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  Mvcs.updateRequestAttributes((HttpServletRequest)req);
  RequestPath path=Mvcs.getRequestPathObject((HttpServletRequest)req);
  if (null == ignorePtn || !ignorePtn.matcher(path.getUrl()).find()) {
    try {
      if (nutMvc.handle((HttpServletRequest)req,(HttpServletResponse)resp)) {
        return;
      }
    }
 catch (    InitException e) {
    }
  }
  chain.doFilter(req,resp);
}"
80738,"public void destroy(){
  if (null != urls)   Inits.destroy(config);
}","public void destroy(){
  nutMvc.destroy();
}"
80739,"@Override public void init() throws ServletException {
  if (log.isInfoEnabled()) {
    URL me=Thread.currentThread().getContextClassLoader().getResource(NutServlet.class.getName().replace('.','/') + ""String_Node_Str"");
    log.infof(""String_Node_Str"",Nutz.version(),me);
  }
  config=new ServletNutConfig(getServletConfig());
  Loading ing=Inits.init(config,false);
  urls=ing.getUrls();
  ok=true;
}","@Override public void init() throws ServletException {
  nutMvc.init(new ServletNutConfig(getServletConfig()));
  ok=true;
}"
80740,"@Override protected void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (null == urls) {
    if (log.isErrorEnabled())     log.error(""String_Node_Str"");
    return;
  }
  Mvcs.updateRequestAttributes(req);
  String path=Mvcs.getRequestPath(req);
  if (log.isInfoEnabled())   log.info(""String_Node_Str"" + path);
  ActionInvoking ing=urls.get(path);
  if (null == ing || null == ing.getInvoker())   resp.setStatus(404);
 else   ing.invoke(config.getServletContext(),req,resp);
}","@Override protected void service(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  try {
    if (!nutMvc.handle(req,resp)) {
      resp.setStatus(404);
    }
  }
 catch (  InitException e) {
    return;
  }
}"
80741,"public void destroy(){
  if (config.getMainModule() != null)   Inits.destroy(config);
}","public void destroy(){
  nutMvc.destroy();
}"
80742,"private void parseArgs(Element beanElement,IocObject iocObject) throws Throwable {
  NodeList argsNodeList=beanElement.getElementsByTagName(TAG_ARGS);
  if (argsNodeList.getLength() > 0) {
    Element argsElement=(Element)argsNodeList.item(0);
    NodeList argNodeList=argsElement.getChildNodes();
    for (int i=0; i < argNodeList.getLength(); i++) {
      if (argNodeList.item(i) instanceof Element)       iocObject.addArg(parseX((Element)argNodeList.item(i)));
    }
  }
}","protected void parseArgs(Element beanElement,IocObject iocObject) throws Throwable {
  NodeList argsNodeList=beanElement.getElementsByTagName(TAG_ARGS);
  if (argsNodeList.getLength() > 0) {
    Element argsElement=(Element)argsNodeList.item(0);
    NodeList argNodeList=argsElement.getChildNodes();
    for (int i=0; i < argNodeList.getLength(); i++) {
      if (argNodeList.item(i) instanceof Element)       iocObject.addArg(parseX((Element)argNodeList.item(i)));
    }
  }
}"
80743,"private void parseEvents(Element beanElement,IocObject iocObject){
  NodeList eventsNodeList=beanElement.getElementsByTagName(""String_Node_Str"");
  if (eventsNodeList.getLength() > 0) {
    Element eventsElement=(Element)eventsNodeList.item(0);
    IocEventSet iocEventSet=new IocEventSet();
    NodeList fetchNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (fetchNodeList.getLength() > 0)     iocEventSet.setFetch(((Element)fetchNodeList.item(0)).getTextContent());
    NodeList createNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (createNodeList.getLength() > 0)     iocEventSet.setCreate(((Element)createNodeList.item(0)).getTextContent());
    NodeList deposeNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (deposeNodeList.getLength() > 0)     iocEventSet.setDepose(((Element)deposeNodeList.item(0)).getTextContent());
    if (iocEventSet.getCreate() == null)     if (iocEventSet.getDepose() == null)     if (iocEventSet.getFetch() == null)     return;
    iocObject.setEvents(iocEventSet);
  }
}","protected void parseEvents(Element beanElement,IocObject iocObject){
  NodeList eventsNodeList=beanElement.getElementsByTagName(""String_Node_Str"");
  if (eventsNodeList.getLength() > 0) {
    Element eventsElement=(Element)eventsNodeList.item(0);
    IocEventSet iocEventSet=new IocEventSet();
    NodeList fetchNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (fetchNodeList.getLength() > 0)     iocEventSet.setFetch(((Element)fetchNodeList.item(0)).getTextContent());
    NodeList createNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (createNodeList.getLength() > 0)     iocEventSet.setCreate(((Element)createNodeList.item(0)).getTextContent());
    NodeList deposeNodeList=eventsElement.getElementsByTagName(""String_Node_Str"");
    if (deposeNodeList.getLength() > 0)     iocEventSet.setDepose(((Element)deposeNodeList.item(0)).getTextContent());
    if (iocEventSet.getCreate() == null)     if (iocEventSet.getDepose() == null)     if (iocEventSet.getFetch() == null)     return;
    iocObject.setEvents(iocEventSet);
  }
}"
80744,"private boolean check(List<String> parentList,String currentBeanId){
  if (parentList.contains(currentBeanId))   return false;
  String parentBeanId=parentMap.get(currentBeanId);
  if (parentBeanId == null)   return true;
  parentList.add(currentBeanId);
  return check(parentList,parentBeanId);
}","protected boolean check(List<String> parentList,String currentBeanId){
  if (parentList.contains(currentBeanId))   return false;
  String parentBeanId=parentMap.get(currentBeanId);
  if (parentBeanId == null)   return true;
  parentList.add(currentBeanId);
  return check(parentList,parentBeanId);
}"
80745,"public XmlIocLoader(String... fileNames){
  try {
    DocumentBuilder builder=Lang.xmls();
    Document document;
    List<NutResource> list=Scans.me().loadResource(""String_Node_Str"",fileNames);
    for (    NutResource nr : list) {
      InputStream ins=nr.getInputStream();
      document=builder.parse(ins);
      document.normalizeDocument();
      NodeList nodeListZ=((Element)document.getDocumentElement()).getChildNodes();
      for (int i=0; i < nodeListZ.getLength(); i++) {
        if (nodeListZ.item(i) instanceof Element)         paserBean((Element)nodeListZ.item(i),false);
      }
      Streams.safeClose(ins);
    }
    handleParent();
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",Json.toJson(iocMap));
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
}","public XmlIocLoader(String... fileNames){
  try {
    DocumentBuilder builder=Lang.xmls();
    Document document;
    List<NutResource> list=Scans.me().loadResource(getScanPatten(),fileNames);
    for (    NutResource nr : list) {
      InputStream ins=nr.getInputStream();
      document=builder.parse(ins);
      document.normalizeDocument();
      NodeList nodeListZ=((Element)document.getDocumentElement()).getChildNodes();
      for (int i=0; i < nodeListZ.getLength(); i++) {
        if (nodeListZ.item(i) instanceof Element)         paserBean((Element)nodeListZ.item(i),false);
      }
      Streams.safeClose(ins);
    }
    handleParent();
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",Json.toJson(iocMap));
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
}"
80746,"private Map<String,?> paserMap(Element element){
  Map<String,Object> map=new HashMap<String,Object>();
  if (element.hasChildNodes()) {
    NodeList nodeList=element.getElementsByTagName(ITEM_TAG);
    for (int i=0; i < nodeList.getLength(); i++) {
      if (nodeList.item(i) instanceof Element) {
        Element elementItem=(Element)nodeList.item(i);
        String key=elementItem.getAttribute(""String_Node_Str"");
        if (map.containsKey(key))         throw new IllegalArgumentException(""String_Node_Str"");
        NodeList list=elementItem.getChildNodes();
        for (int j=0; j < list.getLength(); j++) {
          if (list.item(j) instanceof Element) {
            map.put(key,list.item(j).getTextContent());
            break;
          }
        }
        if (!map.containsKey(key))         map.put(key,null);
      }
    }
  }
  return map;
}","protected Map<String,?> paserMap(Element element){
  Map<String,Object> map=new HashMap<String,Object>();
  if (element.hasChildNodes()) {
    NodeList nodeList=element.getElementsByTagName(ITEM_TAG);
    for (int i=0; i < nodeList.getLength(); i++) {
      if (nodeList.item(i) instanceof Element) {
        Element elementItem=(Element)nodeList.item(i);
        String key=elementItem.getAttribute(""String_Node_Str"");
        if (map.containsKey(key))         throw new IllegalArgumentException(""String_Node_Str"");
        NodeList list=elementItem.getChildNodes();
        for (int j=0; j < list.getLength(); j++) {
          if (list.item(j) instanceof Element) {
            map.put(key,list.item(j).getTextContent());
            break;
          }
        }
        if (!map.containsKey(key))         map.put(key,null);
      }
    }
  }
  return map;
}"
80747,"private void parseFields(Element beanElement,IocObject iocObject) throws Throwable {
  NodeList fieldNodeList=beanElement.getElementsByTagName(TAG_FIELD);
  if (fieldNodeList.getLength() > 0) {
    int len=fieldNodeList.getLength();
    for (int i=0; i < len; i++) {
      Element fieldElement=(Element)fieldNodeList.item(i);
      IocField iocField=new IocField();
      iocField.setName(fieldElement.getAttribute(""String_Node_Str""));
      if (fieldElement.hasChildNodes()) {
        NodeList nodeList=fieldElement.getChildNodes();
        for (int j=0; j < nodeList.getLength(); j++) {
          if (nodeList.item(j) instanceof Element) {
            iocField.setValue(parseX((Element)nodeList.item(j)));
            break;
          }
        }
      }
      iocObject.addField(iocField);
    }
  }
}","protected void parseFields(Element beanElement,IocObject iocObject) throws Throwable {
  NodeList fieldNodeList=beanElement.getElementsByTagName(TAG_FIELD);
  if (fieldNodeList.getLength() > 0) {
    int len=fieldNodeList.getLength();
    for (int i=0; i < len; i++) {
      Element fieldElement=(Element)fieldNodeList.item(i);
      IocField iocField=new IocField();
      iocField.setName(fieldElement.getAttribute(""String_Node_Str""));
      if (fieldElement.hasChildNodes()) {
        NodeList nodeList=fieldElement.getChildNodes();
        for (int j=0; j < nodeList.getLength(); j++) {
          if (nodeList.item(j) instanceof Element) {
            iocField.setValue(parseX((Element)nodeList.item(j)));
            break;
          }
        }
      }
      iocObject.addField(iocField);
    }
  }
}"
80748,"private IocValue parseX(Element element) throws Throwable {
  IocValue iocValue=new IocValue();
  String type=element.getNodeName();
  if (EVN_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(EVN_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (SYS_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(SYS_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JNDI_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JNDI_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JAVA_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JAVA_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (REFER_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(REFER_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (FILE_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(FILE_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (OBJ_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserBean(element,true));
  }
 else   if (MAP_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserMap(element));
  }
 else   if (LIST_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element));
  }
 else   if (ARRAY_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element).toArray());
  }
 else   if (SET_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    Set<Object> set=new HashSet<Object>();
    set.addAll(paserCollection(element));
    iocValue.setValue(set);
  }
 else {
    iocValue.setType(null);
    iocValue.setValue(element.getFirstChild().getTextContent());
  }
  return iocValue;
}","protected IocValue parseX(Element element) throws Throwable {
  IocValue iocValue=new IocValue();
  String type=element.getNodeName();
  if (EVN_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(EVN_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (SYS_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(SYS_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JNDI_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JNDI_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (JAVA_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(JAVA_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (REFER_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(REFER_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (FILE_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(FILE_TAG);
    iocValue.setValue(element.getTextContent());
  }
 else   if (OBJ_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserBean(element,true));
  }
 else   if (MAP_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserMap(element));
  }
 else   if (LIST_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element));
  }
 else   if (ARRAY_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    iocValue.setValue(paserCollection(element).toArray());
  }
 else   if (SET_TAG.equalsIgnoreCase(type)) {
    iocValue.setType(null);
    Set<Object> set=new HashSet<Object>();
    set.addAll(paserCollection(element));
    iocValue.setValue(set);
  }
 else {
    iocValue.setType(null);
    iocValue.setValue(element.getFirstChild().getTextContent());
  }
  return iocValue;
}"
80749,"private IocObject paserBean(Element beanElement,boolean innerBean) throws Throwable {
  String beanId;
  if (innerBean) {
    beanId=""String_Node_Str"" + innerId;
    innerId++;
  }
 else   beanId=beanElement.getAttribute(""String_Node_Str"");
  if (beanId == null)   throw Lang.makeThrow(""String_Node_Str"");
  if (iocMap.containsKey(beanId))   throw Lang.makeThrow(""String_Node_Str"" + beanId);
  if (LOG.isDebugEnabled())   LOG.debugf(""String_Node_Str"",beanId);
  IocObject iocObject=new IocObject();
  String beanType=beanElement.getAttribute(""String_Node_Str"");
  if (!Strings.isBlank(beanType))   iocObject.setType(Lang.loadClass(beanType));
  String beanScope=beanElement.getAttribute(""String_Node_Str"");
  if (!Strings.isBlank(beanScope))   iocObject.setScope(beanScope);
  String beanParent=beanElement.getAttribute(""String_Node_Str"");
  if (!Strings.isBlank(beanParent))   parentMap.put(beanId,beanParent);
  parseArgs(beanElement,iocObject);
  parseFields(beanElement,iocObject);
  parseEvents(beanElement,iocObject);
  iocMap.put(beanId,iocObject);
  if (LOG.isDebugEnabled())   LOG.debugf(""String_Node_Str"",beanId);
  return iocObject;
}","protected IocObject paserBean(Element beanElement,boolean innerBean) throws Throwable {
  String beanId;
  if (innerBean) {
    beanId=""String_Node_Str"" + innerId;
    innerId++;
  }
 else   beanId=beanElement.getAttribute(""String_Node_Str"");
  if (beanId == null)   throw Lang.makeThrow(""String_Node_Str"");
  if (iocMap.containsKey(beanId))   throw Lang.makeThrow(""String_Node_Str"" + beanId);
  if (LOG.isDebugEnabled())   LOG.debugf(""String_Node_Str"",beanId);
  IocObject iocObject=new IocObject();
  String beanType=beanElement.getAttribute(""String_Node_Str"");
  if (!Strings.isBlank(beanType))   iocObject.setType(Lang.loadClass(beanType));
  String beanScope=beanElement.getAttribute(""String_Node_Str"");
  if (!Strings.isBlank(beanScope))   iocObject.setScope(beanScope);
  String beanParent=beanElement.getAttribute(""String_Node_Str"");
  if (!Strings.isBlank(beanParent))   parentMap.put(beanId,beanParent);
  parseArgs(beanElement,iocObject);
  parseFields(beanElement,iocObject);
  parseEvents(beanElement,iocObject);
  iocMap.put(beanId,iocObject);
  if (LOG.isDebugEnabled())   LOG.debugf(""String_Node_Str"",beanId);
  return iocObject;
}"
80750,"private void handleParent(){
  for (  String parentId : parentMap.values())   if (!iocMap.containsKey(parentId))   throw Lang.makeThrow(""String_Node_Str"",parentId);
  List<String> parentList=new ArrayList<String>();
  for (  Entry<String,String> entry : parentMap.entrySet()) {
    if (!check(parentList,entry.getKey()))     throw Lang.makeThrow(""String_Node_Str"",entry.getKey());
    parentList.clear();
  }
  while (parentMap.size() != 0) {
    Iterator<Entry<String,String>> it=parentMap.entrySet().iterator();
    while (it.hasNext()) {
      Entry<String,String> entry=it.next();
      String beanId=entry.getKey();
      String parentId=entry.getValue();
      if (parentMap.get(parentId) == null) {
        IocObject newIocObject=Iocs.mergeWith(iocMap.get(beanId),iocMap.get(parentId));
        iocMap.put(beanId,newIocObject);
        it.remove();
      }
    }
  }
}","protected void handleParent(){
  for (  String parentId : parentMap.values())   if (!iocMap.containsKey(parentId))   throw Lang.makeThrow(""String_Node_Str"",parentId);
  List<String> parentList=new ArrayList<String>();
  for (  Entry<String,String> entry : parentMap.entrySet()) {
    if (!check(parentList,entry.getKey()))     throw Lang.makeThrow(""String_Node_Str"",entry.getKey());
    parentList.clear();
  }
  while (parentMap.size() != 0) {
    Iterator<Entry<String,String>> it=parentMap.entrySet().iterator();
    while (it.hasNext()) {
      Entry<String,String> entry=it.next();
      String beanId=entry.getKey();
      String parentId=entry.getValue();
      if (parentMap.get(parentId) == null) {
        IocObject newIocObject=Iocs.mergeWith(iocMap.get(beanId),iocMap.get(parentId));
        iocMap.put(beanId,newIocObject);
        it.remove();
      }
    }
  }
}"
80751,"private List<IocValue> paserCollection(Element element) throws Throwable {
  List<IocValue> list=new ArrayList<IocValue>();
  if (element.hasChildNodes()) {
    NodeList nodeList=element.getChildNodes();
    for (int i=0; i < nodeList.getLength(); i++) {
      Node node=nodeList.item(i);
      if (node instanceof Element) {
        list.add((IocValue)parseX((Element)node));
      }
    }
  }
  return list;
}","protected List<IocValue> paserCollection(Element element) throws Throwable {
  List<IocValue> list=new ArrayList<IocValue>();
  if (element.hasChildNodes()) {
    NodeList nodeList=element.getChildNodes();
    for (int i=0; i < nodeList.getLength(); i++) {
      Node node=nodeList.item(i);
      if (node instanceof Element) {
        list.add((IocValue)parseX((Element)node));
      }
    }
  }
  return list;
}"
80752,"private void pojo2Json(Object obj) throws IOException {
  if (null == obj)   return;
  Class<? extends Object> type=obj.getClass();
  ToJson tj=type.getAnnotation(ToJson.class);
  String myMethodName=Strings.sNull(null == tj ? null : tj.value(),""String_Node_Str"");
  Method myMethod;
  try {
    myMethod=type.getMethod(myMethodName);
    Object re=myMethod.invoke(obj);
    writer.append(String.valueOf(re));
    return;
  }
 catch (  Exception e1) {
    try {
      myMethod=type.getMethod(myMethodName,JsonFormat.class);
      Object re=myMethod.invoke(obj,format);
      writer.append(String.valueOf(re));
      return;
    }
 catch (    Exception e) {
    }
  }
  Mirror<?> me=Mirror.me(type);
  Field[] fields=me.getFields();
  appendBraceBegin();
  increaseFormatIndent();
  ArrayList<Pair> list=new ArrayList<Pair>(fields.length);
  for (  Field f : fields) {
    String name=f.getName();
    try {
      Object value=me.getValue(obj,name);
      if (!this.isIgnore(name,value))       list.add(new Pair(name,value));
    }
 catch (    FailToGetValueException e) {
    }
  }
  for (Iterator<Pair> it=list.iterator(); it.hasNext(); ) {
    Pair p=it.next();
    this.appendPair(p.name,p.value);
    if (it.hasNext())     this.appendPairEnd();
  }
  decreaseFormatIndent();
  appendBraceEnd();
}","private void pojo2Json(Object obj) throws IOException {
  if (null == obj)   return;
  Class<? extends Object> type=obj.getClass();
  ToJson tj=type.getAnnotation(ToJson.class);
  String myMethodName=Strings.sNull(null == tj ? null : tj.value(),""String_Node_Str"");
  try {
    Method myMethod=type.getMethod(myMethodName);
    if (!myMethod.isAccessible())     myMethod.setAccessible(true);
    Object re=myMethod.invoke(obj);
    writer.append(String.valueOf(re));
    return;
  }
 catch (  Exception e1) {
    try {
      Method myMethod=type.getMethod(myMethodName,JsonFormat.class);
      if (!myMethod.isAccessible())       myMethod.setAccessible(true);
      Object re=myMethod.invoke(obj,format);
      writer.append(String.valueOf(re));
      return;
    }
 catch (    Exception e) {
    }
  }
  Mirror<?> me=Mirror.me(type);
  Field[] fields=me.getFields();
  appendBraceBegin();
  increaseFormatIndent();
  ArrayList<Pair> list=new ArrayList<Pair>(fields.length);
  for (  Field f : fields) {
    String name=f.getName();
    try {
      Object value=me.getValue(obj,name);
      if (!this.isIgnore(name,value))       list.add(new Pair(name,value));
    }
 catch (    FailToGetValueException e) {
    }
  }
  for (Iterator<Pair> it=list.iterator(); it.hasNext(); ) {
    Pair p=it.next();
    this.appendPair(p.name,p.value);
    if (it.hasNext())     this.appendPairEnd();
  }
  decreaseFormatIndent();
  appendBraceEnd();
}"
80753,"/** 
 * @param path 全路径
 * @return 文件或者目录名
 */
public static String getName(String path){
  if (!Strings.isBlank(path)) {
    int pos=path.replace('\\','/').lastIndexOf('/');
    if (pos > 0)     return path.substring(pos);
  }
  return path;
}","/** 
 * @param path 全路径
 * @return 文件或者目录名
 */
public static String getName(String path){
  if (!Strings.isBlank(path)) {
    int pos=path.replace('\\','/').lastIndexOf('/');
    if (pos > 0)     return path.substring(pos + 1);
  }
  return path;
}"
80754,"public static StringGenerator sg(int min,int max){
  return new StringGenerator(min,max);
}","public static StringGenerator sg(int len){
  return new StringGenerator(len,len);
}"
80755,"public E next(){
  return stack.innerGet(i++);
}","public E next(){
  if (i >= stack.offset && i < stack.cursor)   return stack.innerGet(i++);
  return null;
}"
80756,"LinkedArrayIterator(LinkedArray<E> stack){
  this.stack=stack;
  i=0;
}","LinkedArrayIterator(LinkedArray<E> stack){
  this.stack=stack;
  i=stack.offset;
}"
80757,"public boolean hasNext(){
  return (stack.cursor - i + stack.offset) > 0;
}","public boolean hasNext(){
  return i < stack.cursor;
}"
80758,"public LinkedArray(Class<T> eleType,int size){
  this.eleType=eleType;
  if (size < 0)   Lang.makeThrow(""String_Node_Str"");
  this.width=size;
  cache=new ArrayList<T[]>();
}","public LinkedArray(Class<T> eleType,int size){
  this.eleType=eleType;
  if (size <= 0)   Lang.makeThrow(""String_Node_Str"");
  this.width=size;
  cache=new ArrayList<T[]>();
}"
80759,"public LinkedIntArray(int size){
  if (size < 0)   Lang.makeThrow(""String_Node_Str"");
  this.width=size;
  cache=new ArrayList<int[]>();
}","public LinkedIntArray(int size){
  if (size <= 0)   Lang.makeThrow(""String_Node_Str"");
  this.width=size;
  cache=new ArrayList<int[]>();
}"
80760,"protected Object getValue(IocMaking ing,Object obj) throws Exception {
  if (null == args || args.length == 0) {
    return method.invoke(obj);
  }
  Object[] fas=new Object[args.length];
  for (int i=0; i < args.length; i++)   fas[i]=args[i].getValue(ing,null);
  return method.invoke(obj,fas);
}","protected Object getValue(IocMaking ing,Object obj) throws Exception {
  if (method != null) {
    if (null == args || args.length == 0)     return method.invoke(obj);
    Object[] fas=new Object[args.length];
    for (int i=0; i < args.length; i++)     fas[i]=args[i].getValue(ing,null);
    return method.invoke(obj,fas);
  }
  return field.get(null);
}"
80761,"public StaticFunctionNode(String className,String name,ChainNode[] args){
  try {
    Mirror<?> mirror=Mirror.me((Class<?>)Lang.loadClass(className));
    if (null == args || args.length == 0) {
      try {
        method=mirror.getGetter(name);
      }
 catch (      NoSuchMethodException e) {
        throw Lang.makeThrow(""String_Node_Str"",name,mirror);
      }
    }
 else {
      Method[] ms=mirror.findMethods(name,args.length);
      if (0 == ms.length)       throw Lang.makeThrow(""String_Node_Str"",name,mirror);
      this.args=args;
      this.method=ms[0];
    }
    if (!Modifier.isStatic(method.getModifiers()))     throw Lang.makeThrow(""String_Node_Str"",name,mirror);
  }
 catch (  ClassNotFoundException e) {
    throw Lang.wrapThrow(e);
  }
}","public StaticFunctionNode(String className,String name,ChainNode[] args){
  try {
    Mirror<?> mirror=Mirror.me(Lang.loadClass(className));
    if (null == args || args.length == 0) {
      try {
        method=mirror.getGetter(name);
      }
 catch (      NoSuchMethodException e) {
        try {
          field=mirror.getField(name);
          if (!Modifier.isStatic(field.getModifiers()))           throw Lang.makeThrow(""String_Node_Str"",name,mirror);
          return;
        }
 catch (        NoSuchFieldException e1) {
          throw Lang.makeThrow(""String_Node_Str"",name,mirror);
        }
      }
    }
 else {
      Method[] ms=mirror.findMethods(name,args.length);
      if (0 == ms.length)       throw Lang.makeThrow(""String_Node_Str"",name,mirror);
      this.args=args;
      this.method=ms[0];
    }
    if (!Modifier.isStatic(method.getModifiers()))     throw Lang.makeThrow(""String_Node_Str"",name,mirror);
  }
 catch (  ClassNotFoundException e) {
    throw Lang.wrapThrow(e);
  }
}"
80762,"protected String asString(){
  StringBuilder sb=new StringBuilder();
  if (null != args && args.length > 0) {
    sb.append(args[0].toString());
    for (int i=1; i < args.length; i++)     sb.append(""String_Node_Str"").append(args[i].toString());
  }
  return String.format(""String_Node_Str"",method.getDeclaringClass().getName(),method.getName(),sb);
}","protected String asString(){
  StringBuilder sb=new StringBuilder();
  if (null != args && args.length > 0) {
    sb.append(args[0].toString());
    for (int i=1; i < args.length; i++)     sb.append(""String_Node_Str"").append(args[i].toString());
  }
  if (method != null)   return String.format(""String_Node_Str"",method.getDeclaringClass().getName(),method.getName(),sb);
 else   return String.format(""String_Node_Str"",field.getDeclaringClass().getName(),field.getName(),sb);
}"
80763,"/** 
 * 执行过滤
 * @param request 当前的请求对象
 * @param method 即将调用的入口函数
 * @return <ul><li>null - 过滤去通过，可以继续执行后续操作 <li>View 对象实例 - 过滤器认为应该终止操作，用这个视图对象来直接渲染 HTTP响应 </ul>
 */
View match(HttpServletRequest request,Method method);","/** 
 * 执行过滤
 * @param sc Servlet 上下文对象
 * @param request 当前的请求对象
 * @param method 即将调用的入口函数
 * @return <ul><li>null - 过滤去通过，可以继续执行后续操作 <li>View 对象实例 - 过滤器认为应该终止操作，用这个视图对象来直接渲染 HTTP响应 </ul>
 */
View match(ServletContext sc,HttpServletRequest request,Method method);"
80764,"public View match(HttpServletRequest request,Method method){
  Object obj=request.getSession().getAttribute(name);
  if (null == obj)   return new ServerRedirectView(path);
  return null;
}","public View match(ServletContext sc,HttpServletRequest request,Method method){
  Object obj=request.getSession().getAttribute(name);
  if (null == obj)   return new ServerRedirectView(path);
  return null;
}"
80765,"public void invoke(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  try {
    req.setCharacterEncoding(inputCharset);
  }
 catch (  UnsupportedEncodingException e) {
    if (log.isWarnEnabled())     log.warn(getExceptionMessage(e),e);
    throw Lang.wrapThrow(e);
  }
  resp.setCharacterEncoding(outputCharset);
  if (null != filters)   for (  ActionFilter filter : filters) {
    View view=filter.match(req,method);
    if (null != view) {
      try {
        view.render(req,resp,null);
      }
 catch (      Throwable e) {
        if (log.isWarnEnabled())         log.warn(getExceptionMessage(e),e);
        throw Lang.wrapThrow(e);
      }
      return;
    }
  }
  RequestIocContext reqContext=null;
  try {
    Object[] args=adaptor.adapt(sc,req,resp,pathArgs);
    Object obj;
    if (null != module) {
      obj=module;
    }
 else {
      Ioc ioc=Mvcs.getIoc(sc);
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",moduleName);
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(req);
        SessionIocContext sessionContext=new SessionIocContext(req.getSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        obj=((Ioc2)ioc).get(moduleType,moduleName,myContext);
      }
 else       obj=ioc.get(moduleType,moduleName);
    }
    Object re=method.invoke(obj,args);
    if (re instanceof View)     ((View)re).render(req,resp,null);
 else     ok.render(req,resp,re);
  }
 catch (  Throwable e) {
    if (e instanceof InvocationTargetException && e.getCause() != null)     e=e.getCause();
    if (log.isDebugEnabled())     log.debug(getExceptionMessage(e),e);
    try {
      fail.render(req,resp,e);
    }
 catch (    Throwable e1) {
      if (log.isWarnEnabled())       log.warn(getExceptionMessage(e1),e1);
      resp.reset();
      try {
        resp.getWriter().write(e1.getMessage());
        resp.flushBuffer();
      }
 catch (      IOException e2) {
        if (log.isWarnEnabled())         log.warn(getExceptionMessage(e2),e2);
        throw Lang.wrapThrow(e2);
      }
    }
  }
 finally {
    if (null != reqContext)     reqContext.depose();
  }
}","public void invoke(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  try {
    req.setCharacterEncoding(inputCharset);
  }
 catch (  UnsupportedEncodingException e) {
    if (log.isWarnEnabled())     log.warn(getExceptionMessage(e),e);
    throw Lang.wrapThrow(e);
  }
  resp.setCharacterEncoding(outputCharset);
  if (null != filters)   for (  ActionFilter filter : filters) {
    View view=filter.match(sc,req,method);
    if (null != view) {
      try {
        view.render(req,resp,null);
      }
 catch (      Throwable e) {
        if (log.isWarnEnabled())         log.warn(getExceptionMessage(e),e);
        throw Lang.wrapThrow(e);
      }
      return;
    }
  }
  RequestIocContext reqContext=null;
  try {
    Object[] args=adaptor.adapt(sc,req,resp,pathArgs);
    Object obj;
    if (null != module) {
      obj=module;
    }
 else {
      Ioc ioc=Mvcs.getIoc(sc);
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",moduleName);
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(req);
        SessionIocContext sessionContext=new SessionIocContext(req.getSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        obj=((Ioc2)ioc).get(moduleType,moduleName,myContext);
      }
 else       obj=ioc.get(moduleType,moduleName);
    }
    Object re=method.invoke(obj,args);
    if (re instanceof View)     ((View)re).render(req,resp,null);
 else     ok.render(req,resp,re);
  }
 catch (  Throwable e) {
    if (e instanceof InvocationTargetException && e.getCause() != null)     e=e.getCause();
    if (log.isDebugEnabled())     log.debug(getExceptionMessage(e),e);
    try {
      fail.render(req,resp,e);
    }
 catch (    Throwable e1) {
      if (log.isWarnEnabled())       log.warn(getExceptionMessage(e1),e1);
      resp.reset();
      try {
        resp.getWriter().write(e1.getMessage());
        resp.flushBuffer();
      }
 catch (      IOException e2) {
        if (log.isWarnEnabled())         log.warn(getExceptionMessage(e2),e2);
        throw Lang.wrapThrow(e2);
      }
    }
  }
 finally {
    if (null != reqContext)     reqContext.depose();
  }
}"
80766,"/** 
 * 初始化NutLog,检查全部Log的可用性,选择可用的Log适配器 <p/><b>加载本类时,该方法已经在静态构造函数中调用,用户无需主动调用.</b> <p/><b>除非迫不得已,请不要调用本方法<b/>
 */
public static void init(){
  try {
    adapter=new SimplePluginManager<LogAdapter>(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").get();
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}","/** 
 * 初始化NutLog,检查全部Log的可用性,选择可用的Log适配器 <p/> <b>加载本类时,该方法已经在静态构造函数中调用,用户无需主动调用.</b> <p/> <b>除非迫不得已,请不要调用本方法<b/>
 */
public static void init(){
  try {
    adapter=new SimplePluginManager<LogAdapter>(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").get();
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}"
80767,"/** 
 * Get a Log by name
 * @param className the name of Log
 * @return Log 
 * @throws NullPointerException when className is null, maybe it will case NPE
 */
public static Log getLog(String className){
  return adapter.getLogger(className);
}","/** 
 * Get a Log by name
 * @param className the name of Log
 * @return Log
 * @throws NullPointerException when className is null, maybe it will case NPE
 */
public static Log getLog(String className){
  return adapter.getLogger(className);
}"
80768,"public boolean canWork(){
  try {
    Class.forName(LOG4J_CLASS_NAME,true,Thread.currentThread().getContextClassLoader());
  }
 catch (  ClassNotFoundException e) {
    return false;
  }
  return isPropertyFileConfigured();
}","public boolean canWork(){
  try {
    Class.forName(""String_Node_Str"",false,Thread.currentThread().getContextClassLoader());
    return isPropertyFileConfigured();
  }
 catch (  Throwable e) {
  }
  return false;
}"
80769,"public SimplePluginManager(Class<? extends T>... classNames) throws PluginException {
  for (  Class<? extends T> pluginClass : classNames)   loadPlugin(pluginClass);
}","public SimplePluginManager(Class<? extends T>... classNames) throws PluginException {
  if (classNames != null)   for (  Class<? extends T> pluginClass : classNames)   loadPlugin(pluginClass);
}"
80770,"@SuppressWarnings(""String_Node_Str"") private void loadPlugin(String pluginClassName) throws PluginException {
  try {
    if (pluginClassName != null)     loadPlugin((Class<? extends T>)Lang.loadClass(pluginClassName));
  }
 catch (  ClassNotFoundException e) {
  }
}","@SuppressWarnings(""String_Node_Str"") private void loadPlugin(String pluginClassName) throws PluginException {
  try {
    if (pluginClassName != null)     loadPlugin((Class<? extends T>)Lang.loadClass(pluginClassName));
  }
 catch (  Throwable e) {
  }
}"
80771,"public boolean isFile(){
  return null != getContentType() && null != getFileLocalPath();
}","public boolean isFile(){
  return null != getFileLocalPath();
}"
80772,"@SuppressWarnings(""String_Node_Str"") public Node<T> add(Node<?>... nodes){
  if (nodes.length == 0) {
    return this;
  }
  if (nodes.length == 1) {
    Node<T> node=(Node<T>)nodes[0];
    node.parent(this);
    if (!this.hasChild()) {
      firstChild=node;
      lastChild=node;
      node.next(null);
      node.prev(null);
    }
 else {
      lastChild.next(node);
      node.prev(lastChild);
      node.next(null);
      lastChild=node;
    }
  }
 else {
    firstChild=(Node<T>)nodes[0];
    firstChild.parent(this);
    firstChild.next((Node<T>)nodes[1]);
    int i=1;
    for (; i < nodes.length - 1; i++) {
      Node<T> node=(Node<T>)nodes[i];
      node.parent(this);
      node.prev((Node<T>)nodes[i - 1]);
      node.next((Node<T>)nodes[i + 1]);
    }
    lastChild=(Node<T>)nodes[i];
    lastChild.parent(this);
    lastChild.prev((Node<T>)nodes[i - 1]);
  }
  return this;
}","@SuppressWarnings(""String_Node_Str"") public Node<T> add(Node<?>... nodes){
  if (nodes.length == 0) {
    return this;
  }
  if (nodes.length == 1) {
    Node<T> node=(Node<T>)nodes[0];
    node.parent(this);
    if (!this.hasChild()) {
      firstChild=node;
      lastChild=node;
      node.next(null);
      node.prev(null);
    }
 else {
      lastChild.next(node);
      node.prev(lastChild);
      node.next(null);
      lastChild=node;
    }
  }
 else {
    Node<T> theNode=(Node<T>)nodes[0];
    theNode.parent(this);
    theNode.next((Node<T>)nodes[1]);
    if (null == lastChild) {
      firstChild=theNode;
    }
 else {
      lastChild.next(theNode);
    }
    int i=1;
    for (; i < nodes.length - 1; i++) {
      Node<T> node=(Node<T>)nodes[i];
      node.parent(this);
      node.prev((Node<T>)nodes[i - 1]);
      node.next((Node<T>)nodes[i + 1]);
    }
    lastChild=(Node<T>)nodes[i];
    lastChild.parent(this);
    lastChild.prev((Node<T>)nodes[i - 1]);
  }
  return this;
}"
80773,"protected void enhandMethod_Void(){
  mv.visitCode();
  Label l0=new Label();
  Label l1=new Label();
  Label l2=new Label();
  mv.visitTryCatchBlock(l0,l1,l2,""String_Node_Str"");
  mv.visitLabel(l0);
  mv.visitTypeInsn(NEW,""String_Node_Str"");
  mv.visitInsn(DUP);
  visitX(methodIndex);
  mv.visitVarInsn(ALOAD,0);
  mv.visitFieldInsn(GETSTATIC,myName,""String_Node_Str"",""String_Node_Str"");
  visitX(methodIndex);
  mv.visitInsn(AALOAD);
  mv.visitFieldInsn(GETSTATIC,myName,""String_Node_Str"",""String_Node_Str"");
  visitX(methodIndex);
  mv.visitInsn(AALOAD);
  loadArgsAsArray();
  mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
{
    if (Type.getReturnType(desc).equals(Type.VOID_TYPE)) {
      mv.visitInsn(POP);
    }
 else {
      mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      AsmHelper.checkCast(returnType,mv);
      returnIt();
    }
  }
  mv.visitLabel(l1);
  Label l3=new Label();
  mv.visitJumpInsn(GOTO,l3);
  mv.visitLabel(l2);
  mv.visitVarInsn(ASTORE,3);
  mv.visitVarInsn(ALOAD,3);
  mv.visitInsn(ATHROW);
  mv.visitLabel(l3);
  mv.visitInsn(RETURN);
  mv.visitMaxs(8,4);
  mv.visitEnd();
}","protected void enhandMethod_Void(){
  mv.visitCode();
  Label l0=new Label();
  Label l1=new Label();
  Label l2=new Label();
  mv.visitTryCatchBlock(l0,l1,l2,""String_Node_Str"");
  mv.visitLabel(l0);
  mv.visitTypeInsn(NEW,""String_Node_Str"");
  mv.visitInsn(DUP);
  visitX(methodIndex);
  mv.visitVarInsn(ALOAD,0);
  mv.visitFieldInsn(GETSTATIC,myName,AsmClassAgent.MethodArray_FieldName,""String_Node_Str"");
  visitX(methodIndex);
  mv.visitInsn(AALOAD);
  mv.visitFieldInsn(GETSTATIC,myName,AsmClassAgent.MethodInterceptorList_FieldName,""String_Node_Str"");
  visitX(methodIndex);
  mv.visitInsn(AALOAD);
  loadArgsAsArray();
  mv.visitMethodInsn(INVOKESPECIAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
{
    if (Type.getReturnType(desc).equals(Type.VOID_TYPE)) {
      mv.visitInsn(POP);
    }
 else {
      mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      AsmHelper.checkCast(returnType,mv);
      returnIt();
    }
  }
  mv.visitLabel(l1);
  Label l3=new Label();
  mv.visitJumpInsn(GOTO,l3);
  mv.visitLabel(l2);
  mv.visitVarInsn(ASTORE,3);
  mv.visitVarInsn(ALOAD,3);
  mv.visitInsn(ATHROW);
  mv.visitLabel(l3);
  mv.visitInsn(RETURN);
  mv.visitMaxs(8,4);
  mv.visitEnd();
}"
80774,"@SuppressWarnings(""String_Node_Str"") protected <T>Class<T> generate(ClassDefiner cd,Pair2[] pair2s,String newName,Class<T> klass,Constructor<T>[] constructors){
  try {
    return (Class<T>)cd.load(newName);
  }
 catch (  ClassNotFoundException e) {
  }
  Method[] methodArray=new Method[pair2s.length];
  List<MethodInterceptor>[] methodInterceptorList=new List[pair2s.length];
  for (int i=0; i < pair2s.length; i++) {
    Pair2 pair2=pair2s[i];
    methodArray[i]=pair2.method;
    methodInterceptorList[i]=pair2.listeners;
  }
  byte[] bytes=ClassY.enhandClass(klass,newName,methodArray,constructors);
  if (debug)   Files.write(new File(newName),bytes);
  Class<T> newClass=(Class<T>)cd.define(newName,bytes);
  AopToolKit.injectFieldValue(newClass,methodArray,methodInterceptorList);
  return newClass;
}","@SuppressWarnings(""String_Node_Str"") protected <T>Class<T> generate(ClassDefiner cd,Pair2[] pair2s,String newName,Class<T> klass,Constructor<T>[] constructors){
  try {
    return (Class<T>)cd.load(newName);
  }
 catch (  ClassNotFoundException e) {
  }
  Method[] methodArray=new Method[pair2s.length];
  List<MethodInterceptor>[] methodInterceptorList=new List[pair2s.length];
  for (int i=0; i < pair2s.length; i++) {
    Pair2 pair2=pair2s[i];
    methodArray[i]=pair2.method;
    methodInterceptorList[i]=pair2.listeners;
  }
  byte[] bytes=ClassY.enhandClass(klass,newName,methodArray,constructors);
  if (debug)   Files.write(new File(newName),bytes);
  Class<T> newClass=(Class<T>)cd.define(newName,bytes);
  try {
    Mirror<T> mirror=Mirror.me(newClass);
    mirror.setValue(null,MethodArray_FieldName,methodArray);
    mirror.setValue(null,MethodInterceptorList_FieldName,methodInterceptorList);
  }
 catch (  Throwable e) {
  }
  return newClass;
}"
80775,"private void addField(){
  AopToolKit.addFields(cw);
}","private void addField(){
  cw.visitField(ACC_PRIVATE + ACC_STATIC,AsmClassAgent.MethodArray_FieldName,""String_Node_Str"",null,null).visitEnd();
  cw.visitField(ACC_PRIVATE + ACC_STATIC,AsmClassAgent.MethodInterceptorList_FieldName,""String_Node_Str"",""String_Node_Str"",null).visitEnd();
}"
80776,"public static boolean isJDK6(){
  InputStream is=null;
  try {
    String classFileName=Lang.class.getName().replace('.','/') + ""String_Node_Str"";
    is=Lang.class.getResourceAsStream(classFileName);
    if (is == null)     is=Lang.class.getResourceAsStream(""String_Node_Str"" + classFileName);
    if (is != null && is.available() > 8) {
      is.skip(7);
switch (is.read()) {
case 50:
        return true;
    }
  }
}
 catch (Throwable e) {
}
 finally {
  Streams.safeClose(is);
}
return false;
}","public static boolean isJDK6(){
  InputStream is=null;
  try {
    String classFileName=Lang.class.getName().replace('.','/') + ""String_Node_Str"";
    is=Lang.class.getResourceAsStream(classFileName);
    if (is == null)     is=Lang.class.getResourceAsStream(""String_Node_Str"" + classFileName);
    if (is != null && is.available() > 8) {
      is.skip(7);
      return is.read() > 49;
    }
  }
 catch (  Throwable e) {
  }
 finally {
    Streams.safeClose(is);
  }
  return false;
}"
80777,"public String getRealPath(String path){
  if (path.startsWith(""String_Node_Str""))   return new File(""String_Node_Str"" + path).getAbsolutePath();
  if (path.startsWith(""String_Node_Str""))   path=path.substring(""String_Node_Str"".length());
  if (path.startsWith(""String_Node_Str""))   path=path.substring(""String_Node_Str"".length());
  return new File(path).getAbsolutePath();
}","public String getRealPath(String path){
  if (path.startsWith(""String_Node_Str""))   return new File(path.substring(""String_Node_Str"".length())).getAbsolutePath();
  if (path.startsWith(""String_Node_Str""))   return new File(path.substring(""String_Node_Str"".length())).getAbsolutePath();
  if (path.startsWith(""String_Node_Str""))   return new File(""String_Node_Str"" + path).getAbsolutePath();
  return new File(path).getAbsolutePath();
}"
80778,"protected IocValue convert(String value){
  IocValue iocValue=new IocValue();
  iocValue.setType(value.substring(0,value.indexOf(""String_Node_Str"")));
  iocValue.setValue(value.substring(value.indexOf(""String_Node_Str"") + 1));
  return iocValue;
}","protected IocValue convert(String value){
  IocValue iocValue=new IocValue();
  if (value.indexOf(':') > -1) {
    iocValue.setType(value.substring(0,value.indexOf(""String_Node_Str"")));
    iocValue.setValue(value.substring(value.indexOf(""String_Node_Str"") + 1));
  }
 else   iocValue.setValue(value);
  return iocValue;
}"
80779,"private void addClass(Class<?> classZ){
  if (classZ.isInterface() || classZ.isMemberClass() || classZ.isEnum()|| classZ.isAnnotation()|| classZ.isAnonymousClass())   return;
  int modify=classZ.getModifiers();
  if (Modifier.isAbstract(modify) || (!Modifier.isPublic(modify)))   return;
  IocBean iocBean=classZ.getAnnotation(IocBean.class);
  if (iocBean != null) {
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ);
    String beanName=iocBean.name();
    if (Strings.isBlank(beanName))     beanName=Strings.lowerFirst(classZ.getSimpleName());
    IocObject iocObject=new IocObject();
    iocObject.setType(classZ);
    map.put(beanName,iocObject);
    iocObject.setSingleton(iocBean.singleton());
    if (!Strings.isBlank(iocBean.scope()))     iocObject.setScope(iocBean.scope());
    if (iocBean.param().length > 0)     for (    String value : iocBean.param())     iocObject.addArg(convert(value));
    IocEventSet eventSet=new IocEventSet();
    iocObject.setEvents(eventSet);
    if (!Strings.isBlank(iocBean.create()))     eventSet.setCreate(iocBean.create().trim().intern());
    if (!Strings.isBlank(iocBean.depose()))     eventSet.setCreate(iocBean.depose().trim().intern());
    if (!Strings.isBlank(iocBean.fetch()))     eventSet.setCreate(iocBean.fetch().trim().intern());
    List<String> fieldList=new ArrayList<String>();
    Field[] fields=classZ.getDeclaredFields();
    for (    Field field : fields) {
      Inject inject=field.getAnnotation(Inject.class);
      if (inject == null)       continue;
      IocField iocField=new IocField();
      iocField.setName(field.getName());
      IocValue iocValue;
      if (Strings.isBlank(inject.value())) {
        iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(field.getName());
      }
 else       iocValue=convert(inject.value());
      iocField.setValue(iocValue);
      iocObject.addField(iocField);
      fieldList.add(iocField.getName());
    }
    Method[] methods=classZ.getMethods();
    for (    Method method : methods) {
      Inject inject=method.getAnnotation(Inject.class);
      if (inject == null)       continue;
      if (method.getName().startsWith(""String_Node_Str"") && method.getName().length() > 3 && method.getParameterTypes().length == 1) {
        IocField iocField=new IocField();
        iocField.setName(Strings.lowerFirst(method.getName().substring(3)));
        IocValue iocValue;
        if (Strings.isBlank(inject.value())) {
          iocValue=new IocValue();
          iocValue.setType(IocValue.TYPE_REFER);
          iocValue.setValue(Strings.lowerFirst(method.getName().substring(3)));
        }
 else         iocValue=convert(inject.value());
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    if (iocBean.field() != null && iocBean.field().length > 0) {
      for (      String fieldInfo : iocBean.field()) {
        if (fieldList.contains(fieldInfo))         throw Lang.makeThrow(""String_Node_Str"",classZ,fieldInfo);
        IocField iocField=new IocField();
        iocField.setName(fieldInfo);
        IocValue iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(fieldInfo);
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ,beanName);
  }
}","private void addClass(Class<?> classZ){
  if (classZ.isInterface() || classZ.isMemberClass() || classZ.isEnum()|| classZ.isAnnotation()|| classZ.isAnonymousClass())   return;
  int modify=classZ.getModifiers();
  if (Modifier.isAbstract(modify) || (!Modifier.isPublic(modify)))   return;
  IocBean iocBean=classZ.getAnnotation(IocBean.class);
  if (iocBean != null) {
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ);
    String beanName=iocBean.name();
    if (Strings.isBlank(beanName))     beanName=Strings.lowerFirst(classZ.getSimpleName());
    IocObject iocObject=new IocObject();
    iocObject.setType(classZ);
    map.put(beanName,iocObject);
    iocObject.setSingleton(iocBean.singleton());
    if (!Strings.isBlank(iocBean.scope()))     iocObject.setScope(iocBean.scope());
    if (iocBean.param().length > 0)     for (    String value : iocBean.param())     iocObject.addArg(convert(value));
    IocEventSet eventSet=new IocEventSet();
    iocObject.setEvents(eventSet);
    if (!Strings.isBlank(iocBean.create()))     eventSet.setCreate(iocBean.create().trim().intern());
    if (!Strings.isBlank(iocBean.depose()))     eventSet.setDepose(iocBean.depose().trim().intern());
    if (!Strings.isBlank(iocBean.fetch()))     eventSet.setFetch(iocBean.fetch().trim().intern());
    List<String> fieldList=new ArrayList<String>();
    Field[] fields=classZ.getDeclaredFields();
    for (    Field field : fields) {
      Inject inject=field.getAnnotation(Inject.class);
      if (inject == null)       continue;
      IocField iocField=new IocField();
      iocField.setName(field.getName());
      IocValue iocValue;
      if (Strings.isBlank(inject.value())) {
        iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(field.getName());
      }
 else       iocValue=convert(inject.value());
      iocField.setValue(iocValue);
      iocObject.addField(iocField);
      fieldList.add(iocField.getName());
    }
    Method[] methods=classZ.getMethods();
    for (    Method method : methods) {
      Inject inject=method.getAnnotation(Inject.class);
      if (inject == null)       continue;
      if (method.getName().startsWith(""String_Node_Str"") && method.getName().length() > 3 && method.getParameterTypes().length == 1) {
        IocField iocField=new IocField();
        iocField.setName(Strings.lowerFirst(method.getName().substring(3)));
        IocValue iocValue;
        if (Strings.isBlank(inject.value())) {
          iocValue=new IocValue();
          iocValue.setType(IocValue.TYPE_REFER);
          iocValue.setValue(Strings.lowerFirst(method.getName().substring(3)));
        }
 else         iocValue=convert(inject.value());
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    if (iocBean.field() != null && iocBean.field().length > 0) {
      for (      String fieldInfo : iocBean.field()) {
        if (fieldList.contains(fieldInfo))         throw Lang.makeThrow(""String_Node_Str"",classZ,fieldInfo);
        IocField iocField=new IocField();
        iocField.setName(fieldInfo);
        IocValue iocValue=new IocValue();
        iocValue.setType(IocValue.TYPE_REFER);
        iocValue.setValue(fieldInfo);
        iocField.setValue(iocValue);
        iocObject.addField(iocField);
        fieldList.add(iocField.getName());
      }
    }
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",classZ,beanName);
  }
}"
80780,"/** 
 * 初始化NutLog,检查全部Log的可用性,选择可用的Log适配器 <p/> <b>加载本类时,该方法已经在静态构造函数中调用,用户无需主动调用.</b> <p/> <b>除非迫不得已,请不要调用本方法<b/>
 */
public static void init(){
  try {
    adapter=new SimplePluginManager<LogAdapter>(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").get();
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}","/** 
 * 初始化NutLog,检查全部Log的可用性,选择可用的Log适配器 <p/> <b>加载本类时,该方法已经在静态构造函数中调用,用户无需主动调用.</b> <p/> <b>除非迫不得已,请不要调用本方法<b/>
 */
public static void init(){
  try {
    adapter=new SimplePluginManager<LogAdapter>(""String_Node_Str"",""String_Node_Str"").get();
  }
 catch (  Throwable e) {
    e.printStackTrace();
  }
}"
80781,"@Override protected void log(int level,Object message,Throwable tx){
switch (level) {
case LEVEL_FATAL:
    logger.log(SUPER_FQCN,Level.FATAL,message,tx);
  break;
case LEVEL_ERROR:
logger.log(SUPER_FQCN,Level.ERROR,message,tx);
break;
case LEVEL_WARN:
logger.log(SUPER_FQCN,Level.WARN,message,tx);
break;
case LEVEL_INFO:
logger.log(SUPER_FQCN,Level.INFO,message,tx);
break;
case LEVEL_DEBUG:
logger.log(SUPER_FQCN,Level.DEBUG,message,tx);
break;
case LEVEL_TRACE:
if (hasTrace) logger.log(SUPER_FQCN,Level.TRACE,message,tx);
break;
default :
break;
}
}","@Override protected void log(int level,Object message,Throwable tx){
switch (level) {
case LEVEL_FATAL:
    logger.log(SUPER_FQCN,Level.FATAL,message,tx);
  break;
case LEVEL_ERROR:
logger.log(SUPER_FQCN,Level.ERROR,message,tx);
break;
case LEVEL_WARN:
logger.log(SUPER_FQCN,Level.WARN,message,tx);
break;
case LEVEL_INFO:
logger.log(SUPER_FQCN,Level.INFO,message,tx);
break;
case LEVEL_DEBUG:
logger.log(SUPER_FQCN,Level.DEBUG,message,tx);
break;
case LEVEL_TRACE:
if (hasTrace) logger.log(SUPER_FQCN,Level.TRACE,message,tx);
 else logger.log(SUPER_FQCN,Level.DEBUG,message,tx);
break;
default :
break;
}
}"
80782,"Log4JLogger(String className){
  logger=LogManager.getLogger(className);
  isFatalEnabled=logger.isEnabledFor(Level.FATAL);
  isErrorEnabled=logger.isEnabledFor(Level.ERROR);
  isWarnEnabled=logger.isEnabledFor(Level.WARN);
  isInfoEnabled=logger.isEnabledFor(Level.INFO);
  isDebugEnabled=logger.isEnabledFor(Level.DEBUG);
  if (hasTrace)   isTraceEnabled=logger.isEnabledFor(Level.TRACE);
}","Log4JLogger(String className){
  logger=Logger.getLogger(className);
  isFatalEnabled=logger.isEnabledFor(Level.FATAL);
  isErrorEnabled=logger.isEnabledFor(Level.ERROR);
  isWarnEnabled=logger.isEnabledFor(Level.WARN);
  isInfoEnabled=logger.isEnabledFor(Level.INFO);
  isDebugEnabled=logger.isEnabledFor(Level.DEBUG);
  if (hasTrace)   isTraceEnabled=logger.isEnabledFor(Level.TRACE);
}"
80783,"public boolean canWork(){
  try {
    Class.forName(""String_Node_Str"",false,Thread.currentThread().getContextClassLoader());
    return isPropertyFileConfigured();
  }
 catch (  Throwable e) {
  }
  return false;
}","public boolean canWork(){
  try {
    Class.forName(""String_Node_Str"",false,Thread.currentThread().getContextClassLoader());
    return true;
  }
 catch (  Throwable e) {
  }
  return false;
}"
80784,"private int readTokenName(char[] cs,int i,StringBuilder sb){
  for (++i; i < cs.length; i++) {
    int b=(int)cs[i];
    if (b == '_' || b == '-' || (b >= 48 && b <= 57) || (b >= 65 && b <= 90) || (b >= 97 && b <= 122))     sb.append((char)b);
 else     break;
  }
  return i - 1;
}","private int readTokenName(char[] cs,int i,StringBuilder sb){
  for (++i; i < cs.length; i++) {
    int b=(int)cs[i];
    if (b == 95) {
      sb.append((char)b);
    }
 else     if ((b >= 0 && b <= 47) || (b >= 58 && b <= 64) || (b >= 91 && b <= 96)|| (b >= 123 && b <= 160)) {
      break;
    }
 else {
      sb.append((char)b);
    }
  }
  return i - 1;
}"
80785,"/** 
 * 将集合编程变成指定类型的列表
 * @param coll 集合对象
 * @param classOfList 列表类型
 * @return 列表对象
 */
public static <E>List<E> collection2list(Collection<E> coll,Class<List<E>> classOfList){
  if (coll instanceof List<?>)   return (List<E>)coll;
  List<E> list;
  try {
    list=(null == classOfList ? new ArrayList<E>(coll.size()) : classOfList.newInstance());
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
  for (Iterator<E> it=coll.iterator(); it.hasNext(); ) {
    list.add(it.next());
  }
  return list;
}","/** 
 * 将集合编程变成指定类型的列表
 * @param col 集合对象
 * @param classOfList 列表类型
 * @return 列表对象
 */
public static <E>List<E> collection2list(Collection<?> col,Class<E> eleType){
  if (null == col)   return null;
  List<E> list=new ArrayList<E>(col.size());
  for (  Object obj : col)   list.add(Castors.me().castTo(obj,eleType));
  return list;
}"
80786,"/** 
 * 根据一个 Map，和给定的对象类型，创建一个新的 JAVA 对象
 * @param src Map 对象
 * @param toType JAVA 对象类型
 * @return JAVA 对象
 * @throws FailToCastObjectException
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>T map2Object(Map<?,?> src,Class<T> toType) throws FailToCastObjectException {
  if (null == toType)   throw new FailToCastObjectException(""String_Node_Str"");
  if (toType == Map.class)   return (T)src;
  if (Map.class.isAssignableFrom(toType)) {
    Map map;
    try {
      map=(Map)toType.newInstance();
      map.putAll(src);
      return (T)map;
    }
 catch (    Exception e) {
      throw new FailToCastObjectException(""String_Node_Str"",e);
    }
  }
  Mirror<T> mirror=Mirror.me(toType);
  T obj=mirror.born();
  for (  Field field : mirror.getFields()) {
    if (src.containsKey(field.getName())) {
      Object v=src.get(field.getName());
      if (null == v)       continue;
      Class<?> ft=field.getType();
      Object vv=null;
      if (v instanceof Collection) {
        Collection c=(Collection)v;
        if (ft.isArray()) {
          vv=Lang.collection2array(c,ft.getComponentType());
        }
 else {
          Collection newCol;
          Class eleType=Mirror.getGenericTypes(field,0);
          if (ft == List.class) {
            newCol=new ArrayList(c.size());
          }
 else           if (ft == Set.class) {
            newCol=new LinkedHashSet();
          }
 else {
            try {
              newCol=(Collection)ft.newInstance();
            }
 catch (            Exception e) {
              throw Lang.wrapThrow(e);
            }
          }
          for (          Object ele : c) {
            newCol.add(Castors.me().castTo(ele,eleType));
          }
          vv=newCol;
        }
      }
 else       if (v instanceof Map) {
        final Map map;
        if (ft == Map.class) {
          map=new HashMap();
        }
 else {
          try {
            map=(Map)ft.newInstance();
          }
 catch (          Exception e) {
            throw new FailToCastObjectException(""String_Node_Str"",e);
          }
        }
        final Class<?> valType=Mirror.getGenericTypes(field,1);
        each(v,new Each<Entry>(){
          public void invoke(          int i,          Entry en,          int length){
            map.put(en.getKey(),Castors.me().castTo(en.getValue(),valType));
          }
        }
);
        vv=map;
      }
 else {
        vv=Castors.me().castTo(v,ft);
      }
      mirror.setValue(obj,field,vv);
    }
  }
  return obj;
}","/** 
 * 根据一个 Map，和给定的对象类型，创建一个新的 JAVA 对象
 * @param src Map 对象
 * @param toType JAVA 对象类型
 * @return JAVA 对象
 * @throws FailToCastObjectException
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>T map2Object(Map<?,?> src,Class<T> toType) throws FailToCastObjectException {
  if (null == toType)   throw new FailToCastObjectException(""String_Node_Str"");
  if (toType == Map.class)   return (T)src;
  if (Map.class.isAssignableFrom(toType)) {
    Map map;
    try {
      map=(Map)toType.newInstance();
      map.putAll(src);
      return (T)map;
    }
 catch (    Exception e) {
      throw new FailToCastObjectException(""String_Node_Str"",e);
    }
  }
  if (toType.isArray())   return (T)Lang.collection2array(src.values(),toType.getComponentType());
  if (List.class == toType) {
    return (T)Lang.collection2list(src.values());
  }
  Mirror<T> mirror=Mirror.me(toType);
  T obj=mirror.born();
  for (  Field field : mirror.getFields()) {
    if (src.containsKey(field.getName())) {
      Object v=src.get(field.getName());
      if (null == v)       continue;
      Class<?> ft=field.getType();
      Object vv=null;
      if (v instanceof Collection) {
        Collection c=(Collection)v;
        if (ft.isArray()) {
          vv=Lang.collection2array(c,ft.getComponentType());
        }
 else {
          Collection newCol;
          Class eleType=Mirror.getGenericTypes(field,0);
          if (ft == List.class) {
            newCol=new ArrayList(c.size());
          }
 else           if (ft == Set.class) {
            newCol=new LinkedHashSet();
          }
 else {
            try {
              newCol=(Collection)ft.newInstance();
            }
 catch (            Exception e) {
              throw Lang.wrapThrow(e);
            }
          }
          for (          Object ele : c) {
            newCol.add(Castors.me().castTo(ele,eleType));
          }
          vv=newCol;
        }
      }
 else       if (v instanceof Map) {
        final Map map;
        if (ft == Map.class) {
          map=new HashMap();
        }
 else {
          try {
            map=(Map)ft.newInstance();
          }
 catch (          Exception e) {
            throw new FailToCastObjectException(""String_Node_Str"",e);
          }
        }
        final Class<?> valType=Mirror.getGenericTypes(field,1);
        each(v,new Each<Entry>(){
          public void invoke(          int i,          Entry en,          int length){
            map.put(en.getKey(),Castors.me().castTo(en.getValue(),valType));
          }
        }
);
        vv=map;
      }
 else {
        vv=Castors.me().castTo(v,ft);
      }
      mirror.setValue(obj,field,vv);
    }
  }
  return obj;
}"
80787,"/** 
 * 将集合变成指定类型的数组
 * @param coll 集合对象
 * @param eleType 数组元素类型
 * @return 数组
 */
public static Object collection2array(Collection<?> coll,Class<?> eleType){
  if (null == coll)   return null;
  Object re=Array.newInstance(eleType,coll.size());
  int i=0;
  for (Iterator<?> it=coll.iterator(); it.hasNext(); ) {
    Object obj=it.next();
    if (null == obj)     Array.set(re,i++,null);
 else     Array.set(re,i++,Castors.me().castTo(obj,eleType));
  }
  return re;
}","/** 
 * 将集合变成指定类型的数组
 * @param col 集合对象
 * @param eleType 数组元素类型
 * @return 数组
 */
@SuppressWarnings(""String_Node_Str"") public static <E>E[] collection2array(Collection<?> col,Class<E> eleType){
  if (null == col)   return null;
  Object re=Array.newInstance(eleType,col.size());
  int i=0;
  for (Iterator<?> it=col.iterator(); it.hasNext(); ) {
    Object obj=it.next();
    if (null == obj)     Array.set(re,i++,null);
 else     Array.set(re,i++,Castors.me().castTo(obj,eleType));
  }
  return (E[])re;
}"
80788,"private <T>T getAs(Class<T> toType,String key,T dft){
  Object obj=get(key);
  if (null == obj)   return dft;
  return Castors.me().castTo(obj,toType);
}","public <T>T getAs(Class<T> toType,String key,T dft){
  Object obj=get(key);
  if (null == obj)   return dft;
  return Castors.me().castTo(obj,toType);
}"
80789,"public Object[] adapt(ServletContext sc,HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  String str;
  try {
    str=Lang.readAll(new InputStreamReader(request.getInputStream(),Encoding.CHARSET_UTF8));
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
  Map<String,Object> map=Lang.map(str);
  Object[] args=new Object[injs.length];
  int i=fillPathArgs(request,response,pathArgs,args);
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(sc,request,response,map);
  }
  return args;
}","public Object[] adapt(ServletContext sc,HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  String str;
  try {
    str=Lang.readAll(new InputStreamReader(request.getInputStream(),Encoding.CHARSET_UTF8));
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
  Object[] args=new Object[injs.length];
  int i=fillPathArgs(request,response,pathArgs,args);
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(sc,request,response,str);
  }
  return args;
}"
80790,"public View make(Ioc ioc,String type,String value){
  type=type.toLowerCase();
  if (VIEW_JSP.equals(type))   return new JspView(value);
  if (VIEW_JSON.equals(type))   if (Strings.isBlank(value))   return new UTF8JsonView(JsonFormat.compact());
 else   return new UTF8JsonView(Json.fromJson(JsonFormat.class,value));
  if (VIEW_REDIRECT.equals(type) || VIEW_REDIRECT2.equals(type))   return new ServerRedirectView(value);
  if (VIEW_FORWARD.equals(type) || VIEW_FORWARD2.equals(type))   return new ForwardView(value);
  if (VIEW_VOID.equals(type))   return new VoidView();
  if (VIEW_IOC.equals(type))   return ioc.get(View.class,value);
  if (VIEW_HTTP.equals(type))   return new HttpStatusView(Integer.parseInt(value));
  if (VIEW_STRING.equals(type))   return new RawView(value);
  return null;
}","public View make(Ioc ioc,String type,String value){
  type=type.toLowerCase();
  if (VIEW_JSP.equals(type))   return new JspView(value);
  if (VIEW_JSON.equals(type))   if (Strings.isBlank(value))   return new UTF8JsonView(JsonFormat.compact());
 else   return new UTF8JsonView(Json.fromJson(JsonFormat.class,value));
  if (VIEW_REDIRECT.equals(type) || VIEW_REDIRECT2.equals(type))   return new ServerRedirectView(value);
  if (VIEW_FORWARD.equals(type) || VIEW_FORWARD2.equals(type))   return new ForwardView(value);
  if (VIEW_VOID.equals(type))   return new VoidView();
  if (VIEW_IOC.equals(type))   return ioc.get(View.class,value);
  if (VIEW_HTTP.equals(type))   return new HttpStatusView(Integer.parseInt(value));
  if (VIEW_RAW.equals(type))   return new RawView(value);
  return null;
}"
80791,"/** 
 * @param < T >
 * @param type
 * @return
 * @throws Exception
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private <T>T parseFromCurrentLocation(Class<T> type,Class<?> componentType) throws Exception {
  Mirror<T> me=Mirror.me(type);
switch (cursor) {
case -1:
    return null;
case '[':
  Class<?> compType=componentType;
boolean reurnAsList=true;
List list=null;
if (null == type) {
list=new LinkedList();
}
 else if (type.isArray()) {
list=new LinkedList();
reurnAsList=false;
compType=type.getComponentType();
}
 else if (List.class.isAssignableFrom(type)) {
reurnAsList=true;
if (me.is(List.class)) list=new LinkedList();
 else list=(List)me.born();
}
 else {
throw makeError(String.format(""String_Node_Str"",type.getName()));
}
nextChar();
skipCommentsAndBlank();
while (cursor != -1 && cursor != ']') {
Object o=parseFromCurrentLocation(compType,null);
list.add(o);
skipCommentsAndBlank();
if (cursor == ']') break;
if (cursor != ',') throw makeError(""String_Node_Str"");
nextChar();
skipCommentsAndBlank();
}
nextChar();
if (reurnAsList) return (T)list;
Object ary=Array.newInstance(compType,list.size());
int i=0;
for (Iterator it=list.iterator(); it.hasNext(); ) Array.set(ary,i++,Castors.me().castTo(it.next(),compType));
return (T)ary;
case '{':
nextChar();
skipCommentsAndBlank();
if (Map.class == type) me=(Mirror<T>)Mirror.me(TreeMap.class);
if (null == me || Map.class.isAssignableFrom(type)) {
Map<String,Object> map=null == me ? new TreeMap<String,Object>() : (Map<String,Object>)me.born();
while (cursor != -1 && cursor != '}') {
String name=readFieldName();
Object value=parseFromJson(componentType,null);
map.put(name,value);
if (!findNextNamePair()) break;
}
nextChar();
return (T)map;
}
T obj=me.born();
while (cursor != -1 && cursor != '}') {
Field f=me.getField(readFieldName());
Class<?> ft=f.getType();
Class<?> eleType=null;
if (List.class.isAssignableFrom(ft)) {
Class<?>[] ts=Mirror.getGenericTypes(f);
if (ts.length > 0) eleType=ts[0];
}
 else if (Map.class.isAssignableFrom(ft)) {
Class<?>[] ts=Mirror.getGenericTypes(f);
if (ts.length > 1) eleType=ts[1];
}
Object value=parseFromJson(f.getType(),eleType);
me.setValue(obj,f,value);
if (!findNextNamePair()) break;
}
nextChar();
return obj;
case 'u':
if ('n' != (char)nextChar() & 'd' != (char)nextChar() & 'e' != (char)nextChar() & 'f' != (char)nextChar() & 'i' != (char)nextChar() & 'n' != (char)nextChar() & 'e' != (char)nextChar() & 'd' != (char)nextChar()) throw makeError(""String_Node_Str"");
nextChar();
return null;
case 'n':
if ('u' != (char)nextChar() & 'l' != (char)nextChar() & 'l' != (char)nextChar()) throw makeError(""String_Node_Str"");
nextChar();
return null;
case '\'':
case '""':
StringBuilder vs=readString();
String value=vs.toString();
if (null == me || me.is(String.class)) return (T)value;
return Castors.me().castTo(value,me.getType());
case 't':
if ('u' != (char)nextChar() & 'r' != (char)nextChar() & 'e' != (char)nextChar()) throw makeError(""String_Node_Str"");
if (null != type && !Mirror.me(type).isBoolean()) throw makeError(""String_Node_Str"");
nextChar();
return (T)Boolean.valueOf(true);
case 'f':
if ('a' != (char)nextChar() & 'l' != (char)nextChar() & 's' != (char)nextChar() & 'e' != (char)nextChar()) throw makeError(""String_Node_Str"");
if (null != type && !Mirror.me(type).isBoolean()) throw makeError(""String_Node_Str"");
nextChar();
return (T)Boolean.valueOf(false);
case '.':
case '-':
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
StringBuilder sb=new StringBuilder();
do {
sb.append((char)cursor);
nextChar();
}
 while (cursor != ' ' && cursor != -1 && cursor != ',' && cursor != ']' && cursor != '}' && cursor != '/');
String numValue=Strings.trim(sb);
if (null != me) {
if (me.isInt()) {
return (T)Integer.valueOf(numValue);
}
 else if (me.isLong()) {
return (T)Long.valueOf(numValue);
}
 else if (me.isFloat()) {
return (T)Float.valueOf(numValue);
}
 else if (me.isDouble()) {
return (T)Double.valueOf(numValue);
}
 else if (me.isByte()) {
return (T)Byte.valueOf(numValue);
}
}
if (null == me || me.isNumber() || me.is(Object.class)) {
char lastChar=Character.toUpperCase(numValue.charAt(numValue.length() - 1));
if (numValue.indexOf('.') >= 0) {
if (lastChar == 'F') return (T)Float.valueOf(numValue.substring(0,numValue.length() - 1));
 else return (T)Double.valueOf(numValue);
}
 else {
if (lastChar == 'L') return (T)Long.valueOf(numValue.substring(0,numValue.length() - 1));
 else return (T)Integer.valueOf(numValue);
}
}
throw makeError(""String_Node_Str"");
case 'v':
while (-1 != nextChar()) if ('{' == cursor) return parseFromCurrentLocation(type,componentType);
default :
throw makeError(""String_Node_Str"");
}
}","/** 
 * @param < T >
 * @param type
 * @return
 * @throws Exception
 */
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private <T>T parseFromCurrentLocation(Class<T> type,Class<?> componentType) throws Exception {
  Mirror<T> me=Mirror.me(type);
switch (cursor) {
case -1:
    return null;
case '[':
  Class<?> compType=componentType;
boolean reurnAsList=true;
List list=null;
if (null == type) {
list=new LinkedList();
}
 else if (type.isArray()) {
list=new LinkedList();
reurnAsList=false;
compType=type.getComponentType();
}
 else if (List.class.isAssignableFrom(type)) {
reurnAsList=true;
if (me.is(List.class)) list=new LinkedList();
 else list=(List)me.born();
}
 else {
throw makeError(String.format(""String_Node_Str"",type.getName()));
}
nextChar();
skipCommentsAndBlank();
while (cursor != -1 && cursor != ']') {
Object o=parseFromCurrentLocation(compType,null);
list.add(o);
skipCommentsAndBlank();
if (cursor == ']') break;
if (cursor != ',') throw makeError(""String_Node_Str"");
nextChar();
skipCommentsAndBlank();
}
nextChar();
if (reurnAsList) return (T)list;
Object ary=Array.newInstance(compType,list.size());
int i=0;
for (Iterator it=list.iterator(); it.hasNext(); ) Array.set(ary,i++,Castors.me().castTo(it.next(),compType));
return (T)ary;
case '{':
nextChar();
skipCommentsAndBlank();
if (Map.class == type) me=(Mirror<T>)Mirror.me(TreeMap.class);
if (null == me || Map.class.isAssignableFrom(type)) {
Map<String,Object> map=null == me ? new TreeMap<String,Object>() : (Map<String,Object>)me.born();
while (cursor != -1 && cursor != '}') {
String name=readFieldName();
Object value=parseFromJson(componentType,null);
map.put(name,value);
if (!findNextNamePair()) break;
}
nextChar();
return (T)map;
}
T obj=me.born();
while (cursor != -1 && cursor != '}') {
Field f=null;
Class<?> ft=null;
Class<?> eleType=null;
try {
f=me.getField(readFieldName());
ft=f.getType();
}
 catch (NoSuchFieldException e) {
}
if (null != ft) {
if (List.class.isAssignableFrom(ft)) {
Class<?>[] ts=Mirror.getGenericTypes(f);
if (ts.length > 0) eleType=ts[0];
}
 else if (Map.class.isAssignableFrom(ft)) {
Class<?>[] ts=Mirror.getGenericTypes(f);
if (ts.length > 1) eleType=ts[1];
}
}
Object value=parseFromJson(ft,eleType);
if (null != f) me.setValue(obj,f,value);
if (!findNextNamePair()) break;
}
nextChar();
return obj;
case 'u':
if ('n' != (char)nextChar() & 'd' != (char)nextChar() & 'e' != (char)nextChar() & 'f' != (char)nextChar() & 'i' != (char)nextChar() & 'n' != (char)nextChar() & 'e' != (char)nextChar() & 'd' != (char)nextChar()) throw makeError(""String_Node_Str"");
nextChar();
return null;
case 'n':
if ('u' != (char)nextChar() & 'l' != (char)nextChar() & 'l' != (char)nextChar()) throw makeError(""String_Node_Str"");
nextChar();
return null;
case '\'':
case '""':
StringBuilder vs=readString();
String value=vs.toString();
if (null == me || me.is(String.class)) return (T)value;
return Castors.me().castTo(value,me.getType());
case 't':
if ('u' != (char)nextChar() & 'r' != (char)nextChar() & 'e' != (char)nextChar()) throw makeError(""String_Node_Str"");
if (null != type && !Mirror.me(type).isBoolean()) throw makeError(""String_Node_Str"");
nextChar();
return (T)Boolean.valueOf(true);
case 'f':
if ('a' != (char)nextChar() & 'l' != (char)nextChar() & 's' != (char)nextChar() & 'e' != (char)nextChar()) throw makeError(""String_Node_Str"");
if (null != type && !Mirror.me(type).isBoolean()) throw makeError(""String_Node_Str"");
nextChar();
return (T)Boolean.valueOf(false);
case '.':
case '-':
case '0':
case '1':
case '2':
case '3':
case '4':
case '5':
case '6':
case '7':
case '8':
case '9':
StringBuilder sb=new StringBuilder();
do {
sb.append((char)cursor);
nextChar();
}
 while (cursor != ' ' && cursor != -1 && cursor != ',' && cursor != ']' && cursor != '}' && cursor != '/');
String numValue=Strings.trim(sb);
if (null != me) {
if (me.isInt()) {
return (T)Integer.valueOf(numValue);
}
 else if (me.isLong()) {
return (T)Long.valueOf(numValue);
}
 else if (me.isFloat()) {
return (T)Float.valueOf(numValue);
}
 else if (me.isDouble()) {
return (T)Double.valueOf(numValue);
}
 else if (me.isByte()) {
return (T)Byte.valueOf(numValue);
}
}
if (null == me || me.isNumber() || me.is(Object.class)) {
char lastChar=Character.toUpperCase(numValue.charAt(numValue.length() - 1));
if (numValue.indexOf('.') >= 0) {
if (lastChar == 'F') return (T)Float.valueOf(numValue.substring(0,numValue.length() - 1));
 else return (T)Double.valueOf(numValue);
}
 else {
if (lastChar == 'L') return (T)Long.valueOf(numValue.substring(0,numValue.length() - 1));
 else return (T)Integer.valueOf(numValue);
}
}
throw makeError(""String_Node_Str"");
case 'v':
while (-1 != nextChar()) if ('{' == cursor) return parseFromCurrentLocation(type,componentType);
default :
throw makeError(""String_Node_Str"");
}
}"
80792,"/** 
 * 执行根据流来加载sql内容的操作
 * @param stream
 * @throws IOException
 * @author mawenming at 2010-4-10 上午10:04:17
 */
private void loadSQL(Reader stream) throws IOException {
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(stream);
    SqlFileBuilder p=new SqlFileBuilder(bufferedReader);
    Iterator<String> it=p.keys().iterator();
    _sql_keys=new ArrayList<String>(p.map.size());
    while (it.hasNext()) {
      String key=it.next();
      String value=Strings.trim(p.get(key));
      addSql(key,value);
    }
  }
  finally {
    Streams.safeClose(bufferedReader);
    Streams.safeClose(stream);
  }
}","/** 
 * 执行根据字符流来加载sql内容的操作
 * @param reader
 * @throws IOException
 * @author mawenming at 2010-4-10 上午10:04:17
 */
protected void loadSQL(Reader reader) throws IOException {
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(reader);
    SqlFileBuilder p=new SqlFileBuilder(bufferedReader);
    Iterator<String> it=p.keys().iterator();
    _sql_keys=new ArrayList<String>(p.map.size());
    while (it.hasNext()) {
      String key=it.next();
      String value=Strings.trim(p.get(key));
      addSql(key,value);
    }
  }
  finally {
    Streams.safeClose(bufferedReader);
    Streams.safeClose(reader);
  }
}"
80793,"public void refresh(){
  List<NutResource> nrs=new LinkedList<NutResource>();
  for (  String path : paths) {
    File f=Files.findFile(path);
    if (null == f)     continue;
    if (!f.getAbsolutePath().contains(""String_Node_Str"") && f.isFile()) {
      nrs.add(new FileResource(f.getParentFile(),f));
      if (autoscan == false)       continue;
    }
    List<NutResource> list=Scans.me().scan(path,regex);
    String parent=path;
    int pos=path.lastIndexOf('/');
    if (pos == -1)     pos=path.lastIndexOf('\\');
    if (pos > 0)     parent=path.substring(0,pos);
    if (Strings.isBlank(parent)) {
      nrs.addAll(list);
    }
 else {
      for (      NutResource nr : list)       if (autoscan) {
        if (nr.getName().startsWith(parent)) {
          nrs.add(nr);
        }
      }
 else {
        if (nr.getName().equals(path)) {
          nrs.add(nr);
        }
      }
    }
  }
  buildSQLMaps(nrs);
}","public void refresh(){
  List<InputStream> list=Scans.me().loadResource(null,paths);
  _sql_map=new HashMap<String,String>();
  for (  InputStream ins : list) {
    Reader r=new InputStreamReader(ins);
    try {
      loadSQL(r);
    }
 catch (    IOException e) {
      throw Lang.wrapThrow(e);
    }
  }
}"
80794,"public FileSqlManager(String... paths){
  this.paths=paths;
  this.autoscan=true;
}","public FileSqlManager(String... paths){
  this.paths=paths;
}"
80795,"public JsonLoader(String... paths){
  this.setMap(new HashMap<String,Map<String,Object>>());
  try {
    for (    String path : paths) {
      File f=Files.findFile(path);
      if (null != f && f.isFile()) {
        loadFromInputStream(new FileInputStream(f));
        continue;
      }
      List<NutResource> rsList=Scans.me().scan(path,""String_Node_Str"");
      for (      NutResource nr : rsList) {
        loadFromInputStream(nr.getInputStream());
      }
      if (rsList.size() < 1)       throw Lang.makeThrow(RuntimeException.class,""String_Node_Str"",path);
    }
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}","public JsonLoader(String... paths){
  this.setMap(new HashMap<String,Map<String,Object>>());
  List<InputStream> list=Scans.me().loadResource(""String_Node_Str"",paths);
  for (  InputStream ins : list)   loadFromInputStream(ins);
}"
80796,"public XmlIocLoader(String... fileNames){
  try {
    DocumentBuilder builder=Lang.xmls();
    Document document;
    for (    String fileName : fileNames) {
      document=builder.parse(Files.findFileAsStream(fileName));
      document.normalizeDocument();
      NodeList nodeListZ=((Element)document.getDocumentElement()).getChildNodes();
      for (int i=0; i < nodeListZ.getLength(); i++) {
        if (nodeListZ.item(i) instanceof Element)         paserBean((Element)nodeListZ.item(i),false);
      }
    }
    handleParent();
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",Json.toJson(iocMap));
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
}","public XmlIocLoader(String... fileNames){
  try {
    DocumentBuilder builder=Lang.xmls();
    Document document;
    List<InputStream> list=Scans.me().loadResource(""String_Node_Str"",fileNames);
    for (    InputStream ins : list) {
      document=builder.parse(ins);
      document.normalizeDocument();
      NodeList nodeListZ=((Element)document.getDocumentElement()).getChildNodes();
      for (int i=0; i < nodeListZ.getLength(); i++) {
        if (nodeListZ.item(i) instanceof Element)         paserBean((Element)nodeListZ.item(i),false);
      }
      Streams.safeClose(ins);
    }
    handleParent();
    if (LOG.isDebugEnabled())     LOG.debugf(""String_Node_Str"",Json.toJson(iocMap));
  }
 catch (  Throwable e) {
    throw Lang.wrapThrow(e);
  }
}"
80797,"@Test public void test_dynamic_insert(){
  pojos.init();
  ((NutDao)dao).setSqlManager(new FileSqlManager(""String_Node_Str"").setAutoscan(false));
  int platoonId=23;
  try {
    pojos.initPlatoon(platoonId);
    Sql sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",12);
    dao.execute(sql);
    sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",13);
    dao.execute(sql);
    sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",14);
    dao.execute(sql);
    sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",15);
    dao.execute(sql);
    TableName.run(platoonId,new Atom(){
      public void run(){
        assertEquals(4,dao.count(Tank.class));
      }
    }
);
  }
 catch (  SqlNotFoundException e) {
  }
 finally {
    pojos.dropPlatoon(platoonId);
  }
}","@Test public void test_dynamic_insert(){
  pojos.init();
  ((NutDao)dao).setSqlManager(new FileSqlManager(""String_Node_Str""));
  int platoonId=23;
  try {
    pojos.initPlatoon(platoonId);
    Sql sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",12);
    dao.execute(sql);
    sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",13);
    dao.execute(sql);
    sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",14);
    dao.execute(sql);
    sql=dao.sqls().create(""String_Node_Str"");
    sql.vars().set(""String_Node_Str"",platoonId);
    sql.params().set(""String_Node_Str"",""String_Node_Str"").set(""String_Node_Str"",15);
    dao.execute(sql);
    TableName.run(platoonId,new Atom(){
      public void run(){
        assertEquals(4,dao.count(Tank.class));
      }
    }
);
  }
 catch (  SqlNotFoundException e) {
  }
 finally {
    pojos.dropPlatoon(platoonId);
  }
}"
80798,"public Object remove(Object arg0){
  return map.remove(arg0);
}","public Object remove(Object key){
  return map.remove(key.toString().toLowerCase());
}"
80799,"public boolean containsValue(Object arg0){
  return map.containsValue(arg0);
}","public boolean containsValue(Object value){
  return map.containsValue(value);
}"
80800,"public Object put(String arg0,Object arg1){
  return map.put(arg0,arg1);
}","public Object put(String name,Object value){
  return map.put(name.toLowerCase(),value);
}"
80801,"public void putAll(Map<? extends String,? extends Object> arg0){
  map.putAll(arg0);
}","public void putAll(Map<? extends String,? extends Object> out){
  for (  Entry<? extends String,? extends Object> entry : out.entrySet())   map.put(entry.getKey().toLowerCase(),entry.getValue());
}"
80802,"public static Record create(ResultSet rs){
  try {
    Record re=new Record();
    ResultSetMetaData meta=rs.getMetaData();
    int count=meta.getColumnCount();
    for (int i=1; i <= count; i++) {
      String name=meta.getColumnLabel(i);
      if (meta.getColumnType(i) == Types.CLOB) {
        re.set(name.toLowerCase(),rs.getString(i));
      }
 else {
        re.set(name.toLowerCase(),rs.getObject(i));
      }
    }
    return re;
  }
 catch (  SQLException e) {
    throw Lang.wrapThrow(e);
  }
}","public static Record create(ResultSet rs){
  try {
    Record re=new Record();
    ResultSetMetaData meta=rs.getMetaData();
    int count=meta.getColumnCount();
    for (int i=1; i <= count; i++) {
      String name=meta.getColumnLabel(i);
      if (meta.getColumnType(i) == Types.CLOB) {
        re.set(name,rs.getString(i));
      }
 else {
        re.set(name,rs.getObject(i));
      }
    }
    return re;
  }
 catch (  SQLException e) {
    throw Lang.wrapThrow(e);
  }
}"
80803,"/** 
 * 设置值
 * @param name 字段名
 * @param value 字段值
 * @return 记录本身
 */
public Record set(String name,Object value){
  map.put(name,value);
  return this;
}","/** 
 * 设置值
 * @param name 字段名
 * @param value 字段值
 * @return 记录本身
 */
public Record set(String name,Object value){
  map.put(name.toLowerCase(),value);
  return this;
}"
80804,"public Set<java.util.Map.Entry<String,Object>> entrySet(){
  return map.entrySet();
}","public Set<Entry<String,Object>> entrySet(){
  return map.entrySet();
}"
80805,"public boolean containsKey(Object arg0){
  return map.containsKey(arg0);
}","public boolean containsKey(Object key){
  return map.containsKey(key);
}"
80806,"public boolean equals(Object arg0){
  return map.equals(arg0);
}","public boolean equals(Object out){
  return map.equals(out);
}"
80807,"public int updateIgnoreNull(final Object obj){
  final int[] re={0};
  FieldFilter.create(obj.getClass(),true).run(new Atom(){
    public void run(){
      re[0]=update(obj);
    }
  }
);
  return re[0];
}","public int updateIgnoreNull(final Object obj){
  if (null == obj)   return 0;
  Object first=Lang.first(obj);
  if (null == first)   return 0;
  final int[] re={0};
  FieldFilter.create(first.getClass(),true).run(new Atom(){
    public void run(){
      re[0]=update(obj);
    }
  }
);
  return re[0];
}"
80808,"/** 
 * 根据一段字符串，生成一个List 对象。
 * @param str 参照 JSON 标准的字符串，但是可以没有前后的中括号
 * @return List 对象
 */
@SuppressWarnings(""String_Node_Str"") public static List<Object> list(String str){
  if (null == str)   return null;
  if ((str.length() > 0 && str.charAt(0) == '[') && str.endsWith(""String_Node_Str""))   return (List<Object>)Json.fromJson(str);
  return (List<Object>)Json.fromJson(""String_Node_Str"" + str + ""String_Node_Str"");
}","/** 
 * 较方便的创建一个列表，比如： <pre> List《Pet》 pets = Lang.list(pet1, pet2, pet3); </pre>
 * @param eles 可变参数
 * @return 列表对象
 */
public static <T>List<T> list(T... eles){
  List<T> list=new ArrayList<T>(eles.length);
  for (  T ele : eles)   list.add(ele);
  return list;
}"
80809,"@Test public void test_first4_map_collection(){
  assertNull(Lang.first(new HashMap<String,String>()));
  Map<?,?> map1=Lang.map(""String_Node_Str"");
  assertTrue(map1.entrySet().contains(Lang.first(map1)));
  assertNull(Lang.first(new ArrayList<String>()));
  List<Object> l=Lang.list(""String_Node_Str"");
  assertEquals(1,Lang.first(l));
}","@Test public void test_first4_map_collection(){
  assertNull(Lang.first(new HashMap<String,String>()));
  Map<?,?> map1=Lang.map(""String_Node_Str"");
  assertTrue(map1.entrySet().contains(Lang.first(map1)));
  assertNull(Lang.first(new ArrayList<String>()));
  List<Object> l=Lang.list4(""String_Node_Str"");
  assertEquals(1,Lang.first(l));
}"
80810,"protected ParamInjector evalInjector(Class<?> type,Param param){
  if (Map.class.isAssignableFrom(type))   return new MapSelfInjector();
  if (null == param)   return null;
  String paramName=param.value();
  if (File.class.isAssignableFrom(type))   return new FileInjector(paramName);
  if (FieldMeta.class.isAssignableFrom(type))   return new FileMetaInjector(paramName);
  if (TempFile.class.isAssignableFrom(type))   return new TempFileInjector(paramName);
  if (List.class.isAssignableFrom(type))   return new MapListInjector(paramName);
  if (type.isArray())   return new MapArrayInjector(type.getComponentType(),paramName);
  if (""String_Node_Str"".equals(paramName)) {
    if (type.isAssignableFrom(Map.class))     return new MapPairInjector();
    return new MapReferInjector(null,type);
  }
 else   if (paramName.startsWith(""String_Node_Str"") && paramName.length() > 2) {
    return new MapReferInjector(paramName.substring(2),type);
  }
  return new MapItemInjector(paramName,type);
}","protected ParamInjector evalInjector(Class<?> type,Param param){
  if (Map.class.isAssignableFrom(type))   return new MapSelfInjector();
  if (null == param)   return null;
  String paramName=param.value();
  if (File.class.isAssignableFrom(type))   return new FileInjector(paramName);
  if (FieldMeta.class.isAssignableFrom(type))   return new FileMetaInjector(paramName);
  if (TempFile.class.isAssignableFrom(type))   return new TempFileInjector(paramName);
  if (InputStream.class.isAssignableFrom(type))   return new InputStreamInjector(paramName);
  if (Reader.class.isAssignableFrom(type))   return new ReaderInjector(paramName);
  if (List.class.isAssignableFrom(type))   return new MapListInjector(paramName);
  if (type.isArray())   return new MapArrayInjector(type.getComponentType(),paramName);
  if (""String_Node_Str"".equals(paramName)) {
    if (type.isAssignableFrom(Map.class))     return new MapPairInjector();
    return new MapReferInjector(null,type);
  }
 else   if (paramName.startsWith(""String_Node_Str"") && paramName.length() > 2) {
    return new MapReferInjector(paramName.substring(2),type);
  }
  return new MapItemInjector(paramName,type);
}"
80811,"@SuppressWarnings(""String_Node_Str"") public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object obj=((Map<String,Object>)refer).get(name);
  if (obj == null)   return null;
  if (obj instanceof TempFile) {
    return ((TempFile)obj).getFile();
  }
 else {
    List<?> list=(List<?>)obj;
    if (list.isEmpty())     return null;
 else     return ((TempFile)list.get(0)).getFile();
  }
}","public Object get(ServletContext sc,HttpServletRequest req,HttpServletResponse resp,Object refer){
  return getFile(refer);
}"
80812,"public View make(Ioc ioc,String type,String value){
  type=type.toLowerCase();
  if (VIEW_JSP.equals(type))   return new JspView(value);
  if (VIEW_JSON.equals(type))   if (Strings.isBlank(value))   return new UTF8JsonView(JsonFormat.compact());
 else   return new UTF8JsonView(Json.fromJson(JsonFormat.class,value));
  if (VIEW_REDIRECT.equals(type) || VIEW_REDIRECT2.equals(type))   return new ServerRedirectView(value);
  if (VIEW_VOID.equals(type))   return new VoidView();
  if (VIEW_IOC.equals(type))   return ioc.get(View.class,value);
  if (VIEW_HTTP.equals(type))   return new HttpStatusView(Integer.parseInt(value));
  return null;
}","public View make(Ioc ioc,String type,String value){
  type=type.toLowerCase();
  if (VIEW_JSP.equals(type))   return new JspView(value);
  if (VIEW_JSON.equals(type))   if (Strings.isBlank(value))   return new UTF8JsonView(JsonFormat.compact());
 else   return new UTF8JsonView(Json.fromJson(JsonFormat.class,value));
  if (VIEW_REDIRECT.equals(type) || VIEW_REDIRECT2.equals(type))   return new ServerRedirectView(value);
  if (VIEW_FORWARD.equals(type) || VIEW_FORWARD2.equals(type))   return new ForwardView(value);
  if (VIEW_VOID.equals(type))   return new VoidView();
  if (VIEW_IOC.equals(type))   return ioc.get(View.class,value);
  if (VIEW_HTTP.equals(type))   return new HttpStatusView(Integer.parseInt(value));
  return null;
}"
80813,"public JspView(String name){
  if (!Strings.isBlank(name)) {
    path=normalizePath(name,""String_Node_Str"");
  }
}","public JspView(String name){
  super(name);
}"
80814,"private static RuntimeException makeSetValueException(Class<?> type,String name,Object value,Exception e){
  return new FailToSetValueException(String.format(""String_Node_Str"",value,type.getName(),name,e.getMessage()));
}","private static RuntimeException makeSetValueException(Class<?> type,String name,Object value,Exception e){
  if (e instanceof FailToSetValueException) {
    return (FailToSetValueException)e;
  }
  return new FailToSetValueException(String.format(""String_Node_Str"",value,type.getName(),name,e.getMessage()));
}"
80815,"/** 
 * 为对象的一个字段设值。优先调用 setter 方法。
 * @param obj 对象
 * @param fieldName 字段名
 * @param value 值
 * @throws FailToSetValueException
 */
public void setValue(Object obj,String fieldName,Object value) throws FailToSetValueException {
  try {
    this.getSetter(fieldName,value.getClass()).invoke(obj,value);
  }
 catch (  Exception e) {
    try {
      Field field=this.getField(fieldName);
      setValue(obj,field,value);
    }
 catch (    Exception e1) {
      throw makeSetValueException(obj.getClass(),fieldName,value,e1);
    }
  }
}","/** 
 * 为对象的一个字段设值。优先调用 setter 方法。
 * @param obj 对象
 * @param fieldName 字段名
 * @param value 值
 * @throws FailToSetValueException
 */
public void setValue(Object obj,String fieldName,Object value) throws FailToSetValueException {
  if (null == value) {
    try {
      setValue(obj,this.getField(fieldName),value);
    }
 catch (    Exception e1) {
      throw makeSetValueException(obj.getClass(),fieldName,value,e1);
    }
  }
 else {
    try {
      this.getSetter(fieldName,value.getClass()).invoke(obj,value);
    }
 catch (    Exception e) {
      try {
        setValue(obj,this.getField(fieldName),value);
      }
 catch (      Exception e1) {
        throw makeSetValueException(obj.getClass(),fieldName,value,e1);
      }
    }
  }
}"
80816,"@Test public void test_setValue_Boolean_and_Character(){
  SV sv=new SV();
  sv.ok=true;
  sv.cobj=Character.valueOf('F');
  Mirror.me(SV.class).setValue(sv,""String_Node_Str"",null);
  Mirror.me(SV.class).setValue(sv,""String_Node_Str"",null);
  assertNull(sv.ok);
  assertNull(sv.cobj);
}","@Test public void test_setValue_Boolean_and_Character(){
  SV sv=new SV();
  sv.ok=true;
  sv.cobj=Character.valueOf('F');
  sv.intobj=30;
  Mirror.me(SV.class).setValue(sv,""String_Node_Str"",null);
  Mirror.me(SV.class).setValue(sv,""String_Node_Str"",null);
  Mirror.me(SV.class).setValue(sv,""String_Node_Str"",null);
  assertNull(sv.ok);
  assertNull(sv.cobj);
  assertNull(sv.intobj);
}"
80817,"@Override public java.util.Date cast(String src,Class<?> toType,String... args){
  try {
    return dateTimeFormat.parse(src);
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}","@Override public java.util.Date cast(String src,Class<?> toType,String... args){
  try {
    return dateFormat.parse(src);
  }
 catch (  ParseException e) {
    throw Lang.wrapThrow(e);
  }
}"
80818,"public void refresh(){
  List<NutResource> nrs=new LinkedList<NutResource>();
  for (  String path : paths) {
    File f=Files.findFile(path);
    if (null == f)     continue;
    if (f.isFile()) {
      nrs.add(new FileResource(f.getParentFile(),f));
      if (autoscan == false)       continue;
    }
    List<NutResource> list=Scans.me().scan(path,regex);
    String parent=path;
    int pos=path.lastIndexOf('/');
    if (pos == -1)     pos=path.lastIndexOf('\\');
    if (pos > 0)     parent=path.substring(0,pos);
    if (Strings.isBlank(parent)) {
      nrs.addAll(list);
    }
 else {
      for (      NutResource nr : list)       if (autoscan) {
        if (nr.getName().startsWith(parent)) {
          nrs.add(nr);
        }
      }
 else {
        if (nr.getName().equals(path)) {
          nrs.add(nr);
        }
      }
    }
  }
  buildSQLMaps(nrs);
}","public void refresh(){
  List<NutResource> nrs=new LinkedList<NutResource>();
  for (  String path : paths) {
    File f=Files.findFile(path);
    if (null == f)     continue;
    if (!f.getAbsolutePath().contains(""String_Node_Str"") && f.isFile()) {
      nrs.add(new FileResource(f.getParentFile(),f));
      if (autoscan == false)       continue;
    }
    List<NutResource> list=Scans.me().scan(path,regex);
    String parent=path;
    int pos=path.lastIndexOf('/');
    if (pos == -1)     pos=path.lastIndexOf('\\');
    if (pos > 0)     parent=path.substring(0,pos);
    if (Strings.isBlank(parent)) {
      nrs.addAll(list);
    }
 else {
      for (      NutResource nr : list)       if (autoscan) {
        if (nr.getName().startsWith(parent)) {
          nrs.add(nr);
        }
      }
 else {
        if (nr.getName().equals(path)) {
          nrs.add(nr);
        }
      }
    }
  }
  buildSQLMaps(nrs);
}"
80819,"protected List<NutResource> scanInDir(final Pattern regex,final String base,File f,final boolean ignoreHidden){
  final List<NutResource> list=new ArrayList<NutResource>();
  if (null == f || (ignoreHidden && f.isHidden()) || (!f.exists()))   return list;
  if (!f.isDirectory())   f=f.getParentFile();
  Disks.visitFile(f,new FileVisitor(){
    public void visit(    File file){
      list.add(new FileResource(base,file));
    }
  }
,new FileFilter(){
    public boolean accept(    File theFile){
      if (ignoreHidden && theFile.isHidden())       return false;
      if (theFile.isDirectory())       return true;
      return regex == null || regex.matcher(theFile.getName()).find();
    }
  }
);
  return list;
}","protected List<NutResource> scanInDir(final Pattern regex,final String base,File f,final boolean ignoreHidden){
  final List<NutResource> list=new ArrayList<NutResource>();
  if (null == f || (ignoreHidden && f.isHidden()) || (!f.exists()))   return list;
  if (!f.isDirectory())   f=f.getParentFile();
  Disks.visitFile(f,new FileVisitor(){
    public void visit(    File file){
      list.add(new FileResource(base,file));
    }
  }
,new FileFilter(){
    public boolean accept(    File theFile){
      if (ignoreHidden && theFile.isHidden())       return false;
      if (theFile.isDirectory()) {
        String fnm=theFile.getName().toLowerCase();
        if (""String_Node_Str"".equals(fnm) || ""String_Node_Str"".equals(fnm))         return false;
        return true;
      }
      return regex == null || regex.matcher(theFile.getName()).find();
    }
  }
);
  return list;
}"
80820,"public boolean accept(File theFile){
  if (ignoreHidden && theFile.isHidden())   return false;
  if (theFile.isDirectory())   return true;
  return regex == null || regex.matcher(theFile.getName()).find();
}","public boolean accept(File theFile){
  if (ignoreHidden && theFile.isHidden())   return false;
  if (theFile.isDirectory()) {
    String fnm=theFile.getName().toLowerCase();
    if (""String_Node_Str"".equals(fnm) || ""String_Node_Str"".equals(fnm))     return false;
    return true;
  }
  return regex == null || regex.matcher(theFile.getName()).find();
}"
80821,"@Test public void testString2JavaDate() throws FailToCastObjectException {
  java.util.Date date=Castors.me().cast(""String_Node_Str"",String.class,java.util.Date.class);
  Calendar cal=Calendar.getInstance();
  cal.setTime(date);
  assertEquals(2008,cal.get(Calendar.YEAR));
  assertEquals(5,cal.get(Calendar.MONTH));
  assertEquals(12,cal.get(Calendar.DAY_OF_MONTH));
  assertEquals(15,cal.get(Calendar.HOUR_OF_DAY));
  assertEquals(28,cal.get(Calendar.MINUTE));
  assertEquals(35,cal.get(Calendar.SECOND));
}","@Test public void testString2JavaDate() throws FailToCastObjectException {
  java.util.Date date=Castors.me().castTo(""String_Node_Str"",java.util.Date.class);
  Calendar cal=Calendar.getInstance();
  cal.setTime(date);
  assertEquals(2008,cal.get(Calendar.YEAR));
  assertEquals(5,cal.get(Calendar.MONTH));
  assertEquals(12,cal.get(Calendar.DAY_OF_MONTH));
  assertEquals(0,cal.get(Calendar.HOUR_OF_DAY));
  assertEquals(0,cal.get(Calendar.MINUTE));
  assertEquals(0,cal.get(Calendar.SECOND));
}"
80822,"private void reload(){
  HashMap<Class<?>,Method> settingMap=new HashMap<Class<?>,Method>();
  for (  Method m1 : setting.getClass().getMethods()) {
    Class<?>[] pts=m1.getParameterTypes();
    if (pts.length == 1 && Castor.class.isAssignableFrom(pts[0]))     settingMap.put(pts[0],m1);
  }
  this.map=new HashMap<String,Map<String,Castor<?,?>>>();
  for (Iterator<Class<?>> it=paths.iterator(); it.hasNext(); ) {
    Class<?> baseClass=it.next();
    if (baseClass == null)     continue;
    List<Class<?>> list=Scans.me().scanPackage(baseClass);
    if (null == list || list.size() == 0)     continue;
    for (    Class<?> klass : list) {
      try {
        if (Modifier.isAbstract(klass.getModifiers()))         continue;
        if (!Castor.class.isAssignableFrom(klass))         continue;
        Castor<?,?> castor=(Castor<?,?>)klass.newInstance();
        Map<String,Castor<?,?>> map2=this.map.get(castor.getFromClass().getName());
        if (null == map2) {
          map2=new HashMap<String,Castor<?,?>>();
          this.map.put(castor.getFromClass().getName(),map2);
        }
        if (!map2.containsKey(castor.getToClass().getName())) {
          Method m=settingMap.get(castor.getClass());
          if (null == m) {
            for (            Entry<Class<?>,Method> entry : settingMap.entrySet()) {
              Class<?> cc=entry.getKey();
              if (cc.isAssignableFrom(klass)) {
                m=settingMap.get(cc);
                break;
              }
            }
          }
          if (null != m)           m.invoke(setting,castor);
          map2.put(castor.getToClass().getName(),castor);
        }
      }
 catch (      Throwable e) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",klass,e.getMessage());
      }
    }
  }
}","private void reload(){
  HashMap<Class<?>,Method> settingMap=new HashMap<Class<?>,Method>();
  for (  Method m1 : setting.getClass().getMethods()) {
    Class<?>[] pts=m1.getParameterTypes();
    if (pts.length == 1 && Castor.class.isAssignableFrom(pts[0]))     settingMap.put(pts[0],m1);
  }
  this.map=new HashMap<String,Map<String,Castor<?,?>>>();
  for (Iterator<Class<?>> it=paths.iterator(); it.hasNext(); ) {
    Class<?> baseClass=it.next();
    if (baseClass == null)     continue;
    List<Class<?>> list=Scans.me().scanPackage(baseClass);
    if (null == list || list.size() == 0)     continue;
    for (    Class<?> klass : list) {
      try {
        if (Modifier.isAbstract(klass.getModifiers()))         continue;
        if (!Castor.class.isAssignableFrom(klass))         continue;
        Castor<?,?> castor=(Castor<?,?>)klass.newInstance();
        Map<String,Castor<?,?>> map2=this.map.get(castor.getFromClass().getName());
        if (null == map2) {
          map2=new HashMap<String,Castor<?,?>>();
          this.map.put(castor.getFromClass().getName(),map2);
        }
        if (!map2.containsKey(castor.getToClass().getName())) {
          Method m=settingMap.get(castor.getClass());
          if (null == m) {
            for (            Entry<Class<?>,Method> entry : settingMap.entrySet()) {
              Class<?> cc=entry.getKey();
              if (cc.isAssignableFrom(klass)) {
                m=settingMap.get(cc);
                break;
              }
            }
          }
          if (null != m)           m.invoke(setting,castor);
          map2.put(castor.getToClass().getName(),castor);
        }
      }
 catch (      Throwable e) {
        if (log.isWarnEnabled())         log.warnf(""String_Node_Str"",klass,e.getMessage());
      }
    }
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",map.size());
  if (map.size() == 0 && log.isErrorEnabled())   log.error(""String_Node_Str"");
}"
80823,"public Class<?> load(String className) throws ClassNotFoundException {
  try {
    return Thread.currentThread().getContextClassLoader().loadClass(className);
  }
 catch (  ClassNotFoundException e) {
    try {
      return ClassLoader.getSystemClassLoader().loadClass(className);
    }
 catch (    ClassNotFoundException e2) {
      try {
        return getParent().loadClass(className);
      }
 catch (      ClassNotFoundException e3) {
      }
    }
  }
  return super.loadClass(className);
}","public Class<?> load(String className) throws ClassNotFoundException {
  try {
    return Thread.currentThread().getContextClassLoader().loadClass(className);
  }
 catch (  ClassNotFoundException e) {
    try {
      return ClassLoader.getSystemClassLoader().loadClass(className);
    }
 catch (    ClassNotFoundException e2) {
      try {
        return getParent().loadClass(className);
      }
 catch (      ClassNotFoundException e3) {
      }
    }
catch (    SecurityException e2) {
      try {
        return getParent().loadClass(className);
      }
 catch (      ClassNotFoundException e3) {
      }
    }
  }
  return super.loadClass(className);
}"
80824,"public SqlNotFoundException(String key,String[] paths){
  super(String.format(""String_Node_Str"",key,Castors.me().castToString(paths)));
}","public SqlNotFoundException(String key){
  super(String.format(""String_Node_Str"",key));
}"
80825,"public void execute(Connection conn) throws DaoException {
  mergeCondition();
  updateCount=-1;
  boolean statIsClosed=false;
  try {
    if (sql.isSELECT()) {
      if (null != callback) {
        Pager pager=context.getPager();
        int rsType=null == pager ? ResultSet.TYPE_FORWARD_ONLY : pager.getResultSetType();
        PreparedStatement stat=null;
        ResultSet rs=null;
        try {
          String sqlStr=sql.toPreparedStatementString();
          stat=conn.prepareStatement(sqlStr,rsType,ResultSet.CONCUR_READ_ONLY);
          adapter.process(stat,sql,entity);
          rs=stat.executeQuery();
          context.setResult(callback.invoke(conn,rs,this));
        }
  finally {
          Daos.safeClose(stat,rs);
        }
      }
    }
 else     if (sql.isUPDATE() || sql.isINSERT() || sql.isDELETE()|| sql.isTRUNCATE()) {
      PreparedStatement stat=null;
      try {
        String sqlStr=sql.toPreparedStatementString();
        stat=conn.prepareStatement(sqlStr);
        adapter.process(stat,sql,entity);
        stat.execute();
        updateCount=stat.getUpdateCount();
        stat.close();
        statIsClosed=true;
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        if (!statIsClosed)         Daos.safeClose(stat);
      }
    }
 else {
      Statement stat=null;
      try {
        stat=conn.createStatement();
        stat.execute(sql.toString());
        stat.close();
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        if (!statIsClosed)         Daos.safeClose(stat);
      }
    }
  }
 catch (  SQLException e) {
    throw new DaoException(format(""String_Node_Str"",sql.toString(),sql.toPreparedStatementString()),e);
  }
}","public void execute(Connection conn) throws DaoException {
  mergeCondition();
  updateCount=-1;
  boolean statIsClosed=false;
  try {
    if (sql.isSELECT()) {
      if (null != callback) {
        Pager pager=context.getPager();
        int rsType=null == pager ? ResultSet.TYPE_FORWARD_ONLY : pager.getResultSetType();
        PreparedStatement stat=null;
        ResultSet rs=null;
        try {
          String sqlStr=sql.toPreparedStatementString();
          if (log.isDebugEnabled())           log.debug(""String_Node_Str"" + sqlStr);
          stat=conn.prepareStatement(sqlStr,rsType,ResultSet.CONCUR_READ_ONLY);
          adapter.process(stat,sql,entity);
          rs=stat.executeQuery();
          context.setResult(callback.invoke(conn,rs,this));
        }
  finally {
          Daos.safeClose(stat,rs);
        }
      }
    }
 else     if (sql.isUPDATE() || sql.isINSERT() || sql.isDELETE()|| sql.isTRUNCATE()) {
      PreparedStatement stat=null;
      try {
        String sqlStr=sql.toPreparedStatementString();
        if (log.isDebugEnabled())         log.debug(""String_Node_Str"" + sqlStr);
        stat=conn.prepareStatement(sqlStr);
        adapter.process(stat,sql,entity);
        stat.execute();
        updateCount=stat.getUpdateCount();
        stat.close();
        statIsClosed=true;
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        if (!statIsClosed)         Daos.safeClose(stat);
      }
    }
 else {
      Statement stat=null;
      try {
        stat=conn.createStatement();
        stat.execute(sql.toString());
        stat.close();
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        if (!statIsClosed)         Daos.safeClose(stat);
      }
    }
  }
 catch (  SQLException e) {
    throw new DaoException(format(""String_Node_Str"",sql.toString(),sql.toPreparedStatementString()),e);
  }
}"
80826,"int _deleteSelf(Entity<?> entity,Object obj){
  if (null != obj) {
    EntityField idnf=entity.getIdentifiedField();
    if (null == idnf) {
      Object[] args=evalArgsByPks(entity,obj);
      if (null != args) {
        Sql sql=sqlMaker.deletex(entity,args);
        execute(sql);
        return sql.getUpdateCount();
      }
      throw DaoException.create(obj,""String_Node_Str"",""String_Node_Str"",null);
    }
    if (idnf.isId()) {
      int id=Castors.me().castTo(idnf.getValue(obj),Integer.class);
      return delete(obj.getClass(),id);
    }
 else     if (idnf.isName()) {
      String name=idnf.getValue(obj).toString();
      return delete(obj.getClass(),name);
    }
 else {
      throw DaoException.create(obj,""String_Node_Str"",""String_Node_Str"",new Exception(""String_Node_Str""));
    }
  }
  return 0;
}","int _deleteSelf(Entity<?> entity,Object obj){
  if (null != obj) {
    EntityField idnf=entity.getIdentifiedField();
    if (null == idnf) {
      Object[] args=evalArgsByPks(entity,obj);
      if (null != args) {
        Sql sql=sqlMaker.deletex(entity,args);
        execute(sql);
        return sql.getUpdateCount();
      }
      throw DaoException.create(obj,""String_Node_Str"",""String_Node_Str"",null);
    }
    if (idnf.isId()) {
      long id=Castors.me().castTo(idnf.getValue(obj),Long.class);
      return delete(obj.getClass(),id);
    }
 else     if (idnf.isName()) {
      String name=idnf.getValue(obj).toString();
      return delete(obj.getClass(),name);
    }
 else {
      throw DaoException.create(obj,""String_Node_Str"",""String_Node_Str"",new Exception(""String_Node_Str""));
    }
  }
  return 0;
}"
80827,"public static String encode(Object s){
  if (null == s)   return ""String_Node_Str"";
  try {
    return new String(s.toString().getBytes(),Encoding.CHARSET_UTF8.name());
  }
 catch (  UnsupportedEncodingException e) {
    throw Lang.wrapThrow(e);
  }
}","public static String encode(Object s){
  if (null == s)   return ""String_Node_Str"";
  try {
    return URLEncoder.encode(s.toString(),Encoding.CHARSET_UTF8.name());
  }
 catch (  UnsupportedEncodingException e) {
    throw Lang.wrapThrow(e);
  }
}"
80828,"@SuppressWarnings(""String_Node_Str"") public <T>T get(Class<T> classOfT,IocMaking ing){
  Object obj=weaver.weave(ing);
  if (null != fetch)   fetch.trigger(obj);
  return (T)obj;
}","@SuppressWarnings(""String_Node_Str"") public <T>T get(Class<T> classOfT,IocMaking ing){
  Object re;
  if (null != obj)   re=obj;
 else   if (null != weaver)   re=weaver.fill(ing,weaver.born(ing));
 else   throw Lang.makeThrow(""String_Node_Str"",ing.getObjectName());
  if (null != fetch)   fetch.trigger(re);
  return (T)re;
}"
80829,"public void depose(){
  weaver.depose();
}","public void depose(){
  if (null != obj && null != depose)   depose.trigger(obj);
}"
80830,"public ObjectProxy make(IocMaking ing,IocObject iobj){
  Mirror<?> mirror=ing.getMirrors().getMirror(iobj.getType(),ing.getObjectName());
  ObjectProxy op=new ObjectProxy();
  if (iobj.isSingleton() && null != ing.getObjectName())   ing.getContext().save(iobj.getScope(),ing.getObjectName(),op);
  try {
    DynamicWeaver dw;
    if (iobj.isSingleton())     dw=new StaticWeaver();
 else     dw=new DynamicWeaver();
    if (null != iobj.getEvents()) {
      IocEventSet iocEventSet=iobj.getEvents();
      op.setFetch(createTrigger(mirror,iocEventSet.getFetch()));
      dw.setCreate(createTrigger(mirror,iocEventSet.getCreate()));
      dw.setDepose(createTrigger(mirror,iocEventSet.getDepose()));
    }
    ValueProxy[] vps=new ValueProxy[Lang.length(iobj.getArgs())];
    for (int i=0; i < vps.length; i++)     vps[i]=ing.makeValue(iobj.getArgs()[i]);
    dw.setArgs(vps);
    Object[] args=new Object[vps.length];
    for (int i=0; i < args.length; i++)     args[i]=vps[i].get(ing);
    dw.setBorning((Borning<?>)mirror.getBorning(args));
    FieldInjector[] fields=new FieldInjector[iobj.getFields().length];
    for (int i=0; i < fields.length; i++) {
      IocField ifld=iobj.getFields()[i];
      try {
        ValueProxy vp=ing.makeValue(ifld.getValue());
        fields[i]=FieldInjector.create(mirror,ifld.getName(),vp);
      }
 catch (      Exception e) {
        throw Lang.wrapThrow(e,""String_Node_Str"",ifld.getName());
      }
    }
    dw.setFields(fields);
    op.setWeaver(dw);
  }
 catch (  Throwable e) {
    ing.getContext().remove(iobj.getScope(),ing.getObjectName());
    throw Lang.wrapThrow(e);
  }
  return op;
}","public ObjectProxy make(IocMaking ing,IocObject iobj){
  Mirror<?> mirror=ing.getMirrors().getMirror(iobj.getType(),ing.getObjectName());
  IocEventSet iocEventSet=iobj.getEvents();
  ObjectProxy op=new ObjectProxy();
  if (iobj.isSingleton() && null != ing.getObjectName())   ing.getContext().save(iobj.getScope(),ing.getObjectName(),op);
  if (null != iobj.getEvents()) {
    op.setFetch(createTrigger(mirror,iocEventSet.getFetch()));
    op.setDepose(createTrigger(mirror,iocEventSet.getDepose()));
  }
  try {
    DefaultWeaver dw=new DefaultWeaver();
    op.setWeaver(dw);
    if (null != iobj.getEvents()) {
      dw.setCreate(createTrigger(mirror,iocEventSet.getCreate()));
    }
    ValueProxy[] vps=new ValueProxy[Lang.length(iobj.getArgs())];
    for (int i=0; i < vps.length; i++)     vps[i]=ing.makeValue(iobj.getArgs()[i]);
    dw.setArgs(vps);
    Object[] args=new Object[vps.length];
    for (int i=0; i < args.length; i++)     args[i]=vps[i].get(ing);
    dw.setBorning((Borning<?>)mirror.getBorning(args));
    Object obj=null;
    if (iobj.isSingleton()) {
      obj=dw.born(ing);
      op.setObj(obj);
    }
    FieldInjector[] fields=new FieldInjector[iobj.getFields().length];
    for (int i=0; i < fields.length; i++) {
      IocField ifld=iobj.getFields()[i];
      try {
        ValueProxy vp=ing.makeValue(ifld.getValue());
        fields[i]=FieldInjector.create(mirror,ifld.getName(),vp);
      }
 catch (      Exception e) {
        throw Lang.wrapThrow(e,""String_Node_Str"",ifld.getName());
      }
    }
    dw.setFields(fields);
    if (null != obj)     dw.fill(ing,obj);
  }
 catch (  Throwable e) {
    ing.getContext().remove(iobj.getScope(),ing.getObjectName());
    throw Lang.wrapThrow(e);
  }
  return op;
}"
80831,"public ObjectProxy fetch(String name){
  Object re=req.getAttribute(name);
  if (re == null)   return null;
  if (re instanceof ObjectProxy)   return (ObjectProxy)re;
  ObjectProxy op=new ObjectProxy();
  StaticWeaver staticWeaver=new StaticWeaver();
  staticWeaver.setObj(re);
  op.setWeaver(staticWeaver);
  return op;
}","public ObjectProxy fetch(String name){
  Object re=req.getAttribute(name);
  if (re == null)   return null;
  if (re instanceof ObjectProxy)   return (ObjectProxy)re;
  return new ObjectProxy().setObj(re);
}"
80832,"public ObjectProxy fetch(String name){
  Object re=session.getAttribute(name);
  if (re == null)   return null;
  if (re instanceof ObjectProxy)   return (ObjectProxy)re;
  ObjectProxy op=new ObjectProxy();
  StaticWeaver staticWeaver=new StaticWeaver();
  staticWeaver.setObj(re);
  op.setWeaver(staticWeaver);
  return op;
}","public ObjectProxy fetch(String name){
  Object re=session.getAttribute(name);
  if (re == null)   return null;
  if (re instanceof ObjectProxy)   return (ObjectProxy)re;
  return new ObjectProxy().setObj(re);
}"
80833,"@Override public Number cast(String src,Class<?> toType,String... args){
  try {
    return (Number)Mirror.me(toType).getWrapperClass().getConstructor(String.class).newInstance(Strings.isBlank(src) ? ""String_Node_Str"" : src);
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
}","@Override public Number cast(String src,Class<?> toType,String... args){
  if (Strings.isBlank(src)) {
    if (toType.isPrimitive())     return 0;
 else     return null;
  }
  try {
    return (Number)Mirror.me(toType).getWrapperClass().getConstructor(String.class).newInstance(src);
  }
 catch (  Exception e) {
    throw new FailToCastObjectException(String.format(""String_Node_Str"",src,toType.getName()),e);
  }
}"
80834,"/** 
 * @param req 请求对象
 * @param resp 响应对象
 * @param refer 这个参考字段，如果有值，表示是路径参数的值，那么它比 request 里的参数优先
 * @return 注入值
 */
public Object get(HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null != refer)   return Castors.me().castTo(refer,type);
  return Castors.me().castTo(req.getParameter(name),type);
}","/** 
 * @param req 请求对象
 * @param resp 响应对象
 * @param refer 这个参考字段，如果有值，表示是路径参数的值，那么它比 request 里的参数优先
 * @return 注入值
 */
public Object get(HttpServletRequest req,HttpServletResponse resp,Object refer){
  if (null != refer)   return Castors.me().castTo(refer,type);
  String[] params=req.getParameterValues(name);
  return Castors.me().castTo(params,type);
}"
80835,"@SuppressWarnings(""String_Node_Str"") public <T>Mirror<T> getMirror(Class<T> type,String name){
  if (MethodInterceptor.class.isAssignableFrom(type))   return Mirror.me(type);
  if (type.getName().endsWith(ClassAgent.CLASSNAME_SUFFIX))   return Mirror.me(type);
  if (AopConfigration.IOCNAME.equals(name))   return Mirror.me(type);
  try {
    return (Mirror<T>)Mirror.me(cd.load(type.getName() + ClassAgent.CLASSNAME_SUFFIX));
  }
 catch (  ClassNotFoundException e) {
  }
  if (aopConfigration == null)   if (ioc.has(AopConfigration.IOCNAME))   aopConfigration=ioc.get(AopConfigration.class,AopConfigration.IOCNAME);
 else   aopConfigration=new AnnotationAopConfigration();
  List<InterceptorPair> interceptorPairs=aopConfigration.getInterceptorPairList(ioc,type);
  if (interceptorPairs == null || interceptorPairs.size() < 1)   return Mirror.me(type);
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  return Mirror.me(agent.define(cd,type));
}","@SuppressWarnings(""String_Node_Str"") public <T>Mirror<T> getMirror(Class<T> type,String name){
  if (MethodInterceptor.class.isAssignableFrom(type))   return Mirror.me(type);
  if (type.getName().endsWith(ClassAgent.CLASSNAME_SUFFIX))   return Mirror.me(type);
  if (AopConfigration.IOCNAME.equals(name))   return Mirror.me(type);
  if (AopConfigration.class.isAssignableFrom(type))   return Mirror.me(type);
  try {
    return (Mirror<T>)Mirror.me(cd.load(type.getName() + ClassAgent.CLASSNAME_SUFFIX));
  }
 catch (  ClassNotFoundException e) {
  }
  if (aopConfigration == null)   if (ioc.has(AopConfigration.IOCNAME))   aopConfigration=ioc.get(AopConfigration.class,AopConfigration.IOCNAME);
 else   aopConfigration=new AnnotationAopConfigration();
  List<InterceptorPair> interceptorPairs=aopConfigration.getInterceptorPairList(ioc,type);
  if (interceptorPairs == null || interceptorPairs.size() < 1)   return Mirror.me(type);
  ClassAgent agent=new AsmClassAgent();
  for (  InterceptorPair interceptorPair : interceptorPairs)   agent.addInterceptor(interceptorPair.getMethodMatcher(),interceptorPair.getMethodInterceptor());
  return Mirror.me(agent.define(cd,type));
}"
80836,"public Map<String,Object> parse(HttpServletRequest req,String charset,FilePool tmps) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  NutMap params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes firstBoundaryBytes=RemountBytes.create(firstBoundary);
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes itemEndlBytes=RemountBytes.create(itemEndl);
  RemountBytes nameEndlBytes=RemountBytes.create(""String_Node_Str"");
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  try {
    FieldMeta meta;
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString(charset);
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            do {
              info.current=br.load();
              mm=br.mark(itemEndlBytes);
              assertStreamNotEnd(mm);
              br.dump(ops);
            }
 while (mm == MarkMode.NOT_FOUND);
          }
  finally {
            Streams.safeFlush(ops);
            Streams.safeClose(ops);
          }
          params.add(meta.getName(),new TempFile(meta,tmp));
        }
      }
 else {
        StringBuilder sb=new StringBuilder();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          sb.append(br.dumpAsString(charset));
        }
 while (mm == MarkMode.NOT_FOUND);
        params.add(meta.getName(),sb.toString());
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",meta.getName(),sb.toString());
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}","public Map<String,Object> parse(HttpServletRequest req,UploadingContext context) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  int bufferSize=context.getBufferSize();
  String charset=context.getCharset();
  FilePool tmps=context.getFilePool();
  int maxFileSize=context.getMaxFileSize();
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  NutMap params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes firstBoundaryBytes=RemountBytes.create(firstBoundary);
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes itemEndlBytes=RemountBytes.create(itemEndl);
  RemountBytes nameEndlBytes=RemountBytes.create(""String_Node_Str"");
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  try {
    FieldMeta meta;
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString(charset);
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (!context.isNameAccepted(meta.getFileLocalName())) {
          throw new UploadUnsupportedFileNameException(meta);
        }
        if (!context.isContentTypeAccepted(meta.getContentType())) {
          throw new UploadUnsupportedFileTypeException(meta);
        }
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            if (maxFileSize > 0) {
              long maxPos=info.current + maxFileSize;
              do {
                info.current=br.load();
                mm=br.mark(itemEndlBytes);
                assertStreamNotEnd(mm);
                if (mm != MarkMode.FOUND && info.current > maxPos) {
                  throw new UploadOutOfSizeException(meta);
                }
                br.dump(ops);
              }
 while (mm == MarkMode.NOT_FOUND);
            }
 else {
              do {
                info.current=br.load();
                mm=br.mark(itemEndlBytes);
                assertStreamNotEnd(mm);
                br.dump(ops);
              }
 while (mm == MarkMode.NOT_FOUND);
            }
          }
  finally {
            Streams.safeFlush(ops);
            Streams.safeClose(ops);
          }
          if (context.isIgnoreNull() && tmp.length() == 0) {
          }
 else {
            params.add(meta.getName(),new TempFile(meta,tmp));
          }
        }
      }
 else {
        StringBuilder sb=new StringBuilder();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          sb.append(br.dumpAsString(charset));
        }
 while (mm == MarkMode.NOT_FOUND);
        params.add(meta.getName(),sb.toString());
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",meta.getName(),sb.toString());
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}"
80837,"public Map<String,Object> parse(HttpServletRequest req,String charset,FilePool tmps) throws UploadException {
  UploadInfo info=Uploads.createInfo(req);
  StreamBuffer sb=null;
  InputStream ins=null;
  try {
    Map<String,Object> params=Uploads.createParamsMap(req);
    ins=req.getInputStream();
    if (!(ins instanceof BufferedInputStream)) {
      if (bufferSize > 0)       ins=new BufferedInputStream(ins,bufferSize);
 else       ins=new BufferedInputStream(ins);
    }
    String contentType=req.getContentType();
    String s=""String_Node_Str"" + Http.multipart.getBoundary(contentType);
    char[] endValue=s.toCharArray();
    int[] right=new int[endValue.length];
    int cursor;
    int c=0;
    for (int i=0; i < s.length(); i++) {
      c=ins.read();
      info.current++;
    }
    while (c != -1) {
      cursor=0;
      right[cursor++]=ins.read();
      info.current++;
      if (right[0] == -1) {
        right[cursor++]=-1;
      }
 else {
        right[cursor++]=ins.read();
        info.current++;
      }
      if (right[1] == -1 || (right[0] == '-' && right[1] == '-'))       break;
      sb=new StreamBuffer();
      while (cursor < endName.length) {
        c=ins.read();
        if (c == -1)         break;
        info.current++;
        if (c == endName[cursor]) {
          right[cursor++]=c;
        }
 else {
          if (cursor > 0) {
            for (int i=0; i < cursor; i++)             sb.write(right[i]);
          }
          sb.write(c);
          cursor=0;
        }
      }
      FieldMeta meta=new FieldMeta(sb.toString(charset));
      cursor=0;
      if (meta.isFile()) {
        File tmp=null;
        OutputStream ots;
        if (Strings.isBlank(meta.getFileLocalPath())) {
          ots=new StringOutputStream(new StringBuilder());
        }
 else {
          tmp=tmps.createFile(meta.getFileExtension());
          ots=new BufferedOutputStream(new FileOutputStream(tmp));
        }
        while (c != -1 && cursor < endValue.length) {
          c=ins.read();
          info.current++;
          if (c == endValue[cursor]) {
            right[cursor++]=c;
          }
 else {
            if (cursor > 0) {
              for (int i=0; i < cursor; i++)               ots.write(right[i]);
            }
            ots.write(c);
            cursor=0;
          }
        }
        Streams.safeClose(ots);
        if (null != tmp && !Strings.isBlank(meta.getFileLocalPath()) && tmp.length() > 0)         params.put(meta.getName(),new TempFile(meta,tmp));
      }
 else {
        sb=new StreamBuffer();
        while (c != -1 && cursor < endValue.length) {
          c=ins.read();
          info.current++;
          if (c == endValue[cursor]) {
            right[cursor++]=c;
          }
 else {
            if (cursor > 0) {
              for (int i=0; i < cursor; i++)               sb.write(right[i]);
            }
            sb.write(c);
            cursor=0;
          }
        }
        params.put(meta.getName(),sb.toString(charset));
      }
    }
    return params;
  }
 catch (  IOException e) {
    throw new UploadException(e);
  }
 finally {
    Streams.safeClose(ins);
    Streams.safeClose(sb);
    if (null != req.getSession())     req.getSession().removeAttribute(UploadInfo.class.getName());
  }
}","public Map<String,Object> parse(HttpServletRequest req,UploadingContext context) throws UploadException {
  String charset=context.getCharset();
  FilePool tmps=context.getFilePool();
  UploadInfo info=Uploads.createInfo(req);
  StreamBuffer sb=null;
  InputStream ins=null;
  try {
    Map<String,Object> params=Uploads.createParamsMap(req);
    ins=req.getInputStream();
    if (!(ins instanceof BufferedInputStream)) {
      if (bufferSize > 0)       ins=new BufferedInputStream(ins,bufferSize);
 else       ins=new BufferedInputStream(ins);
    }
    String contentType=req.getContentType();
    String s=""String_Node_Str"" + Http.multipart.getBoundary(contentType);
    char[] endValue=s.toCharArray();
    int[] right=new int[endValue.length];
    int cursor;
    int c=0;
    for (int i=0; i < s.length(); i++) {
      c=ins.read();
      info.current++;
    }
    while (c != -1) {
      cursor=0;
      right[cursor++]=ins.read();
      info.current++;
      if (right[0] == -1) {
        right[cursor++]=-1;
      }
 else {
        right[cursor++]=ins.read();
        info.current++;
      }
      if (right[1] == -1 || (right[0] == '-' && right[1] == '-'))       break;
      sb=new StreamBuffer();
      while (cursor < endName.length) {
        c=ins.read();
        if (c == -1)         break;
        info.current++;
        if (c == endName[cursor]) {
          right[cursor++]=c;
        }
 else {
          if (cursor > 0) {
            for (int i=0; i < cursor; i++)             sb.write(right[i]);
          }
          sb.write(c);
          cursor=0;
        }
      }
      FieldMeta meta=new FieldMeta(sb.toString(charset));
      cursor=0;
      if (meta.isFile()) {
        File tmp=null;
        OutputStream ots;
        if (Strings.isBlank(meta.getFileLocalPath())) {
          ots=new StringOutputStream(new StringBuilder());
        }
 else {
          tmp=tmps.createFile(meta.getFileExtension());
          ots=new BufferedOutputStream(new FileOutputStream(tmp));
        }
        while (c != -1 && cursor < endValue.length) {
          c=ins.read();
          info.current++;
          if (c == endValue[cursor]) {
            right[cursor++]=c;
          }
 else {
            if (cursor > 0) {
              for (int i=0; i < cursor; i++)               ots.write(right[i]);
            }
            ots.write(c);
            cursor=0;
          }
        }
        Streams.safeClose(ots);
        if (null != tmp && !Strings.isBlank(meta.getFileLocalPath()) && tmp.length() > 0)         params.put(meta.getName(),new TempFile(meta,tmp));
      }
 else {
        sb=new StreamBuffer();
        while (c != -1 && cursor < endValue.length) {
          c=ins.read();
          info.current++;
          if (c == endValue[cursor]) {
            right[cursor++]=c;
          }
 else {
            if (cursor > 0) {
              for (int i=0; i < cursor; i++)               sb.write(right[i]);
            }
            sb.write(c);
            cursor=0;
          }
        }
        params.put(meta.getName(),sb.toString(charset));
      }
    }
    return params;
  }
 catch (  IOException e) {
    throw new UploadException(e);
  }
 finally {
    Streams.safeClose(ins);
    Streams.safeClose(sb);
    if (null != req.getSession())     req.getSession().removeAttribute(UploadInfo.class.getName());
  }
}"
80838,"public UploadAdaptor(String path,int buffer,String charset,int poolSize){
  this.charset=charset;
  this.pool=new NutFilePool(path,poolSize);
  this.buffer=buffer;
}","public UploadAdaptor(String path,int buffer,String charset,int poolSize){
  context=new UploadingContext();
  context.setBufferSize(buffer);
  context.setCharset(charset);
  context.setFilePool(new NutFilePool(path,poolSize));
}"
80839,"public Object[] adapt(HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  Map<String,Object> map;
  try {
    Uploading ing=new FastUploading(buffer);
    map=ing.parse(request,charset,pool);
  }
 catch (  UploadException e) {
    throw Lang.wrapThrow(e);
  }
  Object[] args=new Object[injs.length];
  int i=fillPathArgs(request,response,pathArgs,args);
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(request,response,map);
  }
  return args;
}","public Object[] adapt(HttpServletRequest request,HttpServletResponse response,String[] pathArgs){
  Map<String,Object> map;
  try {
    Uploading ing=new FastUploading();
    map=ing.parse(request,context);
  }
 catch (  UploadException e) {
    throw Lang.wrapThrow(e);
  }
  Object[] args=new Object[injs.length];
  int i=fillPathArgs(request,response,pathArgs,args);
  for (; i < injs.length; i++) {
    args[i]=injs[i].get(request,response,map);
  }
  return args;
}"
80840,"/** 
 * 对流的解析
 * @param req
 * @param charset
 * @param tmps
 * @throws UploadException
 */
Map<String,Object> parse(HttpServletRequest req,String charset,FilePool tmps) throws UploadException ;","/** 
 * 对流的解析
 * @param req
 * @param charset
 * @param tmps
 * @throws UploadException
 * @throws UploadOutOfSizeException
 * @throws UploadUnsupportedFileNameException
 * @throws UploadUnsupportedFileTypeException
 */
Map<String,Object> parse(HttpServletRequest req,UploadingContext context) throws UploadException, UploadOutOfSizeException, UploadUnsupportedFileNameException, UploadUnsupportedFileTypeException ;"
80841,"public void invoke(HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  try {
    req.setCharacterEncoding(inputCharset);
  }
 catch (  UnsupportedEncodingException e) {
    logException(e);
    throw Lang.wrapThrow(e);
  }
  resp.setCharacterEncoding(outputCharset);
  if (null != filters)   for (  ActionFilter filter : filters) {
    View view=filter.match(req,method);
    if (null != view) {
      try {
        view.render(req,resp,null);
      }
 catch (      Throwable e) {
        logException(e);
        throw Lang.wrapThrow(e);
      }
      return;
    }
  }
  RequestIocContext reqContext=null;
  try {
    Object[] args=adaptor.adapt(req,resp,pathArgs);
    Object obj;
    if (null != module) {
      obj=module;
    }
 else {
      Ioc ioc=Mvcs.getIoc(req);
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",moduleName);
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(req);
        SessionIocContext sessionContext=new SessionIocContext(req.getSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        obj=((Ioc2)ioc).get(moduleType,moduleName,myContext);
      }
 else       obj=ioc.get(moduleType,moduleName);
    }
    Object re=method.invoke(obj,args);
    if (re instanceof View)     ((View)re).render(req,resp,re);
 else     ok.render(req,resp,re);
  }
 catch (  Throwable e) {
    if (e instanceof InvocationTargetException && e.getCause() != null)     e=e.getCause();
    if (log.isDebugEnabled())     logException(e);
    try {
      fail.render(req,resp,e);
    }
 catch (    Throwable e1) {
      logException(e1);
      resp.reset();
      try {
        resp.getWriter().write(e1.getMessage());
        resp.flushBuffer();
      }
 catch (      IOException e2) {
        logException(e2);
        throw Lang.wrapThrow(e2);
      }
    }
  }
 finally {
    if (null != reqContext)     reqContext.depose();
  }
}","public void invoke(HttpServletRequest req,HttpServletResponse resp,String[] pathArgs){
  try {
    req.setCharacterEncoding(inputCharset);
  }
 catch (  UnsupportedEncodingException e) {
    logException(e);
    throw Lang.wrapThrow(e);
  }
  resp.setCharacterEncoding(outputCharset);
  if (null != filters)   for (  ActionFilter filter : filters) {
    View view=filter.match(req,method);
    if (null != view) {
      try {
        view.render(req,resp,null);
      }
 catch (      Throwable e) {
        logException(e);
        throw Lang.wrapThrow(e);
      }
      return;
    }
  }
  RequestIocContext reqContext=null;
  try {
    Object[] args=adaptor.adapt(req,resp,pathArgs);
    Object obj;
    if (null != module) {
      obj=module;
    }
 else {
      Ioc ioc=Mvcs.getIoc(req);
      if (null == ioc)       throw Lang.makeThrow(""String_Node_Str"",moduleName);
      if (ioc instanceof Ioc2) {
        reqContext=new RequestIocContext(req);
        SessionIocContext sessionContext=new SessionIocContext(req.getSession());
        IocContext myContext=new ComboContext(reqContext,sessionContext);
        obj=((Ioc2)ioc).get(moduleType,moduleName,myContext);
      }
 else       obj=ioc.get(moduleType,moduleName);
    }
    Object re=method.invoke(obj,args);
    if (re instanceof View)     ((View)re).render(req,resp,null);
 else     ok.render(req,resp,re);
  }
 catch (  Throwable e) {
    if (e instanceof InvocationTargetException && e.getCause() != null)     e=e.getCause();
    if (log.isDebugEnabled())     logException(e);
    try {
      fail.render(req,resp,e);
    }
 catch (    Throwable e1) {
      logException(e1);
      resp.reset();
      try {
        resp.getWriter().write(e1.getMessage());
        resp.flushBuffer();
      }
 catch (      IOException e2) {
        logException(e2);
        throw Lang.wrapThrow(e2);
      }
    }
  }
 finally {
    if (null != reqContext)     reqContext.depose();
  }
}"
80842,"public static String encode(Object s){
  if (null == s)   return ""String_Node_Str"";
  try {
    return new String(Encoding.CHARSET_UTF8.encode(s.toString()).array(),Encoding.CHARSET_UTF8.name());
  }
 catch (  UnsupportedEncodingException e) {
    throw Lang.wrapThrow(e);
  }
}","public static String encode(Object s){
  if (null == s)   return ""String_Node_Str"";
  try {
    return new String(s.toString().getBytes(),Encoding.CHARSET_UTF8.name());
  }
 catch (  UnsupportedEncodingException e) {
    throw Lang.wrapThrow(e);
  }
}"
80843,"/** 
 * 将数据写入文件,成功就返回true,失败就返回false
 * @param file 需要写入的文件
 * @param data 需要写入的数据
 * @return true 如果写入成功
 */
public static boolean write(File file,byte data[]){
  try {
    FileOutputStream fos=new FileOutputStream(file);
    fos.write(data);
    fos.flush();
    fos.close();
  }
 catch (  Throwable e) {
    return false;
  }
  return true;
}","/** 
 * 将内容写到一个文件内，内容对象可以是： <ul> <li>InputStream - 按二进制方式写入 <li>byte[] - 按二进制方式写入 <li>Reader - 按 UTF-8 方式写入 <li>其他对象被 toString() 后按照 UTF-8 方式写入 </ul>
 * @param f 文件
 * @param obj 内容
 */
public static void write(File f,Object obj){
  if (null == f || null == obj)   return;
  if (f.isDirectory())   throw Lang.makeThrow(""String_Node_Str"",f);
  try {
    if (!f.exists())     Files.createNewFile(f);
    if (obj instanceof InputStream) {
      Streams.writeAndClose(Streams.fileOut(f),(InputStream)obj);
    }
 else     if (obj instanceof byte[]) {
      Streams.writeAndClose(Streams.fileOut(f),(byte[])obj);
    }
 else     if (obj instanceof Reader) {
      Streams.writeAndClose(Streams.fileOutw(f),(Reader)obj);
    }
 else {
      Streams.writeAndClose(Streams.fileOutw(f),obj.toString());
    }
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
}"
80844,"/** 
 * 将一段文本全部写入一个输出流
 * @param ops 输出流
 * @param cs 文本
 * @throws IOException
 */
public static void write(OutputStream ops,CharSequence cs) throws IOException {
  if (null != cs && null != ops)   ops.write(cs.toString().getBytes());
}","/** 
 * 将一个字节数组写入一个输出流。 <p> <b style=color:red>注意</b>，它并不会关闭输出流
 * @param ops 输出流
 * @param bytes 字节数组
 * @throws IOException
 */
public static void write(OutputStream ops,byte[] bytes) throws IOException {
  if (null == ops || null == bytes)   return;
  ops.write(bytes);
}"
80845,"public void setProductName(String productName){
  this.productName=productName;
  String proName=productName.toLowerCase();
  if (""String_Node_Str"".equals(proName)) {
    type=DB.H2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.PSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.MYSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.ORACLE;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.DB2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.SQLSERVER;
  }
 else {
    type=DB.OTHER;
  }
}","public void setProductName(String productName){
  this.productName=productName;
  String proName=productName.toLowerCase();
  if (""String_Node_Str"".equals(proName)) {
    type=DB.H2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.PSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.MYSQL;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.ORACLE;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.DB2;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.SQLSERVER;
  }
 else   if (proName.startsWith(""String_Node_Str"")) {
    type=DB.SQLITE;
  }
 else {
    type=DB.OTHER;
  }
}"
80846,"public Pager make(DatabaseMeta meta,int pageNumber,int pageSize){
  if (pageNumber < 1 || pageSize <= 0)   return null;
  Pager pager;
  if (meta.isMySql() || meta.isH2()) {
    pager=new MysqlPager();
  }
 else   if (meta.isPostgresql()) {
    pager=new PostgresqlPager();
  }
 else   if (meta.isOracle()) {
    pager=new OraclePager();
  }
 else   if (meta.isSqlServer()) {
    if (meta.getVersion().contains(""String_Node_Str""))     pager=new SqlServer2000Pager();
 else     pager=new SqlServer2005Pager();
  }
 else   if (meta.isDB2()) {
    pager=new DB2Pager();
  }
 else {
    pager=new OtherPager();
  }
  pager.setPageNumber(pageNumber);
  pager.setPageSize(pageSize);
  return pager;
}","public Pager make(DatabaseMeta meta,int pageNumber,int pageSize){
  if (pageNumber < 1 || pageSize <= 0)   return null;
  Pager pager;
  if (meta.isMySql() || meta.isH2() || meta.isSQLite()) {
    pager=new MysqlPager();
  }
 else   if (meta.isPostgresql()) {
    pager=new PostgresqlPager();
  }
 else   if (meta.isOracle()) {
    pager=new OraclePager();
  }
 else   if (meta.isSqlServer()) {
    if (meta.getVersion().contains(""String_Node_Str""))     pager=new SqlServer2000Pager();
 else     pager=new SqlServer2005Pager();
  }
 else   if (meta.isDB2()) {
    pager=new DB2Pager();
  }
 else {
    pager=new OtherPager();
  }
  pager.setPageNumber(pageNumber);
  pager.setPageSize(pageSize);
  return pager;
}"
80847,"public void invoke(int i,Object ele,int length) throws ExitLoop, LoopException {
  sb.append(Sqls.formatFieldValue(ele)).append(',');
}","public void invoke(int i,Object ele,int length) throws ExitLoop, LoopException {
  sb.append(Sqls.formatSqlFieldValue(ele)).append(',');
}"
80848,"public void render(final StringBuilder sb,Entity<?> en){
  if (null != en) {
    EntityField ef=en.getField(name);
    sb.append(null != ef ? ef.getColumnName() : name);
  }
 else   sb.append(name);
  if (""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"");
    if (null == value)     throw Lang.makeThrow(""String_Node_Str"",sb);
    if (value instanceof Collection<?> || value.getClass().isArray()) {
      sb.append('(');
      Lang.each(value,new Each<Object>(){
        public void invoke(        int i,        Object ele,        int length) throws ExitLoop, LoopException {
          sb.append(Sqls.formatFieldValue(ele)).append(',');
        }
      }
);
      sb.setCharAt(sb.length() - 1,')');
    }
 else     sb.append(Sqls.formatFieldValue(value));
  }
 else   if (null == value && ""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    sb.append(' ').append(op).append(' ').append(Sqls.formatFieldValue(value));
  }
 else {
    sb.append(op).append(Sqls.formatFieldValue(value));
  }
}","public void render(final StringBuilder sb,Entity<?> en){
  if (null != en) {
    EntityField ef=en.getField(name);
    sb.append(null != ef ? ef.getColumnName() : name);
  }
 else   sb.append(name);
  if (""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"");
    if (null == value)     throw Lang.makeThrow(""String_Node_Str"",sb);
    if (value instanceof Collection<?> || value.getClass().isArray()) {
      sb.append('(');
      Lang.each(value,new Each<Object>(){
        public void invoke(        int i,        Object ele,        int length) throws ExitLoop, LoopException {
          sb.append(Sqls.formatSqlFieldValue(ele)).append(',');
        }
      }
);
      sb.setCharAt(sb.length() - 1,')');
    }
 else     sb.append(Sqls.formatSqlFieldValue(value));
  }
 else   if (null == value && ""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    sb.append(' ').append(op).append(' ').append(Sqls.formatSqlFieldValue(value));
  }
 else {
    sb.append(op).append(Sqls.formatSqlFieldValue(value));
  }
}"
80849,"/** 
 * @param v 字段值
 * @return 格式化后的 Sql 字段值，可以直接拼装在 SQL 里面
 */
public static CharSequence formatFieldValue(Object v){
  if (null == v)   return ""String_Node_Str"";
 else   if (Sqls.isNotNeedQuote(v.getClass()))   return Sqls.escapeFieldValue(v.toString());
 else   return new StringBuilder(""String_Node_Str"").append(Sqls.escapeFieldValue(v.toString())).append('\'');
}","/** 
 * 格式化值，根据值的类型，生成 SQL 字段值的部分，它会考虑 SQL 注入
 * @param v 字段值
 * @return 格式化后的 Sql 字段值，可以直接拼装在 SQL 里面
 */
public static CharSequence formatFieldValue(Object v){
  if (null == v)   return ""String_Node_Str"";
 else   if (Sqls.isNotNeedQuote(v.getClass()))   return Sqls.escapeFieldValue(v.toString());
 else   return new StringBuilder(""String_Node_Str"").append(Sqls.escapeFieldValue(v.toString())).append('\'');
}"
80850,"/** 
 * 将 SQL 的 WHERE 条件值进行转意，可以用来防止 SQL 注入攻击
 * @param s 字段值
 * @return 格式化后的 Sql 字段值，可以直接拼装在 SQL 里面
 */
public static CharSequence escapteConditionValue(CharSequence s){
  if (null == s)   return null;
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < s.length(); i++) {
    char c=s.charAt(i);
    if (c == '\'')     sb.append('\'').append('\'');
 else     if (c == '\\')     sb.append('\\').append('\\');
 else     if (c == '_')     sb.append('\\').append(c);
 else     if (c == '%')     sb.append('\\').append(c);
 else     sb.append(c);
  }
  return sb;
}","/** 
 * 将 SQL 的 WHERE 条件值进行转意，可以用来防止 SQL 注入攻击
 * @param s 字段值
 * @return 格式化后的 Sql 字段值，可以直接拼装在 SQL 里面
 */
public static CharSequence escapteConditionValue(CharSequence s){
  if (null == s)   return null;
  return ES_CND_VAL.escape(s);
}"
80851,"/** 
 * 将 SQL 的字段值进行转意，可以用来防止 SQL 注入攻击
 * @param s 字段值
 * @return 格式化后的 Sql 字段值，可以直接拼装在 SQL 里面
 */
public static CharSequence escapeFieldValue(CharSequence s){
  if (null == s)   return null;
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < s.length(); i++) {
    char c=s.charAt(i);
    if (c == '\'')     sb.append('\'').append('\'');
 else     if (c == '\\')     sb.append('\\').append('\\');
 else     sb.append(c);
  }
  return sb;
}","/** 
 * 将 SQL 的字段值进行转意，可以用来防止 SQL 注入攻击
 * @param s 字段值
 * @return 格式化后的 Sql 字段值，可以直接拼装在 SQL 里面
 */
public static CharSequence escapeFieldValue(CharSequence s){
  if (null == s)   return null;
  return ES_FLD_VAL.escape(s);
}"
80852,"public ActionInvoker getInvoker(){
  return invoker;
}","public ActionInvoker getInvoker(){
  return pathInfo.getObj();
}"
80853,"public void invoke(HttpServletRequest req,HttpServletResponse resp){
  invoker.invoke(req,resp,pathArgs);
}","public void invoke(HttpServletRequest req,HttpServletResponse resp){
  getInvoker().invoke(req,resp,pathArgs);
}"
80854,"public ActionInvoking(ActionInvoker invoker,String[] pathArgs){
  this.invoker=invoker;
  this.pathArgs=pathArgs;
}","public ActionInvoking(PathInfo<ActionInvoker> pathInfo,String[] pathArgs){
  this.pathInfo=pathInfo;
  this.pathArgs=pathArgs;
}"
80855,public ActionInvoking get(String path);,"/** 
 * @param path 请求路径
 * @return 调用时
 */
public ActionInvoking get(String path);"
80856,"public int getCursor(){
  return cursor;
}","/** 
 * @return 匹配的步长<ul> <li>-1 - 表示这个路径全部被匹配了 <li>0 - 表示这个路径没有被匹配 <li>>0 - 表示这个路径被一个 * 匹配 </ul>
 */
public int getCursor(){
  return cursor;
}"
80857,"public String getRemain(){
  return remain;
}","/** 
 * @return 路径中未匹配的部分
 */
public String getRemain(){
  return remain;
}"
80858,"PathInfo(int i,String remain,T obj){
  this.cursor=i;
  this.remain=remain;
  this.obj=obj;
}","PathInfo(int i,String path,T obj){
  this.path=path;
  this.cursor=i;
  if (i == -1) {
    this.known=path;
    this.remain=null;
  }
 else   if (i == 0) {
    this.known=null;
    this.remain=path;
  }
 else {
    this.known=path.substring(0,i);
    this.remain=path.substring(i);
  }
  this.obj=obj;
}"
80859,"PathInfo<T> get(String path){
  char[] cs=path.toLowerCase().toCharArray();
  PathNode<T> wild=null;
  PathNode<T> node=this;
  int i=0;
  for (; i < cs.length; i++) {
    if (node.isStar) {
      wild=node;
    }
    char c=cs[i];
    if (null == node.chars)     break;
    int index=Arrays.binarySearch(node.chars,c);
    if (index < 0)     break;
    node=node.children[index];
  }
  if (i == cs.length) {
    return new PathInfo<T>(i,null,node.obj);
  }
 else   if (null != wild && wild.isStar)   return new PathInfo<T>(i,path.substring(i),wild.obj);
  return new PathInfo<T>(0,path,null);
}","PathInfo<T> get(String path){
  char[] cs=path.toLowerCase().toCharArray();
  PathNode<T> wild=null;
  PathNode<T> node=this;
  int i=0;
  for (; i < cs.length; i++) {
    if (node.isStar) {
      wild=node;
    }
    char c=cs[i];
    if (null == node.chars)     break;
    int index=Arrays.binarySearch(node.chars,c);
    if (index < 0)     break;
    node=node.children[index];
  }
  if (i == cs.length) {
    return new PathInfo<T>(-1,path,node.obj);
  }
 else   if (null != wild && wild.isStar)   return new PathInfo<T>(i,path.substring(i),wild.obj);
  return new PathInfo<T>(0,path,null);
}"
80860,"public ActionInvoking get(String path){
  PathInfo<ActionInvoker> info=root.get(path);
  String[] args=Strings.splitIgnoreBlank(info.getRemain(),""String_Node_Str"");
  return new ActionInvoking(info.getObj(),args);
}","public ActionInvoking get(String path){
  PathInfo<ActionInvoker> info=root.get(path);
  String[] args=Strings.splitIgnoreBlank(info.getRemain(),""String_Node_Str"");
  return new ActionInvoking(info,args);
}"
80861,"public JsonFormat(boolean compact){
  this.compact=compact;
  this.indentBy=""String_Node_Str"";
  this.quoteName=true;
  this.castors=Castors.me();
}","public JsonFormat(boolean compact){
  this.compact=compact;
  this.indentBy=""String_Node_Str"";
  this.quoteName=true;
  this.castors=Castors.me();
  this.separator='\""';
}"
80862,"private void string2Json(String s) throws IOException {
  if (null == s)   writer.append(""String_Node_Str"");
 else {
    char[] cs=s.toCharArray();
    writer.append('""');
    for (    char c : cs) {
switch (c) {
case '""':
        writer.append(""String_Node_Str"");
      break;
case '\n':
    writer.append(""String_Node_Str"");
  break;
case '\t':
writer.append(""String_Node_Str"");
break;
case '\r':
writer.append(""String_Node_Str"");
break;
case '\\':
writer.append(""String_Node_Str"");
break;
default :
writer.append(c);
}
}
writer.append('""');
}
}","private void string2Json(String s) throws IOException {
  if (null == s)   writer.append(""String_Node_Str"");
 else {
    char[] cs=s.toCharArray();
    writer.append(format.getSeparator());
    for (    char c : cs) {
switch (c) {
case '""':
        writer.append(""String_Node_Str"");
      break;
case '\n':
    writer.append(""String_Node_Str"");
  break;
case '\t':
writer.append(""String_Node_Str"");
break;
case '\r':
writer.append(""String_Node_Str"");
break;
case '\\':
writer.append(""String_Node_Str"");
break;
default :
writer.append(c);
}
}
writer.append(format.getSeparator());
}
}"
80863,"public Object get(HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object obj=mirror.born();
  for (int i=0; i < injs.length; i++) {
    Injecting inj=injs[i];
    String s=req.getParameter(names[i]);
    if (null == s)     continue;
    if (Strings.isBlank(s))     s=null;
    inj.inject(obj,s);
  }
  return obj;
}","public Object get(HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object obj=mirror.born();
  for (int i=0; i < injs.length; i++) {
    Injecting inj=injs[i];
    String[] ss=req.getParameterValues(names[i]);
    if (null == ss)     continue;
    inj.inject(obj,ss);
  }
  return obj;
}"
80864,"public boolean add(List<ViewMaker> makers,Class<?> moduleType){
  Ok myOk=moduleType.getAnnotation(Ok.class);
  if (null == myOk)   myOk=ok;
  Fail myFail=moduleType.getAnnotation(Fail.class);
  if (null == myFail)   myFail=fail;
  AdaptBy myAb=moduleType.getAnnotation(AdaptBy.class);
  if (null == myAb)   myAb=adaptBy;
  Filters myFlts=moduleType.getAnnotation(Filters.class);
  if (null == myFlts)   myFlts=filters;
  Encoding myEncoding=moduleType.getAnnotation(Encoding.class);
  if (null == myEncoding)   myEncoding=encoding;
  At baseAt=moduleType.getAnnotation(At.class);
  String[] bases;
  if (null == baseAt)   bases=Lang.array(""String_Node_Str"");
 else   if (null == baseAt.value() || baseAt.value().length == 0)   bases=Lang.array(""String_Node_Str"" + moduleType.getSimpleName().toLowerCase());
 else   bases=baseAt.value();
  boolean isModule=false;
  for (  Method method : moduleType.getMethods()) {
    if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))     continue;
    At ats=method.getAnnotation(At.class);
    isModule=true;
    ActionInvoker invoker=new ActionInvokerImpl(context,ioc,makers,moduleType,method,myOk,myFail,myAb,myFlts,myEncoding);
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",method.getName(),Lang.concat(ats.value()));
    for (    String base : bases) {
      String[] paths=ats.value();
      if ((paths.length == 1 && Strings.isBlank(paths[0])) || paths.length == 0) {
        root.add(base + ""String_Node_Str"" + method.getName().toLowerCase(),invoker);
      }
 else {
        for (        String at : paths)         root.add(base + at,invoker);
      }
    }
  }
  return isModule;
}","public boolean add(List<ViewMaker> makers,Class<?> moduleType){
  Ok myOk=moduleType.getAnnotation(Ok.class);
  if (null == myOk)   myOk=ok;
  Fail myFail=moduleType.getAnnotation(Fail.class);
  if (null == myFail)   myFail=fail;
  AdaptBy myAb=moduleType.getAnnotation(AdaptBy.class);
  if (null == myAb)   myAb=adaptBy;
  Filters myFlts=moduleType.getAnnotation(Filters.class);
  if (null == myFlts)   myFlts=filters;
  Encoding myEncoding=moduleType.getAnnotation(Encoding.class);
  if (null == myEncoding)   myEncoding=encoding;
  At baseAt=moduleType.getAnnotation(At.class);
  String[] bases;
  if (null == baseAt)   bases=Lang.array(""String_Node_Str"");
 else   if (null == baseAt.value() || baseAt.value().length == 0)   bases=Lang.array(""String_Node_Str"" + moduleType.getSimpleName().toLowerCase());
 else   bases=baseAt.value();
  boolean isModule=false;
  for (  Method method : moduleType.getMethods()) {
    if (!Modifier.isPublic(method.getModifiers()) || !method.isAnnotationPresent(At.class))     continue;
    At ats=method.getAnnotation(At.class);
    isModule=true;
    ActionInvoker invoker=new ActionInvokerImpl(context,ioc,makers,moduleType,method,myOk,myFail,myAb,myFlts,myEncoding);
    for (    String base : bases) {
      String[] paths=ats.value();
      if ((paths.length == 1 && Strings.isBlank(paths[0])) || paths.length == 0) {
        String actionPath=base + ""String_Node_Str"" + method.getName().toLowerCase();
        root.add(actionPath,invoker);
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",method.getName(),actionPath);
      }
 else {
        for (        String at : paths) {
          String actionPath=base + at;
          root.add(actionPath,invoker);
          if (log.isDebugEnabled())           log.debugf(""String_Node_Str"",method.getName(),actionPath);
        }
      }
    }
  }
  return isModule;
}"
80865,"public Map<String,String[]> getParameterMap(){
  return parameterMap;
}","public Map<String,String[]> getParameterMap(){
  return params;
}"
80866,"public String getParameter(String key){
  if (parameterMap.containsKey(key)) {
    return parameterMap.get(key)[0];
  }
  return null;
}","public String getParameter(String key){
  if (params.containsKey(key)) {
    return params.get(key)[0];
  }
  return null;
}"
80867,"public Enumeration<String> getParameterNames(){
  return new Vector<String>(parameterMap.keySet()).elements();
}","public Enumeration<String> getParameterNames(){
  return new Vector<String>(params.keySet()).elements();
}"
80868,"public void setParameter(String key,String value){
  parameterMap.put(key,new String[]{value});
}","public void setParameter(String key,Number num){
  setParameter(key,num.toString());
}"
80869,"public String[] getParameterValues(String arg0){
  List<String> pp=new ArrayList<String>(parameterMap.size());
  for (  Entry<String,String[]> strs : parameterMap.entrySet()) {
    for (    String str : strs.getValue()) {
      pp.add(str);
    }
  }
  return pp.toArray(new String[pp.size()]);
}","public String[] getParameterValues(String name){
  Object param=params.get(name);
  return Castors.me().castTo(param,String[].class);
}"
80870,"public String getQueryString(){
  if (parameterMap.size() == 0)   return null;
  StringBuilder sb=new StringBuilder();
  for (  Entry<String,String[]> entry : parameterMap.entrySet()) {
    if (entry.getValue() == null)     sb.append(entry.getKey()).append(""String_Node_Str"");
 else     for (    String str : entry.getValue()) {
      sb.append(entry.getKey()).append(""String_Node_Str"").append(str).append(""String_Node_Str"");
    }
  }
  return sb.toString();
}","public String getQueryString(){
  if (params.size() == 0)   return null;
  StringBuilder sb=new StringBuilder();
  for (  Entry<String,String[]> entry : params.entrySet()) {
    if (entry.getValue() == null)     sb.append(entry.getKey()).append(""String_Node_Str"");
 else     for (    String str : entry.getValue()) {
      sb.append(entry.getKey()).append(""String_Node_Str"").append(str).append(""String_Node_Str"");
    }
  }
  return sb.toString();
}"
80871,"protected ParamInjector evalInjector(Class<?> type,Param param){
  if (File.class.isAssignableFrom(type))   return new FileInjector(param.value());
  if (FieldMeta.class.isAssignableFrom(type))   return new FileMetaInjector(param.value());
  if (TempFile.class.isAssignableFrom(type))   return new TempFileInjector(param.value());
  if (Map.class.isAssignableFrom(type))   return new MapSelfInjector();
  if (null == param)   return null;
  return new MapItemInjector(param.value(),type);
}","protected ParamInjector evalInjector(Class<?> type,Param param){
  if (File.class.isAssignableFrom(type))   return new FileInjector(param.value());
  if (FieldMeta.class.isAssignableFrom(type))   return new FileMetaInjector(param.value());
  if (TempFile.class.isAssignableFrom(type))   return new TempFileInjector(param.value());
  if (Map.class.isAssignableFrom(type))   return new MapSelfInjector();
  if (null == param)   return null;
  String pm=param.value();
  if (""String_Node_Str"".equals(pm)) {
    if (type.isAssignableFrom(Map.class))     return new MapPairInjector();
    return new MapReferInjector(null,type);
  }
 else   if (pm.startsWith(""String_Node_Str"") && pm.length() > 2) {
    return new MapReferInjector(pm.substring(2),type);
  }
 else   if (type.isArray())   return new ArrayInjector(pm,type);
  return new MapItemInjector(param.value(),type);
}"
80872,"Ioc create(ServletConfig config,String[] args);","Ioc create(NutConfig config,String[] args);"
80873,void load(Class<?> klass);,"void load(NutConfig config,Class<?> klass);"
80874,"/** 
 * 获取当前请求的路径，并去掉后缀
 */
public static String getRequestPath(HttpServletRequest req){
  String path=req.getPathInfo();
  if (null == path)   path=req.getServletPath();
  if (null == path)   return ""String_Node_Str"";
  int lio=path.lastIndexOf('.');
  if (lio > 0)   path=path.substring(0,lio);
  return path;
}","/** 
 * 获取当前请求的路径，并去掉后缀
 */
public static String getRequestPath(HttpServletRequest req){
  return getRequestPathObject(req).getPath();
}"
80875,"public void init(FilterConfig config) throws ServletException {
}","public void init(FilterConfig conf) throws ServletException {
  config=new FilterNutConfig(conf);
  Loading ing=Inits.init(config,true);
  if (null != ing)   urls=ing.getUrls();
  String regx=Strings.sNull(config.getAttribute(""String_Node_Str""),IGNORE);
  if (!""String_Node_Str"".equalsIgnoreCase(regx)) {
    ignorePtn=Pattern.compile(regx,Pattern.CASE_INSENSITIVE);
  }
}"
80876,"public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  Mvcs.updateRequestAttributes((HttpServletRequest)req);
  chain.doFilter(req,resp);
}","public void doFilter(ServletRequest req,ServletResponse resp,FilterChain chain) throws IOException, ServletException {
  Mvcs.updateRequestAttributes((HttpServletRequest)req);
  if (null != urls) {
    RequestPath path=Mvcs.getRequestPathObject((HttpServletRequest)req);
    if (null == ignorePtn || !ignorePtn.matcher(path.getUrl()).find()) {
      ActionInvoking ing=urls.get(path.getPath());
      if (null != ing && null != ing.getInvoker()) {
        if (log.isInfoEnabled())         log.info(path);
        ing.invoke((HttpServletRequest)req,(HttpServletResponse)resp);
        return;
      }
    }
  }
  chain.doFilter(req,resp);
}"
80877,"public void destroy(){
}","public void destroy(){
  if (null != urls)   Inits.destroy(config);
}"
80878,"@Override public void init() throws ServletException {
  try {
    if (log.isInfoEnabled()) {
      log.infof(""String_Node_Str"",Nutz.version());
      log.infof(""String_Node_Str"",this.getServletName());
    }
    Stopwatch sw=Stopwatch.begin();
    String name=Strings.trim(this.getServletConfig().getInitParameter(""String_Node_Str""));
    if (Strings.isEmpty(name)) {
      throw Lang.makeThrow(ServletException.class,""String_Node_Str"",this.getClass().getName());
    }
    Class<?> mainModule=Class.forName(name);
    Class<? extends Loading> loadingType;
    LoadingBy lb=mainModule.getAnnotation(LoadingBy.class);
    if (null != lb)     loadingType=lb.value();
 else     loadingType=DefaultLoading.class;
    Loading ing=Mirror.me(loadingType).born(this.getServletConfig());
    ing.load(mainModule);
    urls=ing.getUrls();
    sw.stop();
    if (log.isInfoEnabled())     log.infof(""String_Node_Str"",this.getServletName(),sw.getDuration());
    ok=true;
  }
 catch (  Throwable e) {
    if (log.isErrorEnabled())     log.error(""String_Node_Str"",e);
    if (e instanceof ServletException)     throw (ServletException)e;
    throw new ServletException(e);
  }
}","@Override public void init() throws ServletException {
  Loading ing=Inits.init(new ServletNutConfig(getServletConfig()),false);
  urls=ing.getUrls();
  ok=true;
}"
80879,"public void destroy(){
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",this.getServletName());
  Stopwatch sw=Stopwatch.begin();
  try {
    urls=null;
    Setup setup=(Setup)this.getServletContext().getAttribute(Setup.class.getName());
    if (null != setup)     setup.destroy(getServletConfig());
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e);
  }
 finally {
    super.destroy();
  }
  Ioc ioc=Mvcs.getIoc(this.getServletContext());
  if (null != ioc)   ioc.depose();
  sw.stop();
  if (log.isInfoEnabled())   log.infof(""String_Node_Str"",this.getServletName(),sw.getDuration());
}","public void destroy(){
  NutConfig config=new ServletNutConfig(getServletConfig());
  if (config.getMainModule() != null)   Inits.destroy(config);
}"
80880,"/** 
 * 启动时，额外逻辑
 * @param config
 */
void init(ServletConfig config);","/** 
 * 启动时，额外逻辑
 * @param config
 */
void init(NutConfig config);"
80881,"/** 
 * 关闭时，额外逻辑
 * @param config
 */
void destroy(ServletConfig config);","/** 
 * 关闭时，额外逻辑
 * @param config
 */
void destroy(NutConfig config);"
80882,"protected void loadIoc() throws Throwable {
  IocBy ib=mainModule.getAnnotation(IocBy.class);
  if (null != ib) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",ib.type().getName());
    ioc=ib.type().newInstance().create(config,ib.args());
    saveToContext(Ioc.class.getName(),ioc);
  }
 else   if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
}","protected void loadIoc() throws Throwable {
  IocBy ib=mainModule.getAnnotation(IocBy.class);
  if (null != ib) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",ib.type().getName());
    ioc=ib.type().newInstance().create(config,ib.args());
    if (ioc instanceof Ioc2)     ((Ioc2)ioc).addValueProxyMaker(new MvcValueProxyMaker());
    saveToContext(Ioc.class.getName(),ioc);
  }
 else   if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
}"
80883,"protected void loadSubModules() throws Throwable {
  Views vms=mainModule.getAnnotation(Views.class);
  ArrayList<ViewMaker> makers=new ArrayList<ViewMaker>();
  if (null != vms)   for (  Class<? extends ViewMaker> type : vms.value())   makers.add(type.newInstance());
  makers.add(new DefaultViewMaker());
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",mainModule.getName());
  urls=makeUrlMap(ioc,context,mainModule);
  urls.add(makers,mainModule);
  Modules modules=mainModule.getAnnotation(Modules.class);
  if (null != modules) {
    if (!modules.scanPackage()) {
      for (      Class<?> module : modules.value()) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",module.getName());
        urls.add(makers,module);
      }
    }
 else {
      for (      Class<?> module : modules.value()) {
        Package packageZ=module.getPackage();
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",packageZ.getName());
        List<Class<?>> list=ResourceScanHelper.scanClasses(packageZ.getName());
        if (list != null)         for (        Class<?> md : list) {
          if (urls.add(makers,md))           if (log.isDebugEnabled())           log.debugf(""String_Node_Str"",md.getName());
        }
      }
    }
  }
  config.getServletContext().setAttribute(UrlMap.class.getName(),urls);
}","protected void loadSubModules() throws Throwable {
  Views vms=mainModule.getAnnotation(Views.class);
  ArrayList<ViewMaker> makers=new ArrayList<ViewMaker>();
  if (null != vms)   for (  Class<? extends ViewMaker> type : vms.value())   makers.add(type.newInstance());
  makers.add(new DefaultViewMaker());
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",mainModule.getName());
  urls=makeUrlMap(ioc,context,mainModule);
  urls.add(makers,mainModule);
  Modules modules=mainModule.getAnnotation(Modules.class);
  Set<Class<?>> subModules=new HashSet<Class<?>>();
  if (null != modules) {
    for (    Class<?> module : modules.value()) {
      subModules.add(module);
    }
    if (modules.scanPackage()) {
      for (      Class<?> module : modules.value()) {
        Package packageZ=module.getPackage();
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",packageZ.getName());
        List<Class<?>> list=ResourceScanHelper.scanClasses(packageZ.getName());
        if (list != null)         for (        Class<?> classZ : list)         if (classZ.getPackage().equals(mainModule.getPackage()))         subModules.add(classZ);
      }
    }
  }
  if (config.getInitParameter(""String_Node_Str"") != null) {
    String scanPackages=config.getInitParameter(""String_Node_Str"").trim();
    String[] packages=scanPackages.split(""String_Node_Str"");
    for (int i=0; i < packages.length; i++)     if (packages[i].trim().length() > 0) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",packages[i].trim());
      List<Class<?>> list=ResourceScanHelper.scanClasses(packages[i].trim());
      for (      Class<?> classZ : list)       if (isSubModule(classZ))       subModules.add(classZ);
    }
  }
  subModules.remove(mainModule);
  for (  Class<?> module : subModules) {
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",module.getName());
    urls.add(makers,module);
  }
  config.getServletContext().setAttribute(UrlMap.class.getName(),urls);
}"
80884,"public T born(){
  try {
    return borning.born(realArgs);
  }
 catch (  Throwable e) {
    throw new BorningException(e,type,realArgs);
  }
}","public T born(){
  try {
    return borning.born(realArgs);
  }
 catch (  Throwable e) {
    throw new BorningException(Lang.unwrapThrow(e),type,realArgs);
  }
}"
80885,"private void evalEncoding(Method method,Encoding dftEncoding){
  Encoding encoding=method.getAnnotation(Encoding.class);
  if (null == encoding)   encoding=dftEncoding;
  if (null == encoding) {
    inputCharset=org.nutz.lang.Encoding.defaultEncoding();
    outputCharset=org.nutz.lang.Encoding.defaultEncoding();
  }
 else {
    inputCharset=encoding.input();
    outputCharset=encoding.output();
  }
}","private void evalEncoding(Method method,Encoding dftEncoding){
  Encoding encoding=method.getAnnotation(Encoding.class);
  if (null == encoding)   encoding=dftEncoding;
  if (null == encoding) {
    inputCharset=org.nutz.lang.Encoding.UTF8;
    outputCharset=org.nutz.lang.Encoding.UTF8;
  }
 else {
    inputCharset=encoding.input();
    outputCharset=encoding.output();
  }
}"
80886,"/** 
 * The function try to return the file path of one class or package. If it exists in regular directory, it will return as ""D:/folder/folder/name.class"" in windows, and ""/folder/folder/name.class"" in unix like system. <p> If the class file exists in one jar file, it will return the path like: <b>'XXXXXXXfile:\XXXXXX\XXX.jar!\XX\XX\XX'</b> <p> use ClassLoader.getResources(String) to search resources in classpath <p> <b style=color:red>Note:</b> <p> We use new <i>ClassLoader(){}</i> to instead of <i>classZ.getClassLoader()</i>, for the reason: in <b>GAE</b> , it will fail if you call getClassLoader() <br> <br>
 * @param base : the class file name or package dir name
 * @return path or null if nothing found
 * @author Wendal Chen
 * @author zozoh
 * @see java.lang.ClassLoader
 * @see java.io.File
 */
private static File getBasePath(String base){
  try {
    Enumeration<URL> urls=new ClassLoader(){
    }
.getResources(base);
    File file=null;
    if (null != urls && urls.hasMoreElements()) {
      URL url=urls.nextElement();
      if (url != null) {
        String path=url.getFile();
        path=decodePath(path);
        file=new File(path);
      }
    }
    if (null == file)     file=Files.findFile(base);
    if (null == file)     return null;
    try {
      if (file.isDirectory())       return file;
    }
 catch (    SecurityException e) {
    }
    return file.getParentFile();
  }
 catch (  IOException e) {
  }
  return null;
}","/** 
 * The function try to return the file path of one class or package. If it exists in regular directory, it will return as ""D:/folder/folder/name.class"" in windows, and ""/folder/folder/name.class"" in unix like system. <p> If the class file exists in one jar file, it will return the path like: <b>'XXXXXXXfile:\XXXXXX\XXX.jar!\XX\XX\XX'</b> <p> use ClassLoader.getResources(String) to search resources in classpath <p> <b style=color:red>Note:</b> <p> We use new <i>ClassLoader(){}</i> to instead of <i>classZ.getClassLoader()</i>, for the reason: in <b>GAE</b> , it will fail if you call getClassLoader() <br> <br>
 * @param base : the class file name or package dir name
 * @return path or null if nothing found
 * @author Wendal Chen
 * @author zozoh
 * @see java.lang.ClassLoader
 * @see java.io.File
 */
private static File getBasePath(String base){
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",base);
  try {
    Enumeration<URL> urls=new ClassLoader(){
    }
.getResources(base);
    File file=null;
    if (null != urls && urls.hasMoreElements()) {
      URL url=urls.nextElement();
      if (url != null) {
        String path=url.getFile();
        path=decodePath(path);
        file=new File(path);
      }
    }
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",file);
    if (null == file) {
      file=Files.findFile(base);
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",file);
    }
    if (null == file)     return null;
    try {
      if (file.isDirectory())       return file;
    }
 catch (    SecurityException e) {
    }
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",file.getParentFile());
    return file.getParentFile();
  }
 catch (  IOException e) {
  }
  return null;
}"
80887,"private static String getJarPath(File dir){
  String fpath=dir.getAbsolutePath();
  int posBegin=fpath.indexOf(""String_Node_Str"") + 5;
  int posEnd=fpath.lastIndexOf('!');
  if (posBegin > 0 && (posEnd - posBegin) > 0)   return fpath.substring(posBegin,posEnd);
  return null;
}","static String getJarPath(String jarPath){
  int posBegin=jarPath.indexOf(""String_Node_Str"");
  if (posBegin == -1)   posBegin=0;
 else {
    posBegin+=6;
    if (jarPath.length() <= posBegin)     return null;
    if (jarPath.charAt(posBegin - 1) != '\\')     posBegin--;
  }
  int posEnd=jarPath.lastIndexOf('!');
  if (posBegin >= 0 && (posEnd - posBegin) > 0)   return jarPath.substring(posBegin,posEnd);
  return null;
}"
80888,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  Mirror<?> mirror=Mirror.me(obj);
  boolean isMap=null != obj && obj instanceof Map<?,?>;
  Map<?,?> map=(Map<?,?>)obj;
  Set<String> keySet=dest.keys();
  Iterator<String> it=keySet.iterator();
  while (it.hasNext()) {
    String key=it.next();
    Object value=null;
    int length=key.length();
    if (key.startsWith(""String_Node_Str"") && length > 2) {
      value=req.getParameter(key.substring(2));
    }
 else     if (isMap && key.startsWith(""String_Node_Str"") && length > 4) {
      value=map.get(key);
    }
 else     if (null != mirror && key.startsWith(""String_Node_Str"") && length > 4) {
      value=mirror.getValue(obj,key.substring(4));
    }
 else {
      value=obj;
    }
    if (null == value)     value=obj;
    dest.set(key,value);
  }
  String path=dest.toString();
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.startsWith(""String_Node_Str"")) {
    path=req.getContextPath() + path;
  }
 else {
    String myPath=req.getPathInfo();
    int pos=myPath.lastIndexOf('/');
    if (pos > 0)     path=myPath.substring(0,pos) + ""String_Node_Str"" + path;
 else     path=""String_Node_Str"" + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  Mirror<?> mirror=Mirror.me(obj);
  boolean isMap=null != obj && obj instanceof Map<?,?>;
  Map<?,?> map=isMap ? null : (Map<?,?>)obj;
  Set<String> keySet=dest.keys();
  Iterator<String> it=keySet.iterator();
  while (it.hasNext()) {
    String key=it.next();
    Object value=null;
    int length=key.length();
    if (key.startsWith(""String_Node_Str"") && length > 2) {
      value=req.getParameter(key.substring(2));
    }
 else     if (isMap && key.startsWith(""String_Node_Str"") && length > 4) {
      value=map.get(key);
    }
 else     if (null != mirror && key.startsWith(""String_Node_Str"") && length > 4) {
      value=mirror.getValue(obj,key.substring(4));
    }
 else {
      value=obj;
    }
    if (null == value)     value=obj;
    dest.set(key,value);
  }
  String path=dest.toString();
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.startsWith(""String_Node_Str"")) {
    path=req.getContextPath() + path;
  }
 else {
    String myPath=req.getPathInfo();
    int pos=myPath.lastIndexOf('/');
    if (pos > 0)     path=myPath.substring(0,pos) + ""String_Node_Str"" + path;
 else     path=""String_Node_Str"" + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}"
80889,"public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  Mirror<?> mirror=Mirror.me(obj);
  boolean isMap=null != obj && obj instanceof Map<?,?>;
  Map<?,?> map=isMap ? null : (Map<?,?>)obj;
  Set<String> keySet=dest.keys();
  Iterator<String> it=keySet.iterator();
  while (it.hasNext()) {
    String key=it.next();
    Object value=null;
    int length=key.length();
    if (key.startsWith(""String_Node_Str"") && length > 2) {
      value=req.getParameter(key.substring(2));
    }
 else     if (isMap && key.startsWith(""String_Node_Str"") && length > 4) {
      value=map.get(key);
    }
 else     if (null != mirror && key.startsWith(""String_Node_Str"") && length > 4) {
      value=mirror.getValue(obj,key.substring(4));
    }
 else {
      value=obj;
    }
    if (null == value)     value=obj;
    dest.set(key,value);
  }
  String path=dest.toString();
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.startsWith(""String_Node_Str"")) {
    path=req.getContextPath() + path;
  }
 else {
    String myPath=req.getPathInfo();
    int pos=myPath.lastIndexOf('/');
    if (pos > 0)     path=myPath.substring(0,pos) + ""String_Node_Str"" + path;
 else     path=""String_Node_Str"" + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}","public void render(HttpServletRequest req,HttpServletResponse resp,Object obj) throws Exception {
  Mirror<?> mirror=Mirror.me(obj);
  boolean isMap=null != obj && obj instanceof Map<?,?>;
  Map<?,?> map=isMap ? (Map<?,?>)obj : null;
  Set<String> keySet=dest.keys();
  Iterator<String> it=keySet.iterator();
  while (it.hasNext()) {
    String key=it.next();
    Object value=null;
    int length=key.length();
    if (key.startsWith(""String_Node_Str"") && length > 2) {
      value=req.getParameter(key.substring(2));
    }
 else     if (isMap && key.startsWith(""String_Node_Str"") && length > 4) {
      value=map.get(key);
    }
 else     if (null != mirror && key.startsWith(""String_Node_Str"") && length > 4) {
      value=mirror.getValue(obj,key.substring(4));
    }
 else {
      value=obj;
    }
    if (null == value)     value=obj;
    dest.set(key,value);
  }
  String path=dest.toString();
  if (path.startsWith(""String_Node_Str"") || path.startsWith(""String_Node_Str"")) {
  }
 else   if (path.startsWith(""String_Node_Str"")) {
    path=req.getContextPath() + path;
  }
 else {
    String myPath=req.getPathInfo();
    int pos=myPath.lastIndexOf('/');
    if (pos > 0)     path=myPath.substring(0,pos) + ""String_Node_Str"" + path;
 else     path=""String_Node_Str"" + path;
  }
  resp.sendRedirect(path);
  resp.flushBuffer();
}"
80890,"public void addValueProxyMaker(ValueProxyMaker vpm){
  vpms.add(vpm);
}","public void addValueProxyMaker(ValueProxyMaker vpm){
  vpms.add(0,vpm);
}"
80891,"@SuppressWarnings(""String_Node_Str"") public ValueProxy make(IocMaking ing,IocValue iv){
  Object value=iv.getValue();
  String type=iv.getType();
  if (""String_Node_Str"".equals(type) || null == value) {
    return new StaticValue(null);
  }
 else   if (""String_Node_Str"".equals(type) || null == type) {
    if (value.getClass().isArray()) {
      Object[] vs=(Object[])value;
      IocValue[] tmp=new IocValue[vs.length];
      for (int i=0; i < tmp.length; i++)       tmp[i]=(IocValue)vs[i];
      return new ArrayValue(ing,tmp);
    }
 else     if (value instanceof Map<?,?>) {
      return new MapValue(ing,(Map<String,IocValue>)value,(Class<? extends Map<String,Object>>)value.getClass());
    }
 else     if (value instanceof Collection<?>) {
      return new CollectionValue(ing,(Collection<IocValue>)value,(Class<? extends Collection<Object>>)value.getClass());
    }
 else     if (value instanceof IocObject) {
      return new InnerValue((IocObject)value);
    }
    return new StaticValue(value);
  }
 else   if (""String_Node_Str"".equals(type)) {
    String s=value.toString();
    if (""String_Node_Str"".equalsIgnoreCase(s)) {
      return new IocSelfValue();
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(s)) {
      return new ObjectNameValue();
    }
    return new ReferValue(s);
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new JavaValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new FileValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new EnvValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new SysPropValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new InnerValue((IocObject)value);
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new JNDI_Value(value.toString());
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public ValueProxy make(IocMaking ing,IocValue iv){
  Object value=iv.getValue();
  String type=iv.getType();
  if (""String_Node_Str"".equals(type) || null == value) {
    return new StaticValue(null);
  }
 else   if (""String_Node_Str"".equals(type) || null == type) {
    if (value.getClass().isArray()) {
      Object[] vs=(Object[])value;
      IocValue[] tmp=new IocValue[vs.length];
      for (int i=0; i < tmp.length; i++)       tmp[i]=(IocValue)vs[i];
      return new ArrayValue(ing,tmp);
    }
 else     if (value instanceof Map<?,?>) {
      return new MapValue(ing,(Map<String,IocValue>)value,(Class<? extends Map<String,Object>>)value.getClass());
    }
 else     if (value instanceof Collection<?>) {
      return new CollectionValue(ing,(Collection<IocValue>)value,(Class<? extends Collection<Object>>)value.getClass());
    }
 else     if (value instanceof IocObject) {
      return new InnerValue((IocObject)value);
    }
    return new StaticValue(value);
  }
 else   if (""String_Node_Str"".equals(type)) {
    String s=value.toString();
    if (null != s) {
      String renm=s.toLowerCase();
      if (""String_Node_Str"".equals(renm)) {
        return new IocSelfValue();
      }
 else       if (""String_Node_Str"".equals(renm)) {
        return new ObjectNameValue();
      }
 else       if (""String_Node_Str"".equals(renm)) {
        return new IocContextObjectValue();
      }
    }
    return new ReferValue(s);
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new JavaValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new FileValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new EnvValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new SysPropValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new InnerValue((IocObject)value);
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new JNDI_Value(value.toString());
  }
  return null;
}"
80892,"/** 
 * 如果txt中第一个支付和 firstChar一致,则删除,否则返回 txt <p> 比如: <ul> <li>removeFirst(""12345"",1) => ""2345"" <li>removeFirst(""ABC"",'B') => ""ABC"" <li>removeFirst(""A"",'B') => ""A"" <li>removeFirst(""A"",'A') => """" </ul>
 * @param str 字符串
 * @param c 第一个个要被截取的字符
 * @return 新字符串
 */
public static String removeFirst(String str,char c){
  if (str == null)   return null;
  if (str.length() == 0)   return ""String_Node_Str"";
  if (c == str.charAt(0))   return str.substring(1);
  return str;
}","/** 
 * 如果txt中第一个字符和 firstChar一致,则删除,否则返回 txt <p> 比如: <ul> <li>removeFirst(""12345"",1) => ""2345"" <li>removeFirst(""ABC"",'B') => ""ABC"" <li>removeFirst(""A"",'B') => ""A"" <li>removeFirst(""A"",'A') => """" </ul>
 * @param str 字符串
 * @param c 第一个个要被截取的字符
 * @return 新字符串
 */
public static String removeFirst(String str,char c){
  if (str == null)   return null;
  if (str.length() == 0)   return ""String_Node_Str"";
  if (c == str.charAt(0))   return str.substring(1);
  return str;
}"
80893,"@SuppressWarnings(""String_Node_Str"") void render(Object obj) throws IOException {
  if (null == obj) {
    writer.write(""String_Node_Str"");
  }
 else   if (obj instanceof Class) {
    string2Json(((Class<?>)obj).getName());
  }
 else   if (obj instanceof Mirror) {
    string2Json(((Mirror<?>)obj).getType().getName());
  }
 else {
    Mirror mr=Mirror.me(obj.getClass());
    if (mr.isEnum()) {
      string2Json(((Enum)obj).name());
    }
 else     if (mr.isNumber() || mr.isBoolean() || mr.isChar()) {
      writer.append(obj.toString());
    }
 else     if (mr.isStringLike()) {
      string2Json(obj.toString());
    }
 else     if (mr.isDateTimeLike()) {
      string2Json(format.getCastors().castToString(obj));
    }
 else     if (memo.containsKey(obj)) {
      writer.append(""String_Node_Str"");
    }
 else {
      if (obj instanceof Map)       map2Json((Map)obj);
 else       if (obj instanceof Collection)       coll2Json((Collection)obj);
 else       if (obj.getClass().isArray())       array2Json(obj);
 else {
        memo.put(obj,null);
        pojo2Json(obj);
        memo.remove(obj);
      }
    }
  }
}","@SuppressWarnings(""String_Node_Str"") void render(Object obj) throws IOException {
  if (null == obj) {
    writer.write(""String_Node_Str"");
  }
 else   if (obj instanceof Class) {
    string2Json(((Class<?>)obj).getName());
  }
 else   if (obj instanceof Mirror) {
    string2Json(((Mirror<?>)obj).getType().getName());
  }
 else {
    Mirror mr=Mirror.me(obj.getClass());
    if (mr.isEnum()) {
      string2Json(((Enum)obj).name());
    }
 else     if (mr.isNumber() || mr.isBoolean() || mr.isChar()) {
      writer.append(obj.toString());
    }
 else     if (mr.isStringLike()) {
      string2Json(obj.toString());
    }
 else     if (mr.isDateTimeLike()) {
      string2Json(format.getCastors().castToString(obj));
    }
 else     if (memo.containsKey(obj)) {
      writer.append(""String_Node_Str"");
    }
 else {
      memo.put(obj,null);
      if (obj instanceof Map)       map2Json((Map)obj);
 else       if (obj instanceof Collection)       coll2Json((Collection)obj);
 else       if (obj.getClass().isArray())       array2Json(obj);
 else {
        pojo2Json(obj);
      }
      memo.remove(obj);
    }
  }
}"
80894,"public Class<?> load(String className) throws ClassNotFoundException {
  try {
    return getParent().loadClass(className);
  }
 catch (  ClassNotFoundException e) {
  }
  return loadClass(className);
}","public Class<?> load(String className) throws ClassNotFoundException {
  try {
    return Thread.currentThread().getContextClassLoader().loadClass(className);
  }
 catch (  ClassNotFoundException e) {
    try {
      return ClassLoader.getSystemClassLoader().loadClass(className);
    }
 catch (    ClassNotFoundException e2) {
      try {
        return getParent().loadClass(className);
      }
 catch (      ClassNotFoundException e3) {
      }
    }
  }
  return loadClass(className);
}"
80895,"@SuppressWarnings(""String_Node_Str"") protected <T>Class<T> generate(ClassDefiner cd,Pair2[] pair2s,String newName,Class<T> klass,Constructor<T>[] constructors){
  try {
    return (Class<T>)cd.load(newName);
  }
 catch (  ClassNotFoundException e) {
  }
  try {
    cd.load(""String_Node_Str"");
  }
 catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
  Method[] methodArray=new Method[pair2s.length];
  List<MethodInterceptor>[] methodInterceptorList=new List[pair2s.length];
  for (int i=0; i < pair2s.length; i++) {
    Pair2 pair2=pair2s[i];
    methodArray[i]=pair2.method;
    methodInterceptorList[i]=pair2.listeners;
  }
  byte[] bytes=ClassY.enhandClass(klass,newName,methodArray,constructors);
  if (debug)   Files.write(new File(newName),bytes);
  Class<T> newClass=(Class<T>)cd.define(newName,bytes);
  AopToolKit.injectFieldValue(newClass,methodArray,methodInterceptorList);
  return newClass;
}","@SuppressWarnings(""String_Node_Str"") protected <T>Class<T> generate(ClassDefiner cd,Pair2[] pair2s,String newName,Class<T> klass,Constructor<T>[] constructors){
  try {
    return (Class<T>)cd.load(newName);
  }
 catch (  ClassNotFoundException e) {
  }
  Method[] methodArray=new Method[pair2s.length];
  List<MethodInterceptor>[] methodInterceptorList=new List[pair2s.length];
  for (int i=0; i < pair2s.length; i++) {
    Pair2 pair2=pair2s[i];
    methodArray[i]=pair2.method;
    methodInterceptorList[i]=pair2.listeners;
  }
  byte[] bytes=ClassY.enhandClass(klass,newName,methodArray,constructors);
  if (debug)   Files.write(new File(newName),bytes);
  Class<T> newClass=(Class<T>)cd.define(newName,bytes);
  AopToolKit.injectFieldValue(newClass,methodArray,methodInterceptorList);
  return newClass;
}"
80896,"public DefaultMirrorFactory(Ioc ioc){
  this.ioc=ioc;
  this.cd=new DefaultClassDefiner();
}","public DefaultMirrorFactory(Ioc ioc){
  this.ioc=ioc;
  this.cd=new DefaultClassDefiner(getClass().getClassLoader());
}"
80897,"public XmlFileMirrorFactory(Ioc ioc,String... fileNames) throws ParserConfigurationException, SAXException, IOException {
  this.ioc=ioc;
  this.cd=new DefaultClassDefiner();
  DocumentBuilder builder=Lang.xmls();
  Document document;
  for (  String fileName : fileNames) {
    document=builder.parse(Files.findFile(fileName));
    document.normalizeDocument();
    NodeList nodeListZ=((Element)document.getDocumentElement()).getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodeListZ.getLength(); i++)     parse((Element)nodeListZ.item(i));
  }
}","public XmlFileMirrorFactory(Ioc ioc,String... fileNames) throws ParserConfigurationException, SAXException, IOException {
  this.ioc=ioc;
  this.cd=new DefaultClassDefiner(getClass().getClassLoader());
  DocumentBuilder builder=Lang.xmls();
  Document document;
  for (  String fileName : fileNames) {
    document=builder.parse(Files.findFile(fileName));
    document.normalizeDocument();
    NodeList nodeListZ=((Element)document.getDocumentElement()).getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < nodeListZ.getLength(); i++)     parse((Element)nodeListZ.item(i));
  }
}"
80898,"public static ClassDefiner cd(){
  return new DefaultClassDefiner();
}","public static ClassDefiner cd(){
  return new DefaultClassDefiner(Nutzs.class.getClassLoader());
}"
80899,"public Map<String,Object> parse(HttpServletRequest req,String charset,FilePool tmps) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  NutMap params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  byte[] firstBoundaryBytes=Lang.toBytes(firstBoundary.toCharArray());
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  byte[] itemEndlBytes=Lang.toBytes(itemEndl.toCharArray());
  byte[] nameEndlBytes=Lang.toBytes(""String_Node_Str"".toCharArray());
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  FieldMeta meta;
  try {
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString();
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            do {
              info.current=br.load();
              mm=br.mark(itemEndlBytes);
              assertStreamNotEnd(mm);
              br.dump(ops);
            }
 while (mm == MarkMode.NOT_FOUND);
          }
  finally {
            Streams.safeClose(ops);
          }
          params.add(meta.getName(),new TempFile(meta,tmp));
        }
      }
 else {
        StreamBuffer sb=new StreamBuffer();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          br.dump(sb.getBuffer());
        }
 while (mm == MarkMode.NOT_FOUND);
        params.add(meta.getName(),sb.toString(charset));
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}","public Map<String,Object> parse(HttpServletRequest req,String charset,FilePool tmps) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  NutMap params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes firstBoundaryBytes=RemountBytes.create(firstBoundary);
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  RemountBytes itemEndlBytes=RemountBytes.create(itemEndl);
  RemountBytes nameEndlBytes=RemountBytes.create(""String_Node_Str"");
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  FieldMeta meta;
  try {
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString();
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            do {
              info.current=br.load();
              mm=br.mark(itemEndlBytes);
              assertStreamNotEnd(mm);
              br.dump(ops);
            }
 while (mm == MarkMode.NOT_FOUND);
          }
  finally {
            Streams.safeClose(ops);
          }
          params.add(meta.getName(),new TempFile(meta,tmp));
        }
      }
 else {
        StreamBuffer sb=new StreamBuffer();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          br.dump(sb.getBuffer());
        }
 while (mm == MarkMode.NOT_FOUND);
        params.add(meta.getName(),sb.toString(charset));
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}"
80900,"/** 
 * 根据给定的字节数组，在环中作标记，以便 dump
 * @param bs 数组
 * @return 标记模式
 * @throws IOException
 */
public MarkMode mark(byte[] bs) throws IOException {
  RingItem ri=item;
  int re;
  while ((re=ri.mark(bs)) >= 0 && ri.isDone4Mark()) {
    if (re > 0) {
      if (!ri.next.isLoaded) {
        ri.next.load(ins);
        readed+=ri.next.max;
      }
 else       if (ri.next == this.item) {
        ri.nextmark=ri.r;
        return MarkMode.NOT_FOUND;
      }
      if (ri.next.matchHeadingWithRemain(bs,re)) {
        return MarkMode.FOUND;
      }
 else {
        ri.r=ri.max;
        ri.nextmark=ri.max;
      }
    }
    if (ri.isStreamEnd)     break;
    ri=ri.next;
    if (!ri.isLoaded) {
      ri.load(ins);
      readed+=ri.max;
    }
    if (ri == item)     break;
  }
  if (re == -1)   return MarkMode.FOUND;
  return ri.isStreamEnd ? MarkMode.STREAM_END : MarkMode.NOT_FOUND;
}","/** 
 * 根据给定的字节数组，在环中作标记，以便 dump
 * @param bs 数组
 * @return 标记模式
 * @throws IOException
 */
private MarkMode mark(byte[] bs,int[] fails) throws IOException {
  RingItem ri=item;
  int re;
  while ((re=ri.mark(bs,fails)) >= 0 && ri.isDone4Mark()) {
    if (re > 0) {
      if (!ri.next.isLoaded) {
        ri.next.load(ins);
        readed+=ri.next.max;
      }
 else       if (ri.next == this.item) {
        ri.nextmark=ri.r;
        return MarkMode.NOT_FOUND;
      }
      if (ri.next.matchHeadingWithRemain(bs,re)) {
        return MarkMode.FOUND;
      }
 else {
        ri.r=ri.max;
        ri.nextmark=ri.max;
      }
    }
    if (ri.isStreamEnd)     break;
    ri=ri.next;
    if (!ri.isLoaded) {
      ri.load(ins);
      readed+=ri.max;
    }
    if (ri == item)     break;
  }
  if (re == -1)   return MarkMode.FOUND;
  return ri.isStreamEnd ? MarkMode.STREAM_END : MarkMode.NOT_FOUND;
}"
80901,"public static RemountBytes create(byte[] bs){
  int[] ps=new int[bs.length];
  for (int i=2; i < bs.length; i++) {
  }
  RemountBytes re=new RemountBytes();
  re.bytes=bs;
  re.pos=ps;
  return re;
}","public static RemountBytes create(byte[] bs){
  int[] fails=new int[bs.length];
  if (bs.length > 1) {
    for (int i=2; i < bs.length; i++) {
      int blueL=1;
      int blueR=i - 1;
      int x=0;
      for (int j=blueL; j <= blueR; j++) {
        byte red=bs[x];
        byte blue=bs[j];
        if (red == blue)         x++;
 else         x=0;
      }
      fails[i]=x;
    }
  }
  RemountBytes re=new RemountBytes();
  re.bytes=bs;
  re.fails=fails;
  return re;
}"
80902,"/** 
 * 从给定 offs 尽力匹配给出的数组。 <p> 需要注意的是，如果返回的是 >0 的数，内部的标志位将被设置到第一个匹配字符，以便 DUMP 内容。 <br> 所以，如果下一个节点给出的结论是 -1，但是 'l' 并不是0，那么说明这个匹配是失败的，需要将 本节点的 r 置到 max 处。 <p> 返回值 <ul> <li><b>-1</b> - 全部被匹配 <li><b>0</b> - 未发现匹配 <li><b>大于 0</b> - 在缓冲的末尾发现匹配，但是没有匹配全，希望下一个节点继续从这个位置匹配 </ul>
 * @param bs 数组
 * @return -1, 0 或者 +n
 */
int mark(byte[] bs){
  if (!isLoaded)   throw new MarkUnloadedRingItemException();
  byte start=bs[0];
  for (; r < max; r++) {
    if (buffer[r] == start) {
      int re=0;
      int j=r;
      while (true) {
        re++;
        j++;
        if (re >= bs.length || j >= max)         break;
        if (bs[re] != buffer[j])         break;
      }
      if (re == bs.length) {
        nextmark=j;
        return -1;
      }
 else       if (j == max) {
        nextmark=max;
        if (isStreamEnd) {
          r=max;
          return 0;
        }
        return re;
      }
      r=j;
    }
  }
  nextmark=max;
  return 0;
}","/** 
 * 从给定 offs 尽力匹配给出的数组。 <p> 需要注意的是，如果返回的是 >0 的数，内部的标志位将被设置到第一个匹配字符，以便 DUMP 内容。 <br> 所以，如果下一个节点给出的结论是 -1，但是 'l' 并不是0，那么说明这个匹配是失败的，需要将 本节点的 r 置到 max 处。 <p> 返回值 <ul> <li><b>-1</b> - 全部被匹配 <li><b>0</b> - 未发现匹配 <li><b>大于 0</b> - 在缓冲的末尾发现匹配，但是没有匹配全，希望下一个节点继续从这个位置匹配 </ul>
 * @param bs 数组
 * @return -1, 0 或者 +n
 */
int mark(byte[] bs,int[] fails){
  if (!isLoaded)   throw new MarkUnloadedRingItemException();
  byte start=bs[0];
  for (; r < max; r++) {
    if (buffer[r] == start) {
      int re=0;
      int j=r;
      while (true) {
        re++;
        j++;
        if (re == bs.length) {
          nextmark=j;
          return -1;
        }
        if (j == max) {
          nextmark=max;
          if (isStreamEnd) {
            r=max;
            return 0;
          }
          return re;
        }
        if (bs[re] != buffer[j]) {
          re=fails[re];
          if (bs[re] != buffer[j]) {
            break;
          }
 else {
            r+=re == 0 ? 1 : re;
          }
        }
      }
      r=j;
    }
  }
  nextmark=max;
  return 0;
}"
80903,"@Test public void test_normal_read() throws IOException {
  byte[] boundary=Lang.toBytes(""String_Node_Str"".toCharArray());
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  RingItem ri;
  br.load();
  assertEquals(15,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.NOT_FOUND,mode);
  s=br.dumpAsString();
  assertEquals('1',(char)br.item.buffer[0]);
  assertTrue(br.item.isDone4Mark());
  assertFalse(br.item.isLoaded);
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(3,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(1,ri.l);
  assertEquals(1,ri.r);
  assertEquals(1,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next.next;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(0,ri.r);
  assertEquals(0,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(1,ri.l);
  assertEquals(2,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(0,ri.r);
  assertEquals(0,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next.next;
  assertFalse(ri.isLoaded);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(1,ri.r);
  assertEquals(4,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next;
  assertFalse(ri.isLoaded);
  ri=br.item.next.next;
  assertFalse(ri.isLoaded);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(4,ri.l);
  assertEquals(4,ri.r);
  assertEquals(4,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(35,br.readed);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(4,ri.l);
  assertEquals(4,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(2,ri.l);
  assertEquals(2,ri.r);
  assertEquals(2,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next.next;
  assertFalse(ri.isLoaded);
  s=br.dumpAsString();
  assertEquals('-',(char)br.item.buffer[0]);
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(35,br.readed);
  mode=br.mark(boundary);
  assertEquals(38,br.readed);
  assertTrue(br.item.next.isStreamEnd);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(2,ri.l);
  assertEquals(5,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(3,ri.r);
  assertEquals(3,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}","@Test public void test_normal_read() throws IOException {
  RemountBytes boundary=RemountBytes.create(""String_Node_Str"");
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  RingItem ri;
  br.load();
  assertEquals(15,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.NOT_FOUND,mode);
  s=br.dumpAsString();
  assertEquals('1',(char)br.item.buffer[0]);
  assertTrue(br.item.isDone4Mark());
  assertFalse(br.item.isLoaded);
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(3,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(1,ri.l);
  assertEquals(1,ri.r);
  assertEquals(1,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next.next;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(0,ri.r);
  assertEquals(0,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(1,ri.l);
  assertEquals(2,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(0,ri.r);
  assertEquals(0,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next.next;
  assertFalse(ri.isLoaded);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(1,ri.r);
  assertEquals(4,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next;
  assertFalse(ri.isLoaded);
  ri=br.item.next.next;
  assertFalse(ri.isLoaded);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(4,ri.l);
  assertEquals(4,ri.r);
  assertEquals(4,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  br.load();
  assertEquals(30,br.readed);
  mode=br.mark(boundary);
  assertEquals(35,br.readed);
  assertEquals(MarkMode.FOUND,mode);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(4,ri.l);
  assertEquals(4,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(2,ri.l);
  assertEquals(2,ri.r);
  assertEquals(2,ri.nextmark);
  assertFalse(ri.isDone4Mark());
  ri=br.item.next.next;
  assertFalse(ri.isLoaded);
  s=br.dumpAsString();
  assertEquals('-',(char)br.item.buffer[0]);
  assertEquals(""String_Node_Str"",s);
  br.load();
  assertEquals(35,br.readed);
  mode=br.mark(boundary);
  assertEquals(38,br.readed);
  assertTrue(br.item.next.isStreamEnd);
  ri=br.item;
  assertTrue(ri.isLoaded);
  assertEquals(2,ri.l);
  assertEquals(5,ri.r);
  assertEquals(5,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  ri=br.item.next;
  assertTrue(ri.isLoaded);
  assertEquals(0,ri.l);
  assertEquals(3,ri.r);
  assertEquals(3,ri.nextmark);
  assertTrue(ri.isDone4Mark());
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}"
80904,"@Test public void test_by_buffer2() throws IOException {
  byte[] boundary=Lang.toBytes(""String_Node_Str"".toCharArray());
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  br.skipMark();
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  assertEquals(25,br.readed);
}","@Test public void test_by_buffer2() throws IOException {
  RemountBytes boundary=RemountBytes.create(""String_Node_Str"");
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  br.skipMark();
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  assertEquals(25,br.readed);
}"
80905,"@Test public void test_by_buffer() throws IOException {
  byte[] boundary=Lang.toBytes(""String_Node_Str"".toCharArray());
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  br.skipMark();
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  assertEquals(27,br.readed);
}","@Test public void test_by_buffer() throws IOException {
  RemountBytes boundary=RemountBytes.create(""String_Node_Str"");
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  br.skipMark();
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  assertEquals(27,br.readed);
}"
80906,"@Test public void test_mark_dangerous_char() throws IOException {
  byte[] boundary=Lang.toBytes(""String_Node_Str"".toCharArray());
  String str=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}","@Test public void test_mark_dangerous_char() throws IOException {
  RemountBytes boundary=RemountBytes.create(""String_Node_Str"");
  String str=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}"
80907,"@Test public void test_mark_dangerous_char2() throws IOException {
  byte[] boundary=Lang.toBytes(""String_Node_Str"".toCharArray());
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}","@Test public void test_mark_dangerous_char2() throws IOException {
  RemountBytes boundary=RemountBytes.create(""String_Node_Str"");
  String str=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,10);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}"
80908,"@Test public void test_cross_ring_item() throws IOException {
  byte[] boundary=Lang.toBytes(""String_Node_Str"".toCharArray());
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.NOT_FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}","@Test public void test_cross_ring_item() throws IOException {
  RemountBytes boundary=RemountBytes.create(""String_Node_Str"");
  String str=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  str+=""String_Node_Str"";
  InputStream ins=Lang.ins(str);
  BufferRing br=new BufferRing(ins,3,5);
  String s;
  MarkMode mode;
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.NOT_FOUND,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
  br.load();
  mode=br.mark(boundary);
  assertEquals(MarkMode.STREAM_END,mode);
  s=br.dumpAsString();
  assertEquals(""String_Node_Str"",s);
}"
80909,"@Test public void test_case_A(){
  RemountBytes rb=RB(""String_Node_Str"");
  assertEquals(0,rb.pos[0]);
  assertEquals(0,rb.pos[1]);
  assertEquals(1,rb.pos[2]);
  assertEquals(0,rb.pos[3]);
}","@Test public void test_case_A(){
  RemountBytes rb=RB(""String_Node_Str"");
  assertEquals(0,rb.fails[0]);
  assertEquals(0,rb.fails[1]);
  assertEquals(1,rb.fails[2]);
  assertEquals(0,rb.fails[3]);
}"
80910,"@Test public void test_case_C(){
  RemountBytes rb=RB(""String_Node_Str"");
  assertEquals(0,rb.pos[0]);
  assertEquals(0,rb.pos[1]);
  assertEquals(0,rb.pos[2]);
  assertEquals(0,rb.pos[3]);
  assertEquals(0,rb.pos[4]);
  assertEquals(0,rb.pos[5]);
  assertEquals(3,rb.pos[6]);
}","@Test public void test_case_C(){
  RemountBytes rb=RB(""String_Node_Str"");
  assertEquals(0,rb.fails[0]);
  assertEquals(0,rb.fails[1]);
  assertEquals(0,rb.fails[2]);
  assertEquals(0,rb.fails[3]);
  assertEquals(1,rb.fails[4]);
  assertEquals(2,rb.fails[5]);
  assertEquals(3,rb.fails[6]);
}"
80911,"@Test public void test_case_B(){
  RemountBytes rb=RB(""String_Node_Str"");
  assertEquals(0,rb.pos[0]);
  assertEquals(0,rb.pos[1]);
  assertEquals(0,rb.pos[2]);
  assertEquals(0,rb.pos[3]);
  assertEquals(2,rb.pos[4]);
}","@Test public void test_case_B(){
  RemountBytes rb=RB(""String_Node_Str"");
  assertEquals(0,rb.fails[0]);
  assertEquals(0,rb.fails[1]);
  assertEquals(0,rb.fails[2]);
  assertEquals(1,rb.fails[3]);
  assertEquals(2,rb.fails[4]);
}"
80912,"Exp(String name,String op,Object value){
  this.name=name;
  this.op=Strings.trim(op);
  if (ptn.matcher(this.op).find())   this.op=""String_Node_Str"" + this.op + ""String_Node_Str"";
  this.value=value;
}","Exp(String name,String op,Object value){
  this.name=name;
  this.op=Strings.trim(op);
  if (ptn.matcher(this.op).find())   this.op=this.op.toUpperCase();
  this.value=value;
}"
80913,"public void render(StringBuilder sb,Entity<?> en){
  if (null != en) {
    EntityField ef=en.getField(name);
    sb.append(null != ef ? ef.getColumnName() : name);
  }
 else   sb.append(name);
  sb.append(op);
  sb.append(Sqls.formatFieldValue(value));
}","public void render(final StringBuilder sb,Entity<?> en){
  if (null != en) {
    EntityField ef=en.getField(name);
    sb.append(null != ef ? ef.getColumnName() : name);
  }
 else   sb.append(name);
  if (""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"");
    if (null == value)     throw Lang.makeThrow(""String_Node_Str"",sb);
    if (value instanceof Collection<?> || value.getClass().isArray()) {
      sb.append('(');
      Lang.each(value,new Each<Object>(){
        public void invoke(        int i,        Object ele,        int length) throws ExitLoop, LoopException {
          sb.append(Sqls.formatFieldValue(ele)).append(',');
        }
      }
);
      sb.setCharAt(sb.length() - 1,')');
    }
 else     sb.append(Sqls.formatFieldValue(value));
  }
 else   if (null == value && ""String_Node_Str"".equals(op)) {
    sb.append(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(op) || ""String_Node_Str"".equals(op)) {
    sb.append(' ').append(op).append(' ').append(Sqls.formatFieldValue(value));
  }
 else {
    sb.append(op).append(Sqls.formatFieldValue(value));
  }
}"
80914,"public Map<String,Object> parse(HttpServletRequest req,String charset,FilePool tmps) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  Map<String,Object> params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  byte[] firstBoundaryBytes=Lang.toBytes(firstBoundary.toCharArray());
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  byte[] itemEndlBytes=Lang.toBytes(itemEndl.toCharArray());
  byte[] nameEndlBytes=Lang.toBytes(""String_Node_Str"".toCharArray());
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  FieldMeta meta;
  try {
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString();
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            do {
              info.current=br.load();
              mm=br.mark(itemEndlBytes);
              assertStreamNotEnd(mm);
              br.dump(ops);
            }
 while (mm == MarkMode.NOT_FOUND);
          }
  finally {
            Streams.safeClose(ops);
          }
          params.put(meta.getName(),new TempFile(meta,tmp));
        }
      }
 else {
        StreamBuffer sb=new StreamBuffer();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          br.dump(sb.getBuffer());
        }
 while (mm == MarkMode.NOT_FOUND);
        params.put(meta.getName(),sb.toString(charset));
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}","public Map<String,Object> parse(HttpServletRequest req,String charset,FilePool tmps) throws UploadException {
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + Mvcs.getRequestPath(req));
  UploadInfo info=Uploads.createInfo(req);
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  NutMap params=Uploads.createParamsMap(req);
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",params.size());
  String firstBoundary=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  byte[] firstBoundaryBytes=Lang.toBytes(firstBoundary.toCharArray());
  String itemEndl=""String_Node_Str"" + Http.multipart.getBoundary(req.getContentType());
  byte[] itemEndlBytes=Lang.toBytes(itemEndl.toCharArray());
  byte[] nameEndlBytes=Lang.toBytes(""String_Node_Str"".toCharArray());
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"" + itemEndl);
  MarkMode mm;
  BufferRing br;
  try {
    ServletInputStream ins=req.getInputStream();
    br=new BufferRing(ins,3,bufferSize);
    info.current=br.load();
    mm=br.mark(firstBoundaryBytes);
    if (mm != MarkMode.FOUND) {
      if (log.isWarnEnabled())       log.warnf(""String_Node_Str"",firstBoundary);
      return params;
    }
    br.skipMark();
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (log.isDebugEnabled())   log.debug(""String_Node_Str"");
  FieldMeta meta;
  try {
    do {
      info.current=br.load();
      mm=br.mark(nameEndlBytes);
      String s=br.dumpAsString();
      if (""String_Node_Str"".equals(s) || MarkMode.STREAM_END == mm) {
        break;
      }
 else       if (MarkMode.FOUND == mm) {
        meta=new FieldMeta(s);
      }
 else {
        throw new UploadInvalidFormatException(""String_Node_Str"");
      }
      if (meta.isFile()) {
        if (Strings.isBlank(meta.getFileLocalPath())) {
          do {
            info.current=br.load();
            mm=br.mark(itemEndlBytes);
            assertStreamNotEnd(mm);
            br.skipMark();
          }
 while (mm == MarkMode.NOT_FOUND);
        }
 else {
          File tmp=tmps.createFile(meta.getFileExtension());
          OutputStream ops=null;
          try {
            ops=new BufferedOutputStream(new FileOutputStream(tmp),bufferSize * 2);
            do {
              info.current=br.load();
              mm=br.mark(itemEndlBytes);
              assertStreamNotEnd(mm);
              br.dump(ops);
            }
 while (mm == MarkMode.NOT_FOUND);
          }
  finally {
            Streams.safeClose(ops);
          }
          params.add(meta.getName(),new TempFile(meta,tmp));
        }
      }
 else {
        StreamBuffer sb=new StreamBuffer();
        do {
          info.current=br.load();
          mm=br.mark(itemEndlBytes);
          assertStreamNotEnd(mm);
          br.dump(sb.getBuffer());
        }
 while (mm == MarkMode.NOT_FOUND);
        params.add(meta.getName(),sb.toString(charset));
      }
    }
 while (mm != MarkMode.STREAM_END);
  }
 catch (  Exception e) {
    throw Lang.wrapThrow(e,UploadException.class);
  }
 finally {
    br.close();
  }
  if (log.isDebugEnabled())   log.debugf(""String_Node_Str"",br.readed());
  return params;
}"
80915,"/** 
 * 根据请求对象创建参数 MAP， 同时根据 QueryString，为 MAP 设置初始值
 * @param req 请求对象
 * @return 参数 MAP
 */
public static Map<String,Object> createParamsMap(HttpServletRequest req){
  Map<String,Object> params=new HashMap<String,Object>();
  String qs=req.getQueryString();
  if (null != qs) {
    String[] pairs=Strings.splitIgnoreBlank(qs,""String_Node_Str"");
    for (    String pair : pairs) {
      String[] pp=pair.split(""String_Node_Str"");
      if (pp.length > 1)       params.put(pp[0],pp[1]);
 else       params.put(pp[0],null);
    }
  }
  return params;
}","/** 
 * 根据请求对象创建参数 MAP， 同时根据 QueryString，为 MAP 设置初始值
 * @param req 请求对象
 * @return 参数 MAP
 */
public static NutMap createParamsMap(HttpServletRequest req){
  NutMap params=new NutMap();
  String qs=req.getQueryString();
  if (null != qs) {
    String[] pairs=Strings.splitIgnoreBlank(qs,""String_Node_Str"");
    for (    String pair : pairs) {
      String[] pp=pair.split(""String_Node_Str"");
      if (pp.length > 1)       params.put(pp[0],pp[1]);
 else       params.put(pp[0],null);
    }
  }
  return params;
}"
80916,"public void update(Dao dao,Object obj){
  if (null == obj)   return;
  Sql sql=this.sql.duplicate();
  if (vars.length > 0) {
    sql.vars().set(""String_Node_Str"",ef.getEntity().getViewName());
    sql.vars().set(""String_Node_Str"",ef.getColumnName());
    Object refer=TableName.get();
    if (null != refer) {
      if (TableName.isPrimitive(refer))       for (      String var : vars)       if (var.equals(""String_Node_Str"") || var.equals(""String_Node_Str""))       continue;
 else       sql.vars().set(var,refer);
 else {
        Mirror<?> me=Mirror.me(refer.getClass());
        for (        String var : vars) {
          if (var.equals(""String_Node_Str"") || var.equals(""String_Node_Str""))           continue;
 else {
            Object v=me.getValue(refer,var);
            sql.vars().set(var,v);
          }
        }
      }
    }
  }
  if (params.length > 0) {
    Mirror<?> me=Mirror.me(obj.getClass());
    for (    Field f : params) {
      Object v=me.getValue(obj,f);
      sql.params().set(f.getName(),v);
    }
  }
  dao.execute(sql);
  ef.setValue(obj,sql.getResult());
}","public void update(Dao dao,Object obj){
  if (null == obj)   return;
  Sql sql=this.sql.duplicate();
  if (vars.length > 0) {
    sql.vars().set(""String_Node_Str"",ef.getEntity().getViewName());
    sql.vars().set(""String_Node_Str"",ef.getColumnName());
    Object refer=TableName.get();
    if (null == refer)     refer=obj;
    if (null != refer) {
      if (TableName.isPrimitive(refer))       for (      String var : vars)       if (var.equals(""String_Node_Str"") || var.equals(""String_Node_Str""))       continue;
 else       sql.vars().set(var,refer);
 else {
        Mirror<?> me=Mirror.me(refer.getClass());
        for (        String var : vars) {
          if (var.equals(""String_Node_Str"") || var.equals(""String_Node_Str""))           continue;
 else {
            Object v=me.getValue(refer,var);
            sql.vars().set(var,v);
          }
        }
      }
    }
  }
  if (params.length > 0) {
    Mirror<?> me=Mirror.me(obj.getClass());
    for (    Field f : params) {
      Object v=me.getValue(obj,f);
      sql.params().set(f.getName(),v);
    }
  }
  dao.execute(sql);
  ef.setValue(obj,sql.getResult());
}"
80917,"@SuppressWarnings(""String_Node_Str"") private void map2Json(Map map) throws IOException {
  if (null == map)   return;
  appendBraceBegin();
  increaseFormatIndent();
  ArrayList<Pair> list=new ArrayList<Pair>(map.size());
  for (  Object key : map.keySet()) {
    String name=null == key ? ""String_Node_Str"" : key.toString();
    Object value=map.get(name);
    if (!this.isIgnore(name,value))     list.add(new Pair(name,value));
  }
  for (Iterator<Pair> it=list.iterator(); it.hasNext(); ) {
    Pair p=it.next();
    this.appendPair(p.name,p.value);
    if (it.hasNext())     this.appendPairEnd();
  }
  decreaseFormatIndent();
  appendBraceEnd();
}","@SuppressWarnings(""String_Node_Str"") private void map2Json(Map map) throws IOException {
  if (null == map)   return;
  appendBraceBegin();
  increaseFormatIndent();
  ArrayList<Pair> list=new ArrayList<Pair>(map.size());
  for (  Object key : map.keySet()) {
    String name=null == key ? ""String_Node_Str"" : key.toString();
    Object value=map.get(key);
    if (!this.isIgnore(name,value))     list.add(new Pair(name,value));
  }
  for (Iterator<Pair> it=list.iterator(); it.hasNext(); ) {
    Pair p=it.next();
    this.appendPair(p.name,p.value);
    if (it.hasNext())     this.appendPairEnd();
  }
  decreaseFormatIndent();
  appendBraceEnd();
}"
80918,"public Object get(HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object obj=mirror.born();
  for (int i=0; i < injs.length; i++) {
    Injecting inj=injs[i];
    String s=req.getParameter(names[i]);
    if (Strings.isBlank(s))     s=null;
    inj.inject(obj,s);
  }
  return obj;
}","public Object get(HttpServletRequest req,HttpServletResponse resp,Object refer){
  Object obj=mirror.born();
  for (int i=0; i < injs.length; i++) {
    Injecting inj=injs[i];
    String s=req.getParameter(names[i]);
    if (null == s)     continue;
    if (Strings.isBlank(s))     s=null;
    inj.inject(obj,s);
  }
  return obj;
}"
80919,"/** 
 * 清除数据表所有记录
 * @param tableName 表名
 */
void clear(String tableName);","/** 
 * 清除数据表所有记录
 * @param tableName 表名
 * @return 影响的行数
 */
int clear(String tableName);"
80920,"public void clear(String tableName,Condition condition){
  Sql sql;
  if (null == condition) {
    sql=sqlMaker.truncate(tableName);
  }
 else {
    sql=sqlMaker.clear(tableName).setCondition(condition);
  }
  execute(sql);
}","public int clear(String tableName,Condition condition){
  Sql sql;
  if (null == condition) {
    sql=sqlMaker.truncate(tableName);
  }
 else {
    sql=sqlMaker.clear(tableName).setCondition(condition);
  }
  execute(sql);
  return sql.getUpdateCount();
}"
80921,"public void clear(){
  dao().clear(getEntityClass(),null);
}","public int clear(){
  return dao().clear(getEntityClass(),null);
}"
80922,"public void delete(long id){
  dao().delete(getEntityClass(),id);
}","public int delete(long id){
  return dao().delete(getEntityClass(),id);
}"
80923,"public void delete(String name){
  dao().delete(getEntityClass(),name);
}","public int delete(String name){
  return dao().delete(getEntityClass(),name);
}"
80924,"public void delete(String name){
  dao().delete(getEntityClass(),name);
}","public int delete(String name){
  return dao().delete(getEntityClass(),name);
}"
80925,"@SuppressWarnings(""String_Node_Str"") public <T>T fetch(T obj){
  if (null != obj) {
    Entity<?> entity=(Entity)getEntity(obj.getClass());
    EntityField idnf=entity.getIdentifiedField();
    Sql sql;
    if (idnf == null) {
      Object[] args=evalArgsByPks(entity,obj);
      if (null != args) {
        sql=sqlMaker.fetchx(entity,args);
      }
 else {
        throw new DaoException(format(""String_Node_Str"",entity.getType().getName()));
      }
    }
 else {
      sql=sqlMaker.fetch(entity,idnf);
      sql.params().set(idnf.getFieldName(),idnf.getValue(obj));
    }
    execute(sql);
    return sql.getObject((Class<T>)entity.getType());
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public <T>T fetch(T obj){
  if (null != obj) {
    Entity<?> entity=(Entity)getEntity(obj.getClass());
    EntityField idnf=entity.getIdentifiedField();
    Sql sql;
    if (idnf == null) {
      Object[] args=evalArgsByPks(entity,obj);
      if (null != args) {
        sql=sqlMaker.fetchx(entity,args);
      }
 else {
        throw new DaoException(format(""String_Node_Str"",entity.getType().getName()));
      }
    }
 else {
      sql=sqlMaker.fetch(entity,idnf);
      sql.params().set(idnf.getName(),idnf.getValue(obj));
    }
    execute(sql);
    return sql.getObject((Class<T>)entity.getType());
  }
  return null;
}"
80926,"public Sql insert(Entity<?> en,Object obj){
  StringBuilder fields=new StringBuilder();
  StringBuilder values=new StringBuilder();
  FieldMatcher fm=FieldFilter.get(en.getType());
  Map<String,Object> map=new HashMap<String,Object>();
  for (Iterator<EntityField> it=en.fields().iterator(); it.hasNext(); ) {
    EntityField ef=it.next();
    String fn=ef.getFieldName();
    if (ef.isSerial() || ef.isReadonly())     continue;
    Object value=ef.getValue(obj);
    if (null != fm) {
      if (fm.isIgnoreNull() && null == value)       continue;
 else       if (!fm.match(fn))       continue;
    }
 else     if (null == value) {
      if (ef.hasDefaultValue())       value=ef.getDefaultValue(obj);
 else       continue;
    }
    fields.append(',').append(ef.getColumnName());
    values.append(""String_Node_Str"").append(fn);
    map.put(fn,value);
  }
  fields.deleteCharAt(0);
  values.deleteCharAt(0);
  Sql sql=Sqls.create(format(""String_Node_Str"",en.getTableName(),fields,values)).setEntity(en);
  sql.params().putAll(map);
  return sql;
}","public Sql insert(Entity<?> en,Object obj){
  StringBuilder fields=new StringBuilder();
  StringBuilder values=new StringBuilder();
  FieldMatcher fm=FieldFilter.get(en.getType());
  Map<String,Object> map=new HashMap<String,Object>();
  for (Iterator<EntityField> it=en.fields().iterator(); it.hasNext(); ) {
    EntityField ef=it.next();
    String fn=ef.getName();
    if (ef.isSerial() || ef.isReadonly())     continue;
    Object value=ef.getValue(obj);
    if (null != fm) {
      if (fm.isIgnoreNull() && null == value)       continue;
 else       if (!fm.match(fn))       continue;
    }
 else     if (null == value) {
      if (ef.hasDefaultValue())       value=ef.getDefaultValue(obj);
 else       continue;
    }
    fields.append(',').append(ef.getColumnName());
    values.append(""String_Node_Str"").append(fn);
    map.put(fn,value);
  }
  fields.deleteCharAt(0);
  values.deleteCharAt(0);
  Sql sql=Sqls.create(format(""String_Node_Str"",en.getTableName(),fields,values)).setEntity(en);
  sql.params().putAll(map);
  return sql;
}"
80927,"public Sql update(Entity<?> en,Object obj){
  StringBuilder sb=new StringBuilder();
  FieldMatcher fm=FieldFilter.get(en.getType());
  Map<String,Object> map=new HashMap<String,Object>();
  for (Iterator<EntityField> it=en.fields().iterator(); it.hasNext(); ) {
    EntityField ef=it.next();
    String fn=ef.getFieldName();
    if (ef == en.getIdentifiedField() || ef.isPk() || ef.isReadonly())     continue;
    Object value=ef.getValue(obj);
    if (null != fm) {
      if (fm.isIgnoreNull() && null == value)       continue;
 else       if (!fm.match(fn))       continue;
    }
    sb.append(',').append(ef.getColumnName()).append('=').append(""String_Node_Str"").append(fn);
    map.put(fn,value);
  }
  sb.deleteCharAt(0);
  EntityField idf=en.getIdentifiedField();
  if (null != idf) {
    String fmt=format(""String_Node_Str"",en.getTableName(),sb,idf.getColumnName(),idf.getFieldName());
    Sql sql=Sqls.create(fmt).setEntity(en);
    sql.params().putAll(map).set(idf.getFieldName(),idf.getValue(obj));
    return sql;
  }
  EntityField[] pks=en.getPkFields();
  if (null == pks || pks.length <= 1) {
    throw Lang.makeThrow(""String_Node_Str"",en.getType());
  }
  Object[] args=new Object[pks.length];
  for (int i=0; i < args.length; i++) {
    args[i]=pks[i].getValue(obj);
  }
  String fmt=format(""String_Node_Str"",en.getTableName(),sb);
  Sql sql=Sqls.create(fmt).setEntity(en);
  sql.params().putAll(map);
  sql.setCondition(new PkCondition(args));
  return sql;
}","public Sql update(Entity<?> en,Object obj){
  StringBuilder sb=new StringBuilder();
  FieldMatcher fm=FieldFilter.get(en.getType());
  Map<String,Object> map=new HashMap<String,Object>();
  for (Iterator<EntityField> it=en.fields().iterator(); it.hasNext(); ) {
    EntityField ef=it.next();
    String fn=ef.getName();
    if (ef == en.getIdentifiedField() || ef.isPk() || ef.isReadonly())     continue;
    Object value=ef.getValue(obj);
    if (null != fm) {
      if (fm.isIgnoreNull() && null == value)       continue;
 else       if (!fm.match(fn))       continue;
    }
    sb.append(',').append(ef.getColumnName()).append('=').append(""String_Node_Str"").append(fn);
    map.put(fn,value);
  }
  sb.deleteCharAt(0);
  EntityField idf=en.getIdentifiedField();
  if (null != idf) {
    String fmt=format(""String_Node_Str"",en.getTableName(),sb,idf.getColumnName(),idf.getName());
    Sql sql=Sqls.create(fmt).setEntity(en);
    sql.params().putAll(map).set(idf.getName(),idf.getValue(obj));
    return sql;
  }
  EntityField[] pks=en.getPkFields();
  if (null == pks || pks.length <= 1) {
    throw Lang.makeThrow(""String_Node_Str"",en.getType());
  }
  Object[] args=new Object[pks.length];
  for (int i=0; i < args.length; i++) {
    args[i]=pks[i].getValue(obj);
  }
  String fmt=format(""String_Node_Str"",en.getTableName(),sb);
  Sql sql=Sqls.create(fmt).setEntity(en);
  sql.params().putAll(map);
  sql.setCondition(new PkCondition(args));
  return sql;
}"
80928,"public Sql delete(Entity<?> entity,EntityField ef){
  return Sqls.create(format(""String_Node_Str"",entity.getTableName(),ef.getColumnName(),ef.getFieldName())).setEntity(entity);
}","public Sql delete(Entity<?> entity,EntityField ef){
  return Sqls.create(format(""String_Node_Str"",entity.getTableName(),ef.getColumnName(),ef.getName())).setEntity(entity);
}"
80929,"public Sql fetch(Entity<?> entity,EntityField ef){
  String fields=evalActivedFields(entity);
  String fmt;
  if (ef == null) {
    fmt=format(""String_Node_Str"",fields,entity.getViewName());
  }
 else   if (ef.isName() && !ef.isCasesensitive()) {
    fmt=format(""String_Node_Str"",fields,entity.getViewName(),ef.getColumnName(),ef.getFieldName());
  }
 else {
    fmt=format(""String_Node_Str"",fields,entity.getViewName(),ef.getColumnName(),ef.getFieldName());
  }
  return Sqls.fetchEntity(fmt).setEntity(entity);
}","public Sql fetch(Entity<?> entity,EntityField ef){
  String fields=evalActivedFields(entity);
  String fmt;
  if (ef == null) {
    fmt=format(""String_Node_Str"",fields,entity.getViewName());
  }
 else   if (ef.isName() && !ef.isCasesensitive()) {
    fmt=format(""String_Node_Str"",fields,entity.getViewName(),ef.getColumnName(),ef.getName());
  }
 else {
    fmt=format(""String_Node_Str"",fields,entity.getViewName(),ef.getColumnName(),ef.getName());
  }
  return Sqls.fetchEntity(fmt).setEntity(entity);
}"
80930,"public boolean exists(long id){
  EntityField ef=getEntity().getIdField();
  if (null == ef)   return false;
  return dao().count(getEntityClass(),Cnd.where(ef.getFieldName(),""String_Node_Str"",id)) > 0;
}","public boolean exists(long id){
  EntityField ef=getEntity().getIdField();
  if (null == ef)   return false;
  return dao().count(getEntityClass(),Cnd.where(ef.getName(),""String_Node_Str"",id)) > 0;
}"
80931,"public boolean exists(String name){
  EntityField ef=getEntity().getNameField();
  if (null == ef)   return false;
  return dao().count(getEntityClass(),Cnd.where(ef.getFieldName(),""String_Node_Str"",name)) > 0;
}","public boolean exists(String name){
  EntityField ef=getEntity().getNameField();
  if (null == ef)   return false;
  return dao().count(getEntityClass(),Cnd.where(ef.getName(),""String_Node_Str"",name)) > 0;
}"
80932,"public boolean exists(String name){
  EntityField ef=getEntity().getNameField();
  if (null == ef)   return false;
  return dao().count(getEntityClass(),Cnd.where(ef.getFieldName(),""String_Node_Str"",name)) > 0;
}","public boolean exists(String name){
  EntityField ef=getEntity().getNameField();
  if (null == ef)   return false;
  return dao().count(getEntityClass(),Cnd.where(ef.getName(),""String_Node_Str"",name)) > 0;
}"
80933,"private void pojo2Json(Object obj) throws IOException {
  if (null == obj)   return;
  Class<? extends Object> type=obj.getClass();
  ToJson tj=type.getAnnotation(ToJson.class);
  String myMethodName=Strings.sNull(null == tj ? null : tj.value(),""String_Node_Str"");
  Method myMethod;
  try {
    myMethod=type.getMethod(myMethodName);
    Object re=myMethod.invoke(obj);
    writer.append(re.toString());
    return;
  }
 catch (  Exception e1) {
    try {
      myMethod=type.getMethod(myMethodName,JsonFormat.class);
      Object re=myMethod.invoke(obj,format);
      writer.append(re.toString());
      return;
    }
 catch (    Exception e) {
    }
  }
  Mirror<?> me=Mirror.me(type);
  Field[] fields=me.getFields();
  appendBraceBegin();
  increaseFormatIndent();
  ArrayList<Pair> list=new ArrayList<Pair>(fields.length);
  for (  Field f : fields) {
    String name=f.getName();
    try {
      Object value=me.getValue(obj,f);
      if (!this.isIgnore(name,value))       list.add(new Pair(name,value));
    }
 catch (    FailToGetValueException e) {
    }
  }
  for (Iterator<Pair> it=list.iterator(); it.hasNext(); ) {
    Pair p=it.next();
    this.appendPair(p.name,p.value);
    if (it.hasNext())     this.appendPairEnd();
  }
  decreaseFormatIndent();
  appendBraceEnd();
}","private void pojo2Json(Object obj) throws IOException {
  if (null == obj)   return;
  Class<? extends Object> type=obj.getClass();
  ToJson tj=type.getAnnotation(ToJson.class);
  String myMethodName=Strings.sNull(null == tj ? null : tj.value(),""String_Node_Str"");
  Method myMethod;
  try {
    myMethod=type.getMethod(myMethodName);
    Object re=myMethod.invoke(obj);
    writer.append(re.toString());
    return;
  }
 catch (  Exception e1) {
    try {
      myMethod=type.getMethod(myMethodName,JsonFormat.class);
      Object re=myMethod.invoke(obj,format);
      writer.append(re.toString());
      return;
    }
 catch (    Exception e) {
    }
  }
  Mirror<?> me=Mirror.me(type);
  Field[] fields=me.getFields();
  appendBraceBegin();
  increaseFormatIndent();
  ArrayList<Pair> list=new ArrayList<Pair>(fields.length);
  for (  Field f : fields) {
    String name=f.getName();
    try {
      Object value=me.getValue(obj,name);
      if (!this.isIgnore(name,value))       list.add(new Pair(name,value));
    }
 catch (    FailToGetValueException e) {
    }
  }
  for (Iterator<Pair> it=list.iterator(); it.hasNext(); ) {
    Pair p=it.next();
    this.appendPair(p.name,p.value);
    if (it.hasNext())     this.appendPairEnd();
  }
  decreaseFormatIndent();
  appendBraceEnd();
}"
80934,"private void buildSQLMaps(){
  sqlMaps=new HashMap<String,String>();
  if (null != paths)   for (  String path : paths) {
    if (null == path)     continue;
    InputStream stream=Files.findFileAsStream(path);
    if (stream != null) {
      Reader reader=null;
      try {
        reader=new InputStreamReader(stream);
        loadSQL(reader);
      }
 catch (      IOException e) {
        Logs.getLog(getClass()).warnf(""String_Node_Str"",e);
      }
 finally {
        Streams.safeClose(reader);
        Streams.safeClose(stream);
      }
    }
  }
}","private void buildSQLMaps() throws MalformedURLException, IOException {
  sqlMaps=new HashMap<String,String>();
  if (null != paths)   for (  String path : paths) {
    if (null == path)     continue;
    File f=Files.findFile(Strings.trim(path));
    if (f == null || (!f.exists())) {
      InputStream stream=ClassLoaderUtil.getStream(path);
      if (stream != null) {
        InputStreamReader reader=null;
        try {
          reader=new InputStreamReader(stream,""String_Node_Str"");
          loadSQL(reader);
        }
  finally {
          Streams.safeClose(reader);
          Streams.safeClose(stream);
        }
      }
    }
 else {
      File[] files;
      if (f.isDirectory()) {
        files=f.listFiles(sqkFileFilter == null ? defaultSqkFileFilter : sqkFileFilter);
      }
 else       files=Lang.array(f);
      try {
        for (        File file : files) {
          Reader stream=Streams.fileInr(file);
          loadSQL(stream);
        }
      }
 catch (      Exception e) {
        throw Lang.wrapThrow(e);
      }
    }
  }
}"
80935,"@Test public void check_parse_comboSqls(){
  sqls=new FileSqlManager(""String_Node_Str"");
  ComboSql sql=sqls.createCombo();
  assertEquals(10,sql.count());
}","@Test public void check_parse_comboSqls(){
  SqlManager sqls=new FileSqlManager(""String_Node_Str"");
  ComboSql sql=sqls.createCombo();
  assertEquals(10,sql.count());
}"
80936,"@Test public void check_Query_SQL(){
  sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}","@Test public void check_Query_SQL(){
  SqlManager sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}"
80937,"@Test public void check_Update_SQL(){
  sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}","@Test public void check_Update_SQL(){
  SqlManager sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}"
80938,"@Test public void check_Fetch_SQL(){
  sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}","@Test public void check_Fetch_SQL(){
  SqlManager sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}"
80939,"@Test public void check_Create_SQL(){
  sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}","@Test public void check_Create_SQL(){
  SqlManager sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}"
80940,"@Test public void check_PersonTestSQLs(){
  sqls=new FileSqlManager(""String_Node_Str"");
  String[] keys={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < keys.length; i++) {
    assertEquals(keys[i],sqls.keys()[i]);
  }
}","@Test public void check_PersonTestSQLs(){
  SqlManager sqls=new FileSqlManager(""String_Node_Str"");
  String[] keys={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < keys.length; i++) {
    assertEquals(keys[i],sqls.keys()[i]);
  }
}"
80941,"@Test public void test_sqls_save() throws IOException {
  sqls=new FileSqlManager(""String_Node_Str"");
  int count=sqls.count();
  File f=Files.findFile(""String_Node_Str"");
  ((FileSqlManager)sqls).saveAs(f.getAbsolutePath());
  sqls=new FileSqlManager(""String_Node_Str"");
  assertEquals(count,sqls.count());
}","@Test public void test_sqls_save() throws IOException {
  SqlManager sqls=new FileSqlManager(""String_Node_Str"");
  int count=sqls.count();
  File f=Files.findFile(""String_Node_Str"");
  ((FileSqlManager)sqls).saveAs(f.getAbsolutePath());
  sqls=new FileSqlManager(""String_Node_Str"");
  assertEquals(count,sqls.count());
}"
80942,"@Test public void check_Insert_SQL(){
  sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}","@Test public void check_Insert_SQL(){
  SqlManager sqls=new FileSqlManager(PATH);
  Sql sql=sqls.create(""String_Node_Str"");
  assertTrue(sql.toString().toUpperCase().startsWith(""String_Node_Str""));
}"
80943,"@Test public void check_Count_SQL(){
  sqls=new FileSqlManager(PATH);
  assertEquals(10,sqls.count());
  String[] keys={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < keys.length; i++) {
    assertEquals(keys[i],sqls.keys()[i]);
  }
}","@Test public void check_Count_SQL(){
  SqlManager sqls=new FileSqlManager(PATH);
  assertEquals(10,sqls.count());
  String[] keys={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  for (int i=0; i < keys.length; i++) {
    assertEquals(keys[i],sqls.keys()[i]);
  }
}"
80944,"public Object get(IocMaking ing){
  return ing.getIoc().get(type,name);
}","public Object get(IocMaking ing){
  Ioc ioc=ing.getIoc();
  if (ioc instanceof Ioc2)   return ((Ioc2)ioc).get(type,name,ing.getContext());
  return ioc.get(type,name);
}"
80945,"public boolean equals(Object obj){
  Project p=(Project)obj;
  return id == p.id & name.equals(p.name) & alias.equals(p.alias);
}","public boolean equals(Object obj){
  Project p=(Project)obj;
  return id == p.id && name.equals(p.name) && alias.equals(p.alias);
}"
80946,"@SuppressWarnings(""String_Node_Str"") public ValueProxy make(IocMaking ing,IocValue iv){
  Object value=iv.getValue();
  String type=iv.getType();
  if (""String_Node_Str"".equals(type) || null == value) {
    return new StaticValue(null);
  }
 else   if (""String_Node_Str"".equals(type) || null == type) {
    if (value.getClass().isArray()) {
      return new ArrayValue(ing,(IocValue[])value);
    }
 else     if (value instanceof Map<?,?>) {
      return new MapValue(ing,(Map<String,IocValue>)value,(Class<? extends Map<String,Object>>)value.getClass());
    }
 else     if (value instanceof Collection<?>) {
      return new CollectionValue(ing,(Collection<IocValue>)value,(Class<? extends Collection<Object>>)value.getClass());
    }
 else     if (value instanceof IocObject) {
      return new InnerValue((IocObject)value);
    }
    return new StaticValue(value);
  }
 else   if (""String_Node_Str"".equals(type)) {
    String s=value.toString();
    if (""String_Node_Str"".equalsIgnoreCase(s)) {
      return new IocSelfValue();
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(s)) {
      return new ObjectNameValue();
    }
    return new ReferValue(s);
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new JavaValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new FileValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new EnvValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new InnerValue((IocObject)value);
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public ValueProxy make(IocMaking ing,IocValue iv){
  Object value=iv.getValue();
  String type=iv.getType();
  if (""String_Node_Str"".equals(type) || null == value) {
    return new StaticValue(null);
  }
 else   if (""String_Node_Str"".equals(type) || null == type) {
    if (value.getClass().isArray()) {
      return new ArrayValue(ing,(IocValue[])value);
    }
 else     if (value instanceof Map<?,?>) {
      return new MapValue(ing,(Map<String,IocValue>)value,(Class<? extends Map<String,Object>>)value.getClass());
    }
 else     if (value instanceof Collection<?>) {
      return new CollectionValue(ing,(Collection<IocValue>)value,(Class<? extends Collection<Object>>)value.getClass());
    }
 else     if (value instanceof IocObject) {
      return new InnerValue((IocObject)value);
    }
    return new StaticValue(value);
  }
 else   if (""String_Node_Str"".equals(type)) {
    String s=value.toString();
    if (""String_Node_Str"".equalsIgnoreCase(s)) {
      return new IocSelfValue();
    }
 else     if (""String_Node_Str"".equalsIgnoreCase(s)) {
      return new ObjectNameValue();
    }
    return new ReferValue(s);
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new JavaValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new FileValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new EnvValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new SysPropValue(value.toString());
  }
 else   if (""String_Node_Str"".equals(type)) {
    return new InnerValue((IocObject)value);
  }
  return null;
}"
80947,"private static String[] findInJar(String jarPath,Class<?> baseClass){
  try {
    jarPath=decodePath(jarPath);
    ZipEntry[] entrys=Files.findEntryInZip(new ZipFile(jarPath),baseClass.getPackage().getName().replace('.','/') + ""String_Node_Str"");
    if (null != entrys && entrys.length > 0) {
      String[] classNames=new String[entrys.length];
      for (int i=0; i < entrys.length; i++) {
        String ph=entrys[i].getName();
        classNames[i]=ph.substring(0,ph.lastIndexOf('.')).replaceAll(""String_Node_Str"",""String_Node_Str"");
      }
      return classNames;
    }
  }
 catch (  IOException e) {
  }
  return null;
}","private static String[] findInJar(String jarPath,Package packageA){
  try {
    jarPath=decodePath(jarPath);
    ZipEntry[] entrys=Files.findEntryInZip(new ZipFile(jarPath),packageA.getName().replace('.','/') + ""String_Node_Str"");
    if (null != entrys && entrys.length > 0) {
      String[] classNames=new String[entrys.length];
      for (int i=0; i < entrys.length; i++) {
        String ph=entrys[i].getName();
        classNames[i]=ph.substring(0,ph.lastIndexOf('.')).replaceAll(""String_Node_Str"",""String_Node_Str"");
      }
      return classNames;
    }
  }
 catch (  IOException e) {
  }
  return null;
}"
80948,"private static String[] findInClassPath(File dir,Class<?> classZ){
  try {
    File[] files=dir.listFiles(new FileFilter(){
      public boolean accept(      File pathname){
        return pathname.getName().endsWith(""String_Node_Str"");
      }
    }
);
    if (null != files && files.length > 0) {
      String[] classNames=new String[files.length];
      Package packageA=classZ.getPackage();
      for (int i=0; i < files.length; i++) {
        String fileName=files[i].getName();
        String classShortName=fileName.substring(0,fileName.length() - ""String_Node_Str"".length());
        classNames[i]=packageA.getName() + ""String_Node_Str"" + classShortName;
      }
      return classNames;
    }
  }
 catch (  SecurityException e) {
  }
  return null;
}","private static String[] findInClassPath(File dir,Package packageA){
  try {
    File[] files=dir.listFiles(new FileFilter(){
      public boolean accept(      File pathname){
        return pathname.getName().endsWith(""String_Node_Str"");
      }
    }
);
    if (null != files && files.length > 0) {
      String[] classNames=new String[files.length];
      for (int i=0; i < files.length; i++) {
        String fileName=files[i].getName();
        String classShortName=fileName.substring(0,fileName.length() - ""String_Node_Str"".length());
        classNames[i]=packageA.getName() + ""String_Node_Str"" + classShortName;
      }
      return classNames;
    }
  }
 catch (  SecurityException e) {
  }
  return null;
}"
80949,"/** 
 * It will list all Class object same package with the Class you give. Whatever the class file you give existed in normal directory or jar file.
 * @param baseClass
 * @return a class List
 */
public static List<Class<?>> scanClass(Class<?> baseClass){
  File dir=getBasePath(baseClass);
  if (dir == null)   return null;
  String[] classNames=null;
  String jarPath=getJarPath(dir);
  if (jarPath != null) {
    classNames=findInJar(jarPath,baseClass);
  }
 else   classNames=findInClassPath(dir,baseClass);
  if (classNames == null)   return null;
  List<Class<?>> list=new ArrayList<Class<?>>(classNames.length);
  for (  String className : classNames)   try {
    list.add(Class.forName(className));
  }
 catch (  Throwable e) {
  }
  return list;
}","/** 
 * It will list all Class object in the package you give. <p/>Whatever the class file you give existed in normal directory or jar file. <p/><b>Not working in GAE</b>
 * @return a class List
 * @throws NullPointerException when packageZ is null
 */
public static List<Class<?>> scanClass(File dir,Package packageZ){
  if (dir == null)   dir=Files.findFile(packageZ.getName().replaceAll(""String_Node_Str"",""String_Node_Str""));
  String[] classNames=null;
  String jarPath=getJarPath(dir);
  if (jarPath != null) {
    classNames=findInJar(jarPath,packageZ);
  }
 else   classNames=findInClassPath(dir,packageZ);
  if (classNames == null)   return null;
  List<Class<?>> list=new ArrayList<Class<?>>(classNames.length);
  for (  String className : classNames)   try {
    list.add(Class.forName(className));
  }
 catch (  Throwable e) {
  }
  return list;
}"
80950,"public void load(Class<?> mainModule){
  try {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    IocBy ib=mainModule.getAnnotation(IocBy.class);
    SetupBy sb=mainModule.getAnnotation(SetupBy.class);
    Views vms=mainModule.getAnnotation(Views.class);
    Localization lc=mainModule.getAnnotation(Localization.class);
    if (null != ib) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",ib.type().getName());
      ioc=ib.type().newInstance().create(config,ib.args());
      config.getServletContext().setAttribute(Ioc.class.getName(),ioc);
    }
 else     if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    ArrayList<ViewMaker> makers=new ArrayList<ViewMaker>();
    makers.add(new DefaultViewMaker());
    if (null != vms)     for (    Class<? extends ViewMaker> type : vms.value())     makers.add(type.newInstance());
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",mainModule.getName());
    urls=new UrlMapImpl(ioc,context);
    urls.setOk(mainModule.getAnnotation(Ok.class));
    urls.setFail(mainModule.getAnnotation(Fail.class));
    urls.setAdaptBy(mainModule.getAnnotation(AdaptBy.class));
    urls.setFilters(mainModule.getAnnotation(Filters.class));
    urls.setEncoding(mainModule.getAnnotation(Encoding.class));
    urls.add(makers,mainModule);
    Modules modules=mainModule.getAnnotation(Modules.class);
    if (null != modules)     for (    Class<?> module : modules.value()) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",module.getName());
      urls.add(makers,module);
    }
    config.getServletContext().setAttribute(UrlMap.class.getName(),urls);
    if (null != lc) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",lc.value());
      msgss=Mirror.me(lc.type()).born(lc.value()).load();
    }
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (null != sb) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      Setup setup=sb.value().newInstance();
      config.getServletContext().setAttribute(Setup.class.getName(),setup);
      setup.init(config);
    }
  }
 catch (  InstantiationException e) {
    throw Lang.wrapThrow(e);
  }
catch (  IllegalAccessException e) {
    throw Lang.wrapThrow(e);
  }
}","public void load(Class<?> mainModule){
  try {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    IocBy ib=mainModule.getAnnotation(IocBy.class);
    SetupBy sb=mainModule.getAnnotation(SetupBy.class);
    Views vms=mainModule.getAnnotation(Views.class);
    Localization lc=mainModule.getAnnotation(Localization.class);
    if (null != ib) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",ib.type().getName());
      ioc=ib.type().newInstance().create(config,ib.args());
      config.getServletContext().setAttribute(Ioc.class.getName(),ioc);
    }
 else     if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    ArrayList<ViewMaker> makers=new ArrayList<ViewMaker>();
    makers.add(new DefaultViewMaker());
    if (null != vms)     for (    Class<? extends ViewMaker> type : vms.value())     makers.add(type.newInstance());
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",mainModule.getName());
    urls=new UrlMapImpl(ioc,context);
    urls.setOk(mainModule.getAnnotation(Ok.class));
    urls.setFail(mainModule.getAnnotation(Fail.class));
    urls.setAdaptBy(mainModule.getAnnotation(AdaptBy.class));
    urls.setFilters(mainModule.getAnnotation(Filters.class));
    urls.setEncoding(mainModule.getAnnotation(Encoding.class));
    urls.add(makers,mainModule);
    Modules modules=mainModule.getAnnotation(Modules.class);
    if (null != modules) {
      for (      Class<?> module : modules.value()) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",module.getName());
        urls.add(makers,module);
      }
      for (      String packageZ : modules.packages()) {
        if (log.isDebugEnabled())         log.debugf(""String_Node_Str"",packageZ);
        List<Class<?>> list=Resources.scanClass(null,Package.getPackage(packageZ));
        if (list != null)         for (        Class<?> module : list) {
          if (log.isDebugEnabled())           log.debugf(""String_Node_Str"",module.getName());
          urls.add(makers,module);
        }
      }
    }
    config.getServletContext().setAttribute(UrlMap.class.getName(),urls);
    if (null != lc) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",lc.value());
      msgss=Mirror.me(lc.type()).born(lc.value()).load();
    }
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (null != sb) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      Setup setup=sb.value().newInstance();
      config.getServletContext().setAttribute(Setup.class.getName(),setup);
      setup.init(config);
    }
  }
 catch (  InstantiationException e) {
    throw Lang.wrapThrow(e);
  }
catch (  IllegalAccessException e) {
    throw Lang.wrapThrow(e);
  }
}"
80951,"private void unpackagePrivateData(Type type){
  if (type.equals(Type.BOOLEAN_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.BYTE_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.CHAR_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.SHORT_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.INT_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.LONG_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.FLOAT_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.DOUBLE_TYPE)) {
    mv.visitMethodInsn(INVOKEVIRTUAL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
}","private void unpackagePrivateData(Type type){
  if (type.equals(Type.BOOLEAN_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.BYTE_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.CHAR_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.SHORT_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.INT_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.LONG_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.FLOAT_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else   if (type.equals(Type.DOUBLE_TYPE)) {
    mv.visitMethodInsn(INVOKESTATIC,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
}"
80952,"private void load(Map<String,Map<String,Object>> map,File[] files){
  for (  File f : files) {
    if (f.isDirectory()) {
      loadFromDir(map,f);
    }
 else     if (f.isFile()) {
      map.putAll(buildMap(f));
    }
  }
}","private void load(Map<String,Map<String,Object>> map,File[] files){
  for (  File f : files) {
    if (f.isDirectory()) {
      loadFromDir(map,f);
    }
 else     if (f.isFile()) {
      Map<String,Map<String,Object>> fileMap=buildMap(f);
      if (null != fileMap && fileMap.size() > 0)       map.putAll(fileMap);
    }
  }
}"
80953,"protected NutIoc(ObjectMaker maker,IocLoader loader,IocContext context,String defaultScope){
  this.maker=maker;
  this.defaultScope=defaultScope;
  this.context=context;
  if (loader instanceof CachedIocLoader)   this.loader=loader;
 else   this.loader=CachedIocLoaderImpl.create(loader);
  vpms=new ArrayList<ValueProxyMaker>(5);
  addValueProxyMaker(new DefaultValueProxyMaker());
  mirrors=new DefaultMirrorFactory(this);
}","protected NutIoc(ObjectMaker maker,IocLoader loader,IocContext context,String defaultScope,MirrorFactory mirrors){
  this.maker=maker;
  this.defaultScope=defaultScope;
  this.context=context;
  if (loader instanceof CachedIocLoader)   this.loader=loader;
 else   this.loader=CachedIocLoaderImpl.create(loader);
  vpms=new ArrayList<ValueProxyMaker>(5);
  addValueProxyMaker(new DefaultValueProxyMaker());
  if (mirrors == null)   this.mirrors=new DefaultMirrorFactory(this);
 else   this.mirrors=mirrors;
}"
80954,"public NutFilePool(String homePath,int size){
  this.size=size;
  home=Files.findFile(homePath);
  if (null == home) {
    home=new File(homePath);
    try {
      Files.makeDir(home);
    }
 catch (    IOException e) {
      throw Lang.wrapThrow(e);
    }
  }
  if (!home.isDirectory())   throw Lang.makeThrow(""String_Node_Str"",homePath,this.getClass().getName());
  File last=home;
  String[] subs=null;
  while (last.isDirectory()) {
    subs=last.list(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        return name.matches(""String_Node_Str"");
      }
    }
);
    if (null != subs && subs.length > 0) {
      last=new File(last.getAbsolutePath() + ""String_Node_Str"" + subs[subs.length - 1]);
      if (last.isFile()) {
        cursor=Pools.getFileId(home,last);
        break;
      }
    }
 else {
      break;
    }
  }
}","public NutFilePool(String homePath,int size){
  this.size=size;
  try {
    home=Files.createIfNoExists(homePath);
  }
 catch (  IOException e) {
    throw Lang.wrapThrow(e);
  }
  if (null == home) {
    home=new File(homePath);
    Files.makeDir(home);
  }
  if (!home.isDirectory())   throw Lang.makeThrow(""String_Node_Str"",homePath,this.getClass().getName());
  File last=home;
  String[] subs=null;
  while (last.isDirectory()) {
    subs=last.list(new FilenameFilter(){
      public boolean accept(      File dir,      String name){
        return name.matches(""String_Node_Str"");
      }
    }
);
    if (null != subs && subs.length > 0) {
      last=new File(last.getAbsolutePath() + ""String_Node_Str"" + subs[subs.length - 1]);
      if (last.isFile()) {
        cursor=Pools.getFileId(home,last);
        break;
      }
    }
 else {
      break;
    }
  }
}"
80955,"/** 
 * 创建新目录，如果父目录不存在，也一并创建。可接受 null 参数
 * @param dir 目录对象
 * @return false，如果目录已存在。 true 创建成功
 * @throws IOException
 */
public static boolean makeDir(File dir) throws IOException {
  if (null == dir)   return false;
  if (dir.exists())   return false;
  return dir.mkdirs();
}","/** 
 * 创建新目录，如果父目录不存在，也一并创建。可接受 null 参数
 * @param dir 目录对象
 * @return false，如果目录已存在。 true 创建成功
 * @throws IOException
 */
public static boolean makeDir(File dir){
  if (null == dir)   return false;
  if (dir.exists())   return false;
  return dir.mkdirs();
}"
80956,"/** 
 * 从 CLASSPATH 下寻找一个文件
 * @param path 文件路径
 * @return 文件对象，如果不存在，则为 null
 */
public static File findFile(String path){
  return findFile(path,Files.class,Charset.defaultCharset().name());
}","/** 
 * 从 CLASSPATH 下寻找一个文件
 * @param path 文件路径
 * @return 文件对象，如果不存在，则为 null
 */
public static File findFile(String path){
  return findFile(path,Files.class.getClassLoader(),Charset.defaultCharset().name());
}"
80957,"/** 
 * 将文件改名
 * @param src 文件
 * @param newName 新名称
 * @return 改名是否成功
 */
public static boolean rename(File src,String newName){
  if (src == null || newName == null)   return false;
  if (src.exists()) {
    File newFile=new File(src.getParent() + ""String_Node_Str"" + newName);
    if (newFile.exists())     return false;
    try {
      Files.makeDir(newFile.getParentFile());
    }
 catch (    IOException e) {
      return false;
    }
    return src.renameTo(newFile);
  }
  return false;
}","/** 
 * 将文件改名
 * @param src 文件
 * @param newName 新名称
 * @return 改名是否成功
 */
public static boolean rename(File src,String newName){
  if (src == null || newName == null)   return false;
  if (src.exists()) {
    File newFile=new File(src.getParent() + ""String_Node_Str"" + newName);
    if (newFile.exists())     return false;
    Files.makeDir(newFile.getParentFile());
    return src.renameTo(newFile);
  }
  return false;
}"
80958,"public Context(){
  this.map=new HashMap<String,Object>();
}","public Context(Map<String,Object> map){
  this.map=map;
}"
80959,"public void load(Class<?> mainModule){
  try {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    IocBy ib=mainModule.getAnnotation(IocBy.class);
    SetupBy sb=mainModule.getAnnotation(SetupBy.class);
    Views vms=mainModule.getAnnotation(Views.class);
    Localization lc=mainModule.getAnnotation(Localization.class);
    if (null != ib) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",ib.type().getName());
      ioc=ib.type().newInstance().create(config,ib.args());
      config.getServletContext().setAttribute(Ioc.class.getName(),ioc);
    }
 else     if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    ArrayList<ViewMaker> makers=new ArrayList<ViewMaker>();
    makers.add(new DefaultViewMaker());
    if (null != vms)     for (    Class<? extends ViewMaker> type : vms.value())     makers.add(type.newInstance());
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",mainModule.getName());
    urls=new UrlMapImpl(ioc);
    urls.setOk(mainModule.getAnnotation(Ok.class));
    urls.setFail(mainModule.getAnnotation(Fail.class));
    urls.setAdaptBy(mainModule.getAnnotation(AdaptBy.class));
    urls.setFilters(mainModule.getAnnotation(Filters.class));
    urls.setEncoding(mainModule.getAnnotation(Encoding.class));
    urls.add(makers,mainModule);
    Modules modules=mainModule.getAnnotation(Modules.class);
    if (null != modules)     for (    Class<?> module : modules.value()) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",module.getName());
      urls.add(makers,module);
    }
    config.getServletContext().setAttribute(UrlMap.class.getName(),urls);
    if (null != lc) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",lc.value());
      msgss=Mirror.me(lc.type()).born(lc.value()).load();
    }
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (null != sb) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      Setup setup=sb.value().newInstance();
      config.getServletContext().setAttribute(Setup.class.getName(),setup);
      setup.init(config);
    }
  }
 catch (  InstantiationException e) {
    throw Lang.wrapThrow(e);
  }
catch (  IllegalAccessException e) {
    throw Lang.wrapThrow(e);
  }
}","public void load(Class<?> mainModule){
  try {
    if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    IocBy ib=mainModule.getAnnotation(IocBy.class);
    SetupBy sb=mainModule.getAnnotation(SetupBy.class);
    Views vms=mainModule.getAnnotation(Views.class);
    Localization lc=mainModule.getAnnotation(Localization.class);
    if (null != ib) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",ib.type().getName());
      ioc=ib.type().newInstance().create(config,ib.args());
      config.getServletContext().setAttribute(Ioc.class.getName(),ioc);
    }
 else     if (log.isDebugEnabled()) {
      log.debug(""String_Node_Str"");
    }
    ArrayList<ViewMaker> makers=new ArrayList<ViewMaker>();
    makers.add(new DefaultViewMaker());
    if (null != vms)     for (    Class<? extends ViewMaker> type : vms.value())     makers.add(type.newInstance());
    if (log.isDebugEnabled())     log.debugf(""String_Node_Str"",mainModule.getName());
    urls=new UrlMapImpl(ioc,context);
    urls.setOk(mainModule.getAnnotation(Ok.class));
    urls.setFail(mainModule.getAnnotation(Fail.class));
    urls.setAdaptBy(mainModule.getAnnotation(AdaptBy.class));
    urls.setFilters(mainModule.getAnnotation(Filters.class));
    urls.setEncoding(mainModule.getAnnotation(Encoding.class));
    urls.add(makers,mainModule);
    Modules modules=mainModule.getAnnotation(Modules.class);
    if (null != modules)     for (    Class<?> module : modules.value()) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",module.getName());
      urls.add(makers,module);
    }
    config.getServletContext().setAttribute(UrlMap.class.getName(),urls);
    if (null != lc) {
      if (log.isDebugEnabled())       log.debugf(""String_Node_Str"",lc.value());
      msgss=Mirror.me(lc.type()).born(lc.value()).load();
    }
 else     if (log.isDebugEnabled())     log.debug(""String_Node_Str"");
    if (null != sb) {
      if (log.isInfoEnabled())       log.info(""String_Node_Str"");
      Setup setup=sb.value().newInstance();
      config.getServletContext().setAttribute(Setup.class.getName(),setup);
      setup.init(config);
    }
  }
 catch (  InstantiationException e) {
    throw Lang.wrapThrow(e);
  }
catch (  IllegalAccessException e) {
    throw Lang.wrapThrow(e);
  }
}"
80960,"public DefaultLoading(ServletConfig config){
  this.config=config;
}","public DefaultLoading(ServletConfig config){
  this.config=config;
  context=new Context();
  saveRootPathToContext(config);
  if (log.isDebugEnabled()) {
    log.debugf(""String_Node_Str"",Json.toJson(context,JsonFormat.nice()));
  }
}"
80961,"public static void safeClose(ResultSet rs){
  if (null != rs)   try {
    if (!rs.isClosed())     rs.close();
  }
 catch (  Throwable e) {
  }
}","public static void safeClose(ResultSet rs){
  if (null != rs)   try {
    rs.close();
  }
 catch (  Throwable e) {
  }
}"
80962,"public void execute(Connection conn) throws DaoException {
  mergeCondition();
  updateCount=-1;
  try {
    if (sql.isSELECT()) {
      if (null != callback) {
        Pager pager=context.getPager();
        int rsType=null == pager ? ResultSet.TYPE_FORWARD_ONLY : pager.getResultSetType();
        PreparedStatement stat=null;
        ResultSet rs=null;
        try {
          String sqlStr=sql.toPreparedStatementString();
          stat=conn.prepareStatement(sqlStr,rsType,ResultSet.CONCUR_READ_ONLY);
          adapter.process(stat,sql,entity);
          rs=stat.executeQuery();
          context.setResult(callback.invoke(conn,rs,this));
        }
  finally {
          Daos.safeClose(stat,rs);
        }
      }
    }
 else     if (sql.isUPDATE() || sql.isINSERT() || sql.isDELETE()|| sql.isTRUNCATE()) {
      PreparedStatement stat=null;
      try {
        String sqlStr=sql.toPreparedStatementString();
        stat=conn.prepareStatement(sqlStr);
        adapter.process(stat,sql,entity);
        stat.execute();
        updateCount=stat.getUpdateCount();
        stat.close();
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        Daos.safeClose(stat,null);
      }
    }
 else {
      Statement stat=null;
      try {
        stat=conn.createStatement();
        stat.execute(sql.toString());
        stat.close();
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        Daos.safeClose(stat,null);
      }
    }
  }
 catch (  SQLException e) {
    throw new DaoException(format(""String_Node_Str"",sql.toString()),e);
  }
}","public void execute(Connection conn) throws DaoException {
  mergeCondition();
  updateCount=-1;
  boolean statIsClosed=false;
  try {
    if (sql.isSELECT()) {
      if (null != callback) {
        Pager pager=context.getPager();
        int rsType=null == pager ? ResultSet.TYPE_FORWARD_ONLY : pager.getResultSetType();
        PreparedStatement stat=null;
        ResultSet rs=null;
        try {
          String sqlStr=sql.toPreparedStatementString();
          stat=conn.prepareStatement(sqlStr,rsType,ResultSet.CONCUR_READ_ONLY);
          adapter.process(stat,sql,entity);
          rs=stat.executeQuery();
          context.setResult(callback.invoke(conn,rs,this));
        }
  finally {
          Daos.safeClose(stat,rs);
        }
      }
    }
 else     if (sql.isUPDATE() || sql.isINSERT() || sql.isDELETE()|| sql.isTRUNCATE()) {
      PreparedStatement stat=null;
      try {
        String sqlStr=sql.toPreparedStatementString();
        stat=conn.prepareStatement(sqlStr);
        adapter.process(stat,sql,entity);
        stat.execute();
        updateCount=stat.getUpdateCount();
        stat.close();
        statIsClosed=true;
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        if (!statIsClosed)         Daos.safeClose(stat);
      }
    }
 else {
      Statement stat=null;
      try {
        stat=conn.createStatement();
        stat.execute(sql.toString());
        stat.close();
        if (null != callback)         context.setResult(callback.invoke(conn,null,this));
      }
  finally {
        if (!statIsClosed)         Daos.safeClose(stat);
      }
    }
  }
 catch (  SQLException e) {
    throw new DaoException(format(""String_Node_Str"",sql.toString()),e);
  }
}"
80963,"public Link(Mirror<?> mirror,Field field,ManyMany mm,boolean fromName,boolean toName){
  this.ownField=field;
  this.type=LinkType.ManyMany;
  this.mapKeyField=""String_Node_Str"".equals(mm.key()) ? null : mm.key();
  this.targetClass=mm.target();
  this.from=mm.from();
  this.to=mm.to();
  this.relation=Relation.make(mm.relation());
  this.referField=lookupKeyField(mirror,fromName);
  this.targetField=lookupKeyField(Mirror.me(targetClass),toName);
  if (null == this.referField || null == this.targetField) {
    throw Lang.makeThrow(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",mirror.getType().getName(),field.getName(),targetClass.getName(),referField,targetField);
  }
}","@Deprecated public Link(Mirror<?> mirror,Field field,ManyMany mm,boolean fromName,boolean toName){
  this.ownField=field;
  this.type=LinkType.ManyMany;
  this.mapKeyField=""String_Node_Str"".equals(mm.key()) ? null : mm.key();
  this.targetClass=mm.target();
  this.from=mm.from();
  this.to=mm.to();
  this.relation=Relation.make(mm.relation());
  this.referField=lookupKeyField(mirror,fromName);
  this.targetField=lookupKeyField(Mirror.me(targetClass),toName);
  if (null == this.referField || null == this.targetField) {
    throw Lang.makeThrow(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",mirror.getType().getName(),field.getName(),targetClass.getName(),referField,targetField);
  }
}"
80964,"private Link evalLink(DatabaseMeta db,Connection conn,Mirror<?> mirror,Field field){
  try {
    One one=field.getAnnotation(One.class);
    if (null != one) {
      return new Link(mirror,field,one);
    }
 else {
      Many many=field.getAnnotation(Many.class);
      if (null != many) {
        return new Link(mirror,field,many);
      }
 else {
        ManyMany mm=field.getAnnotation(ManyMany.class);
        if (null != mm) {
          Statement stat=null;
          ResultSet rs=null;
          ResultSetMetaData rsmd=null;
          boolean fromName=false;
          boolean toName=false;
          try {
            stat=conn.createStatement();
            Segment tableName=new CharSegment(mm.relation());
            rs=stat.executeQuery(db.getResultSetMetaSql(TableName.render(tableName)));
            rsmd=rs.getMetaData();
            fromName=!Daos.isIntLikeColumn(rsmd,mm.from());
            toName=!Daos.isIntLikeColumn(rsmd,mm.to());
          }
 catch (          Exception e) {
            if (log.isWarnEnabled())             log.warnf(""String_Node_Str"" + ""String_Node_Str"",mm.relation(),mm.from(),mm.to());
          }
 finally {
            Daos.safeClose(stat,rs);
          }
          return new Link(mirror,field,mm,fromName,toName);
        }
      }
    }
  }
 catch (  Exception e) {
    throw Lang.makeThrow(""String_Node_Str"",field.getName(),mirror.getType().getName(),e.getMessage());
  }
  return null;
}","private Link evalLink(DatabaseMeta db,Connection conn,Mirror<?> mirror,Field field){
  try {
    One one=field.getAnnotation(One.class);
    if (null != one) {
      return Link.getLinkForOne(mirror,field,one.target(),one.field());
    }
 else {
      Many many=field.getAnnotation(Many.class);
      if (null != many) {
        return Link.getLinkForMany(mirror,field,many.target(),many.field(),many.key());
      }
 else {
        ManyMany mm=field.getAnnotation(ManyMany.class);
        if (null != mm) {
          Statement stat=null;
          ResultSet rs=null;
          ResultSetMetaData rsmd=null;
          boolean fromName=false;
          boolean toName=false;
          try {
            stat=conn.createStatement();
            Segment tableName=new CharSegment(mm.relation());
            rs=stat.executeQuery(db.getResultSetMetaSql(TableName.render(tableName)));
            rsmd=rs.getMetaData();
            fromName=!Daos.isIntLikeColumn(rsmd,mm.from());
            toName=!Daos.isIntLikeColumn(rsmd,mm.to());
          }
 catch (          Exception e) {
            if (log.isWarnEnabled())             log.warnf(""String_Node_Str"" + ""String_Node_Str"",mm.relation(),mm.from(),mm.to());
          }
 finally {
            Daos.safeClose(stat,rs);
          }
          return Link.getLinkForManyMany(mirror,field,mm.target(),mm.key(),mm.from(),mm.to(),mm.relation(),fromName,toName);
        }
      }
    }
  }
 catch (  Exception e) {
    throw Lang.makeThrow(""String_Node_Str"",field.getName(),mirror.getType().getName(),e.getMessage());
  }
  return null;
}"
80965,"public Entity(){
  fields=new HashMap<String,EntityField>();
  links=new LinkedList<Link>();
  _ln_cache=new HashMap<String,List<Link>>();
}","public Entity(){
  super();
  fields=new HashMap<String,EntityField>();
  links=new LinkedList<Link>();
  _ln_cache=new HashMap<String,List<Link>>();
}"
80966,"public EntityField(Entity<?> entity,Field field){
  if (null != entity && null != field) {
    this.mirror=Mirror.me(field.getType());
    this.entity=entity;
    this.field=field;
    try {
      getter=entity.getMirror().getGetter(field);
      getter.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
    try {
      setter=entity.getMirror().getSetter(field);
      setter.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
  }
}","public EntityField(Entity<?> entity,Field field){
  super();
  if (null != entity && null != field) {
    this.mirror=Mirror.me(field.getType());
    this.entity=entity;
    this.field=field;
    try {
      getter=entity.getMirror().getGetter(field);
      getter.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
    try {
      setter=entity.getMirror().getSetter(field);
      setter.setAccessible(true);
    }
 catch (    NoSuchMethodException e) {
    }
  }
}"
80967,"private void _insertSelf(Entity<?> entity,Object obj){
  if (null != entity.getBefores())   for (  FieldQuery nq : entity.getBefores())   nq.update(this,obj);
  Sql sql=sqlMaker.insert(entity,obj);
  execute(sql);
  if (null != entity.getAfters())   for (  FieldQuery nq : entity.getAfters())   nq.update(this,obj);
}","private void _insertSelf(Entity<?> entity,Object obj){
  runFieldQuery(entity.getBefores(),obj);
  execute(sqlMaker.insert(entity,obj));
  runFieldQuery(entity.getAfters(),obj);
}"
80968,"public <T>T fastInsert(T obj){
  if (Lang.length(obj) > 0) {
    Object first=Lang.first(obj);
    final Entity<?> entity=this.getEntity(first.getClass());
    Lang.each(obj,new Each<Object>(){
      public void invoke(      int i,      Object ele,      int length){
        execute(sqlMaker.insert(entity,ele));
      }
    }
);
  }
  return obj;
}","public <T>T fastInsert(T obj){
  if (Lang.length(obj) > 0) {
    Object first=Lang.first(obj);
    final Entity<?> entity=this.getEntity(first.getClass());
    Lang.each(obj,new Each<Object>(){
      public void invoke(      int i,      Object ele,      int length){
        runFieldQuery(entity.getBefores(),ele);
        execute(sqlMaker.insert(entity,ele));
      }
    }
);
  }
  return obj;
}"
80969,"/** 
 * 获取一个路径的绝对路径
 * @param path 路径
 * @param klassLoader 参考 ClassLoader
 * @param enc 路径编码方式
 * @return 绝对路径
 */
public static String absolute(String path,ClassLoader klassLoader,String enc){
  path=normalize(path,enc);
  if (null == path || path.length() == 0)   return null;
  File f=new File(path);
  if (!f.exists()) {
    URL url=klassLoader.getResource(path);
    if (null == url)     url=ClassLoader.getSystemResource(path);
    if (null != url) {
      return url.getPath();
    }
    return null;
  }
  return path;
}","/** 
 * 获取一个路径的绝对路径
 * @param path 路径
 * @param klassLoader 参考 ClassLoader
 * @param enc 路径编码方式
 * @return 绝对路径
 */
public static String absolute(String path,ClassLoader klassLoader,String enc){
  path=normalize(path,enc);
  if (null == path || path.length() == 0)   return null;
  File f=new File(path);
  if (!f.exists()) {
    URL url=klassLoader.getResource(path);
    if (null == url)     url=ClassLoader.getSystemResource(path);
    if (null != url)     return normalize(url.getPath(),enc);
    return null;
  }
  return path;
}"
80970,"public static Link getLinkForOne(Field field,Class<?> targetClass,Field referField,Field targetField) throws NoSuchFieldException {
  Link link=new Link(field,targetClass,LinkType.One,referField,targetField);
  return link;
}","/** 
 * 创建一条一对一的映射，将<b>本 POJO</b> 的一个字段通过本身的一个参考字段指向<b>目标POJO</b>的主键。 <p> <b style=color:red>这里需要注意的是：</b><br> 你的 <b>本 POJO</b>的参考字段类型要同<b>目标POJO</b>的主键要对应。即， <ul> <li><b>目标POJO</b>不可以是复合主键 <li>如果你的 <b>本 POJO</b>参考字段类型是整数，<b>目标POJO</b>的主键就必须是整数型主键。 <li>如果你的 <b>本 POJO</b>参考字段类型是字符串，<b>目标POJO</b>的主键就必须是字符型主键 </ul>
 * @param mirror <b>本 POJO</b>的类型
 * @param field 被映射的字段，它的类型应该是<b>目标POJO</b>的类型的接口或者超类
 * @param targetClass <b>目标POJO</b>的类型
 * @param referFld <b>本 POJO</b>的参考字段
 * @param targetPkFld <b>目标POJO</b>的主键
 * @return 映射对象
 */
public static Link getLinkForOne(Mirror<?> mirror,Field field,Class<?> targetClass,Field referFld,Field targetPkFld){
  Link link=new Link(field,targetClass);
  link.type=LinkType.One;
  link.referField=referFld;
  link.targetField=targetPkFld;
  return link;
}"
80971,"public static Link getLinkForMany(Field field,Class<?> targetClass,Field referField,Field targetField,String key) throws NoSuchFieldException {
  Link link=new Link(field,targetClass,LinkType.Many,referField,targetField);
  link.mapKeyField=""String_Node_Str"".equals(key) ? null : key;
  return link;
}","/** 
 * 创建一条一对多的映射，将<b>本 POJO</b> 的一个字段通过<b>目标POJO</b>一个参考字段指向本身的主键。 因此<b>本 POJO</b>的这个映射字段可以是一个集合或数组，因为可能有多个<b>目标POJO</b>指向自己 <p> <b style=color:red>这里需要注意的是：</b><br> 你的 <b>目标POJO</b>的参考字段类型要同<b>本POJO</b>的主键要对应。即， <ul> <li><b>本POJO</b>不可以是复合主键 <li>如果你的 <b>目标 POJO</b>参考字段类型是整数，<b>本POJO</b>的主键就必须是整数型主键。 <li>如果你的 <b>目标 POJO</b>参考字段类型是字符串，<b>本POJO</b>的主键就必须是字符型主键 <li>如果 referField 为 null，则将映射 <b>目标 POJO</b>的全部集合 -- 比较适用于枚举类型。 </ul>
 * @param mirror <b>本 POJO</b>的类型
 * @param field 被映射的字段，它的类型应该是<b>目标POJO</b>的类型的接口或者超类
 * @param targetClass <b>目标POJO</b>的类型
 * @param targetReferFld <b>本 POJO</b>主键
 * @param pkFld <b>目标POJO</b>的参考字段
 * @param key 如果被映射字段是个 Map， 你需要声明一下，<b>目标POJO</b>哪个字段是用来作为键值的。 默认的，赋值 null 即可
 * @return 映射对象
 */
public static Link getLinkForMany(Mirror<?> mirror,Field field,Class<?> targetClass,Field targetReferFld,Field pkFld,String key){
  Link link=new Link(field,targetClass);
  link.type=LinkType.Many;
  link.mapKeyField=Strings.isBlank(key) ? null : key;
  link.targetField=targetReferFld;
  link.referField=pkFld;
  return link;
}"
80972,"public static Link getLinkForManyMany(Mirror<?> mirror,Field field,Class<?> targetClass,String key,String from,String to,String relation,Field referField,Field targetField) throws NoSuchFieldException {
  Link link=new Link(field,targetClass,LinkType.ManyMany,referField,targetField);
  link.mapKeyField=""String_Node_Str"".equals(key) ? null : key;
  link.from=from;
  link.to=to;
  link.relation=Relation.make(relation);
  if (null == link.referField || null == link.targetField) {
    throw Lang.makeThrow(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",mirror.getType().getName(),field.getName(),targetClass.getName(),link.referField,link.targetField);
  }
  return link;
}","/** 
 * 创建一条多对多的映射，通过一个关联表的两个字段 <ul> <li>from - selfClass.PK <li>to - targetClass.PK </ul> 为当前字段关联一组<b>目标POJO</b> <p> <b style=color:red>这里需要注意的是：</b><br> 无论是 from 和 to，都要和相对应的对象的主键类型一直 <ul> <li><b>本POJO</b>和<b>目标POJO</b>都不可以是复合主键 <li>如果 from 字段类型是整数，<b>本POJO</b>的主键就必须是整数型主键。 <li>如果 to 字段类型是字符串，<b>本POJO</b>的主键就必须是字符型主键 </ul>
 * @param mirror <b>本 POJO</b>的类型
 * @param field 被映射的字段，它的类型应该是<b>目标POJO</b>的类型的接口或者超类
 * @param targetClass <b>目标POJO</b>的类型
 * @param selfPk <b>本 POJO</b>的主键
 * @param targetPk <b>目标 POJO</b>的主键
 * @param key 如果被映射字段是个 Map， 你需要声明一下，<b>目标POJO</b>哪个字段是用来作为键值的。 <br> 默认的，赋值 null 即可
 * @param relation 关联表名
 * @param from 在关联表中指向 <b>本 POJO</b>主键的字段名
 * @param to 在关联表中指向 <b>目标POJO</b>主键的字段名
 * @return 映射对象
 */
public static Link getLinkForManyMany(Mirror<?> mirror,Field field,Class<?> targetClass,Field selfPk,Field targetPk,String key,String relation,String from,String to){
  Link link=new Link(field,targetClass);
  link.type=LinkType.ManyMany;
  link.mapKeyField=""String_Node_Str"".equals(key) ? null : key;
  link.from=from;
  link.to=to;
  link.relation=Relation.make(relation);
  link.referField=selfPk;
  link.targetField=targetPk;
  if (null == link.referField || null == link.targetField) {
    throw Lang.makeThrow(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",mirror.getType().getName(),field.getName(),targetClass.getName(),link.referField,link.targetField);
  }
  return link;
}"
80973,"private Link(Field field,Class<?> targetClass,LinkType type,Field referField,Field targetField) throws NoSuchFieldException {
  this.ownField=field;
  this.targetClass=targetClass;
  this.type=type;
  this.referField=referField;
  this.targetField=targetField;
}","private Link(Field field,Class<?> targetClass){
  this.ownField=field;
  this.targetClass=targetClass;
}"
80974,"public void debug(Object message){
  debug(message,null);
}","public void debug(Object message){
  if (isDebugEnabled())   log(LEVEL_DEBUG,message,null);
}"
80975,"public void infof(String fmt,Object... args){
  info(String.format(fmt,args));
}","public void infof(String fmt,Object... args){
  if (isInfoEnabled())   log(LEVEL_INFO,String.format(fmt,args),null);
}"
80976,"public void tracef(String fmt,Object... args){
  trace(String.format(fmt,args));
}","public void tracef(String fmt,Object... args){
  if (isTraceEnabled())   log(LEVEL_TRACE,String.format(fmt,args),null);
}"
80977,"public void errorf(String fmt,Object... args){
  error(String.format(fmt,args));
}","public void errorf(String fmt,Object... args){
  if (isErrorEnabled())   log(LEVEL_ERROR,String.format(fmt,args),null);
}"
80978,"public void error(Object message){
  error(message,null);
}","public void error(Object message){
  if (isErrorEnabled())   log(LEVEL_ERROR,message,null);
}"
80979,"public void fatal(Object message){
  fatal(message,null);
}","public void fatal(Object message){
  if (isFatalEnabled())   log(LEVEL_FATAL,message,null);
}"
80980,"public void debugf(String fmt,Object... args){
  debug(String.format(fmt,args));
}","public void debugf(String fmt,Object... args){
  if (isDebugEnabled())   log(LEVEL_DEBUG,String.format(fmt,args),null);
}"
80981,"public void warn(Object message){
  warn(message,null);
}","public void warn(Object message){
  if (isWarnEnabled())   log(LEVEL_WARN,message,null);
}"
80982,"public void trace(Object message){
  trace(message,null);
}","public void trace(Object message){
  if (isTraceEnabled())   log(LEVEL_TRACE,message,null);
}"
80983,"public void fatalf(String fmt,Object... args){
  fatal(String.format(fmt,args));
}","public void fatalf(String fmt,Object... args){
  if (isFatalEnabled())   log(LEVEL_FATAL,String.format(fmt,args),null);
}"
80984,"public void warnf(String fmt,Object... args){
  warn(String.format(fmt,args));
}","public void warnf(String fmt,Object... args){
  if (isWarnEnabled())   log(LEVEL_WARN,String.format(fmt,args),null);
}"
80985,"public void info(Object message){
  info(message,null);
}","public void info(Object message){
  if (isInfoEnabled())   log(LEVEL_INFO,message,null);
}"
80986,"public void warn(Object message,Throwable t){
  if (isWarnEnabled())   log(WARN_LEVEL,message,t);
}","public void warn(Object message,Throwable t){
  if (isWarnEnabled())   log(LEVEL_WARN,message,t);
}"
80987,"public void trace(Object message,Throwable t){
  if (isTraceEnabled())   log(TRACE_LEVEL,message,t);
}","public void trace(Object message,Throwable t){
  if (isTraceEnabled())   log(LEVEL_TRACE,message,t);
}"
80988,"public void debug(Object message,Throwable t){
  if (isDebugEnabled())   log(DEBUG_LEVEL,message,t);
}","public void debug(Object message,Throwable t){
  if (isDebugEnabled())   log(LEVEL_DEBUG,message,t);
}"
80989,"public JdkLogger(String className){
  jdkLogger=Logger.getLogger(className);
  isFatalEnabled=jdkLogger.isLoggable(FATAL_LEVEL);
  isErrorEnabled=jdkLogger.isLoggable(ERROR_LEVEL);
  isWarnEnabled=jdkLogger.isLoggable(WARN_LEVEL);
  isInfoEnabled=jdkLogger.isLoggable(INFO_LEVEL);
  isDebugEnabled=jdkLogger.isLoggable(DEBUG_LEVEL);
  isTraceEnabled=jdkLogger.isLoggable(TRACE_LEVEL);
}","public JdkLogger(String className){
  jdkLogger=Logger.getLogger(className);
  isFatalEnabled=jdkLogger.isLoggable(Level.SEVERE);
  isErrorEnabled=jdkLogger.isLoggable(Level.SEVERE);
  isWarnEnabled=jdkLogger.isLoggable(Level.WARNING);
  isInfoEnabled=jdkLogger.isLoggable(Level.INFO);
  isDebugEnabled=jdkLogger.isLoggable(Level.FINE);
  isTraceEnabled=jdkLogger.isLoggable(Level.FINEST);
}"
80990,"public void log(Level level,Object message,Throwable t){
  Throwable dummyException=new Throwable();
  StackTraceElement locations[]=dummyException.getStackTrace();
  String cname=""String_Node_Str"";
  String method=""String_Node_Str"";
  if (locations != null && locations.length > 2) {
    StackTraceElement caller=locations[2];
    cname=caller.getClassName();
    method=caller.getMethodName();
  }
  if (t == null)   jdkLogger.logp(level,cname,method,String.valueOf(message));
 else   jdkLogger.logp(level,cname,method,String.valueOf(message),t);
}","protected void log(int level_int,Object message,Throwable t){
  Level level=null;
switch (level_int) {
case LEVEL_FATAL:
    level=Level.SEVERE;
  break;
case LEVEL_ERROR:
level=Level.SEVERE;
break;
case LEVEL_WARN:
level=Level.WARNING;
break;
case LEVEL_INFO:
level=Level.INFO;
break;
case LEVEL_DEBUG:
level=Level.FINE;
break;
case LEVEL_TRACE:
level=Level.FINEST;
break;
default :
return;
}
Throwable dummyException=new Throwable();
StackTraceElement locations[]=dummyException.getStackTrace();
String cname=""String_Node_Str"";
String method=""String_Node_Str"";
if (locations != null && locations.length > 1) {
StackTraceElement caller=locations[2];
cname=caller.getClassName();
method=caller.getMethodName();
}
if (t == null) jdkLogger.logp(level,cname,method,String.valueOf(message));
 else jdkLogger.logp(level,cname,method,String.valueOf(message),t);
}"
80991,"public void error(Object message,Throwable t){
  if (isErrorEnabled())   log(ERROR_LEVEL,message,t);
}","public void error(Object message,Throwable t){
  if (isErrorEnabled())   log(LEVEL_ERROR,message,t);
}"
80992,"public void fatal(Object message,Throwable t){
  if (isFatalEnabled())   log(FATAL_LEVEL,message,t);
}","public void fatal(Object message,Throwable t){
  if (isFatalEnabled())   log(LEVEL_FATAL,message,t);
}"
80993,"public void info(Object message,Throwable t){
  if (isInfoEnabled())   log(INFO_LEVEL,message,t);
}","public void info(Object message,Throwable t){
  if (isInfoEnabled())   log(LEVEL_INFO,message,t);
}"
80994,"public void debug(Object message,Throwable t){
  if (isDebugEnabled())   logMessage(Level.DEBUG,message,t);
}","public void debug(Object message,Throwable t){
  if (isDebugEnabled())   logger.log(SELF_FQCN,Level.DEBUG,message,t);
}"
80995,"Log4JLogger(String className){
  logger=LogManager.getLogger(className);
  loadLevel();
}","Log4JLogger(String className){
  logger=LogManager.getLogger(className);
  isFatalEnabled=logger.isEnabledFor(Level.FATAL);
  isErrorEnabled=logger.isEnabledFor(Level.ERROR);
  isWarnEnabled=logger.isEnabledFor(Level.WARN);
  isInfoEnabled=logger.isEnabledFor(Level.INFO);
  isDebugEnabled=logger.isEnabledFor(Level.DEBUG);
  if (hasTrace)   isTraceEnabled=logger.isEnabledFor(Level.TRACE);
}"
80996,"public void error(Object message,Throwable t){
  if (isErrorEnabled())   logMessage(Level.ERROR,message,t);
}","public void error(Object message,Throwable t){
  if (isErrorEnabled())   logger.log(SELF_FQCN,Level.ERROR,message,t);
}"
80997,"public void fatal(Object message,Throwable t){
  if (isFatalEnabled())   logMessage(Level.FATAL,message,t);
}","public void fatal(Object message,Throwable t){
  if (isFatalEnabled())   logger.log(SELF_FQCN,Level.FATAL,message,t);
}"
80998,"public void warn(Object message,Throwable t){
  if (isWarnEnabled())   logMessage(Level.WARN,message,t);
}","public void warn(Object message,Throwable t){
  if (isWarnEnabled())   logger.log(SELF_FQCN,Level.WARN,message,t);
}"
80999,"public void trace(Object message,Throwable t){
  if (isTraceEnabled())   logMessage(Level.TRACE,message,t);
 else   if (!hasTrace)   debug(message,t);
}","public void trace(Object message,Throwable t){
  if (isTraceEnabled())   logger.log(SELF_FQCN,Level.TRACE,message,t);
 else   if ((!hasTrace) && isDebugEnabled())   logger.log(SELF_FQCN,Level.DEBUG,message,t);
}"
81000,"public void info(Object message,Throwable t){
  if (isInfoEnabled())   logMessage(Level.INFO,message,t);
}","public void info(Object message,Throwable t){
  if (isInfoEnabled())   logger.log(SELF_FQCN,Level.INFO,message,t);
}"
